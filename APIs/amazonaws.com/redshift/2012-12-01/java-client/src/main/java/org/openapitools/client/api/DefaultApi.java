/*
 * Amazon Redshift
 * <fullname>Amazon Redshift</fullname> <p> <b>Overview</b> </p> <p>This is an interface reference for Amazon Redshift. It contains documentation for one of the programming or command line interfaces you can use to manage Amazon Redshift clusters. Note that Amazon Redshift is asynchronous, which means that some interfaces may require techniques, such as polling or asynchronous callback handlers, to determine when a command has been applied. In this reference, the parameter descriptions indicate whether a change is applied immediately, on the next instance reboot, or during the next maintenance window. For a summary of the Amazon Redshift cluster management interfaces, go to <a href=\"https://docs.aws.amazon.com/redshift/latest/mgmt/using-aws-sdk.html\">Using the Amazon Redshift Management Interfaces</a>.</p> <p>Amazon Redshift manages all the work of setting up, operating, and scaling a data warehouse: provisioning capacity, monitoring and backing up the cluster, and applying patches and upgrades to the Amazon Redshift engine. You can focus on using your data to acquire new insights for your business and customers.</p> <p>If you are a first-time user of Amazon Redshift, we recommend that you begin by reading the <a href=\"https://docs.aws.amazon.com/redshift/latest/gsg/getting-started.html\">Amazon Redshift Getting Started Guide</a>.</p> <p>If you are a database developer, the <a href=\"https://docs.aws.amazon.com/redshift/latest/dg/welcome.html\">Amazon Redshift Database Developer Guide</a> explains how to design, build, query, and maintain the databases that make up your data warehouse. </p>
 *
 * The version of the OpenAPI document: 2012-12-01
 * Contact: mike.ralphson@gmail.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package org.openapitools.client.api;

import org.openapitools.client.ApiCallback;
import org.openapitools.client.ApiClient;
import org.openapitools.client.ApiException;
import org.openapitools.client.ApiResponse;
import org.openapitools.client.Configuration;
import org.openapitools.client.Pair;
import org.openapitools.client.ProgressRequestBody;
import org.openapitools.client.ProgressResponseBody;

import com.google.gson.reflect.TypeToken;

import java.io.IOException;


import org.openapitools.client.model.AcceptReservedNodeExchangeInputMessage;
import org.openapitools.client.model.AcceptReservedNodeExchangeOutputMessage;
import org.openapitools.client.model.AccountAttributeList;
import org.openapitools.client.model.AssociateDataShareConsumerMessage;
import org.openapitools.client.model.AuthorizeClusterSecurityGroupIngressMessage;
import org.openapitools.client.model.AuthorizeClusterSecurityGroupIngressResult;
import org.openapitools.client.model.AuthorizeDataShareMessage;
import org.openapitools.client.model.AuthorizeEndpointAccessMessage;
import org.openapitools.client.model.AuthorizeSnapshotAccessMessage;
import org.openapitools.client.model.AuthorizeSnapshotAccessResult;
import org.openapitools.client.model.BatchDeleteClusterSnapshotsRequest;
import org.openapitools.client.model.BatchDeleteClusterSnapshotsResult;
import org.openapitools.client.model.BatchModifyClusterSnapshotsMessage;
import org.openapitools.client.model.BatchModifyClusterSnapshotsOutputMessage;
import org.openapitools.client.model.CancelResizeMessage;
import org.openapitools.client.model.ClusterCredentials;
import org.openapitools.client.model.ClusterDbRevisionsMessage;
import org.openapitools.client.model.ClusterExtendedCredentials;
import org.openapitools.client.model.ClusterParameterGroupDetails;
import org.openapitools.client.model.ClusterParameterGroupNameMessage;
import org.openapitools.client.model.ClusterParameterGroupsMessage;
import org.openapitools.client.model.ClusterSecurityGroupMessage;
import org.openapitools.client.model.ClusterSubnetGroupMessage;
import org.openapitools.client.model.ClusterVersionsMessage;
import org.openapitools.client.model.ClustersMessage;
import org.openapitools.client.model.CopyClusterSnapshotMessage;
import org.openapitools.client.model.CopyClusterSnapshotResult;
import org.openapitools.client.model.CreateAuthenticationProfileMessage;
import org.openapitools.client.model.CreateAuthenticationProfileResult;
import org.openapitools.client.model.CreateClusterMessage;
import org.openapitools.client.model.CreateClusterParameterGroupMessage;
import org.openapitools.client.model.CreateClusterParameterGroupResult;
import org.openapitools.client.model.CreateClusterResult;
import org.openapitools.client.model.CreateClusterSecurityGroupMessage;
import org.openapitools.client.model.CreateClusterSecurityGroupResult;
import org.openapitools.client.model.CreateClusterSnapshotMessage;
import org.openapitools.client.model.CreateClusterSnapshotResult;
import org.openapitools.client.model.CreateClusterSubnetGroupMessage;
import org.openapitools.client.model.CreateClusterSubnetGroupResult;
import org.openapitools.client.model.CreateCustomDomainAssociationMessage;
import org.openapitools.client.model.CreateCustomDomainAssociationResult;
import org.openapitools.client.model.CreateEndpointAccessMessage;
import org.openapitools.client.model.CreateEventSubscriptionMessage;
import org.openapitools.client.model.CreateEventSubscriptionResult;
import org.openapitools.client.model.CreateHsmClientCertificateMessage;
import org.openapitools.client.model.CreateHsmClientCertificateResult;
import org.openapitools.client.model.CreateHsmConfigurationMessage;
import org.openapitools.client.model.CreateHsmConfigurationResult;
import org.openapitools.client.model.CreateScheduledActionMessage;
import org.openapitools.client.model.CreateSnapshotCopyGrantMessage;
import org.openapitools.client.model.CreateSnapshotCopyGrantResult;
import org.openapitools.client.model.CreateSnapshotScheduleMessage;
import org.openapitools.client.model.CreateTagsMessage;
import org.openapitools.client.model.CreateUsageLimitMessage;
import org.openapitools.client.model.CustomDomainAssociationsMessage;
import org.openapitools.client.model.CustomerStorageMessage;
import org.openapitools.client.model.DataShare;
import org.openapitools.client.model.DeauthorizeDataShareMessage;
import org.openapitools.client.model.DeleteAuthenticationProfileMessage;
import org.openapitools.client.model.DeleteAuthenticationProfileResult;
import org.openapitools.client.model.DeleteClusterMessage;
import org.openapitools.client.model.DeleteClusterParameterGroupMessage;
import org.openapitools.client.model.DeleteClusterResult;
import org.openapitools.client.model.DeleteClusterSecurityGroupMessage;
import org.openapitools.client.model.DeleteClusterSnapshotMessage;
import org.openapitools.client.model.DeleteClusterSnapshotResult;
import org.openapitools.client.model.DeleteClusterSubnetGroupMessage;
import org.openapitools.client.model.DeleteCustomDomainAssociationMessage;
import org.openapitools.client.model.DeleteEndpointAccessMessage;
import org.openapitools.client.model.DeleteEventSubscriptionMessage;
import org.openapitools.client.model.DeleteHsmClientCertificateMessage;
import org.openapitools.client.model.DeleteHsmConfigurationMessage;
import org.openapitools.client.model.DeleteScheduledActionMessage;
import org.openapitools.client.model.DeleteSnapshotCopyGrantMessage;
import org.openapitools.client.model.DeleteSnapshotScheduleMessage;
import org.openapitools.client.model.DeleteTagsMessage;
import org.openapitools.client.model.DeleteUsageLimitMessage;
import org.openapitools.client.model.DescribeAccountAttributesMessage;
import org.openapitools.client.model.DescribeAuthenticationProfilesMessage;
import org.openapitools.client.model.DescribeAuthenticationProfilesResult;
import org.openapitools.client.model.DescribeClusterDbRevisionsMessage;
import org.openapitools.client.model.DescribeClusterParameterGroupsMessage;
import org.openapitools.client.model.DescribeClusterParametersMessage;
import org.openapitools.client.model.DescribeClusterSecurityGroupsMessage;
import org.openapitools.client.model.DescribeClusterSnapshotsMessage;
import org.openapitools.client.model.DescribeClusterSubnetGroupsMessage;
import org.openapitools.client.model.DescribeClusterTracksMessage;
import org.openapitools.client.model.DescribeClusterVersionsMessage;
import org.openapitools.client.model.DescribeClustersMessage;
import org.openapitools.client.model.DescribeCustomDomainAssociationsMessage;
import org.openapitools.client.model.DescribeDataSharesForConsumerMessage;
import org.openapitools.client.model.DescribeDataSharesForConsumerResult;
import org.openapitools.client.model.DescribeDataSharesForProducerMessage;
import org.openapitools.client.model.DescribeDataSharesForProducerResult;
import org.openapitools.client.model.DescribeDataSharesMessage;
import org.openapitools.client.model.DescribeDataSharesResult;
import org.openapitools.client.model.DescribeDefaultClusterParametersMessage;
import org.openapitools.client.model.DescribeDefaultClusterParametersResult;
import org.openapitools.client.model.DescribeEndpointAccessMessage;
import org.openapitools.client.model.DescribeEndpointAuthorizationMessage;
import org.openapitools.client.model.DescribeEventCategoriesMessage;
import org.openapitools.client.model.DescribeEventSubscriptionsMessage;
import org.openapitools.client.model.DescribeEventsMessage;
import org.openapitools.client.model.DescribeHsmClientCertificatesMessage;
import org.openapitools.client.model.DescribeHsmConfigurationsMessage;
import org.openapitools.client.model.DescribeLoggingStatusMessage;
import org.openapitools.client.model.DescribeNodeConfigurationOptionsMessage;
import org.openapitools.client.model.DescribeOrderableClusterOptionsMessage;
import org.openapitools.client.model.DescribePartnersInputMessage;
import org.openapitools.client.model.DescribePartnersOutputMessage;
import org.openapitools.client.model.DescribeReservedNodeExchangeStatusInputMessage;
import org.openapitools.client.model.DescribeReservedNodeExchangeStatusOutputMessage;
import org.openapitools.client.model.DescribeReservedNodeOfferingsMessage;
import org.openapitools.client.model.DescribeReservedNodesMessage;
import org.openapitools.client.model.DescribeResizeMessage;
import org.openapitools.client.model.DescribeScheduledActionsMessage;
import org.openapitools.client.model.DescribeSnapshotCopyGrantsMessage;
import org.openapitools.client.model.DescribeSnapshotSchedulesMessage;
import org.openapitools.client.model.DescribeSnapshotSchedulesOutputMessage;
import org.openapitools.client.model.DescribeTableRestoreStatusMessage;
import org.openapitools.client.model.DescribeTagsMessage;
import org.openapitools.client.model.DescribeUsageLimitsMessage;
import org.openapitools.client.model.DisableLoggingMessage;
import org.openapitools.client.model.DisableSnapshotCopyMessage;
import org.openapitools.client.model.DisableSnapshotCopyResult;
import org.openapitools.client.model.DisassociateDataShareConsumerMessage;
import org.openapitools.client.model.EnableLoggingMessage;
import org.openapitools.client.model.EnableSnapshotCopyMessage;
import org.openapitools.client.model.EnableSnapshotCopyResult;
import org.openapitools.client.model.EndpointAccess;
import org.openapitools.client.model.EndpointAccessList;
import org.openapitools.client.model.EndpointAuthorization;
import org.openapitools.client.model.EndpointAuthorizationList;
import org.openapitools.client.model.EventCategoriesMessage;
import org.openapitools.client.model.EventSubscriptionsMessage;
import org.openapitools.client.model.EventsMessage;
import org.openapitools.client.model.GETBatchDeleteClusterSnapshotsIdentifiersParameterInner;
import org.openapitools.client.model.GETCreateClusterTagsParameterInner;
import org.openapitools.client.model.GETCreateScheduledActionTargetActionParameter;
import org.openapitools.client.model.GETDescribeClusterSnapshotsSortingEntitiesParameterInner;
import org.openapitools.client.model.GETDescribeNodeConfigurationOptionsFilterParameterInner;
import org.openapitools.client.model.GETDescribeScheduledActionsFiltersParameterInner;
import org.openapitools.client.model.GETModifyClusterParameterGroupParametersParameterInner;
import org.openapitools.client.model.GetClusterCredentialsMessage;
import org.openapitools.client.model.GetClusterCredentialsWithIAMMessage;
import org.openapitools.client.model.GetReservedNodeExchangeConfigurationOptionsInputMessage;
import org.openapitools.client.model.GetReservedNodeExchangeConfigurationOptionsOutputMessage;
import org.openapitools.client.model.GetReservedNodeExchangeOfferingsInputMessage;
import org.openapitools.client.model.GetReservedNodeExchangeOfferingsOutputMessage;
import org.openapitools.client.model.HsmClientCertificateMessage;
import org.openapitools.client.model.HsmConfigurationMessage;
import org.openapitools.client.model.LoggingStatus;
import org.openapitools.client.model.ModifyAquaInputMessage;
import org.openapitools.client.model.ModifyAquaOutputMessage;
import org.openapitools.client.model.ModifyAuthenticationProfileMessage;
import org.openapitools.client.model.ModifyAuthenticationProfileResult;
import org.openapitools.client.model.ModifyClusterDbRevisionMessage;
import org.openapitools.client.model.ModifyClusterDbRevisionResult;
import org.openapitools.client.model.ModifyClusterIamRolesMessage;
import org.openapitools.client.model.ModifyClusterIamRolesResult;
import org.openapitools.client.model.ModifyClusterMaintenanceMessage;
import org.openapitools.client.model.ModifyClusterMaintenanceResult;
import org.openapitools.client.model.ModifyClusterMessage;
import org.openapitools.client.model.ModifyClusterParameterGroupMessage;
import org.openapitools.client.model.ModifyClusterResult;
import org.openapitools.client.model.ModifyClusterSnapshotMessage;
import org.openapitools.client.model.ModifyClusterSnapshotResult;
import org.openapitools.client.model.ModifyClusterSnapshotScheduleMessage;
import org.openapitools.client.model.ModifyClusterSubnetGroupMessage;
import org.openapitools.client.model.ModifyClusterSubnetGroupResult;
import org.openapitools.client.model.ModifyCustomDomainAssociationMessage;
import org.openapitools.client.model.ModifyCustomDomainAssociationResult;
import org.openapitools.client.model.ModifyEndpointAccessMessage;
import org.openapitools.client.model.ModifyEventSubscriptionMessage;
import org.openapitools.client.model.ModifyEventSubscriptionResult;
import org.openapitools.client.model.ModifyScheduledActionMessage;
import org.openapitools.client.model.ModifySnapshotCopyRetentionPeriodMessage;
import org.openapitools.client.model.ModifySnapshotCopyRetentionPeriodResult;
import org.openapitools.client.model.ModifySnapshotScheduleMessage;
import org.openapitools.client.model.ModifyUsageLimitMessage;
import org.openapitools.client.model.NodeConfigurationOptionsMessage;
import java.time.OffsetDateTime;
import org.openapitools.client.model.OrderableClusterOptionsMessage;
import org.openapitools.client.model.PartnerIntegrationInputMessage;
import org.openapitools.client.model.PartnerIntegrationOutputMessage;
import org.openapitools.client.model.PauseClusterMessage;
import org.openapitools.client.model.PauseClusterResult;
import org.openapitools.client.model.PurchaseReservedNodeOfferingMessage;
import org.openapitools.client.model.PurchaseReservedNodeOfferingResult;
import org.openapitools.client.model.RebootClusterMessage;
import org.openapitools.client.model.RebootClusterResult;
import org.openapitools.client.model.RejectDataShareMessage;
import org.openapitools.client.model.ReservedNodeOfferingsMessage;
import org.openapitools.client.model.ReservedNodesMessage;
import org.openapitools.client.model.ResetClusterParameterGroupMessage;
import org.openapitools.client.model.ResizeClusterMessage;
import org.openapitools.client.model.ResizeClusterResult;
import org.openapitools.client.model.ResizeProgressMessage;
import org.openapitools.client.model.RestoreFromClusterSnapshotMessage;
import org.openapitools.client.model.RestoreFromClusterSnapshotResult;
import org.openapitools.client.model.RestoreTableFromClusterSnapshotMessage;
import org.openapitools.client.model.RestoreTableFromClusterSnapshotResult;
import org.openapitools.client.model.ResumeClusterMessage;
import org.openapitools.client.model.ResumeClusterResult;
import org.openapitools.client.model.RevokeClusterSecurityGroupIngressMessage;
import org.openapitools.client.model.RevokeClusterSecurityGroupIngressResult;
import org.openapitools.client.model.RevokeEndpointAccessMessage;
import org.openapitools.client.model.RevokeSnapshotAccessMessage;
import org.openapitools.client.model.RevokeSnapshotAccessResult;
import org.openapitools.client.model.RotateEncryptionKeyMessage;
import org.openapitools.client.model.RotateEncryptionKeyResult;
import org.openapitools.client.model.ScheduledAction;
import org.openapitools.client.model.ScheduledActionsMessage;
import org.openapitools.client.model.SnapshotCopyGrantMessage;
import org.openapitools.client.model.SnapshotMessage;
import org.openapitools.client.model.SnapshotSchedule;
import org.openapitools.client.model.TableRestoreStatusMessage;
import org.openapitools.client.model.TaggedResourceListMessage;
import org.openapitools.client.model.TrackListMessage;
import org.openapitools.client.model.UpdatePartnerStatusInputMessage;
import org.openapitools.client.model.UsageLimit;
import org.openapitools.client.model.UsageLimitList;

import java.lang.reflect.Type;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

public class DefaultApi {
    private ApiClient localVarApiClient;
    private int localHostIndex;
    private String localCustomBaseUrl;

    public DefaultApi() {
        this(Configuration.getDefaultApiClient());
    }

    public DefaultApi(ApiClient apiClient) {
        this.localVarApiClient = apiClient;
    }

    public ApiClient getApiClient() {
        return localVarApiClient;
    }

    public void setApiClient(ApiClient apiClient) {
        this.localVarApiClient = apiClient;
    }

    public int getHostIndex() {
        return localHostIndex;
    }

    public void setHostIndex(int hostIndex) {
        this.localHostIndex = hostIndex;
    }

    public String getCustomBaseUrl() {
        return localCustomBaseUrl;
    }

    public void setCustomBaseUrl(String customBaseUrl) {
        this.localCustomBaseUrl = customBaseUrl;
    }

    /**
     * Build call for gETAcceptReservedNodeExchange
     * @param reservedNodeId A string representing the node identifier of the DC1 Reserved Node to be exchanged. (required)
     * @param targetReservedNodeOfferingId The unique identifier of the DC2 Reserved Node offering to be used for the exchange. You can obtain the value for the parameter by calling &lt;a&gt;GetReservedNodeExchangeOfferings&lt;/a&gt;  (required)
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> ReservedNodeNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> InvalidReservedNodeStateFault </td><td>  -  </td></tr>
        <tr><td> 482 </td><td> ReservedNodeAlreadyMigratedFault </td><td>  -  </td></tr>
        <tr><td> 483 </td><td> ReservedNodeOfferingNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 484 </td><td> UnsupportedOperationFault </td><td>  -  </td></tr>
        <tr><td> 485 </td><td> DependentServiceUnavailableFault </td><td>  -  </td></tr>
        <tr><td> 486 </td><td> ReservedNodeAlreadyExistsFault </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call gETAcceptReservedNodeExchangeCall(String reservedNodeId, String targetReservedNodeOfferingId, String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/#Action=AcceptReservedNodeExchange";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (reservedNodeId != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("ReservedNodeId", reservedNodeId));
        }

        if (targetReservedNodeOfferingId != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("TargetReservedNodeOfferingId", targetReservedNodeOfferingId));
        }

        if (action != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("Action", action));
        }

        if (version != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("Version", version));
        }

        if (xAmzContentSha256 != null) {
            localVarHeaderParams.put("X-Amz-Content-Sha256", localVarApiClient.parameterToString(xAmzContentSha256));
        }

        if (xAmzDate != null) {
            localVarHeaderParams.put("X-Amz-Date", localVarApiClient.parameterToString(xAmzDate));
        }

        if (xAmzAlgorithm != null) {
            localVarHeaderParams.put("X-Amz-Algorithm", localVarApiClient.parameterToString(xAmzAlgorithm));
        }

        if (xAmzCredential != null) {
            localVarHeaderParams.put("X-Amz-Credential", localVarApiClient.parameterToString(xAmzCredential));
        }

        if (xAmzSecurityToken != null) {
            localVarHeaderParams.put("X-Amz-Security-Token", localVarApiClient.parameterToString(xAmzSecurityToken));
        }

        if (xAmzSignature != null) {
            localVarHeaderParams.put("X-Amz-Signature", localVarApiClient.parameterToString(xAmzSignature));
        }

        if (xAmzSignedHeaders != null) {
            localVarHeaderParams.put("X-Amz-SignedHeaders", localVarApiClient.parameterToString(xAmzSignedHeaders));
        }

        final String[] localVarAccepts = {
            "text/xml"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "hmac" };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call gETAcceptReservedNodeExchangeValidateBeforeCall(String reservedNodeId, String targetReservedNodeOfferingId, String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'reservedNodeId' is set
        if (reservedNodeId == null) {
            throw new ApiException("Missing the required parameter 'reservedNodeId' when calling gETAcceptReservedNodeExchange(Async)");
        }

        // verify the required parameter 'targetReservedNodeOfferingId' is set
        if (targetReservedNodeOfferingId == null) {
            throw new ApiException("Missing the required parameter 'targetReservedNodeOfferingId' when calling gETAcceptReservedNodeExchange(Async)");
        }

        // verify the required parameter 'action' is set
        if (action == null) {
            throw new ApiException("Missing the required parameter 'action' when calling gETAcceptReservedNodeExchange(Async)");
        }

        // verify the required parameter 'version' is set
        if (version == null) {
            throw new ApiException("Missing the required parameter 'version' when calling gETAcceptReservedNodeExchange(Async)");
        }

        return gETAcceptReservedNodeExchangeCall(reservedNodeId, targetReservedNodeOfferingId, action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, _callback);

    }

    /**
     * 
     * Exchanges a DC1 Reserved Node for a DC2 Reserved Node with no changes to the configuration (term, payment type, or number of nodes) and no additional costs. 
     * @param reservedNodeId A string representing the node identifier of the DC1 Reserved Node to be exchanged. (required)
     * @param targetReservedNodeOfferingId The unique identifier of the DC2 Reserved Node offering to be used for the exchange. You can obtain the value for the parameter by calling &lt;a&gt;GetReservedNodeExchangeOfferings&lt;/a&gt;  (required)
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @return AcceptReservedNodeExchangeOutputMessage
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> ReservedNodeNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> InvalidReservedNodeStateFault </td><td>  -  </td></tr>
        <tr><td> 482 </td><td> ReservedNodeAlreadyMigratedFault </td><td>  -  </td></tr>
        <tr><td> 483 </td><td> ReservedNodeOfferingNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 484 </td><td> UnsupportedOperationFault </td><td>  -  </td></tr>
        <tr><td> 485 </td><td> DependentServiceUnavailableFault </td><td>  -  </td></tr>
        <tr><td> 486 </td><td> ReservedNodeAlreadyExistsFault </td><td>  -  </td></tr>
     </table>
     */
    public AcceptReservedNodeExchangeOutputMessage gETAcceptReservedNodeExchange(String reservedNodeId, String targetReservedNodeOfferingId, String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders) throws ApiException {
        ApiResponse<AcceptReservedNodeExchangeOutputMessage> localVarResp = gETAcceptReservedNodeExchangeWithHttpInfo(reservedNodeId, targetReservedNodeOfferingId, action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders);
        return localVarResp.getData();
    }

    /**
     * 
     * Exchanges a DC1 Reserved Node for a DC2 Reserved Node with no changes to the configuration (term, payment type, or number of nodes) and no additional costs. 
     * @param reservedNodeId A string representing the node identifier of the DC1 Reserved Node to be exchanged. (required)
     * @param targetReservedNodeOfferingId The unique identifier of the DC2 Reserved Node offering to be used for the exchange. You can obtain the value for the parameter by calling &lt;a&gt;GetReservedNodeExchangeOfferings&lt;/a&gt;  (required)
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @return ApiResponse&lt;AcceptReservedNodeExchangeOutputMessage&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> ReservedNodeNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> InvalidReservedNodeStateFault </td><td>  -  </td></tr>
        <tr><td> 482 </td><td> ReservedNodeAlreadyMigratedFault </td><td>  -  </td></tr>
        <tr><td> 483 </td><td> ReservedNodeOfferingNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 484 </td><td> UnsupportedOperationFault </td><td>  -  </td></tr>
        <tr><td> 485 </td><td> DependentServiceUnavailableFault </td><td>  -  </td></tr>
        <tr><td> 486 </td><td> ReservedNodeAlreadyExistsFault </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<AcceptReservedNodeExchangeOutputMessage> gETAcceptReservedNodeExchangeWithHttpInfo(String reservedNodeId, String targetReservedNodeOfferingId, String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders) throws ApiException {
        okhttp3.Call localVarCall = gETAcceptReservedNodeExchangeValidateBeforeCall(reservedNodeId, targetReservedNodeOfferingId, action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, null);
        Type localVarReturnType = new TypeToken<AcceptReservedNodeExchangeOutputMessage>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     *  (asynchronously)
     * Exchanges a DC1 Reserved Node for a DC2 Reserved Node with no changes to the configuration (term, payment type, or number of nodes) and no additional costs. 
     * @param reservedNodeId A string representing the node identifier of the DC1 Reserved Node to be exchanged. (required)
     * @param targetReservedNodeOfferingId The unique identifier of the DC2 Reserved Node offering to be used for the exchange. You can obtain the value for the parameter by calling &lt;a&gt;GetReservedNodeExchangeOfferings&lt;/a&gt;  (required)
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> ReservedNodeNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> InvalidReservedNodeStateFault </td><td>  -  </td></tr>
        <tr><td> 482 </td><td> ReservedNodeAlreadyMigratedFault </td><td>  -  </td></tr>
        <tr><td> 483 </td><td> ReservedNodeOfferingNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 484 </td><td> UnsupportedOperationFault </td><td>  -  </td></tr>
        <tr><td> 485 </td><td> DependentServiceUnavailableFault </td><td>  -  </td></tr>
        <tr><td> 486 </td><td> ReservedNodeAlreadyExistsFault </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call gETAcceptReservedNodeExchangeAsync(String reservedNodeId, String targetReservedNodeOfferingId, String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, final ApiCallback<AcceptReservedNodeExchangeOutputMessage> _callback) throws ApiException {

        okhttp3.Call localVarCall = gETAcceptReservedNodeExchangeValidateBeforeCall(reservedNodeId, targetReservedNodeOfferingId, action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, _callback);
        Type localVarReturnType = new TypeToken<AcceptReservedNodeExchangeOutputMessage>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for gETAddPartner
     * @param accountId The Amazon Web Services account ID that owns the cluster. (required)
     * @param clusterIdentifier The cluster identifier of the cluster that receives data from the partner. (required)
     * @param databaseName The name of the database that receives data from the partner. (required)
     * @param partnerName The name of the partner that is authorized to send data. (required)
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> PartnerNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> ClusterNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 482 </td><td> UnauthorizedPartnerIntegrationFault </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call gETAddPartnerCall(String accountId, String clusterIdentifier, String databaseName, String partnerName, String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/#Action=AddPartner";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (accountId != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("AccountId", accountId));
        }

        if (clusterIdentifier != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("ClusterIdentifier", clusterIdentifier));
        }

        if (databaseName != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("DatabaseName", databaseName));
        }

        if (partnerName != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("PartnerName", partnerName));
        }

        if (action != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("Action", action));
        }

        if (version != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("Version", version));
        }

        if (xAmzContentSha256 != null) {
            localVarHeaderParams.put("X-Amz-Content-Sha256", localVarApiClient.parameterToString(xAmzContentSha256));
        }

        if (xAmzDate != null) {
            localVarHeaderParams.put("X-Amz-Date", localVarApiClient.parameterToString(xAmzDate));
        }

        if (xAmzAlgorithm != null) {
            localVarHeaderParams.put("X-Amz-Algorithm", localVarApiClient.parameterToString(xAmzAlgorithm));
        }

        if (xAmzCredential != null) {
            localVarHeaderParams.put("X-Amz-Credential", localVarApiClient.parameterToString(xAmzCredential));
        }

        if (xAmzSecurityToken != null) {
            localVarHeaderParams.put("X-Amz-Security-Token", localVarApiClient.parameterToString(xAmzSecurityToken));
        }

        if (xAmzSignature != null) {
            localVarHeaderParams.put("X-Amz-Signature", localVarApiClient.parameterToString(xAmzSignature));
        }

        if (xAmzSignedHeaders != null) {
            localVarHeaderParams.put("X-Amz-SignedHeaders", localVarApiClient.parameterToString(xAmzSignedHeaders));
        }

        final String[] localVarAccepts = {
            "text/xml"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "hmac" };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call gETAddPartnerValidateBeforeCall(String accountId, String clusterIdentifier, String databaseName, String partnerName, String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'accountId' is set
        if (accountId == null) {
            throw new ApiException("Missing the required parameter 'accountId' when calling gETAddPartner(Async)");
        }

        // verify the required parameter 'clusterIdentifier' is set
        if (clusterIdentifier == null) {
            throw new ApiException("Missing the required parameter 'clusterIdentifier' when calling gETAddPartner(Async)");
        }

        // verify the required parameter 'databaseName' is set
        if (databaseName == null) {
            throw new ApiException("Missing the required parameter 'databaseName' when calling gETAddPartner(Async)");
        }

        // verify the required parameter 'partnerName' is set
        if (partnerName == null) {
            throw new ApiException("Missing the required parameter 'partnerName' when calling gETAddPartner(Async)");
        }

        // verify the required parameter 'action' is set
        if (action == null) {
            throw new ApiException("Missing the required parameter 'action' when calling gETAddPartner(Async)");
        }

        // verify the required parameter 'version' is set
        if (version == null) {
            throw new ApiException("Missing the required parameter 'version' when calling gETAddPartner(Async)");
        }

        return gETAddPartnerCall(accountId, clusterIdentifier, databaseName, partnerName, action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, _callback);

    }

    /**
     * 
     * Adds a partner integration to a cluster. This operation authorizes a partner to push status updates for the specified database. To complete the integration, you also set up the integration on the partner website.
     * @param accountId The Amazon Web Services account ID that owns the cluster. (required)
     * @param clusterIdentifier The cluster identifier of the cluster that receives data from the partner. (required)
     * @param databaseName The name of the database that receives data from the partner. (required)
     * @param partnerName The name of the partner that is authorized to send data. (required)
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @return PartnerIntegrationOutputMessage
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> PartnerNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> ClusterNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 482 </td><td> UnauthorizedPartnerIntegrationFault </td><td>  -  </td></tr>
     </table>
     */
    public PartnerIntegrationOutputMessage gETAddPartner(String accountId, String clusterIdentifier, String databaseName, String partnerName, String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders) throws ApiException {
        ApiResponse<PartnerIntegrationOutputMessage> localVarResp = gETAddPartnerWithHttpInfo(accountId, clusterIdentifier, databaseName, partnerName, action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders);
        return localVarResp.getData();
    }

    /**
     * 
     * Adds a partner integration to a cluster. This operation authorizes a partner to push status updates for the specified database. To complete the integration, you also set up the integration on the partner website.
     * @param accountId The Amazon Web Services account ID that owns the cluster. (required)
     * @param clusterIdentifier The cluster identifier of the cluster that receives data from the partner. (required)
     * @param databaseName The name of the database that receives data from the partner. (required)
     * @param partnerName The name of the partner that is authorized to send data. (required)
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @return ApiResponse&lt;PartnerIntegrationOutputMessage&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> PartnerNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> ClusterNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 482 </td><td> UnauthorizedPartnerIntegrationFault </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<PartnerIntegrationOutputMessage> gETAddPartnerWithHttpInfo(String accountId, String clusterIdentifier, String databaseName, String partnerName, String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders) throws ApiException {
        okhttp3.Call localVarCall = gETAddPartnerValidateBeforeCall(accountId, clusterIdentifier, databaseName, partnerName, action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, null);
        Type localVarReturnType = new TypeToken<PartnerIntegrationOutputMessage>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     *  (asynchronously)
     * Adds a partner integration to a cluster. This operation authorizes a partner to push status updates for the specified database. To complete the integration, you also set up the integration on the partner website.
     * @param accountId The Amazon Web Services account ID that owns the cluster. (required)
     * @param clusterIdentifier The cluster identifier of the cluster that receives data from the partner. (required)
     * @param databaseName The name of the database that receives data from the partner. (required)
     * @param partnerName The name of the partner that is authorized to send data. (required)
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> PartnerNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> ClusterNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 482 </td><td> UnauthorizedPartnerIntegrationFault </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call gETAddPartnerAsync(String accountId, String clusterIdentifier, String databaseName, String partnerName, String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, final ApiCallback<PartnerIntegrationOutputMessage> _callback) throws ApiException {

        okhttp3.Call localVarCall = gETAddPartnerValidateBeforeCall(accountId, clusterIdentifier, databaseName, partnerName, action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, _callback);
        Type localVarReturnType = new TypeToken<PartnerIntegrationOutputMessage>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for gETAssociateDataShareConsumer
     * @param dataShareArn The Amazon Resource Name (ARN) of the datashare that the consumer is to use with the account or the namespace. (required)
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param associateEntireAccount A value that specifies whether the datashare is associated with the entire account. (optional)
     * @param consumerArn The Amazon Resource Name (ARN) of the consumer that is associated with the datashare. (optional)
     * @param consumerRegion From a datashare consumer account, associates a datashare with all existing and future namespaces in the specified Amazon Web Services Region. (optional)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> InvalidDataShareFault </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> InvalidNamespaceFault </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call gETAssociateDataShareConsumerCall(String dataShareArn, String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, Boolean associateEntireAccount, String consumerArn, String consumerRegion, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/#Action=AssociateDataShareConsumer";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (dataShareArn != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("DataShareArn", dataShareArn));
        }

        if (associateEntireAccount != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("AssociateEntireAccount", associateEntireAccount));
        }

        if (consumerArn != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("ConsumerArn", consumerArn));
        }

        if (consumerRegion != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("ConsumerRegion", consumerRegion));
        }

        if (action != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("Action", action));
        }

        if (version != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("Version", version));
        }

        if (xAmzContentSha256 != null) {
            localVarHeaderParams.put("X-Amz-Content-Sha256", localVarApiClient.parameterToString(xAmzContentSha256));
        }

        if (xAmzDate != null) {
            localVarHeaderParams.put("X-Amz-Date", localVarApiClient.parameterToString(xAmzDate));
        }

        if (xAmzAlgorithm != null) {
            localVarHeaderParams.put("X-Amz-Algorithm", localVarApiClient.parameterToString(xAmzAlgorithm));
        }

        if (xAmzCredential != null) {
            localVarHeaderParams.put("X-Amz-Credential", localVarApiClient.parameterToString(xAmzCredential));
        }

        if (xAmzSecurityToken != null) {
            localVarHeaderParams.put("X-Amz-Security-Token", localVarApiClient.parameterToString(xAmzSecurityToken));
        }

        if (xAmzSignature != null) {
            localVarHeaderParams.put("X-Amz-Signature", localVarApiClient.parameterToString(xAmzSignature));
        }

        if (xAmzSignedHeaders != null) {
            localVarHeaderParams.put("X-Amz-SignedHeaders", localVarApiClient.parameterToString(xAmzSignedHeaders));
        }

        final String[] localVarAccepts = {
            "text/xml"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "hmac" };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call gETAssociateDataShareConsumerValidateBeforeCall(String dataShareArn, String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, Boolean associateEntireAccount, String consumerArn, String consumerRegion, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'dataShareArn' is set
        if (dataShareArn == null) {
            throw new ApiException("Missing the required parameter 'dataShareArn' when calling gETAssociateDataShareConsumer(Async)");
        }

        // verify the required parameter 'action' is set
        if (action == null) {
            throw new ApiException("Missing the required parameter 'action' when calling gETAssociateDataShareConsumer(Async)");
        }

        // verify the required parameter 'version' is set
        if (version == null) {
            throw new ApiException("Missing the required parameter 'version' when calling gETAssociateDataShareConsumer(Async)");
        }

        return gETAssociateDataShareConsumerCall(dataShareArn, action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, associateEntireAccount, consumerArn, consumerRegion, _callback);

    }

    /**
     * 
     * From a datashare consumer account, associates a datashare with the account (AssociateEntireAccount) or the specified namespace (ConsumerArn). If you make this association, the consumer can consume the datashare.
     * @param dataShareArn The Amazon Resource Name (ARN) of the datashare that the consumer is to use with the account or the namespace. (required)
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param associateEntireAccount A value that specifies whether the datashare is associated with the entire account. (optional)
     * @param consumerArn The Amazon Resource Name (ARN) of the consumer that is associated with the datashare. (optional)
     * @param consumerRegion From a datashare consumer account, associates a datashare with all existing and future namespaces in the specified Amazon Web Services Region. (optional)
     * @return DataShare
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> InvalidDataShareFault </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> InvalidNamespaceFault </td><td>  -  </td></tr>
     </table>
     */
    public DataShare gETAssociateDataShareConsumer(String dataShareArn, String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, Boolean associateEntireAccount, String consumerArn, String consumerRegion) throws ApiException {
        ApiResponse<DataShare> localVarResp = gETAssociateDataShareConsumerWithHttpInfo(dataShareArn, action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, associateEntireAccount, consumerArn, consumerRegion);
        return localVarResp.getData();
    }

    /**
     * 
     * From a datashare consumer account, associates a datashare with the account (AssociateEntireAccount) or the specified namespace (ConsumerArn). If you make this association, the consumer can consume the datashare.
     * @param dataShareArn The Amazon Resource Name (ARN) of the datashare that the consumer is to use with the account or the namespace. (required)
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param associateEntireAccount A value that specifies whether the datashare is associated with the entire account. (optional)
     * @param consumerArn The Amazon Resource Name (ARN) of the consumer that is associated with the datashare. (optional)
     * @param consumerRegion From a datashare consumer account, associates a datashare with all existing and future namespaces in the specified Amazon Web Services Region. (optional)
     * @return ApiResponse&lt;DataShare&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> InvalidDataShareFault </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> InvalidNamespaceFault </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<DataShare> gETAssociateDataShareConsumerWithHttpInfo(String dataShareArn, String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, Boolean associateEntireAccount, String consumerArn, String consumerRegion) throws ApiException {
        okhttp3.Call localVarCall = gETAssociateDataShareConsumerValidateBeforeCall(dataShareArn, action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, associateEntireAccount, consumerArn, consumerRegion, null);
        Type localVarReturnType = new TypeToken<DataShare>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     *  (asynchronously)
     * From a datashare consumer account, associates a datashare with the account (AssociateEntireAccount) or the specified namespace (ConsumerArn). If you make this association, the consumer can consume the datashare.
     * @param dataShareArn The Amazon Resource Name (ARN) of the datashare that the consumer is to use with the account or the namespace. (required)
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param associateEntireAccount A value that specifies whether the datashare is associated with the entire account. (optional)
     * @param consumerArn The Amazon Resource Name (ARN) of the consumer that is associated with the datashare. (optional)
     * @param consumerRegion From a datashare consumer account, associates a datashare with all existing and future namespaces in the specified Amazon Web Services Region. (optional)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> InvalidDataShareFault </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> InvalidNamespaceFault </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call gETAssociateDataShareConsumerAsync(String dataShareArn, String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, Boolean associateEntireAccount, String consumerArn, String consumerRegion, final ApiCallback<DataShare> _callback) throws ApiException {

        okhttp3.Call localVarCall = gETAssociateDataShareConsumerValidateBeforeCall(dataShareArn, action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, associateEntireAccount, consumerArn, consumerRegion, _callback);
        Type localVarReturnType = new TypeToken<DataShare>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for gETAuthorizeClusterSecurityGroupIngress
     * @param clusterSecurityGroupName The name of the security group to which the ingress rule is added. (required)
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param CIDRIP The IP range to be added the Amazon Redshift security group. (optional)
     * @param ec2SecurityGroupName The EC2 security group to be added the Amazon Redshift security group. (optional)
     * @param ec2SecurityGroupOwnerId &lt;p&gt;The Amazon Web Services account number of the owner of the security group specified by the &lt;i&gt;EC2SecurityGroupName&lt;/i&gt; parameter. The Amazon Web Services Access Key ID is not an acceptable value. &lt;/p&gt; &lt;p&gt;Example: &lt;code&gt;111122223333&lt;/code&gt; &lt;/p&gt; (optional)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> ClusterSecurityGroupNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> InvalidClusterSecurityGroupStateFault </td><td>  -  </td></tr>
        <tr><td> 482 </td><td> AuthorizationAlreadyExistsFault </td><td>  -  </td></tr>
        <tr><td> 483 </td><td> AuthorizationQuotaExceededFault </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call gETAuthorizeClusterSecurityGroupIngressCall(String clusterSecurityGroupName, String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, String CIDRIP, String ec2SecurityGroupName, String ec2SecurityGroupOwnerId, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/#Action=AuthorizeClusterSecurityGroupIngress";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (clusterSecurityGroupName != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("ClusterSecurityGroupName", clusterSecurityGroupName));
        }

        if (CIDRIP != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("CIDRIP", CIDRIP));
        }

        if (ec2SecurityGroupName != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("EC2SecurityGroupName", ec2SecurityGroupName));
        }

        if (ec2SecurityGroupOwnerId != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("EC2SecurityGroupOwnerId", ec2SecurityGroupOwnerId));
        }

        if (action != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("Action", action));
        }

        if (version != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("Version", version));
        }

        if (xAmzContentSha256 != null) {
            localVarHeaderParams.put("X-Amz-Content-Sha256", localVarApiClient.parameterToString(xAmzContentSha256));
        }

        if (xAmzDate != null) {
            localVarHeaderParams.put("X-Amz-Date", localVarApiClient.parameterToString(xAmzDate));
        }

        if (xAmzAlgorithm != null) {
            localVarHeaderParams.put("X-Amz-Algorithm", localVarApiClient.parameterToString(xAmzAlgorithm));
        }

        if (xAmzCredential != null) {
            localVarHeaderParams.put("X-Amz-Credential", localVarApiClient.parameterToString(xAmzCredential));
        }

        if (xAmzSecurityToken != null) {
            localVarHeaderParams.put("X-Amz-Security-Token", localVarApiClient.parameterToString(xAmzSecurityToken));
        }

        if (xAmzSignature != null) {
            localVarHeaderParams.put("X-Amz-Signature", localVarApiClient.parameterToString(xAmzSignature));
        }

        if (xAmzSignedHeaders != null) {
            localVarHeaderParams.put("X-Amz-SignedHeaders", localVarApiClient.parameterToString(xAmzSignedHeaders));
        }

        final String[] localVarAccepts = {
            "text/xml"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "hmac" };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call gETAuthorizeClusterSecurityGroupIngressValidateBeforeCall(String clusterSecurityGroupName, String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, String CIDRIP, String ec2SecurityGroupName, String ec2SecurityGroupOwnerId, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'clusterSecurityGroupName' is set
        if (clusterSecurityGroupName == null) {
            throw new ApiException("Missing the required parameter 'clusterSecurityGroupName' when calling gETAuthorizeClusterSecurityGroupIngress(Async)");
        }

        // verify the required parameter 'action' is set
        if (action == null) {
            throw new ApiException("Missing the required parameter 'action' when calling gETAuthorizeClusterSecurityGroupIngress(Async)");
        }

        // verify the required parameter 'version' is set
        if (version == null) {
            throw new ApiException("Missing the required parameter 'version' when calling gETAuthorizeClusterSecurityGroupIngress(Async)");
        }

        return gETAuthorizeClusterSecurityGroupIngressCall(clusterSecurityGroupName, action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, CIDRIP, ec2SecurityGroupName, ec2SecurityGroupOwnerId, _callback);

    }

    /**
     * 
     * &lt;p&gt;Adds an inbound (ingress) rule to an Amazon Redshift security group. Depending on whether the application accessing your cluster is running on the Internet or an Amazon EC2 instance, you can authorize inbound access to either a Classless Interdomain Routing (CIDR)/Internet Protocol (IP) range or to an Amazon EC2 security group. You can add as many as 20 ingress rules to an Amazon Redshift security group.&lt;/p&gt; &lt;p&gt;If you authorize access to an Amazon EC2 security group, specify &lt;i&gt;EC2SecurityGroupName&lt;/i&gt; and &lt;i&gt;EC2SecurityGroupOwnerId&lt;/i&gt;. The Amazon EC2 security group and Amazon Redshift cluster must be in the same Amazon Web Services Region. &lt;/p&gt; &lt;p&gt;If you authorize access to a CIDR/IP address range, specify &lt;i&gt;CIDRIP&lt;/i&gt;. For an overview of CIDR blocks, see the Wikipedia article on &lt;a href&#x3D;\&quot;http://en.wikipedia.org/wiki/Classless_Inter-Domain_Routing\&quot;&gt;Classless Inter-Domain Routing&lt;/a&gt;. &lt;/p&gt; &lt;p&gt;You must also associate the security group with a cluster so that clients running on these IP addresses or the EC2 instance are authorized to connect to the cluster. For information about managing security groups, go to &lt;a href&#x3D;\&quot;https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-security-groups.html\&quot;&gt;Working with Security Groups&lt;/a&gt; in the &lt;i&gt;Amazon Redshift Cluster Management Guide&lt;/i&gt;.&lt;/p&gt;
     * @param clusterSecurityGroupName The name of the security group to which the ingress rule is added. (required)
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param CIDRIP The IP range to be added the Amazon Redshift security group. (optional)
     * @param ec2SecurityGroupName The EC2 security group to be added the Amazon Redshift security group. (optional)
     * @param ec2SecurityGroupOwnerId &lt;p&gt;The Amazon Web Services account number of the owner of the security group specified by the &lt;i&gt;EC2SecurityGroupName&lt;/i&gt; parameter. The Amazon Web Services Access Key ID is not an acceptable value. &lt;/p&gt; &lt;p&gt;Example: &lt;code&gt;111122223333&lt;/code&gt; &lt;/p&gt; (optional)
     * @return AuthorizeClusterSecurityGroupIngressResult
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> ClusterSecurityGroupNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> InvalidClusterSecurityGroupStateFault </td><td>  -  </td></tr>
        <tr><td> 482 </td><td> AuthorizationAlreadyExistsFault </td><td>  -  </td></tr>
        <tr><td> 483 </td><td> AuthorizationQuotaExceededFault </td><td>  -  </td></tr>
     </table>
     */
    public AuthorizeClusterSecurityGroupIngressResult gETAuthorizeClusterSecurityGroupIngress(String clusterSecurityGroupName, String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, String CIDRIP, String ec2SecurityGroupName, String ec2SecurityGroupOwnerId) throws ApiException {
        ApiResponse<AuthorizeClusterSecurityGroupIngressResult> localVarResp = gETAuthorizeClusterSecurityGroupIngressWithHttpInfo(clusterSecurityGroupName, action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, CIDRIP, ec2SecurityGroupName, ec2SecurityGroupOwnerId);
        return localVarResp.getData();
    }

    /**
     * 
     * &lt;p&gt;Adds an inbound (ingress) rule to an Amazon Redshift security group. Depending on whether the application accessing your cluster is running on the Internet or an Amazon EC2 instance, you can authorize inbound access to either a Classless Interdomain Routing (CIDR)/Internet Protocol (IP) range or to an Amazon EC2 security group. You can add as many as 20 ingress rules to an Amazon Redshift security group.&lt;/p&gt; &lt;p&gt;If you authorize access to an Amazon EC2 security group, specify &lt;i&gt;EC2SecurityGroupName&lt;/i&gt; and &lt;i&gt;EC2SecurityGroupOwnerId&lt;/i&gt;. The Amazon EC2 security group and Amazon Redshift cluster must be in the same Amazon Web Services Region. &lt;/p&gt; &lt;p&gt;If you authorize access to a CIDR/IP address range, specify &lt;i&gt;CIDRIP&lt;/i&gt;. For an overview of CIDR blocks, see the Wikipedia article on &lt;a href&#x3D;\&quot;http://en.wikipedia.org/wiki/Classless_Inter-Domain_Routing\&quot;&gt;Classless Inter-Domain Routing&lt;/a&gt;. &lt;/p&gt; &lt;p&gt;You must also associate the security group with a cluster so that clients running on these IP addresses or the EC2 instance are authorized to connect to the cluster. For information about managing security groups, go to &lt;a href&#x3D;\&quot;https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-security-groups.html\&quot;&gt;Working with Security Groups&lt;/a&gt; in the &lt;i&gt;Amazon Redshift Cluster Management Guide&lt;/i&gt;.&lt;/p&gt;
     * @param clusterSecurityGroupName The name of the security group to which the ingress rule is added. (required)
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param CIDRIP The IP range to be added the Amazon Redshift security group. (optional)
     * @param ec2SecurityGroupName The EC2 security group to be added the Amazon Redshift security group. (optional)
     * @param ec2SecurityGroupOwnerId &lt;p&gt;The Amazon Web Services account number of the owner of the security group specified by the &lt;i&gt;EC2SecurityGroupName&lt;/i&gt; parameter. The Amazon Web Services Access Key ID is not an acceptable value. &lt;/p&gt; &lt;p&gt;Example: &lt;code&gt;111122223333&lt;/code&gt; &lt;/p&gt; (optional)
     * @return ApiResponse&lt;AuthorizeClusterSecurityGroupIngressResult&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> ClusterSecurityGroupNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> InvalidClusterSecurityGroupStateFault </td><td>  -  </td></tr>
        <tr><td> 482 </td><td> AuthorizationAlreadyExistsFault </td><td>  -  </td></tr>
        <tr><td> 483 </td><td> AuthorizationQuotaExceededFault </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<AuthorizeClusterSecurityGroupIngressResult> gETAuthorizeClusterSecurityGroupIngressWithHttpInfo(String clusterSecurityGroupName, String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, String CIDRIP, String ec2SecurityGroupName, String ec2SecurityGroupOwnerId) throws ApiException {
        okhttp3.Call localVarCall = gETAuthorizeClusterSecurityGroupIngressValidateBeforeCall(clusterSecurityGroupName, action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, CIDRIP, ec2SecurityGroupName, ec2SecurityGroupOwnerId, null);
        Type localVarReturnType = new TypeToken<AuthorizeClusterSecurityGroupIngressResult>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     *  (asynchronously)
     * &lt;p&gt;Adds an inbound (ingress) rule to an Amazon Redshift security group. Depending on whether the application accessing your cluster is running on the Internet or an Amazon EC2 instance, you can authorize inbound access to either a Classless Interdomain Routing (CIDR)/Internet Protocol (IP) range or to an Amazon EC2 security group. You can add as many as 20 ingress rules to an Amazon Redshift security group.&lt;/p&gt; &lt;p&gt;If you authorize access to an Amazon EC2 security group, specify &lt;i&gt;EC2SecurityGroupName&lt;/i&gt; and &lt;i&gt;EC2SecurityGroupOwnerId&lt;/i&gt;. The Amazon EC2 security group and Amazon Redshift cluster must be in the same Amazon Web Services Region. &lt;/p&gt; &lt;p&gt;If you authorize access to a CIDR/IP address range, specify &lt;i&gt;CIDRIP&lt;/i&gt;. For an overview of CIDR blocks, see the Wikipedia article on &lt;a href&#x3D;\&quot;http://en.wikipedia.org/wiki/Classless_Inter-Domain_Routing\&quot;&gt;Classless Inter-Domain Routing&lt;/a&gt;. &lt;/p&gt; &lt;p&gt;You must also associate the security group with a cluster so that clients running on these IP addresses or the EC2 instance are authorized to connect to the cluster. For information about managing security groups, go to &lt;a href&#x3D;\&quot;https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-security-groups.html\&quot;&gt;Working with Security Groups&lt;/a&gt; in the &lt;i&gt;Amazon Redshift Cluster Management Guide&lt;/i&gt;.&lt;/p&gt;
     * @param clusterSecurityGroupName The name of the security group to which the ingress rule is added. (required)
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param CIDRIP The IP range to be added the Amazon Redshift security group. (optional)
     * @param ec2SecurityGroupName The EC2 security group to be added the Amazon Redshift security group. (optional)
     * @param ec2SecurityGroupOwnerId &lt;p&gt;The Amazon Web Services account number of the owner of the security group specified by the &lt;i&gt;EC2SecurityGroupName&lt;/i&gt; parameter. The Amazon Web Services Access Key ID is not an acceptable value. &lt;/p&gt; &lt;p&gt;Example: &lt;code&gt;111122223333&lt;/code&gt; &lt;/p&gt; (optional)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> ClusterSecurityGroupNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> InvalidClusterSecurityGroupStateFault </td><td>  -  </td></tr>
        <tr><td> 482 </td><td> AuthorizationAlreadyExistsFault </td><td>  -  </td></tr>
        <tr><td> 483 </td><td> AuthorizationQuotaExceededFault </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call gETAuthorizeClusterSecurityGroupIngressAsync(String clusterSecurityGroupName, String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, String CIDRIP, String ec2SecurityGroupName, String ec2SecurityGroupOwnerId, final ApiCallback<AuthorizeClusterSecurityGroupIngressResult> _callback) throws ApiException {

        okhttp3.Call localVarCall = gETAuthorizeClusterSecurityGroupIngressValidateBeforeCall(clusterSecurityGroupName, action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, CIDRIP, ec2SecurityGroupName, ec2SecurityGroupOwnerId, _callback);
        Type localVarReturnType = new TypeToken<AuthorizeClusterSecurityGroupIngressResult>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for gETAuthorizeDataShare
     * @param dataShareArn The Amazon Resource Name (ARN) of the datashare that producers are to authorize sharing for. (required)
     * @param consumerIdentifier The identifier of the data consumer that is authorized to access the datashare. This identifier is an Amazon Web Services account ID or a keyword, such as ADX. (required)
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> InvalidDataShareFault </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call gETAuthorizeDataShareCall(String dataShareArn, String consumerIdentifier, String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/#Action=AuthorizeDataShare";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (dataShareArn != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("DataShareArn", dataShareArn));
        }

        if (consumerIdentifier != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("ConsumerIdentifier", consumerIdentifier));
        }

        if (action != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("Action", action));
        }

        if (version != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("Version", version));
        }

        if (xAmzContentSha256 != null) {
            localVarHeaderParams.put("X-Amz-Content-Sha256", localVarApiClient.parameterToString(xAmzContentSha256));
        }

        if (xAmzDate != null) {
            localVarHeaderParams.put("X-Amz-Date", localVarApiClient.parameterToString(xAmzDate));
        }

        if (xAmzAlgorithm != null) {
            localVarHeaderParams.put("X-Amz-Algorithm", localVarApiClient.parameterToString(xAmzAlgorithm));
        }

        if (xAmzCredential != null) {
            localVarHeaderParams.put("X-Amz-Credential", localVarApiClient.parameterToString(xAmzCredential));
        }

        if (xAmzSecurityToken != null) {
            localVarHeaderParams.put("X-Amz-Security-Token", localVarApiClient.parameterToString(xAmzSecurityToken));
        }

        if (xAmzSignature != null) {
            localVarHeaderParams.put("X-Amz-Signature", localVarApiClient.parameterToString(xAmzSignature));
        }

        if (xAmzSignedHeaders != null) {
            localVarHeaderParams.put("X-Amz-SignedHeaders", localVarApiClient.parameterToString(xAmzSignedHeaders));
        }

        final String[] localVarAccepts = {
            "text/xml"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "hmac" };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call gETAuthorizeDataShareValidateBeforeCall(String dataShareArn, String consumerIdentifier, String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'dataShareArn' is set
        if (dataShareArn == null) {
            throw new ApiException("Missing the required parameter 'dataShareArn' when calling gETAuthorizeDataShare(Async)");
        }

        // verify the required parameter 'consumerIdentifier' is set
        if (consumerIdentifier == null) {
            throw new ApiException("Missing the required parameter 'consumerIdentifier' when calling gETAuthorizeDataShare(Async)");
        }

        // verify the required parameter 'action' is set
        if (action == null) {
            throw new ApiException("Missing the required parameter 'action' when calling gETAuthorizeDataShare(Async)");
        }

        // verify the required parameter 'version' is set
        if (version == null) {
            throw new ApiException("Missing the required parameter 'version' when calling gETAuthorizeDataShare(Async)");
        }

        return gETAuthorizeDataShareCall(dataShareArn, consumerIdentifier, action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, _callback);

    }

    /**
     * 
     * From a data producer account, authorizes the sharing of a datashare with one or more consumer accounts or managing entities. To authorize a datashare for a data consumer, the producer account must have the correct access permissions.
     * @param dataShareArn The Amazon Resource Name (ARN) of the datashare that producers are to authorize sharing for. (required)
     * @param consumerIdentifier The identifier of the data consumer that is authorized to access the datashare. This identifier is an Amazon Web Services account ID or a keyword, such as ADX. (required)
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @return DataShare
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> InvalidDataShareFault </td><td>  -  </td></tr>
     </table>
     */
    public DataShare gETAuthorizeDataShare(String dataShareArn, String consumerIdentifier, String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders) throws ApiException {
        ApiResponse<DataShare> localVarResp = gETAuthorizeDataShareWithHttpInfo(dataShareArn, consumerIdentifier, action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders);
        return localVarResp.getData();
    }

    /**
     * 
     * From a data producer account, authorizes the sharing of a datashare with one or more consumer accounts or managing entities. To authorize a datashare for a data consumer, the producer account must have the correct access permissions.
     * @param dataShareArn The Amazon Resource Name (ARN) of the datashare that producers are to authorize sharing for. (required)
     * @param consumerIdentifier The identifier of the data consumer that is authorized to access the datashare. This identifier is an Amazon Web Services account ID or a keyword, such as ADX. (required)
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @return ApiResponse&lt;DataShare&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> InvalidDataShareFault </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<DataShare> gETAuthorizeDataShareWithHttpInfo(String dataShareArn, String consumerIdentifier, String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders) throws ApiException {
        okhttp3.Call localVarCall = gETAuthorizeDataShareValidateBeforeCall(dataShareArn, consumerIdentifier, action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, null);
        Type localVarReturnType = new TypeToken<DataShare>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     *  (asynchronously)
     * From a data producer account, authorizes the sharing of a datashare with one or more consumer accounts or managing entities. To authorize a datashare for a data consumer, the producer account must have the correct access permissions.
     * @param dataShareArn The Amazon Resource Name (ARN) of the datashare that producers are to authorize sharing for. (required)
     * @param consumerIdentifier The identifier of the data consumer that is authorized to access the datashare. This identifier is an Amazon Web Services account ID or a keyword, such as ADX. (required)
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> InvalidDataShareFault </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call gETAuthorizeDataShareAsync(String dataShareArn, String consumerIdentifier, String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, final ApiCallback<DataShare> _callback) throws ApiException {

        okhttp3.Call localVarCall = gETAuthorizeDataShareValidateBeforeCall(dataShareArn, consumerIdentifier, action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, _callback);
        Type localVarReturnType = new TypeToken<DataShare>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for gETAuthorizeEndpointAccess
     * @param account The Amazon Web Services account ID to grant access to. (required)
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param clusterIdentifier The cluster identifier of the cluster to grant access to. (optional)
     * @param vpcIds The virtual private cloud (VPC) identifiers to grant access to. (optional)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> ClusterNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> EndpointAuthorizationsPerClusterLimitExceededFault </td><td>  -  </td></tr>
        <tr><td> 482 </td><td> UnsupportedOperationFault </td><td>  -  </td></tr>
        <tr><td> 483 </td><td> EndpointAuthorizationAlreadyExistsFault </td><td>  -  </td></tr>
        <tr><td> 484 </td><td> InvalidAuthorizationStateFault </td><td>  -  </td></tr>
        <tr><td> 485 </td><td> InvalidClusterStateFault </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call gETAuthorizeEndpointAccessCall(String account, String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, String clusterIdentifier, List<String> vpcIds, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/#Action=AuthorizeEndpointAccess";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (clusterIdentifier != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("ClusterIdentifier", clusterIdentifier));
        }

        if (account != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("Account", account));
        }

        if (vpcIds != null) {
            localVarCollectionQueryParams.addAll(localVarApiClient.parameterToPairs("multi", "VpcIds", vpcIds));
        }

        if (action != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("Action", action));
        }

        if (version != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("Version", version));
        }

        if (xAmzContentSha256 != null) {
            localVarHeaderParams.put("X-Amz-Content-Sha256", localVarApiClient.parameterToString(xAmzContentSha256));
        }

        if (xAmzDate != null) {
            localVarHeaderParams.put("X-Amz-Date", localVarApiClient.parameterToString(xAmzDate));
        }

        if (xAmzAlgorithm != null) {
            localVarHeaderParams.put("X-Amz-Algorithm", localVarApiClient.parameterToString(xAmzAlgorithm));
        }

        if (xAmzCredential != null) {
            localVarHeaderParams.put("X-Amz-Credential", localVarApiClient.parameterToString(xAmzCredential));
        }

        if (xAmzSecurityToken != null) {
            localVarHeaderParams.put("X-Amz-Security-Token", localVarApiClient.parameterToString(xAmzSecurityToken));
        }

        if (xAmzSignature != null) {
            localVarHeaderParams.put("X-Amz-Signature", localVarApiClient.parameterToString(xAmzSignature));
        }

        if (xAmzSignedHeaders != null) {
            localVarHeaderParams.put("X-Amz-SignedHeaders", localVarApiClient.parameterToString(xAmzSignedHeaders));
        }

        final String[] localVarAccepts = {
            "text/xml"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "hmac" };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call gETAuthorizeEndpointAccessValidateBeforeCall(String account, String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, String clusterIdentifier, List<String> vpcIds, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'account' is set
        if (account == null) {
            throw new ApiException("Missing the required parameter 'account' when calling gETAuthorizeEndpointAccess(Async)");
        }

        // verify the required parameter 'action' is set
        if (action == null) {
            throw new ApiException("Missing the required parameter 'action' when calling gETAuthorizeEndpointAccess(Async)");
        }

        // verify the required parameter 'version' is set
        if (version == null) {
            throw new ApiException("Missing the required parameter 'version' when calling gETAuthorizeEndpointAccess(Async)");
        }

        return gETAuthorizeEndpointAccessCall(account, action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, clusterIdentifier, vpcIds, _callback);

    }

    /**
     * 
     * Grants access to a cluster.
     * @param account The Amazon Web Services account ID to grant access to. (required)
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param clusterIdentifier The cluster identifier of the cluster to grant access to. (optional)
     * @param vpcIds The virtual private cloud (VPC) identifiers to grant access to. (optional)
     * @return EndpointAuthorization
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> ClusterNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> EndpointAuthorizationsPerClusterLimitExceededFault </td><td>  -  </td></tr>
        <tr><td> 482 </td><td> UnsupportedOperationFault </td><td>  -  </td></tr>
        <tr><td> 483 </td><td> EndpointAuthorizationAlreadyExistsFault </td><td>  -  </td></tr>
        <tr><td> 484 </td><td> InvalidAuthorizationStateFault </td><td>  -  </td></tr>
        <tr><td> 485 </td><td> InvalidClusterStateFault </td><td>  -  </td></tr>
     </table>
     */
    public EndpointAuthorization gETAuthorizeEndpointAccess(String account, String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, String clusterIdentifier, List<String> vpcIds) throws ApiException {
        ApiResponse<EndpointAuthorization> localVarResp = gETAuthorizeEndpointAccessWithHttpInfo(account, action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, clusterIdentifier, vpcIds);
        return localVarResp.getData();
    }

    /**
     * 
     * Grants access to a cluster.
     * @param account The Amazon Web Services account ID to grant access to. (required)
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param clusterIdentifier The cluster identifier of the cluster to grant access to. (optional)
     * @param vpcIds The virtual private cloud (VPC) identifiers to grant access to. (optional)
     * @return ApiResponse&lt;EndpointAuthorization&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> ClusterNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> EndpointAuthorizationsPerClusterLimitExceededFault </td><td>  -  </td></tr>
        <tr><td> 482 </td><td> UnsupportedOperationFault </td><td>  -  </td></tr>
        <tr><td> 483 </td><td> EndpointAuthorizationAlreadyExistsFault </td><td>  -  </td></tr>
        <tr><td> 484 </td><td> InvalidAuthorizationStateFault </td><td>  -  </td></tr>
        <tr><td> 485 </td><td> InvalidClusterStateFault </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<EndpointAuthorization> gETAuthorizeEndpointAccessWithHttpInfo(String account, String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, String clusterIdentifier, List<String> vpcIds) throws ApiException {
        okhttp3.Call localVarCall = gETAuthorizeEndpointAccessValidateBeforeCall(account, action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, clusterIdentifier, vpcIds, null);
        Type localVarReturnType = new TypeToken<EndpointAuthorization>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     *  (asynchronously)
     * Grants access to a cluster.
     * @param account The Amazon Web Services account ID to grant access to. (required)
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param clusterIdentifier The cluster identifier of the cluster to grant access to. (optional)
     * @param vpcIds The virtual private cloud (VPC) identifiers to grant access to. (optional)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> ClusterNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> EndpointAuthorizationsPerClusterLimitExceededFault </td><td>  -  </td></tr>
        <tr><td> 482 </td><td> UnsupportedOperationFault </td><td>  -  </td></tr>
        <tr><td> 483 </td><td> EndpointAuthorizationAlreadyExistsFault </td><td>  -  </td></tr>
        <tr><td> 484 </td><td> InvalidAuthorizationStateFault </td><td>  -  </td></tr>
        <tr><td> 485 </td><td> InvalidClusterStateFault </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call gETAuthorizeEndpointAccessAsync(String account, String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, String clusterIdentifier, List<String> vpcIds, final ApiCallback<EndpointAuthorization> _callback) throws ApiException {

        okhttp3.Call localVarCall = gETAuthorizeEndpointAccessValidateBeforeCall(account, action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, clusterIdentifier, vpcIds, _callback);
        Type localVarReturnType = new TypeToken<EndpointAuthorization>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for gETAuthorizeSnapshotAccess
     * @param accountWithRestoreAccess &lt;p&gt;The identifier of the Amazon Web Services account authorized to restore the specified snapshot.&lt;/p&gt; &lt;p&gt;To share a snapshot with Amazon Web Services Support, specify amazon-redshift-support.&lt;/p&gt; (required)
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param snapshotIdentifier The identifier of the snapshot the account is authorized to restore. (optional)
     * @param snapshotArn The Amazon Resource Name (ARN) of the snapshot to authorize access to. (optional)
     * @param snapshotClusterIdentifier The identifier of the cluster the snapshot was created from. This parameter is required if your IAM user has a policy containing a snapshot resource element that specifies anything other than * for the cluster name. (optional)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> ClusterSnapshotNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> AuthorizationAlreadyExistsFault </td><td>  -  </td></tr>
        <tr><td> 482 </td><td> AuthorizationQuotaExceededFault </td><td>  -  </td></tr>
        <tr><td> 483 </td><td> DependentServiceRequestThrottlingFault </td><td>  -  </td></tr>
        <tr><td> 484 </td><td> InvalidClusterSnapshotStateFault </td><td>  -  </td></tr>
        <tr><td> 485 </td><td> LimitExceededFault </td><td>  -  </td></tr>
        <tr><td> 486 </td><td> UnsupportedOperationFault </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call gETAuthorizeSnapshotAccessCall(String accountWithRestoreAccess, String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, String snapshotIdentifier, String snapshotArn, String snapshotClusterIdentifier, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/#Action=AuthorizeSnapshotAccess";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (snapshotIdentifier != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("SnapshotIdentifier", snapshotIdentifier));
        }

        if (snapshotArn != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("SnapshotArn", snapshotArn));
        }

        if (snapshotClusterIdentifier != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("SnapshotClusterIdentifier", snapshotClusterIdentifier));
        }

        if (accountWithRestoreAccess != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("AccountWithRestoreAccess", accountWithRestoreAccess));
        }

        if (action != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("Action", action));
        }

        if (version != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("Version", version));
        }

        if (xAmzContentSha256 != null) {
            localVarHeaderParams.put("X-Amz-Content-Sha256", localVarApiClient.parameterToString(xAmzContentSha256));
        }

        if (xAmzDate != null) {
            localVarHeaderParams.put("X-Amz-Date", localVarApiClient.parameterToString(xAmzDate));
        }

        if (xAmzAlgorithm != null) {
            localVarHeaderParams.put("X-Amz-Algorithm", localVarApiClient.parameterToString(xAmzAlgorithm));
        }

        if (xAmzCredential != null) {
            localVarHeaderParams.put("X-Amz-Credential", localVarApiClient.parameterToString(xAmzCredential));
        }

        if (xAmzSecurityToken != null) {
            localVarHeaderParams.put("X-Amz-Security-Token", localVarApiClient.parameterToString(xAmzSecurityToken));
        }

        if (xAmzSignature != null) {
            localVarHeaderParams.put("X-Amz-Signature", localVarApiClient.parameterToString(xAmzSignature));
        }

        if (xAmzSignedHeaders != null) {
            localVarHeaderParams.put("X-Amz-SignedHeaders", localVarApiClient.parameterToString(xAmzSignedHeaders));
        }

        final String[] localVarAccepts = {
            "text/xml"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "hmac" };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call gETAuthorizeSnapshotAccessValidateBeforeCall(String accountWithRestoreAccess, String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, String snapshotIdentifier, String snapshotArn, String snapshotClusterIdentifier, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'accountWithRestoreAccess' is set
        if (accountWithRestoreAccess == null) {
            throw new ApiException("Missing the required parameter 'accountWithRestoreAccess' when calling gETAuthorizeSnapshotAccess(Async)");
        }

        // verify the required parameter 'action' is set
        if (action == null) {
            throw new ApiException("Missing the required parameter 'action' when calling gETAuthorizeSnapshotAccess(Async)");
        }

        // verify the required parameter 'version' is set
        if (version == null) {
            throw new ApiException("Missing the required parameter 'version' when calling gETAuthorizeSnapshotAccess(Async)");
        }

        return gETAuthorizeSnapshotAccessCall(accountWithRestoreAccess, action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, snapshotIdentifier, snapshotArn, snapshotClusterIdentifier, _callback);

    }

    /**
     * 
     * &lt;p&gt;Authorizes the specified Amazon Web Services account to restore the specified snapshot.&lt;/p&gt; &lt;p&gt; For more information about working with snapshots, go to &lt;a href&#x3D;\&quot;https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-snapshots.html\&quot;&gt;Amazon Redshift Snapshots&lt;/a&gt; in the &lt;i&gt;Amazon Redshift Cluster Management Guide&lt;/i&gt;.&lt;/p&gt;
     * @param accountWithRestoreAccess &lt;p&gt;The identifier of the Amazon Web Services account authorized to restore the specified snapshot.&lt;/p&gt; &lt;p&gt;To share a snapshot with Amazon Web Services Support, specify amazon-redshift-support.&lt;/p&gt; (required)
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param snapshotIdentifier The identifier of the snapshot the account is authorized to restore. (optional)
     * @param snapshotArn The Amazon Resource Name (ARN) of the snapshot to authorize access to. (optional)
     * @param snapshotClusterIdentifier The identifier of the cluster the snapshot was created from. This parameter is required if your IAM user has a policy containing a snapshot resource element that specifies anything other than * for the cluster name. (optional)
     * @return AuthorizeSnapshotAccessResult
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> ClusterSnapshotNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> AuthorizationAlreadyExistsFault </td><td>  -  </td></tr>
        <tr><td> 482 </td><td> AuthorizationQuotaExceededFault </td><td>  -  </td></tr>
        <tr><td> 483 </td><td> DependentServiceRequestThrottlingFault </td><td>  -  </td></tr>
        <tr><td> 484 </td><td> InvalidClusterSnapshotStateFault </td><td>  -  </td></tr>
        <tr><td> 485 </td><td> LimitExceededFault </td><td>  -  </td></tr>
        <tr><td> 486 </td><td> UnsupportedOperationFault </td><td>  -  </td></tr>
     </table>
     */
    public AuthorizeSnapshotAccessResult gETAuthorizeSnapshotAccess(String accountWithRestoreAccess, String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, String snapshotIdentifier, String snapshotArn, String snapshotClusterIdentifier) throws ApiException {
        ApiResponse<AuthorizeSnapshotAccessResult> localVarResp = gETAuthorizeSnapshotAccessWithHttpInfo(accountWithRestoreAccess, action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, snapshotIdentifier, snapshotArn, snapshotClusterIdentifier);
        return localVarResp.getData();
    }

    /**
     * 
     * &lt;p&gt;Authorizes the specified Amazon Web Services account to restore the specified snapshot.&lt;/p&gt; &lt;p&gt; For more information about working with snapshots, go to &lt;a href&#x3D;\&quot;https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-snapshots.html\&quot;&gt;Amazon Redshift Snapshots&lt;/a&gt; in the &lt;i&gt;Amazon Redshift Cluster Management Guide&lt;/i&gt;.&lt;/p&gt;
     * @param accountWithRestoreAccess &lt;p&gt;The identifier of the Amazon Web Services account authorized to restore the specified snapshot.&lt;/p&gt; &lt;p&gt;To share a snapshot with Amazon Web Services Support, specify amazon-redshift-support.&lt;/p&gt; (required)
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param snapshotIdentifier The identifier of the snapshot the account is authorized to restore. (optional)
     * @param snapshotArn The Amazon Resource Name (ARN) of the snapshot to authorize access to. (optional)
     * @param snapshotClusterIdentifier The identifier of the cluster the snapshot was created from. This parameter is required if your IAM user has a policy containing a snapshot resource element that specifies anything other than * for the cluster name. (optional)
     * @return ApiResponse&lt;AuthorizeSnapshotAccessResult&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> ClusterSnapshotNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> AuthorizationAlreadyExistsFault </td><td>  -  </td></tr>
        <tr><td> 482 </td><td> AuthorizationQuotaExceededFault </td><td>  -  </td></tr>
        <tr><td> 483 </td><td> DependentServiceRequestThrottlingFault </td><td>  -  </td></tr>
        <tr><td> 484 </td><td> InvalidClusterSnapshotStateFault </td><td>  -  </td></tr>
        <tr><td> 485 </td><td> LimitExceededFault </td><td>  -  </td></tr>
        <tr><td> 486 </td><td> UnsupportedOperationFault </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<AuthorizeSnapshotAccessResult> gETAuthorizeSnapshotAccessWithHttpInfo(String accountWithRestoreAccess, String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, String snapshotIdentifier, String snapshotArn, String snapshotClusterIdentifier) throws ApiException {
        okhttp3.Call localVarCall = gETAuthorizeSnapshotAccessValidateBeforeCall(accountWithRestoreAccess, action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, snapshotIdentifier, snapshotArn, snapshotClusterIdentifier, null);
        Type localVarReturnType = new TypeToken<AuthorizeSnapshotAccessResult>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     *  (asynchronously)
     * &lt;p&gt;Authorizes the specified Amazon Web Services account to restore the specified snapshot.&lt;/p&gt; &lt;p&gt; For more information about working with snapshots, go to &lt;a href&#x3D;\&quot;https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-snapshots.html\&quot;&gt;Amazon Redshift Snapshots&lt;/a&gt; in the &lt;i&gt;Amazon Redshift Cluster Management Guide&lt;/i&gt;.&lt;/p&gt;
     * @param accountWithRestoreAccess &lt;p&gt;The identifier of the Amazon Web Services account authorized to restore the specified snapshot.&lt;/p&gt; &lt;p&gt;To share a snapshot with Amazon Web Services Support, specify amazon-redshift-support.&lt;/p&gt; (required)
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param snapshotIdentifier The identifier of the snapshot the account is authorized to restore. (optional)
     * @param snapshotArn The Amazon Resource Name (ARN) of the snapshot to authorize access to. (optional)
     * @param snapshotClusterIdentifier The identifier of the cluster the snapshot was created from. This parameter is required if your IAM user has a policy containing a snapshot resource element that specifies anything other than * for the cluster name. (optional)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> ClusterSnapshotNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> AuthorizationAlreadyExistsFault </td><td>  -  </td></tr>
        <tr><td> 482 </td><td> AuthorizationQuotaExceededFault </td><td>  -  </td></tr>
        <tr><td> 483 </td><td> DependentServiceRequestThrottlingFault </td><td>  -  </td></tr>
        <tr><td> 484 </td><td> InvalidClusterSnapshotStateFault </td><td>  -  </td></tr>
        <tr><td> 485 </td><td> LimitExceededFault </td><td>  -  </td></tr>
        <tr><td> 486 </td><td> UnsupportedOperationFault </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call gETAuthorizeSnapshotAccessAsync(String accountWithRestoreAccess, String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, String snapshotIdentifier, String snapshotArn, String snapshotClusterIdentifier, final ApiCallback<AuthorizeSnapshotAccessResult> _callback) throws ApiException {

        okhttp3.Call localVarCall = gETAuthorizeSnapshotAccessValidateBeforeCall(accountWithRestoreAccess, action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, snapshotIdentifier, snapshotArn, snapshotClusterIdentifier, _callback);
        Type localVarReturnType = new TypeToken<AuthorizeSnapshotAccessResult>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for gETBatchDeleteClusterSnapshots
     * @param identifiers A list of identifiers for the snapshots that you want to delete. (required)
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> BatchDeleteRequestSizeExceededFault </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call gETBatchDeleteClusterSnapshotsCall(List<GETBatchDeleteClusterSnapshotsIdentifiersParameterInner> identifiers, String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/#Action=BatchDeleteClusterSnapshots";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (identifiers != null) {
            localVarCollectionQueryParams.addAll(localVarApiClient.parameterToPairs("multi", "Identifiers", identifiers));
        }

        if (action != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("Action", action));
        }

        if (version != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("Version", version));
        }

        if (xAmzContentSha256 != null) {
            localVarHeaderParams.put("X-Amz-Content-Sha256", localVarApiClient.parameterToString(xAmzContentSha256));
        }

        if (xAmzDate != null) {
            localVarHeaderParams.put("X-Amz-Date", localVarApiClient.parameterToString(xAmzDate));
        }

        if (xAmzAlgorithm != null) {
            localVarHeaderParams.put("X-Amz-Algorithm", localVarApiClient.parameterToString(xAmzAlgorithm));
        }

        if (xAmzCredential != null) {
            localVarHeaderParams.put("X-Amz-Credential", localVarApiClient.parameterToString(xAmzCredential));
        }

        if (xAmzSecurityToken != null) {
            localVarHeaderParams.put("X-Amz-Security-Token", localVarApiClient.parameterToString(xAmzSecurityToken));
        }

        if (xAmzSignature != null) {
            localVarHeaderParams.put("X-Amz-Signature", localVarApiClient.parameterToString(xAmzSignature));
        }

        if (xAmzSignedHeaders != null) {
            localVarHeaderParams.put("X-Amz-SignedHeaders", localVarApiClient.parameterToString(xAmzSignedHeaders));
        }

        final String[] localVarAccepts = {
            "text/xml"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "hmac" };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call gETBatchDeleteClusterSnapshotsValidateBeforeCall(List<GETBatchDeleteClusterSnapshotsIdentifiersParameterInner> identifiers, String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'identifiers' is set
        if (identifiers == null) {
            throw new ApiException("Missing the required parameter 'identifiers' when calling gETBatchDeleteClusterSnapshots(Async)");
        }

        // verify the required parameter 'action' is set
        if (action == null) {
            throw new ApiException("Missing the required parameter 'action' when calling gETBatchDeleteClusterSnapshots(Async)");
        }

        // verify the required parameter 'version' is set
        if (version == null) {
            throw new ApiException("Missing the required parameter 'version' when calling gETBatchDeleteClusterSnapshots(Async)");
        }

        return gETBatchDeleteClusterSnapshotsCall(identifiers, action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, _callback);

    }

    /**
     * 
     * Deletes a set of cluster snapshots.
     * @param identifiers A list of identifiers for the snapshots that you want to delete. (required)
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @return BatchDeleteClusterSnapshotsResult
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> BatchDeleteRequestSizeExceededFault </td><td>  -  </td></tr>
     </table>
     */
    public BatchDeleteClusterSnapshotsResult gETBatchDeleteClusterSnapshots(List<GETBatchDeleteClusterSnapshotsIdentifiersParameterInner> identifiers, String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders) throws ApiException {
        ApiResponse<BatchDeleteClusterSnapshotsResult> localVarResp = gETBatchDeleteClusterSnapshotsWithHttpInfo(identifiers, action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders);
        return localVarResp.getData();
    }

    /**
     * 
     * Deletes a set of cluster snapshots.
     * @param identifiers A list of identifiers for the snapshots that you want to delete. (required)
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @return ApiResponse&lt;BatchDeleteClusterSnapshotsResult&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> BatchDeleteRequestSizeExceededFault </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<BatchDeleteClusterSnapshotsResult> gETBatchDeleteClusterSnapshotsWithHttpInfo(List<GETBatchDeleteClusterSnapshotsIdentifiersParameterInner> identifiers, String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders) throws ApiException {
        okhttp3.Call localVarCall = gETBatchDeleteClusterSnapshotsValidateBeforeCall(identifiers, action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, null);
        Type localVarReturnType = new TypeToken<BatchDeleteClusterSnapshotsResult>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     *  (asynchronously)
     * Deletes a set of cluster snapshots.
     * @param identifiers A list of identifiers for the snapshots that you want to delete. (required)
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> BatchDeleteRequestSizeExceededFault </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call gETBatchDeleteClusterSnapshotsAsync(List<GETBatchDeleteClusterSnapshotsIdentifiersParameterInner> identifiers, String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, final ApiCallback<BatchDeleteClusterSnapshotsResult> _callback) throws ApiException {

        okhttp3.Call localVarCall = gETBatchDeleteClusterSnapshotsValidateBeforeCall(identifiers, action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, _callback);
        Type localVarReturnType = new TypeToken<BatchDeleteClusterSnapshotsResult>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for gETBatchModifyClusterSnapshots
     * @param snapshotIdentifierList A list of snapshot identifiers you want to modify. (required)
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param manualSnapshotRetentionPeriod &lt;p&gt;The number of days that a manual snapshot is retained. If you specify the value -1, the manual snapshot is retained indefinitely.&lt;/p&gt; &lt;p&gt;The number must be either -1 or an integer between 1 and 3,653.&lt;/p&gt; &lt;p&gt;If you decrease the manual snapshot retention period from its current value, existing manual snapshots that fall outside of the new retention period will return an error. If you want to suppress the errors and delete the snapshots, use the force option. &lt;/p&gt; (optional)
     * @param force A boolean value indicating whether to override an exception if the retention period has passed.  (optional)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> InvalidRetentionPeriodFault </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> BatchModifyClusterSnapshotsLimitExceededFault </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call gETBatchModifyClusterSnapshotsCall(List<String> snapshotIdentifierList, String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, Integer manualSnapshotRetentionPeriod, Boolean force, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/#Action=BatchModifyClusterSnapshots";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (snapshotIdentifierList != null) {
            localVarCollectionQueryParams.addAll(localVarApiClient.parameterToPairs("multi", "SnapshotIdentifierList", snapshotIdentifierList));
        }

        if (manualSnapshotRetentionPeriod != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("ManualSnapshotRetentionPeriod", manualSnapshotRetentionPeriod));
        }

        if (force != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("Force", force));
        }

        if (action != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("Action", action));
        }

        if (version != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("Version", version));
        }

        if (xAmzContentSha256 != null) {
            localVarHeaderParams.put("X-Amz-Content-Sha256", localVarApiClient.parameterToString(xAmzContentSha256));
        }

        if (xAmzDate != null) {
            localVarHeaderParams.put("X-Amz-Date", localVarApiClient.parameterToString(xAmzDate));
        }

        if (xAmzAlgorithm != null) {
            localVarHeaderParams.put("X-Amz-Algorithm", localVarApiClient.parameterToString(xAmzAlgorithm));
        }

        if (xAmzCredential != null) {
            localVarHeaderParams.put("X-Amz-Credential", localVarApiClient.parameterToString(xAmzCredential));
        }

        if (xAmzSecurityToken != null) {
            localVarHeaderParams.put("X-Amz-Security-Token", localVarApiClient.parameterToString(xAmzSecurityToken));
        }

        if (xAmzSignature != null) {
            localVarHeaderParams.put("X-Amz-Signature", localVarApiClient.parameterToString(xAmzSignature));
        }

        if (xAmzSignedHeaders != null) {
            localVarHeaderParams.put("X-Amz-SignedHeaders", localVarApiClient.parameterToString(xAmzSignedHeaders));
        }

        final String[] localVarAccepts = {
            "text/xml"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "hmac" };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call gETBatchModifyClusterSnapshotsValidateBeforeCall(List<String> snapshotIdentifierList, String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, Integer manualSnapshotRetentionPeriod, Boolean force, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'snapshotIdentifierList' is set
        if (snapshotIdentifierList == null) {
            throw new ApiException("Missing the required parameter 'snapshotIdentifierList' when calling gETBatchModifyClusterSnapshots(Async)");
        }

        // verify the required parameter 'action' is set
        if (action == null) {
            throw new ApiException("Missing the required parameter 'action' when calling gETBatchModifyClusterSnapshots(Async)");
        }

        // verify the required parameter 'version' is set
        if (version == null) {
            throw new ApiException("Missing the required parameter 'version' when calling gETBatchModifyClusterSnapshots(Async)");
        }

        return gETBatchModifyClusterSnapshotsCall(snapshotIdentifierList, action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, manualSnapshotRetentionPeriod, force, _callback);

    }

    /**
     * 
     * Modifies the settings for a set of cluster snapshots.
     * @param snapshotIdentifierList A list of snapshot identifiers you want to modify. (required)
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param manualSnapshotRetentionPeriod &lt;p&gt;The number of days that a manual snapshot is retained. If you specify the value -1, the manual snapshot is retained indefinitely.&lt;/p&gt; &lt;p&gt;The number must be either -1 or an integer between 1 and 3,653.&lt;/p&gt; &lt;p&gt;If you decrease the manual snapshot retention period from its current value, existing manual snapshots that fall outside of the new retention period will return an error. If you want to suppress the errors and delete the snapshots, use the force option. &lt;/p&gt; (optional)
     * @param force A boolean value indicating whether to override an exception if the retention period has passed.  (optional)
     * @return BatchModifyClusterSnapshotsOutputMessage
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> InvalidRetentionPeriodFault </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> BatchModifyClusterSnapshotsLimitExceededFault </td><td>  -  </td></tr>
     </table>
     */
    public BatchModifyClusterSnapshotsOutputMessage gETBatchModifyClusterSnapshots(List<String> snapshotIdentifierList, String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, Integer manualSnapshotRetentionPeriod, Boolean force) throws ApiException {
        ApiResponse<BatchModifyClusterSnapshotsOutputMessage> localVarResp = gETBatchModifyClusterSnapshotsWithHttpInfo(snapshotIdentifierList, action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, manualSnapshotRetentionPeriod, force);
        return localVarResp.getData();
    }

    /**
     * 
     * Modifies the settings for a set of cluster snapshots.
     * @param snapshotIdentifierList A list of snapshot identifiers you want to modify. (required)
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param manualSnapshotRetentionPeriod &lt;p&gt;The number of days that a manual snapshot is retained. If you specify the value -1, the manual snapshot is retained indefinitely.&lt;/p&gt; &lt;p&gt;The number must be either -1 or an integer between 1 and 3,653.&lt;/p&gt; &lt;p&gt;If you decrease the manual snapshot retention period from its current value, existing manual snapshots that fall outside of the new retention period will return an error. If you want to suppress the errors and delete the snapshots, use the force option. &lt;/p&gt; (optional)
     * @param force A boolean value indicating whether to override an exception if the retention period has passed.  (optional)
     * @return ApiResponse&lt;BatchModifyClusterSnapshotsOutputMessage&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> InvalidRetentionPeriodFault </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> BatchModifyClusterSnapshotsLimitExceededFault </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<BatchModifyClusterSnapshotsOutputMessage> gETBatchModifyClusterSnapshotsWithHttpInfo(List<String> snapshotIdentifierList, String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, Integer manualSnapshotRetentionPeriod, Boolean force) throws ApiException {
        okhttp3.Call localVarCall = gETBatchModifyClusterSnapshotsValidateBeforeCall(snapshotIdentifierList, action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, manualSnapshotRetentionPeriod, force, null);
        Type localVarReturnType = new TypeToken<BatchModifyClusterSnapshotsOutputMessage>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     *  (asynchronously)
     * Modifies the settings for a set of cluster snapshots.
     * @param snapshotIdentifierList A list of snapshot identifiers you want to modify. (required)
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param manualSnapshotRetentionPeriod &lt;p&gt;The number of days that a manual snapshot is retained. If you specify the value -1, the manual snapshot is retained indefinitely.&lt;/p&gt; &lt;p&gt;The number must be either -1 or an integer between 1 and 3,653.&lt;/p&gt; &lt;p&gt;If you decrease the manual snapshot retention period from its current value, existing manual snapshots that fall outside of the new retention period will return an error. If you want to suppress the errors and delete the snapshots, use the force option. &lt;/p&gt; (optional)
     * @param force A boolean value indicating whether to override an exception if the retention period has passed.  (optional)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> InvalidRetentionPeriodFault </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> BatchModifyClusterSnapshotsLimitExceededFault </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call gETBatchModifyClusterSnapshotsAsync(List<String> snapshotIdentifierList, String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, Integer manualSnapshotRetentionPeriod, Boolean force, final ApiCallback<BatchModifyClusterSnapshotsOutputMessage> _callback) throws ApiException {

        okhttp3.Call localVarCall = gETBatchModifyClusterSnapshotsValidateBeforeCall(snapshotIdentifierList, action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, manualSnapshotRetentionPeriod, force, _callback);
        Type localVarReturnType = new TypeToken<BatchModifyClusterSnapshotsOutputMessage>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for gETCancelResize
     * @param clusterIdentifier The unique identifier for the cluster that you want to cancel a resize operation for. (required)
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> ClusterNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> ResizeNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 482 </td><td> InvalidClusterStateFault </td><td>  -  </td></tr>
        <tr><td> 483 </td><td> UnsupportedOperationFault </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call gETCancelResizeCall(String clusterIdentifier, String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/#Action=CancelResize";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (clusterIdentifier != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("ClusterIdentifier", clusterIdentifier));
        }

        if (action != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("Action", action));
        }

        if (version != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("Version", version));
        }

        if (xAmzContentSha256 != null) {
            localVarHeaderParams.put("X-Amz-Content-Sha256", localVarApiClient.parameterToString(xAmzContentSha256));
        }

        if (xAmzDate != null) {
            localVarHeaderParams.put("X-Amz-Date", localVarApiClient.parameterToString(xAmzDate));
        }

        if (xAmzAlgorithm != null) {
            localVarHeaderParams.put("X-Amz-Algorithm", localVarApiClient.parameterToString(xAmzAlgorithm));
        }

        if (xAmzCredential != null) {
            localVarHeaderParams.put("X-Amz-Credential", localVarApiClient.parameterToString(xAmzCredential));
        }

        if (xAmzSecurityToken != null) {
            localVarHeaderParams.put("X-Amz-Security-Token", localVarApiClient.parameterToString(xAmzSecurityToken));
        }

        if (xAmzSignature != null) {
            localVarHeaderParams.put("X-Amz-Signature", localVarApiClient.parameterToString(xAmzSignature));
        }

        if (xAmzSignedHeaders != null) {
            localVarHeaderParams.put("X-Amz-SignedHeaders", localVarApiClient.parameterToString(xAmzSignedHeaders));
        }

        final String[] localVarAccepts = {
            "text/xml"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "hmac" };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call gETCancelResizeValidateBeforeCall(String clusterIdentifier, String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'clusterIdentifier' is set
        if (clusterIdentifier == null) {
            throw new ApiException("Missing the required parameter 'clusterIdentifier' when calling gETCancelResize(Async)");
        }

        // verify the required parameter 'action' is set
        if (action == null) {
            throw new ApiException("Missing the required parameter 'action' when calling gETCancelResize(Async)");
        }

        // verify the required parameter 'version' is set
        if (version == null) {
            throw new ApiException("Missing the required parameter 'version' when calling gETCancelResize(Async)");
        }

        return gETCancelResizeCall(clusterIdentifier, action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, _callback);

    }

    /**
     * 
     * Cancels a resize operation for a cluster.
     * @param clusterIdentifier The unique identifier for the cluster that you want to cancel a resize operation for. (required)
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @return ResizeProgressMessage
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> ClusterNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> ResizeNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 482 </td><td> InvalidClusterStateFault </td><td>  -  </td></tr>
        <tr><td> 483 </td><td> UnsupportedOperationFault </td><td>  -  </td></tr>
     </table>
     */
    public ResizeProgressMessage gETCancelResize(String clusterIdentifier, String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders) throws ApiException {
        ApiResponse<ResizeProgressMessage> localVarResp = gETCancelResizeWithHttpInfo(clusterIdentifier, action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders);
        return localVarResp.getData();
    }

    /**
     * 
     * Cancels a resize operation for a cluster.
     * @param clusterIdentifier The unique identifier for the cluster that you want to cancel a resize operation for. (required)
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @return ApiResponse&lt;ResizeProgressMessage&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> ClusterNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> ResizeNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 482 </td><td> InvalidClusterStateFault </td><td>  -  </td></tr>
        <tr><td> 483 </td><td> UnsupportedOperationFault </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<ResizeProgressMessage> gETCancelResizeWithHttpInfo(String clusterIdentifier, String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders) throws ApiException {
        okhttp3.Call localVarCall = gETCancelResizeValidateBeforeCall(clusterIdentifier, action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, null);
        Type localVarReturnType = new TypeToken<ResizeProgressMessage>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     *  (asynchronously)
     * Cancels a resize operation for a cluster.
     * @param clusterIdentifier The unique identifier for the cluster that you want to cancel a resize operation for. (required)
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> ClusterNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> ResizeNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 482 </td><td> InvalidClusterStateFault </td><td>  -  </td></tr>
        <tr><td> 483 </td><td> UnsupportedOperationFault </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call gETCancelResizeAsync(String clusterIdentifier, String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, final ApiCallback<ResizeProgressMessage> _callback) throws ApiException {

        okhttp3.Call localVarCall = gETCancelResizeValidateBeforeCall(clusterIdentifier, action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, _callback);
        Type localVarReturnType = new TypeToken<ResizeProgressMessage>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for gETCopyClusterSnapshot
     * @param sourceSnapshotIdentifier &lt;p&gt;The identifier for the source snapshot.&lt;/p&gt; &lt;p&gt;Constraints:&lt;/p&gt; &lt;ul&gt; &lt;li&gt; &lt;p&gt;Must be the identifier for a valid automated snapshot whose state is &lt;code&gt;available&lt;/code&gt;.&lt;/p&gt; &lt;/li&gt; &lt;/ul&gt; (required)
     * @param targetSnapshotIdentifier &lt;p&gt;The identifier given to the new manual snapshot.&lt;/p&gt; &lt;p&gt;Constraints:&lt;/p&gt; &lt;ul&gt; &lt;li&gt; &lt;p&gt;Cannot be null, empty, or blank.&lt;/p&gt; &lt;/li&gt; &lt;li&gt; &lt;p&gt;Must contain from 1 to 255 alphanumeric characters or hyphens.&lt;/p&gt; &lt;/li&gt; &lt;li&gt; &lt;p&gt;First character must be a letter.&lt;/p&gt; &lt;/li&gt; &lt;li&gt; &lt;p&gt;Cannot end with a hyphen or contain two consecutive hyphens.&lt;/p&gt; &lt;/li&gt; &lt;li&gt; &lt;p&gt;Must be unique for the Amazon Web Services account that is making the request.&lt;/p&gt; &lt;/li&gt; &lt;/ul&gt; (required)
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param sourceSnapshotClusterIdentifier &lt;p&gt;The identifier of the cluster the source snapshot was created from. This parameter is required if your IAM user has a policy containing a snapshot resource element that specifies anything other than * for the cluster name.&lt;/p&gt; &lt;p&gt;Constraints:&lt;/p&gt; &lt;ul&gt; &lt;li&gt; &lt;p&gt;Must be the identifier for a valid cluster.&lt;/p&gt; &lt;/li&gt; &lt;/ul&gt; (optional)
     * @param manualSnapshotRetentionPeriod &lt;p&gt;The number of days that a manual snapshot is retained. If the value is -1, the manual snapshot is retained indefinitely. &lt;/p&gt; &lt;p&gt;The value must be either -1 or an integer between 1 and 3,653.&lt;/p&gt; &lt;p&gt;The default value is -1.&lt;/p&gt; (optional)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> ClusterSnapshotAlreadyExistsFault </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> ClusterSnapshotNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 482 </td><td> InvalidClusterSnapshotStateFault </td><td>  -  </td></tr>
        <tr><td> 483 </td><td> ClusterSnapshotQuotaExceededFault </td><td>  -  </td></tr>
        <tr><td> 484 </td><td> InvalidRetentionPeriodFault </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call gETCopyClusterSnapshotCall(String sourceSnapshotIdentifier, String targetSnapshotIdentifier, String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, String sourceSnapshotClusterIdentifier, Integer manualSnapshotRetentionPeriod, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/#Action=CopyClusterSnapshot";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (sourceSnapshotIdentifier != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("SourceSnapshotIdentifier", sourceSnapshotIdentifier));
        }

        if (sourceSnapshotClusterIdentifier != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("SourceSnapshotClusterIdentifier", sourceSnapshotClusterIdentifier));
        }

        if (targetSnapshotIdentifier != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("TargetSnapshotIdentifier", targetSnapshotIdentifier));
        }

        if (manualSnapshotRetentionPeriod != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("ManualSnapshotRetentionPeriod", manualSnapshotRetentionPeriod));
        }

        if (action != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("Action", action));
        }

        if (version != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("Version", version));
        }

        if (xAmzContentSha256 != null) {
            localVarHeaderParams.put("X-Amz-Content-Sha256", localVarApiClient.parameterToString(xAmzContentSha256));
        }

        if (xAmzDate != null) {
            localVarHeaderParams.put("X-Amz-Date", localVarApiClient.parameterToString(xAmzDate));
        }

        if (xAmzAlgorithm != null) {
            localVarHeaderParams.put("X-Amz-Algorithm", localVarApiClient.parameterToString(xAmzAlgorithm));
        }

        if (xAmzCredential != null) {
            localVarHeaderParams.put("X-Amz-Credential", localVarApiClient.parameterToString(xAmzCredential));
        }

        if (xAmzSecurityToken != null) {
            localVarHeaderParams.put("X-Amz-Security-Token", localVarApiClient.parameterToString(xAmzSecurityToken));
        }

        if (xAmzSignature != null) {
            localVarHeaderParams.put("X-Amz-Signature", localVarApiClient.parameterToString(xAmzSignature));
        }

        if (xAmzSignedHeaders != null) {
            localVarHeaderParams.put("X-Amz-SignedHeaders", localVarApiClient.parameterToString(xAmzSignedHeaders));
        }

        final String[] localVarAccepts = {
            "text/xml"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "hmac" };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call gETCopyClusterSnapshotValidateBeforeCall(String sourceSnapshotIdentifier, String targetSnapshotIdentifier, String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, String sourceSnapshotClusterIdentifier, Integer manualSnapshotRetentionPeriod, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'sourceSnapshotIdentifier' is set
        if (sourceSnapshotIdentifier == null) {
            throw new ApiException("Missing the required parameter 'sourceSnapshotIdentifier' when calling gETCopyClusterSnapshot(Async)");
        }

        // verify the required parameter 'targetSnapshotIdentifier' is set
        if (targetSnapshotIdentifier == null) {
            throw new ApiException("Missing the required parameter 'targetSnapshotIdentifier' when calling gETCopyClusterSnapshot(Async)");
        }

        // verify the required parameter 'action' is set
        if (action == null) {
            throw new ApiException("Missing the required parameter 'action' when calling gETCopyClusterSnapshot(Async)");
        }

        // verify the required parameter 'version' is set
        if (version == null) {
            throw new ApiException("Missing the required parameter 'version' when calling gETCopyClusterSnapshot(Async)");
        }

        return gETCopyClusterSnapshotCall(sourceSnapshotIdentifier, targetSnapshotIdentifier, action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, sourceSnapshotClusterIdentifier, manualSnapshotRetentionPeriod, _callback);

    }

    /**
     * 
     * &lt;p&gt;Copies the specified automated cluster snapshot to a new manual cluster snapshot. The source must be an automated snapshot and it must be in the available state.&lt;/p&gt; &lt;p&gt;When you delete a cluster, Amazon Redshift deletes any automated snapshots of the cluster. Also, when the retention period of the snapshot expires, Amazon Redshift automatically deletes it. If you want to keep an automated snapshot for a longer period, you can make a manual copy of the snapshot. Manual snapshots are retained until you delete them.&lt;/p&gt; &lt;p&gt; For more information about working with snapshots, go to &lt;a href&#x3D;\&quot;https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-snapshots.html\&quot;&gt;Amazon Redshift Snapshots&lt;/a&gt; in the &lt;i&gt;Amazon Redshift Cluster Management Guide&lt;/i&gt;.&lt;/p&gt;
     * @param sourceSnapshotIdentifier &lt;p&gt;The identifier for the source snapshot.&lt;/p&gt; &lt;p&gt;Constraints:&lt;/p&gt; &lt;ul&gt; &lt;li&gt; &lt;p&gt;Must be the identifier for a valid automated snapshot whose state is &lt;code&gt;available&lt;/code&gt;.&lt;/p&gt; &lt;/li&gt; &lt;/ul&gt; (required)
     * @param targetSnapshotIdentifier &lt;p&gt;The identifier given to the new manual snapshot.&lt;/p&gt; &lt;p&gt;Constraints:&lt;/p&gt; &lt;ul&gt; &lt;li&gt; &lt;p&gt;Cannot be null, empty, or blank.&lt;/p&gt; &lt;/li&gt; &lt;li&gt; &lt;p&gt;Must contain from 1 to 255 alphanumeric characters or hyphens.&lt;/p&gt; &lt;/li&gt; &lt;li&gt; &lt;p&gt;First character must be a letter.&lt;/p&gt; &lt;/li&gt; &lt;li&gt; &lt;p&gt;Cannot end with a hyphen or contain two consecutive hyphens.&lt;/p&gt; &lt;/li&gt; &lt;li&gt; &lt;p&gt;Must be unique for the Amazon Web Services account that is making the request.&lt;/p&gt; &lt;/li&gt; &lt;/ul&gt; (required)
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param sourceSnapshotClusterIdentifier &lt;p&gt;The identifier of the cluster the source snapshot was created from. This parameter is required if your IAM user has a policy containing a snapshot resource element that specifies anything other than * for the cluster name.&lt;/p&gt; &lt;p&gt;Constraints:&lt;/p&gt; &lt;ul&gt; &lt;li&gt; &lt;p&gt;Must be the identifier for a valid cluster.&lt;/p&gt; &lt;/li&gt; &lt;/ul&gt; (optional)
     * @param manualSnapshotRetentionPeriod &lt;p&gt;The number of days that a manual snapshot is retained. If the value is -1, the manual snapshot is retained indefinitely. &lt;/p&gt; &lt;p&gt;The value must be either -1 or an integer between 1 and 3,653.&lt;/p&gt; &lt;p&gt;The default value is -1.&lt;/p&gt; (optional)
     * @return CopyClusterSnapshotResult
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> ClusterSnapshotAlreadyExistsFault </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> ClusterSnapshotNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 482 </td><td> InvalidClusterSnapshotStateFault </td><td>  -  </td></tr>
        <tr><td> 483 </td><td> ClusterSnapshotQuotaExceededFault </td><td>  -  </td></tr>
        <tr><td> 484 </td><td> InvalidRetentionPeriodFault </td><td>  -  </td></tr>
     </table>
     */
    public CopyClusterSnapshotResult gETCopyClusterSnapshot(String sourceSnapshotIdentifier, String targetSnapshotIdentifier, String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, String sourceSnapshotClusterIdentifier, Integer manualSnapshotRetentionPeriod) throws ApiException {
        ApiResponse<CopyClusterSnapshotResult> localVarResp = gETCopyClusterSnapshotWithHttpInfo(sourceSnapshotIdentifier, targetSnapshotIdentifier, action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, sourceSnapshotClusterIdentifier, manualSnapshotRetentionPeriod);
        return localVarResp.getData();
    }

    /**
     * 
     * &lt;p&gt;Copies the specified automated cluster snapshot to a new manual cluster snapshot. The source must be an automated snapshot and it must be in the available state.&lt;/p&gt; &lt;p&gt;When you delete a cluster, Amazon Redshift deletes any automated snapshots of the cluster. Also, when the retention period of the snapshot expires, Amazon Redshift automatically deletes it. If you want to keep an automated snapshot for a longer period, you can make a manual copy of the snapshot. Manual snapshots are retained until you delete them.&lt;/p&gt; &lt;p&gt; For more information about working with snapshots, go to &lt;a href&#x3D;\&quot;https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-snapshots.html\&quot;&gt;Amazon Redshift Snapshots&lt;/a&gt; in the &lt;i&gt;Amazon Redshift Cluster Management Guide&lt;/i&gt;.&lt;/p&gt;
     * @param sourceSnapshotIdentifier &lt;p&gt;The identifier for the source snapshot.&lt;/p&gt; &lt;p&gt;Constraints:&lt;/p&gt; &lt;ul&gt; &lt;li&gt; &lt;p&gt;Must be the identifier for a valid automated snapshot whose state is &lt;code&gt;available&lt;/code&gt;.&lt;/p&gt; &lt;/li&gt; &lt;/ul&gt; (required)
     * @param targetSnapshotIdentifier &lt;p&gt;The identifier given to the new manual snapshot.&lt;/p&gt; &lt;p&gt;Constraints:&lt;/p&gt; &lt;ul&gt; &lt;li&gt; &lt;p&gt;Cannot be null, empty, or blank.&lt;/p&gt; &lt;/li&gt; &lt;li&gt; &lt;p&gt;Must contain from 1 to 255 alphanumeric characters or hyphens.&lt;/p&gt; &lt;/li&gt; &lt;li&gt; &lt;p&gt;First character must be a letter.&lt;/p&gt; &lt;/li&gt; &lt;li&gt; &lt;p&gt;Cannot end with a hyphen or contain two consecutive hyphens.&lt;/p&gt; &lt;/li&gt; &lt;li&gt; &lt;p&gt;Must be unique for the Amazon Web Services account that is making the request.&lt;/p&gt; &lt;/li&gt; &lt;/ul&gt; (required)
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param sourceSnapshotClusterIdentifier &lt;p&gt;The identifier of the cluster the source snapshot was created from. This parameter is required if your IAM user has a policy containing a snapshot resource element that specifies anything other than * for the cluster name.&lt;/p&gt; &lt;p&gt;Constraints:&lt;/p&gt; &lt;ul&gt; &lt;li&gt; &lt;p&gt;Must be the identifier for a valid cluster.&lt;/p&gt; &lt;/li&gt; &lt;/ul&gt; (optional)
     * @param manualSnapshotRetentionPeriod &lt;p&gt;The number of days that a manual snapshot is retained. If the value is -1, the manual snapshot is retained indefinitely. &lt;/p&gt; &lt;p&gt;The value must be either -1 or an integer between 1 and 3,653.&lt;/p&gt; &lt;p&gt;The default value is -1.&lt;/p&gt; (optional)
     * @return ApiResponse&lt;CopyClusterSnapshotResult&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> ClusterSnapshotAlreadyExistsFault </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> ClusterSnapshotNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 482 </td><td> InvalidClusterSnapshotStateFault </td><td>  -  </td></tr>
        <tr><td> 483 </td><td> ClusterSnapshotQuotaExceededFault </td><td>  -  </td></tr>
        <tr><td> 484 </td><td> InvalidRetentionPeriodFault </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<CopyClusterSnapshotResult> gETCopyClusterSnapshotWithHttpInfo(String sourceSnapshotIdentifier, String targetSnapshotIdentifier, String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, String sourceSnapshotClusterIdentifier, Integer manualSnapshotRetentionPeriod) throws ApiException {
        okhttp3.Call localVarCall = gETCopyClusterSnapshotValidateBeforeCall(sourceSnapshotIdentifier, targetSnapshotIdentifier, action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, sourceSnapshotClusterIdentifier, manualSnapshotRetentionPeriod, null);
        Type localVarReturnType = new TypeToken<CopyClusterSnapshotResult>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     *  (asynchronously)
     * &lt;p&gt;Copies the specified automated cluster snapshot to a new manual cluster snapshot. The source must be an automated snapshot and it must be in the available state.&lt;/p&gt; &lt;p&gt;When you delete a cluster, Amazon Redshift deletes any automated snapshots of the cluster. Also, when the retention period of the snapshot expires, Amazon Redshift automatically deletes it. If you want to keep an automated snapshot for a longer period, you can make a manual copy of the snapshot. Manual snapshots are retained until you delete them.&lt;/p&gt; &lt;p&gt; For more information about working with snapshots, go to &lt;a href&#x3D;\&quot;https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-snapshots.html\&quot;&gt;Amazon Redshift Snapshots&lt;/a&gt; in the &lt;i&gt;Amazon Redshift Cluster Management Guide&lt;/i&gt;.&lt;/p&gt;
     * @param sourceSnapshotIdentifier &lt;p&gt;The identifier for the source snapshot.&lt;/p&gt; &lt;p&gt;Constraints:&lt;/p&gt; &lt;ul&gt; &lt;li&gt; &lt;p&gt;Must be the identifier for a valid automated snapshot whose state is &lt;code&gt;available&lt;/code&gt;.&lt;/p&gt; &lt;/li&gt; &lt;/ul&gt; (required)
     * @param targetSnapshotIdentifier &lt;p&gt;The identifier given to the new manual snapshot.&lt;/p&gt; &lt;p&gt;Constraints:&lt;/p&gt; &lt;ul&gt; &lt;li&gt; &lt;p&gt;Cannot be null, empty, or blank.&lt;/p&gt; &lt;/li&gt; &lt;li&gt; &lt;p&gt;Must contain from 1 to 255 alphanumeric characters or hyphens.&lt;/p&gt; &lt;/li&gt; &lt;li&gt; &lt;p&gt;First character must be a letter.&lt;/p&gt; &lt;/li&gt; &lt;li&gt; &lt;p&gt;Cannot end with a hyphen or contain two consecutive hyphens.&lt;/p&gt; &lt;/li&gt; &lt;li&gt; &lt;p&gt;Must be unique for the Amazon Web Services account that is making the request.&lt;/p&gt; &lt;/li&gt; &lt;/ul&gt; (required)
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param sourceSnapshotClusterIdentifier &lt;p&gt;The identifier of the cluster the source snapshot was created from. This parameter is required if your IAM user has a policy containing a snapshot resource element that specifies anything other than * for the cluster name.&lt;/p&gt; &lt;p&gt;Constraints:&lt;/p&gt; &lt;ul&gt; &lt;li&gt; &lt;p&gt;Must be the identifier for a valid cluster.&lt;/p&gt; &lt;/li&gt; &lt;/ul&gt; (optional)
     * @param manualSnapshotRetentionPeriod &lt;p&gt;The number of days that a manual snapshot is retained. If the value is -1, the manual snapshot is retained indefinitely. &lt;/p&gt; &lt;p&gt;The value must be either -1 or an integer between 1 and 3,653.&lt;/p&gt; &lt;p&gt;The default value is -1.&lt;/p&gt; (optional)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> ClusterSnapshotAlreadyExistsFault </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> ClusterSnapshotNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 482 </td><td> InvalidClusterSnapshotStateFault </td><td>  -  </td></tr>
        <tr><td> 483 </td><td> ClusterSnapshotQuotaExceededFault </td><td>  -  </td></tr>
        <tr><td> 484 </td><td> InvalidRetentionPeriodFault </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call gETCopyClusterSnapshotAsync(String sourceSnapshotIdentifier, String targetSnapshotIdentifier, String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, String sourceSnapshotClusterIdentifier, Integer manualSnapshotRetentionPeriod, final ApiCallback<CopyClusterSnapshotResult> _callback) throws ApiException {

        okhttp3.Call localVarCall = gETCopyClusterSnapshotValidateBeforeCall(sourceSnapshotIdentifier, targetSnapshotIdentifier, action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, sourceSnapshotClusterIdentifier, manualSnapshotRetentionPeriod, _callback);
        Type localVarReturnType = new TypeToken<CopyClusterSnapshotResult>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for gETCreateAuthenticationProfile
     * @param authenticationProfileName The name of the authentication profile to be created. (required)
     * @param authenticationProfileContent The content of the authentication profile in JSON format. The maximum length of the JSON string is determined by a quota for your account. (required)
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> AuthenticationProfileAlreadyExistsFault </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> AuthenticationProfileQuotaExceededFault </td><td>  -  </td></tr>
        <tr><td> 482 </td><td> InvalidAuthenticationProfileRequestFault </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call gETCreateAuthenticationProfileCall(String authenticationProfileName, String authenticationProfileContent, String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/#Action=CreateAuthenticationProfile";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (authenticationProfileName != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("AuthenticationProfileName", authenticationProfileName));
        }

        if (authenticationProfileContent != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("AuthenticationProfileContent", authenticationProfileContent));
        }

        if (action != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("Action", action));
        }

        if (version != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("Version", version));
        }

        if (xAmzContentSha256 != null) {
            localVarHeaderParams.put("X-Amz-Content-Sha256", localVarApiClient.parameterToString(xAmzContentSha256));
        }

        if (xAmzDate != null) {
            localVarHeaderParams.put("X-Amz-Date", localVarApiClient.parameterToString(xAmzDate));
        }

        if (xAmzAlgorithm != null) {
            localVarHeaderParams.put("X-Amz-Algorithm", localVarApiClient.parameterToString(xAmzAlgorithm));
        }

        if (xAmzCredential != null) {
            localVarHeaderParams.put("X-Amz-Credential", localVarApiClient.parameterToString(xAmzCredential));
        }

        if (xAmzSecurityToken != null) {
            localVarHeaderParams.put("X-Amz-Security-Token", localVarApiClient.parameterToString(xAmzSecurityToken));
        }

        if (xAmzSignature != null) {
            localVarHeaderParams.put("X-Amz-Signature", localVarApiClient.parameterToString(xAmzSignature));
        }

        if (xAmzSignedHeaders != null) {
            localVarHeaderParams.put("X-Amz-SignedHeaders", localVarApiClient.parameterToString(xAmzSignedHeaders));
        }

        final String[] localVarAccepts = {
            "text/xml"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "hmac" };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call gETCreateAuthenticationProfileValidateBeforeCall(String authenticationProfileName, String authenticationProfileContent, String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'authenticationProfileName' is set
        if (authenticationProfileName == null) {
            throw new ApiException("Missing the required parameter 'authenticationProfileName' when calling gETCreateAuthenticationProfile(Async)");
        }

        // verify the required parameter 'authenticationProfileContent' is set
        if (authenticationProfileContent == null) {
            throw new ApiException("Missing the required parameter 'authenticationProfileContent' when calling gETCreateAuthenticationProfile(Async)");
        }

        // verify the required parameter 'action' is set
        if (action == null) {
            throw new ApiException("Missing the required parameter 'action' when calling gETCreateAuthenticationProfile(Async)");
        }

        // verify the required parameter 'version' is set
        if (version == null) {
            throw new ApiException("Missing the required parameter 'version' when calling gETCreateAuthenticationProfile(Async)");
        }

        return gETCreateAuthenticationProfileCall(authenticationProfileName, authenticationProfileContent, action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, _callback);

    }

    /**
     * 
     * Creates an authentication profile with the specified parameters.
     * @param authenticationProfileName The name of the authentication profile to be created. (required)
     * @param authenticationProfileContent The content of the authentication profile in JSON format. The maximum length of the JSON string is determined by a quota for your account. (required)
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @return CreateAuthenticationProfileResult
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> AuthenticationProfileAlreadyExistsFault </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> AuthenticationProfileQuotaExceededFault </td><td>  -  </td></tr>
        <tr><td> 482 </td><td> InvalidAuthenticationProfileRequestFault </td><td>  -  </td></tr>
     </table>
     */
    public CreateAuthenticationProfileResult gETCreateAuthenticationProfile(String authenticationProfileName, String authenticationProfileContent, String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders) throws ApiException {
        ApiResponse<CreateAuthenticationProfileResult> localVarResp = gETCreateAuthenticationProfileWithHttpInfo(authenticationProfileName, authenticationProfileContent, action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders);
        return localVarResp.getData();
    }

    /**
     * 
     * Creates an authentication profile with the specified parameters.
     * @param authenticationProfileName The name of the authentication profile to be created. (required)
     * @param authenticationProfileContent The content of the authentication profile in JSON format. The maximum length of the JSON string is determined by a quota for your account. (required)
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @return ApiResponse&lt;CreateAuthenticationProfileResult&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> AuthenticationProfileAlreadyExistsFault </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> AuthenticationProfileQuotaExceededFault </td><td>  -  </td></tr>
        <tr><td> 482 </td><td> InvalidAuthenticationProfileRequestFault </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<CreateAuthenticationProfileResult> gETCreateAuthenticationProfileWithHttpInfo(String authenticationProfileName, String authenticationProfileContent, String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders) throws ApiException {
        okhttp3.Call localVarCall = gETCreateAuthenticationProfileValidateBeforeCall(authenticationProfileName, authenticationProfileContent, action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, null);
        Type localVarReturnType = new TypeToken<CreateAuthenticationProfileResult>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     *  (asynchronously)
     * Creates an authentication profile with the specified parameters.
     * @param authenticationProfileName The name of the authentication profile to be created. (required)
     * @param authenticationProfileContent The content of the authentication profile in JSON format. The maximum length of the JSON string is determined by a quota for your account. (required)
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> AuthenticationProfileAlreadyExistsFault </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> AuthenticationProfileQuotaExceededFault </td><td>  -  </td></tr>
        <tr><td> 482 </td><td> InvalidAuthenticationProfileRequestFault </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call gETCreateAuthenticationProfileAsync(String authenticationProfileName, String authenticationProfileContent, String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, final ApiCallback<CreateAuthenticationProfileResult> _callback) throws ApiException {

        okhttp3.Call localVarCall = gETCreateAuthenticationProfileValidateBeforeCall(authenticationProfileName, authenticationProfileContent, action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, _callback);
        Type localVarReturnType = new TypeToken<CreateAuthenticationProfileResult>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for gETCreateCluster
     * @param clusterIdentifier &lt;p&gt;A unique identifier for the cluster. You use this identifier to refer to the cluster for any subsequent cluster operations such as deleting or modifying. The identifier also appears in the Amazon Redshift console.&lt;/p&gt; &lt;p&gt;Constraints:&lt;/p&gt; &lt;ul&gt; &lt;li&gt; &lt;p&gt;Must contain from 1 to 63 alphanumeric characters or hyphens.&lt;/p&gt; &lt;/li&gt; &lt;li&gt; &lt;p&gt;Alphabetic characters must be lowercase.&lt;/p&gt; &lt;/li&gt; &lt;li&gt; &lt;p&gt;First character must be a letter.&lt;/p&gt; &lt;/li&gt; &lt;li&gt; &lt;p&gt;Cannot end with a hyphen or contain two consecutive hyphens.&lt;/p&gt; &lt;/li&gt; &lt;li&gt; &lt;p&gt;Must be unique for all clusters within an Amazon Web Services account.&lt;/p&gt; &lt;/li&gt; &lt;/ul&gt; &lt;p&gt;Example: &lt;code&gt;myexamplecluster&lt;/code&gt; &lt;/p&gt; (required)
     * @param nodeType &lt;p&gt;The node type to be provisioned for the cluster. For information about node types, go to &lt;a href&#x3D;\&quot;https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html#how-many-nodes\&quot;&gt; Working with Clusters&lt;/a&gt; in the &lt;i&gt;Amazon Redshift Cluster Management Guide&lt;/i&gt;. &lt;/p&gt; &lt;p&gt;Valid Values: &lt;code&gt;ds2.xlarge&lt;/code&gt; | &lt;code&gt;ds2.8xlarge&lt;/code&gt; | &lt;code&gt;dc1.large&lt;/code&gt; | &lt;code&gt;dc1.8xlarge&lt;/code&gt; | &lt;code&gt;dc2.large&lt;/code&gt; | &lt;code&gt;dc2.8xlarge&lt;/code&gt; | &lt;code&gt;ra3.xlplus&lt;/code&gt; | &lt;code&gt;ra3.4xlarge&lt;/code&gt; | &lt;code&gt;ra3.16xlarge&lt;/code&gt; &lt;/p&gt; (required)
     * @param masterUsername &lt;p&gt;The user name associated with the admin user account for the cluster that is being created.&lt;/p&gt; &lt;p&gt;Constraints:&lt;/p&gt; &lt;ul&gt; &lt;li&gt; &lt;p&gt;Must be 1 - 128 alphanumeric characters or hyphens. The user name can&#39;t be &lt;code&gt;PUBLIC&lt;/code&gt;.&lt;/p&gt; &lt;/li&gt; &lt;li&gt; &lt;p&gt;Must contain only lowercase letters, numbers, underscore, plus sign, period (dot), at symbol (@), or hyphen.&lt;/p&gt; &lt;/li&gt; &lt;li&gt; &lt;p&gt;The first character must be a letter.&lt;/p&gt; &lt;/li&gt; &lt;li&gt; &lt;p&gt;Must not contain a colon (:) or a slash (/).&lt;/p&gt; &lt;/li&gt; &lt;li&gt; &lt;p&gt;Cannot be a reserved word. A list of reserved words can be found in &lt;a href&#x3D;\&quot;https://docs.aws.amazon.com/redshift/latest/dg/r_pg_keywords.html\&quot;&gt;Reserved Words&lt;/a&gt; in the Amazon Redshift Database Developer Guide. &lt;/p&gt; &lt;/li&gt; &lt;/ul&gt; (required)
     * @param masterUserPassword &lt;p&gt;The password associated with the admin user account for the cluster that is being created.&lt;/p&gt; &lt;p&gt;Constraints:&lt;/p&gt; &lt;ul&gt; &lt;li&gt; &lt;p&gt;Must be between 8 and 64 characters in length.&lt;/p&gt; &lt;/li&gt; &lt;li&gt; &lt;p&gt;Must contain at least one uppercase letter.&lt;/p&gt; &lt;/li&gt; &lt;li&gt; &lt;p&gt;Must contain at least one lowercase letter.&lt;/p&gt; &lt;/li&gt; &lt;li&gt; &lt;p&gt;Must contain one number.&lt;/p&gt; &lt;/li&gt; &lt;li&gt; &lt;p&gt;Can be any printable ASCII character (ASCII code 33-126) except &lt;code&gt;&#39;&lt;/code&gt; (single quote), &lt;code&gt;\&quot;&lt;/code&gt; (double quote), &lt;code&gt;\\&lt;/code&gt;, &lt;code&gt;/&lt;/code&gt;, or &lt;code&gt;@&lt;/code&gt;.&lt;/p&gt; &lt;/li&gt; &lt;/ul&gt; (required)
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param dbName &lt;p&gt;The name of the first database to be created when the cluster is created.&lt;/p&gt; &lt;p&gt;To create additional databases after the cluster is created, connect to the cluster with a SQL client and use SQL commands to create a database. For more information, go to &lt;a href&#x3D;\&quot;https://docs.aws.amazon.com/redshift/latest/dg/t_creating_database.html\&quot;&gt;Create a Database&lt;/a&gt; in the Amazon Redshift Database Developer Guide. &lt;/p&gt; &lt;p&gt;Default: &lt;code&gt;dev&lt;/code&gt; &lt;/p&gt; &lt;p&gt;Constraints:&lt;/p&gt; &lt;ul&gt; &lt;li&gt; &lt;p&gt;Must contain 1 to 64 alphanumeric characters.&lt;/p&gt; &lt;/li&gt; &lt;li&gt; &lt;p&gt;Must contain only lowercase letters.&lt;/p&gt; &lt;/li&gt; &lt;li&gt; &lt;p&gt;Cannot be a word that is reserved by the service. A list of reserved words can be found in &lt;a href&#x3D;\&quot;https://docs.aws.amazon.com/redshift/latest/dg/r_pg_keywords.html\&quot;&gt;Reserved Words&lt;/a&gt; in the Amazon Redshift Database Developer Guide. &lt;/p&gt; &lt;/li&gt; &lt;/ul&gt; (optional)
     * @param clusterType &lt;p&gt;The type of the cluster. When cluster type is specified as&lt;/p&gt; &lt;ul&gt; &lt;li&gt; &lt;p&gt; &lt;code&gt;single-node&lt;/code&gt;, the &lt;b&gt;NumberOfNodes&lt;/b&gt; parameter is not required.&lt;/p&gt; &lt;/li&gt; &lt;li&gt; &lt;p&gt; &lt;code&gt;multi-node&lt;/code&gt;, the &lt;b&gt;NumberOfNodes&lt;/b&gt; parameter is required.&lt;/p&gt; &lt;/li&gt; &lt;/ul&gt; &lt;p&gt;Valid Values: &lt;code&gt;multi-node&lt;/code&gt; | &lt;code&gt;single-node&lt;/code&gt; &lt;/p&gt; &lt;p&gt;Default: &lt;code&gt;multi-node&lt;/code&gt; &lt;/p&gt; (optional)
     * @param clusterSecurityGroups &lt;p&gt;A list of security groups to be associated with this cluster.&lt;/p&gt; &lt;p&gt;Default: The default cluster security group for Amazon Redshift.&lt;/p&gt; (optional)
     * @param vpcSecurityGroupIds &lt;p&gt;A list of Virtual Private Cloud (VPC) security groups to be associated with the cluster.&lt;/p&gt; &lt;p&gt;Default: The default VPC security group is associated with the cluster.&lt;/p&gt; (optional)
     * @param clusterSubnetGroupName &lt;p&gt;The name of a cluster subnet group to be associated with this cluster.&lt;/p&gt; &lt;p&gt;If this parameter is not provided the resulting cluster will be deployed outside virtual private cloud (VPC).&lt;/p&gt; (optional)
     * @param availabilityZone &lt;p&gt;The EC2 Availability Zone (AZ) in which you want Amazon Redshift to provision the cluster. For example, if you have several EC2 instances running in a specific Availability Zone, then you might want the cluster to be provisioned in the same zone in order to decrease network latency.&lt;/p&gt; &lt;p&gt;Default: A random, system-chosen Availability Zone in the region that is specified by the endpoint.&lt;/p&gt; &lt;p&gt;Example: &lt;code&gt;us-east-2d&lt;/code&gt; &lt;/p&gt; &lt;p&gt;Constraint: The specified Availability Zone must be in the same region as the current endpoint.&lt;/p&gt; (optional)
     * @param preferredMaintenanceWindow &lt;p&gt;The weekly time range (in UTC) during which automated cluster maintenance can occur.&lt;/p&gt; &lt;p&gt; Format: &lt;code&gt;ddd:hh24:mi-ddd:hh24:mi&lt;/code&gt; &lt;/p&gt; &lt;p&gt; Default: A 30-minute window selected at random from an 8-hour block of time per region, occurring on a random day of the week. For more information about the time blocks for each region, see &lt;a href&#x3D;\&quot;https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html#rs-maintenance-windows\&quot;&gt;Maintenance Windows&lt;/a&gt; in Amazon Redshift Cluster Management Guide.&lt;/p&gt; &lt;p&gt;Valid Days: Mon | Tue | Wed | Thu | Fri | Sat | Sun&lt;/p&gt; &lt;p&gt;Constraints: Minimum 30-minute window.&lt;/p&gt; (optional)
     * @param clusterParameterGroupName &lt;p&gt;The name of the parameter group to be associated with this cluster.&lt;/p&gt; &lt;p&gt;Default: The default Amazon Redshift cluster parameter group. For information about the default parameter group, go to &lt;a href&#x3D;\&quot;https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-parameter-groups.html\&quot;&gt;Working with Amazon Redshift Parameter Groups&lt;/a&gt; &lt;/p&gt; &lt;p&gt;Constraints:&lt;/p&gt; &lt;ul&gt; &lt;li&gt; &lt;p&gt;Must be 1 to 255 alphanumeric characters or hyphens.&lt;/p&gt; &lt;/li&gt; &lt;li&gt; &lt;p&gt;First character must be a letter.&lt;/p&gt; &lt;/li&gt; &lt;li&gt; &lt;p&gt;Cannot end with a hyphen or contain two consecutive hyphens.&lt;/p&gt; &lt;/li&gt; &lt;/ul&gt; (optional)
     * @param automatedSnapshotRetentionPeriod &lt;p&gt;The number of days that automated snapshots are retained. If the value is 0, automated snapshots are disabled. Even if automated snapshots are disabled, you can still create manual snapshots when you want with &lt;a&gt;CreateClusterSnapshot&lt;/a&gt;. &lt;/p&gt; &lt;p&gt;You can&#39;t disable automated snapshots for RA3 node types. Set the automated retention period from 1-35 days.&lt;/p&gt; &lt;p&gt;Default: &lt;code&gt;1&lt;/code&gt; &lt;/p&gt; &lt;p&gt;Constraints: Must be a value from 0 to 35.&lt;/p&gt; (optional)
     * @param manualSnapshotRetentionPeriod &lt;p&gt;The default number of days to retain a manual snapshot. If the value is -1, the snapshot is retained indefinitely. This setting doesn&#39;t change the retention period of existing snapshots.&lt;/p&gt; &lt;p&gt;The value must be either -1 or an integer between 1 and 3,653.&lt;/p&gt; (optional)
     * @param port &lt;p&gt;The port number on which the cluster accepts incoming connections.&lt;/p&gt; &lt;p&gt;The cluster is accessible only via the JDBC and ODBC connection strings. Part of the connection string requires the port on which the cluster will listen for incoming connections.&lt;/p&gt; &lt;p&gt;Default: &lt;code&gt;5439&lt;/code&gt; &lt;/p&gt; &lt;p&gt;Valid Values: &lt;code&gt;1150-65535&lt;/code&gt; &lt;/p&gt; (optional)
     * @param clusterVersion &lt;p&gt;The version of the Amazon Redshift engine software that you want to deploy on the cluster.&lt;/p&gt; &lt;p&gt;The version selected runs on all the nodes in the cluster.&lt;/p&gt; &lt;p&gt;Constraints: Only version 1.0 is currently available.&lt;/p&gt; &lt;p&gt;Example: &lt;code&gt;1.0&lt;/code&gt; &lt;/p&gt; (optional)
     * @param allowVersionUpgrade &lt;p&gt;If &lt;code&gt;true&lt;/code&gt;, major version upgrades can be applied during the maintenance window to the Amazon Redshift engine that is running on the cluster.&lt;/p&gt; &lt;p&gt;When a new major version of the Amazon Redshift engine is released, you can request that the service automatically apply upgrades during the maintenance window to the Amazon Redshift engine that is running on your cluster.&lt;/p&gt; &lt;p&gt;Default: &lt;code&gt;true&lt;/code&gt; &lt;/p&gt; (optional)
     * @param numberOfNodes &lt;p&gt;The number of compute nodes in the cluster. This parameter is required when the &lt;b&gt;ClusterType&lt;/b&gt; parameter is specified as &lt;code&gt;multi-node&lt;/code&gt;. &lt;/p&gt; &lt;p&gt;For information about determining how many nodes you need, go to &lt;a href&#x3D;\&quot;https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html#how-many-nodes\&quot;&gt; Working with Clusters&lt;/a&gt; in the &lt;i&gt;Amazon Redshift Cluster Management Guide&lt;/i&gt;. &lt;/p&gt; &lt;p&gt;If you don&#39;t specify this parameter, you get a single-node cluster. When requesting a multi-node cluster, you must specify the number of nodes that you want in the cluster.&lt;/p&gt; &lt;p&gt;Default: &lt;code&gt;1&lt;/code&gt; &lt;/p&gt; &lt;p&gt;Constraints: Value must be at least 1 and no more than 100.&lt;/p&gt; (optional)
     * @param publiclyAccessible If &lt;code&gt;true&lt;/code&gt;, the cluster can be accessed from a public network.  (optional)
     * @param encrypted &lt;p&gt;If &lt;code&gt;true&lt;/code&gt;, the data in the cluster is encrypted at rest. &lt;/p&gt; &lt;p&gt;Default: false&lt;/p&gt; (optional)
     * @param hsmClientCertificateIdentifier Specifies the name of the HSM client certificate the Amazon Redshift cluster uses to retrieve the data encryption keys stored in an HSM. (optional)
     * @param hsmConfigurationIdentifier Specifies the name of the HSM configuration that contains the information the Amazon Redshift cluster can use to retrieve and store keys in an HSM. (optional)
     * @param elasticIp &lt;p&gt;The Elastic IP (EIP) address for the cluster.&lt;/p&gt; &lt;p&gt;Constraints: The cluster must be provisioned in EC2-VPC and publicly-accessible through an Internet gateway. Don&#39;t specify the Elastic IP address for a publicly accessible cluster with availability zone relocation turned on. For more information about provisioning clusters in EC2-VPC, go to &lt;a href&#x3D;\&quot;https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html#cluster-platforms\&quot;&gt;Supported Platforms to Launch Your Cluster&lt;/a&gt; in the Amazon Redshift Cluster Management Guide.&lt;/p&gt; (optional)
     * @param tags A list of tag instances. (optional)
     * @param kmsKeyId The Key Management Service (KMS) key ID of the encryption key that you want to use to encrypt data in the cluster. (optional)
     * @param enhancedVpcRouting &lt;p&gt;An option that specifies whether to create the cluster with enhanced VPC routing enabled. To create a cluster that uses enhanced VPC routing, the cluster must be in a VPC. For more information, see &lt;a href&#x3D;\&quot;https://docs.aws.amazon.com/redshift/latest/mgmt/enhanced-vpc-routing.html\&quot;&gt;Enhanced VPC Routing&lt;/a&gt; in the Amazon Redshift Cluster Management Guide.&lt;/p&gt; &lt;p&gt;If this option is &lt;code&gt;true&lt;/code&gt;, enhanced VPC routing is enabled. &lt;/p&gt; &lt;p&gt;Default: false&lt;/p&gt; (optional)
     * @param additionalInfo Reserved. (optional)
     * @param iamRoles &lt;p&gt;A list of Identity and Access Management (IAM) roles that can be used by the cluster to access other Amazon Web Services services. You must supply the IAM roles in their Amazon Resource Name (ARN) format. &lt;/p&gt; &lt;p&gt;The maximum number of IAM roles that you can associate is subject to a quota. For more information, go to &lt;a href&#x3D;\&quot;https://docs.aws.amazon.com/redshift/latest/mgmt/amazon-redshift-limits.html\&quot;&gt;Quotas and limits&lt;/a&gt; in the &lt;i&gt;Amazon Redshift Cluster Management Guide&lt;/i&gt;.&lt;/p&gt; (optional)
     * @param maintenanceTrackName An optional parameter for the name of the maintenance track for the cluster. If you don&#39;t provide a maintenance track name, the cluster is assigned to the &lt;code&gt;current&lt;/code&gt; track. (optional)
     * @param snapshotScheduleIdentifier A unique identifier for the snapshot schedule. (optional)
     * @param availabilityZoneRelocation The option to enable relocation for an Amazon Redshift cluster between Availability Zones after the cluster is created. (optional)
     * @param aquaConfigurationStatus This parameter is retired. It does not set the AQUA configuration status. Amazon Redshift automatically determines whether to use AQUA (Advanced Query Accelerator). (optional)
     * @param defaultIamRoleArn The Amazon Resource Name (ARN) for the IAM role that was set as default for the cluster when the cluster was created.  (optional)
     * @param loadSampleData A flag that specifies whether to load sample data once the cluster is created. (optional)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> ClusterAlreadyExistsFault </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> InsufficientClusterCapacityFault </td><td>  -  </td></tr>
        <tr><td> 482 </td><td> ClusterParameterGroupNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 483 </td><td> ClusterSecurityGroupNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 484 </td><td> ClusterQuotaExceededFault </td><td>  -  </td></tr>
        <tr><td> 485 </td><td> NumberOfNodesQuotaExceededFault </td><td>  -  </td></tr>
        <tr><td> 486 </td><td> NumberOfNodesPerClusterLimitExceededFault </td><td>  -  </td></tr>
        <tr><td> 487 </td><td> ClusterSubnetGroupNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 488 </td><td> InvalidVPCNetworkStateFault </td><td>  -  </td></tr>
        <tr><td> 489 </td><td> InvalidClusterSubnetGroupStateFault </td><td>  -  </td></tr>
        <tr><td> 490 </td><td> InvalidSubnet </td><td>  -  </td></tr>
        <tr><td> 491 </td><td> UnauthorizedOperation </td><td>  -  </td></tr>
        <tr><td> 492 </td><td> HsmClientCertificateNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 493 </td><td> HsmConfigurationNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 494 </td><td> InvalidElasticIpFault </td><td>  -  </td></tr>
        <tr><td> 495 </td><td> TagLimitExceededFault </td><td>  -  </td></tr>
        <tr><td> 496 </td><td> InvalidTagFault </td><td>  -  </td></tr>
        <tr><td> 497 </td><td> LimitExceededFault </td><td>  -  </td></tr>
        <tr><td> 498 </td><td> DependentServiceRequestThrottlingFault </td><td>  -  </td></tr>
        <tr><td> 499 </td><td> InvalidClusterTrackFault </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> SnapshotScheduleNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 501 </td><td> InvalidRetentionPeriodFault </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call gETCreateClusterCall(String clusterIdentifier, String nodeType, String masterUsername, String masterUserPassword, String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, String dbName, String clusterType, List<String> clusterSecurityGroups, List<String> vpcSecurityGroupIds, String clusterSubnetGroupName, String availabilityZone, String preferredMaintenanceWindow, String clusterParameterGroupName, Integer automatedSnapshotRetentionPeriod, Integer manualSnapshotRetentionPeriod, Integer port, String clusterVersion, Boolean allowVersionUpgrade, Integer numberOfNodes, Boolean publiclyAccessible, Boolean encrypted, String hsmClientCertificateIdentifier, String hsmConfigurationIdentifier, String elasticIp, List<GETCreateClusterTagsParameterInner> tags, String kmsKeyId, Boolean enhancedVpcRouting, String additionalInfo, List<String> iamRoles, String maintenanceTrackName, String snapshotScheduleIdentifier, Boolean availabilityZoneRelocation, String aquaConfigurationStatus, String defaultIamRoleArn, String loadSampleData, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/#Action=CreateCluster";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (dbName != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("DBName", dbName));
        }

        if (clusterIdentifier != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("ClusterIdentifier", clusterIdentifier));
        }

        if (clusterType != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("ClusterType", clusterType));
        }

        if (nodeType != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("NodeType", nodeType));
        }

        if (masterUsername != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("MasterUsername", masterUsername));
        }

        if (masterUserPassword != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("MasterUserPassword", masterUserPassword));
        }

        if (clusterSecurityGroups != null) {
            localVarCollectionQueryParams.addAll(localVarApiClient.parameterToPairs("multi", "ClusterSecurityGroups", clusterSecurityGroups));
        }

        if (vpcSecurityGroupIds != null) {
            localVarCollectionQueryParams.addAll(localVarApiClient.parameterToPairs("multi", "VpcSecurityGroupIds", vpcSecurityGroupIds));
        }

        if (clusterSubnetGroupName != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("ClusterSubnetGroupName", clusterSubnetGroupName));
        }

        if (availabilityZone != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("AvailabilityZone", availabilityZone));
        }

        if (preferredMaintenanceWindow != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("PreferredMaintenanceWindow", preferredMaintenanceWindow));
        }

        if (clusterParameterGroupName != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("ClusterParameterGroupName", clusterParameterGroupName));
        }

        if (automatedSnapshotRetentionPeriod != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("AutomatedSnapshotRetentionPeriod", automatedSnapshotRetentionPeriod));
        }

        if (manualSnapshotRetentionPeriod != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("ManualSnapshotRetentionPeriod", manualSnapshotRetentionPeriod));
        }

        if (port != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("Port", port));
        }

        if (clusterVersion != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("ClusterVersion", clusterVersion));
        }

        if (allowVersionUpgrade != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("AllowVersionUpgrade", allowVersionUpgrade));
        }

        if (numberOfNodes != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("NumberOfNodes", numberOfNodes));
        }

        if (publiclyAccessible != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("PubliclyAccessible", publiclyAccessible));
        }

        if (encrypted != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("Encrypted", encrypted));
        }

        if (hsmClientCertificateIdentifier != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("HsmClientCertificateIdentifier", hsmClientCertificateIdentifier));
        }

        if (hsmConfigurationIdentifier != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("HsmConfigurationIdentifier", hsmConfigurationIdentifier));
        }

        if (elasticIp != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("ElasticIp", elasticIp));
        }

        if (tags != null) {
            localVarCollectionQueryParams.addAll(localVarApiClient.parameterToPairs("multi", "Tags", tags));
        }

        if (kmsKeyId != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("KmsKeyId", kmsKeyId));
        }

        if (enhancedVpcRouting != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("EnhancedVpcRouting", enhancedVpcRouting));
        }

        if (additionalInfo != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("AdditionalInfo", additionalInfo));
        }

        if (iamRoles != null) {
            localVarCollectionQueryParams.addAll(localVarApiClient.parameterToPairs("multi", "IamRoles", iamRoles));
        }

        if (maintenanceTrackName != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("MaintenanceTrackName", maintenanceTrackName));
        }

        if (snapshotScheduleIdentifier != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("SnapshotScheduleIdentifier", snapshotScheduleIdentifier));
        }

        if (availabilityZoneRelocation != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("AvailabilityZoneRelocation", availabilityZoneRelocation));
        }

        if (aquaConfigurationStatus != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("AquaConfigurationStatus", aquaConfigurationStatus));
        }

        if (defaultIamRoleArn != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("DefaultIamRoleArn", defaultIamRoleArn));
        }

        if (loadSampleData != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("LoadSampleData", loadSampleData));
        }

        if (action != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("Action", action));
        }

        if (version != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("Version", version));
        }

        if (xAmzContentSha256 != null) {
            localVarHeaderParams.put("X-Amz-Content-Sha256", localVarApiClient.parameterToString(xAmzContentSha256));
        }

        if (xAmzDate != null) {
            localVarHeaderParams.put("X-Amz-Date", localVarApiClient.parameterToString(xAmzDate));
        }

        if (xAmzAlgorithm != null) {
            localVarHeaderParams.put("X-Amz-Algorithm", localVarApiClient.parameterToString(xAmzAlgorithm));
        }

        if (xAmzCredential != null) {
            localVarHeaderParams.put("X-Amz-Credential", localVarApiClient.parameterToString(xAmzCredential));
        }

        if (xAmzSecurityToken != null) {
            localVarHeaderParams.put("X-Amz-Security-Token", localVarApiClient.parameterToString(xAmzSecurityToken));
        }

        if (xAmzSignature != null) {
            localVarHeaderParams.put("X-Amz-Signature", localVarApiClient.parameterToString(xAmzSignature));
        }

        if (xAmzSignedHeaders != null) {
            localVarHeaderParams.put("X-Amz-SignedHeaders", localVarApiClient.parameterToString(xAmzSignedHeaders));
        }

        final String[] localVarAccepts = {
            "text/xml"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "hmac" };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call gETCreateClusterValidateBeforeCall(String clusterIdentifier, String nodeType, String masterUsername, String masterUserPassword, String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, String dbName, String clusterType, List<String> clusterSecurityGroups, List<String> vpcSecurityGroupIds, String clusterSubnetGroupName, String availabilityZone, String preferredMaintenanceWindow, String clusterParameterGroupName, Integer automatedSnapshotRetentionPeriod, Integer manualSnapshotRetentionPeriod, Integer port, String clusterVersion, Boolean allowVersionUpgrade, Integer numberOfNodes, Boolean publiclyAccessible, Boolean encrypted, String hsmClientCertificateIdentifier, String hsmConfigurationIdentifier, String elasticIp, List<GETCreateClusterTagsParameterInner> tags, String kmsKeyId, Boolean enhancedVpcRouting, String additionalInfo, List<String> iamRoles, String maintenanceTrackName, String snapshotScheduleIdentifier, Boolean availabilityZoneRelocation, String aquaConfigurationStatus, String defaultIamRoleArn, String loadSampleData, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'clusterIdentifier' is set
        if (clusterIdentifier == null) {
            throw new ApiException("Missing the required parameter 'clusterIdentifier' when calling gETCreateCluster(Async)");
        }

        // verify the required parameter 'nodeType' is set
        if (nodeType == null) {
            throw new ApiException("Missing the required parameter 'nodeType' when calling gETCreateCluster(Async)");
        }

        // verify the required parameter 'masterUsername' is set
        if (masterUsername == null) {
            throw new ApiException("Missing the required parameter 'masterUsername' when calling gETCreateCluster(Async)");
        }

        // verify the required parameter 'masterUserPassword' is set
        if (masterUserPassword == null) {
            throw new ApiException("Missing the required parameter 'masterUserPassword' when calling gETCreateCluster(Async)");
        }

        // verify the required parameter 'action' is set
        if (action == null) {
            throw new ApiException("Missing the required parameter 'action' when calling gETCreateCluster(Async)");
        }

        // verify the required parameter 'version' is set
        if (version == null) {
            throw new ApiException("Missing the required parameter 'version' when calling gETCreateCluster(Async)");
        }

        return gETCreateClusterCall(clusterIdentifier, nodeType, masterUsername, masterUserPassword, action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, dbName, clusterType, clusterSecurityGroups, vpcSecurityGroupIds, clusterSubnetGroupName, availabilityZone, preferredMaintenanceWindow, clusterParameterGroupName, automatedSnapshotRetentionPeriod, manualSnapshotRetentionPeriod, port, clusterVersion, allowVersionUpgrade, numberOfNodes, publiclyAccessible, encrypted, hsmClientCertificateIdentifier, hsmConfigurationIdentifier, elasticIp, tags, kmsKeyId, enhancedVpcRouting, additionalInfo, iamRoles, maintenanceTrackName, snapshotScheduleIdentifier, availabilityZoneRelocation, aquaConfigurationStatus, defaultIamRoleArn, loadSampleData, _callback);

    }

    /**
     * 
     * &lt;p&gt;Creates a new cluster with the specified parameters.&lt;/p&gt; &lt;p&gt;To create a cluster in Virtual Private Cloud (VPC), you must provide a cluster subnet group name. The cluster subnet group identifies the subnets of your VPC that Amazon Redshift uses when creating the cluster. For more information about managing clusters, go to &lt;a href&#x3D;\&quot;https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html\&quot;&gt;Amazon Redshift Clusters&lt;/a&gt; in the &lt;i&gt;Amazon Redshift Cluster Management Guide&lt;/i&gt;.&lt;/p&gt;
     * @param clusterIdentifier &lt;p&gt;A unique identifier for the cluster. You use this identifier to refer to the cluster for any subsequent cluster operations such as deleting or modifying. The identifier also appears in the Amazon Redshift console.&lt;/p&gt; &lt;p&gt;Constraints:&lt;/p&gt; &lt;ul&gt; &lt;li&gt; &lt;p&gt;Must contain from 1 to 63 alphanumeric characters or hyphens.&lt;/p&gt; &lt;/li&gt; &lt;li&gt; &lt;p&gt;Alphabetic characters must be lowercase.&lt;/p&gt; &lt;/li&gt; &lt;li&gt; &lt;p&gt;First character must be a letter.&lt;/p&gt; &lt;/li&gt; &lt;li&gt; &lt;p&gt;Cannot end with a hyphen or contain two consecutive hyphens.&lt;/p&gt; &lt;/li&gt; &lt;li&gt; &lt;p&gt;Must be unique for all clusters within an Amazon Web Services account.&lt;/p&gt; &lt;/li&gt; &lt;/ul&gt; &lt;p&gt;Example: &lt;code&gt;myexamplecluster&lt;/code&gt; &lt;/p&gt; (required)
     * @param nodeType &lt;p&gt;The node type to be provisioned for the cluster. For information about node types, go to &lt;a href&#x3D;\&quot;https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html#how-many-nodes\&quot;&gt; Working with Clusters&lt;/a&gt; in the &lt;i&gt;Amazon Redshift Cluster Management Guide&lt;/i&gt;. &lt;/p&gt; &lt;p&gt;Valid Values: &lt;code&gt;ds2.xlarge&lt;/code&gt; | &lt;code&gt;ds2.8xlarge&lt;/code&gt; | &lt;code&gt;dc1.large&lt;/code&gt; | &lt;code&gt;dc1.8xlarge&lt;/code&gt; | &lt;code&gt;dc2.large&lt;/code&gt; | &lt;code&gt;dc2.8xlarge&lt;/code&gt; | &lt;code&gt;ra3.xlplus&lt;/code&gt; | &lt;code&gt;ra3.4xlarge&lt;/code&gt; | &lt;code&gt;ra3.16xlarge&lt;/code&gt; &lt;/p&gt; (required)
     * @param masterUsername &lt;p&gt;The user name associated with the admin user account for the cluster that is being created.&lt;/p&gt; &lt;p&gt;Constraints:&lt;/p&gt; &lt;ul&gt; &lt;li&gt; &lt;p&gt;Must be 1 - 128 alphanumeric characters or hyphens. The user name can&#39;t be &lt;code&gt;PUBLIC&lt;/code&gt;.&lt;/p&gt; &lt;/li&gt; &lt;li&gt; &lt;p&gt;Must contain only lowercase letters, numbers, underscore, plus sign, period (dot), at symbol (@), or hyphen.&lt;/p&gt; &lt;/li&gt; &lt;li&gt; &lt;p&gt;The first character must be a letter.&lt;/p&gt; &lt;/li&gt; &lt;li&gt; &lt;p&gt;Must not contain a colon (:) or a slash (/).&lt;/p&gt; &lt;/li&gt; &lt;li&gt; &lt;p&gt;Cannot be a reserved word. A list of reserved words can be found in &lt;a href&#x3D;\&quot;https://docs.aws.amazon.com/redshift/latest/dg/r_pg_keywords.html\&quot;&gt;Reserved Words&lt;/a&gt; in the Amazon Redshift Database Developer Guide. &lt;/p&gt; &lt;/li&gt; &lt;/ul&gt; (required)
     * @param masterUserPassword &lt;p&gt;The password associated with the admin user account for the cluster that is being created.&lt;/p&gt; &lt;p&gt;Constraints:&lt;/p&gt; &lt;ul&gt; &lt;li&gt; &lt;p&gt;Must be between 8 and 64 characters in length.&lt;/p&gt; &lt;/li&gt; &lt;li&gt; &lt;p&gt;Must contain at least one uppercase letter.&lt;/p&gt; &lt;/li&gt; &lt;li&gt; &lt;p&gt;Must contain at least one lowercase letter.&lt;/p&gt; &lt;/li&gt; &lt;li&gt; &lt;p&gt;Must contain one number.&lt;/p&gt; &lt;/li&gt; &lt;li&gt; &lt;p&gt;Can be any printable ASCII character (ASCII code 33-126) except &lt;code&gt;&#39;&lt;/code&gt; (single quote), &lt;code&gt;\&quot;&lt;/code&gt; (double quote), &lt;code&gt;\\&lt;/code&gt;, &lt;code&gt;/&lt;/code&gt;, or &lt;code&gt;@&lt;/code&gt;.&lt;/p&gt; &lt;/li&gt; &lt;/ul&gt; (required)
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param dbName &lt;p&gt;The name of the first database to be created when the cluster is created.&lt;/p&gt; &lt;p&gt;To create additional databases after the cluster is created, connect to the cluster with a SQL client and use SQL commands to create a database. For more information, go to &lt;a href&#x3D;\&quot;https://docs.aws.amazon.com/redshift/latest/dg/t_creating_database.html\&quot;&gt;Create a Database&lt;/a&gt; in the Amazon Redshift Database Developer Guide. &lt;/p&gt; &lt;p&gt;Default: &lt;code&gt;dev&lt;/code&gt; &lt;/p&gt; &lt;p&gt;Constraints:&lt;/p&gt; &lt;ul&gt; &lt;li&gt; &lt;p&gt;Must contain 1 to 64 alphanumeric characters.&lt;/p&gt; &lt;/li&gt; &lt;li&gt; &lt;p&gt;Must contain only lowercase letters.&lt;/p&gt; &lt;/li&gt; &lt;li&gt; &lt;p&gt;Cannot be a word that is reserved by the service. A list of reserved words can be found in &lt;a href&#x3D;\&quot;https://docs.aws.amazon.com/redshift/latest/dg/r_pg_keywords.html\&quot;&gt;Reserved Words&lt;/a&gt; in the Amazon Redshift Database Developer Guide. &lt;/p&gt; &lt;/li&gt; &lt;/ul&gt; (optional)
     * @param clusterType &lt;p&gt;The type of the cluster. When cluster type is specified as&lt;/p&gt; &lt;ul&gt; &lt;li&gt; &lt;p&gt; &lt;code&gt;single-node&lt;/code&gt;, the &lt;b&gt;NumberOfNodes&lt;/b&gt; parameter is not required.&lt;/p&gt; &lt;/li&gt; &lt;li&gt; &lt;p&gt; &lt;code&gt;multi-node&lt;/code&gt;, the &lt;b&gt;NumberOfNodes&lt;/b&gt; parameter is required.&lt;/p&gt; &lt;/li&gt; &lt;/ul&gt; &lt;p&gt;Valid Values: &lt;code&gt;multi-node&lt;/code&gt; | &lt;code&gt;single-node&lt;/code&gt; &lt;/p&gt; &lt;p&gt;Default: &lt;code&gt;multi-node&lt;/code&gt; &lt;/p&gt; (optional)
     * @param clusterSecurityGroups &lt;p&gt;A list of security groups to be associated with this cluster.&lt;/p&gt; &lt;p&gt;Default: The default cluster security group for Amazon Redshift.&lt;/p&gt; (optional)
     * @param vpcSecurityGroupIds &lt;p&gt;A list of Virtual Private Cloud (VPC) security groups to be associated with the cluster.&lt;/p&gt; &lt;p&gt;Default: The default VPC security group is associated with the cluster.&lt;/p&gt; (optional)
     * @param clusterSubnetGroupName &lt;p&gt;The name of a cluster subnet group to be associated with this cluster.&lt;/p&gt; &lt;p&gt;If this parameter is not provided the resulting cluster will be deployed outside virtual private cloud (VPC).&lt;/p&gt; (optional)
     * @param availabilityZone &lt;p&gt;The EC2 Availability Zone (AZ) in which you want Amazon Redshift to provision the cluster. For example, if you have several EC2 instances running in a specific Availability Zone, then you might want the cluster to be provisioned in the same zone in order to decrease network latency.&lt;/p&gt; &lt;p&gt;Default: A random, system-chosen Availability Zone in the region that is specified by the endpoint.&lt;/p&gt; &lt;p&gt;Example: &lt;code&gt;us-east-2d&lt;/code&gt; &lt;/p&gt; &lt;p&gt;Constraint: The specified Availability Zone must be in the same region as the current endpoint.&lt;/p&gt; (optional)
     * @param preferredMaintenanceWindow &lt;p&gt;The weekly time range (in UTC) during which automated cluster maintenance can occur.&lt;/p&gt; &lt;p&gt; Format: &lt;code&gt;ddd:hh24:mi-ddd:hh24:mi&lt;/code&gt; &lt;/p&gt; &lt;p&gt; Default: A 30-minute window selected at random from an 8-hour block of time per region, occurring on a random day of the week. For more information about the time blocks for each region, see &lt;a href&#x3D;\&quot;https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html#rs-maintenance-windows\&quot;&gt;Maintenance Windows&lt;/a&gt; in Amazon Redshift Cluster Management Guide.&lt;/p&gt; &lt;p&gt;Valid Days: Mon | Tue | Wed | Thu | Fri | Sat | Sun&lt;/p&gt; &lt;p&gt;Constraints: Minimum 30-minute window.&lt;/p&gt; (optional)
     * @param clusterParameterGroupName &lt;p&gt;The name of the parameter group to be associated with this cluster.&lt;/p&gt; &lt;p&gt;Default: The default Amazon Redshift cluster parameter group. For information about the default parameter group, go to &lt;a href&#x3D;\&quot;https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-parameter-groups.html\&quot;&gt;Working with Amazon Redshift Parameter Groups&lt;/a&gt; &lt;/p&gt; &lt;p&gt;Constraints:&lt;/p&gt; &lt;ul&gt; &lt;li&gt; &lt;p&gt;Must be 1 to 255 alphanumeric characters or hyphens.&lt;/p&gt; &lt;/li&gt; &lt;li&gt; &lt;p&gt;First character must be a letter.&lt;/p&gt; &lt;/li&gt; &lt;li&gt; &lt;p&gt;Cannot end with a hyphen or contain two consecutive hyphens.&lt;/p&gt; &lt;/li&gt; &lt;/ul&gt; (optional)
     * @param automatedSnapshotRetentionPeriod &lt;p&gt;The number of days that automated snapshots are retained. If the value is 0, automated snapshots are disabled. Even if automated snapshots are disabled, you can still create manual snapshots when you want with &lt;a&gt;CreateClusterSnapshot&lt;/a&gt;. &lt;/p&gt; &lt;p&gt;You can&#39;t disable automated snapshots for RA3 node types. Set the automated retention period from 1-35 days.&lt;/p&gt; &lt;p&gt;Default: &lt;code&gt;1&lt;/code&gt; &lt;/p&gt; &lt;p&gt;Constraints: Must be a value from 0 to 35.&lt;/p&gt; (optional)
     * @param manualSnapshotRetentionPeriod &lt;p&gt;The default number of days to retain a manual snapshot. If the value is -1, the snapshot is retained indefinitely. This setting doesn&#39;t change the retention period of existing snapshots.&lt;/p&gt; &lt;p&gt;The value must be either -1 or an integer between 1 and 3,653.&lt;/p&gt; (optional)
     * @param port &lt;p&gt;The port number on which the cluster accepts incoming connections.&lt;/p&gt; &lt;p&gt;The cluster is accessible only via the JDBC and ODBC connection strings. Part of the connection string requires the port on which the cluster will listen for incoming connections.&lt;/p&gt; &lt;p&gt;Default: &lt;code&gt;5439&lt;/code&gt; &lt;/p&gt; &lt;p&gt;Valid Values: &lt;code&gt;1150-65535&lt;/code&gt; &lt;/p&gt; (optional)
     * @param clusterVersion &lt;p&gt;The version of the Amazon Redshift engine software that you want to deploy on the cluster.&lt;/p&gt; &lt;p&gt;The version selected runs on all the nodes in the cluster.&lt;/p&gt; &lt;p&gt;Constraints: Only version 1.0 is currently available.&lt;/p&gt; &lt;p&gt;Example: &lt;code&gt;1.0&lt;/code&gt; &lt;/p&gt; (optional)
     * @param allowVersionUpgrade &lt;p&gt;If &lt;code&gt;true&lt;/code&gt;, major version upgrades can be applied during the maintenance window to the Amazon Redshift engine that is running on the cluster.&lt;/p&gt; &lt;p&gt;When a new major version of the Amazon Redshift engine is released, you can request that the service automatically apply upgrades during the maintenance window to the Amazon Redshift engine that is running on your cluster.&lt;/p&gt; &lt;p&gt;Default: &lt;code&gt;true&lt;/code&gt; &lt;/p&gt; (optional)
     * @param numberOfNodes &lt;p&gt;The number of compute nodes in the cluster. This parameter is required when the &lt;b&gt;ClusterType&lt;/b&gt; parameter is specified as &lt;code&gt;multi-node&lt;/code&gt;. &lt;/p&gt; &lt;p&gt;For information about determining how many nodes you need, go to &lt;a href&#x3D;\&quot;https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html#how-many-nodes\&quot;&gt; Working with Clusters&lt;/a&gt; in the &lt;i&gt;Amazon Redshift Cluster Management Guide&lt;/i&gt;. &lt;/p&gt; &lt;p&gt;If you don&#39;t specify this parameter, you get a single-node cluster. When requesting a multi-node cluster, you must specify the number of nodes that you want in the cluster.&lt;/p&gt; &lt;p&gt;Default: &lt;code&gt;1&lt;/code&gt; &lt;/p&gt; &lt;p&gt;Constraints: Value must be at least 1 and no more than 100.&lt;/p&gt; (optional)
     * @param publiclyAccessible If &lt;code&gt;true&lt;/code&gt;, the cluster can be accessed from a public network.  (optional)
     * @param encrypted &lt;p&gt;If &lt;code&gt;true&lt;/code&gt;, the data in the cluster is encrypted at rest. &lt;/p&gt; &lt;p&gt;Default: false&lt;/p&gt; (optional)
     * @param hsmClientCertificateIdentifier Specifies the name of the HSM client certificate the Amazon Redshift cluster uses to retrieve the data encryption keys stored in an HSM. (optional)
     * @param hsmConfigurationIdentifier Specifies the name of the HSM configuration that contains the information the Amazon Redshift cluster can use to retrieve and store keys in an HSM. (optional)
     * @param elasticIp &lt;p&gt;The Elastic IP (EIP) address for the cluster.&lt;/p&gt; &lt;p&gt;Constraints: The cluster must be provisioned in EC2-VPC and publicly-accessible through an Internet gateway. Don&#39;t specify the Elastic IP address for a publicly accessible cluster with availability zone relocation turned on. For more information about provisioning clusters in EC2-VPC, go to &lt;a href&#x3D;\&quot;https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html#cluster-platforms\&quot;&gt;Supported Platforms to Launch Your Cluster&lt;/a&gt; in the Amazon Redshift Cluster Management Guide.&lt;/p&gt; (optional)
     * @param tags A list of tag instances. (optional)
     * @param kmsKeyId The Key Management Service (KMS) key ID of the encryption key that you want to use to encrypt data in the cluster. (optional)
     * @param enhancedVpcRouting &lt;p&gt;An option that specifies whether to create the cluster with enhanced VPC routing enabled. To create a cluster that uses enhanced VPC routing, the cluster must be in a VPC. For more information, see &lt;a href&#x3D;\&quot;https://docs.aws.amazon.com/redshift/latest/mgmt/enhanced-vpc-routing.html\&quot;&gt;Enhanced VPC Routing&lt;/a&gt; in the Amazon Redshift Cluster Management Guide.&lt;/p&gt; &lt;p&gt;If this option is &lt;code&gt;true&lt;/code&gt;, enhanced VPC routing is enabled. &lt;/p&gt; &lt;p&gt;Default: false&lt;/p&gt; (optional)
     * @param additionalInfo Reserved. (optional)
     * @param iamRoles &lt;p&gt;A list of Identity and Access Management (IAM) roles that can be used by the cluster to access other Amazon Web Services services. You must supply the IAM roles in their Amazon Resource Name (ARN) format. &lt;/p&gt; &lt;p&gt;The maximum number of IAM roles that you can associate is subject to a quota. For more information, go to &lt;a href&#x3D;\&quot;https://docs.aws.amazon.com/redshift/latest/mgmt/amazon-redshift-limits.html\&quot;&gt;Quotas and limits&lt;/a&gt; in the &lt;i&gt;Amazon Redshift Cluster Management Guide&lt;/i&gt;.&lt;/p&gt; (optional)
     * @param maintenanceTrackName An optional parameter for the name of the maintenance track for the cluster. If you don&#39;t provide a maintenance track name, the cluster is assigned to the &lt;code&gt;current&lt;/code&gt; track. (optional)
     * @param snapshotScheduleIdentifier A unique identifier for the snapshot schedule. (optional)
     * @param availabilityZoneRelocation The option to enable relocation for an Amazon Redshift cluster between Availability Zones after the cluster is created. (optional)
     * @param aquaConfigurationStatus This parameter is retired. It does not set the AQUA configuration status. Amazon Redshift automatically determines whether to use AQUA (Advanced Query Accelerator). (optional)
     * @param defaultIamRoleArn The Amazon Resource Name (ARN) for the IAM role that was set as default for the cluster when the cluster was created.  (optional)
     * @param loadSampleData A flag that specifies whether to load sample data once the cluster is created. (optional)
     * @return CreateClusterResult
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> ClusterAlreadyExistsFault </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> InsufficientClusterCapacityFault </td><td>  -  </td></tr>
        <tr><td> 482 </td><td> ClusterParameterGroupNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 483 </td><td> ClusterSecurityGroupNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 484 </td><td> ClusterQuotaExceededFault </td><td>  -  </td></tr>
        <tr><td> 485 </td><td> NumberOfNodesQuotaExceededFault </td><td>  -  </td></tr>
        <tr><td> 486 </td><td> NumberOfNodesPerClusterLimitExceededFault </td><td>  -  </td></tr>
        <tr><td> 487 </td><td> ClusterSubnetGroupNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 488 </td><td> InvalidVPCNetworkStateFault </td><td>  -  </td></tr>
        <tr><td> 489 </td><td> InvalidClusterSubnetGroupStateFault </td><td>  -  </td></tr>
        <tr><td> 490 </td><td> InvalidSubnet </td><td>  -  </td></tr>
        <tr><td> 491 </td><td> UnauthorizedOperation </td><td>  -  </td></tr>
        <tr><td> 492 </td><td> HsmClientCertificateNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 493 </td><td> HsmConfigurationNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 494 </td><td> InvalidElasticIpFault </td><td>  -  </td></tr>
        <tr><td> 495 </td><td> TagLimitExceededFault </td><td>  -  </td></tr>
        <tr><td> 496 </td><td> InvalidTagFault </td><td>  -  </td></tr>
        <tr><td> 497 </td><td> LimitExceededFault </td><td>  -  </td></tr>
        <tr><td> 498 </td><td> DependentServiceRequestThrottlingFault </td><td>  -  </td></tr>
        <tr><td> 499 </td><td> InvalidClusterTrackFault </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> SnapshotScheduleNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 501 </td><td> InvalidRetentionPeriodFault </td><td>  -  </td></tr>
     </table>
     */
    public CreateClusterResult gETCreateCluster(String clusterIdentifier, String nodeType, String masterUsername, String masterUserPassword, String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, String dbName, String clusterType, List<String> clusterSecurityGroups, List<String> vpcSecurityGroupIds, String clusterSubnetGroupName, String availabilityZone, String preferredMaintenanceWindow, String clusterParameterGroupName, Integer automatedSnapshotRetentionPeriod, Integer manualSnapshotRetentionPeriod, Integer port, String clusterVersion, Boolean allowVersionUpgrade, Integer numberOfNodes, Boolean publiclyAccessible, Boolean encrypted, String hsmClientCertificateIdentifier, String hsmConfigurationIdentifier, String elasticIp, List<GETCreateClusterTagsParameterInner> tags, String kmsKeyId, Boolean enhancedVpcRouting, String additionalInfo, List<String> iamRoles, String maintenanceTrackName, String snapshotScheduleIdentifier, Boolean availabilityZoneRelocation, String aquaConfigurationStatus, String defaultIamRoleArn, String loadSampleData) throws ApiException {
        ApiResponse<CreateClusterResult> localVarResp = gETCreateClusterWithHttpInfo(clusterIdentifier, nodeType, masterUsername, masterUserPassword, action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, dbName, clusterType, clusterSecurityGroups, vpcSecurityGroupIds, clusterSubnetGroupName, availabilityZone, preferredMaintenanceWindow, clusterParameterGroupName, automatedSnapshotRetentionPeriod, manualSnapshotRetentionPeriod, port, clusterVersion, allowVersionUpgrade, numberOfNodes, publiclyAccessible, encrypted, hsmClientCertificateIdentifier, hsmConfigurationIdentifier, elasticIp, tags, kmsKeyId, enhancedVpcRouting, additionalInfo, iamRoles, maintenanceTrackName, snapshotScheduleIdentifier, availabilityZoneRelocation, aquaConfigurationStatus, defaultIamRoleArn, loadSampleData);
        return localVarResp.getData();
    }

    /**
     * 
     * &lt;p&gt;Creates a new cluster with the specified parameters.&lt;/p&gt; &lt;p&gt;To create a cluster in Virtual Private Cloud (VPC), you must provide a cluster subnet group name. The cluster subnet group identifies the subnets of your VPC that Amazon Redshift uses when creating the cluster. For more information about managing clusters, go to &lt;a href&#x3D;\&quot;https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html\&quot;&gt;Amazon Redshift Clusters&lt;/a&gt; in the &lt;i&gt;Amazon Redshift Cluster Management Guide&lt;/i&gt;.&lt;/p&gt;
     * @param clusterIdentifier &lt;p&gt;A unique identifier for the cluster. You use this identifier to refer to the cluster for any subsequent cluster operations such as deleting or modifying. The identifier also appears in the Amazon Redshift console.&lt;/p&gt; &lt;p&gt;Constraints:&lt;/p&gt; &lt;ul&gt; &lt;li&gt; &lt;p&gt;Must contain from 1 to 63 alphanumeric characters or hyphens.&lt;/p&gt; &lt;/li&gt; &lt;li&gt; &lt;p&gt;Alphabetic characters must be lowercase.&lt;/p&gt; &lt;/li&gt; &lt;li&gt; &lt;p&gt;First character must be a letter.&lt;/p&gt; &lt;/li&gt; &lt;li&gt; &lt;p&gt;Cannot end with a hyphen or contain two consecutive hyphens.&lt;/p&gt; &lt;/li&gt; &lt;li&gt; &lt;p&gt;Must be unique for all clusters within an Amazon Web Services account.&lt;/p&gt; &lt;/li&gt; &lt;/ul&gt; &lt;p&gt;Example: &lt;code&gt;myexamplecluster&lt;/code&gt; &lt;/p&gt; (required)
     * @param nodeType &lt;p&gt;The node type to be provisioned for the cluster. For information about node types, go to &lt;a href&#x3D;\&quot;https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html#how-many-nodes\&quot;&gt; Working with Clusters&lt;/a&gt; in the &lt;i&gt;Amazon Redshift Cluster Management Guide&lt;/i&gt;. &lt;/p&gt; &lt;p&gt;Valid Values: &lt;code&gt;ds2.xlarge&lt;/code&gt; | &lt;code&gt;ds2.8xlarge&lt;/code&gt; | &lt;code&gt;dc1.large&lt;/code&gt; | &lt;code&gt;dc1.8xlarge&lt;/code&gt; | &lt;code&gt;dc2.large&lt;/code&gt; | &lt;code&gt;dc2.8xlarge&lt;/code&gt; | &lt;code&gt;ra3.xlplus&lt;/code&gt; | &lt;code&gt;ra3.4xlarge&lt;/code&gt; | &lt;code&gt;ra3.16xlarge&lt;/code&gt; &lt;/p&gt; (required)
     * @param masterUsername &lt;p&gt;The user name associated with the admin user account for the cluster that is being created.&lt;/p&gt; &lt;p&gt;Constraints:&lt;/p&gt; &lt;ul&gt; &lt;li&gt; &lt;p&gt;Must be 1 - 128 alphanumeric characters or hyphens. The user name can&#39;t be &lt;code&gt;PUBLIC&lt;/code&gt;.&lt;/p&gt; &lt;/li&gt; &lt;li&gt; &lt;p&gt;Must contain only lowercase letters, numbers, underscore, plus sign, period (dot), at symbol (@), or hyphen.&lt;/p&gt; &lt;/li&gt; &lt;li&gt; &lt;p&gt;The first character must be a letter.&lt;/p&gt; &lt;/li&gt; &lt;li&gt; &lt;p&gt;Must not contain a colon (:) or a slash (/).&lt;/p&gt; &lt;/li&gt; &lt;li&gt; &lt;p&gt;Cannot be a reserved word. A list of reserved words can be found in &lt;a href&#x3D;\&quot;https://docs.aws.amazon.com/redshift/latest/dg/r_pg_keywords.html\&quot;&gt;Reserved Words&lt;/a&gt; in the Amazon Redshift Database Developer Guide. &lt;/p&gt; &lt;/li&gt; &lt;/ul&gt; (required)
     * @param masterUserPassword &lt;p&gt;The password associated with the admin user account for the cluster that is being created.&lt;/p&gt; &lt;p&gt;Constraints:&lt;/p&gt; &lt;ul&gt; &lt;li&gt; &lt;p&gt;Must be between 8 and 64 characters in length.&lt;/p&gt; &lt;/li&gt; &lt;li&gt; &lt;p&gt;Must contain at least one uppercase letter.&lt;/p&gt; &lt;/li&gt; &lt;li&gt; &lt;p&gt;Must contain at least one lowercase letter.&lt;/p&gt; &lt;/li&gt; &lt;li&gt; &lt;p&gt;Must contain one number.&lt;/p&gt; &lt;/li&gt; &lt;li&gt; &lt;p&gt;Can be any printable ASCII character (ASCII code 33-126) except &lt;code&gt;&#39;&lt;/code&gt; (single quote), &lt;code&gt;\&quot;&lt;/code&gt; (double quote), &lt;code&gt;\\&lt;/code&gt;, &lt;code&gt;/&lt;/code&gt;, or &lt;code&gt;@&lt;/code&gt;.&lt;/p&gt; &lt;/li&gt; &lt;/ul&gt; (required)
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param dbName &lt;p&gt;The name of the first database to be created when the cluster is created.&lt;/p&gt; &lt;p&gt;To create additional databases after the cluster is created, connect to the cluster with a SQL client and use SQL commands to create a database. For more information, go to &lt;a href&#x3D;\&quot;https://docs.aws.amazon.com/redshift/latest/dg/t_creating_database.html\&quot;&gt;Create a Database&lt;/a&gt; in the Amazon Redshift Database Developer Guide. &lt;/p&gt; &lt;p&gt;Default: &lt;code&gt;dev&lt;/code&gt; &lt;/p&gt; &lt;p&gt;Constraints:&lt;/p&gt; &lt;ul&gt; &lt;li&gt; &lt;p&gt;Must contain 1 to 64 alphanumeric characters.&lt;/p&gt; &lt;/li&gt; &lt;li&gt; &lt;p&gt;Must contain only lowercase letters.&lt;/p&gt; &lt;/li&gt; &lt;li&gt; &lt;p&gt;Cannot be a word that is reserved by the service. A list of reserved words can be found in &lt;a href&#x3D;\&quot;https://docs.aws.amazon.com/redshift/latest/dg/r_pg_keywords.html\&quot;&gt;Reserved Words&lt;/a&gt; in the Amazon Redshift Database Developer Guide. &lt;/p&gt; &lt;/li&gt; &lt;/ul&gt; (optional)
     * @param clusterType &lt;p&gt;The type of the cluster. When cluster type is specified as&lt;/p&gt; &lt;ul&gt; &lt;li&gt; &lt;p&gt; &lt;code&gt;single-node&lt;/code&gt;, the &lt;b&gt;NumberOfNodes&lt;/b&gt; parameter is not required.&lt;/p&gt; &lt;/li&gt; &lt;li&gt; &lt;p&gt; &lt;code&gt;multi-node&lt;/code&gt;, the &lt;b&gt;NumberOfNodes&lt;/b&gt; parameter is required.&lt;/p&gt; &lt;/li&gt; &lt;/ul&gt; &lt;p&gt;Valid Values: &lt;code&gt;multi-node&lt;/code&gt; | &lt;code&gt;single-node&lt;/code&gt; &lt;/p&gt; &lt;p&gt;Default: &lt;code&gt;multi-node&lt;/code&gt; &lt;/p&gt; (optional)
     * @param clusterSecurityGroups &lt;p&gt;A list of security groups to be associated with this cluster.&lt;/p&gt; &lt;p&gt;Default: The default cluster security group for Amazon Redshift.&lt;/p&gt; (optional)
     * @param vpcSecurityGroupIds &lt;p&gt;A list of Virtual Private Cloud (VPC) security groups to be associated with the cluster.&lt;/p&gt; &lt;p&gt;Default: The default VPC security group is associated with the cluster.&lt;/p&gt; (optional)
     * @param clusterSubnetGroupName &lt;p&gt;The name of a cluster subnet group to be associated with this cluster.&lt;/p&gt; &lt;p&gt;If this parameter is not provided the resulting cluster will be deployed outside virtual private cloud (VPC).&lt;/p&gt; (optional)
     * @param availabilityZone &lt;p&gt;The EC2 Availability Zone (AZ) in which you want Amazon Redshift to provision the cluster. For example, if you have several EC2 instances running in a specific Availability Zone, then you might want the cluster to be provisioned in the same zone in order to decrease network latency.&lt;/p&gt; &lt;p&gt;Default: A random, system-chosen Availability Zone in the region that is specified by the endpoint.&lt;/p&gt; &lt;p&gt;Example: &lt;code&gt;us-east-2d&lt;/code&gt; &lt;/p&gt; &lt;p&gt;Constraint: The specified Availability Zone must be in the same region as the current endpoint.&lt;/p&gt; (optional)
     * @param preferredMaintenanceWindow &lt;p&gt;The weekly time range (in UTC) during which automated cluster maintenance can occur.&lt;/p&gt; &lt;p&gt; Format: &lt;code&gt;ddd:hh24:mi-ddd:hh24:mi&lt;/code&gt; &lt;/p&gt; &lt;p&gt; Default: A 30-minute window selected at random from an 8-hour block of time per region, occurring on a random day of the week. For more information about the time blocks for each region, see &lt;a href&#x3D;\&quot;https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html#rs-maintenance-windows\&quot;&gt;Maintenance Windows&lt;/a&gt; in Amazon Redshift Cluster Management Guide.&lt;/p&gt; &lt;p&gt;Valid Days: Mon | Tue | Wed | Thu | Fri | Sat | Sun&lt;/p&gt; &lt;p&gt;Constraints: Minimum 30-minute window.&lt;/p&gt; (optional)
     * @param clusterParameterGroupName &lt;p&gt;The name of the parameter group to be associated with this cluster.&lt;/p&gt; &lt;p&gt;Default: The default Amazon Redshift cluster parameter group. For information about the default parameter group, go to &lt;a href&#x3D;\&quot;https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-parameter-groups.html\&quot;&gt;Working with Amazon Redshift Parameter Groups&lt;/a&gt; &lt;/p&gt; &lt;p&gt;Constraints:&lt;/p&gt; &lt;ul&gt; &lt;li&gt; &lt;p&gt;Must be 1 to 255 alphanumeric characters or hyphens.&lt;/p&gt; &lt;/li&gt; &lt;li&gt; &lt;p&gt;First character must be a letter.&lt;/p&gt; &lt;/li&gt; &lt;li&gt; &lt;p&gt;Cannot end with a hyphen or contain two consecutive hyphens.&lt;/p&gt; &lt;/li&gt; &lt;/ul&gt; (optional)
     * @param automatedSnapshotRetentionPeriod &lt;p&gt;The number of days that automated snapshots are retained. If the value is 0, automated snapshots are disabled. Even if automated snapshots are disabled, you can still create manual snapshots when you want with &lt;a&gt;CreateClusterSnapshot&lt;/a&gt;. &lt;/p&gt; &lt;p&gt;You can&#39;t disable automated snapshots for RA3 node types. Set the automated retention period from 1-35 days.&lt;/p&gt; &lt;p&gt;Default: &lt;code&gt;1&lt;/code&gt; &lt;/p&gt; &lt;p&gt;Constraints: Must be a value from 0 to 35.&lt;/p&gt; (optional)
     * @param manualSnapshotRetentionPeriod &lt;p&gt;The default number of days to retain a manual snapshot. If the value is -1, the snapshot is retained indefinitely. This setting doesn&#39;t change the retention period of existing snapshots.&lt;/p&gt; &lt;p&gt;The value must be either -1 or an integer between 1 and 3,653.&lt;/p&gt; (optional)
     * @param port &lt;p&gt;The port number on which the cluster accepts incoming connections.&lt;/p&gt; &lt;p&gt;The cluster is accessible only via the JDBC and ODBC connection strings. Part of the connection string requires the port on which the cluster will listen for incoming connections.&lt;/p&gt; &lt;p&gt;Default: &lt;code&gt;5439&lt;/code&gt; &lt;/p&gt; &lt;p&gt;Valid Values: &lt;code&gt;1150-65535&lt;/code&gt; &lt;/p&gt; (optional)
     * @param clusterVersion &lt;p&gt;The version of the Amazon Redshift engine software that you want to deploy on the cluster.&lt;/p&gt; &lt;p&gt;The version selected runs on all the nodes in the cluster.&lt;/p&gt; &lt;p&gt;Constraints: Only version 1.0 is currently available.&lt;/p&gt; &lt;p&gt;Example: &lt;code&gt;1.0&lt;/code&gt; &lt;/p&gt; (optional)
     * @param allowVersionUpgrade &lt;p&gt;If &lt;code&gt;true&lt;/code&gt;, major version upgrades can be applied during the maintenance window to the Amazon Redshift engine that is running on the cluster.&lt;/p&gt; &lt;p&gt;When a new major version of the Amazon Redshift engine is released, you can request that the service automatically apply upgrades during the maintenance window to the Amazon Redshift engine that is running on your cluster.&lt;/p&gt; &lt;p&gt;Default: &lt;code&gt;true&lt;/code&gt; &lt;/p&gt; (optional)
     * @param numberOfNodes &lt;p&gt;The number of compute nodes in the cluster. This parameter is required when the &lt;b&gt;ClusterType&lt;/b&gt; parameter is specified as &lt;code&gt;multi-node&lt;/code&gt;. &lt;/p&gt; &lt;p&gt;For information about determining how many nodes you need, go to &lt;a href&#x3D;\&quot;https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html#how-many-nodes\&quot;&gt; Working with Clusters&lt;/a&gt; in the &lt;i&gt;Amazon Redshift Cluster Management Guide&lt;/i&gt;. &lt;/p&gt; &lt;p&gt;If you don&#39;t specify this parameter, you get a single-node cluster. When requesting a multi-node cluster, you must specify the number of nodes that you want in the cluster.&lt;/p&gt; &lt;p&gt;Default: &lt;code&gt;1&lt;/code&gt; &lt;/p&gt; &lt;p&gt;Constraints: Value must be at least 1 and no more than 100.&lt;/p&gt; (optional)
     * @param publiclyAccessible If &lt;code&gt;true&lt;/code&gt;, the cluster can be accessed from a public network.  (optional)
     * @param encrypted &lt;p&gt;If &lt;code&gt;true&lt;/code&gt;, the data in the cluster is encrypted at rest. &lt;/p&gt; &lt;p&gt;Default: false&lt;/p&gt; (optional)
     * @param hsmClientCertificateIdentifier Specifies the name of the HSM client certificate the Amazon Redshift cluster uses to retrieve the data encryption keys stored in an HSM. (optional)
     * @param hsmConfigurationIdentifier Specifies the name of the HSM configuration that contains the information the Amazon Redshift cluster can use to retrieve and store keys in an HSM. (optional)
     * @param elasticIp &lt;p&gt;The Elastic IP (EIP) address for the cluster.&lt;/p&gt; &lt;p&gt;Constraints: The cluster must be provisioned in EC2-VPC and publicly-accessible through an Internet gateway. Don&#39;t specify the Elastic IP address for a publicly accessible cluster with availability zone relocation turned on. For more information about provisioning clusters in EC2-VPC, go to &lt;a href&#x3D;\&quot;https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html#cluster-platforms\&quot;&gt;Supported Platforms to Launch Your Cluster&lt;/a&gt; in the Amazon Redshift Cluster Management Guide.&lt;/p&gt; (optional)
     * @param tags A list of tag instances. (optional)
     * @param kmsKeyId The Key Management Service (KMS) key ID of the encryption key that you want to use to encrypt data in the cluster. (optional)
     * @param enhancedVpcRouting &lt;p&gt;An option that specifies whether to create the cluster with enhanced VPC routing enabled. To create a cluster that uses enhanced VPC routing, the cluster must be in a VPC. For more information, see &lt;a href&#x3D;\&quot;https://docs.aws.amazon.com/redshift/latest/mgmt/enhanced-vpc-routing.html\&quot;&gt;Enhanced VPC Routing&lt;/a&gt; in the Amazon Redshift Cluster Management Guide.&lt;/p&gt; &lt;p&gt;If this option is &lt;code&gt;true&lt;/code&gt;, enhanced VPC routing is enabled. &lt;/p&gt; &lt;p&gt;Default: false&lt;/p&gt; (optional)
     * @param additionalInfo Reserved. (optional)
     * @param iamRoles &lt;p&gt;A list of Identity and Access Management (IAM) roles that can be used by the cluster to access other Amazon Web Services services. You must supply the IAM roles in their Amazon Resource Name (ARN) format. &lt;/p&gt; &lt;p&gt;The maximum number of IAM roles that you can associate is subject to a quota. For more information, go to &lt;a href&#x3D;\&quot;https://docs.aws.amazon.com/redshift/latest/mgmt/amazon-redshift-limits.html\&quot;&gt;Quotas and limits&lt;/a&gt; in the &lt;i&gt;Amazon Redshift Cluster Management Guide&lt;/i&gt;.&lt;/p&gt; (optional)
     * @param maintenanceTrackName An optional parameter for the name of the maintenance track for the cluster. If you don&#39;t provide a maintenance track name, the cluster is assigned to the &lt;code&gt;current&lt;/code&gt; track. (optional)
     * @param snapshotScheduleIdentifier A unique identifier for the snapshot schedule. (optional)
     * @param availabilityZoneRelocation The option to enable relocation for an Amazon Redshift cluster between Availability Zones after the cluster is created. (optional)
     * @param aquaConfigurationStatus This parameter is retired. It does not set the AQUA configuration status. Amazon Redshift automatically determines whether to use AQUA (Advanced Query Accelerator). (optional)
     * @param defaultIamRoleArn The Amazon Resource Name (ARN) for the IAM role that was set as default for the cluster when the cluster was created.  (optional)
     * @param loadSampleData A flag that specifies whether to load sample data once the cluster is created. (optional)
     * @return ApiResponse&lt;CreateClusterResult&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> ClusterAlreadyExistsFault </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> InsufficientClusterCapacityFault </td><td>  -  </td></tr>
        <tr><td> 482 </td><td> ClusterParameterGroupNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 483 </td><td> ClusterSecurityGroupNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 484 </td><td> ClusterQuotaExceededFault </td><td>  -  </td></tr>
        <tr><td> 485 </td><td> NumberOfNodesQuotaExceededFault </td><td>  -  </td></tr>
        <tr><td> 486 </td><td> NumberOfNodesPerClusterLimitExceededFault </td><td>  -  </td></tr>
        <tr><td> 487 </td><td> ClusterSubnetGroupNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 488 </td><td> InvalidVPCNetworkStateFault </td><td>  -  </td></tr>
        <tr><td> 489 </td><td> InvalidClusterSubnetGroupStateFault </td><td>  -  </td></tr>
        <tr><td> 490 </td><td> InvalidSubnet </td><td>  -  </td></tr>
        <tr><td> 491 </td><td> UnauthorizedOperation </td><td>  -  </td></tr>
        <tr><td> 492 </td><td> HsmClientCertificateNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 493 </td><td> HsmConfigurationNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 494 </td><td> InvalidElasticIpFault </td><td>  -  </td></tr>
        <tr><td> 495 </td><td> TagLimitExceededFault </td><td>  -  </td></tr>
        <tr><td> 496 </td><td> InvalidTagFault </td><td>  -  </td></tr>
        <tr><td> 497 </td><td> LimitExceededFault </td><td>  -  </td></tr>
        <tr><td> 498 </td><td> DependentServiceRequestThrottlingFault </td><td>  -  </td></tr>
        <tr><td> 499 </td><td> InvalidClusterTrackFault </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> SnapshotScheduleNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 501 </td><td> InvalidRetentionPeriodFault </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<CreateClusterResult> gETCreateClusterWithHttpInfo(String clusterIdentifier, String nodeType, String masterUsername, String masterUserPassword, String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, String dbName, String clusterType, List<String> clusterSecurityGroups, List<String> vpcSecurityGroupIds, String clusterSubnetGroupName, String availabilityZone, String preferredMaintenanceWindow, String clusterParameterGroupName, Integer automatedSnapshotRetentionPeriod, Integer manualSnapshotRetentionPeriod, Integer port, String clusterVersion, Boolean allowVersionUpgrade, Integer numberOfNodes, Boolean publiclyAccessible, Boolean encrypted, String hsmClientCertificateIdentifier, String hsmConfigurationIdentifier, String elasticIp, List<GETCreateClusterTagsParameterInner> tags, String kmsKeyId, Boolean enhancedVpcRouting, String additionalInfo, List<String> iamRoles, String maintenanceTrackName, String snapshotScheduleIdentifier, Boolean availabilityZoneRelocation, String aquaConfigurationStatus, String defaultIamRoleArn, String loadSampleData) throws ApiException {
        okhttp3.Call localVarCall = gETCreateClusterValidateBeforeCall(clusterIdentifier, nodeType, masterUsername, masterUserPassword, action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, dbName, clusterType, clusterSecurityGroups, vpcSecurityGroupIds, clusterSubnetGroupName, availabilityZone, preferredMaintenanceWindow, clusterParameterGroupName, automatedSnapshotRetentionPeriod, manualSnapshotRetentionPeriod, port, clusterVersion, allowVersionUpgrade, numberOfNodes, publiclyAccessible, encrypted, hsmClientCertificateIdentifier, hsmConfigurationIdentifier, elasticIp, tags, kmsKeyId, enhancedVpcRouting, additionalInfo, iamRoles, maintenanceTrackName, snapshotScheduleIdentifier, availabilityZoneRelocation, aquaConfigurationStatus, defaultIamRoleArn, loadSampleData, null);
        Type localVarReturnType = new TypeToken<CreateClusterResult>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     *  (asynchronously)
     * &lt;p&gt;Creates a new cluster with the specified parameters.&lt;/p&gt; &lt;p&gt;To create a cluster in Virtual Private Cloud (VPC), you must provide a cluster subnet group name. The cluster subnet group identifies the subnets of your VPC that Amazon Redshift uses when creating the cluster. For more information about managing clusters, go to &lt;a href&#x3D;\&quot;https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html\&quot;&gt;Amazon Redshift Clusters&lt;/a&gt; in the &lt;i&gt;Amazon Redshift Cluster Management Guide&lt;/i&gt;.&lt;/p&gt;
     * @param clusterIdentifier &lt;p&gt;A unique identifier for the cluster. You use this identifier to refer to the cluster for any subsequent cluster operations such as deleting or modifying. The identifier also appears in the Amazon Redshift console.&lt;/p&gt; &lt;p&gt;Constraints:&lt;/p&gt; &lt;ul&gt; &lt;li&gt; &lt;p&gt;Must contain from 1 to 63 alphanumeric characters or hyphens.&lt;/p&gt; &lt;/li&gt; &lt;li&gt; &lt;p&gt;Alphabetic characters must be lowercase.&lt;/p&gt; &lt;/li&gt; &lt;li&gt; &lt;p&gt;First character must be a letter.&lt;/p&gt; &lt;/li&gt; &lt;li&gt; &lt;p&gt;Cannot end with a hyphen or contain two consecutive hyphens.&lt;/p&gt; &lt;/li&gt; &lt;li&gt; &lt;p&gt;Must be unique for all clusters within an Amazon Web Services account.&lt;/p&gt; &lt;/li&gt; &lt;/ul&gt; &lt;p&gt;Example: &lt;code&gt;myexamplecluster&lt;/code&gt; &lt;/p&gt; (required)
     * @param nodeType &lt;p&gt;The node type to be provisioned for the cluster. For information about node types, go to &lt;a href&#x3D;\&quot;https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html#how-many-nodes\&quot;&gt; Working with Clusters&lt;/a&gt; in the &lt;i&gt;Amazon Redshift Cluster Management Guide&lt;/i&gt;. &lt;/p&gt; &lt;p&gt;Valid Values: &lt;code&gt;ds2.xlarge&lt;/code&gt; | &lt;code&gt;ds2.8xlarge&lt;/code&gt; | &lt;code&gt;dc1.large&lt;/code&gt; | &lt;code&gt;dc1.8xlarge&lt;/code&gt; | &lt;code&gt;dc2.large&lt;/code&gt; | &lt;code&gt;dc2.8xlarge&lt;/code&gt; | &lt;code&gt;ra3.xlplus&lt;/code&gt; | &lt;code&gt;ra3.4xlarge&lt;/code&gt; | &lt;code&gt;ra3.16xlarge&lt;/code&gt; &lt;/p&gt; (required)
     * @param masterUsername &lt;p&gt;The user name associated with the admin user account for the cluster that is being created.&lt;/p&gt; &lt;p&gt;Constraints:&lt;/p&gt; &lt;ul&gt; &lt;li&gt; &lt;p&gt;Must be 1 - 128 alphanumeric characters or hyphens. The user name can&#39;t be &lt;code&gt;PUBLIC&lt;/code&gt;.&lt;/p&gt; &lt;/li&gt; &lt;li&gt; &lt;p&gt;Must contain only lowercase letters, numbers, underscore, plus sign, period (dot), at symbol (@), or hyphen.&lt;/p&gt; &lt;/li&gt; &lt;li&gt; &lt;p&gt;The first character must be a letter.&lt;/p&gt; &lt;/li&gt; &lt;li&gt; &lt;p&gt;Must not contain a colon (:) or a slash (/).&lt;/p&gt; &lt;/li&gt; &lt;li&gt; &lt;p&gt;Cannot be a reserved word. A list of reserved words can be found in &lt;a href&#x3D;\&quot;https://docs.aws.amazon.com/redshift/latest/dg/r_pg_keywords.html\&quot;&gt;Reserved Words&lt;/a&gt; in the Amazon Redshift Database Developer Guide. &lt;/p&gt; &lt;/li&gt; &lt;/ul&gt; (required)
     * @param masterUserPassword &lt;p&gt;The password associated with the admin user account for the cluster that is being created.&lt;/p&gt; &lt;p&gt;Constraints:&lt;/p&gt; &lt;ul&gt; &lt;li&gt; &lt;p&gt;Must be between 8 and 64 characters in length.&lt;/p&gt; &lt;/li&gt; &lt;li&gt; &lt;p&gt;Must contain at least one uppercase letter.&lt;/p&gt; &lt;/li&gt; &lt;li&gt; &lt;p&gt;Must contain at least one lowercase letter.&lt;/p&gt; &lt;/li&gt; &lt;li&gt; &lt;p&gt;Must contain one number.&lt;/p&gt; &lt;/li&gt; &lt;li&gt; &lt;p&gt;Can be any printable ASCII character (ASCII code 33-126) except &lt;code&gt;&#39;&lt;/code&gt; (single quote), &lt;code&gt;\&quot;&lt;/code&gt; (double quote), &lt;code&gt;\\&lt;/code&gt;, &lt;code&gt;/&lt;/code&gt;, or &lt;code&gt;@&lt;/code&gt;.&lt;/p&gt; &lt;/li&gt; &lt;/ul&gt; (required)
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param dbName &lt;p&gt;The name of the first database to be created when the cluster is created.&lt;/p&gt; &lt;p&gt;To create additional databases after the cluster is created, connect to the cluster with a SQL client and use SQL commands to create a database. For more information, go to &lt;a href&#x3D;\&quot;https://docs.aws.amazon.com/redshift/latest/dg/t_creating_database.html\&quot;&gt;Create a Database&lt;/a&gt; in the Amazon Redshift Database Developer Guide. &lt;/p&gt; &lt;p&gt;Default: &lt;code&gt;dev&lt;/code&gt; &lt;/p&gt; &lt;p&gt;Constraints:&lt;/p&gt; &lt;ul&gt; &lt;li&gt; &lt;p&gt;Must contain 1 to 64 alphanumeric characters.&lt;/p&gt; &lt;/li&gt; &lt;li&gt; &lt;p&gt;Must contain only lowercase letters.&lt;/p&gt; &lt;/li&gt; &lt;li&gt; &lt;p&gt;Cannot be a word that is reserved by the service. A list of reserved words can be found in &lt;a href&#x3D;\&quot;https://docs.aws.amazon.com/redshift/latest/dg/r_pg_keywords.html\&quot;&gt;Reserved Words&lt;/a&gt; in the Amazon Redshift Database Developer Guide. &lt;/p&gt; &lt;/li&gt; &lt;/ul&gt; (optional)
     * @param clusterType &lt;p&gt;The type of the cluster. When cluster type is specified as&lt;/p&gt; &lt;ul&gt; &lt;li&gt; &lt;p&gt; &lt;code&gt;single-node&lt;/code&gt;, the &lt;b&gt;NumberOfNodes&lt;/b&gt; parameter is not required.&lt;/p&gt; &lt;/li&gt; &lt;li&gt; &lt;p&gt; &lt;code&gt;multi-node&lt;/code&gt;, the &lt;b&gt;NumberOfNodes&lt;/b&gt; parameter is required.&lt;/p&gt; &lt;/li&gt; &lt;/ul&gt; &lt;p&gt;Valid Values: &lt;code&gt;multi-node&lt;/code&gt; | &lt;code&gt;single-node&lt;/code&gt; &lt;/p&gt; &lt;p&gt;Default: &lt;code&gt;multi-node&lt;/code&gt; &lt;/p&gt; (optional)
     * @param clusterSecurityGroups &lt;p&gt;A list of security groups to be associated with this cluster.&lt;/p&gt; &lt;p&gt;Default: The default cluster security group for Amazon Redshift.&lt;/p&gt; (optional)
     * @param vpcSecurityGroupIds &lt;p&gt;A list of Virtual Private Cloud (VPC) security groups to be associated with the cluster.&lt;/p&gt; &lt;p&gt;Default: The default VPC security group is associated with the cluster.&lt;/p&gt; (optional)
     * @param clusterSubnetGroupName &lt;p&gt;The name of a cluster subnet group to be associated with this cluster.&lt;/p&gt; &lt;p&gt;If this parameter is not provided the resulting cluster will be deployed outside virtual private cloud (VPC).&lt;/p&gt; (optional)
     * @param availabilityZone &lt;p&gt;The EC2 Availability Zone (AZ) in which you want Amazon Redshift to provision the cluster. For example, if you have several EC2 instances running in a specific Availability Zone, then you might want the cluster to be provisioned in the same zone in order to decrease network latency.&lt;/p&gt; &lt;p&gt;Default: A random, system-chosen Availability Zone in the region that is specified by the endpoint.&lt;/p&gt; &lt;p&gt;Example: &lt;code&gt;us-east-2d&lt;/code&gt; &lt;/p&gt; &lt;p&gt;Constraint: The specified Availability Zone must be in the same region as the current endpoint.&lt;/p&gt; (optional)
     * @param preferredMaintenanceWindow &lt;p&gt;The weekly time range (in UTC) during which automated cluster maintenance can occur.&lt;/p&gt; &lt;p&gt; Format: &lt;code&gt;ddd:hh24:mi-ddd:hh24:mi&lt;/code&gt; &lt;/p&gt; &lt;p&gt; Default: A 30-minute window selected at random from an 8-hour block of time per region, occurring on a random day of the week. For more information about the time blocks for each region, see &lt;a href&#x3D;\&quot;https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html#rs-maintenance-windows\&quot;&gt;Maintenance Windows&lt;/a&gt; in Amazon Redshift Cluster Management Guide.&lt;/p&gt; &lt;p&gt;Valid Days: Mon | Tue | Wed | Thu | Fri | Sat | Sun&lt;/p&gt; &lt;p&gt;Constraints: Minimum 30-minute window.&lt;/p&gt; (optional)
     * @param clusterParameterGroupName &lt;p&gt;The name of the parameter group to be associated with this cluster.&lt;/p&gt; &lt;p&gt;Default: The default Amazon Redshift cluster parameter group. For information about the default parameter group, go to &lt;a href&#x3D;\&quot;https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-parameter-groups.html\&quot;&gt;Working with Amazon Redshift Parameter Groups&lt;/a&gt; &lt;/p&gt; &lt;p&gt;Constraints:&lt;/p&gt; &lt;ul&gt; &lt;li&gt; &lt;p&gt;Must be 1 to 255 alphanumeric characters or hyphens.&lt;/p&gt; &lt;/li&gt; &lt;li&gt; &lt;p&gt;First character must be a letter.&lt;/p&gt; &lt;/li&gt; &lt;li&gt; &lt;p&gt;Cannot end with a hyphen or contain two consecutive hyphens.&lt;/p&gt; &lt;/li&gt; &lt;/ul&gt; (optional)
     * @param automatedSnapshotRetentionPeriod &lt;p&gt;The number of days that automated snapshots are retained. If the value is 0, automated snapshots are disabled. Even if automated snapshots are disabled, you can still create manual snapshots when you want with &lt;a&gt;CreateClusterSnapshot&lt;/a&gt;. &lt;/p&gt; &lt;p&gt;You can&#39;t disable automated snapshots for RA3 node types. Set the automated retention period from 1-35 days.&lt;/p&gt; &lt;p&gt;Default: &lt;code&gt;1&lt;/code&gt; &lt;/p&gt; &lt;p&gt;Constraints: Must be a value from 0 to 35.&lt;/p&gt; (optional)
     * @param manualSnapshotRetentionPeriod &lt;p&gt;The default number of days to retain a manual snapshot. If the value is -1, the snapshot is retained indefinitely. This setting doesn&#39;t change the retention period of existing snapshots.&lt;/p&gt; &lt;p&gt;The value must be either -1 or an integer between 1 and 3,653.&lt;/p&gt; (optional)
     * @param port &lt;p&gt;The port number on which the cluster accepts incoming connections.&lt;/p&gt; &lt;p&gt;The cluster is accessible only via the JDBC and ODBC connection strings. Part of the connection string requires the port on which the cluster will listen for incoming connections.&lt;/p&gt; &lt;p&gt;Default: &lt;code&gt;5439&lt;/code&gt; &lt;/p&gt; &lt;p&gt;Valid Values: &lt;code&gt;1150-65535&lt;/code&gt; &lt;/p&gt; (optional)
     * @param clusterVersion &lt;p&gt;The version of the Amazon Redshift engine software that you want to deploy on the cluster.&lt;/p&gt; &lt;p&gt;The version selected runs on all the nodes in the cluster.&lt;/p&gt; &lt;p&gt;Constraints: Only version 1.0 is currently available.&lt;/p&gt; &lt;p&gt;Example: &lt;code&gt;1.0&lt;/code&gt; &lt;/p&gt; (optional)
     * @param allowVersionUpgrade &lt;p&gt;If &lt;code&gt;true&lt;/code&gt;, major version upgrades can be applied during the maintenance window to the Amazon Redshift engine that is running on the cluster.&lt;/p&gt; &lt;p&gt;When a new major version of the Amazon Redshift engine is released, you can request that the service automatically apply upgrades during the maintenance window to the Amazon Redshift engine that is running on your cluster.&lt;/p&gt; &lt;p&gt;Default: &lt;code&gt;true&lt;/code&gt; &lt;/p&gt; (optional)
     * @param numberOfNodes &lt;p&gt;The number of compute nodes in the cluster. This parameter is required when the &lt;b&gt;ClusterType&lt;/b&gt; parameter is specified as &lt;code&gt;multi-node&lt;/code&gt;. &lt;/p&gt; &lt;p&gt;For information about determining how many nodes you need, go to &lt;a href&#x3D;\&quot;https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html#how-many-nodes\&quot;&gt; Working with Clusters&lt;/a&gt; in the &lt;i&gt;Amazon Redshift Cluster Management Guide&lt;/i&gt;. &lt;/p&gt; &lt;p&gt;If you don&#39;t specify this parameter, you get a single-node cluster. When requesting a multi-node cluster, you must specify the number of nodes that you want in the cluster.&lt;/p&gt; &lt;p&gt;Default: &lt;code&gt;1&lt;/code&gt; &lt;/p&gt; &lt;p&gt;Constraints: Value must be at least 1 and no more than 100.&lt;/p&gt; (optional)
     * @param publiclyAccessible If &lt;code&gt;true&lt;/code&gt;, the cluster can be accessed from a public network.  (optional)
     * @param encrypted &lt;p&gt;If &lt;code&gt;true&lt;/code&gt;, the data in the cluster is encrypted at rest. &lt;/p&gt; &lt;p&gt;Default: false&lt;/p&gt; (optional)
     * @param hsmClientCertificateIdentifier Specifies the name of the HSM client certificate the Amazon Redshift cluster uses to retrieve the data encryption keys stored in an HSM. (optional)
     * @param hsmConfigurationIdentifier Specifies the name of the HSM configuration that contains the information the Amazon Redshift cluster can use to retrieve and store keys in an HSM. (optional)
     * @param elasticIp &lt;p&gt;The Elastic IP (EIP) address for the cluster.&lt;/p&gt; &lt;p&gt;Constraints: The cluster must be provisioned in EC2-VPC and publicly-accessible through an Internet gateway. Don&#39;t specify the Elastic IP address for a publicly accessible cluster with availability zone relocation turned on. For more information about provisioning clusters in EC2-VPC, go to &lt;a href&#x3D;\&quot;https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html#cluster-platforms\&quot;&gt;Supported Platforms to Launch Your Cluster&lt;/a&gt; in the Amazon Redshift Cluster Management Guide.&lt;/p&gt; (optional)
     * @param tags A list of tag instances. (optional)
     * @param kmsKeyId The Key Management Service (KMS) key ID of the encryption key that you want to use to encrypt data in the cluster. (optional)
     * @param enhancedVpcRouting &lt;p&gt;An option that specifies whether to create the cluster with enhanced VPC routing enabled. To create a cluster that uses enhanced VPC routing, the cluster must be in a VPC. For more information, see &lt;a href&#x3D;\&quot;https://docs.aws.amazon.com/redshift/latest/mgmt/enhanced-vpc-routing.html\&quot;&gt;Enhanced VPC Routing&lt;/a&gt; in the Amazon Redshift Cluster Management Guide.&lt;/p&gt; &lt;p&gt;If this option is &lt;code&gt;true&lt;/code&gt;, enhanced VPC routing is enabled. &lt;/p&gt; &lt;p&gt;Default: false&lt;/p&gt; (optional)
     * @param additionalInfo Reserved. (optional)
     * @param iamRoles &lt;p&gt;A list of Identity and Access Management (IAM) roles that can be used by the cluster to access other Amazon Web Services services. You must supply the IAM roles in their Amazon Resource Name (ARN) format. &lt;/p&gt; &lt;p&gt;The maximum number of IAM roles that you can associate is subject to a quota. For more information, go to &lt;a href&#x3D;\&quot;https://docs.aws.amazon.com/redshift/latest/mgmt/amazon-redshift-limits.html\&quot;&gt;Quotas and limits&lt;/a&gt; in the &lt;i&gt;Amazon Redshift Cluster Management Guide&lt;/i&gt;.&lt;/p&gt; (optional)
     * @param maintenanceTrackName An optional parameter for the name of the maintenance track for the cluster. If you don&#39;t provide a maintenance track name, the cluster is assigned to the &lt;code&gt;current&lt;/code&gt; track. (optional)
     * @param snapshotScheduleIdentifier A unique identifier for the snapshot schedule. (optional)
     * @param availabilityZoneRelocation The option to enable relocation for an Amazon Redshift cluster between Availability Zones after the cluster is created. (optional)
     * @param aquaConfigurationStatus This parameter is retired. It does not set the AQUA configuration status. Amazon Redshift automatically determines whether to use AQUA (Advanced Query Accelerator). (optional)
     * @param defaultIamRoleArn The Amazon Resource Name (ARN) for the IAM role that was set as default for the cluster when the cluster was created.  (optional)
     * @param loadSampleData A flag that specifies whether to load sample data once the cluster is created. (optional)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> ClusterAlreadyExistsFault </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> InsufficientClusterCapacityFault </td><td>  -  </td></tr>
        <tr><td> 482 </td><td> ClusterParameterGroupNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 483 </td><td> ClusterSecurityGroupNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 484 </td><td> ClusterQuotaExceededFault </td><td>  -  </td></tr>
        <tr><td> 485 </td><td> NumberOfNodesQuotaExceededFault </td><td>  -  </td></tr>
        <tr><td> 486 </td><td> NumberOfNodesPerClusterLimitExceededFault </td><td>  -  </td></tr>
        <tr><td> 487 </td><td> ClusterSubnetGroupNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 488 </td><td> InvalidVPCNetworkStateFault </td><td>  -  </td></tr>
        <tr><td> 489 </td><td> InvalidClusterSubnetGroupStateFault </td><td>  -  </td></tr>
        <tr><td> 490 </td><td> InvalidSubnet </td><td>  -  </td></tr>
        <tr><td> 491 </td><td> UnauthorizedOperation </td><td>  -  </td></tr>
        <tr><td> 492 </td><td> HsmClientCertificateNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 493 </td><td> HsmConfigurationNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 494 </td><td> InvalidElasticIpFault </td><td>  -  </td></tr>
        <tr><td> 495 </td><td> TagLimitExceededFault </td><td>  -  </td></tr>
        <tr><td> 496 </td><td> InvalidTagFault </td><td>  -  </td></tr>
        <tr><td> 497 </td><td> LimitExceededFault </td><td>  -  </td></tr>
        <tr><td> 498 </td><td> DependentServiceRequestThrottlingFault </td><td>  -  </td></tr>
        <tr><td> 499 </td><td> InvalidClusterTrackFault </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> SnapshotScheduleNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 501 </td><td> InvalidRetentionPeriodFault </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call gETCreateClusterAsync(String clusterIdentifier, String nodeType, String masterUsername, String masterUserPassword, String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, String dbName, String clusterType, List<String> clusterSecurityGroups, List<String> vpcSecurityGroupIds, String clusterSubnetGroupName, String availabilityZone, String preferredMaintenanceWindow, String clusterParameterGroupName, Integer automatedSnapshotRetentionPeriod, Integer manualSnapshotRetentionPeriod, Integer port, String clusterVersion, Boolean allowVersionUpgrade, Integer numberOfNodes, Boolean publiclyAccessible, Boolean encrypted, String hsmClientCertificateIdentifier, String hsmConfigurationIdentifier, String elasticIp, List<GETCreateClusterTagsParameterInner> tags, String kmsKeyId, Boolean enhancedVpcRouting, String additionalInfo, List<String> iamRoles, String maintenanceTrackName, String snapshotScheduleIdentifier, Boolean availabilityZoneRelocation, String aquaConfigurationStatus, String defaultIamRoleArn, String loadSampleData, final ApiCallback<CreateClusterResult> _callback) throws ApiException {

        okhttp3.Call localVarCall = gETCreateClusterValidateBeforeCall(clusterIdentifier, nodeType, masterUsername, masterUserPassword, action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, dbName, clusterType, clusterSecurityGroups, vpcSecurityGroupIds, clusterSubnetGroupName, availabilityZone, preferredMaintenanceWindow, clusterParameterGroupName, automatedSnapshotRetentionPeriod, manualSnapshotRetentionPeriod, port, clusterVersion, allowVersionUpgrade, numberOfNodes, publiclyAccessible, encrypted, hsmClientCertificateIdentifier, hsmConfigurationIdentifier, elasticIp, tags, kmsKeyId, enhancedVpcRouting, additionalInfo, iamRoles, maintenanceTrackName, snapshotScheduleIdentifier, availabilityZoneRelocation, aquaConfigurationStatus, defaultIamRoleArn, loadSampleData, _callback);
        Type localVarReturnType = new TypeToken<CreateClusterResult>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for gETCreateClusterParameterGroup
     * @param parameterGroupName &lt;p&gt;The name of the cluster parameter group.&lt;/p&gt; &lt;p&gt;Constraints:&lt;/p&gt; &lt;ul&gt; &lt;li&gt; &lt;p&gt;Must be 1 to 255 alphanumeric characters or hyphens&lt;/p&gt; &lt;/li&gt; &lt;li&gt; &lt;p&gt;First character must be a letter.&lt;/p&gt; &lt;/li&gt; &lt;li&gt; &lt;p&gt;Cannot end with a hyphen or contain two consecutive hyphens.&lt;/p&gt; &lt;/li&gt; &lt;li&gt; &lt;p&gt;Must be unique withing your Amazon Web Services account.&lt;/p&gt; &lt;/li&gt; &lt;/ul&gt; &lt;note&gt; &lt;p&gt;This value is stored as a lower-case string.&lt;/p&gt; &lt;/note&gt; (required)
     * @param parameterGroupFamily &lt;p&gt;The Amazon Redshift engine version to which the cluster parameter group applies. The cluster engine version determines the set of parameters.&lt;/p&gt; &lt;p&gt;To get a list of valid parameter group family names, you can call &lt;a&gt;DescribeClusterParameterGroups&lt;/a&gt;. By default, Amazon Redshift returns a list of all the parameter groups that are owned by your Amazon Web Services account, including the default parameter groups for each Amazon Redshift engine version. The parameter group family names associated with the default parameter groups provide you the valid values. For example, a valid family name is \&quot;redshift-1.0\&quot;. &lt;/p&gt; (required)
     * @param description A description of the parameter group. (required)
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param tags A list of tag instances. (optional)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> ClusterParameterGroupQuotaExceededFault </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> ClusterParameterGroupAlreadyExistsFault </td><td>  -  </td></tr>
        <tr><td> 482 </td><td> TagLimitExceededFault </td><td>  -  </td></tr>
        <tr><td> 483 </td><td> InvalidTagFault </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call gETCreateClusterParameterGroupCall(String parameterGroupName, String parameterGroupFamily, String description, String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, List<GETCreateClusterTagsParameterInner> tags, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/#Action=CreateClusterParameterGroup";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (parameterGroupName != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("ParameterGroupName", parameterGroupName));
        }

        if (parameterGroupFamily != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("ParameterGroupFamily", parameterGroupFamily));
        }

        if (description != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("Description", description));
        }

        if (tags != null) {
            localVarCollectionQueryParams.addAll(localVarApiClient.parameterToPairs("multi", "Tags", tags));
        }

        if (action != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("Action", action));
        }

        if (version != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("Version", version));
        }

        if (xAmzContentSha256 != null) {
            localVarHeaderParams.put("X-Amz-Content-Sha256", localVarApiClient.parameterToString(xAmzContentSha256));
        }

        if (xAmzDate != null) {
            localVarHeaderParams.put("X-Amz-Date", localVarApiClient.parameterToString(xAmzDate));
        }

        if (xAmzAlgorithm != null) {
            localVarHeaderParams.put("X-Amz-Algorithm", localVarApiClient.parameterToString(xAmzAlgorithm));
        }

        if (xAmzCredential != null) {
            localVarHeaderParams.put("X-Amz-Credential", localVarApiClient.parameterToString(xAmzCredential));
        }

        if (xAmzSecurityToken != null) {
            localVarHeaderParams.put("X-Amz-Security-Token", localVarApiClient.parameterToString(xAmzSecurityToken));
        }

        if (xAmzSignature != null) {
            localVarHeaderParams.put("X-Amz-Signature", localVarApiClient.parameterToString(xAmzSignature));
        }

        if (xAmzSignedHeaders != null) {
            localVarHeaderParams.put("X-Amz-SignedHeaders", localVarApiClient.parameterToString(xAmzSignedHeaders));
        }

        final String[] localVarAccepts = {
            "text/xml"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "hmac" };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call gETCreateClusterParameterGroupValidateBeforeCall(String parameterGroupName, String parameterGroupFamily, String description, String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, List<GETCreateClusterTagsParameterInner> tags, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'parameterGroupName' is set
        if (parameterGroupName == null) {
            throw new ApiException("Missing the required parameter 'parameterGroupName' when calling gETCreateClusterParameterGroup(Async)");
        }

        // verify the required parameter 'parameterGroupFamily' is set
        if (parameterGroupFamily == null) {
            throw new ApiException("Missing the required parameter 'parameterGroupFamily' when calling gETCreateClusterParameterGroup(Async)");
        }

        // verify the required parameter 'description' is set
        if (description == null) {
            throw new ApiException("Missing the required parameter 'description' when calling gETCreateClusterParameterGroup(Async)");
        }

        // verify the required parameter 'action' is set
        if (action == null) {
            throw new ApiException("Missing the required parameter 'action' when calling gETCreateClusterParameterGroup(Async)");
        }

        // verify the required parameter 'version' is set
        if (version == null) {
            throw new ApiException("Missing the required parameter 'version' when calling gETCreateClusterParameterGroup(Async)");
        }

        return gETCreateClusterParameterGroupCall(parameterGroupName, parameterGroupFamily, description, action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, tags, _callback);

    }

    /**
     * 
     * &lt;p&gt;Creates an Amazon Redshift parameter group.&lt;/p&gt; &lt;p&gt;Creating parameter groups is independent of creating clusters. You can associate a cluster with a parameter group when you create the cluster. You can also associate an existing cluster with a parameter group after the cluster is created by using &lt;a&gt;ModifyCluster&lt;/a&gt;. &lt;/p&gt; &lt;p&gt;Parameters in the parameter group define specific behavior that applies to the databases you create on the cluster. For more information about parameters and parameter groups, go to &lt;a href&#x3D;\&quot;https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-parameter-groups.html\&quot;&gt;Amazon Redshift Parameter Groups&lt;/a&gt; in the &lt;i&gt;Amazon Redshift Cluster Management Guide&lt;/i&gt;.&lt;/p&gt;
     * @param parameterGroupName &lt;p&gt;The name of the cluster parameter group.&lt;/p&gt; &lt;p&gt;Constraints:&lt;/p&gt; &lt;ul&gt; &lt;li&gt; &lt;p&gt;Must be 1 to 255 alphanumeric characters or hyphens&lt;/p&gt; &lt;/li&gt; &lt;li&gt; &lt;p&gt;First character must be a letter.&lt;/p&gt; &lt;/li&gt; &lt;li&gt; &lt;p&gt;Cannot end with a hyphen or contain two consecutive hyphens.&lt;/p&gt; &lt;/li&gt; &lt;li&gt; &lt;p&gt;Must be unique withing your Amazon Web Services account.&lt;/p&gt; &lt;/li&gt; &lt;/ul&gt; &lt;note&gt; &lt;p&gt;This value is stored as a lower-case string.&lt;/p&gt; &lt;/note&gt; (required)
     * @param parameterGroupFamily &lt;p&gt;The Amazon Redshift engine version to which the cluster parameter group applies. The cluster engine version determines the set of parameters.&lt;/p&gt; &lt;p&gt;To get a list of valid parameter group family names, you can call &lt;a&gt;DescribeClusterParameterGroups&lt;/a&gt;. By default, Amazon Redshift returns a list of all the parameter groups that are owned by your Amazon Web Services account, including the default parameter groups for each Amazon Redshift engine version. The parameter group family names associated with the default parameter groups provide you the valid values. For example, a valid family name is \&quot;redshift-1.0\&quot;. &lt;/p&gt; (required)
     * @param description A description of the parameter group. (required)
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param tags A list of tag instances. (optional)
     * @return CreateClusterParameterGroupResult
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> ClusterParameterGroupQuotaExceededFault </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> ClusterParameterGroupAlreadyExistsFault </td><td>  -  </td></tr>
        <tr><td> 482 </td><td> TagLimitExceededFault </td><td>  -  </td></tr>
        <tr><td> 483 </td><td> InvalidTagFault </td><td>  -  </td></tr>
     </table>
     */
    public CreateClusterParameterGroupResult gETCreateClusterParameterGroup(String parameterGroupName, String parameterGroupFamily, String description, String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, List<GETCreateClusterTagsParameterInner> tags) throws ApiException {
        ApiResponse<CreateClusterParameterGroupResult> localVarResp = gETCreateClusterParameterGroupWithHttpInfo(parameterGroupName, parameterGroupFamily, description, action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, tags);
        return localVarResp.getData();
    }

    /**
     * 
     * &lt;p&gt;Creates an Amazon Redshift parameter group.&lt;/p&gt; &lt;p&gt;Creating parameter groups is independent of creating clusters. You can associate a cluster with a parameter group when you create the cluster. You can also associate an existing cluster with a parameter group after the cluster is created by using &lt;a&gt;ModifyCluster&lt;/a&gt;. &lt;/p&gt; &lt;p&gt;Parameters in the parameter group define specific behavior that applies to the databases you create on the cluster. For more information about parameters and parameter groups, go to &lt;a href&#x3D;\&quot;https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-parameter-groups.html\&quot;&gt;Amazon Redshift Parameter Groups&lt;/a&gt; in the &lt;i&gt;Amazon Redshift Cluster Management Guide&lt;/i&gt;.&lt;/p&gt;
     * @param parameterGroupName &lt;p&gt;The name of the cluster parameter group.&lt;/p&gt; &lt;p&gt;Constraints:&lt;/p&gt; &lt;ul&gt; &lt;li&gt; &lt;p&gt;Must be 1 to 255 alphanumeric characters or hyphens&lt;/p&gt; &lt;/li&gt; &lt;li&gt; &lt;p&gt;First character must be a letter.&lt;/p&gt; &lt;/li&gt; &lt;li&gt; &lt;p&gt;Cannot end with a hyphen or contain two consecutive hyphens.&lt;/p&gt; &lt;/li&gt; &lt;li&gt; &lt;p&gt;Must be unique withing your Amazon Web Services account.&lt;/p&gt; &lt;/li&gt; &lt;/ul&gt; &lt;note&gt; &lt;p&gt;This value is stored as a lower-case string.&lt;/p&gt; &lt;/note&gt; (required)
     * @param parameterGroupFamily &lt;p&gt;The Amazon Redshift engine version to which the cluster parameter group applies. The cluster engine version determines the set of parameters.&lt;/p&gt; &lt;p&gt;To get a list of valid parameter group family names, you can call &lt;a&gt;DescribeClusterParameterGroups&lt;/a&gt;. By default, Amazon Redshift returns a list of all the parameter groups that are owned by your Amazon Web Services account, including the default parameter groups for each Amazon Redshift engine version. The parameter group family names associated with the default parameter groups provide you the valid values. For example, a valid family name is \&quot;redshift-1.0\&quot;. &lt;/p&gt; (required)
     * @param description A description of the parameter group. (required)
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param tags A list of tag instances. (optional)
     * @return ApiResponse&lt;CreateClusterParameterGroupResult&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> ClusterParameterGroupQuotaExceededFault </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> ClusterParameterGroupAlreadyExistsFault </td><td>  -  </td></tr>
        <tr><td> 482 </td><td> TagLimitExceededFault </td><td>  -  </td></tr>
        <tr><td> 483 </td><td> InvalidTagFault </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<CreateClusterParameterGroupResult> gETCreateClusterParameterGroupWithHttpInfo(String parameterGroupName, String parameterGroupFamily, String description, String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, List<GETCreateClusterTagsParameterInner> tags) throws ApiException {
        okhttp3.Call localVarCall = gETCreateClusterParameterGroupValidateBeforeCall(parameterGroupName, parameterGroupFamily, description, action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, tags, null);
        Type localVarReturnType = new TypeToken<CreateClusterParameterGroupResult>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     *  (asynchronously)
     * &lt;p&gt;Creates an Amazon Redshift parameter group.&lt;/p&gt; &lt;p&gt;Creating parameter groups is independent of creating clusters. You can associate a cluster with a parameter group when you create the cluster. You can also associate an existing cluster with a parameter group after the cluster is created by using &lt;a&gt;ModifyCluster&lt;/a&gt;. &lt;/p&gt; &lt;p&gt;Parameters in the parameter group define specific behavior that applies to the databases you create on the cluster. For more information about parameters and parameter groups, go to &lt;a href&#x3D;\&quot;https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-parameter-groups.html\&quot;&gt;Amazon Redshift Parameter Groups&lt;/a&gt; in the &lt;i&gt;Amazon Redshift Cluster Management Guide&lt;/i&gt;.&lt;/p&gt;
     * @param parameterGroupName &lt;p&gt;The name of the cluster parameter group.&lt;/p&gt; &lt;p&gt;Constraints:&lt;/p&gt; &lt;ul&gt; &lt;li&gt; &lt;p&gt;Must be 1 to 255 alphanumeric characters or hyphens&lt;/p&gt; &lt;/li&gt; &lt;li&gt; &lt;p&gt;First character must be a letter.&lt;/p&gt; &lt;/li&gt; &lt;li&gt; &lt;p&gt;Cannot end with a hyphen or contain two consecutive hyphens.&lt;/p&gt; &lt;/li&gt; &lt;li&gt; &lt;p&gt;Must be unique withing your Amazon Web Services account.&lt;/p&gt; &lt;/li&gt; &lt;/ul&gt; &lt;note&gt; &lt;p&gt;This value is stored as a lower-case string.&lt;/p&gt; &lt;/note&gt; (required)
     * @param parameterGroupFamily &lt;p&gt;The Amazon Redshift engine version to which the cluster parameter group applies. The cluster engine version determines the set of parameters.&lt;/p&gt; &lt;p&gt;To get a list of valid parameter group family names, you can call &lt;a&gt;DescribeClusterParameterGroups&lt;/a&gt;. By default, Amazon Redshift returns a list of all the parameter groups that are owned by your Amazon Web Services account, including the default parameter groups for each Amazon Redshift engine version. The parameter group family names associated with the default parameter groups provide you the valid values. For example, a valid family name is \&quot;redshift-1.0\&quot;. &lt;/p&gt; (required)
     * @param description A description of the parameter group. (required)
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param tags A list of tag instances. (optional)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> ClusterParameterGroupQuotaExceededFault </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> ClusterParameterGroupAlreadyExistsFault </td><td>  -  </td></tr>
        <tr><td> 482 </td><td> TagLimitExceededFault </td><td>  -  </td></tr>
        <tr><td> 483 </td><td> InvalidTagFault </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call gETCreateClusterParameterGroupAsync(String parameterGroupName, String parameterGroupFamily, String description, String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, List<GETCreateClusterTagsParameterInner> tags, final ApiCallback<CreateClusterParameterGroupResult> _callback) throws ApiException {

        okhttp3.Call localVarCall = gETCreateClusterParameterGroupValidateBeforeCall(parameterGroupName, parameterGroupFamily, description, action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, tags, _callback);
        Type localVarReturnType = new TypeToken<CreateClusterParameterGroupResult>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for gETCreateClusterSecurityGroup
     * @param clusterSecurityGroupName &lt;p&gt;The name for the security group. Amazon Redshift stores the value as a lowercase string.&lt;/p&gt; &lt;p&gt;Constraints:&lt;/p&gt; &lt;ul&gt; &lt;li&gt; &lt;p&gt;Must contain no more than 255 alphanumeric characters or hyphens.&lt;/p&gt; &lt;/li&gt; &lt;li&gt; &lt;p&gt;Must not be \&quot;Default\&quot;.&lt;/p&gt; &lt;/li&gt; &lt;li&gt; &lt;p&gt;Must be unique for all security groups that are created by your Amazon Web Services account.&lt;/p&gt; &lt;/li&gt; &lt;/ul&gt; &lt;p&gt;Example: &lt;code&gt;examplesecuritygroup&lt;/code&gt; &lt;/p&gt; (required)
     * @param description A description for the security group. (required)
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param tags A list of tag instances. (optional)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> ClusterSecurityGroupAlreadyExistsFault </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> ClusterSecurityGroupQuotaExceededFault </td><td>  -  </td></tr>
        <tr><td> 482 </td><td> TagLimitExceededFault </td><td>  -  </td></tr>
        <tr><td> 483 </td><td> InvalidTagFault </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call gETCreateClusterSecurityGroupCall(String clusterSecurityGroupName, String description, String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, List<GETCreateClusterTagsParameterInner> tags, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/#Action=CreateClusterSecurityGroup";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (clusterSecurityGroupName != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("ClusterSecurityGroupName", clusterSecurityGroupName));
        }

        if (description != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("Description", description));
        }

        if (tags != null) {
            localVarCollectionQueryParams.addAll(localVarApiClient.parameterToPairs("multi", "Tags", tags));
        }

        if (action != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("Action", action));
        }

        if (version != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("Version", version));
        }

        if (xAmzContentSha256 != null) {
            localVarHeaderParams.put("X-Amz-Content-Sha256", localVarApiClient.parameterToString(xAmzContentSha256));
        }

        if (xAmzDate != null) {
            localVarHeaderParams.put("X-Amz-Date", localVarApiClient.parameterToString(xAmzDate));
        }

        if (xAmzAlgorithm != null) {
            localVarHeaderParams.put("X-Amz-Algorithm", localVarApiClient.parameterToString(xAmzAlgorithm));
        }

        if (xAmzCredential != null) {
            localVarHeaderParams.put("X-Amz-Credential", localVarApiClient.parameterToString(xAmzCredential));
        }

        if (xAmzSecurityToken != null) {
            localVarHeaderParams.put("X-Amz-Security-Token", localVarApiClient.parameterToString(xAmzSecurityToken));
        }

        if (xAmzSignature != null) {
            localVarHeaderParams.put("X-Amz-Signature", localVarApiClient.parameterToString(xAmzSignature));
        }

        if (xAmzSignedHeaders != null) {
            localVarHeaderParams.put("X-Amz-SignedHeaders", localVarApiClient.parameterToString(xAmzSignedHeaders));
        }

        final String[] localVarAccepts = {
            "text/xml"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "hmac" };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call gETCreateClusterSecurityGroupValidateBeforeCall(String clusterSecurityGroupName, String description, String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, List<GETCreateClusterTagsParameterInner> tags, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'clusterSecurityGroupName' is set
        if (clusterSecurityGroupName == null) {
            throw new ApiException("Missing the required parameter 'clusterSecurityGroupName' when calling gETCreateClusterSecurityGroup(Async)");
        }

        // verify the required parameter 'description' is set
        if (description == null) {
            throw new ApiException("Missing the required parameter 'description' when calling gETCreateClusterSecurityGroup(Async)");
        }

        // verify the required parameter 'action' is set
        if (action == null) {
            throw new ApiException("Missing the required parameter 'action' when calling gETCreateClusterSecurityGroup(Async)");
        }

        // verify the required parameter 'version' is set
        if (version == null) {
            throw new ApiException("Missing the required parameter 'version' when calling gETCreateClusterSecurityGroup(Async)");
        }

        return gETCreateClusterSecurityGroupCall(clusterSecurityGroupName, description, action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, tags, _callback);

    }

    /**
     * 
     * &lt;p&gt;Creates a new Amazon Redshift security group. You use security groups to control access to non-VPC clusters.&lt;/p&gt; &lt;p&gt; For information about managing security groups, go to &lt;a href&#x3D;\&quot;https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-security-groups.html\&quot;&gt;Amazon Redshift Cluster Security Groups&lt;/a&gt; in the &lt;i&gt;Amazon Redshift Cluster Management Guide&lt;/i&gt;.&lt;/p&gt;
     * @param clusterSecurityGroupName &lt;p&gt;The name for the security group. Amazon Redshift stores the value as a lowercase string.&lt;/p&gt; &lt;p&gt;Constraints:&lt;/p&gt; &lt;ul&gt; &lt;li&gt; &lt;p&gt;Must contain no more than 255 alphanumeric characters or hyphens.&lt;/p&gt; &lt;/li&gt; &lt;li&gt; &lt;p&gt;Must not be \&quot;Default\&quot;.&lt;/p&gt; &lt;/li&gt; &lt;li&gt; &lt;p&gt;Must be unique for all security groups that are created by your Amazon Web Services account.&lt;/p&gt; &lt;/li&gt; &lt;/ul&gt; &lt;p&gt;Example: &lt;code&gt;examplesecuritygroup&lt;/code&gt; &lt;/p&gt; (required)
     * @param description A description for the security group. (required)
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param tags A list of tag instances. (optional)
     * @return CreateClusterSecurityGroupResult
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> ClusterSecurityGroupAlreadyExistsFault </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> ClusterSecurityGroupQuotaExceededFault </td><td>  -  </td></tr>
        <tr><td> 482 </td><td> TagLimitExceededFault </td><td>  -  </td></tr>
        <tr><td> 483 </td><td> InvalidTagFault </td><td>  -  </td></tr>
     </table>
     */
    public CreateClusterSecurityGroupResult gETCreateClusterSecurityGroup(String clusterSecurityGroupName, String description, String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, List<GETCreateClusterTagsParameterInner> tags) throws ApiException {
        ApiResponse<CreateClusterSecurityGroupResult> localVarResp = gETCreateClusterSecurityGroupWithHttpInfo(clusterSecurityGroupName, description, action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, tags);
        return localVarResp.getData();
    }

    /**
     * 
     * &lt;p&gt;Creates a new Amazon Redshift security group. You use security groups to control access to non-VPC clusters.&lt;/p&gt; &lt;p&gt; For information about managing security groups, go to &lt;a href&#x3D;\&quot;https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-security-groups.html\&quot;&gt;Amazon Redshift Cluster Security Groups&lt;/a&gt; in the &lt;i&gt;Amazon Redshift Cluster Management Guide&lt;/i&gt;.&lt;/p&gt;
     * @param clusterSecurityGroupName &lt;p&gt;The name for the security group. Amazon Redshift stores the value as a lowercase string.&lt;/p&gt; &lt;p&gt;Constraints:&lt;/p&gt; &lt;ul&gt; &lt;li&gt; &lt;p&gt;Must contain no more than 255 alphanumeric characters or hyphens.&lt;/p&gt; &lt;/li&gt; &lt;li&gt; &lt;p&gt;Must not be \&quot;Default\&quot;.&lt;/p&gt; &lt;/li&gt; &lt;li&gt; &lt;p&gt;Must be unique for all security groups that are created by your Amazon Web Services account.&lt;/p&gt; &lt;/li&gt; &lt;/ul&gt; &lt;p&gt;Example: &lt;code&gt;examplesecuritygroup&lt;/code&gt; &lt;/p&gt; (required)
     * @param description A description for the security group. (required)
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param tags A list of tag instances. (optional)
     * @return ApiResponse&lt;CreateClusterSecurityGroupResult&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> ClusterSecurityGroupAlreadyExistsFault </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> ClusterSecurityGroupQuotaExceededFault </td><td>  -  </td></tr>
        <tr><td> 482 </td><td> TagLimitExceededFault </td><td>  -  </td></tr>
        <tr><td> 483 </td><td> InvalidTagFault </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<CreateClusterSecurityGroupResult> gETCreateClusterSecurityGroupWithHttpInfo(String clusterSecurityGroupName, String description, String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, List<GETCreateClusterTagsParameterInner> tags) throws ApiException {
        okhttp3.Call localVarCall = gETCreateClusterSecurityGroupValidateBeforeCall(clusterSecurityGroupName, description, action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, tags, null);
        Type localVarReturnType = new TypeToken<CreateClusterSecurityGroupResult>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     *  (asynchronously)
     * &lt;p&gt;Creates a new Amazon Redshift security group. You use security groups to control access to non-VPC clusters.&lt;/p&gt; &lt;p&gt; For information about managing security groups, go to &lt;a href&#x3D;\&quot;https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-security-groups.html\&quot;&gt;Amazon Redshift Cluster Security Groups&lt;/a&gt; in the &lt;i&gt;Amazon Redshift Cluster Management Guide&lt;/i&gt;.&lt;/p&gt;
     * @param clusterSecurityGroupName &lt;p&gt;The name for the security group. Amazon Redshift stores the value as a lowercase string.&lt;/p&gt; &lt;p&gt;Constraints:&lt;/p&gt; &lt;ul&gt; &lt;li&gt; &lt;p&gt;Must contain no more than 255 alphanumeric characters or hyphens.&lt;/p&gt; &lt;/li&gt; &lt;li&gt; &lt;p&gt;Must not be \&quot;Default\&quot;.&lt;/p&gt; &lt;/li&gt; &lt;li&gt; &lt;p&gt;Must be unique for all security groups that are created by your Amazon Web Services account.&lt;/p&gt; &lt;/li&gt; &lt;/ul&gt; &lt;p&gt;Example: &lt;code&gt;examplesecuritygroup&lt;/code&gt; &lt;/p&gt; (required)
     * @param description A description for the security group. (required)
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param tags A list of tag instances. (optional)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> ClusterSecurityGroupAlreadyExistsFault </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> ClusterSecurityGroupQuotaExceededFault </td><td>  -  </td></tr>
        <tr><td> 482 </td><td> TagLimitExceededFault </td><td>  -  </td></tr>
        <tr><td> 483 </td><td> InvalidTagFault </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call gETCreateClusterSecurityGroupAsync(String clusterSecurityGroupName, String description, String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, List<GETCreateClusterTagsParameterInner> tags, final ApiCallback<CreateClusterSecurityGroupResult> _callback) throws ApiException {

        okhttp3.Call localVarCall = gETCreateClusterSecurityGroupValidateBeforeCall(clusterSecurityGroupName, description, action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, tags, _callback);
        Type localVarReturnType = new TypeToken<CreateClusterSecurityGroupResult>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for gETCreateClusterSnapshot
     * @param snapshotIdentifier &lt;p&gt;A unique identifier for the snapshot that you are requesting. This identifier must be unique for all snapshots within the Amazon Web Services account.&lt;/p&gt; &lt;p&gt;Constraints:&lt;/p&gt; &lt;ul&gt; &lt;li&gt; &lt;p&gt;Cannot be null, empty, or blank&lt;/p&gt; &lt;/li&gt; &lt;li&gt; &lt;p&gt;Must contain from 1 to 255 alphanumeric characters or hyphens&lt;/p&gt; &lt;/li&gt; &lt;li&gt; &lt;p&gt;First character must be a letter&lt;/p&gt; &lt;/li&gt; &lt;li&gt; &lt;p&gt;Cannot end with a hyphen or contain two consecutive hyphens&lt;/p&gt; &lt;/li&gt; &lt;/ul&gt; &lt;p&gt;Example: &lt;code&gt;my-snapshot-id&lt;/code&gt; &lt;/p&gt; (required)
     * @param clusterIdentifier The cluster identifier for which you want a snapshot. (required)
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param manualSnapshotRetentionPeriod &lt;p&gt;The number of days that a manual snapshot is retained. If the value is -1, the manual snapshot is retained indefinitely. &lt;/p&gt; &lt;p&gt;The value must be either -1 or an integer between 1 and 3,653.&lt;/p&gt; &lt;p&gt;The default value is -1.&lt;/p&gt; (optional)
     * @param tags A list of tag instances. (optional)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> ClusterSnapshotAlreadyExistsFault </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> InvalidClusterStateFault </td><td>  -  </td></tr>
        <tr><td> 482 </td><td> ClusterNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 483 </td><td> ClusterSnapshotQuotaExceededFault </td><td>  -  </td></tr>
        <tr><td> 484 </td><td> TagLimitExceededFault </td><td>  -  </td></tr>
        <tr><td> 485 </td><td> InvalidTagFault </td><td>  -  </td></tr>
        <tr><td> 486 </td><td> InvalidRetentionPeriodFault </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call gETCreateClusterSnapshotCall(String snapshotIdentifier, String clusterIdentifier, String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, Integer manualSnapshotRetentionPeriod, List<GETCreateClusterTagsParameterInner> tags, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/#Action=CreateClusterSnapshot";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (snapshotIdentifier != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("SnapshotIdentifier", snapshotIdentifier));
        }

        if (clusterIdentifier != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("ClusterIdentifier", clusterIdentifier));
        }

        if (manualSnapshotRetentionPeriod != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("ManualSnapshotRetentionPeriod", manualSnapshotRetentionPeriod));
        }

        if (tags != null) {
            localVarCollectionQueryParams.addAll(localVarApiClient.parameterToPairs("multi", "Tags", tags));
        }

        if (action != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("Action", action));
        }

        if (version != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("Version", version));
        }

        if (xAmzContentSha256 != null) {
            localVarHeaderParams.put("X-Amz-Content-Sha256", localVarApiClient.parameterToString(xAmzContentSha256));
        }

        if (xAmzDate != null) {
            localVarHeaderParams.put("X-Amz-Date", localVarApiClient.parameterToString(xAmzDate));
        }

        if (xAmzAlgorithm != null) {
            localVarHeaderParams.put("X-Amz-Algorithm", localVarApiClient.parameterToString(xAmzAlgorithm));
        }

        if (xAmzCredential != null) {
            localVarHeaderParams.put("X-Amz-Credential", localVarApiClient.parameterToString(xAmzCredential));
        }

        if (xAmzSecurityToken != null) {
            localVarHeaderParams.put("X-Amz-Security-Token", localVarApiClient.parameterToString(xAmzSecurityToken));
        }

        if (xAmzSignature != null) {
            localVarHeaderParams.put("X-Amz-Signature", localVarApiClient.parameterToString(xAmzSignature));
        }

        if (xAmzSignedHeaders != null) {
            localVarHeaderParams.put("X-Amz-SignedHeaders", localVarApiClient.parameterToString(xAmzSignedHeaders));
        }

        final String[] localVarAccepts = {
            "text/xml"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "hmac" };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call gETCreateClusterSnapshotValidateBeforeCall(String snapshotIdentifier, String clusterIdentifier, String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, Integer manualSnapshotRetentionPeriod, List<GETCreateClusterTagsParameterInner> tags, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'snapshotIdentifier' is set
        if (snapshotIdentifier == null) {
            throw new ApiException("Missing the required parameter 'snapshotIdentifier' when calling gETCreateClusterSnapshot(Async)");
        }

        // verify the required parameter 'clusterIdentifier' is set
        if (clusterIdentifier == null) {
            throw new ApiException("Missing the required parameter 'clusterIdentifier' when calling gETCreateClusterSnapshot(Async)");
        }

        // verify the required parameter 'action' is set
        if (action == null) {
            throw new ApiException("Missing the required parameter 'action' when calling gETCreateClusterSnapshot(Async)");
        }

        // verify the required parameter 'version' is set
        if (version == null) {
            throw new ApiException("Missing the required parameter 'version' when calling gETCreateClusterSnapshot(Async)");
        }

        return gETCreateClusterSnapshotCall(snapshotIdentifier, clusterIdentifier, action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, manualSnapshotRetentionPeriod, tags, _callback);

    }

    /**
     * 
     * &lt;p&gt;Creates a manual snapshot of the specified cluster. The cluster must be in the &lt;code&gt;available&lt;/code&gt; state. &lt;/p&gt; &lt;p&gt; For more information about working with snapshots, go to &lt;a href&#x3D;\&quot;https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-snapshots.html\&quot;&gt;Amazon Redshift Snapshots&lt;/a&gt; in the &lt;i&gt;Amazon Redshift Cluster Management Guide&lt;/i&gt;.&lt;/p&gt;
     * @param snapshotIdentifier &lt;p&gt;A unique identifier for the snapshot that you are requesting. This identifier must be unique for all snapshots within the Amazon Web Services account.&lt;/p&gt; &lt;p&gt;Constraints:&lt;/p&gt; &lt;ul&gt; &lt;li&gt; &lt;p&gt;Cannot be null, empty, or blank&lt;/p&gt; &lt;/li&gt; &lt;li&gt; &lt;p&gt;Must contain from 1 to 255 alphanumeric characters or hyphens&lt;/p&gt; &lt;/li&gt; &lt;li&gt; &lt;p&gt;First character must be a letter&lt;/p&gt; &lt;/li&gt; &lt;li&gt; &lt;p&gt;Cannot end with a hyphen or contain two consecutive hyphens&lt;/p&gt; &lt;/li&gt; &lt;/ul&gt; &lt;p&gt;Example: &lt;code&gt;my-snapshot-id&lt;/code&gt; &lt;/p&gt; (required)
     * @param clusterIdentifier The cluster identifier for which you want a snapshot. (required)
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param manualSnapshotRetentionPeriod &lt;p&gt;The number of days that a manual snapshot is retained. If the value is -1, the manual snapshot is retained indefinitely. &lt;/p&gt; &lt;p&gt;The value must be either -1 or an integer between 1 and 3,653.&lt;/p&gt; &lt;p&gt;The default value is -1.&lt;/p&gt; (optional)
     * @param tags A list of tag instances. (optional)
     * @return CreateClusterSnapshotResult
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> ClusterSnapshotAlreadyExistsFault </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> InvalidClusterStateFault </td><td>  -  </td></tr>
        <tr><td> 482 </td><td> ClusterNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 483 </td><td> ClusterSnapshotQuotaExceededFault </td><td>  -  </td></tr>
        <tr><td> 484 </td><td> TagLimitExceededFault </td><td>  -  </td></tr>
        <tr><td> 485 </td><td> InvalidTagFault </td><td>  -  </td></tr>
        <tr><td> 486 </td><td> InvalidRetentionPeriodFault </td><td>  -  </td></tr>
     </table>
     */
    public CreateClusterSnapshotResult gETCreateClusterSnapshot(String snapshotIdentifier, String clusterIdentifier, String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, Integer manualSnapshotRetentionPeriod, List<GETCreateClusterTagsParameterInner> tags) throws ApiException {
        ApiResponse<CreateClusterSnapshotResult> localVarResp = gETCreateClusterSnapshotWithHttpInfo(snapshotIdentifier, clusterIdentifier, action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, manualSnapshotRetentionPeriod, tags);
        return localVarResp.getData();
    }

    /**
     * 
     * &lt;p&gt;Creates a manual snapshot of the specified cluster. The cluster must be in the &lt;code&gt;available&lt;/code&gt; state. &lt;/p&gt; &lt;p&gt; For more information about working with snapshots, go to &lt;a href&#x3D;\&quot;https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-snapshots.html\&quot;&gt;Amazon Redshift Snapshots&lt;/a&gt; in the &lt;i&gt;Amazon Redshift Cluster Management Guide&lt;/i&gt;.&lt;/p&gt;
     * @param snapshotIdentifier &lt;p&gt;A unique identifier for the snapshot that you are requesting. This identifier must be unique for all snapshots within the Amazon Web Services account.&lt;/p&gt; &lt;p&gt;Constraints:&lt;/p&gt; &lt;ul&gt; &lt;li&gt; &lt;p&gt;Cannot be null, empty, or blank&lt;/p&gt; &lt;/li&gt; &lt;li&gt; &lt;p&gt;Must contain from 1 to 255 alphanumeric characters or hyphens&lt;/p&gt; &lt;/li&gt; &lt;li&gt; &lt;p&gt;First character must be a letter&lt;/p&gt; &lt;/li&gt; &lt;li&gt; &lt;p&gt;Cannot end with a hyphen or contain two consecutive hyphens&lt;/p&gt; &lt;/li&gt; &lt;/ul&gt; &lt;p&gt;Example: &lt;code&gt;my-snapshot-id&lt;/code&gt; &lt;/p&gt; (required)
     * @param clusterIdentifier The cluster identifier for which you want a snapshot. (required)
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param manualSnapshotRetentionPeriod &lt;p&gt;The number of days that a manual snapshot is retained. If the value is -1, the manual snapshot is retained indefinitely. &lt;/p&gt; &lt;p&gt;The value must be either -1 or an integer between 1 and 3,653.&lt;/p&gt; &lt;p&gt;The default value is -1.&lt;/p&gt; (optional)
     * @param tags A list of tag instances. (optional)
     * @return ApiResponse&lt;CreateClusterSnapshotResult&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> ClusterSnapshotAlreadyExistsFault </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> InvalidClusterStateFault </td><td>  -  </td></tr>
        <tr><td> 482 </td><td> ClusterNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 483 </td><td> ClusterSnapshotQuotaExceededFault </td><td>  -  </td></tr>
        <tr><td> 484 </td><td> TagLimitExceededFault </td><td>  -  </td></tr>
        <tr><td> 485 </td><td> InvalidTagFault </td><td>  -  </td></tr>
        <tr><td> 486 </td><td> InvalidRetentionPeriodFault </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<CreateClusterSnapshotResult> gETCreateClusterSnapshotWithHttpInfo(String snapshotIdentifier, String clusterIdentifier, String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, Integer manualSnapshotRetentionPeriod, List<GETCreateClusterTagsParameterInner> tags) throws ApiException {
        okhttp3.Call localVarCall = gETCreateClusterSnapshotValidateBeforeCall(snapshotIdentifier, clusterIdentifier, action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, manualSnapshotRetentionPeriod, tags, null);
        Type localVarReturnType = new TypeToken<CreateClusterSnapshotResult>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     *  (asynchronously)
     * &lt;p&gt;Creates a manual snapshot of the specified cluster. The cluster must be in the &lt;code&gt;available&lt;/code&gt; state. &lt;/p&gt; &lt;p&gt; For more information about working with snapshots, go to &lt;a href&#x3D;\&quot;https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-snapshots.html\&quot;&gt;Amazon Redshift Snapshots&lt;/a&gt; in the &lt;i&gt;Amazon Redshift Cluster Management Guide&lt;/i&gt;.&lt;/p&gt;
     * @param snapshotIdentifier &lt;p&gt;A unique identifier for the snapshot that you are requesting. This identifier must be unique for all snapshots within the Amazon Web Services account.&lt;/p&gt; &lt;p&gt;Constraints:&lt;/p&gt; &lt;ul&gt; &lt;li&gt; &lt;p&gt;Cannot be null, empty, or blank&lt;/p&gt; &lt;/li&gt; &lt;li&gt; &lt;p&gt;Must contain from 1 to 255 alphanumeric characters or hyphens&lt;/p&gt; &lt;/li&gt; &lt;li&gt; &lt;p&gt;First character must be a letter&lt;/p&gt; &lt;/li&gt; &lt;li&gt; &lt;p&gt;Cannot end with a hyphen or contain two consecutive hyphens&lt;/p&gt; &lt;/li&gt; &lt;/ul&gt; &lt;p&gt;Example: &lt;code&gt;my-snapshot-id&lt;/code&gt; &lt;/p&gt; (required)
     * @param clusterIdentifier The cluster identifier for which you want a snapshot. (required)
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param manualSnapshotRetentionPeriod &lt;p&gt;The number of days that a manual snapshot is retained. If the value is -1, the manual snapshot is retained indefinitely. &lt;/p&gt; &lt;p&gt;The value must be either -1 or an integer between 1 and 3,653.&lt;/p&gt; &lt;p&gt;The default value is -1.&lt;/p&gt; (optional)
     * @param tags A list of tag instances. (optional)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> ClusterSnapshotAlreadyExistsFault </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> InvalidClusterStateFault </td><td>  -  </td></tr>
        <tr><td> 482 </td><td> ClusterNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 483 </td><td> ClusterSnapshotQuotaExceededFault </td><td>  -  </td></tr>
        <tr><td> 484 </td><td> TagLimitExceededFault </td><td>  -  </td></tr>
        <tr><td> 485 </td><td> InvalidTagFault </td><td>  -  </td></tr>
        <tr><td> 486 </td><td> InvalidRetentionPeriodFault </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call gETCreateClusterSnapshotAsync(String snapshotIdentifier, String clusterIdentifier, String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, Integer manualSnapshotRetentionPeriod, List<GETCreateClusterTagsParameterInner> tags, final ApiCallback<CreateClusterSnapshotResult> _callback) throws ApiException {

        okhttp3.Call localVarCall = gETCreateClusterSnapshotValidateBeforeCall(snapshotIdentifier, clusterIdentifier, action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, manualSnapshotRetentionPeriod, tags, _callback);
        Type localVarReturnType = new TypeToken<CreateClusterSnapshotResult>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for gETCreateClusterSubnetGroup
     * @param clusterSubnetGroupName &lt;p&gt;The name for the subnet group. Amazon Redshift stores the value as a lowercase string.&lt;/p&gt; &lt;p&gt;Constraints:&lt;/p&gt; &lt;ul&gt; &lt;li&gt; &lt;p&gt;Must contain no more than 255 alphanumeric characters or hyphens.&lt;/p&gt; &lt;/li&gt; &lt;li&gt; &lt;p&gt;Must not be \&quot;Default\&quot;.&lt;/p&gt; &lt;/li&gt; &lt;li&gt; &lt;p&gt;Must be unique for all subnet groups that are created by your Amazon Web Services account.&lt;/p&gt; &lt;/li&gt; &lt;/ul&gt; &lt;p&gt;Example: &lt;code&gt;examplesubnetgroup&lt;/code&gt; &lt;/p&gt; (required)
     * @param description A description for the subnet group. (required)
     * @param subnetIds An array of VPC subnet IDs. A maximum of 20 subnets can be modified in a single request. (required)
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param tags A list of tag instances. (optional)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> ClusterSubnetGroupAlreadyExistsFault </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> ClusterSubnetGroupQuotaExceededFault </td><td>  -  </td></tr>
        <tr><td> 482 </td><td> ClusterSubnetQuotaExceededFault </td><td>  -  </td></tr>
        <tr><td> 483 </td><td> InvalidSubnet </td><td>  -  </td></tr>
        <tr><td> 484 </td><td> UnauthorizedOperation </td><td>  -  </td></tr>
        <tr><td> 485 </td><td> TagLimitExceededFault </td><td>  -  </td></tr>
        <tr><td> 486 </td><td> InvalidTagFault </td><td>  -  </td></tr>
        <tr><td> 487 </td><td> DependentServiceRequestThrottlingFault </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call gETCreateClusterSubnetGroupCall(String clusterSubnetGroupName, String description, List<String> subnetIds, String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, List<GETCreateClusterTagsParameterInner> tags, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/#Action=CreateClusterSubnetGroup";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (clusterSubnetGroupName != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("ClusterSubnetGroupName", clusterSubnetGroupName));
        }

        if (description != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("Description", description));
        }

        if (subnetIds != null) {
            localVarCollectionQueryParams.addAll(localVarApiClient.parameterToPairs("multi", "SubnetIds", subnetIds));
        }

        if (tags != null) {
            localVarCollectionQueryParams.addAll(localVarApiClient.parameterToPairs("multi", "Tags", tags));
        }

        if (action != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("Action", action));
        }

        if (version != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("Version", version));
        }

        if (xAmzContentSha256 != null) {
            localVarHeaderParams.put("X-Amz-Content-Sha256", localVarApiClient.parameterToString(xAmzContentSha256));
        }

        if (xAmzDate != null) {
            localVarHeaderParams.put("X-Amz-Date", localVarApiClient.parameterToString(xAmzDate));
        }

        if (xAmzAlgorithm != null) {
            localVarHeaderParams.put("X-Amz-Algorithm", localVarApiClient.parameterToString(xAmzAlgorithm));
        }

        if (xAmzCredential != null) {
            localVarHeaderParams.put("X-Amz-Credential", localVarApiClient.parameterToString(xAmzCredential));
        }

        if (xAmzSecurityToken != null) {
            localVarHeaderParams.put("X-Amz-Security-Token", localVarApiClient.parameterToString(xAmzSecurityToken));
        }

        if (xAmzSignature != null) {
            localVarHeaderParams.put("X-Amz-Signature", localVarApiClient.parameterToString(xAmzSignature));
        }

        if (xAmzSignedHeaders != null) {
            localVarHeaderParams.put("X-Amz-SignedHeaders", localVarApiClient.parameterToString(xAmzSignedHeaders));
        }

        final String[] localVarAccepts = {
            "text/xml"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "hmac" };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call gETCreateClusterSubnetGroupValidateBeforeCall(String clusterSubnetGroupName, String description, List<String> subnetIds, String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, List<GETCreateClusterTagsParameterInner> tags, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'clusterSubnetGroupName' is set
        if (clusterSubnetGroupName == null) {
            throw new ApiException("Missing the required parameter 'clusterSubnetGroupName' when calling gETCreateClusterSubnetGroup(Async)");
        }

        // verify the required parameter 'description' is set
        if (description == null) {
            throw new ApiException("Missing the required parameter 'description' when calling gETCreateClusterSubnetGroup(Async)");
        }

        // verify the required parameter 'subnetIds' is set
        if (subnetIds == null) {
            throw new ApiException("Missing the required parameter 'subnetIds' when calling gETCreateClusterSubnetGroup(Async)");
        }

        // verify the required parameter 'action' is set
        if (action == null) {
            throw new ApiException("Missing the required parameter 'action' when calling gETCreateClusterSubnetGroup(Async)");
        }

        // verify the required parameter 'version' is set
        if (version == null) {
            throw new ApiException("Missing the required parameter 'version' when calling gETCreateClusterSubnetGroup(Async)");
        }

        return gETCreateClusterSubnetGroupCall(clusterSubnetGroupName, description, subnetIds, action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, tags, _callback);

    }

    /**
     * 
     * &lt;p&gt;Creates a new Amazon Redshift subnet group. You must provide a list of one or more subnets in your existing Amazon Virtual Private Cloud (Amazon VPC) when creating Amazon Redshift subnet group.&lt;/p&gt; &lt;p&gt; For information about subnet groups, go to &lt;a href&#x3D;\&quot;https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-cluster-subnet-groups.html\&quot;&gt;Amazon Redshift Cluster Subnet Groups&lt;/a&gt; in the &lt;i&gt;Amazon Redshift Cluster Management Guide&lt;/i&gt;.&lt;/p&gt;
     * @param clusterSubnetGroupName &lt;p&gt;The name for the subnet group. Amazon Redshift stores the value as a lowercase string.&lt;/p&gt; &lt;p&gt;Constraints:&lt;/p&gt; &lt;ul&gt; &lt;li&gt; &lt;p&gt;Must contain no more than 255 alphanumeric characters or hyphens.&lt;/p&gt; &lt;/li&gt; &lt;li&gt; &lt;p&gt;Must not be \&quot;Default\&quot;.&lt;/p&gt; &lt;/li&gt; &lt;li&gt; &lt;p&gt;Must be unique for all subnet groups that are created by your Amazon Web Services account.&lt;/p&gt; &lt;/li&gt; &lt;/ul&gt; &lt;p&gt;Example: &lt;code&gt;examplesubnetgroup&lt;/code&gt; &lt;/p&gt; (required)
     * @param description A description for the subnet group. (required)
     * @param subnetIds An array of VPC subnet IDs. A maximum of 20 subnets can be modified in a single request. (required)
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param tags A list of tag instances. (optional)
     * @return CreateClusterSubnetGroupResult
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> ClusterSubnetGroupAlreadyExistsFault </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> ClusterSubnetGroupQuotaExceededFault </td><td>  -  </td></tr>
        <tr><td> 482 </td><td> ClusterSubnetQuotaExceededFault </td><td>  -  </td></tr>
        <tr><td> 483 </td><td> InvalidSubnet </td><td>  -  </td></tr>
        <tr><td> 484 </td><td> UnauthorizedOperation </td><td>  -  </td></tr>
        <tr><td> 485 </td><td> TagLimitExceededFault </td><td>  -  </td></tr>
        <tr><td> 486 </td><td> InvalidTagFault </td><td>  -  </td></tr>
        <tr><td> 487 </td><td> DependentServiceRequestThrottlingFault </td><td>  -  </td></tr>
     </table>
     */
    public CreateClusterSubnetGroupResult gETCreateClusterSubnetGroup(String clusterSubnetGroupName, String description, List<String> subnetIds, String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, List<GETCreateClusterTagsParameterInner> tags) throws ApiException {
        ApiResponse<CreateClusterSubnetGroupResult> localVarResp = gETCreateClusterSubnetGroupWithHttpInfo(clusterSubnetGroupName, description, subnetIds, action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, tags);
        return localVarResp.getData();
    }

    /**
     * 
     * &lt;p&gt;Creates a new Amazon Redshift subnet group. You must provide a list of one or more subnets in your existing Amazon Virtual Private Cloud (Amazon VPC) when creating Amazon Redshift subnet group.&lt;/p&gt; &lt;p&gt; For information about subnet groups, go to &lt;a href&#x3D;\&quot;https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-cluster-subnet-groups.html\&quot;&gt;Amazon Redshift Cluster Subnet Groups&lt;/a&gt; in the &lt;i&gt;Amazon Redshift Cluster Management Guide&lt;/i&gt;.&lt;/p&gt;
     * @param clusterSubnetGroupName &lt;p&gt;The name for the subnet group. Amazon Redshift stores the value as a lowercase string.&lt;/p&gt; &lt;p&gt;Constraints:&lt;/p&gt; &lt;ul&gt; &lt;li&gt; &lt;p&gt;Must contain no more than 255 alphanumeric characters or hyphens.&lt;/p&gt; &lt;/li&gt; &lt;li&gt; &lt;p&gt;Must not be \&quot;Default\&quot;.&lt;/p&gt; &lt;/li&gt; &lt;li&gt; &lt;p&gt;Must be unique for all subnet groups that are created by your Amazon Web Services account.&lt;/p&gt; &lt;/li&gt; &lt;/ul&gt; &lt;p&gt;Example: &lt;code&gt;examplesubnetgroup&lt;/code&gt; &lt;/p&gt; (required)
     * @param description A description for the subnet group. (required)
     * @param subnetIds An array of VPC subnet IDs. A maximum of 20 subnets can be modified in a single request. (required)
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param tags A list of tag instances. (optional)
     * @return ApiResponse&lt;CreateClusterSubnetGroupResult&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> ClusterSubnetGroupAlreadyExistsFault </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> ClusterSubnetGroupQuotaExceededFault </td><td>  -  </td></tr>
        <tr><td> 482 </td><td> ClusterSubnetQuotaExceededFault </td><td>  -  </td></tr>
        <tr><td> 483 </td><td> InvalidSubnet </td><td>  -  </td></tr>
        <tr><td> 484 </td><td> UnauthorizedOperation </td><td>  -  </td></tr>
        <tr><td> 485 </td><td> TagLimitExceededFault </td><td>  -  </td></tr>
        <tr><td> 486 </td><td> InvalidTagFault </td><td>  -  </td></tr>
        <tr><td> 487 </td><td> DependentServiceRequestThrottlingFault </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<CreateClusterSubnetGroupResult> gETCreateClusterSubnetGroupWithHttpInfo(String clusterSubnetGroupName, String description, List<String> subnetIds, String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, List<GETCreateClusterTagsParameterInner> tags) throws ApiException {
        okhttp3.Call localVarCall = gETCreateClusterSubnetGroupValidateBeforeCall(clusterSubnetGroupName, description, subnetIds, action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, tags, null);
        Type localVarReturnType = new TypeToken<CreateClusterSubnetGroupResult>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     *  (asynchronously)
     * &lt;p&gt;Creates a new Amazon Redshift subnet group. You must provide a list of one or more subnets in your existing Amazon Virtual Private Cloud (Amazon VPC) when creating Amazon Redshift subnet group.&lt;/p&gt; &lt;p&gt; For information about subnet groups, go to &lt;a href&#x3D;\&quot;https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-cluster-subnet-groups.html\&quot;&gt;Amazon Redshift Cluster Subnet Groups&lt;/a&gt; in the &lt;i&gt;Amazon Redshift Cluster Management Guide&lt;/i&gt;.&lt;/p&gt;
     * @param clusterSubnetGroupName &lt;p&gt;The name for the subnet group. Amazon Redshift stores the value as a lowercase string.&lt;/p&gt; &lt;p&gt;Constraints:&lt;/p&gt; &lt;ul&gt; &lt;li&gt; &lt;p&gt;Must contain no more than 255 alphanumeric characters or hyphens.&lt;/p&gt; &lt;/li&gt; &lt;li&gt; &lt;p&gt;Must not be \&quot;Default\&quot;.&lt;/p&gt; &lt;/li&gt; &lt;li&gt; &lt;p&gt;Must be unique for all subnet groups that are created by your Amazon Web Services account.&lt;/p&gt; &lt;/li&gt; &lt;/ul&gt; &lt;p&gt;Example: &lt;code&gt;examplesubnetgroup&lt;/code&gt; &lt;/p&gt; (required)
     * @param description A description for the subnet group. (required)
     * @param subnetIds An array of VPC subnet IDs. A maximum of 20 subnets can be modified in a single request. (required)
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param tags A list of tag instances. (optional)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> ClusterSubnetGroupAlreadyExistsFault </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> ClusterSubnetGroupQuotaExceededFault </td><td>  -  </td></tr>
        <tr><td> 482 </td><td> ClusterSubnetQuotaExceededFault </td><td>  -  </td></tr>
        <tr><td> 483 </td><td> InvalidSubnet </td><td>  -  </td></tr>
        <tr><td> 484 </td><td> UnauthorizedOperation </td><td>  -  </td></tr>
        <tr><td> 485 </td><td> TagLimitExceededFault </td><td>  -  </td></tr>
        <tr><td> 486 </td><td> InvalidTagFault </td><td>  -  </td></tr>
        <tr><td> 487 </td><td> DependentServiceRequestThrottlingFault </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call gETCreateClusterSubnetGroupAsync(String clusterSubnetGroupName, String description, List<String> subnetIds, String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, List<GETCreateClusterTagsParameterInner> tags, final ApiCallback<CreateClusterSubnetGroupResult> _callback) throws ApiException {

        okhttp3.Call localVarCall = gETCreateClusterSubnetGroupValidateBeforeCall(clusterSubnetGroupName, description, subnetIds, action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, tags, _callback);
        Type localVarReturnType = new TypeToken<CreateClusterSubnetGroupResult>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for gETCreateCustomDomainAssociation
     * @param customDomainName The custom domain name for a custom domain association. (required)
     * @param customDomainCertificateArn The certificate Amazon Resource Name (ARN) for the custom domain name association. (required)
     * @param clusterIdentifier The cluster identifier that the custom domain is associated with. (required)
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> UnsupportedOperationFault </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> ClusterNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 482 </td><td> CustomCnameAssociationFault </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call gETCreateCustomDomainAssociationCall(String customDomainName, String customDomainCertificateArn, String clusterIdentifier, String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/#Action=CreateCustomDomainAssociation";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (customDomainName != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("CustomDomainName", customDomainName));
        }

        if (customDomainCertificateArn != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("CustomDomainCertificateArn", customDomainCertificateArn));
        }

        if (clusterIdentifier != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("ClusterIdentifier", clusterIdentifier));
        }

        if (action != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("Action", action));
        }

        if (version != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("Version", version));
        }

        if (xAmzContentSha256 != null) {
            localVarHeaderParams.put("X-Amz-Content-Sha256", localVarApiClient.parameterToString(xAmzContentSha256));
        }

        if (xAmzDate != null) {
            localVarHeaderParams.put("X-Amz-Date", localVarApiClient.parameterToString(xAmzDate));
        }

        if (xAmzAlgorithm != null) {
            localVarHeaderParams.put("X-Amz-Algorithm", localVarApiClient.parameterToString(xAmzAlgorithm));
        }

        if (xAmzCredential != null) {
            localVarHeaderParams.put("X-Amz-Credential", localVarApiClient.parameterToString(xAmzCredential));
        }

        if (xAmzSecurityToken != null) {
            localVarHeaderParams.put("X-Amz-Security-Token", localVarApiClient.parameterToString(xAmzSecurityToken));
        }

        if (xAmzSignature != null) {
            localVarHeaderParams.put("X-Amz-Signature", localVarApiClient.parameterToString(xAmzSignature));
        }

        if (xAmzSignedHeaders != null) {
            localVarHeaderParams.put("X-Amz-SignedHeaders", localVarApiClient.parameterToString(xAmzSignedHeaders));
        }

        final String[] localVarAccepts = {
            "text/xml"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "hmac" };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call gETCreateCustomDomainAssociationValidateBeforeCall(String customDomainName, String customDomainCertificateArn, String clusterIdentifier, String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'customDomainName' is set
        if (customDomainName == null) {
            throw new ApiException("Missing the required parameter 'customDomainName' when calling gETCreateCustomDomainAssociation(Async)");
        }

        // verify the required parameter 'customDomainCertificateArn' is set
        if (customDomainCertificateArn == null) {
            throw new ApiException("Missing the required parameter 'customDomainCertificateArn' when calling gETCreateCustomDomainAssociation(Async)");
        }

        // verify the required parameter 'clusterIdentifier' is set
        if (clusterIdentifier == null) {
            throw new ApiException("Missing the required parameter 'clusterIdentifier' when calling gETCreateCustomDomainAssociation(Async)");
        }

        // verify the required parameter 'action' is set
        if (action == null) {
            throw new ApiException("Missing the required parameter 'action' when calling gETCreateCustomDomainAssociation(Async)");
        }

        // verify the required parameter 'version' is set
        if (version == null) {
            throw new ApiException("Missing the required parameter 'version' when calling gETCreateCustomDomainAssociation(Async)");
        }

        return gETCreateCustomDomainAssociationCall(customDomainName, customDomainCertificateArn, clusterIdentifier, action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, _callback);

    }

    /**
     * 
     * Used to create a custom domain name for a cluster. Properties include the custom domain name, the cluster the custom domain is associated with, and the certificate Amazon Resource Name (ARN).
     * @param customDomainName The custom domain name for a custom domain association. (required)
     * @param customDomainCertificateArn The certificate Amazon Resource Name (ARN) for the custom domain name association. (required)
     * @param clusterIdentifier The cluster identifier that the custom domain is associated with. (required)
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @return CreateCustomDomainAssociationResult
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> UnsupportedOperationFault </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> ClusterNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 482 </td><td> CustomCnameAssociationFault </td><td>  -  </td></tr>
     </table>
     */
    public CreateCustomDomainAssociationResult gETCreateCustomDomainAssociation(String customDomainName, String customDomainCertificateArn, String clusterIdentifier, String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders) throws ApiException {
        ApiResponse<CreateCustomDomainAssociationResult> localVarResp = gETCreateCustomDomainAssociationWithHttpInfo(customDomainName, customDomainCertificateArn, clusterIdentifier, action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders);
        return localVarResp.getData();
    }

    /**
     * 
     * Used to create a custom domain name for a cluster. Properties include the custom domain name, the cluster the custom domain is associated with, and the certificate Amazon Resource Name (ARN).
     * @param customDomainName The custom domain name for a custom domain association. (required)
     * @param customDomainCertificateArn The certificate Amazon Resource Name (ARN) for the custom domain name association. (required)
     * @param clusterIdentifier The cluster identifier that the custom domain is associated with. (required)
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @return ApiResponse&lt;CreateCustomDomainAssociationResult&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> UnsupportedOperationFault </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> ClusterNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 482 </td><td> CustomCnameAssociationFault </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<CreateCustomDomainAssociationResult> gETCreateCustomDomainAssociationWithHttpInfo(String customDomainName, String customDomainCertificateArn, String clusterIdentifier, String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders) throws ApiException {
        okhttp3.Call localVarCall = gETCreateCustomDomainAssociationValidateBeforeCall(customDomainName, customDomainCertificateArn, clusterIdentifier, action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, null);
        Type localVarReturnType = new TypeToken<CreateCustomDomainAssociationResult>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     *  (asynchronously)
     * Used to create a custom domain name for a cluster. Properties include the custom domain name, the cluster the custom domain is associated with, and the certificate Amazon Resource Name (ARN).
     * @param customDomainName The custom domain name for a custom domain association. (required)
     * @param customDomainCertificateArn The certificate Amazon Resource Name (ARN) for the custom domain name association. (required)
     * @param clusterIdentifier The cluster identifier that the custom domain is associated with. (required)
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> UnsupportedOperationFault </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> ClusterNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 482 </td><td> CustomCnameAssociationFault </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call gETCreateCustomDomainAssociationAsync(String customDomainName, String customDomainCertificateArn, String clusterIdentifier, String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, final ApiCallback<CreateCustomDomainAssociationResult> _callback) throws ApiException {

        okhttp3.Call localVarCall = gETCreateCustomDomainAssociationValidateBeforeCall(customDomainName, customDomainCertificateArn, clusterIdentifier, action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, _callback);
        Type localVarReturnType = new TypeToken<CreateCustomDomainAssociationResult>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for gETCreateEndpointAccess
     * @param endpointName &lt;p&gt;The Redshift-managed VPC endpoint name.&lt;/p&gt; &lt;p&gt;An endpoint name must contain 1-30 characters. Valid characters are A-Z, a-z, 0-9, and hyphen(-). The first character must be a letter. The name can&#39;t contain two consecutive hyphens or end with a hyphen.&lt;/p&gt; (required)
     * @param subnetGroupName The subnet group from which Amazon Redshift chooses the subnet to deploy the endpoint. (required)
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param clusterIdentifier The cluster identifier of the cluster to access. (optional)
     * @param resourceOwner The Amazon Web Services account ID of the owner of the cluster. This is only required if the cluster is in another Amazon Web Services account. (optional)
     * @param vpcSecurityGroupIds The security group that defines the ports, protocols, and sources for inbound traffic that you are authorizing into your endpoint. (optional)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> ClusterNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> AccessToClusterDeniedFault </td><td>  -  </td></tr>
        <tr><td> 482 </td><td> EndpointsPerClusterLimitExceededFault </td><td>  -  </td></tr>
        <tr><td> 483 </td><td> EndpointsPerAuthorizationLimitExceededFault </td><td>  -  </td></tr>
        <tr><td> 484 </td><td> InvalidClusterSecurityGroupStateFault </td><td>  -  </td></tr>
        <tr><td> 485 </td><td> ClusterSubnetGroupNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 486 </td><td> EndpointAlreadyExistsFault </td><td>  -  </td></tr>
        <tr><td> 487 </td><td> UnsupportedOperationFault </td><td>  -  </td></tr>
        <tr><td> 488 </td><td> InvalidClusterStateFault </td><td>  -  </td></tr>
        <tr><td> 489 </td><td> UnauthorizedOperation </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call gETCreateEndpointAccessCall(String endpointName, String subnetGroupName, String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, String clusterIdentifier, String resourceOwner, List<String> vpcSecurityGroupIds, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/#Action=CreateEndpointAccess";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (clusterIdentifier != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("ClusterIdentifier", clusterIdentifier));
        }

        if (resourceOwner != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("ResourceOwner", resourceOwner));
        }

        if (endpointName != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("EndpointName", endpointName));
        }

        if (subnetGroupName != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("SubnetGroupName", subnetGroupName));
        }

        if (vpcSecurityGroupIds != null) {
            localVarCollectionQueryParams.addAll(localVarApiClient.parameterToPairs("multi", "VpcSecurityGroupIds", vpcSecurityGroupIds));
        }

        if (action != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("Action", action));
        }

        if (version != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("Version", version));
        }

        if (xAmzContentSha256 != null) {
            localVarHeaderParams.put("X-Amz-Content-Sha256", localVarApiClient.parameterToString(xAmzContentSha256));
        }

        if (xAmzDate != null) {
            localVarHeaderParams.put("X-Amz-Date", localVarApiClient.parameterToString(xAmzDate));
        }

        if (xAmzAlgorithm != null) {
            localVarHeaderParams.put("X-Amz-Algorithm", localVarApiClient.parameterToString(xAmzAlgorithm));
        }

        if (xAmzCredential != null) {
            localVarHeaderParams.put("X-Amz-Credential", localVarApiClient.parameterToString(xAmzCredential));
        }

        if (xAmzSecurityToken != null) {
            localVarHeaderParams.put("X-Amz-Security-Token", localVarApiClient.parameterToString(xAmzSecurityToken));
        }

        if (xAmzSignature != null) {
            localVarHeaderParams.put("X-Amz-Signature", localVarApiClient.parameterToString(xAmzSignature));
        }

        if (xAmzSignedHeaders != null) {
            localVarHeaderParams.put("X-Amz-SignedHeaders", localVarApiClient.parameterToString(xAmzSignedHeaders));
        }

        final String[] localVarAccepts = {
            "text/xml"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "hmac" };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call gETCreateEndpointAccessValidateBeforeCall(String endpointName, String subnetGroupName, String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, String clusterIdentifier, String resourceOwner, List<String> vpcSecurityGroupIds, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'endpointName' is set
        if (endpointName == null) {
            throw new ApiException("Missing the required parameter 'endpointName' when calling gETCreateEndpointAccess(Async)");
        }

        // verify the required parameter 'subnetGroupName' is set
        if (subnetGroupName == null) {
            throw new ApiException("Missing the required parameter 'subnetGroupName' when calling gETCreateEndpointAccess(Async)");
        }

        // verify the required parameter 'action' is set
        if (action == null) {
            throw new ApiException("Missing the required parameter 'action' when calling gETCreateEndpointAccess(Async)");
        }

        // verify the required parameter 'version' is set
        if (version == null) {
            throw new ApiException("Missing the required parameter 'version' when calling gETCreateEndpointAccess(Async)");
        }

        return gETCreateEndpointAccessCall(endpointName, subnetGroupName, action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, clusterIdentifier, resourceOwner, vpcSecurityGroupIds, _callback);

    }

    /**
     * 
     * Creates a Redshift-managed VPC endpoint.
     * @param endpointName &lt;p&gt;The Redshift-managed VPC endpoint name.&lt;/p&gt; &lt;p&gt;An endpoint name must contain 1-30 characters. Valid characters are A-Z, a-z, 0-9, and hyphen(-). The first character must be a letter. The name can&#39;t contain two consecutive hyphens or end with a hyphen.&lt;/p&gt; (required)
     * @param subnetGroupName The subnet group from which Amazon Redshift chooses the subnet to deploy the endpoint. (required)
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param clusterIdentifier The cluster identifier of the cluster to access. (optional)
     * @param resourceOwner The Amazon Web Services account ID of the owner of the cluster. This is only required if the cluster is in another Amazon Web Services account. (optional)
     * @param vpcSecurityGroupIds The security group that defines the ports, protocols, and sources for inbound traffic that you are authorizing into your endpoint. (optional)
     * @return EndpointAccess
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> ClusterNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> AccessToClusterDeniedFault </td><td>  -  </td></tr>
        <tr><td> 482 </td><td> EndpointsPerClusterLimitExceededFault </td><td>  -  </td></tr>
        <tr><td> 483 </td><td> EndpointsPerAuthorizationLimitExceededFault </td><td>  -  </td></tr>
        <tr><td> 484 </td><td> InvalidClusterSecurityGroupStateFault </td><td>  -  </td></tr>
        <tr><td> 485 </td><td> ClusterSubnetGroupNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 486 </td><td> EndpointAlreadyExistsFault </td><td>  -  </td></tr>
        <tr><td> 487 </td><td> UnsupportedOperationFault </td><td>  -  </td></tr>
        <tr><td> 488 </td><td> InvalidClusterStateFault </td><td>  -  </td></tr>
        <tr><td> 489 </td><td> UnauthorizedOperation </td><td>  -  </td></tr>
     </table>
     */
    public EndpointAccess gETCreateEndpointAccess(String endpointName, String subnetGroupName, String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, String clusterIdentifier, String resourceOwner, List<String> vpcSecurityGroupIds) throws ApiException {
        ApiResponse<EndpointAccess> localVarResp = gETCreateEndpointAccessWithHttpInfo(endpointName, subnetGroupName, action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, clusterIdentifier, resourceOwner, vpcSecurityGroupIds);
        return localVarResp.getData();
    }

    /**
     * 
     * Creates a Redshift-managed VPC endpoint.
     * @param endpointName &lt;p&gt;The Redshift-managed VPC endpoint name.&lt;/p&gt; &lt;p&gt;An endpoint name must contain 1-30 characters. Valid characters are A-Z, a-z, 0-9, and hyphen(-). The first character must be a letter. The name can&#39;t contain two consecutive hyphens or end with a hyphen.&lt;/p&gt; (required)
     * @param subnetGroupName The subnet group from which Amazon Redshift chooses the subnet to deploy the endpoint. (required)
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param clusterIdentifier The cluster identifier of the cluster to access. (optional)
     * @param resourceOwner The Amazon Web Services account ID of the owner of the cluster. This is only required if the cluster is in another Amazon Web Services account. (optional)
     * @param vpcSecurityGroupIds The security group that defines the ports, protocols, and sources for inbound traffic that you are authorizing into your endpoint. (optional)
     * @return ApiResponse&lt;EndpointAccess&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> ClusterNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> AccessToClusterDeniedFault </td><td>  -  </td></tr>
        <tr><td> 482 </td><td> EndpointsPerClusterLimitExceededFault </td><td>  -  </td></tr>
        <tr><td> 483 </td><td> EndpointsPerAuthorizationLimitExceededFault </td><td>  -  </td></tr>
        <tr><td> 484 </td><td> InvalidClusterSecurityGroupStateFault </td><td>  -  </td></tr>
        <tr><td> 485 </td><td> ClusterSubnetGroupNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 486 </td><td> EndpointAlreadyExistsFault </td><td>  -  </td></tr>
        <tr><td> 487 </td><td> UnsupportedOperationFault </td><td>  -  </td></tr>
        <tr><td> 488 </td><td> InvalidClusterStateFault </td><td>  -  </td></tr>
        <tr><td> 489 </td><td> UnauthorizedOperation </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<EndpointAccess> gETCreateEndpointAccessWithHttpInfo(String endpointName, String subnetGroupName, String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, String clusterIdentifier, String resourceOwner, List<String> vpcSecurityGroupIds) throws ApiException {
        okhttp3.Call localVarCall = gETCreateEndpointAccessValidateBeforeCall(endpointName, subnetGroupName, action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, clusterIdentifier, resourceOwner, vpcSecurityGroupIds, null);
        Type localVarReturnType = new TypeToken<EndpointAccess>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     *  (asynchronously)
     * Creates a Redshift-managed VPC endpoint.
     * @param endpointName &lt;p&gt;The Redshift-managed VPC endpoint name.&lt;/p&gt; &lt;p&gt;An endpoint name must contain 1-30 characters. Valid characters are A-Z, a-z, 0-9, and hyphen(-). The first character must be a letter. The name can&#39;t contain two consecutive hyphens or end with a hyphen.&lt;/p&gt; (required)
     * @param subnetGroupName The subnet group from which Amazon Redshift chooses the subnet to deploy the endpoint. (required)
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param clusterIdentifier The cluster identifier of the cluster to access. (optional)
     * @param resourceOwner The Amazon Web Services account ID of the owner of the cluster. This is only required if the cluster is in another Amazon Web Services account. (optional)
     * @param vpcSecurityGroupIds The security group that defines the ports, protocols, and sources for inbound traffic that you are authorizing into your endpoint. (optional)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> ClusterNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> AccessToClusterDeniedFault </td><td>  -  </td></tr>
        <tr><td> 482 </td><td> EndpointsPerClusterLimitExceededFault </td><td>  -  </td></tr>
        <tr><td> 483 </td><td> EndpointsPerAuthorizationLimitExceededFault </td><td>  -  </td></tr>
        <tr><td> 484 </td><td> InvalidClusterSecurityGroupStateFault </td><td>  -  </td></tr>
        <tr><td> 485 </td><td> ClusterSubnetGroupNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 486 </td><td> EndpointAlreadyExistsFault </td><td>  -  </td></tr>
        <tr><td> 487 </td><td> UnsupportedOperationFault </td><td>  -  </td></tr>
        <tr><td> 488 </td><td> InvalidClusterStateFault </td><td>  -  </td></tr>
        <tr><td> 489 </td><td> UnauthorizedOperation </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call gETCreateEndpointAccessAsync(String endpointName, String subnetGroupName, String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, String clusterIdentifier, String resourceOwner, List<String> vpcSecurityGroupIds, final ApiCallback<EndpointAccess> _callback) throws ApiException {

        okhttp3.Call localVarCall = gETCreateEndpointAccessValidateBeforeCall(endpointName, subnetGroupName, action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, clusterIdentifier, resourceOwner, vpcSecurityGroupIds, _callback);
        Type localVarReturnType = new TypeToken<EndpointAccess>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for gETCreateEventSubscription
     * @param subscriptionName &lt;p&gt;The name of the event subscription to be created.&lt;/p&gt; &lt;p&gt;Constraints:&lt;/p&gt; &lt;ul&gt; &lt;li&gt; &lt;p&gt;Cannot be null, empty, or blank.&lt;/p&gt; &lt;/li&gt; &lt;li&gt; &lt;p&gt;Must contain from 1 to 255 alphanumeric characters or hyphens.&lt;/p&gt; &lt;/li&gt; &lt;li&gt; &lt;p&gt;First character must be a letter.&lt;/p&gt; &lt;/li&gt; &lt;li&gt; &lt;p&gt;Cannot end with a hyphen or contain two consecutive hyphens.&lt;/p&gt; &lt;/li&gt; &lt;/ul&gt; (required)
     * @param snsTopicArn The Amazon Resource Name (ARN) of the Amazon SNS topic used to transmit the event notifications. The ARN is created by Amazon SNS when you create a topic and subscribe to it. (required)
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param sourceType &lt;p&gt;The type of source that will be generating the events. For example, if you want to be notified of events generated by a cluster, you would set this parameter to cluster. If this value is not specified, events are returned for all Amazon Redshift objects in your Amazon Web Services account. You must specify a source type in order to specify source IDs.&lt;/p&gt; &lt;p&gt;Valid values: cluster, cluster-parameter-group, cluster-security-group, cluster-snapshot, and scheduled-action.&lt;/p&gt; (optional)
     * @param sourceIds &lt;p&gt;A list of one or more identifiers of Amazon Redshift source objects. All of the objects must be of the same type as was specified in the source type parameter. The event subscription will return only events generated by the specified objects. If not specified, then events are returned for all objects within the source type specified.&lt;/p&gt; &lt;p&gt;Example: my-cluster-1, my-cluster-2&lt;/p&gt; &lt;p&gt;Example: my-snapshot-20131010&lt;/p&gt; (optional)
     * @param eventCategories &lt;p&gt;Specifies the Amazon Redshift event categories to be published by the event notification subscription.&lt;/p&gt; &lt;p&gt;Values: configuration, management, monitoring, security, pending&lt;/p&gt; (optional)
     * @param severity &lt;p&gt;Specifies the Amazon Redshift event severity to be published by the event notification subscription.&lt;/p&gt; &lt;p&gt;Values: ERROR, INFO&lt;/p&gt; (optional)
     * @param enabled A boolean value; set to &lt;code&gt;true&lt;/code&gt; to activate the subscription, and set to &lt;code&gt;false&lt;/code&gt; to create the subscription but not activate it.  (optional)
     * @param tags A list of tag instances. (optional)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> EventSubscriptionQuotaExceededFault </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> SubscriptionAlreadyExistFault </td><td>  -  </td></tr>
        <tr><td> 482 </td><td> SNSInvalidTopicFault </td><td>  -  </td></tr>
        <tr><td> 483 </td><td> SNSNoAuthorizationFault </td><td>  -  </td></tr>
        <tr><td> 484 </td><td> SNSTopicArnNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 485 </td><td> SubscriptionEventIdNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 486 </td><td> SubscriptionCategoryNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 487 </td><td> SubscriptionSeverityNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 488 </td><td> SourceNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 489 </td><td> TagLimitExceededFault </td><td>  -  </td></tr>
        <tr><td> 490 </td><td> InvalidTagFault </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call gETCreateEventSubscriptionCall(String subscriptionName, String snsTopicArn, String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, String sourceType, List<String> sourceIds, List<String> eventCategories, String severity, Boolean enabled, List<GETCreateClusterTagsParameterInner> tags, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/#Action=CreateEventSubscription";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (subscriptionName != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("SubscriptionName", subscriptionName));
        }

        if (snsTopicArn != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("SnsTopicArn", snsTopicArn));
        }

        if (sourceType != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("SourceType", sourceType));
        }

        if (sourceIds != null) {
            localVarCollectionQueryParams.addAll(localVarApiClient.parameterToPairs("multi", "SourceIds", sourceIds));
        }

        if (eventCategories != null) {
            localVarCollectionQueryParams.addAll(localVarApiClient.parameterToPairs("multi", "EventCategories", eventCategories));
        }

        if (severity != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("Severity", severity));
        }

        if (enabled != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("Enabled", enabled));
        }

        if (tags != null) {
            localVarCollectionQueryParams.addAll(localVarApiClient.parameterToPairs("multi", "Tags", tags));
        }

        if (action != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("Action", action));
        }

        if (version != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("Version", version));
        }

        if (xAmzContentSha256 != null) {
            localVarHeaderParams.put("X-Amz-Content-Sha256", localVarApiClient.parameterToString(xAmzContentSha256));
        }

        if (xAmzDate != null) {
            localVarHeaderParams.put("X-Amz-Date", localVarApiClient.parameterToString(xAmzDate));
        }

        if (xAmzAlgorithm != null) {
            localVarHeaderParams.put("X-Amz-Algorithm", localVarApiClient.parameterToString(xAmzAlgorithm));
        }

        if (xAmzCredential != null) {
            localVarHeaderParams.put("X-Amz-Credential", localVarApiClient.parameterToString(xAmzCredential));
        }

        if (xAmzSecurityToken != null) {
            localVarHeaderParams.put("X-Amz-Security-Token", localVarApiClient.parameterToString(xAmzSecurityToken));
        }

        if (xAmzSignature != null) {
            localVarHeaderParams.put("X-Amz-Signature", localVarApiClient.parameterToString(xAmzSignature));
        }

        if (xAmzSignedHeaders != null) {
            localVarHeaderParams.put("X-Amz-SignedHeaders", localVarApiClient.parameterToString(xAmzSignedHeaders));
        }

        final String[] localVarAccepts = {
            "text/xml"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "hmac" };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call gETCreateEventSubscriptionValidateBeforeCall(String subscriptionName, String snsTopicArn, String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, String sourceType, List<String> sourceIds, List<String> eventCategories, String severity, Boolean enabled, List<GETCreateClusterTagsParameterInner> tags, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'subscriptionName' is set
        if (subscriptionName == null) {
            throw new ApiException("Missing the required parameter 'subscriptionName' when calling gETCreateEventSubscription(Async)");
        }

        // verify the required parameter 'snsTopicArn' is set
        if (snsTopicArn == null) {
            throw new ApiException("Missing the required parameter 'snsTopicArn' when calling gETCreateEventSubscription(Async)");
        }

        // verify the required parameter 'action' is set
        if (action == null) {
            throw new ApiException("Missing the required parameter 'action' when calling gETCreateEventSubscription(Async)");
        }

        // verify the required parameter 'version' is set
        if (version == null) {
            throw new ApiException("Missing the required parameter 'version' when calling gETCreateEventSubscription(Async)");
        }

        return gETCreateEventSubscriptionCall(subscriptionName, snsTopicArn, action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, sourceType, sourceIds, eventCategories, severity, enabled, tags, _callback);

    }

    /**
     * 
     * &lt;p&gt;Creates an Amazon Redshift event notification subscription. This action requires an ARN (Amazon Resource Name) of an Amazon SNS topic created by either the Amazon Redshift console, the Amazon SNS console, or the Amazon SNS API. To obtain an ARN with Amazon SNS, you must create a topic in Amazon SNS and subscribe to the topic. The ARN is displayed in the SNS console.&lt;/p&gt; &lt;p&gt;You can specify the source type, and lists of Amazon Redshift source IDs, event categories, and event severities. Notifications will be sent for all events you want that match those criteria. For example, you can specify source type &#x3D; cluster, source ID &#x3D; my-cluster-1 and mycluster2, event categories &#x3D; Availability, Backup, and severity &#x3D; ERROR. The subscription will only send notifications for those ERROR events in the Availability and Backup categories for the specified clusters.&lt;/p&gt; &lt;p&gt;If you specify both the source type and source IDs, such as source type &#x3D; cluster and source identifier &#x3D; my-cluster-1, notifications will be sent for all the cluster events for my-cluster-1. If you specify a source type but do not specify a source identifier, you will receive notice of the events for the objects of that type in your Amazon Web Services account. If you do not specify either the SourceType nor the SourceIdentifier, you will be notified of events generated from all Amazon Redshift sources belonging to your Amazon Web Services account. You must specify a source type if you specify a source ID.&lt;/p&gt;
     * @param subscriptionName &lt;p&gt;The name of the event subscription to be created.&lt;/p&gt; &lt;p&gt;Constraints:&lt;/p&gt; &lt;ul&gt; &lt;li&gt; &lt;p&gt;Cannot be null, empty, or blank.&lt;/p&gt; &lt;/li&gt; &lt;li&gt; &lt;p&gt;Must contain from 1 to 255 alphanumeric characters or hyphens.&lt;/p&gt; &lt;/li&gt; &lt;li&gt; &lt;p&gt;First character must be a letter.&lt;/p&gt; &lt;/li&gt; &lt;li&gt; &lt;p&gt;Cannot end with a hyphen or contain two consecutive hyphens.&lt;/p&gt; &lt;/li&gt; &lt;/ul&gt; (required)
     * @param snsTopicArn The Amazon Resource Name (ARN) of the Amazon SNS topic used to transmit the event notifications. The ARN is created by Amazon SNS when you create a topic and subscribe to it. (required)
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param sourceType &lt;p&gt;The type of source that will be generating the events. For example, if you want to be notified of events generated by a cluster, you would set this parameter to cluster. If this value is not specified, events are returned for all Amazon Redshift objects in your Amazon Web Services account. You must specify a source type in order to specify source IDs.&lt;/p&gt; &lt;p&gt;Valid values: cluster, cluster-parameter-group, cluster-security-group, cluster-snapshot, and scheduled-action.&lt;/p&gt; (optional)
     * @param sourceIds &lt;p&gt;A list of one or more identifiers of Amazon Redshift source objects. All of the objects must be of the same type as was specified in the source type parameter. The event subscription will return only events generated by the specified objects. If not specified, then events are returned for all objects within the source type specified.&lt;/p&gt; &lt;p&gt;Example: my-cluster-1, my-cluster-2&lt;/p&gt; &lt;p&gt;Example: my-snapshot-20131010&lt;/p&gt; (optional)
     * @param eventCategories &lt;p&gt;Specifies the Amazon Redshift event categories to be published by the event notification subscription.&lt;/p&gt; &lt;p&gt;Values: configuration, management, monitoring, security, pending&lt;/p&gt; (optional)
     * @param severity &lt;p&gt;Specifies the Amazon Redshift event severity to be published by the event notification subscription.&lt;/p&gt; &lt;p&gt;Values: ERROR, INFO&lt;/p&gt; (optional)
     * @param enabled A boolean value; set to &lt;code&gt;true&lt;/code&gt; to activate the subscription, and set to &lt;code&gt;false&lt;/code&gt; to create the subscription but not activate it.  (optional)
     * @param tags A list of tag instances. (optional)
     * @return CreateEventSubscriptionResult
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> EventSubscriptionQuotaExceededFault </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> SubscriptionAlreadyExistFault </td><td>  -  </td></tr>
        <tr><td> 482 </td><td> SNSInvalidTopicFault </td><td>  -  </td></tr>
        <tr><td> 483 </td><td> SNSNoAuthorizationFault </td><td>  -  </td></tr>
        <tr><td> 484 </td><td> SNSTopicArnNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 485 </td><td> SubscriptionEventIdNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 486 </td><td> SubscriptionCategoryNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 487 </td><td> SubscriptionSeverityNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 488 </td><td> SourceNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 489 </td><td> TagLimitExceededFault </td><td>  -  </td></tr>
        <tr><td> 490 </td><td> InvalidTagFault </td><td>  -  </td></tr>
     </table>
     */
    public CreateEventSubscriptionResult gETCreateEventSubscription(String subscriptionName, String snsTopicArn, String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, String sourceType, List<String> sourceIds, List<String> eventCategories, String severity, Boolean enabled, List<GETCreateClusterTagsParameterInner> tags) throws ApiException {
        ApiResponse<CreateEventSubscriptionResult> localVarResp = gETCreateEventSubscriptionWithHttpInfo(subscriptionName, snsTopicArn, action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, sourceType, sourceIds, eventCategories, severity, enabled, tags);
        return localVarResp.getData();
    }

    /**
     * 
     * &lt;p&gt;Creates an Amazon Redshift event notification subscription. This action requires an ARN (Amazon Resource Name) of an Amazon SNS topic created by either the Amazon Redshift console, the Amazon SNS console, or the Amazon SNS API. To obtain an ARN with Amazon SNS, you must create a topic in Amazon SNS and subscribe to the topic. The ARN is displayed in the SNS console.&lt;/p&gt; &lt;p&gt;You can specify the source type, and lists of Amazon Redshift source IDs, event categories, and event severities. Notifications will be sent for all events you want that match those criteria. For example, you can specify source type &#x3D; cluster, source ID &#x3D; my-cluster-1 and mycluster2, event categories &#x3D; Availability, Backup, and severity &#x3D; ERROR. The subscription will only send notifications for those ERROR events in the Availability and Backup categories for the specified clusters.&lt;/p&gt; &lt;p&gt;If you specify both the source type and source IDs, such as source type &#x3D; cluster and source identifier &#x3D; my-cluster-1, notifications will be sent for all the cluster events for my-cluster-1. If you specify a source type but do not specify a source identifier, you will receive notice of the events for the objects of that type in your Amazon Web Services account. If you do not specify either the SourceType nor the SourceIdentifier, you will be notified of events generated from all Amazon Redshift sources belonging to your Amazon Web Services account. You must specify a source type if you specify a source ID.&lt;/p&gt;
     * @param subscriptionName &lt;p&gt;The name of the event subscription to be created.&lt;/p&gt; &lt;p&gt;Constraints:&lt;/p&gt; &lt;ul&gt; &lt;li&gt; &lt;p&gt;Cannot be null, empty, or blank.&lt;/p&gt; &lt;/li&gt; &lt;li&gt; &lt;p&gt;Must contain from 1 to 255 alphanumeric characters or hyphens.&lt;/p&gt; &lt;/li&gt; &lt;li&gt; &lt;p&gt;First character must be a letter.&lt;/p&gt; &lt;/li&gt; &lt;li&gt; &lt;p&gt;Cannot end with a hyphen or contain two consecutive hyphens.&lt;/p&gt; &lt;/li&gt; &lt;/ul&gt; (required)
     * @param snsTopicArn The Amazon Resource Name (ARN) of the Amazon SNS topic used to transmit the event notifications. The ARN is created by Amazon SNS when you create a topic and subscribe to it. (required)
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param sourceType &lt;p&gt;The type of source that will be generating the events. For example, if you want to be notified of events generated by a cluster, you would set this parameter to cluster. If this value is not specified, events are returned for all Amazon Redshift objects in your Amazon Web Services account. You must specify a source type in order to specify source IDs.&lt;/p&gt; &lt;p&gt;Valid values: cluster, cluster-parameter-group, cluster-security-group, cluster-snapshot, and scheduled-action.&lt;/p&gt; (optional)
     * @param sourceIds &lt;p&gt;A list of one or more identifiers of Amazon Redshift source objects. All of the objects must be of the same type as was specified in the source type parameter. The event subscription will return only events generated by the specified objects. If not specified, then events are returned for all objects within the source type specified.&lt;/p&gt; &lt;p&gt;Example: my-cluster-1, my-cluster-2&lt;/p&gt; &lt;p&gt;Example: my-snapshot-20131010&lt;/p&gt; (optional)
     * @param eventCategories &lt;p&gt;Specifies the Amazon Redshift event categories to be published by the event notification subscription.&lt;/p&gt; &lt;p&gt;Values: configuration, management, monitoring, security, pending&lt;/p&gt; (optional)
     * @param severity &lt;p&gt;Specifies the Amazon Redshift event severity to be published by the event notification subscription.&lt;/p&gt; &lt;p&gt;Values: ERROR, INFO&lt;/p&gt; (optional)
     * @param enabled A boolean value; set to &lt;code&gt;true&lt;/code&gt; to activate the subscription, and set to &lt;code&gt;false&lt;/code&gt; to create the subscription but not activate it.  (optional)
     * @param tags A list of tag instances. (optional)
     * @return ApiResponse&lt;CreateEventSubscriptionResult&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> EventSubscriptionQuotaExceededFault </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> SubscriptionAlreadyExistFault </td><td>  -  </td></tr>
        <tr><td> 482 </td><td> SNSInvalidTopicFault </td><td>  -  </td></tr>
        <tr><td> 483 </td><td> SNSNoAuthorizationFault </td><td>  -  </td></tr>
        <tr><td> 484 </td><td> SNSTopicArnNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 485 </td><td> SubscriptionEventIdNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 486 </td><td> SubscriptionCategoryNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 487 </td><td> SubscriptionSeverityNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 488 </td><td> SourceNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 489 </td><td> TagLimitExceededFault </td><td>  -  </td></tr>
        <tr><td> 490 </td><td> InvalidTagFault </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<CreateEventSubscriptionResult> gETCreateEventSubscriptionWithHttpInfo(String subscriptionName, String snsTopicArn, String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, String sourceType, List<String> sourceIds, List<String> eventCategories, String severity, Boolean enabled, List<GETCreateClusterTagsParameterInner> tags) throws ApiException {
        okhttp3.Call localVarCall = gETCreateEventSubscriptionValidateBeforeCall(subscriptionName, snsTopicArn, action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, sourceType, sourceIds, eventCategories, severity, enabled, tags, null);
        Type localVarReturnType = new TypeToken<CreateEventSubscriptionResult>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     *  (asynchronously)
     * &lt;p&gt;Creates an Amazon Redshift event notification subscription. This action requires an ARN (Amazon Resource Name) of an Amazon SNS topic created by either the Amazon Redshift console, the Amazon SNS console, or the Amazon SNS API. To obtain an ARN with Amazon SNS, you must create a topic in Amazon SNS and subscribe to the topic. The ARN is displayed in the SNS console.&lt;/p&gt; &lt;p&gt;You can specify the source type, and lists of Amazon Redshift source IDs, event categories, and event severities. Notifications will be sent for all events you want that match those criteria. For example, you can specify source type &#x3D; cluster, source ID &#x3D; my-cluster-1 and mycluster2, event categories &#x3D; Availability, Backup, and severity &#x3D; ERROR. The subscription will only send notifications for those ERROR events in the Availability and Backup categories for the specified clusters.&lt;/p&gt; &lt;p&gt;If you specify both the source type and source IDs, such as source type &#x3D; cluster and source identifier &#x3D; my-cluster-1, notifications will be sent for all the cluster events for my-cluster-1. If you specify a source type but do not specify a source identifier, you will receive notice of the events for the objects of that type in your Amazon Web Services account. If you do not specify either the SourceType nor the SourceIdentifier, you will be notified of events generated from all Amazon Redshift sources belonging to your Amazon Web Services account. You must specify a source type if you specify a source ID.&lt;/p&gt;
     * @param subscriptionName &lt;p&gt;The name of the event subscription to be created.&lt;/p&gt; &lt;p&gt;Constraints:&lt;/p&gt; &lt;ul&gt; &lt;li&gt; &lt;p&gt;Cannot be null, empty, or blank.&lt;/p&gt; &lt;/li&gt; &lt;li&gt; &lt;p&gt;Must contain from 1 to 255 alphanumeric characters or hyphens.&lt;/p&gt; &lt;/li&gt; &lt;li&gt; &lt;p&gt;First character must be a letter.&lt;/p&gt; &lt;/li&gt; &lt;li&gt; &lt;p&gt;Cannot end with a hyphen or contain two consecutive hyphens.&lt;/p&gt; &lt;/li&gt; &lt;/ul&gt; (required)
     * @param snsTopicArn The Amazon Resource Name (ARN) of the Amazon SNS topic used to transmit the event notifications. The ARN is created by Amazon SNS when you create a topic and subscribe to it. (required)
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param sourceType &lt;p&gt;The type of source that will be generating the events. For example, if you want to be notified of events generated by a cluster, you would set this parameter to cluster. If this value is not specified, events are returned for all Amazon Redshift objects in your Amazon Web Services account. You must specify a source type in order to specify source IDs.&lt;/p&gt; &lt;p&gt;Valid values: cluster, cluster-parameter-group, cluster-security-group, cluster-snapshot, and scheduled-action.&lt;/p&gt; (optional)
     * @param sourceIds &lt;p&gt;A list of one or more identifiers of Amazon Redshift source objects. All of the objects must be of the same type as was specified in the source type parameter. The event subscription will return only events generated by the specified objects. If not specified, then events are returned for all objects within the source type specified.&lt;/p&gt; &lt;p&gt;Example: my-cluster-1, my-cluster-2&lt;/p&gt; &lt;p&gt;Example: my-snapshot-20131010&lt;/p&gt; (optional)
     * @param eventCategories &lt;p&gt;Specifies the Amazon Redshift event categories to be published by the event notification subscription.&lt;/p&gt; &lt;p&gt;Values: configuration, management, monitoring, security, pending&lt;/p&gt; (optional)
     * @param severity &lt;p&gt;Specifies the Amazon Redshift event severity to be published by the event notification subscription.&lt;/p&gt; &lt;p&gt;Values: ERROR, INFO&lt;/p&gt; (optional)
     * @param enabled A boolean value; set to &lt;code&gt;true&lt;/code&gt; to activate the subscription, and set to &lt;code&gt;false&lt;/code&gt; to create the subscription but not activate it.  (optional)
     * @param tags A list of tag instances. (optional)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> EventSubscriptionQuotaExceededFault </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> SubscriptionAlreadyExistFault </td><td>  -  </td></tr>
        <tr><td> 482 </td><td> SNSInvalidTopicFault </td><td>  -  </td></tr>
        <tr><td> 483 </td><td> SNSNoAuthorizationFault </td><td>  -  </td></tr>
        <tr><td> 484 </td><td> SNSTopicArnNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 485 </td><td> SubscriptionEventIdNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 486 </td><td> SubscriptionCategoryNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 487 </td><td> SubscriptionSeverityNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 488 </td><td> SourceNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 489 </td><td> TagLimitExceededFault </td><td>  -  </td></tr>
        <tr><td> 490 </td><td> InvalidTagFault </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call gETCreateEventSubscriptionAsync(String subscriptionName, String snsTopicArn, String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, String sourceType, List<String> sourceIds, List<String> eventCategories, String severity, Boolean enabled, List<GETCreateClusterTagsParameterInner> tags, final ApiCallback<CreateEventSubscriptionResult> _callback) throws ApiException {

        okhttp3.Call localVarCall = gETCreateEventSubscriptionValidateBeforeCall(subscriptionName, snsTopicArn, action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, sourceType, sourceIds, eventCategories, severity, enabled, tags, _callback);
        Type localVarReturnType = new TypeToken<CreateEventSubscriptionResult>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for gETCreateHsmClientCertificate
     * @param hsmClientCertificateIdentifier The identifier to be assigned to the new HSM client certificate that the cluster will use to connect to the HSM to use the database encryption keys. (required)
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param tags A list of tag instances. (optional)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> HsmClientCertificateAlreadyExistsFault </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> HsmClientCertificateQuotaExceededFault </td><td>  -  </td></tr>
        <tr><td> 482 </td><td> TagLimitExceededFault </td><td>  -  </td></tr>
        <tr><td> 483 </td><td> InvalidTagFault </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call gETCreateHsmClientCertificateCall(String hsmClientCertificateIdentifier, String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, List<GETCreateClusterTagsParameterInner> tags, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/#Action=CreateHsmClientCertificate";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (hsmClientCertificateIdentifier != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("HsmClientCertificateIdentifier", hsmClientCertificateIdentifier));
        }

        if (tags != null) {
            localVarCollectionQueryParams.addAll(localVarApiClient.parameterToPairs("multi", "Tags", tags));
        }

        if (action != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("Action", action));
        }

        if (version != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("Version", version));
        }

        if (xAmzContentSha256 != null) {
            localVarHeaderParams.put("X-Amz-Content-Sha256", localVarApiClient.parameterToString(xAmzContentSha256));
        }

        if (xAmzDate != null) {
            localVarHeaderParams.put("X-Amz-Date", localVarApiClient.parameterToString(xAmzDate));
        }

        if (xAmzAlgorithm != null) {
            localVarHeaderParams.put("X-Amz-Algorithm", localVarApiClient.parameterToString(xAmzAlgorithm));
        }

        if (xAmzCredential != null) {
            localVarHeaderParams.put("X-Amz-Credential", localVarApiClient.parameterToString(xAmzCredential));
        }

        if (xAmzSecurityToken != null) {
            localVarHeaderParams.put("X-Amz-Security-Token", localVarApiClient.parameterToString(xAmzSecurityToken));
        }

        if (xAmzSignature != null) {
            localVarHeaderParams.put("X-Amz-Signature", localVarApiClient.parameterToString(xAmzSignature));
        }

        if (xAmzSignedHeaders != null) {
            localVarHeaderParams.put("X-Amz-SignedHeaders", localVarApiClient.parameterToString(xAmzSignedHeaders));
        }

        final String[] localVarAccepts = {
            "text/xml"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "hmac" };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call gETCreateHsmClientCertificateValidateBeforeCall(String hsmClientCertificateIdentifier, String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, List<GETCreateClusterTagsParameterInner> tags, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'hsmClientCertificateIdentifier' is set
        if (hsmClientCertificateIdentifier == null) {
            throw new ApiException("Missing the required parameter 'hsmClientCertificateIdentifier' when calling gETCreateHsmClientCertificate(Async)");
        }

        // verify the required parameter 'action' is set
        if (action == null) {
            throw new ApiException("Missing the required parameter 'action' when calling gETCreateHsmClientCertificate(Async)");
        }

        // verify the required parameter 'version' is set
        if (version == null) {
            throw new ApiException("Missing the required parameter 'version' when calling gETCreateHsmClientCertificate(Async)");
        }

        return gETCreateHsmClientCertificateCall(hsmClientCertificateIdentifier, action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, tags, _callback);

    }

    /**
     * 
     * &lt;p&gt;Creates an HSM client certificate that an Amazon Redshift cluster will use to connect to the client&#39;s HSM in order to store and retrieve the keys used to encrypt the cluster databases.&lt;/p&gt; &lt;p&gt;The command returns a public key, which you must store in the HSM. In addition to creating the HSM certificate, you must create an Amazon Redshift HSM configuration that provides a cluster the information needed to store and use encryption keys in the HSM. For more information, go to &lt;a href&#x3D;\&quot;https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-db-encryption.html#working-with-HSM\&quot;&gt;Hardware Security Modules&lt;/a&gt; in the &lt;i&gt;Amazon Redshift Cluster Management Guide&lt;/i&gt;.&lt;/p&gt;
     * @param hsmClientCertificateIdentifier The identifier to be assigned to the new HSM client certificate that the cluster will use to connect to the HSM to use the database encryption keys. (required)
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param tags A list of tag instances. (optional)
     * @return CreateHsmClientCertificateResult
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> HsmClientCertificateAlreadyExistsFault </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> HsmClientCertificateQuotaExceededFault </td><td>  -  </td></tr>
        <tr><td> 482 </td><td> TagLimitExceededFault </td><td>  -  </td></tr>
        <tr><td> 483 </td><td> InvalidTagFault </td><td>  -  </td></tr>
     </table>
     */
    public CreateHsmClientCertificateResult gETCreateHsmClientCertificate(String hsmClientCertificateIdentifier, String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, List<GETCreateClusterTagsParameterInner> tags) throws ApiException {
        ApiResponse<CreateHsmClientCertificateResult> localVarResp = gETCreateHsmClientCertificateWithHttpInfo(hsmClientCertificateIdentifier, action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, tags);
        return localVarResp.getData();
    }

    /**
     * 
     * &lt;p&gt;Creates an HSM client certificate that an Amazon Redshift cluster will use to connect to the client&#39;s HSM in order to store and retrieve the keys used to encrypt the cluster databases.&lt;/p&gt; &lt;p&gt;The command returns a public key, which you must store in the HSM. In addition to creating the HSM certificate, you must create an Amazon Redshift HSM configuration that provides a cluster the information needed to store and use encryption keys in the HSM. For more information, go to &lt;a href&#x3D;\&quot;https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-db-encryption.html#working-with-HSM\&quot;&gt;Hardware Security Modules&lt;/a&gt; in the &lt;i&gt;Amazon Redshift Cluster Management Guide&lt;/i&gt;.&lt;/p&gt;
     * @param hsmClientCertificateIdentifier The identifier to be assigned to the new HSM client certificate that the cluster will use to connect to the HSM to use the database encryption keys. (required)
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param tags A list of tag instances. (optional)
     * @return ApiResponse&lt;CreateHsmClientCertificateResult&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> HsmClientCertificateAlreadyExistsFault </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> HsmClientCertificateQuotaExceededFault </td><td>  -  </td></tr>
        <tr><td> 482 </td><td> TagLimitExceededFault </td><td>  -  </td></tr>
        <tr><td> 483 </td><td> InvalidTagFault </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<CreateHsmClientCertificateResult> gETCreateHsmClientCertificateWithHttpInfo(String hsmClientCertificateIdentifier, String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, List<GETCreateClusterTagsParameterInner> tags) throws ApiException {
        okhttp3.Call localVarCall = gETCreateHsmClientCertificateValidateBeforeCall(hsmClientCertificateIdentifier, action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, tags, null);
        Type localVarReturnType = new TypeToken<CreateHsmClientCertificateResult>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     *  (asynchronously)
     * &lt;p&gt;Creates an HSM client certificate that an Amazon Redshift cluster will use to connect to the client&#39;s HSM in order to store and retrieve the keys used to encrypt the cluster databases.&lt;/p&gt; &lt;p&gt;The command returns a public key, which you must store in the HSM. In addition to creating the HSM certificate, you must create an Amazon Redshift HSM configuration that provides a cluster the information needed to store and use encryption keys in the HSM. For more information, go to &lt;a href&#x3D;\&quot;https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-db-encryption.html#working-with-HSM\&quot;&gt;Hardware Security Modules&lt;/a&gt; in the &lt;i&gt;Amazon Redshift Cluster Management Guide&lt;/i&gt;.&lt;/p&gt;
     * @param hsmClientCertificateIdentifier The identifier to be assigned to the new HSM client certificate that the cluster will use to connect to the HSM to use the database encryption keys. (required)
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param tags A list of tag instances. (optional)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> HsmClientCertificateAlreadyExistsFault </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> HsmClientCertificateQuotaExceededFault </td><td>  -  </td></tr>
        <tr><td> 482 </td><td> TagLimitExceededFault </td><td>  -  </td></tr>
        <tr><td> 483 </td><td> InvalidTagFault </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call gETCreateHsmClientCertificateAsync(String hsmClientCertificateIdentifier, String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, List<GETCreateClusterTagsParameterInner> tags, final ApiCallback<CreateHsmClientCertificateResult> _callback) throws ApiException {

        okhttp3.Call localVarCall = gETCreateHsmClientCertificateValidateBeforeCall(hsmClientCertificateIdentifier, action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, tags, _callback);
        Type localVarReturnType = new TypeToken<CreateHsmClientCertificateResult>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for gETCreateHsmConfiguration
     * @param hsmConfigurationIdentifier The identifier to be assigned to the new Amazon Redshift HSM configuration. (required)
     * @param description A text description of the HSM configuration to be created. (required)
     * @param hsmIpAddress The IP address that the Amazon Redshift cluster must use to access the HSM. (required)
     * @param hsmPartitionName The name of the partition in the HSM where the Amazon Redshift clusters will store their database encryption keys. (required)
     * @param hsmPartitionPassword The password required to access the HSM partition. (required)
     * @param hsmServerPublicCertificate The HSMs public certificate file. When using Cloud HSM, the file name is server.pem. (required)
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param tags A list of tag instances. (optional)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> HsmConfigurationAlreadyExistsFault </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> HsmConfigurationQuotaExceededFault </td><td>  -  </td></tr>
        <tr><td> 482 </td><td> TagLimitExceededFault </td><td>  -  </td></tr>
        <tr><td> 483 </td><td> InvalidTagFault </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call gETCreateHsmConfigurationCall(String hsmConfigurationIdentifier, String description, String hsmIpAddress, String hsmPartitionName, String hsmPartitionPassword, String hsmServerPublicCertificate, String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, List<GETCreateClusterTagsParameterInner> tags, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/#Action=CreateHsmConfiguration";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (hsmConfigurationIdentifier != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("HsmConfigurationIdentifier", hsmConfigurationIdentifier));
        }

        if (description != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("Description", description));
        }

        if (hsmIpAddress != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("HsmIpAddress", hsmIpAddress));
        }

        if (hsmPartitionName != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("HsmPartitionName", hsmPartitionName));
        }

        if (hsmPartitionPassword != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("HsmPartitionPassword", hsmPartitionPassword));
        }

        if (hsmServerPublicCertificate != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("HsmServerPublicCertificate", hsmServerPublicCertificate));
        }

        if (tags != null) {
            localVarCollectionQueryParams.addAll(localVarApiClient.parameterToPairs("multi", "Tags", tags));
        }

        if (action != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("Action", action));
        }

        if (version != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("Version", version));
        }

        if (xAmzContentSha256 != null) {
            localVarHeaderParams.put("X-Amz-Content-Sha256", localVarApiClient.parameterToString(xAmzContentSha256));
        }

        if (xAmzDate != null) {
            localVarHeaderParams.put("X-Amz-Date", localVarApiClient.parameterToString(xAmzDate));
        }

        if (xAmzAlgorithm != null) {
            localVarHeaderParams.put("X-Amz-Algorithm", localVarApiClient.parameterToString(xAmzAlgorithm));
        }

        if (xAmzCredential != null) {
            localVarHeaderParams.put("X-Amz-Credential", localVarApiClient.parameterToString(xAmzCredential));
        }

        if (xAmzSecurityToken != null) {
            localVarHeaderParams.put("X-Amz-Security-Token", localVarApiClient.parameterToString(xAmzSecurityToken));
        }

        if (xAmzSignature != null) {
            localVarHeaderParams.put("X-Amz-Signature", localVarApiClient.parameterToString(xAmzSignature));
        }

        if (xAmzSignedHeaders != null) {
            localVarHeaderParams.put("X-Amz-SignedHeaders", localVarApiClient.parameterToString(xAmzSignedHeaders));
        }

        final String[] localVarAccepts = {
            "text/xml"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "hmac" };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call gETCreateHsmConfigurationValidateBeforeCall(String hsmConfigurationIdentifier, String description, String hsmIpAddress, String hsmPartitionName, String hsmPartitionPassword, String hsmServerPublicCertificate, String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, List<GETCreateClusterTagsParameterInner> tags, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'hsmConfigurationIdentifier' is set
        if (hsmConfigurationIdentifier == null) {
            throw new ApiException("Missing the required parameter 'hsmConfigurationIdentifier' when calling gETCreateHsmConfiguration(Async)");
        }

        // verify the required parameter 'description' is set
        if (description == null) {
            throw new ApiException("Missing the required parameter 'description' when calling gETCreateHsmConfiguration(Async)");
        }

        // verify the required parameter 'hsmIpAddress' is set
        if (hsmIpAddress == null) {
            throw new ApiException("Missing the required parameter 'hsmIpAddress' when calling gETCreateHsmConfiguration(Async)");
        }

        // verify the required parameter 'hsmPartitionName' is set
        if (hsmPartitionName == null) {
            throw new ApiException("Missing the required parameter 'hsmPartitionName' when calling gETCreateHsmConfiguration(Async)");
        }

        // verify the required parameter 'hsmPartitionPassword' is set
        if (hsmPartitionPassword == null) {
            throw new ApiException("Missing the required parameter 'hsmPartitionPassword' when calling gETCreateHsmConfiguration(Async)");
        }

        // verify the required parameter 'hsmServerPublicCertificate' is set
        if (hsmServerPublicCertificate == null) {
            throw new ApiException("Missing the required parameter 'hsmServerPublicCertificate' when calling gETCreateHsmConfiguration(Async)");
        }

        // verify the required parameter 'action' is set
        if (action == null) {
            throw new ApiException("Missing the required parameter 'action' when calling gETCreateHsmConfiguration(Async)");
        }

        // verify the required parameter 'version' is set
        if (version == null) {
            throw new ApiException("Missing the required parameter 'version' when calling gETCreateHsmConfiguration(Async)");
        }

        return gETCreateHsmConfigurationCall(hsmConfigurationIdentifier, description, hsmIpAddress, hsmPartitionName, hsmPartitionPassword, hsmServerPublicCertificate, action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, tags, _callback);

    }

    /**
     * 
     * &lt;p&gt;Creates an HSM configuration that contains the information required by an Amazon Redshift cluster to store and use database encryption keys in a Hardware Security Module (HSM). After creating the HSM configuration, you can specify it as a parameter when creating a cluster. The cluster will then store its encryption keys in the HSM.&lt;/p&gt; &lt;p&gt;In addition to creating an HSM configuration, you must also create an HSM client certificate. For more information, go to &lt;a href&#x3D;\&quot;https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-HSM.html\&quot;&gt;Hardware Security Modules&lt;/a&gt; in the Amazon Redshift Cluster Management Guide.&lt;/p&gt;
     * @param hsmConfigurationIdentifier The identifier to be assigned to the new Amazon Redshift HSM configuration. (required)
     * @param description A text description of the HSM configuration to be created. (required)
     * @param hsmIpAddress The IP address that the Amazon Redshift cluster must use to access the HSM. (required)
     * @param hsmPartitionName The name of the partition in the HSM where the Amazon Redshift clusters will store their database encryption keys. (required)
     * @param hsmPartitionPassword The password required to access the HSM partition. (required)
     * @param hsmServerPublicCertificate The HSMs public certificate file. When using Cloud HSM, the file name is server.pem. (required)
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param tags A list of tag instances. (optional)
     * @return CreateHsmConfigurationResult
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> HsmConfigurationAlreadyExistsFault </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> HsmConfigurationQuotaExceededFault </td><td>  -  </td></tr>
        <tr><td> 482 </td><td> TagLimitExceededFault </td><td>  -  </td></tr>
        <tr><td> 483 </td><td> InvalidTagFault </td><td>  -  </td></tr>
     </table>
     */
    public CreateHsmConfigurationResult gETCreateHsmConfiguration(String hsmConfigurationIdentifier, String description, String hsmIpAddress, String hsmPartitionName, String hsmPartitionPassword, String hsmServerPublicCertificate, String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, List<GETCreateClusterTagsParameterInner> tags) throws ApiException {
        ApiResponse<CreateHsmConfigurationResult> localVarResp = gETCreateHsmConfigurationWithHttpInfo(hsmConfigurationIdentifier, description, hsmIpAddress, hsmPartitionName, hsmPartitionPassword, hsmServerPublicCertificate, action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, tags);
        return localVarResp.getData();
    }

    /**
     * 
     * &lt;p&gt;Creates an HSM configuration that contains the information required by an Amazon Redshift cluster to store and use database encryption keys in a Hardware Security Module (HSM). After creating the HSM configuration, you can specify it as a parameter when creating a cluster. The cluster will then store its encryption keys in the HSM.&lt;/p&gt; &lt;p&gt;In addition to creating an HSM configuration, you must also create an HSM client certificate. For more information, go to &lt;a href&#x3D;\&quot;https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-HSM.html\&quot;&gt;Hardware Security Modules&lt;/a&gt; in the Amazon Redshift Cluster Management Guide.&lt;/p&gt;
     * @param hsmConfigurationIdentifier The identifier to be assigned to the new Amazon Redshift HSM configuration. (required)
     * @param description A text description of the HSM configuration to be created. (required)
     * @param hsmIpAddress The IP address that the Amazon Redshift cluster must use to access the HSM. (required)
     * @param hsmPartitionName The name of the partition in the HSM where the Amazon Redshift clusters will store their database encryption keys. (required)
     * @param hsmPartitionPassword The password required to access the HSM partition. (required)
     * @param hsmServerPublicCertificate The HSMs public certificate file. When using Cloud HSM, the file name is server.pem. (required)
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param tags A list of tag instances. (optional)
     * @return ApiResponse&lt;CreateHsmConfigurationResult&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> HsmConfigurationAlreadyExistsFault </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> HsmConfigurationQuotaExceededFault </td><td>  -  </td></tr>
        <tr><td> 482 </td><td> TagLimitExceededFault </td><td>  -  </td></tr>
        <tr><td> 483 </td><td> InvalidTagFault </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<CreateHsmConfigurationResult> gETCreateHsmConfigurationWithHttpInfo(String hsmConfigurationIdentifier, String description, String hsmIpAddress, String hsmPartitionName, String hsmPartitionPassword, String hsmServerPublicCertificate, String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, List<GETCreateClusterTagsParameterInner> tags) throws ApiException {
        okhttp3.Call localVarCall = gETCreateHsmConfigurationValidateBeforeCall(hsmConfigurationIdentifier, description, hsmIpAddress, hsmPartitionName, hsmPartitionPassword, hsmServerPublicCertificate, action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, tags, null);
        Type localVarReturnType = new TypeToken<CreateHsmConfigurationResult>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     *  (asynchronously)
     * &lt;p&gt;Creates an HSM configuration that contains the information required by an Amazon Redshift cluster to store and use database encryption keys in a Hardware Security Module (HSM). After creating the HSM configuration, you can specify it as a parameter when creating a cluster. The cluster will then store its encryption keys in the HSM.&lt;/p&gt; &lt;p&gt;In addition to creating an HSM configuration, you must also create an HSM client certificate. For more information, go to &lt;a href&#x3D;\&quot;https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-HSM.html\&quot;&gt;Hardware Security Modules&lt;/a&gt; in the Amazon Redshift Cluster Management Guide.&lt;/p&gt;
     * @param hsmConfigurationIdentifier The identifier to be assigned to the new Amazon Redshift HSM configuration. (required)
     * @param description A text description of the HSM configuration to be created. (required)
     * @param hsmIpAddress The IP address that the Amazon Redshift cluster must use to access the HSM. (required)
     * @param hsmPartitionName The name of the partition in the HSM where the Amazon Redshift clusters will store their database encryption keys. (required)
     * @param hsmPartitionPassword The password required to access the HSM partition. (required)
     * @param hsmServerPublicCertificate The HSMs public certificate file. When using Cloud HSM, the file name is server.pem. (required)
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param tags A list of tag instances. (optional)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> HsmConfigurationAlreadyExistsFault </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> HsmConfigurationQuotaExceededFault </td><td>  -  </td></tr>
        <tr><td> 482 </td><td> TagLimitExceededFault </td><td>  -  </td></tr>
        <tr><td> 483 </td><td> InvalidTagFault </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call gETCreateHsmConfigurationAsync(String hsmConfigurationIdentifier, String description, String hsmIpAddress, String hsmPartitionName, String hsmPartitionPassword, String hsmServerPublicCertificate, String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, List<GETCreateClusterTagsParameterInner> tags, final ApiCallback<CreateHsmConfigurationResult> _callback) throws ApiException {

        okhttp3.Call localVarCall = gETCreateHsmConfigurationValidateBeforeCall(hsmConfigurationIdentifier, description, hsmIpAddress, hsmPartitionName, hsmPartitionPassword, hsmServerPublicCertificate, action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, tags, _callback);
        Type localVarReturnType = new TypeToken<CreateHsmConfigurationResult>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for gETCreateScheduledAction
     * @param scheduledActionName The name of the scheduled action. The name must be unique within an account. For more information about this parameter, see &lt;a&gt;ScheduledAction&lt;/a&gt;.  (required)
     * @param targetAction A JSON format string of the Amazon Redshift API operation with input parameters. For more information about this parameter, see &lt;a&gt;ScheduledAction&lt;/a&gt;.  (required)
     * @param schedule The schedule in &lt;code&gt;at( )&lt;/code&gt; or &lt;code&gt;cron( )&lt;/code&gt; format. For more information about this parameter, see &lt;a&gt;ScheduledAction&lt;/a&gt;. (required)
     * @param iamRole The IAM role to assume to run the target action. For more information about this parameter, see &lt;a&gt;ScheduledAction&lt;/a&gt;.  (required)
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param scheduledActionDescription The description of the scheduled action.  (optional)
     * @param startTime The start time in UTC of the scheduled action. Before this time, the scheduled action does not trigger. For more information about this parameter, see &lt;a&gt;ScheduledAction&lt;/a&gt;. (optional)
     * @param endTime The end time in UTC of the scheduled action. After this time, the scheduled action does not trigger. For more information about this parameter, see &lt;a&gt;ScheduledAction&lt;/a&gt;.  (optional)
     * @param enable If true, the schedule is enabled. If false, the scheduled action does not trigger. For more information about &lt;code&gt;state&lt;/code&gt; of the scheduled action, see &lt;a&gt;ScheduledAction&lt;/a&gt;.  (optional)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> ScheduledActionAlreadyExistsFault </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> ScheduledActionQuotaExceededFault </td><td>  -  </td></tr>
        <tr><td> 482 </td><td> ScheduledActionTypeUnsupportedFault </td><td>  -  </td></tr>
        <tr><td> 483 </td><td> InvalidScheduleFault </td><td>  -  </td></tr>
        <tr><td> 484 </td><td> InvalidScheduledActionFault </td><td>  -  </td></tr>
        <tr><td> 485 </td><td> UnauthorizedOperation </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call gETCreateScheduledActionCall(String scheduledActionName, GETCreateScheduledActionTargetActionParameter targetAction, String schedule, String iamRole, String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, String scheduledActionDescription, OffsetDateTime startTime, OffsetDateTime endTime, Boolean enable, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/#Action=CreateScheduledAction";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (scheduledActionName != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("ScheduledActionName", scheduledActionName));
        }

        if (targetAction != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("TargetAction", targetAction));
        }

        if (schedule != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("Schedule", schedule));
        }

        if (iamRole != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("IamRole", iamRole));
        }

        if (scheduledActionDescription != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("ScheduledActionDescription", scheduledActionDescription));
        }

        if (startTime != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("StartTime", startTime));
        }

        if (endTime != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("EndTime", endTime));
        }

        if (enable != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("Enable", enable));
        }

        if (action != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("Action", action));
        }

        if (version != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("Version", version));
        }

        if (xAmzContentSha256 != null) {
            localVarHeaderParams.put("X-Amz-Content-Sha256", localVarApiClient.parameterToString(xAmzContentSha256));
        }

        if (xAmzDate != null) {
            localVarHeaderParams.put("X-Amz-Date", localVarApiClient.parameterToString(xAmzDate));
        }

        if (xAmzAlgorithm != null) {
            localVarHeaderParams.put("X-Amz-Algorithm", localVarApiClient.parameterToString(xAmzAlgorithm));
        }

        if (xAmzCredential != null) {
            localVarHeaderParams.put("X-Amz-Credential", localVarApiClient.parameterToString(xAmzCredential));
        }

        if (xAmzSecurityToken != null) {
            localVarHeaderParams.put("X-Amz-Security-Token", localVarApiClient.parameterToString(xAmzSecurityToken));
        }

        if (xAmzSignature != null) {
            localVarHeaderParams.put("X-Amz-Signature", localVarApiClient.parameterToString(xAmzSignature));
        }

        if (xAmzSignedHeaders != null) {
            localVarHeaderParams.put("X-Amz-SignedHeaders", localVarApiClient.parameterToString(xAmzSignedHeaders));
        }

        final String[] localVarAccepts = {
            "text/xml"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "hmac" };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call gETCreateScheduledActionValidateBeforeCall(String scheduledActionName, GETCreateScheduledActionTargetActionParameter targetAction, String schedule, String iamRole, String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, String scheduledActionDescription, OffsetDateTime startTime, OffsetDateTime endTime, Boolean enable, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'scheduledActionName' is set
        if (scheduledActionName == null) {
            throw new ApiException("Missing the required parameter 'scheduledActionName' when calling gETCreateScheduledAction(Async)");
        }

        // verify the required parameter 'targetAction' is set
        if (targetAction == null) {
            throw new ApiException("Missing the required parameter 'targetAction' when calling gETCreateScheduledAction(Async)");
        }

        // verify the required parameter 'schedule' is set
        if (schedule == null) {
            throw new ApiException("Missing the required parameter 'schedule' when calling gETCreateScheduledAction(Async)");
        }

        // verify the required parameter 'iamRole' is set
        if (iamRole == null) {
            throw new ApiException("Missing the required parameter 'iamRole' when calling gETCreateScheduledAction(Async)");
        }

        // verify the required parameter 'action' is set
        if (action == null) {
            throw new ApiException("Missing the required parameter 'action' when calling gETCreateScheduledAction(Async)");
        }

        // verify the required parameter 'version' is set
        if (version == null) {
            throw new ApiException("Missing the required parameter 'version' when calling gETCreateScheduledAction(Async)");
        }

        return gETCreateScheduledActionCall(scheduledActionName, targetAction, schedule, iamRole, action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, scheduledActionDescription, startTime, endTime, enable, _callback);

    }

    /**
     * 
     * Creates a scheduled action. A scheduled action contains a schedule and an Amazon Redshift API action. For example, you can create a schedule of when to run the &lt;code&gt;ResizeCluster&lt;/code&gt; API operation. 
     * @param scheduledActionName The name of the scheduled action. The name must be unique within an account. For more information about this parameter, see &lt;a&gt;ScheduledAction&lt;/a&gt;.  (required)
     * @param targetAction A JSON format string of the Amazon Redshift API operation with input parameters. For more information about this parameter, see &lt;a&gt;ScheduledAction&lt;/a&gt;.  (required)
     * @param schedule The schedule in &lt;code&gt;at( )&lt;/code&gt; or &lt;code&gt;cron( )&lt;/code&gt; format. For more information about this parameter, see &lt;a&gt;ScheduledAction&lt;/a&gt;. (required)
     * @param iamRole The IAM role to assume to run the target action. For more information about this parameter, see &lt;a&gt;ScheduledAction&lt;/a&gt;.  (required)
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param scheduledActionDescription The description of the scheduled action.  (optional)
     * @param startTime The start time in UTC of the scheduled action. Before this time, the scheduled action does not trigger. For more information about this parameter, see &lt;a&gt;ScheduledAction&lt;/a&gt;. (optional)
     * @param endTime The end time in UTC of the scheduled action. After this time, the scheduled action does not trigger. For more information about this parameter, see &lt;a&gt;ScheduledAction&lt;/a&gt;.  (optional)
     * @param enable If true, the schedule is enabled. If false, the scheduled action does not trigger. For more information about &lt;code&gt;state&lt;/code&gt; of the scheduled action, see &lt;a&gt;ScheduledAction&lt;/a&gt;.  (optional)
     * @return ScheduledAction
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> ScheduledActionAlreadyExistsFault </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> ScheduledActionQuotaExceededFault </td><td>  -  </td></tr>
        <tr><td> 482 </td><td> ScheduledActionTypeUnsupportedFault </td><td>  -  </td></tr>
        <tr><td> 483 </td><td> InvalidScheduleFault </td><td>  -  </td></tr>
        <tr><td> 484 </td><td> InvalidScheduledActionFault </td><td>  -  </td></tr>
        <tr><td> 485 </td><td> UnauthorizedOperation </td><td>  -  </td></tr>
     </table>
     */
    public ScheduledAction gETCreateScheduledAction(String scheduledActionName, GETCreateScheduledActionTargetActionParameter targetAction, String schedule, String iamRole, String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, String scheduledActionDescription, OffsetDateTime startTime, OffsetDateTime endTime, Boolean enable) throws ApiException {
        ApiResponse<ScheduledAction> localVarResp = gETCreateScheduledActionWithHttpInfo(scheduledActionName, targetAction, schedule, iamRole, action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, scheduledActionDescription, startTime, endTime, enable);
        return localVarResp.getData();
    }

    /**
     * 
     * Creates a scheduled action. A scheduled action contains a schedule and an Amazon Redshift API action. For example, you can create a schedule of when to run the &lt;code&gt;ResizeCluster&lt;/code&gt; API operation. 
     * @param scheduledActionName The name of the scheduled action. The name must be unique within an account. For more information about this parameter, see &lt;a&gt;ScheduledAction&lt;/a&gt;.  (required)
     * @param targetAction A JSON format string of the Amazon Redshift API operation with input parameters. For more information about this parameter, see &lt;a&gt;ScheduledAction&lt;/a&gt;.  (required)
     * @param schedule The schedule in &lt;code&gt;at( )&lt;/code&gt; or &lt;code&gt;cron( )&lt;/code&gt; format. For more information about this parameter, see &lt;a&gt;ScheduledAction&lt;/a&gt;. (required)
     * @param iamRole The IAM role to assume to run the target action. For more information about this parameter, see &lt;a&gt;ScheduledAction&lt;/a&gt;.  (required)
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param scheduledActionDescription The description of the scheduled action.  (optional)
     * @param startTime The start time in UTC of the scheduled action. Before this time, the scheduled action does not trigger. For more information about this parameter, see &lt;a&gt;ScheduledAction&lt;/a&gt;. (optional)
     * @param endTime The end time in UTC of the scheduled action. After this time, the scheduled action does not trigger. For more information about this parameter, see &lt;a&gt;ScheduledAction&lt;/a&gt;.  (optional)
     * @param enable If true, the schedule is enabled. If false, the scheduled action does not trigger. For more information about &lt;code&gt;state&lt;/code&gt; of the scheduled action, see &lt;a&gt;ScheduledAction&lt;/a&gt;.  (optional)
     * @return ApiResponse&lt;ScheduledAction&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> ScheduledActionAlreadyExistsFault </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> ScheduledActionQuotaExceededFault </td><td>  -  </td></tr>
        <tr><td> 482 </td><td> ScheduledActionTypeUnsupportedFault </td><td>  -  </td></tr>
        <tr><td> 483 </td><td> InvalidScheduleFault </td><td>  -  </td></tr>
        <tr><td> 484 </td><td> InvalidScheduledActionFault </td><td>  -  </td></tr>
        <tr><td> 485 </td><td> UnauthorizedOperation </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<ScheduledAction> gETCreateScheduledActionWithHttpInfo(String scheduledActionName, GETCreateScheduledActionTargetActionParameter targetAction, String schedule, String iamRole, String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, String scheduledActionDescription, OffsetDateTime startTime, OffsetDateTime endTime, Boolean enable) throws ApiException {
        okhttp3.Call localVarCall = gETCreateScheduledActionValidateBeforeCall(scheduledActionName, targetAction, schedule, iamRole, action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, scheduledActionDescription, startTime, endTime, enable, null);
        Type localVarReturnType = new TypeToken<ScheduledAction>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     *  (asynchronously)
     * Creates a scheduled action. A scheduled action contains a schedule and an Amazon Redshift API action. For example, you can create a schedule of when to run the &lt;code&gt;ResizeCluster&lt;/code&gt; API operation. 
     * @param scheduledActionName The name of the scheduled action. The name must be unique within an account. For more information about this parameter, see &lt;a&gt;ScheduledAction&lt;/a&gt;.  (required)
     * @param targetAction A JSON format string of the Amazon Redshift API operation with input parameters. For more information about this parameter, see &lt;a&gt;ScheduledAction&lt;/a&gt;.  (required)
     * @param schedule The schedule in &lt;code&gt;at( )&lt;/code&gt; or &lt;code&gt;cron( )&lt;/code&gt; format. For more information about this parameter, see &lt;a&gt;ScheduledAction&lt;/a&gt;. (required)
     * @param iamRole The IAM role to assume to run the target action. For more information about this parameter, see &lt;a&gt;ScheduledAction&lt;/a&gt;.  (required)
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param scheduledActionDescription The description of the scheduled action.  (optional)
     * @param startTime The start time in UTC of the scheduled action. Before this time, the scheduled action does not trigger. For more information about this parameter, see &lt;a&gt;ScheduledAction&lt;/a&gt;. (optional)
     * @param endTime The end time in UTC of the scheduled action. After this time, the scheduled action does not trigger. For more information about this parameter, see &lt;a&gt;ScheduledAction&lt;/a&gt;.  (optional)
     * @param enable If true, the schedule is enabled. If false, the scheduled action does not trigger. For more information about &lt;code&gt;state&lt;/code&gt; of the scheduled action, see &lt;a&gt;ScheduledAction&lt;/a&gt;.  (optional)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> ScheduledActionAlreadyExistsFault </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> ScheduledActionQuotaExceededFault </td><td>  -  </td></tr>
        <tr><td> 482 </td><td> ScheduledActionTypeUnsupportedFault </td><td>  -  </td></tr>
        <tr><td> 483 </td><td> InvalidScheduleFault </td><td>  -  </td></tr>
        <tr><td> 484 </td><td> InvalidScheduledActionFault </td><td>  -  </td></tr>
        <tr><td> 485 </td><td> UnauthorizedOperation </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call gETCreateScheduledActionAsync(String scheduledActionName, GETCreateScheduledActionTargetActionParameter targetAction, String schedule, String iamRole, String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, String scheduledActionDescription, OffsetDateTime startTime, OffsetDateTime endTime, Boolean enable, final ApiCallback<ScheduledAction> _callback) throws ApiException {

        okhttp3.Call localVarCall = gETCreateScheduledActionValidateBeforeCall(scheduledActionName, targetAction, schedule, iamRole, action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, scheduledActionDescription, startTime, endTime, enable, _callback);
        Type localVarReturnType = new TypeToken<ScheduledAction>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for gETCreateSnapshotCopyGrant
     * @param snapshotCopyGrantName &lt;p&gt;The name of the snapshot copy grant. This name must be unique in the region for the Amazon Web Services account.&lt;/p&gt; &lt;p&gt;Constraints:&lt;/p&gt; &lt;ul&gt; &lt;li&gt; &lt;p&gt;Must contain from 1 to 63 alphanumeric characters or hyphens.&lt;/p&gt; &lt;/li&gt; &lt;li&gt; &lt;p&gt;Alphabetic characters must be lowercase.&lt;/p&gt; &lt;/li&gt; &lt;li&gt; &lt;p&gt;First character must be a letter.&lt;/p&gt; &lt;/li&gt; &lt;li&gt; &lt;p&gt;Cannot end with a hyphen or contain two consecutive hyphens.&lt;/p&gt; &lt;/li&gt; &lt;li&gt; &lt;p&gt;Must be unique for all clusters within an Amazon Web Services account.&lt;/p&gt; &lt;/li&gt; &lt;/ul&gt; (required)
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param kmsKeyId The unique identifier of the encrypted symmetric key to which to grant Amazon Redshift permission. If no key is specified, the default key is used. (optional)
     * @param tags A list of tag instances. (optional)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> SnapshotCopyGrantAlreadyExistsFault </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> SnapshotCopyGrantQuotaExceededFault </td><td>  -  </td></tr>
        <tr><td> 482 </td><td> LimitExceededFault </td><td>  -  </td></tr>
        <tr><td> 483 </td><td> TagLimitExceededFault </td><td>  -  </td></tr>
        <tr><td> 484 </td><td> InvalidTagFault </td><td>  -  </td></tr>
        <tr><td> 485 </td><td> DependentServiceRequestThrottlingFault </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call gETCreateSnapshotCopyGrantCall(String snapshotCopyGrantName, String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, String kmsKeyId, List<GETCreateClusterTagsParameterInner> tags, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/#Action=CreateSnapshotCopyGrant";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (snapshotCopyGrantName != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("SnapshotCopyGrantName", snapshotCopyGrantName));
        }

        if (kmsKeyId != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("KmsKeyId", kmsKeyId));
        }

        if (tags != null) {
            localVarCollectionQueryParams.addAll(localVarApiClient.parameterToPairs("multi", "Tags", tags));
        }

        if (action != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("Action", action));
        }

        if (version != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("Version", version));
        }

        if (xAmzContentSha256 != null) {
            localVarHeaderParams.put("X-Amz-Content-Sha256", localVarApiClient.parameterToString(xAmzContentSha256));
        }

        if (xAmzDate != null) {
            localVarHeaderParams.put("X-Amz-Date", localVarApiClient.parameterToString(xAmzDate));
        }

        if (xAmzAlgorithm != null) {
            localVarHeaderParams.put("X-Amz-Algorithm", localVarApiClient.parameterToString(xAmzAlgorithm));
        }

        if (xAmzCredential != null) {
            localVarHeaderParams.put("X-Amz-Credential", localVarApiClient.parameterToString(xAmzCredential));
        }

        if (xAmzSecurityToken != null) {
            localVarHeaderParams.put("X-Amz-Security-Token", localVarApiClient.parameterToString(xAmzSecurityToken));
        }

        if (xAmzSignature != null) {
            localVarHeaderParams.put("X-Amz-Signature", localVarApiClient.parameterToString(xAmzSignature));
        }

        if (xAmzSignedHeaders != null) {
            localVarHeaderParams.put("X-Amz-SignedHeaders", localVarApiClient.parameterToString(xAmzSignedHeaders));
        }

        final String[] localVarAccepts = {
            "text/xml"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "hmac" };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call gETCreateSnapshotCopyGrantValidateBeforeCall(String snapshotCopyGrantName, String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, String kmsKeyId, List<GETCreateClusterTagsParameterInner> tags, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'snapshotCopyGrantName' is set
        if (snapshotCopyGrantName == null) {
            throw new ApiException("Missing the required parameter 'snapshotCopyGrantName' when calling gETCreateSnapshotCopyGrant(Async)");
        }

        // verify the required parameter 'action' is set
        if (action == null) {
            throw new ApiException("Missing the required parameter 'action' when calling gETCreateSnapshotCopyGrant(Async)");
        }

        // verify the required parameter 'version' is set
        if (version == null) {
            throw new ApiException("Missing the required parameter 'version' when calling gETCreateSnapshotCopyGrant(Async)");
        }

        return gETCreateSnapshotCopyGrantCall(snapshotCopyGrantName, action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, kmsKeyId, tags, _callback);

    }

    /**
     * 
     * &lt;p&gt;Creates a snapshot copy grant that permits Amazon Redshift to use an encrypted symmetric key from Key Management Service (KMS) to encrypt copied snapshots in a destination region.&lt;/p&gt; &lt;p&gt; For more information about managing snapshot copy grants, go to &lt;a href&#x3D;\&quot;https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-db-encryption.html\&quot;&gt;Amazon Redshift Database Encryption&lt;/a&gt; in the &lt;i&gt;Amazon Redshift Cluster Management Guide&lt;/i&gt;. &lt;/p&gt;
     * @param snapshotCopyGrantName &lt;p&gt;The name of the snapshot copy grant. This name must be unique in the region for the Amazon Web Services account.&lt;/p&gt; &lt;p&gt;Constraints:&lt;/p&gt; &lt;ul&gt; &lt;li&gt; &lt;p&gt;Must contain from 1 to 63 alphanumeric characters or hyphens.&lt;/p&gt; &lt;/li&gt; &lt;li&gt; &lt;p&gt;Alphabetic characters must be lowercase.&lt;/p&gt; &lt;/li&gt; &lt;li&gt; &lt;p&gt;First character must be a letter.&lt;/p&gt; &lt;/li&gt; &lt;li&gt; &lt;p&gt;Cannot end with a hyphen or contain two consecutive hyphens.&lt;/p&gt; &lt;/li&gt; &lt;li&gt; &lt;p&gt;Must be unique for all clusters within an Amazon Web Services account.&lt;/p&gt; &lt;/li&gt; &lt;/ul&gt; (required)
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param kmsKeyId The unique identifier of the encrypted symmetric key to which to grant Amazon Redshift permission. If no key is specified, the default key is used. (optional)
     * @param tags A list of tag instances. (optional)
     * @return CreateSnapshotCopyGrantResult
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> SnapshotCopyGrantAlreadyExistsFault </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> SnapshotCopyGrantQuotaExceededFault </td><td>  -  </td></tr>
        <tr><td> 482 </td><td> LimitExceededFault </td><td>  -  </td></tr>
        <tr><td> 483 </td><td> TagLimitExceededFault </td><td>  -  </td></tr>
        <tr><td> 484 </td><td> InvalidTagFault </td><td>  -  </td></tr>
        <tr><td> 485 </td><td> DependentServiceRequestThrottlingFault </td><td>  -  </td></tr>
     </table>
     */
    public CreateSnapshotCopyGrantResult gETCreateSnapshotCopyGrant(String snapshotCopyGrantName, String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, String kmsKeyId, List<GETCreateClusterTagsParameterInner> tags) throws ApiException {
        ApiResponse<CreateSnapshotCopyGrantResult> localVarResp = gETCreateSnapshotCopyGrantWithHttpInfo(snapshotCopyGrantName, action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, kmsKeyId, tags);
        return localVarResp.getData();
    }

    /**
     * 
     * &lt;p&gt;Creates a snapshot copy grant that permits Amazon Redshift to use an encrypted symmetric key from Key Management Service (KMS) to encrypt copied snapshots in a destination region.&lt;/p&gt; &lt;p&gt; For more information about managing snapshot copy grants, go to &lt;a href&#x3D;\&quot;https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-db-encryption.html\&quot;&gt;Amazon Redshift Database Encryption&lt;/a&gt; in the &lt;i&gt;Amazon Redshift Cluster Management Guide&lt;/i&gt;. &lt;/p&gt;
     * @param snapshotCopyGrantName &lt;p&gt;The name of the snapshot copy grant. This name must be unique in the region for the Amazon Web Services account.&lt;/p&gt; &lt;p&gt;Constraints:&lt;/p&gt; &lt;ul&gt; &lt;li&gt; &lt;p&gt;Must contain from 1 to 63 alphanumeric characters or hyphens.&lt;/p&gt; &lt;/li&gt; &lt;li&gt; &lt;p&gt;Alphabetic characters must be lowercase.&lt;/p&gt; &lt;/li&gt; &lt;li&gt; &lt;p&gt;First character must be a letter.&lt;/p&gt; &lt;/li&gt; &lt;li&gt; &lt;p&gt;Cannot end with a hyphen or contain two consecutive hyphens.&lt;/p&gt; &lt;/li&gt; &lt;li&gt; &lt;p&gt;Must be unique for all clusters within an Amazon Web Services account.&lt;/p&gt; &lt;/li&gt; &lt;/ul&gt; (required)
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param kmsKeyId The unique identifier of the encrypted symmetric key to which to grant Amazon Redshift permission. If no key is specified, the default key is used. (optional)
     * @param tags A list of tag instances. (optional)
     * @return ApiResponse&lt;CreateSnapshotCopyGrantResult&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> SnapshotCopyGrantAlreadyExistsFault </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> SnapshotCopyGrantQuotaExceededFault </td><td>  -  </td></tr>
        <tr><td> 482 </td><td> LimitExceededFault </td><td>  -  </td></tr>
        <tr><td> 483 </td><td> TagLimitExceededFault </td><td>  -  </td></tr>
        <tr><td> 484 </td><td> InvalidTagFault </td><td>  -  </td></tr>
        <tr><td> 485 </td><td> DependentServiceRequestThrottlingFault </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<CreateSnapshotCopyGrantResult> gETCreateSnapshotCopyGrantWithHttpInfo(String snapshotCopyGrantName, String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, String kmsKeyId, List<GETCreateClusterTagsParameterInner> tags) throws ApiException {
        okhttp3.Call localVarCall = gETCreateSnapshotCopyGrantValidateBeforeCall(snapshotCopyGrantName, action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, kmsKeyId, tags, null);
        Type localVarReturnType = new TypeToken<CreateSnapshotCopyGrantResult>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     *  (asynchronously)
     * &lt;p&gt;Creates a snapshot copy grant that permits Amazon Redshift to use an encrypted symmetric key from Key Management Service (KMS) to encrypt copied snapshots in a destination region.&lt;/p&gt; &lt;p&gt; For more information about managing snapshot copy grants, go to &lt;a href&#x3D;\&quot;https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-db-encryption.html\&quot;&gt;Amazon Redshift Database Encryption&lt;/a&gt; in the &lt;i&gt;Amazon Redshift Cluster Management Guide&lt;/i&gt;. &lt;/p&gt;
     * @param snapshotCopyGrantName &lt;p&gt;The name of the snapshot copy grant. This name must be unique in the region for the Amazon Web Services account.&lt;/p&gt; &lt;p&gt;Constraints:&lt;/p&gt; &lt;ul&gt; &lt;li&gt; &lt;p&gt;Must contain from 1 to 63 alphanumeric characters or hyphens.&lt;/p&gt; &lt;/li&gt; &lt;li&gt; &lt;p&gt;Alphabetic characters must be lowercase.&lt;/p&gt; &lt;/li&gt; &lt;li&gt; &lt;p&gt;First character must be a letter.&lt;/p&gt; &lt;/li&gt; &lt;li&gt; &lt;p&gt;Cannot end with a hyphen or contain two consecutive hyphens.&lt;/p&gt; &lt;/li&gt; &lt;li&gt; &lt;p&gt;Must be unique for all clusters within an Amazon Web Services account.&lt;/p&gt; &lt;/li&gt; &lt;/ul&gt; (required)
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param kmsKeyId The unique identifier of the encrypted symmetric key to which to grant Amazon Redshift permission. If no key is specified, the default key is used. (optional)
     * @param tags A list of tag instances. (optional)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> SnapshotCopyGrantAlreadyExistsFault </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> SnapshotCopyGrantQuotaExceededFault </td><td>  -  </td></tr>
        <tr><td> 482 </td><td> LimitExceededFault </td><td>  -  </td></tr>
        <tr><td> 483 </td><td> TagLimitExceededFault </td><td>  -  </td></tr>
        <tr><td> 484 </td><td> InvalidTagFault </td><td>  -  </td></tr>
        <tr><td> 485 </td><td> DependentServiceRequestThrottlingFault </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call gETCreateSnapshotCopyGrantAsync(String snapshotCopyGrantName, String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, String kmsKeyId, List<GETCreateClusterTagsParameterInner> tags, final ApiCallback<CreateSnapshotCopyGrantResult> _callback) throws ApiException {

        okhttp3.Call localVarCall = gETCreateSnapshotCopyGrantValidateBeforeCall(snapshotCopyGrantName, action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, kmsKeyId, tags, _callback);
        Type localVarReturnType = new TypeToken<CreateSnapshotCopyGrantResult>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for gETCreateSnapshotSchedule
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param scheduleDefinitions The definition of the snapshot schedule. The definition is made up of schedule expressions, for example \&quot;cron(30 12 *)\&quot; or \&quot;rate(12 hours)\&quot;.  (optional)
     * @param scheduleIdentifier A unique identifier for a snapshot schedule. Only alphanumeric characters are allowed for the identifier. (optional)
     * @param scheduleDescription The description of the snapshot schedule. (optional)
     * @param tags An optional set of tags you can use to search for the schedule. (optional)
     * @param dryRun &lt;p/&gt; (optional)
     * @param nextInvocations &lt;p/&gt; (optional)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> SnapshotScheduleAlreadyExistsFault </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> InvalidScheduleFault </td><td>  -  </td></tr>
        <tr><td> 482 </td><td> SnapshotScheduleQuotaExceededFault </td><td>  -  </td></tr>
        <tr><td> 483 </td><td> TagLimitExceededFault </td><td>  -  </td></tr>
        <tr><td> 484 </td><td> ScheduleDefinitionTypeUnsupportedFault </td><td>  -  </td></tr>
        <tr><td> 485 </td><td> InvalidTagFault </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call gETCreateSnapshotScheduleCall(String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, List<String> scheduleDefinitions, String scheduleIdentifier, String scheduleDescription, List<GETCreateClusterTagsParameterInner> tags, Boolean dryRun, Integer nextInvocations, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/#Action=CreateSnapshotSchedule";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (scheduleDefinitions != null) {
            localVarCollectionQueryParams.addAll(localVarApiClient.parameterToPairs("multi", "ScheduleDefinitions", scheduleDefinitions));
        }

        if (scheduleIdentifier != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("ScheduleIdentifier", scheduleIdentifier));
        }

        if (scheduleDescription != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("ScheduleDescription", scheduleDescription));
        }

        if (tags != null) {
            localVarCollectionQueryParams.addAll(localVarApiClient.parameterToPairs("multi", "Tags", tags));
        }

        if (dryRun != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("DryRun", dryRun));
        }

        if (nextInvocations != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("NextInvocations", nextInvocations));
        }

        if (action != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("Action", action));
        }

        if (version != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("Version", version));
        }

        if (xAmzContentSha256 != null) {
            localVarHeaderParams.put("X-Amz-Content-Sha256", localVarApiClient.parameterToString(xAmzContentSha256));
        }

        if (xAmzDate != null) {
            localVarHeaderParams.put("X-Amz-Date", localVarApiClient.parameterToString(xAmzDate));
        }

        if (xAmzAlgorithm != null) {
            localVarHeaderParams.put("X-Amz-Algorithm", localVarApiClient.parameterToString(xAmzAlgorithm));
        }

        if (xAmzCredential != null) {
            localVarHeaderParams.put("X-Amz-Credential", localVarApiClient.parameterToString(xAmzCredential));
        }

        if (xAmzSecurityToken != null) {
            localVarHeaderParams.put("X-Amz-Security-Token", localVarApiClient.parameterToString(xAmzSecurityToken));
        }

        if (xAmzSignature != null) {
            localVarHeaderParams.put("X-Amz-Signature", localVarApiClient.parameterToString(xAmzSignature));
        }

        if (xAmzSignedHeaders != null) {
            localVarHeaderParams.put("X-Amz-SignedHeaders", localVarApiClient.parameterToString(xAmzSignedHeaders));
        }

        final String[] localVarAccepts = {
            "text/xml"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "hmac" };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call gETCreateSnapshotScheduleValidateBeforeCall(String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, List<String> scheduleDefinitions, String scheduleIdentifier, String scheduleDescription, List<GETCreateClusterTagsParameterInner> tags, Boolean dryRun, Integer nextInvocations, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'action' is set
        if (action == null) {
            throw new ApiException("Missing the required parameter 'action' when calling gETCreateSnapshotSchedule(Async)");
        }

        // verify the required parameter 'version' is set
        if (version == null) {
            throw new ApiException("Missing the required parameter 'version' when calling gETCreateSnapshotSchedule(Async)");
        }

        return gETCreateSnapshotScheduleCall(action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, scheduleDefinitions, scheduleIdentifier, scheduleDescription, tags, dryRun, nextInvocations, _callback);

    }

    /**
     * 
     * Create a snapshot schedule that can be associated to a cluster and which overrides the default system backup schedule. 
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param scheduleDefinitions The definition of the snapshot schedule. The definition is made up of schedule expressions, for example \&quot;cron(30 12 *)\&quot; or \&quot;rate(12 hours)\&quot;.  (optional)
     * @param scheduleIdentifier A unique identifier for a snapshot schedule. Only alphanumeric characters are allowed for the identifier. (optional)
     * @param scheduleDescription The description of the snapshot schedule. (optional)
     * @param tags An optional set of tags you can use to search for the schedule. (optional)
     * @param dryRun &lt;p/&gt; (optional)
     * @param nextInvocations &lt;p/&gt; (optional)
     * @return SnapshotSchedule
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> SnapshotScheduleAlreadyExistsFault </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> InvalidScheduleFault </td><td>  -  </td></tr>
        <tr><td> 482 </td><td> SnapshotScheduleQuotaExceededFault </td><td>  -  </td></tr>
        <tr><td> 483 </td><td> TagLimitExceededFault </td><td>  -  </td></tr>
        <tr><td> 484 </td><td> ScheduleDefinitionTypeUnsupportedFault </td><td>  -  </td></tr>
        <tr><td> 485 </td><td> InvalidTagFault </td><td>  -  </td></tr>
     </table>
     */
    public SnapshotSchedule gETCreateSnapshotSchedule(String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, List<String> scheduleDefinitions, String scheduleIdentifier, String scheduleDescription, List<GETCreateClusterTagsParameterInner> tags, Boolean dryRun, Integer nextInvocations) throws ApiException {
        ApiResponse<SnapshotSchedule> localVarResp = gETCreateSnapshotScheduleWithHttpInfo(action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, scheduleDefinitions, scheduleIdentifier, scheduleDescription, tags, dryRun, nextInvocations);
        return localVarResp.getData();
    }

    /**
     * 
     * Create a snapshot schedule that can be associated to a cluster and which overrides the default system backup schedule. 
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param scheduleDefinitions The definition of the snapshot schedule. The definition is made up of schedule expressions, for example \&quot;cron(30 12 *)\&quot; or \&quot;rate(12 hours)\&quot;.  (optional)
     * @param scheduleIdentifier A unique identifier for a snapshot schedule. Only alphanumeric characters are allowed for the identifier. (optional)
     * @param scheduleDescription The description of the snapshot schedule. (optional)
     * @param tags An optional set of tags you can use to search for the schedule. (optional)
     * @param dryRun &lt;p/&gt; (optional)
     * @param nextInvocations &lt;p/&gt; (optional)
     * @return ApiResponse&lt;SnapshotSchedule&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> SnapshotScheduleAlreadyExistsFault </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> InvalidScheduleFault </td><td>  -  </td></tr>
        <tr><td> 482 </td><td> SnapshotScheduleQuotaExceededFault </td><td>  -  </td></tr>
        <tr><td> 483 </td><td> TagLimitExceededFault </td><td>  -  </td></tr>
        <tr><td> 484 </td><td> ScheduleDefinitionTypeUnsupportedFault </td><td>  -  </td></tr>
        <tr><td> 485 </td><td> InvalidTagFault </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<SnapshotSchedule> gETCreateSnapshotScheduleWithHttpInfo(String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, List<String> scheduleDefinitions, String scheduleIdentifier, String scheduleDescription, List<GETCreateClusterTagsParameterInner> tags, Boolean dryRun, Integer nextInvocations) throws ApiException {
        okhttp3.Call localVarCall = gETCreateSnapshotScheduleValidateBeforeCall(action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, scheduleDefinitions, scheduleIdentifier, scheduleDescription, tags, dryRun, nextInvocations, null);
        Type localVarReturnType = new TypeToken<SnapshotSchedule>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     *  (asynchronously)
     * Create a snapshot schedule that can be associated to a cluster and which overrides the default system backup schedule. 
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param scheduleDefinitions The definition of the snapshot schedule. The definition is made up of schedule expressions, for example \&quot;cron(30 12 *)\&quot; or \&quot;rate(12 hours)\&quot;.  (optional)
     * @param scheduleIdentifier A unique identifier for a snapshot schedule. Only alphanumeric characters are allowed for the identifier. (optional)
     * @param scheduleDescription The description of the snapshot schedule. (optional)
     * @param tags An optional set of tags you can use to search for the schedule. (optional)
     * @param dryRun &lt;p/&gt; (optional)
     * @param nextInvocations &lt;p/&gt; (optional)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> SnapshotScheduleAlreadyExistsFault </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> InvalidScheduleFault </td><td>  -  </td></tr>
        <tr><td> 482 </td><td> SnapshotScheduleQuotaExceededFault </td><td>  -  </td></tr>
        <tr><td> 483 </td><td> TagLimitExceededFault </td><td>  -  </td></tr>
        <tr><td> 484 </td><td> ScheduleDefinitionTypeUnsupportedFault </td><td>  -  </td></tr>
        <tr><td> 485 </td><td> InvalidTagFault </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call gETCreateSnapshotScheduleAsync(String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, List<String> scheduleDefinitions, String scheduleIdentifier, String scheduleDescription, List<GETCreateClusterTagsParameterInner> tags, Boolean dryRun, Integer nextInvocations, final ApiCallback<SnapshotSchedule> _callback) throws ApiException {

        okhttp3.Call localVarCall = gETCreateSnapshotScheduleValidateBeforeCall(action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, scheduleDefinitions, scheduleIdentifier, scheduleDescription, tags, dryRun, nextInvocations, _callback);
        Type localVarReturnType = new TypeToken<SnapshotSchedule>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for gETCreateTags
     * @param resourceName The Amazon Resource Name (ARN) to which you want to add the tag or tags. For example, &lt;code&gt;arn:aws:redshift:us-east-2:123456789:cluster:t1&lt;/code&gt;.  (required)
     * @param tags One or more name/value pairs to add as tags to the specified resource. Each tag name is passed in with the parameter &lt;code&gt;Key&lt;/code&gt; and the corresponding value is passed in with the parameter &lt;code&gt;Value&lt;/code&gt;. The &lt;code&gt;Key&lt;/code&gt; and &lt;code&gt;Value&lt;/code&gt; parameters are separated by a comma (,). Separate multiple tags with a space. For example, &lt;code&gt;--tags \&quot;Key\&quot;&#x3D;\&quot;owner\&quot;,\&quot;Value\&quot;&#x3D;\&quot;admin\&quot; \&quot;Key\&quot;&#x3D;\&quot;environment\&quot;,\&quot;Value\&quot;&#x3D;\&quot;test\&quot; \&quot;Key\&quot;&#x3D;\&quot;version\&quot;,\&quot;Value\&quot;&#x3D;\&quot;1.0\&quot;&lt;/code&gt;.  (required)
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> TagLimitExceededFault </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> ResourceNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 482 </td><td> InvalidTagFault </td><td>  -  </td></tr>
        <tr><td> 483 </td><td> InvalidClusterStateFault </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call gETCreateTagsCall(String resourceName, List<GETCreateClusterTagsParameterInner> tags, String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/#Action=CreateTags";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (resourceName != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("ResourceName", resourceName));
        }

        if (tags != null) {
            localVarCollectionQueryParams.addAll(localVarApiClient.parameterToPairs("multi", "Tags", tags));
        }

        if (action != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("Action", action));
        }

        if (version != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("Version", version));
        }

        if (xAmzContentSha256 != null) {
            localVarHeaderParams.put("X-Amz-Content-Sha256", localVarApiClient.parameterToString(xAmzContentSha256));
        }

        if (xAmzDate != null) {
            localVarHeaderParams.put("X-Amz-Date", localVarApiClient.parameterToString(xAmzDate));
        }

        if (xAmzAlgorithm != null) {
            localVarHeaderParams.put("X-Amz-Algorithm", localVarApiClient.parameterToString(xAmzAlgorithm));
        }

        if (xAmzCredential != null) {
            localVarHeaderParams.put("X-Amz-Credential", localVarApiClient.parameterToString(xAmzCredential));
        }

        if (xAmzSecurityToken != null) {
            localVarHeaderParams.put("X-Amz-Security-Token", localVarApiClient.parameterToString(xAmzSecurityToken));
        }

        if (xAmzSignature != null) {
            localVarHeaderParams.put("X-Amz-Signature", localVarApiClient.parameterToString(xAmzSignature));
        }

        if (xAmzSignedHeaders != null) {
            localVarHeaderParams.put("X-Amz-SignedHeaders", localVarApiClient.parameterToString(xAmzSignedHeaders));
        }

        final String[] localVarAccepts = {
            "text/xml"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "hmac" };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call gETCreateTagsValidateBeforeCall(String resourceName, List<GETCreateClusterTagsParameterInner> tags, String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'resourceName' is set
        if (resourceName == null) {
            throw new ApiException("Missing the required parameter 'resourceName' when calling gETCreateTags(Async)");
        }

        // verify the required parameter 'tags' is set
        if (tags == null) {
            throw new ApiException("Missing the required parameter 'tags' when calling gETCreateTags(Async)");
        }

        // verify the required parameter 'action' is set
        if (action == null) {
            throw new ApiException("Missing the required parameter 'action' when calling gETCreateTags(Async)");
        }

        // verify the required parameter 'version' is set
        if (version == null) {
            throw new ApiException("Missing the required parameter 'version' when calling gETCreateTags(Async)");
        }

        return gETCreateTagsCall(resourceName, tags, action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, _callback);

    }

    /**
     * 
     * &lt;p&gt;Adds tags to a cluster.&lt;/p&gt; &lt;p&gt;A resource can have up to 50 tags. If you try to create more than 50 tags for a resource, you will receive an error and the attempt will fail.&lt;/p&gt; &lt;p&gt;If you specify a key that already exists for the resource, the value for that key will be updated with the new value.&lt;/p&gt;
     * @param resourceName The Amazon Resource Name (ARN) to which you want to add the tag or tags. For example, &lt;code&gt;arn:aws:redshift:us-east-2:123456789:cluster:t1&lt;/code&gt;.  (required)
     * @param tags One or more name/value pairs to add as tags to the specified resource. Each tag name is passed in with the parameter &lt;code&gt;Key&lt;/code&gt; and the corresponding value is passed in with the parameter &lt;code&gt;Value&lt;/code&gt;. The &lt;code&gt;Key&lt;/code&gt; and &lt;code&gt;Value&lt;/code&gt; parameters are separated by a comma (,). Separate multiple tags with a space. For example, &lt;code&gt;--tags \&quot;Key\&quot;&#x3D;\&quot;owner\&quot;,\&quot;Value\&quot;&#x3D;\&quot;admin\&quot; \&quot;Key\&quot;&#x3D;\&quot;environment\&quot;,\&quot;Value\&quot;&#x3D;\&quot;test\&quot; \&quot;Key\&quot;&#x3D;\&quot;version\&quot;,\&quot;Value\&quot;&#x3D;\&quot;1.0\&quot;&lt;/code&gt;.  (required)
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> TagLimitExceededFault </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> ResourceNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 482 </td><td> InvalidTagFault </td><td>  -  </td></tr>
        <tr><td> 483 </td><td> InvalidClusterStateFault </td><td>  -  </td></tr>
     </table>
     */
    public void gETCreateTags(String resourceName, List<GETCreateClusterTagsParameterInner> tags, String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders) throws ApiException {
        gETCreateTagsWithHttpInfo(resourceName, tags, action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders);
    }

    /**
     * 
     * &lt;p&gt;Adds tags to a cluster.&lt;/p&gt; &lt;p&gt;A resource can have up to 50 tags. If you try to create more than 50 tags for a resource, you will receive an error and the attempt will fail.&lt;/p&gt; &lt;p&gt;If you specify a key that already exists for the resource, the value for that key will be updated with the new value.&lt;/p&gt;
     * @param resourceName The Amazon Resource Name (ARN) to which you want to add the tag or tags. For example, &lt;code&gt;arn:aws:redshift:us-east-2:123456789:cluster:t1&lt;/code&gt;.  (required)
     * @param tags One or more name/value pairs to add as tags to the specified resource. Each tag name is passed in with the parameter &lt;code&gt;Key&lt;/code&gt; and the corresponding value is passed in with the parameter &lt;code&gt;Value&lt;/code&gt;. The &lt;code&gt;Key&lt;/code&gt; and &lt;code&gt;Value&lt;/code&gt; parameters are separated by a comma (,). Separate multiple tags with a space. For example, &lt;code&gt;--tags \&quot;Key\&quot;&#x3D;\&quot;owner\&quot;,\&quot;Value\&quot;&#x3D;\&quot;admin\&quot; \&quot;Key\&quot;&#x3D;\&quot;environment\&quot;,\&quot;Value\&quot;&#x3D;\&quot;test\&quot; \&quot;Key\&quot;&#x3D;\&quot;version\&quot;,\&quot;Value\&quot;&#x3D;\&quot;1.0\&quot;&lt;/code&gt;.  (required)
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @return ApiResponse&lt;Void&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> TagLimitExceededFault </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> ResourceNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 482 </td><td> InvalidTagFault </td><td>  -  </td></tr>
        <tr><td> 483 </td><td> InvalidClusterStateFault </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<Void> gETCreateTagsWithHttpInfo(String resourceName, List<GETCreateClusterTagsParameterInner> tags, String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders) throws ApiException {
        okhttp3.Call localVarCall = gETCreateTagsValidateBeforeCall(resourceName, tags, action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, null);
        return localVarApiClient.execute(localVarCall);
    }

    /**
     *  (asynchronously)
     * &lt;p&gt;Adds tags to a cluster.&lt;/p&gt; &lt;p&gt;A resource can have up to 50 tags. If you try to create more than 50 tags for a resource, you will receive an error and the attempt will fail.&lt;/p&gt; &lt;p&gt;If you specify a key that already exists for the resource, the value for that key will be updated with the new value.&lt;/p&gt;
     * @param resourceName The Amazon Resource Name (ARN) to which you want to add the tag or tags. For example, &lt;code&gt;arn:aws:redshift:us-east-2:123456789:cluster:t1&lt;/code&gt;.  (required)
     * @param tags One or more name/value pairs to add as tags to the specified resource. Each tag name is passed in with the parameter &lt;code&gt;Key&lt;/code&gt; and the corresponding value is passed in with the parameter &lt;code&gt;Value&lt;/code&gt;. The &lt;code&gt;Key&lt;/code&gt; and &lt;code&gt;Value&lt;/code&gt; parameters are separated by a comma (,). Separate multiple tags with a space. For example, &lt;code&gt;--tags \&quot;Key\&quot;&#x3D;\&quot;owner\&quot;,\&quot;Value\&quot;&#x3D;\&quot;admin\&quot; \&quot;Key\&quot;&#x3D;\&quot;environment\&quot;,\&quot;Value\&quot;&#x3D;\&quot;test\&quot; \&quot;Key\&quot;&#x3D;\&quot;version\&quot;,\&quot;Value\&quot;&#x3D;\&quot;1.0\&quot;&lt;/code&gt;.  (required)
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> TagLimitExceededFault </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> ResourceNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 482 </td><td> InvalidTagFault </td><td>  -  </td></tr>
        <tr><td> 483 </td><td> InvalidClusterStateFault </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call gETCreateTagsAsync(String resourceName, List<GETCreateClusterTagsParameterInner> tags, String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, final ApiCallback<Void> _callback) throws ApiException {

        okhttp3.Call localVarCall = gETCreateTagsValidateBeforeCall(resourceName, tags, action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, _callback);
        localVarApiClient.executeAsync(localVarCall, _callback);
        return localVarCall;
    }
    /**
     * Build call for gETCreateUsageLimit
     * @param clusterIdentifier The identifier of the cluster that you want to limit usage. (required)
     * @param featureType The Amazon Redshift feature that you want to limit. (required)
     * @param limitType The type of limit. Depending on the feature type, this can be based on a time duration or data size. If &lt;code&gt;FeatureType&lt;/code&gt; is &lt;code&gt;spectrum&lt;/code&gt;, then &lt;code&gt;LimitType&lt;/code&gt; must be &lt;code&gt;data-scanned&lt;/code&gt;. If &lt;code&gt;FeatureType&lt;/code&gt; is &lt;code&gt;concurrency-scaling&lt;/code&gt;, then &lt;code&gt;LimitType&lt;/code&gt; must be &lt;code&gt;time&lt;/code&gt;. If &lt;code&gt;FeatureType&lt;/code&gt; is &lt;code&gt;cross-region-datasharing&lt;/code&gt;, then &lt;code&gt;LimitType&lt;/code&gt; must be &lt;code&gt;data-scanned&lt;/code&gt;.  (required)
     * @param amount The limit amount. If time-based, this amount is in minutes. If data-based, this amount is in terabytes (TB). The value must be a positive number.  (required)
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param period The time period that the amount applies to. A &lt;code&gt;weekly&lt;/code&gt; period begins on Sunday. The default is &lt;code&gt;monthly&lt;/code&gt;.  (optional)
     * @param breachAction The action that Amazon Redshift takes when the limit is reached. The default is log. For more information about this parameter, see &lt;a&gt;UsageLimit&lt;/a&gt;. (optional)
     * @param tags A list of tag instances. (optional)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> ClusterNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> InvalidClusterStateFault </td><td>  -  </td></tr>
        <tr><td> 482 </td><td> LimitExceededFault </td><td>  -  </td></tr>
        <tr><td> 483 </td><td> UsageLimitAlreadyExistsFault </td><td>  -  </td></tr>
        <tr><td> 484 </td><td> InvalidUsageLimitFault </td><td>  -  </td></tr>
        <tr><td> 485 </td><td> TagLimitExceededFault </td><td>  -  </td></tr>
        <tr><td> 486 </td><td> UnsupportedOperationFault </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call gETCreateUsageLimitCall(String clusterIdentifier, String featureType, String limitType, Integer amount, String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, String period, String breachAction, List<GETCreateClusterTagsParameterInner> tags, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/#Action=CreateUsageLimit";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (clusterIdentifier != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("ClusterIdentifier", clusterIdentifier));
        }

        if (featureType != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("FeatureType", featureType));
        }

        if (limitType != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("LimitType", limitType));
        }

        if (amount != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("Amount", amount));
        }

        if (period != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("Period", period));
        }

        if (breachAction != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("BreachAction", breachAction));
        }

        if (tags != null) {
            localVarCollectionQueryParams.addAll(localVarApiClient.parameterToPairs("multi", "Tags", tags));
        }

        if (action != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("Action", action));
        }

        if (version != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("Version", version));
        }

        if (xAmzContentSha256 != null) {
            localVarHeaderParams.put("X-Amz-Content-Sha256", localVarApiClient.parameterToString(xAmzContentSha256));
        }

        if (xAmzDate != null) {
            localVarHeaderParams.put("X-Amz-Date", localVarApiClient.parameterToString(xAmzDate));
        }

        if (xAmzAlgorithm != null) {
            localVarHeaderParams.put("X-Amz-Algorithm", localVarApiClient.parameterToString(xAmzAlgorithm));
        }

        if (xAmzCredential != null) {
            localVarHeaderParams.put("X-Amz-Credential", localVarApiClient.parameterToString(xAmzCredential));
        }

        if (xAmzSecurityToken != null) {
            localVarHeaderParams.put("X-Amz-Security-Token", localVarApiClient.parameterToString(xAmzSecurityToken));
        }

        if (xAmzSignature != null) {
            localVarHeaderParams.put("X-Amz-Signature", localVarApiClient.parameterToString(xAmzSignature));
        }

        if (xAmzSignedHeaders != null) {
            localVarHeaderParams.put("X-Amz-SignedHeaders", localVarApiClient.parameterToString(xAmzSignedHeaders));
        }

        final String[] localVarAccepts = {
            "text/xml"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "hmac" };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call gETCreateUsageLimitValidateBeforeCall(String clusterIdentifier, String featureType, String limitType, Integer amount, String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, String period, String breachAction, List<GETCreateClusterTagsParameterInner> tags, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'clusterIdentifier' is set
        if (clusterIdentifier == null) {
            throw new ApiException("Missing the required parameter 'clusterIdentifier' when calling gETCreateUsageLimit(Async)");
        }

        // verify the required parameter 'featureType' is set
        if (featureType == null) {
            throw new ApiException("Missing the required parameter 'featureType' when calling gETCreateUsageLimit(Async)");
        }

        // verify the required parameter 'limitType' is set
        if (limitType == null) {
            throw new ApiException("Missing the required parameter 'limitType' when calling gETCreateUsageLimit(Async)");
        }

        // verify the required parameter 'amount' is set
        if (amount == null) {
            throw new ApiException("Missing the required parameter 'amount' when calling gETCreateUsageLimit(Async)");
        }

        // verify the required parameter 'action' is set
        if (action == null) {
            throw new ApiException("Missing the required parameter 'action' when calling gETCreateUsageLimit(Async)");
        }

        // verify the required parameter 'version' is set
        if (version == null) {
            throw new ApiException("Missing the required parameter 'version' when calling gETCreateUsageLimit(Async)");
        }

        return gETCreateUsageLimitCall(clusterIdentifier, featureType, limitType, amount, action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, period, breachAction, tags, _callback);

    }

    /**
     * 
     * Creates a usage limit for a specified Amazon Redshift feature on a cluster. The usage limit is identified by the returned usage limit identifier.
     * @param clusterIdentifier The identifier of the cluster that you want to limit usage. (required)
     * @param featureType The Amazon Redshift feature that you want to limit. (required)
     * @param limitType The type of limit. Depending on the feature type, this can be based on a time duration or data size. If &lt;code&gt;FeatureType&lt;/code&gt; is &lt;code&gt;spectrum&lt;/code&gt;, then &lt;code&gt;LimitType&lt;/code&gt; must be &lt;code&gt;data-scanned&lt;/code&gt;. If &lt;code&gt;FeatureType&lt;/code&gt; is &lt;code&gt;concurrency-scaling&lt;/code&gt;, then &lt;code&gt;LimitType&lt;/code&gt; must be &lt;code&gt;time&lt;/code&gt;. If &lt;code&gt;FeatureType&lt;/code&gt; is &lt;code&gt;cross-region-datasharing&lt;/code&gt;, then &lt;code&gt;LimitType&lt;/code&gt; must be &lt;code&gt;data-scanned&lt;/code&gt;.  (required)
     * @param amount The limit amount. If time-based, this amount is in minutes. If data-based, this amount is in terabytes (TB). The value must be a positive number.  (required)
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param period The time period that the amount applies to. A &lt;code&gt;weekly&lt;/code&gt; period begins on Sunday. The default is &lt;code&gt;monthly&lt;/code&gt;.  (optional)
     * @param breachAction The action that Amazon Redshift takes when the limit is reached. The default is log. For more information about this parameter, see &lt;a&gt;UsageLimit&lt;/a&gt;. (optional)
     * @param tags A list of tag instances. (optional)
     * @return UsageLimit
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> ClusterNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> InvalidClusterStateFault </td><td>  -  </td></tr>
        <tr><td> 482 </td><td> LimitExceededFault </td><td>  -  </td></tr>
        <tr><td> 483 </td><td> UsageLimitAlreadyExistsFault </td><td>  -  </td></tr>
        <tr><td> 484 </td><td> InvalidUsageLimitFault </td><td>  -  </td></tr>
        <tr><td> 485 </td><td> TagLimitExceededFault </td><td>  -  </td></tr>
        <tr><td> 486 </td><td> UnsupportedOperationFault </td><td>  -  </td></tr>
     </table>
     */
    public UsageLimit gETCreateUsageLimit(String clusterIdentifier, String featureType, String limitType, Integer amount, String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, String period, String breachAction, List<GETCreateClusterTagsParameterInner> tags) throws ApiException {
        ApiResponse<UsageLimit> localVarResp = gETCreateUsageLimitWithHttpInfo(clusterIdentifier, featureType, limitType, amount, action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, period, breachAction, tags);
        return localVarResp.getData();
    }

    /**
     * 
     * Creates a usage limit for a specified Amazon Redshift feature on a cluster. The usage limit is identified by the returned usage limit identifier.
     * @param clusterIdentifier The identifier of the cluster that you want to limit usage. (required)
     * @param featureType The Amazon Redshift feature that you want to limit. (required)
     * @param limitType The type of limit. Depending on the feature type, this can be based on a time duration or data size. If &lt;code&gt;FeatureType&lt;/code&gt; is &lt;code&gt;spectrum&lt;/code&gt;, then &lt;code&gt;LimitType&lt;/code&gt; must be &lt;code&gt;data-scanned&lt;/code&gt;. If &lt;code&gt;FeatureType&lt;/code&gt; is &lt;code&gt;concurrency-scaling&lt;/code&gt;, then &lt;code&gt;LimitType&lt;/code&gt; must be &lt;code&gt;time&lt;/code&gt;. If &lt;code&gt;FeatureType&lt;/code&gt; is &lt;code&gt;cross-region-datasharing&lt;/code&gt;, then &lt;code&gt;LimitType&lt;/code&gt; must be &lt;code&gt;data-scanned&lt;/code&gt;.  (required)
     * @param amount The limit amount. If time-based, this amount is in minutes. If data-based, this amount is in terabytes (TB). The value must be a positive number.  (required)
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param period The time period that the amount applies to. A &lt;code&gt;weekly&lt;/code&gt; period begins on Sunday. The default is &lt;code&gt;monthly&lt;/code&gt;.  (optional)
     * @param breachAction The action that Amazon Redshift takes when the limit is reached. The default is log. For more information about this parameter, see &lt;a&gt;UsageLimit&lt;/a&gt;. (optional)
     * @param tags A list of tag instances. (optional)
     * @return ApiResponse&lt;UsageLimit&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> ClusterNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> InvalidClusterStateFault </td><td>  -  </td></tr>
        <tr><td> 482 </td><td> LimitExceededFault </td><td>  -  </td></tr>
        <tr><td> 483 </td><td> UsageLimitAlreadyExistsFault </td><td>  -  </td></tr>
        <tr><td> 484 </td><td> InvalidUsageLimitFault </td><td>  -  </td></tr>
        <tr><td> 485 </td><td> TagLimitExceededFault </td><td>  -  </td></tr>
        <tr><td> 486 </td><td> UnsupportedOperationFault </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<UsageLimit> gETCreateUsageLimitWithHttpInfo(String clusterIdentifier, String featureType, String limitType, Integer amount, String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, String period, String breachAction, List<GETCreateClusterTagsParameterInner> tags) throws ApiException {
        okhttp3.Call localVarCall = gETCreateUsageLimitValidateBeforeCall(clusterIdentifier, featureType, limitType, amount, action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, period, breachAction, tags, null);
        Type localVarReturnType = new TypeToken<UsageLimit>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     *  (asynchronously)
     * Creates a usage limit for a specified Amazon Redshift feature on a cluster. The usage limit is identified by the returned usage limit identifier.
     * @param clusterIdentifier The identifier of the cluster that you want to limit usage. (required)
     * @param featureType The Amazon Redshift feature that you want to limit. (required)
     * @param limitType The type of limit. Depending on the feature type, this can be based on a time duration or data size. If &lt;code&gt;FeatureType&lt;/code&gt; is &lt;code&gt;spectrum&lt;/code&gt;, then &lt;code&gt;LimitType&lt;/code&gt; must be &lt;code&gt;data-scanned&lt;/code&gt;. If &lt;code&gt;FeatureType&lt;/code&gt; is &lt;code&gt;concurrency-scaling&lt;/code&gt;, then &lt;code&gt;LimitType&lt;/code&gt; must be &lt;code&gt;time&lt;/code&gt;. If &lt;code&gt;FeatureType&lt;/code&gt; is &lt;code&gt;cross-region-datasharing&lt;/code&gt;, then &lt;code&gt;LimitType&lt;/code&gt; must be &lt;code&gt;data-scanned&lt;/code&gt;.  (required)
     * @param amount The limit amount. If time-based, this amount is in minutes. If data-based, this amount is in terabytes (TB). The value must be a positive number.  (required)
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param period The time period that the amount applies to. A &lt;code&gt;weekly&lt;/code&gt; period begins on Sunday. The default is &lt;code&gt;monthly&lt;/code&gt;.  (optional)
     * @param breachAction The action that Amazon Redshift takes when the limit is reached. The default is log. For more information about this parameter, see &lt;a&gt;UsageLimit&lt;/a&gt;. (optional)
     * @param tags A list of tag instances. (optional)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> ClusterNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> InvalidClusterStateFault </td><td>  -  </td></tr>
        <tr><td> 482 </td><td> LimitExceededFault </td><td>  -  </td></tr>
        <tr><td> 483 </td><td> UsageLimitAlreadyExistsFault </td><td>  -  </td></tr>
        <tr><td> 484 </td><td> InvalidUsageLimitFault </td><td>  -  </td></tr>
        <tr><td> 485 </td><td> TagLimitExceededFault </td><td>  -  </td></tr>
        <tr><td> 486 </td><td> UnsupportedOperationFault </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call gETCreateUsageLimitAsync(String clusterIdentifier, String featureType, String limitType, Integer amount, String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, String period, String breachAction, List<GETCreateClusterTagsParameterInner> tags, final ApiCallback<UsageLimit> _callback) throws ApiException {

        okhttp3.Call localVarCall = gETCreateUsageLimitValidateBeforeCall(clusterIdentifier, featureType, limitType, amount, action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, period, breachAction, tags, _callback);
        Type localVarReturnType = new TypeToken<UsageLimit>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for gETDeauthorizeDataShare
     * @param dataShareArn The Amazon Resource Name (ARN) of the datashare to remove authorization from. (required)
     * @param consumerIdentifier The identifier of the data consumer that is to have authorization removed from the datashare. This identifier is an Amazon Web Services account ID or a keyword, such as ADX. (required)
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> InvalidDataShareFault </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call gETDeauthorizeDataShareCall(String dataShareArn, String consumerIdentifier, String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/#Action=DeauthorizeDataShare";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (dataShareArn != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("DataShareArn", dataShareArn));
        }

        if (consumerIdentifier != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("ConsumerIdentifier", consumerIdentifier));
        }

        if (action != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("Action", action));
        }

        if (version != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("Version", version));
        }

        if (xAmzContentSha256 != null) {
            localVarHeaderParams.put("X-Amz-Content-Sha256", localVarApiClient.parameterToString(xAmzContentSha256));
        }

        if (xAmzDate != null) {
            localVarHeaderParams.put("X-Amz-Date", localVarApiClient.parameterToString(xAmzDate));
        }

        if (xAmzAlgorithm != null) {
            localVarHeaderParams.put("X-Amz-Algorithm", localVarApiClient.parameterToString(xAmzAlgorithm));
        }

        if (xAmzCredential != null) {
            localVarHeaderParams.put("X-Amz-Credential", localVarApiClient.parameterToString(xAmzCredential));
        }

        if (xAmzSecurityToken != null) {
            localVarHeaderParams.put("X-Amz-Security-Token", localVarApiClient.parameterToString(xAmzSecurityToken));
        }

        if (xAmzSignature != null) {
            localVarHeaderParams.put("X-Amz-Signature", localVarApiClient.parameterToString(xAmzSignature));
        }

        if (xAmzSignedHeaders != null) {
            localVarHeaderParams.put("X-Amz-SignedHeaders", localVarApiClient.parameterToString(xAmzSignedHeaders));
        }

        final String[] localVarAccepts = {
            "text/xml"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "hmac" };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call gETDeauthorizeDataShareValidateBeforeCall(String dataShareArn, String consumerIdentifier, String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'dataShareArn' is set
        if (dataShareArn == null) {
            throw new ApiException("Missing the required parameter 'dataShareArn' when calling gETDeauthorizeDataShare(Async)");
        }

        // verify the required parameter 'consumerIdentifier' is set
        if (consumerIdentifier == null) {
            throw new ApiException("Missing the required parameter 'consumerIdentifier' when calling gETDeauthorizeDataShare(Async)");
        }

        // verify the required parameter 'action' is set
        if (action == null) {
            throw new ApiException("Missing the required parameter 'action' when calling gETDeauthorizeDataShare(Async)");
        }

        // verify the required parameter 'version' is set
        if (version == null) {
            throw new ApiException("Missing the required parameter 'version' when calling gETDeauthorizeDataShare(Async)");
        }

        return gETDeauthorizeDataShareCall(dataShareArn, consumerIdentifier, action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, _callback);

    }

    /**
     * 
     * From a datashare producer account, removes authorization from the specified datashare. 
     * @param dataShareArn The Amazon Resource Name (ARN) of the datashare to remove authorization from. (required)
     * @param consumerIdentifier The identifier of the data consumer that is to have authorization removed from the datashare. This identifier is an Amazon Web Services account ID or a keyword, such as ADX. (required)
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @return DataShare
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> InvalidDataShareFault </td><td>  -  </td></tr>
     </table>
     */
    public DataShare gETDeauthorizeDataShare(String dataShareArn, String consumerIdentifier, String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders) throws ApiException {
        ApiResponse<DataShare> localVarResp = gETDeauthorizeDataShareWithHttpInfo(dataShareArn, consumerIdentifier, action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders);
        return localVarResp.getData();
    }

    /**
     * 
     * From a datashare producer account, removes authorization from the specified datashare. 
     * @param dataShareArn The Amazon Resource Name (ARN) of the datashare to remove authorization from. (required)
     * @param consumerIdentifier The identifier of the data consumer that is to have authorization removed from the datashare. This identifier is an Amazon Web Services account ID or a keyword, such as ADX. (required)
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @return ApiResponse&lt;DataShare&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> InvalidDataShareFault </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<DataShare> gETDeauthorizeDataShareWithHttpInfo(String dataShareArn, String consumerIdentifier, String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders) throws ApiException {
        okhttp3.Call localVarCall = gETDeauthorizeDataShareValidateBeforeCall(dataShareArn, consumerIdentifier, action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, null);
        Type localVarReturnType = new TypeToken<DataShare>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     *  (asynchronously)
     * From a datashare producer account, removes authorization from the specified datashare. 
     * @param dataShareArn The Amazon Resource Name (ARN) of the datashare to remove authorization from. (required)
     * @param consumerIdentifier The identifier of the data consumer that is to have authorization removed from the datashare. This identifier is an Amazon Web Services account ID or a keyword, such as ADX. (required)
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> InvalidDataShareFault </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call gETDeauthorizeDataShareAsync(String dataShareArn, String consumerIdentifier, String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, final ApiCallback<DataShare> _callback) throws ApiException {

        okhttp3.Call localVarCall = gETDeauthorizeDataShareValidateBeforeCall(dataShareArn, consumerIdentifier, action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, _callback);
        Type localVarReturnType = new TypeToken<DataShare>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for gETDeleteAuthenticationProfile
     * @param authenticationProfileName The name of the authentication profile to delete. (required)
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> AuthenticationProfileNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> InvalidAuthenticationProfileRequestFault </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call gETDeleteAuthenticationProfileCall(String authenticationProfileName, String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/#Action=DeleteAuthenticationProfile";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (authenticationProfileName != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("AuthenticationProfileName", authenticationProfileName));
        }

        if (action != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("Action", action));
        }

        if (version != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("Version", version));
        }

        if (xAmzContentSha256 != null) {
            localVarHeaderParams.put("X-Amz-Content-Sha256", localVarApiClient.parameterToString(xAmzContentSha256));
        }

        if (xAmzDate != null) {
            localVarHeaderParams.put("X-Amz-Date", localVarApiClient.parameterToString(xAmzDate));
        }

        if (xAmzAlgorithm != null) {
            localVarHeaderParams.put("X-Amz-Algorithm", localVarApiClient.parameterToString(xAmzAlgorithm));
        }

        if (xAmzCredential != null) {
            localVarHeaderParams.put("X-Amz-Credential", localVarApiClient.parameterToString(xAmzCredential));
        }

        if (xAmzSecurityToken != null) {
            localVarHeaderParams.put("X-Amz-Security-Token", localVarApiClient.parameterToString(xAmzSecurityToken));
        }

        if (xAmzSignature != null) {
            localVarHeaderParams.put("X-Amz-Signature", localVarApiClient.parameterToString(xAmzSignature));
        }

        if (xAmzSignedHeaders != null) {
            localVarHeaderParams.put("X-Amz-SignedHeaders", localVarApiClient.parameterToString(xAmzSignedHeaders));
        }

        final String[] localVarAccepts = {
            "text/xml"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "hmac" };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call gETDeleteAuthenticationProfileValidateBeforeCall(String authenticationProfileName, String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'authenticationProfileName' is set
        if (authenticationProfileName == null) {
            throw new ApiException("Missing the required parameter 'authenticationProfileName' when calling gETDeleteAuthenticationProfile(Async)");
        }

        // verify the required parameter 'action' is set
        if (action == null) {
            throw new ApiException("Missing the required parameter 'action' when calling gETDeleteAuthenticationProfile(Async)");
        }

        // verify the required parameter 'version' is set
        if (version == null) {
            throw new ApiException("Missing the required parameter 'version' when calling gETDeleteAuthenticationProfile(Async)");
        }

        return gETDeleteAuthenticationProfileCall(authenticationProfileName, action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, _callback);

    }

    /**
     * 
     * Deletes an authentication profile.
     * @param authenticationProfileName The name of the authentication profile to delete. (required)
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @return DeleteAuthenticationProfileResult
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> AuthenticationProfileNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> InvalidAuthenticationProfileRequestFault </td><td>  -  </td></tr>
     </table>
     */
    public DeleteAuthenticationProfileResult gETDeleteAuthenticationProfile(String authenticationProfileName, String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders) throws ApiException {
        ApiResponse<DeleteAuthenticationProfileResult> localVarResp = gETDeleteAuthenticationProfileWithHttpInfo(authenticationProfileName, action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders);
        return localVarResp.getData();
    }

    /**
     * 
     * Deletes an authentication profile.
     * @param authenticationProfileName The name of the authentication profile to delete. (required)
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @return ApiResponse&lt;DeleteAuthenticationProfileResult&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> AuthenticationProfileNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> InvalidAuthenticationProfileRequestFault </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<DeleteAuthenticationProfileResult> gETDeleteAuthenticationProfileWithHttpInfo(String authenticationProfileName, String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders) throws ApiException {
        okhttp3.Call localVarCall = gETDeleteAuthenticationProfileValidateBeforeCall(authenticationProfileName, action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, null);
        Type localVarReturnType = new TypeToken<DeleteAuthenticationProfileResult>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     *  (asynchronously)
     * Deletes an authentication profile.
     * @param authenticationProfileName The name of the authentication profile to delete. (required)
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> AuthenticationProfileNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> InvalidAuthenticationProfileRequestFault </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call gETDeleteAuthenticationProfileAsync(String authenticationProfileName, String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, final ApiCallback<DeleteAuthenticationProfileResult> _callback) throws ApiException {

        okhttp3.Call localVarCall = gETDeleteAuthenticationProfileValidateBeforeCall(authenticationProfileName, action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, _callback);
        Type localVarReturnType = new TypeToken<DeleteAuthenticationProfileResult>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for gETDeleteCluster
     * @param clusterIdentifier &lt;p&gt;The identifier of the cluster to be deleted.&lt;/p&gt; &lt;p&gt;Constraints:&lt;/p&gt; &lt;ul&gt; &lt;li&gt; &lt;p&gt;Must contain lowercase characters.&lt;/p&gt; &lt;/li&gt; &lt;li&gt; &lt;p&gt;Must contain from 1 to 63 alphanumeric characters or hyphens.&lt;/p&gt; &lt;/li&gt; &lt;li&gt; &lt;p&gt;First character must be a letter.&lt;/p&gt; &lt;/li&gt; &lt;li&gt; &lt;p&gt;Cannot end with a hyphen or contain two consecutive hyphens.&lt;/p&gt; &lt;/li&gt; &lt;/ul&gt; (required)
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param skipFinalClusterSnapshot &lt;p&gt;Determines whether a final snapshot of the cluster is created before Amazon Redshift deletes the cluster. If &lt;code&gt;true&lt;/code&gt;, a final cluster snapshot is not created. If &lt;code&gt;false&lt;/code&gt;, a final cluster snapshot is created before the cluster is deleted. &lt;/p&gt; &lt;note&gt; &lt;p&gt;The &lt;i&gt;FinalClusterSnapshotIdentifier&lt;/i&gt; parameter must be specified if &lt;i&gt;SkipFinalClusterSnapshot&lt;/i&gt; is &lt;code&gt;false&lt;/code&gt;.&lt;/p&gt; &lt;/note&gt; &lt;p&gt;Default: &lt;code&gt;false&lt;/code&gt; &lt;/p&gt; (optional)
     * @param finalClusterSnapshotIdentifier &lt;p&gt;The identifier of the final snapshot that is to be created immediately before deleting the cluster. If this parameter is provided, &lt;i&gt;SkipFinalClusterSnapshot&lt;/i&gt; must be &lt;code&gt;false&lt;/code&gt;. &lt;/p&gt; &lt;p&gt;Constraints:&lt;/p&gt; &lt;ul&gt; &lt;li&gt; &lt;p&gt;Must be 1 to 255 alphanumeric characters.&lt;/p&gt; &lt;/li&gt; &lt;li&gt; &lt;p&gt;First character must be a letter.&lt;/p&gt; &lt;/li&gt; &lt;li&gt; &lt;p&gt;Cannot end with a hyphen or contain two consecutive hyphens.&lt;/p&gt; &lt;/li&gt; &lt;/ul&gt; (optional)
     * @param finalClusterSnapshotRetentionPeriod &lt;p&gt;The number of days that a manual snapshot is retained. If the value is -1, the manual snapshot is retained indefinitely.&lt;/p&gt; &lt;p&gt;The value must be either -1 or an integer between 1 and 3,653.&lt;/p&gt; &lt;p&gt;The default value is -1.&lt;/p&gt; (optional)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> ClusterNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> InvalidClusterStateFault </td><td>  -  </td></tr>
        <tr><td> 482 </td><td> ClusterSnapshotAlreadyExistsFault </td><td>  -  </td></tr>
        <tr><td> 483 </td><td> ClusterSnapshotQuotaExceededFault </td><td>  -  </td></tr>
        <tr><td> 484 </td><td> InvalidRetentionPeriodFault </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call gETDeleteClusterCall(String clusterIdentifier, String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, Boolean skipFinalClusterSnapshot, String finalClusterSnapshotIdentifier, Integer finalClusterSnapshotRetentionPeriod, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/#Action=DeleteCluster";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (clusterIdentifier != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("ClusterIdentifier", clusterIdentifier));
        }

        if (skipFinalClusterSnapshot != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("SkipFinalClusterSnapshot", skipFinalClusterSnapshot));
        }

        if (finalClusterSnapshotIdentifier != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("FinalClusterSnapshotIdentifier", finalClusterSnapshotIdentifier));
        }

        if (finalClusterSnapshotRetentionPeriod != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("FinalClusterSnapshotRetentionPeriod", finalClusterSnapshotRetentionPeriod));
        }

        if (action != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("Action", action));
        }

        if (version != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("Version", version));
        }

        if (xAmzContentSha256 != null) {
            localVarHeaderParams.put("X-Amz-Content-Sha256", localVarApiClient.parameterToString(xAmzContentSha256));
        }

        if (xAmzDate != null) {
            localVarHeaderParams.put("X-Amz-Date", localVarApiClient.parameterToString(xAmzDate));
        }

        if (xAmzAlgorithm != null) {
            localVarHeaderParams.put("X-Amz-Algorithm", localVarApiClient.parameterToString(xAmzAlgorithm));
        }

        if (xAmzCredential != null) {
            localVarHeaderParams.put("X-Amz-Credential", localVarApiClient.parameterToString(xAmzCredential));
        }

        if (xAmzSecurityToken != null) {
            localVarHeaderParams.put("X-Amz-Security-Token", localVarApiClient.parameterToString(xAmzSecurityToken));
        }

        if (xAmzSignature != null) {
            localVarHeaderParams.put("X-Amz-Signature", localVarApiClient.parameterToString(xAmzSignature));
        }

        if (xAmzSignedHeaders != null) {
            localVarHeaderParams.put("X-Amz-SignedHeaders", localVarApiClient.parameterToString(xAmzSignedHeaders));
        }

        final String[] localVarAccepts = {
            "text/xml"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "hmac" };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call gETDeleteClusterValidateBeforeCall(String clusterIdentifier, String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, Boolean skipFinalClusterSnapshot, String finalClusterSnapshotIdentifier, Integer finalClusterSnapshotRetentionPeriod, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'clusterIdentifier' is set
        if (clusterIdentifier == null) {
            throw new ApiException("Missing the required parameter 'clusterIdentifier' when calling gETDeleteCluster(Async)");
        }

        // verify the required parameter 'action' is set
        if (action == null) {
            throw new ApiException("Missing the required parameter 'action' when calling gETDeleteCluster(Async)");
        }

        // verify the required parameter 'version' is set
        if (version == null) {
            throw new ApiException("Missing the required parameter 'version' when calling gETDeleteCluster(Async)");
        }

        return gETDeleteClusterCall(clusterIdentifier, action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, skipFinalClusterSnapshot, finalClusterSnapshotIdentifier, finalClusterSnapshotRetentionPeriod, _callback);

    }

    /**
     * 
     * &lt;p&gt;Deletes a previously provisioned cluster without its final snapshot being created. A successful response from the web service indicates that the request was received correctly. Use &lt;a&gt;DescribeClusters&lt;/a&gt; to monitor the status of the deletion. The delete operation cannot be canceled or reverted once submitted. For more information about managing clusters, go to &lt;a href&#x3D;\&quot;https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html\&quot;&gt;Amazon Redshift Clusters&lt;/a&gt; in the &lt;i&gt;Amazon Redshift Cluster Management Guide&lt;/i&gt;.&lt;/p&gt; &lt;p&gt;If you want to shut down the cluster and retain it for future use, set &lt;i&gt;SkipFinalClusterSnapshot&lt;/i&gt; to &lt;code&gt;false&lt;/code&gt; and specify a name for &lt;i&gt;FinalClusterSnapshotIdentifier&lt;/i&gt;. You can later restore this snapshot to resume using the cluster. If a final cluster snapshot is requested, the status of the cluster will be \&quot;final-snapshot\&quot; while the snapshot is being taken, then it&#39;s \&quot;deleting\&quot; once Amazon Redshift begins deleting the cluster. &lt;/p&gt; &lt;p&gt; For more information about managing clusters, go to &lt;a href&#x3D;\&quot;https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html\&quot;&gt;Amazon Redshift Clusters&lt;/a&gt; in the &lt;i&gt;Amazon Redshift Cluster Management Guide&lt;/i&gt;.&lt;/p&gt;
     * @param clusterIdentifier &lt;p&gt;The identifier of the cluster to be deleted.&lt;/p&gt; &lt;p&gt;Constraints:&lt;/p&gt; &lt;ul&gt; &lt;li&gt; &lt;p&gt;Must contain lowercase characters.&lt;/p&gt; &lt;/li&gt; &lt;li&gt; &lt;p&gt;Must contain from 1 to 63 alphanumeric characters or hyphens.&lt;/p&gt; &lt;/li&gt; &lt;li&gt; &lt;p&gt;First character must be a letter.&lt;/p&gt; &lt;/li&gt; &lt;li&gt; &lt;p&gt;Cannot end with a hyphen or contain two consecutive hyphens.&lt;/p&gt; &lt;/li&gt; &lt;/ul&gt; (required)
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param skipFinalClusterSnapshot &lt;p&gt;Determines whether a final snapshot of the cluster is created before Amazon Redshift deletes the cluster. If &lt;code&gt;true&lt;/code&gt;, a final cluster snapshot is not created. If &lt;code&gt;false&lt;/code&gt;, a final cluster snapshot is created before the cluster is deleted. &lt;/p&gt; &lt;note&gt; &lt;p&gt;The &lt;i&gt;FinalClusterSnapshotIdentifier&lt;/i&gt; parameter must be specified if &lt;i&gt;SkipFinalClusterSnapshot&lt;/i&gt; is &lt;code&gt;false&lt;/code&gt;.&lt;/p&gt; &lt;/note&gt; &lt;p&gt;Default: &lt;code&gt;false&lt;/code&gt; &lt;/p&gt; (optional)
     * @param finalClusterSnapshotIdentifier &lt;p&gt;The identifier of the final snapshot that is to be created immediately before deleting the cluster. If this parameter is provided, &lt;i&gt;SkipFinalClusterSnapshot&lt;/i&gt; must be &lt;code&gt;false&lt;/code&gt;. &lt;/p&gt; &lt;p&gt;Constraints:&lt;/p&gt; &lt;ul&gt; &lt;li&gt; &lt;p&gt;Must be 1 to 255 alphanumeric characters.&lt;/p&gt; &lt;/li&gt; &lt;li&gt; &lt;p&gt;First character must be a letter.&lt;/p&gt; &lt;/li&gt; &lt;li&gt; &lt;p&gt;Cannot end with a hyphen or contain two consecutive hyphens.&lt;/p&gt; &lt;/li&gt; &lt;/ul&gt; (optional)
     * @param finalClusterSnapshotRetentionPeriod &lt;p&gt;The number of days that a manual snapshot is retained. If the value is -1, the manual snapshot is retained indefinitely.&lt;/p&gt; &lt;p&gt;The value must be either -1 or an integer between 1 and 3,653.&lt;/p&gt; &lt;p&gt;The default value is -1.&lt;/p&gt; (optional)
     * @return DeleteClusterResult
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> ClusterNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> InvalidClusterStateFault </td><td>  -  </td></tr>
        <tr><td> 482 </td><td> ClusterSnapshotAlreadyExistsFault </td><td>  -  </td></tr>
        <tr><td> 483 </td><td> ClusterSnapshotQuotaExceededFault </td><td>  -  </td></tr>
        <tr><td> 484 </td><td> InvalidRetentionPeriodFault </td><td>  -  </td></tr>
     </table>
     */
    public DeleteClusterResult gETDeleteCluster(String clusterIdentifier, String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, Boolean skipFinalClusterSnapshot, String finalClusterSnapshotIdentifier, Integer finalClusterSnapshotRetentionPeriod) throws ApiException {
        ApiResponse<DeleteClusterResult> localVarResp = gETDeleteClusterWithHttpInfo(clusterIdentifier, action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, skipFinalClusterSnapshot, finalClusterSnapshotIdentifier, finalClusterSnapshotRetentionPeriod);
        return localVarResp.getData();
    }

    /**
     * 
     * &lt;p&gt;Deletes a previously provisioned cluster without its final snapshot being created. A successful response from the web service indicates that the request was received correctly. Use &lt;a&gt;DescribeClusters&lt;/a&gt; to monitor the status of the deletion. The delete operation cannot be canceled or reverted once submitted. For more information about managing clusters, go to &lt;a href&#x3D;\&quot;https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html\&quot;&gt;Amazon Redshift Clusters&lt;/a&gt; in the &lt;i&gt;Amazon Redshift Cluster Management Guide&lt;/i&gt;.&lt;/p&gt; &lt;p&gt;If you want to shut down the cluster and retain it for future use, set &lt;i&gt;SkipFinalClusterSnapshot&lt;/i&gt; to &lt;code&gt;false&lt;/code&gt; and specify a name for &lt;i&gt;FinalClusterSnapshotIdentifier&lt;/i&gt;. You can later restore this snapshot to resume using the cluster. If a final cluster snapshot is requested, the status of the cluster will be \&quot;final-snapshot\&quot; while the snapshot is being taken, then it&#39;s \&quot;deleting\&quot; once Amazon Redshift begins deleting the cluster. &lt;/p&gt; &lt;p&gt; For more information about managing clusters, go to &lt;a href&#x3D;\&quot;https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html\&quot;&gt;Amazon Redshift Clusters&lt;/a&gt; in the &lt;i&gt;Amazon Redshift Cluster Management Guide&lt;/i&gt;.&lt;/p&gt;
     * @param clusterIdentifier &lt;p&gt;The identifier of the cluster to be deleted.&lt;/p&gt; &lt;p&gt;Constraints:&lt;/p&gt; &lt;ul&gt; &lt;li&gt; &lt;p&gt;Must contain lowercase characters.&lt;/p&gt; &lt;/li&gt; &lt;li&gt; &lt;p&gt;Must contain from 1 to 63 alphanumeric characters or hyphens.&lt;/p&gt; &lt;/li&gt; &lt;li&gt; &lt;p&gt;First character must be a letter.&lt;/p&gt; &lt;/li&gt; &lt;li&gt; &lt;p&gt;Cannot end with a hyphen or contain two consecutive hyphens.&lt;/p&gt; &lt;/li&gt; &lt;/ul&gt; (required)
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param skipFinalClusterSnapshot &lt;p&gt;Determines whether a final snapshot of the cluster is created before Amazon Redshift deletes the cluster. If &lt;code&gt;true&lt;/code&gt;, a final cluster snapshot is not created. If &lt;code&gt;false&lt;/code&gt;, a final cluster snapshot is created before the cluster is deleted. &lt;/p&gt; &lt;note&gt; &lt;p&gt;The &lt;i&gt;FinalClusterSnapshotIdentifier&lt;/i&gt; parameter must be specified if &lt;i&gt;SkipFinalClusterSnapshot&lt;/i&gt; is &lt;code&gt;false&lt;/code&gt;.&lt;/p&gt; &lt;/note&gt; &lt;p&gt;Default: &lt;code&gt;false&lt;/code&gt; &lt;/p&gt; (optional)
     * @param finalClusterSnapshotIdentifier &lt;p&gt;The identifier of the final snapshot that is to be created immediately before deleting the cluster. If this parameter is provided, &lt;i&gt;SkipFinalClusterSnapshot&lt;/i&gt; must be &lt;code&gt;false&lt;/code&gt;. &lt;/p&gt; &lt;p&gt;Constraints:&lt;/p&gt; &lt;ul&gt; &lt;li&gt; &lt;p&gt;Must be 1 to 255 alphanumeric characters.&lt;/p&gt; &lt;/li&gt; &lt;li&gt; &lt;p&gt;First character must be a letter.&lt;/p&gt; &lt;/li&gt; &lt;li&gt; &lt;p&gt;Cannot end with a hyphen or contain two consecutive hyphens.&lt;/p&gt; &lt;/li&gt; &lt;/ul&gt; (optional)
     * @param finalClusterSnapshotRetentionPeriod &lt;p&gt;The number of days that a manual snapshot is retained. If the value is -1, the manual snapshot is retained indefinitely.&lt;/p&gt; &lt;p&gt;The value must be either -1 or an integer between 1 and 3,653.&lt;/p&gt; &lt;p&gt;The default value is -1.&lt;/p&gt; (optional)
     * @return ApiResponse&lt;DeleteClusterResult&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> ClusterNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> InvalidClusterStateFault </td><td>  -  </td></tr>
        <tr><td> 482 </td><td> ClusterSnapshotAlreadyExistsFault </td><td>  -  </td></tr>
        <tr><td> 483 </td><td> ClusterSnapshotQuotaExceededFault </td><td>  -  </td></tr>
        <tr><td> 484 </td><td> InvalidRetentionPeriodFault </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<DeleteClusterResult> gETDeleteClusterWithHttpInfo(String clusterIdentifier, String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, Boolean skipFinalClusterSnapshot, String finalClusterSnapshotIdentifier, Integer finalClusterSnapshotRetentionPeriod) throws ApiException {
        okhttp3.Call localVarCall = gETDeleteClusterValidateBeforeCall(clusterIdentifier, action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, skipFinalClusterSnapshot, finalClusterSnapshotIdentifier, finalClusterSnapshotRetentionPeriod, null);
        Type localVarReturnType = new TypeToken<DeleteClusterResult>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     *  (asynchronously)
     * &lt;p&gt;Deletes a previously provisioned cluster without its final snapshot being created. A successful response from the web service indicates that the request was received correctly. Use &lt;a&gt;DescribeClusters&lt;/a&gt; to monitor the status of the deletion. The delete operation cannot be canceled or reverted once submitted. For more information about managing clusters, go to &lt;a href&#x3D;\&quot;https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html\&quot;&gt;Amazon Redshift Clusters&lt;/a&gt; in the &lt;i&gt;Amazon Redshift Cluster Management Guide&lt;/i&gt;.&lt;/p&gt; &lt;p&gt;If you want to shut down the cluster and retain it for future use, set &lt;i&gt;SkipFinalClusterSnapshot&lt;/i&gt; to &lt;code&gt;false&lt;/code&gt; and specify a name for &lt;i&gt;FinalClusterSnapshotIdentifier&lt;/i&gt;. You can later restore this snapshot to resume using the cluster. If a final cluster snapshot is requested, the status of the cluster will be \&quot;final-snapshot\&quot; while the snapshot is being taken, then it&#39;s \&quot;deleting\&quot; once Amazon Redshift begins deleting the cluster. &lt;/p&gt; &lt;p&gt; For more information about managing clusters, go to &lt;a href&#x3D;\&quot;https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html\&quot;&gt;Amazon Redshift Clusters&lt;/a&gt; in the &lt;i&gt;Amazon Redshift Cluster Management Guide&lt;/i&gt;.&lt;/p&gt;
     * @param clusterIdentifier &lt;p&gt;The identifier of the cluster to be deleted.&lt;/p&gt; &lt;p&gt;Constraints:&lt;/p&gt; &lt;ul&gt; &lt;li&gt; &lt;p&gt;Must contain lowercase characters.&lt;/p&gt; &lt;/li&gt; &lt;li&gt; &lt;p&gt;Must contain from 1 to 63 alphanumeric characters or hyphens.&lt;/p&gt; &lt;/li&gt; &lt;li&gt; &lt;p&gt;First character must be a letter.&lt;/p&gt; &lt;/li&gt; &lt;li&gt; &lt;p&gt;Cannot end with a hyphen or contain two consecutive hyphens.&lt;/p&gt; &lt;/li&gt; &lt;/ul&gt; (required)
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param skipFinalClusterSnapshot &lt;p&gt;Determines whether a final snapshot of the cluster is created before Amazon Redshift deletes the cluster. If &lt;code&gt;true&lt;/code&gt;, a final cluster snapshot is not created. If &lt;code&gt;false&lt;/code&gt;, a final cluster snapshot is created before the cluster is deleted. &lt;/p&gt; &lt;note&gt; &lt;p&gt;The &lt;i&gt;FinalClusterSnapshotIdentifier&lt;/i&gt; parameter must be specified if &lt;i&gt;SkipFinalClusterSnapshot&lt;/i&gt; is &lt;code&gt;false&lt;/code&gt;.&lt;/p&gt; &lt;/note&gt; &lt;p&gt;Default: &lt;code&gt;false&lt;/code&gt; &lt;/p&gt; (optional)
     * @param finalClusterSnapshotIdentifier &lt;p&gt;The identifier of the final snapshot that is to be created immediately before deleting the cluster. If this parameter is provided, &lt;i&gt;SkipFinalClusterSnapshot&lt;/i&gt; must be &lt;code&gt;false&lt;/code&gt;. &lt;/p&gt; &lt;p&gt;Constraints:&lt;/p&gt; &lt;ul&gt; &lt;li&gt; &lt;p&gt;Must be 1 to 255 alphanumeric characters.&lt;/p&gt; &lt;/li&gt; &lt;li&gt; &lt;p&gt;First character must be a letter.&lt;/p&gt; &lt;/li&gt; &lt;li&gt; &lt;p&gt;Cannot end with a hyphen or contain two consecutive hyphens.&lt;/p&gt; &lt;/li&gt; &lt;/ul&gt; (optional)
     * @param finalClusterSnapshotRetentionPeriod &lt;p&gt;The number of days that a manual snapshot is retained. If the value is -1, the manual snapshot is retained indefinitely.&lt;/p&gt; &lt;p&gt;The value must be either -1 or an integer between 1 and 3,653.&lt;/p&gt; &lt;p&gt;The default value is -1.&lt;/p&gt; (optional)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> ClusterNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> InvalidClusterStateFault </td><td>  -  </td></tr>
        <tr><td> 482 </td><td> ClusterSnapshotAlreadyExistsFault </td><td>  -  </td></tr>
        <tr><td> 483 </td><td> ClusterSnapshotQuotaExceededFault </td><td>  -  </td></tr>
        <tr><td> 484 </td><td> InvalidRetentionPeriodFault </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call gETDeleteClusterAsync(String clusterIdentifier, String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, Boolean skipFinalClusterSnapshot, String finalClusterSnapshotIdentifier, Integer finalClusterSnapshotRetentionPeriod, final ApiCallback<DeleteClusterResult> _callback) throws ApiException {

        okhttp3.Call localVarCall = gETDeleteClusterValidateBeforeCall(clusterIdentifier, action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, skipFinalClusterSnapshot, finalClusterSnapshotIdentifier, finalClusterSnapshotRetentionPeriod, _callback);
        Type localVarReturnType = new TypeToken<DeleteClusterResult>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for gETDeleteClusterParameterGroup
     * @param parameterGroupName &lt;p&gt;The name of the parameter group to be deleted.&lt;/p&gt; &lt;p&gt;Constraints:&lt;/p&gt; &lt;ul&gt; &lt;li&gt; &lt;p&gt;Must be the name of an existing cluster parameter group.&lt;/p&gt; &lt;/li&gt; &lt;li&gt; &lt;p&gt;Cannot delete a default cluster parameter group.&lt;/p&gt; &lt;/li&gt; &lt;/ul&gt; (required)
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> InvalidClusterParameterGroupStateFault </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> ClusterParameterGroupNotFoundFault </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call gETDeleteClusterParameterGroupCall(String parameterGroupName, String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/#Action=DeleteClusterParameterGroup";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (parameterGroupName != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("ParameterGroupName", parameterGroupName));
        }

        if (action != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("Action", action));
        }

        if (version != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("Version", version));
        }

        if (xAmzContentSha256 != null) {
            localVarHeaderParams.put("X-Amz-Content-Sha256", localVarApiClient.parameterToString(xAmzContentSha256));
        }

        if (xAmzDate != null) {
            localVarHeaderParams.put("X-Amz-Date", localVarApiClient.parameterToString(xAmzDate));
        }

        if (xAmzAlgorithm != null) {
            localVarHeaderParams.put("X-Amz-Algorithm", localVarApiClient.parameterToString(xAmzAlgorithm));
        }

        if (xAmzCredential != null) {
            localVarHeaderParams.put("X-Amz-Credential", localVarApiClient.parameterToString(xAmzCredential));
        }

        if (xAmzSecurityToken != null) {
            localVarHeaderParams.put("X-Amz-Security-Token", localVarApiClient.parameterToString(xAmzSecurityToken));
        }

        if (xAmzSignature != null) {
            localVarHeaderParams.put("X-Amz-Signature", localVarApiClient.parameterToString(xAmzSignature));
        }

        if (xAmzSignedHeaders != null) {
            localVarHeaderParams.put("X-Amz-SignedHeaders", localVarApiClient.parameterToString(xAmzSignedHeaders));
        }

        final String[] localVarAccepts = {
            "text/xml"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "hmac" };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call gETDeleteClusterParameterGroupValidateBeforeCall(String parameterGroupName, String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'parameterGroupName' is set
        if (parameterGroupName == null) {
            throw new ApiException("Missing the required parameter 'parameterGroupName' when calling gETDeleteClusterParameterGroup(Async)");
        }

        // verify the required parameter 'action' is set
        if (action == null) {
            throw new ApiException("Missing the required parameter 'action' when calling gETDeleteClusterParameterGroup(Async)");
        }

        // verify the required parameter 'version' is set
        if (version == null) {
            throw new ApiException("Missing the required parameter 'version' when calling gETDeleteClusterParameterGroup(Async)");
        }

        return gETDeleteClusterParameterGroupCall(parameterGroupName, action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, _callback);

    }

    /**
     * 
     * &lt;p&gt;Deletes a specified Amazon Redshift parameter group.&lt;/p&gt; &lt;note&gt; &lt;p&gt;You cannot delete a parameter group if it is associated with a cluster.&lt;/p&gt; &lt;/note&gt;
     * @param parameterGroupName &lt;p&gt;The name of the parameter group to be deleted.&lt;/p&gt; &lt;p&gt;Constraints:&lt;/p&gt; &lt;ul&gt; &lt;li&gt; &lt;p&gt;Must be the name of an existing cluster parameter group.&lt;/p&gt; &lt;/li&gt; &lt;li&gt; &lt;p&gt;Cannot delete a default cluster parameter group.&lt;/p&gt; &lt;/li&gt; &lt;/ul&gt; (required)
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> InvalidClusterParameterGroupStateFault </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> ClusterParameterGroupNotFoundFault </td><td>  -  </td></tr>
     </table>
     */
    public void gETDeleteClusterParameterGroup(String parameterGroupName, String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders) throws ApiException {
        gETDeleteClusterParameterGroupWithHttpInfo(parameterGroupName, action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders);
    }

    /**
     * 
     * &lt;p&gt;Deletes a specified Amazon Redshift parameter group.&lt;/p&gt; &lt;note&gt; &lt;p&gt;You cannot delete a parameter group if it is associated with a cluster.&lt;/p&gt; &lt;/note&gt;
     * @param parameterGroupName &lt;p&gt;The name of the parameter group to be deleted.&lt;/p&gt; &lt;p&gt;Constraints:&lt;/p&gt; &lt;ul&gt; &lt;li&gt; &lt;p&gt;Must be the name of an existing cluster parameter group.&lt;/p&gt; &lt;/li&gt; &lt;li&gt; &lt;p&gt;Cannot delete a default cluster parameter group.&lt;/p&gt; &lt;/li&gt; &lt;/ul&gt; (required)
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @return ApiResponse&lt;Void&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> InvalidClusterParameterGroupStateFault </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> ClusterParameterGroupNotFoundFault </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<Void> gETDeleteClusterParameterGroupWithHttpInfo(String parameterGroupName, String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders) throws ApiException {
        okhttp3.Call localVarCall = gETDeleteClusterParameterGroupValidateBeforeCall(parameterGroupName, action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, null);
        return localVarApiClient.execute(localVarCall);
    }

    /**
     *  (asynchronously)
     * &lt;p&gt;Deletes a specified Amazon Redshift parameter group.&lt;/p&gt; &lt;note&gt; &lt;p&gt;You cannot delete a parameter group if it is associated with a cluster.&lt;/p&gt; &lt;/note&gt;
     * @param parameterGroupName &lt;p&gt;The name of the parameter group to be deleted.&lt;/p&gt; &lt;p&gt;Constraints:&lt;/p&gt; &lt;ul&gt; &lt;li&gt; &lt;p&gt;Must be the name of an existing cluster parameter group.&lt;/p&gt; &lt;/li&gt; &lt;li&gt; &lt;p&gt;Cannot delete a default cluster parameter group.&lt;/p&gt; &lt;/li&gt; &lt;/ul&gt; (required)
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> InvalidClusterParameterGroupStateFault </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> ClusterParameterGroupNotFoundFault </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call gETDeleteClusterParameterGroupAsync(String parameterGroupName, String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, final ApiCallback<Void> _callback) throws ApiException {

        okhttp3.Call localVarCall = gETDeleteClusterParameterGroupValidateBeforeCall(parameterGroupName, action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, _callback);
        localVarApiClient.executeAsync(localVarCall, _callback);
        return localVarCall;
    }
    /**
     * Build call for gETDeleteClusterSecurityGroup
     * @param clusterSecurityGroupName The name of the cluster security group to be deleted. (required)
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> InvalidClusterSecurityGroupStateFault </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> ClusterSecurityGroupNotFoundFault </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call gETDeleteClusterSecurityGroupCall(String clusterSecurityGroupName, String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/#Action=DeleteClusterSecurityGroup";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (clusterSecurityGroupName != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("ClusterSecurityGroupName", clusterSecurityGroupName));
        }

        if (action != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("Action", action));
        }

        if (version != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("Version", version));
        }

        if (xAmzContentSha256 != null) {
            localVarHeaderParams.put("X-Amz-Content-Sha256", localVarApiClient.parameterToString(xAmzContentSha256));
        }

        if (xAmzDate != null) {
            localVarHeaderParams.put("X-Amz-Date", localVarApiClient.parameterToString(xAmzDate));
        }

        if (xAmzAlgorithm != null) {
            localVarHeaderParams.put("X-Amz-Algorithm", localVarApiClient.parameterToString(xAmzAlgorithm));
        }

        if (xAmzCredential != null) {
            localVarHeaderParams.put("X-Amz-Credential", localVarApiClient.parameterToString(xAmzCredential));
        }

        if (xAmzSecurityToken != null) {
            localVarHeaderParams.put("X-Amz-Security-Token", localVarApiClient.parameterToString(xAmzSecurityToken));
        }

        if (xAmzSignature != null) {
            localVarHeaderParams.put("X-Amz-Signature", localVarApiClient.parameterToString(xAmzSignature));
        }

        if (xAmzSignedHeaders != null) {
            localVarHeaderParams.put("X-Amz-SignedHeaders", localVarApiClient.parameterToString(xAmzSignedHeaders));
        }

        final String[] localVarAccepts = {
            "text/xml"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "hmac" };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call gETDeleteClusterSecurityGroupValidateBeforeCall(String clusterSecurityGroupName, String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'clusterSecurityGroupName' is set
        if (clusterSecurityGroupName == null) {
            throw new ApiException("Missing the required parameter 'clusterSecurityGroupName' when calling gETDeleteClusterSecurityGroup(Async)");
        }

        // verify the required parameter 'action' is set
        if (action == null) {
            throw new ApiException("Missing the required parameter 'action' when calling gETDeleteClusterSecurityGroup(Async)");
        }

        // verify the required parameter 'version' is set
        if (version == null) {
            throw new ApiException("Missing the required parameter 'version' when calling gETDeleteClusterSecurityGroup(Async)");
        }

        return gETDeleteClusterSecurityGroupCall(clusterSecurityGroupName, action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, _callback);

    }

    /**
     * 
     * &lt;p&gt;Deletes an Amazon Redshift security group.&lt;/p&gt; &lt;note&gt; &lt;p&gt;You cannot delete a security group that is associated with any clusters. You cannot delete the default security group.&lt;/p&gt; &lt;/note&gt; &lt;p&gt; For information about managing security groups, go to &lt;a href&#x3D;\&quot;https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-security-groups.html\&quot;&gt;Amazon Redshift Cluster Security Groups&lt;/a&gt; in the &lt;i&gt;Amazon Redshift Cluster Management Guide&lt;/i&gt;.&lt;/p&gt;
     * @param clusterSecurityGroupName The name of the cluster security group to be deleted. (required)
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> InvalidClusterSecurityGroupStateFault </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> ClusterSecurityGroupNotFoundFault </td><td>  -  </td></tr>
     </table>
     */
    public void gETDeleteClusterSecurityGroup(String clusterSecurityGroupName, String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders) throws ApiException {
        gETDeleteClusterSecurityGroupWithHttpInfo(clusterSecurityGroupName, action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders);
    }

    /**
     * 
     * &lt;p&gt;Deletes an Amazon Redshift security group.&lt;/p&gt; &lt;note&gt; &lt;p&gt;You cannot delete a security group that is associated with any clusters. You cannot delete the default security group.&lt;/p&gt; &lt;/note&gt; &lt;p&gt; For information about managing security groups, go to &lt;a href&#x3D;\&quot;https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-security-groups.html\&quot;&gt;Amazon Redshift Cluster Security Groups&lt;/a&gt; in the &lt;i&gt;Amazon Redshift Cluster Management Guide&lt;/i&gt;.&lt;/p&gt;
     * @param clusterSecurityGroupName The name of the cluster security group to be deleted. (required)
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @return ApiResponse&lt;Void&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> InvalidClusterSecurityGroupStateFault </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> ClusterSecurityGroupNotFoundFault </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<Void> gETDeleteClusterSecurityGroupWithHttpInfo(String clusterSecurityGroupName, String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders) throws ApiException {
        okhttp3.Call localVarCall = gETDeleteClusterSecurityGroupValidateBeforeCall(clusterSecurityGroupName, action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, null);
        return localVarApiClient.execute(localVarCall);
    }

    /**
     *  (asynchronously)
     * &lt;p&gt;Deletes an Amazon Redshift security group.&lt;/p&gt; &lt;note&gt; &lt;p&gt;You cannot delete a security group that is associated with any clusters. You cannot delete the default security group.&lt;/p&gt; &lt;/note&gt; &lt;p&gt; For information about managing security groups, go to &lt;a href&#x3D;\&quot;https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-security-groups.html\&quot;&gt;Amazon Redshift Cluster Security Groups&lt;/a&gt; in the &lt;i&gt;Amazon Redshift Cluster Management Guide&lt;/i&gt;.&lt;/p&gt;
     * @param clusterSecurityGroupName The name of the cluster security group to be deleted. (required)
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> InvalidClusterSecurityGroupStateFault </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> ClusterSecurityGroupNotFoundFault </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call gETDeleteClusterSecurityGroupAsync(String clusterSecurityGroupName, String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, final ApiCallback<Void> _callback) throws ApiException {

        okhttp3.Call localVarCall = gETDeleteClusterSecurityGroupValidateBeforeCall(clusterSecurityGroupName, action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, _callback);
        localVarApiClient.executeAsync(localVarCall, _callback);
        return localVarCall;
    }
    /**
     * Build call for gETDeleteClusterSnapshot
     * @param snapshotIdentifier &lt;p&gt;The unique identifier of the manual snapshot to be deleted.&lt;/p&gt; &lt;p&gt;Constraints: Must be the name of an existing snapshot that is in the &lt;code&gt;available&lt;/code&gt;, &lt;code&gt;failed&lt;/code&gt;, or &lt;code&gt;cancelled&lt;/code&gt; state.&lt;/p&gt; (required)
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param snapshotClusterIdentifier &lt;p&gt;The unique identifier of the cluster the snapshot was created from. This parameter is required if your IAM user has a policy containing a snapshot resource element that specifies anything other than * for the cluster name.&lt;/p&gt; &lt;p&gt;Constraints: Must be the name of valid cluster.&lt;/p&gt; (optional)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> InvalidClusterSnapshotStateFault </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> ClusterSnapshotNotFoundFault </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call gETDeleteClusterSnapshotCall(String snapshotIdentifier, String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, String snapshotClusterIdentifier, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/#Action=DeleteClusterSnapshot";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (snapshotIdentifier != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("SnapshotIdentifier", snapshotIdentifier));
        }

        if (snapshotClusterIdentifier != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("SnapshotClusterIdentifier", snapshotClusterIdentifier));
        }

        if (action != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("Action", action));
        }

        if (version != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("Version", version));
        }

        if (xAmzContentSha256 != null) {
            localVarHeaderParams.put("X-Amz-Content-Sha256", localVarApiClient.parameterToString(xAmzContentSha256));
        }

        if (xAmzDate != null) {
            localVarHeaderParams.put("X-Amz-Date", localVarApiClient.parameterToString(xAmzDate));
        }

        if (xAmzAlgorithm != null) {
            localVarHeaderParams.put("X-Amz-Algorithm", localVarApiClient.parameterToString(xAmzAlgorithm));
        }

        if (xAmzCredential != null) {
            localVarHeaderParams.put("X-Amz-Credential", localVarApiClient.parameterToString(xAmzCredential));
        }

        if (xAmzSecurityToken != null) {
            localVarHeaderParams.put("X-Amz-Security-Token", localVarApiClient.parameterToString(xAmzSecurityToken));
        }

        if (xAmzSignature != null) {
            localVarHeaderParams.put("X-Amz-Signature", localVarApiClient.parameterToString(xAmzSignature));
        }

        if (xAmzSignedHeaders != null) {
            localVarHeaderParams.put("X-Amz-SignedHeaders", localVarApiClient.parameterToString(xAmzSignedHeaders));
        }

        final String[] localVarAccepts = {
            "text/xml"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "hmac" };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call gETDeleteClusterSnapshotValidateBeforeCall(String snapshotIdentifier, String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, String snapshotClusterIdentifier, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'snapshotIdentifier' is set
        if (snapshotIdentifier == null) {
            throw new ApiException("Missing the required parameter 'snapshotIdentifier' when calling gETDeleteClusterSnapshot(Async)");
        }

        // verify the required parameter 'action' is set
        if (action == null) {
            throw new ApiException("Missing the required parameter 'action' when calling gETDeleteClusterSnapshot(Async)");
        }

        // verify the required parameter 'version' is set
        if (version == null) {
            throw new ApiException("Missing the required parameter 'version' when calling gETDeleteClusterSnapshot(Async)");
        }

        return gETDeleteClusterSnapshotCall(snapshotIdentifier, action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, snapshotClusterIdentifier, _callback);

    }

    /**
     * 
     * &lt;p&gt;Deletes the specified manual snapshot. The snapshot must be in the &lt;code&gt;available&lt;/code&gt; state, with no other users authorized to access the snapshot. &lt;/p&gt; &lt;p&gt;Unlike automated snapshots, manual snapshots are retained even after you delete your cluster. Amazon Redshift does not delete your manual snapshots. You must delete manual snapshot explicitly to avoid getting charged. If other accounts are authorized to access the snapshot, you must revoke all of the authorizations before you can delete the snapshot.&lt;/p&gt;
     * @param snapshotIdentifier &lt;p&gt;The unique identifier of the manual snapshot to be deleted.&lt;/p&gt; &lt;p&gt;Constraints: Must be the name of an existing snapshot that is in the &lt;code&gt;available&lt;/code&gt;, &lt;code&gt;failed&lt;/code&gt;, or &lt;code&gt;cancelled&lt;/code&gt; state.&lt;/p&gt; (required)
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param snapshotClusterIdentifier &lt;p&gt;The unique identifier of the cluster the snapshot was created from. This parameter is required if your IAM user has a policy containing a snapshot resource element that specifies anything other than * for the cluster name.&lt;/p&gt; &lt;p&gt;Constraints: Must be the name of valid cluster.&lt;/p&gt; (optional)
     * @return DeleteClusterSnapshotResult
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> InvalidClusterSnapshotStateFault </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> ClusterSnapshotNotFoundFault </td><td>  -  </td></tr>
     </table>
     */
    public DeleteClusterSnapshotResult gETDeleteClusterSnapshot(String snapshotIdentifier, String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, String snapshotClusterIdentifier) throws ApiException {
        ApiResponse<DeleteClusterSnapshotResult> localVarResp = gETDeleteClusterSnapshotWithHttpInfo(snapshotIdentifier, action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, snapshotClusterIdentifier);
        return localVarResp.getData();
    }

    /**
     * 
     * &lt;p&gt;Deletes the specified manual snapshot. The snapshot must be in the &lt;code&gt;available&lt;/code&gt; state, with no other users authorized to access the snapshot. &lt;/p&gt; &lt;p&gt;Unlike automated snapshots, manual snapshots are retained even after you delete your cluster. Amazon Redshift does not delete your manual snapshots. You must delete manual snapshot explicitly to avoid getting charged. If other accounts are authorized to access the snapshot, you must revoke all of the authorizations before you can delete the snapshot.&lt;/p&gt;
     * @param snapshotIdentifier &lt;p&gt;The unique identifier of the manual snapshot to be deleted.&lt;/p&gt; &lt;p&gt;Constraints: Must be the name of an existing snapshot that is in the &lt;code&gt;available&lt;/code&gt;, &lt;code&gt;failed&lt;/code&gt;, or &lt;code&gt;cancelled&lt;/code&gt; state.&lt;/p&gt; (required)
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param snapshotClusterIdentifier &lt;p&gt;The unique identifier of the cluster the snapshot was created from. This parameter is required if your IAM user has a policy containing a snapshot resource element that specifies anything other than * for the cluster name.&lt;/p&gt; &lt;p&gt;Constraints: Must be the name of valid cluster.&lt;/p&gt; (optional)
     * @return ApiResponse&lt;DeleteClusterSnapshotResult&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> InvalidClusterSnapshotStateFault </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> ClusterSnapshotNotFoundFault </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<DeleteClusterSnapshotResult> gETDeleteClusterSnapshotWithHttpInfo(String snapshotIdentifier, String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, String snapshotClusterIdentifier) throws ApiException {
        okhttp3.Call localVarCall = gETDeleteClusterSnapshotValidateBeforeCall(snapshotIdentifier, action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, snapshotClusterIdentifier, null);
        Type localVarReturnType = new TypeToken<DeleteClusterSnapshotResult>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     *  (asynchronously)
     * &lt;p&gt;Deletes the specified manual snapshot. The snapshot must be in the &lt;code&gt;available&lt;/code&gt; state, with no other users authorized to access the snapshot. &lt;/p&gt; &lt;p&gt;Unlike automated snapshots, manual snapshots are retained even after you delete your cluster. Amazon Redshift does not delete your manual snapshots. You must delete manual snapshot explicitly to avoid getting charged. If other accounts are authorized to access the snapshot, you must revoke all of the authorizations before you can delete the snapshot.&lt;/p&gt;
     * @param snapshotIdentifier &lt;p&gt;The unique identifier of the manual snapshot to be deleted.&lt;/p&gt; &lt;p&gt;Constraints: Must be the name of an existing snapshot that is in the &lt;code&gt;available&lt;/code&gt;, &lt;code&gt;failed&lt;/code&gt;, or &lt;code&gt;cancelled&lt;/code&gt; state.&lt;/p&gt; (required)
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param snapshotClusterIdentifier &lt;p&gt;The unique identifier of the cluster the snapshot was created from. This parameter is required if your IAM user has a policy containing a snapshot resource element that specifies anything other than * for the cluster name.&lt;/p&gt; &lt;p&gt;Constraints: Must be the name of valid cluster.&lt;/p&gt; (optional)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> InvalidClusterSnapshotStateFault </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> ClusterSnapshotNotFoundFault </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call gETDeleteClusterSnapshotAsync(String snapshotIdentifier, String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, String snapshotClusterIdentifier, final ApiCallback<DeleteClusterSnapshotResult> _callback) throws ApiException {

        okhttp3.Call localVarCall = gETDeleteClusterSnapshotValidateBeforeCall(snapshotIdentifier, action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, snapshotClusterIdentifier, _callback);
        Type localVarReturnType = new TypeToken<DeleteClusterSnapshotResult>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for gETDeleteClusterSubnetGroup
     * @param clusterSubnetGroupName The name of the cluster subnet group name to be deleted. (required)
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> InvalidClusterSubnetGroupStateFault </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> InvalidClusterSubnetStateFault </td><td>  -  </td></tr>
        <tr><td> 482 </td><td> ClusterSubnetGroupNotFoundFault </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call gETDeleteClusterSubnetGroupCall(String clusterSubnetGroupName, String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/#Action=DeleteClusterSubnetGroup";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (clusterSubnetGroupName != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("ClusterSubnetGroupName", clusterSubnetGroupName));
        }

        if (action != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("Action", action));
        }

        if (version != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("Version", version));
        }

        if (xAmzContentSha256 != null) {
            localVarHeaderParams.put("X-Amz-Content-Sha256", localVarApiClient.parameterToString(xAmzContentSha256));
        }

        if (xAmzDate != null) {
            localVarHeaderParams.put("X-Amz-Date", localVarApiClient.parameterToString(xAmzDate));
        }

        if (xAmzAlgorithm != null) {
            localVarHeaderParams.put("X-Amz-Algorithm", localVarApiClient.parameterToString(xAmzAlgorithm));
        }

        if (xAmzCredential != null) {
            localVarHeaderParams.put("X-Amz-Credential", localVarApiClient.parameterToString(xAmzCredential));
        }

        if (xAmzSecurityToken != null) {
            localVarHeaderParams.put("X-Amz-Security-Token", localVarApiClient.parameterToString(xAmzSecurityToken));
        }

        if (xAmzSignature != null) {
            localVarHeaderParams.put("X-Amz-Signature", localVarApiClient.parameterToString(xAmzSignature));
        }

        if (xAmzSignedHeaders != null) {
            localVarHeaderParams.put("X-Amz-SignedHeaders", localVarApiClient.parameterToString(xAmzSignedHeaders));
        }

        final String[] localVarAccepts = {
            "text/xml"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "hmac" };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call gETDeleteClusterSubnetGroupValidateBeforeCall(String clusterSubnetGroupName, String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'clusterSubnetGroupName' is set
        if (clusterSubnetGroupName == null) {
            throw new ApiException("Missing the required parameter 'clusterSubnetGroupName' when calling gETDeleteClusterSubnetGroup(Async)");
        }

        // verify the required parameter 'action' is set
        if (action == null) {
            throw new ApiException("Missing the required parameter 'action' when calling gETDeleteClusterSubnetGroup(Async)");
        }

        // verify the required parameter 'version' is set
        if (version == null) {
            throw new ApiException("Missing the required parameter 'version' when calling gETDeleteClusterSubnetGroup(Async)");
        }

        return gETDeleteClusterSubnetGroupCall(clusterSubnetGroupName, action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, _callback);

    }

    /**
     * 
     * Deletes the specified cluster subnet group.
     * @param clusterSubnetGroupName The name of the cluster subnet group name to be deleted. (required)
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> InvalidClusterSubnetGroupStateFault </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> InvalidClusterSubnetStateFault </td><td>  -  </td></tr>
        <tr><td> 482 </td><td> ClusterSubnetGroupNotFoundFault </td><td>  -  </td></tr>
     </table>
     */
    public void gETDeleteClusterSubnetGroup(String clusterSubnetGroupName, String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders) throws ApiException {
        gETDeleteClusterSubnetGroupWithHttpInfo(clusterSubnetGroupName, action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders);
    }

    /**
     * 
     * Deletes the specified cluster subnet group.
     * @param clusterSubnetGroupName The name of the cluster subnet group name to be deleted. (required)
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @return ApiResponse&lt;Void&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> InvalidClusterSubnetGroupStateFault </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> InvalidClusterSubnetStateFault </td><td>  -  </td></tr>
        <tr><td> 482 </td><td> ClusterSubnetGroupNotFoundFault </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<Void> gETDeleteClusterSubnetGroupWithHttpInfo(String clusterSubnetGroupName, String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders) throws ApiException {
        okhttp3.Call localVarCall = gETDeleteClusterSubnetGroupValidateBeforeCall(clusterSubnetGroupName, action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, null);
        return localVarApiClient.execute(localVarCall);
    }

    /**
     *  (asynchronously)
     * Deletes the specified cluster subnet group.
     * @param clusterSubnetGroupName The name of the cluster subnet group name to be deleted. (required)
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> InvalidClusterSubnetGroupStateFault </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> InvalidClusterSubnetStateFault </td><td>  -  </td></tr>
        <tr><td> 482 </td><td> ClusterSubnetGroupNotFoundFault </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call gETDeleteClusterSubnetGroupAsync(String clusterSubnetGroupName, String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, final ApiCallback<Void> _callback) throws ApiException {

        okhttp3.Call localVarCall = gETDeleteClusterSubnetGroupValidateBeforeCall(clusterSubnetGroupName, action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, _callback);
        localVarApiClient.executeAsync(localVarCall, _callback);
        return localVarCall;
    }
    /**
     * Build call for gETDeleteCustomDomainAssociation
     * @param clusterIdentifier The identifier of the cluster to delete a custom domain association for. (required)
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> UnsupportedOperationFault </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> ClusterNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 482 </td><td> CustomCnameAssociationFault </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call gETDeleteCustomDomainAssociationCall(String clusterIdentifier, String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/#Action=DeleteCustomDomainAssociation";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (clusterIdentifier != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("ClusterIdentifier", clusterIdentifier));
        }

        if (action != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("Action", action));
        }

        if (version != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("Version", version));
        }

        if (xAmzContentSha256 != null) {
            localVarHeaderParams.put("X-Amz-Content-Sha256", localVarApiClient.parameterToString(xAmzContentSha256));
        }

        if (xAmzDate != null) {
            localVarHeaderParams.put("X-Amz-Date", localVarApiClient.parameterToString(xAmzDate));
        }

        if (xAmzAlgorithm != null) {
            localVarHeaderParams.put("X-Amz-Algorithm", localVarApiClient.parameterToString(xAmzAlgorithm));
        }

        if (xAmzCredential != null) {
            localVarHeaderParams.put("X-Amz-Credential", localVarApiClient.parameterToString(xAmzCredential));
        }

        if (xAmzSecurityToken != null) {
            localVarHeaderParams.put("X-Amz-Security-Token", localVarApiClient.parameterToString(xAmzSecurityToken));
        }

        if (xAmzSignature != null) {
            localVarHeaderParams.put("X-Amz-Signature", localVarApiClient.parameterToString(xAmzSignature));
        }

        if (xAmzSignedHeaders != null) {
            localVarHeaderParams.put("X-Amz-SignedHeaders", localVarApiClient.parameterToString(xAmzSignedHeaders));
        }

        final String[] localVarAccepts = {
            "text/xml"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "hmac" };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call gETDeleteCustomDomainAssociationValidateBeforeCall(String clusterIdentifier, String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'clusterIdentifier' is set
        if (clusterIdentifier == null) {
            throw new ApiException("Missing the required parameter 'clusterIdentifier' when calling gETDeleteCustomDomainAssociation(Async)");
        }

        // verify the required parameter 'action' is set
        if (action == null) {
            throw new ApiException("Missing the required parameter 'action' when calling gETDeleteCustomDomainAssociation(Async)");
        }

        // verify the required parameter 'version' is set
        if (version == null) {
            throw new ApiException("Missing the required parameter 'version' when calling gETDeleteCustomDomainAssociation(Async)");
        }

        return gETDeleteCustomDomainAssociationCall(clusterIdentifier, action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, _callback);

    }

    /**
     * 
     * Contains information about deleting a custom domain association for a cluster.
     * @param clusterIdentifier The identifier of the cluster to delete a custom domain association for. (required)
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> UnsupportedOperationFault </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> ClusterNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 482 </td><td> CustomCnameAssociationFault </td><td>  -  </td></tr>
     </table>
     */
    public void gETDeleteCustomDomainAssociation(String clusterIdentifier, String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders) throws ApiException {
        gETDeleteCustomDomainAssociationWithHttpInfo(clusterIdentifier, action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders);
    }

    /**
     * 
     * Contains information about deleting a custom domain association for a cluster.
     * @param clusterIdentifier The identifier of the cluster to delete a custom domain association for. (required)
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @return ApiResponse&lt;Void&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> UnsupportedOperationFault </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> ClusterNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 482 </td><td> CustomCnameAssociationFault </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<Void> gETDeleteCustomDomainAssociationWithHttpInfo(String clusterIdentifier, String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders) throws ApiException {
        okhttp3.Call localVarCall = gETDeleteCustomDomainAssociationValidateBeforeCall(clusterIdentifier, action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, null);
        return localVarApiClient.execute(localVarCall);
    }

    /**
     *  (asynchronously)
     * Contains information about deleting a custom domain association for a cluster.
     * @param clusterIdentifier The identifier of the cluster to delete a custom domain association for. (required)
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> UnsupportedOperationFault </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> ClusterNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 482 </td><td> CustomCnameAssociationFault </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call gETDeleteCustomDomainAssociationAsync(String clusterIdentifier, String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, final ApiCallback<Void> _callback) throws ApiException {

        okhttp3.Call localVarCall = gETDeleteCustomDomainAssociationValidateBeforeCall(clusterIdentifier, action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, _callback);
        localVarApiClient.executeAsync(localVarCall, _callback);
        return localVarCall;
    }
    /**
     * Build call for gETDeleteEndpointAccess
     * @param endpointName The Redshift-managed VPC endpoint to delete. (required)
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> ClusterNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> InvalidEndpointStateFault </td><td>  -  </td></tr>
        <tr><td> 482 </td><td> InvalidClusterSecurityGroupStateFault </td><td>  -  </td></tr>
        <tr><td> 483 </td><td> EndpointNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 484 </td><td> InvalidClusterStateFault </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call gETDeleteEndpointAccessCall(String endpointName, String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/#Action=DeleteEndpointAccess";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (endpointName != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("EndpointName", endpointName));
        }

        if (action != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("Action", action));
        }

        if (version != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("Version", version));
        }

        if (xAmzContentSha256 != null) {
            localVarHeaderParams.put("X-Amz-Content-Sha256", localVarApiClient.parameterToString(xAmzContentSha256));
        }

        if (xAmzDate != null) {
            localVarHeaderParams.put("X-Amz-Date", localVarApiClient.parameterToString(xAmzDate));
        }

        if (xAmzAlgorithm != null) {
            localVarHeaderParams.put("X-Amz-Algorithm", localVarApiClient.parameterToString(xAmzAlgorithm));
        }

        if (xAmzCredential != null) {
            localVarHeaderParams.put("X-Amz-Credential", localVarApiClient.parameterToString(xAmzCredential));
        }

        if (xAmzSecurityToken != null) {
            localVarHeaderParams.put("X-Amz-Security-Token", localVarApiClient.parameterToString(xAmzSecurityToken));
        }

        if (xAmzSignature != null) {
            localVarHeaderParams.put("X-Amz-Signature", localVarApiClient.parameterToString(xAmzSignature));
        }

        if (xAmzSignedHeaders != null) {
            localVarHeaderParams.put("X-Amz-SignedHeaders", localVarApiClient.parameterToString(xAmzSignedHeaders));
        }

        final String[] localVarAccepts = {
            "text/xml"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "hmac" };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call gETDeleteEndpointAccessValidateBeforeCall(String endpointName, String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'endpointName' is set
        if (endpointName == null) {
            throw new ApiException("Missing the required parameter 'endpointName' when calling gETDeleteEndpointAccess(Async)");
        }

        // verify the required parameter 'action' is set
        if (action == null) {
            throw new ApiException("Missing the required parameter 'action' when calling gETDeleteEndpointAccess(Async)");
        }

        // verify the required parameter 'version' is set
        if (version == null) {
            throw new ApiException("Missing the required parameter 'version' when calling gETDeleteEndpointAccess(Async)");
        }

        return gETDeleteEndpointAccessCall(endpointName, action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, _callback);

    }

    /**
     * 
     * Deletes a Redshift-managed VPC endpoint.
     * @param endpointName The Redshift-managed VPC endpoint to delete. (required)
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @return EndpointAccess
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> ClusterNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> InvalidEndpointStateFault </td><td>  -  </td></tr>
        <tr><td> 482 </td><td> InvalidClusterSecurityGroupStateFault </td><td>  -  </td></tr>
        <tr><td> 483 </td><td> EndpointNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 484 </td><td> InvalidClusterStateFault </td><td>  -  </td></tr>
     </table>
     */
    public EndpointAccess gETDeleteEndpointAccess(String endpointName, String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders) throws ApiException {
        ApiResponse<EndpointAccess> localVarResp = gETDeleteEndpointAccessWithHttpInfo(endpointName, action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders);
        return localVarResp.getData();
    }

    /**
     * 
     * Deletes a Redshift-managed VPC endpoint.
     * @param endpointName The Redshift-managed VPC endpoint to delete. (required)
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @return ApiResponse&lt;EndpointAccess&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> ClusterNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> InvalidEndpointStateFault </td><td>  -  </td></tr>
        <tr><td> 482 </td><td> InvalidClusterSecurityGroupStateFault </td><td>  -  </td></tr>
        <tr><td> 483 </td><td> EndpointNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 484 </td><td> InvalidClusterStateFault </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<EndpointAccess> gETDeleteEndpointAccessWithHttpInfo(String endpointName, String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders) throws ApiException {
        okhttp3.Call localVarCall = gETDeleteEndpointAccessValidateBeforeCall(endpointName, action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, null);
        Type localVarReturnType = new TypeToken<EndpointAccess>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     *  (asynchronously)
     * Deletes a Redshift-managed VPC endpoint.
     * @param endpointName The Redshift-managed VPC endpoint to delete. (required)
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> ClusterNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> InvalidEndpointStateFault </td><td>  -  </td></tr>
        <tr><td> 482 </td><td> InvalidClusterSecurityGroupStateFault </td><td>  -  </td></tr>
        <tr><td> 483 </td><td> EndpointNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 484 </td><td> InvalidClusterStateFault </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call gETDeleteEndpointAccessAsync(String endpointName, String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, final ApiCallback<EndpointAccess> _callback) throws ApiException {

        okhttp3.Call localVarCall = gETDeleteEndpointAccessValidateBeforeCall(endpointName, action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, _callback);
        Type localVarReturnType = new TypeToken<EndpointAccess>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for gETDeleteEventSubscription
     * @param subscriptionName The name of the Amazon Redshift event notification subscription to be deleted. (required)
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> SubscriptionNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> InvalidSubscriptionStateFault </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call gETDeleteEventSubscriptionCall(String subscriptionName, String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/#Action=DeleteEventSubscription";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (subscriptionName != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("SubscriptionName", subscriptionName));
        }

        if (action != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("Action", action));
        }

        if (version != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("Version", version));
        }

        if (xAmzContentSha256 != null) {
            localVarHeaderParams.put("X-Amz-Content-Sha256", localVarApiClient.parameterToString(xAmzContentSha256));
        }

        if (xAmzDate != null) {
            localVarHeaderParams.put("X-Amz-Date", localVarApiClient.parameterToString(xAmzDate));
        }

        if (xAmzAlgorithm != null) {
            localVarHeaderParams.put("X-Amz-Algorithm", localVarApiClient.parameterToString(xAmzAlgorithm));
        }

        if (xAmzCredential != null) {
            localVarHeaderParams.put("X-Amz-Credential", localVarApiClient.parameterToString(xAmzCredential));
        }

        if (xAmzSecurityToken != null) {
            localVarHeaderParams.put("X-Amz-Security-Token", localVarApiClient.parameterToString(xAmzSecurityToken));
        }

        if (xAmzSignature != null) {
            localVarHeaderParams.put("X-Amz-Signature", localVarApiClient.parameterToString(xAmzSignature));
        }

        if (xAmzSignedHeaders != null) {
            localVarHeaderParams.put("X-Amz-SignedHeaders", localVarApiClient.parameterToString(xAmzSignedHeaders));
        }

        final String[] localVarAccepts = {
            "text/xml"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "hmac" };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call gETDeleteEventSubscriptionValidateBeforeCall(String subscriptionName, String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'subscriptionName' is set
        if (subscriptionName == null) {
            throw new ApiException("Missing the required parameter 'subscriptionName' when calling gETDeleteEventSubscription(Async)");
        }

        // verify the required parameter 'action' is set
        if (action == null) {
            throw new ApiException("Missing the required parameter 'action' when calling gETDeleteEventSubscription(Async)");
        }

        // verify the required parameter 'version' is set
        if (version == null) {
            throw new ApiException("Missing the required parameter 'version' when calling gETDeleteEventSubscription(Async)");
        }

        return gETDeleteEventSubscriptionCall(subscriptionName, action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, _callback);

    }

    /**
     * 
     * Deletes an Amazon Redshift event notification subscription.
     * @param subscriptionName The name of the Amazon Redshift event notification subscription to be deleted. (required)
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> SubscriptionNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> InvalidSubscriptionStateFault </td><td>  -  </td></tr>
     </table>
     */
    public void gETDeleteEventSubscription(String subscriptionName, String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders) throws ApiException {
        gETDeleteEventSubscriptionWithHttpInfo(subscriptionName, action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders);
    }

    /**
     * 
     * Deletes an Amazon Redshift event notification subscription.
     * @param subscriptionName The name of the Amazon Redshift event notification subscription to be deleted. (required)
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @return ApiResponse&lt;Void&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> SubscriptionNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> InvalidSubscriptionStateFault </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<Void> gETDeleteEventSubscriptionWithHttpInfo(String subscriptionName, String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders) throws ApiException {
        okhttp3.Call localVarCall = gETDeleteEventSubscriptionValidateBeforeCall(subscriptionName, action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, null);
        return localVarApiClient.execute(localVarCall);
    }

    /**
     *  (asynchronously)
     * Deletes an Amazon Redshift event notification subscription.
     * @param subscriptionName The name of the Amazon Redshift event notification subscription to be deleted. (required)
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> SubscriptionNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> InvalidSubscriptionStateFault </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call gETDeleteEventSubscriptionAsync(String subscriptionName, String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, final ApiCallback<Void> _callback) throws ApiException {

        okhttp3.Call localVarCall = gETDeleteEventSubscriptionValidateBeforeCall(subscriptionName, action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, _callback);
        localVarApiClient.executeAsync(localVarCall, _callback);
        return localVarCall;
    }
    /**
     * Build call for gETDeleteHsmClientCertificate
     * @param hsmClientCertificateIdentifier The identifier of the HSM client certificate to be deleted. (required)
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> InvalidHsmClientCertificateStateFault </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> HsmClientCertificateNotFoundFault </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call gETDeleteHsmClientCertificateCall(String hsmClientCertificateIdentifier, String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/#Action=DeleteHsmClientCertificate";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (hsmClientCertificateIdentifier != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("HsmClientCertificateIdentifier", hsmClientCertificateIdentifier));
        }

        if (action != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("Action", action));
        }

        if (version != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("Version", version));
        }

        if (xAmzContentSha256 != null) {
            localVarHeaderParams.put("X-Amz-Content-Sha256", localVarApiClient.parameterToString(xAmzContentSha256));
        }

        if (xAmzDate != null) {
            localVarHeaderParams.put("X-Amz-Date", localVarApiClient.parameterToString(xAmzDate));
        }

        if (xAmzAlgorithm != null) {
            localVarHeaderParams.put("X-Amz-Algorithm", localVarApiClient.parameterToString(xAmzAlgorithm));
        }

        if (xAmzCredential != null) {
            localVarHeaderParams.put("X-Amz-Credential", localVarApiClient.parameterToString(xAmzCredential));
        }

        if (xAmzSecurityToken != null) {
            localVarHeaderParams.put("X-Amz-Security-Token", localVarApiClient.parameterToString(xAmzSecurityToken));
        }

        if (xAmzSignature != null) {
            localVarHeaderParams.put("X-Amz-Signature", localVarApiClient.parameterToString(xAmzSignature));
        }

        if (xAmzSignedHeaders != null) {
            localVarHeaderParams.put("X-Amz-SignedHeaders", localVarApiClient.parameterToString(xAmzSignedHeaders));
        }

        final String[] localVarAccepts = {
            "text/xml"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "hmac" };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call gETDeleteHsmClientCertificateValidateBeforeCall(String hsmClientCertificateIdentifier, String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'hsmClientCertificateIdentifier' is set
        if (hsmClientCertificateIdentifier == null) {
            throw new ApiException("Missing the required parameter 'hsmClientCertificateIdentifier' when calling gETDeleteHsmClientCertificate(Async)");
        }

        // verify the required parameter 'action' is set
        if (action == null) {
            throw new ApiException("Missing the required parameter 'action' when calling gETDeleteHsmClientCertificate(Async)");
        }

        // verify the required parameter 'version' is set
        if (version == null) {
            throw new ApiException("Missing the required parameter 'version' when calling gETDeleteHsmClientCertificate(Async)");
        }

        return gETDeleteHsmClientCertificateCall(hsmClientCertificateIdentifier, action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, _callback);

    }

    /**
     * 
     * Deletes the specified HSM client certificate.
     * @param hsmClientCertificateIdentifier The identifier of the HSM client certificate to be deleted. (required)
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> InvalidHsmClientCertificateStateFault </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> HsmClientCertificateNotFoundFault </td><td>  -  </td></tr>
     </table>
     */
    public void gETDeleteHsmClientCertificate(String hsmClientCertificateIdentifier, String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders) throws ApiException {
        gETDeleteHsmClientCertificateWithHttpInfo(hsmClientCertificateIdentifier, action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders);
    }

    /**
     * 
     * Deletes the specified HSM client certificate.
     * @param hsmClientCertificateIdentifier The identifier of the HSM client certificate to be deleted. (required)
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @return ApiResponse&lt;Void&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> InvalidHsmClientCertificateStateFault </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> HsmClientCertificateNotFoundFault </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<Void> gETDeleteHsmClientCertificateWithHttpInfo(String hsmClientCertificateIdentifier, String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders) throws ApiException {
        okhttp3.Call localVarCall = gETDeleteHsmClientCertificateValidateBeforeCall(hsmClientCertificateIdentifier, action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, null);
        return localVarApiClient.execute(localVarCall);
    }

    /**
     *  (asynchronously)
     * Deletes the specified HSM client certificate.
     * @param hsmClientCertificateIdentifier The identifier of the HSM client certificate to be deleted. (required)
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> InvalidHsmClientCertificateStateFault </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> HsmClientCertificateNotFoundFault </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call gETDeleteHsmClientCertificateAsync(String hsmClientCertificateIdentifier, String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, final ApiCallback<Void> _callback) throws ApiException {

        okhttp3.Call localVarCall = gETDeleteHsmClientCertificateValidateBeforeCall(hsmClientCertificateIdentifier, action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, _callback);
        localVarApiClient.executeAsync(localVarCall, _callback);
        return localVarCall;
    }
    /**
     * Build call for gETDeleteHsmConfiguration
     * @param hsmConfigurationIdentifier The identifier of the Amazon Redshift HSM configuration to be deleted. (required)
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> InvalidHsmConfigurationStateFault </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> HsmConfigurationNotFoundFault </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call gETDeleteHsmConfigurationCall(String hsmConfigurationIdentifier, String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/#Action=DeleteHsmConfiguration";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (hsmConfigurationIdentifier != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("HsmConfigurationIdentifier", hsmConfigurationIdentifier));
        }

        if (action != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("Action", action));
        }

        if (version != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("Version", version));
        }

        if (xAmzContentSha256 != null) {
            localVarHeaderParams.put("X-Amz-Content-Sha256", localVarApiClient.parameterToString(xAmzContentSha256));
        }

        if (xAmzDate != null) {
            localVarHeaderParams.put("X-Amz-Date", localVarApiClient.parameterToString(xAmzDate));
        }

        if (xAmzAlgorithm != null) {
            localVarHeaderParams.put("X-Amz-Algorithm", localVarApiClient.parameterToString(xAmzAlgorithm));
        }

        if (xAmzCredential != null) {
            localVarHeaderParams.put("X-Amz-Credential", localVarApiClient.parameterToString(xAmzCredential));
        }

        if (xAmzSecurityToken != null) {
            localVarHeaderParams.put("X-Amz-Security-Token", localVarApiClient.parameterToString(xAmzSecurityToken));
        }

        if (xAmzSignature != null) {
            localVarHeaderParams.put("X-Amz-Signature", localVarApiClient.parameterToString(xAmzSignature));
        }

        if (xAmzSignedHeaders != null) {
            localVarHeaderParams.put("X-Amz-SignedHeaders", localVarApiClient.parameterToString(xAmzSignedHeaders));
        }

        final String[] localVarAccepts = {
            "text/xml"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "hmac" };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call gETDeleteHsmConfigurationValidateBeforeCall(String hsmConfigurationIdentifier, String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'hsmConfigurationIdentifier' is set
        if (hsmConfigurationIdentifier == null) {
            throw new ApiException("Missing the required parameter 'hsmConfigurationIdentifier' when calling gETDeleteHsmConfiguration(Async)");
        }

        // verify the required parameter 'action' is set
        if (action == null) {
            throw new ApiException("Missing the required parameter 'action' when calling gETDeleteHsmConfiguration(Async)");
        }

        // verify the required parameter 'version' is set
        if (version == null) {
            throw new ApiException("Missing the required parameter 'version' when calling gETDeleteHsmConfiguration(Async)");
        }

        return gETDeleteHsmConfigurationCall(hsmConfigurationIdentifier, action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, _callback);

    }

    /**
     * 
     * Deletes the specified Amazon Redshift HSM configuration.
     * @param hsmConfigurationIdentifier The identifier of the Amazon Redshift HSM configuration to be deleted. (required)
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> InvalidHsmConfigurationStateFault </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> HsmConfigurationNotFoundFault </td><td>  -  </td></tr>
     </table>
     */
    public void gETDeleteHsmConfiguration(String hsmConfigurationIdentifier, String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders) throws ApiException {
        gETDeleteHsmConfigurationWithHttpInfo(hsmConfigurationIdentifier, action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders);
    }

    /**
     * 
     * Deletes the specified Amazon Redshift HSM configuration.
     * @param hsmConfigurationIdentifier The identifier of the Amazon Redshift HSM configuration to be deleted. (required)
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @return ApiResponse&lt;Void&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> InvalidHsmConfigurationStateFault </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> HsmConfigurationNotFoundFault </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<Void> gETDeleteHsmConfigurationWithHttpInfo(String hsmConfigurationIdentifier, String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders) throws ApiException {
        okhttp3.Call localVarCall = gETDeleteHsmConfigurationValidateBeforeCall(hsmConfigurationIdentifier, action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, null);
        return localVarApiClient.execute(localVarCall);
    }

    /**
     *  (asynchronously)
     * Deletes the specified Amazon Redshift HSM configuration.
     * @param hsmConfigurationIdentifier The identifier of the Amazon Redshift HSM configuration to be deleted. (required)
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> InvalidHsmConfigurationStateFault </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> HsmConfigurationNotFoundFault </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call gETDeleteHsmConfigurationAsync(String hsmConfigurationIdentifier, String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, final ApiCallback<Void> _callback) throws ApiException {

        okhttp3.Call localVarCall = gETDeleteHsmConfigurationValidateBeforeCall(hsmConfigurationIdentifier, action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, _callback);
        localVarApiClient.executeAsync(localVarCall, _callback);
        return localVarCall;
    }
    /**
     * Build call for gETDeletePartner
     * @param accountId The Amazon Web Services account ID that owns the cluster. (required)
     * @param clusterIdentifier The cluster identifier of the cluster that receives data from the partner. (required)
     * @param databaseName The name of the database that receives data from the partner. (required)
     * @param partnerName The name of the partner that is authorized to send data. (required)
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> PartnerNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> ClusterNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 482 </td><td> UnauthorizedPartnerIntegrationFault </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call gETDeletePartnerCall(String accountId, String clusterIdentifier, String databaseName, String partnerName, String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/#Action=DeletePartner";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (accountId != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("AccountId", accountId));
        }

        if (clusterIdentifier != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("ClusterIdentifier", clusterIdentifier));
        }

        if (databaseName != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("DatabaseName", databaseName));
        }

        if (partnerName != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("PartnerName", partnerName));
        }

        if (action != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("Action", action));
        }

        if (version != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("Version", version));
        }

        if (xAmzContentSha256 != null) {
            localVarHeaderParams.put("X-Amz-Content-Sha256", localVarApiClient.parameterToString(xAmzContentSha256));
        }

        if (xAmzDate != null) {
            localVarHeaderParams.put("X-Amz-Date", localVarApiClient.parameterToString(xAmzDate));
        }

        if (xAmzAlgorithm != null) {
            localVarHeaderParams.put("X-Amz-Algorithm", localVarApiClient.parameterToString(xAmzAlgorithm));
        }

        if (xAmzCredential != null) {
            localVarHeaderParams.put("X-Amz-Credential", localVarApiClient.parameterToString(xAmzCredential));
        }

        if (xAmzSecurityToken != null) {
            localVarHeaderParams.put("X-Amz-Security-Token", localVarApiClient.parameterToString(xAmzSecurityToken));
        }

        if (xAmzSignature != null) {
            localVarHeaderParams.put("X-Amz-Signature", localVarApiClient.parameterToString(xAmzSignature));
        }

        if (xAmzSignedHeaders != null) {
            localVarHeaderParams.put("X-Amz-SignedHeaders", localVarApiClient.parameterToString(xAmzSignedHeaders));
        }

        final String[] localVarAccepts = {
            "text/xml"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "hmac" };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call gETDeletePartnerValidateBeforeCall(String accountId, String clusterIdentifier, String databaseName, String partnerName, String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'accountId' is set
        if (accountId == null) {
            throw new ApiException("Missing the required parameter 'accountId' when calling gETDeletePartner(Async)");
        }

        // verify the required parameter 'clusterIdentifier' is set
        if (clusterIdentifier == null) {
            throw new ApiException("Missing the required parameter 'clusterIdentifier' when calling gETDeletePartner(Async)");
        }

        // verify the required parameter 'databaseName' is set
        if (databaseName == null) {
            throw new ApiException("Missing the required parameter 'databaseName' when calling gETDeletePartner(Async)");
        }

        // verify the required parameter 'partnerName' is set
        if (partnerName == null) {
            throw new ApiException("Missing the required parameter 'partnerName' when calling gETDeletePartner(Async)");
        }

        // verify the required parameter 'action' is set
        if (action == null) {
            throw new ApiException("Missing the required parameter 'action' when calling gETDeletePartner(Async)");
        }

        // verify the required parameter 'version' is set
        if (version == null) {
            throw new ApiException("Missing the required parameter 'version' when calling gETDeletePartner(Async)");
        }

        return gETDeletePartnerCall(accountId, clusterIdentifier, databaseName, partnerName, action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, _callback);

    }

    /**
     * 
     * Deletes a partner integration from a cluster. Data can still flow to the cluster until the integration is deleted at the partner&#39;s website.
     * @param accountId The Amazon Web Services account ID that owns the cluster. (required)
     * @param clusterIdentifier The cluster identifier of the cluster that receives data from the partner. (required)
     * @param databaseName The name of the database that receives data from the partner. (required)
     * @param partnerName The name of the partner that is authorized to send data. (required)
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @return PartnerIntegrationOutputMessage
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> PartnerNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> ClusterNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 482 </td><td> UnauthorizedPartnerIntegrationFault </td><td>  -  </td></tr>
     </table>
     */
    public PartnerIntegrationOutputMessage gETDeletePartner(String accountId, String clusterIdentifier, String databaseName, String partnerName, String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders) throws ApiException {
        ApiResponse<PartnerIntegrationOutputMessage> localVarResp = gETDeletePartnerWithHttpInfo(accountId, clusterIdentifier, databaseName, partnerName, action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders);
        return localVarResp.getData();
    }

    /**
     * 
     * Deletes a partner integration from a cluster. Data can still flow to the cluster until the integration is deleted at the partner&#39;s website.
     * @param accountId The Amazon Web Services account ID that owns the cluster. (required)
     * @param clusterIdentifier The cluster identifier of the cluster that receives data from the partner. (required)
     * @param databaseName The name of the database that receives data from the partner. (required)
     * @param partnerName The name of the partner that is authorized to send data. (required)
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @return ApiResponse&lt;PartnerIntegrationOutputMessage&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> PartnerNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> ClusterNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 482 </td><td> UnauthorizedPartnerIntegrationFault </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<PartnerIntegrationOutputMessage> gETDeletePartnerWithHttpInfo(String accountId, String clusterIdentifier, String databaseName, String partnerName, String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders) throws ApiException {
        okhttp3.Call localVarCall = gETDeletePartnerValidateBeforeCall(accountId, clusterIdentifier, databaseName, partnerName, action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, null);
        Type localVarReturnType = new TypeToken<PartnerIntegrationOutputMessage>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     *  (asynchronously)
     * Deletes a partner integration from a cluster. Data can still flow to the cluster until the integration is deleted at the partner&#39;s website.
     * @param accountId The Amazon Web Services account ID that owns the cluster. (required)
     * @param clusterIdentifier The cluster identifier of the cluster that receives data from the partner. (required)
     * @param databaseName The name of the database that receives data from the partner. (required)
     * @param partnerName The name of the partner that is authorized to send data. (required)
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> PartnerNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> ClusterNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 482 </td><td> UnauthorizedPartnerIntegrationFault </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call gETDeletePartnerAsync(String accountId, String clusterIdentifier, String databaseName, String partnerName, String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, final ApiCallback<PartnerIntegrationOutputMessage> _callback) throws ApiException {

        okhttp3.Call localVarCall = gETDeletePartnerValidateBeforeCall(accountId, clusterIdentifier, databaseName, partnerName, action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, _callback);
        Type localVarReturnType = new TypeToken<PartnerIntegrationOutputMessage>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for gETDeleteScheduledAction
     * @param scheduledActionName The name of the scheduled action to delete.  (required)
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> ScheduledActionNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> UnauthorizedOperation </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call gETDeleteScheduledActionCall(String scheduledActionName, String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/#Action=DeleteScheduledAction";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (scheduledActionName != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("ScheduledActionName", scheduledActionName));
        }

        if (action != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("Action", action));
        }

        if (version != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("Version", version));
        }

        if (xAmzContentSha256 != null) {
            localVarHeaderParams.put("X-Amz-Content-Sha256", localVarApiClient.parameterToString(xAmzContentSha256));
        }

        if (xAmzDate != null) {
            localVarHeaderParams.put("X-Amz-Date", localVarApiClient.parameterToString(xAmzDate));
        }

        if (xAmzAlgorithm != null) {
            localVarHeaderParams.put("X-Amz-Algorithm", localVarApiClient.parameterToString(xAmzAlgorithm));
        }

        if (xAmzCredential != null) {
            localVarHeaderParams.put("X-Amz-Credential", localVarApiClient.parameterToString(xAmzCredential));
        }

        if (xAmzSecurityToken != null) {
            localVarHeaderParams.put("X-Amz-Security-Token", localVarApiClient.parameterToString(xAmzSecurityToken));
        }

        if (xAmzSignature != null) {
            localVarHeaderParams.put("X-Amz-Signature", localVarApiClient.parameterToString(xAmzSignature));
        }

        if (xAmzSignedHeaders != null) {
            localVarHeaderParams.put("X-Amz-SignedHeaders", localVarApiClient.parameterToString(xAmzSignedHeaders));
        }

        final String[] localVarAccepts = {
            "text/xml"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "hmac" };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call gETDeleteScheduledActionValidateBeforeCall(String scheduledActionName, String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'scheduledActionName' is set
        if (scheduledActionName == null) {
            throw new ApiException("Missing the required parameter 'scheduledActionName' when calling gETDeleteScheduledAction(Async)");
        }

        // verify the required parameter 'action' is set
        if (action == null) {
            throw new ApiException("Missing the required parameter 'action' when calling gETDeleteScheduledAction(Async)");
        }

        // verify the required parameter 'version' is set
        if (version == null) {
            throw new ApiException("Missing the required parameter 'version' when calling gETDeleteScheduledAction(Async)");
        }

        return gETDeleteScheduledActionCall(scheduledActionName, action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, _callback);

    }

    /**
     * 
     * Deletes a scheduled action. 
     * @param scheduledActionName The name of the scheduled action to delete.  (required)
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> ScheduledActionNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> UnauthorizedOperation </td><td>  -  </td></tr>
     </table>
     */
    public void gETDeleteScheduledAction(String scheduledActionName, String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders) throws ApiException {
        gETDeleteScheduledActionWithHttpInfo(scheduledActionName, action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders);
    }

    /**
     * 
     * Deletes a scheduled action. 
     * @param scheduledActionName The name of the scheduled action to delete.  (required)
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @return ApiResponse&lt;Void&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> ScheduledActionNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> UnauthorizedOperation </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<Void> gETDeleteScheduledActionWithHttpInfo(String scheduledActionName, String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders) throws ApiException {
        okhttp3.Call localVarCall = gETDeleteScheduledActionValidateBeforeCall(scheduledActionName, action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, null);
        return localVarApiClient.execute(localVarCall);
    }

    /**
     *  (asynchronously)
     * Deletes a scheduled action. 
     * @param scheduledActionName The name of the scheduled action to delete.  (required)
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> ScheduledActionNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> UnauthorizedOperation </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call gETDeleteScheduledActionAsync(String scheduledActionName, String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, final ApiCallback<Void> _callback) throws ApiException {

        okhttp3.Call localVarCall = gETDeleteScheduledActionValidateBeforeCall(scheduledActionName, action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, _callback);
        localVarApiClient.executeAsync(localVarCall, _callback);
        return localVarCall;
    }
    /**
     * Build call for gETDeleteSnapshotCopyGrant
     * @param snapshotCopyGrantName The name of the snapshot copy grant to delete. (required)
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> InvalidSnapshotCopyGrantStateFault </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> SnapshotCopyGrantNotFoundFault </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call gETDeleteSnapshotCopyGrantCall(String snapshotCopyGrantName, String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/#Action=DeleteSnapshotCopyGrant";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (snapshotCopyGrantName != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("SnapshotCopyGrantName", snapshotCopyGrantName));
        }

        if (action != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("Action", action));
        }

        if (version != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("Version", version));
        }

        if (xAmzContentSha256 != null) {
            localVarHeaderParams.put("X-Amz-Content-Sha256", localVarApiClient.parameterToString(xAmzContentSha256));
        }

        if (xAmzDate != null) {
            localVarHeaderParams.put("X-Amz-Date", localVarApiClient.parameterToString(xAmzDate));
        }

        if (xAmzAlgorithm != null) {
            localVarHeaderParams.put("X-Amz-Algorithm", localVarApiClient.parameterToString(xAmzAlgorithm));
        }

        if (xAmzCredential != null) {
            localVarHeaderParams.put("X-Amz-Credential", localVarApiClient.parameterToString(xAmzCredential));
        }

        if (xAmzSecurityToken != null) {
            localVarHeaderParams.put("X-Amz-Security-Token", localVarApiClient.parameterToString(xAmzSecurityToken));
        }

        if (xAmzSignature != null) {
            localVarHeaderParams.put("X-Amz-Signature", localVarApiClient.parameterToString(xAmzSignature));
        }

        if (xAmzSignedHeaders != null) {
            localVarHeaderParams.put("X-Amz-SignedHeaders", localVarApiClient.parameterToString(xAmzSignedHeaders));
        }

        final String[] localVarAccepts = {
            "text/xml"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "hmac" };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call gETDeleteSnapshotCopyGrantValidateBeforeCall(String snapshotCopyGrantName, String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'snapshotCopyGrantName' is set
        if (snapshotCopyGrantName == null) {
            throw new ApiException("Missing the required parameter 'snapshotCopyGrantName' when calling gETDeleteSnapshotCopyGrant(Async)");
        }

        // verify the required parameter 'action' is set
        if (action == null) {
            throw new ApiException("Missing the required parameter 'action' when calling gETDeleteSnapshotCopyGrant(Async)");
        }

        // verify the required parameter 'version' is set
        if (version == null) {
            throw new ApiException("Missing the required parameter 'version' when calling gETDeleteSnapshotCopyGrant(Async)");
        }

        return gETDeleteSnapshotCopyGrantCall(snapshotCopyGrantName, action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, _callback);

    }

    /**
     * 
     * Deletes the specified snapshot copy grant.
     * @param snapshotCopyGrantName The name of the snapshot copy grant to delete. (required)
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> InvalidSnapshotCopyGrantStateFault </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> SnapshotCopyGrantNotFoundFault </td><td>  -  </td></tr>
     </table>
     */
    public void gETDeleteSnapshotCopyGrant(String snapshotCopyGrantName, String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders) throws ApiException {
        gETDeleteSnapshotCopyGrantWithHttpInfo(snapshotCopyGrantName, action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders);
    }

    /**
     * 
     * Deletes the specified snapshot copy grant.
     * @param snapshotCopyGrantName The name of the snapshot copy grant to delete. (required)
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @return ApiResponse&lt;Void&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> InvalidSnapshotCopyGrantStateFault </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> SnapshotCopyGrantNotFoundFault </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<Void> gETDeleteSnapshotCopyGrantWithHttpInfo(String snapshotCopyGrantName, String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders) throws ApiException {
        okhttp3.Call localVarCall = gETDeleteSnapshotCopyGrantValidateBeforeCall(snapshotCopyGrantName, action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, null);
        return localVarApiClient.execute(localVarCall);
    }

    /**
     *  (asynchronously)
     * Deletes the specified snapshot copy grant.
     * @param snapshotCopyGrantName The name of the snapshot copy grant to delete. (required)
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> InvalidSnapshotCopyGrantStateFault </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> SnapshotCopyGrantNotFoundFault </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call gETDeleteSnapshotCopyGrantAsync(String snapshotCopyGrantName, String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, final ApiCallback<Void> _callback) throws ApiException {

        okhttp3.Call localVarCall = gETDeleteSnapshotCopyGrantValidateBeforeCall(snapshotCopyGrantName, action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, _callback);
        localVarApiClient.executeAsync(localVarCall, _callback);
        return localVarCall;
    }
    /**
     * Build call for gETDeleteSnapshotSchedule
     * @param scheduleIdentifier A unique identifier of the snapshot schedule to delete. (required)
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> InvalidClusterSnapshotScheduleStateFault </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> SnapshotScheduleNotFoundFault </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call gETDeleteSnapshotScheduleCall(String scheduleIdentifier, String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/#Action=DeleteSnapshotSchedule";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (scheduleIdentifier != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("ScheduleIdentifier", scheduleIdentifier));
        }

        if (action != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("Action", action));
        }

        if (version != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("Version", version));
        }

        if (xAmzContentSha256 != null) {
            localVarHeaderParams.put("X-Amz-Content-Sha256", localVarApiClient.parameterToString(xAmzContentSha256));
        }

        if (xAmzDate != null) {
            localVarHeaderParams.put("X-Amz-Date", localVarApiClient.parameterToString(xAmzDate));
        }

        if (xAmzAlgorithm != null) {
            localVarHeaderParams.put("X-Amz-Algorithm", localVarApiClient.parameterToString(xAmzAlgorithm));
        }

        if (xAmzCredential != null) {
            localVarHeaderParams.put("X-Amz-Credential", localVarApiClient.parameterToString(xAmzCredential));
        }

        if (xAmzSecurityToken != null) {
            localVarHeaderParams.put("X-Amz-Security-Token", localVarApiClient.parameterToString(xAmzSecurityToken));
        }

        if (xAmzSignature != null) {
            localVarHeaderParams.put("X-Amz-Signature", localVarApiClient.parameterToString(xAmzSignature));
        }

        if (xAmzSignedHeaders != null) {
            localVarHeaderParams.put("X-Amz-SignedHeaders", localVarApiClient.parameterToString(xAmzSignedHeaders));
        }

        final String[] localVarAccepts = {
            "text/xml"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "hmac" };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call gETDeleteSnapshotScheduleValidateBeforeCall(String scheduleIdentifier, String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'scheduleIdentifier' is set
        if (scheduleIdentifier == null) {
            throw new ApiException("Missing the required parameter 'scheduleIdentifier' when calling gETDeleteSnapshotSchedule(Async)");
        }

        // verify the required parameter 'action' is set
        if (action == null) {
            throw new ApiException("Missing the required parameter 'action' when calling gETDeleteSnapshotSchedule(Async)");
        }

        // verify the required parameter 'version' is set
        if (version == null) {
            throw new ApiException("Missing the required parameter 'version' when calling gETDeleteSnapshotSchedule(Async)");
        }

        return gETDeleteSnapshotScheduleCall(scheduleIdentifier, action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, _callback);

    }

    /**
     * 
     * Deletes a snapshot schedule.
     * @param scheduleIdentifier A unique identifier of the snapshot schedule to delete. (required)
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> InvalidClusterSnapshotScheduleStateFault </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> SnapshotScheduleNotFoundFault </td><td>  -  </td></tr>
     </table>
     */
    public void gETDeleteSnapshotSchedule(String scheduleIdentifier, String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders) throws ApiException {
        gETDeleteSnapshotScheduleWithHttpInfo(scheduleIdentifier, action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders);
    }

    /**
     * 
     * Deletes a snapshot schedule.
     * @param scheduleIdentifier A unique identifier of the snapshot schedule to delete. (required)
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @return ApiResponse&lt;Void&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> InvalidClusterSnapshotScheduleStateFault </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> SnapshotScheduleNotFoundFault </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<Void> gETDeleteSnapshotScheduleWithHttpInfo(String scheduleIdentifier, String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders) throws ApiException {
        okhttp3.Call localVarCall = gETDeleteSnapshotScheduleValidateBeforeCall(scheduleIdentifier, action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, null);
        return localVarApiClient.execute(localVarCall);
    }

    /**
     *  (asynchronously)
     * Deletes a snapshot schedule.
     * @param scheduleIdentifier A unique identifier of the snapshot schedule to delete. (required)
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> InvalidClusterSnapshotScheduleStateFault </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> SnapshotScheduleNotFoundFault </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call gETDeleteSnapshotScheduleAsync(String scheduleIdentifier, String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, final ApiCallback<Void> _callback) throws ApiException {

        okhttp3.Call localVarCall = gETDeleteSnapshotScheduleValidateBeforeCall(scheduleIdentifier, action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, _callback);
        localVarApiClient.executeAsync(localVarCall, _callback);
        return localVarCall;
    }
    /**
     * Build call for gETDeleteTags
     * @param resourceName The Amazon Resource Name (ARN) from which you want to remove the tag or tags. For example, &lt;code&gt;arn:aws:redshift:us-east-2:123456789:cluster:t1&lt;/code&gt;.  (required)
     * @param tagKeys The tag key that you want to delete. (required)
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> ResourceNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> InvalidTagFault </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call gETDeleteTagsCall(String resourceName, List<String> tagKeys, String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/#Action=DeleteTags";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (resourceName != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("ResourceName", resourceName));
        }

        if (tagKeys != null) {
            localVarCollectionQueryParams.addAll(localVarApiClient.parameterToPairs("multi", "TagKeys", tagKeys));
        }

        if (action != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("Action", action));
        }

        if (version != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("Version", version));
        }

        if (xAmzContentSha256 != null) {
            localVarHeaderParams.put("X-Amz-Content-Sha256", localVarApiClient.parameterToString(xAmzContentSha256));
        }

        if (xAmzDate != null) {
            localVarHeaderParams.put("X-Amz-Date", localVarApiClient.parameterToString(xAmzDate));
        }

        if (xAmzAlgorithm != null) {
            localVarHeaderParams.put("X-Amz-Algorithm", localVarApiClient.parameterToString(xAmzAlgorithm));
        }

        if (xAmzCredential != null) {
            localVarHeaderParams.put("X-Amz-Credential", localVarApiClient.parameterToString(xAmzCredential));
        }

        if (xAmzSecurityToken != null) {
            localVarHeaderParams.put("X-Amz-Security-Token", localVarApiClient.parameterToString(xAmzSecurityToken));
        }

        if (xAmzSignature != null) {
            localVarHeaderParams.put("X-Amz-Signature", localVarApiClient.parameterToString(xAmzSignature));
        }

        if (xAmzSignedHeaders != null) {
            localVarHeaderParams.put("X-Amz-SignedHeaders", localVarApiClient.parameterToString(xAmzSignedHeaders));
        }

        final String[] localVarAccepts = {
            "text/xml"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "hmac" };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call gETDeleteTagsValidateBeforeCall(String resourceName, List<String> tagKeys, String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'resourceName' is set
        if (resourceName == null) {
            throw new ApiException("Missing the required parameter 'resourceName' when calling gETDeleteTags(Async)");
        }

        // verify the required parameter 'tagKeys' is set
        if (tagKeys == null) {
            throw new ApiException("Missing the required parameter 'tagKeys' when calling gETDeleteTags(Async)");
        }

        // verify the required parameter 'action' is set
        if (action == null) {
            throw new ApiException("Missing the required parameter 'action' when calling gETDeleteTags(Async)");
        }

        // verify the required parameter 'version' is set
        if (version == null) {
            throw new ApiException("Missing the required parameter 'version' when calling gETDeleteTags(Async)");
        }

        return gETDeleteTagsCall(resourceName, tagKeys, action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, _callback);

    }

    /**
     * 
     * Deletes tags from a resource. You must provide the ARN of the resource from which you want to delete the tag or tags.
     * @param resourceName The Amazon Resource Name (ARN) from which you want to remove the tag or tags. For example, &lt;code&gt;arn:aws:redshift:us-east-2:123456789:cluster:t1&lt;/code&gt;.  (required)
     * @param tagKeys The tag key that you want to delete. (required)
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> ResourceNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> InvalidTagFault </td><td>  -  </td></tr>
     </table>
     */
    public void gETDeleteTags(String resourceName, List<String> tagKeys, String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders) throws ApiException {
        gETDeleteTagsWithHttpInfo(resourceName, tagKeys, action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders);
    }

    /**
     * 
     * Deletes tags from a resource. You must provide the ARN of the resource from which you want to delete the tag or tags.
     * @param resourceName The Amazon Resource Name (ARN) from which you want to remove the tag or tags. For example, &lt;code&gt;arn:aws:redshift:us-east-2:123456789:cluster:t1&lt;/code&gt;.  (required)
     * @param tagKeys The tag key that you want to delete. (required)
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @return ApiResponse&lt;Void&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> ResourceNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> InvalidTagFault </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<Void> gETDeleteTagsWithHttpInfo(String resourceName, List<String> tagKeys, String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders) throws ApiException {
        okhttp3.Call localVarCall = gETDeleteTagsValidateBeforeCall(resourceName, tagKeys, action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, null);
        return localVarApiClient.execute(localVarCall);
    }

    /**
     *  (asynchronously)
     * Deletes tags from a resource. You must provide the ARN of the resource from which you want to delete the tag or tags.
     * @param resourceName The Amazon Resource Name (ARN) from which you want to remove the tag or tags. For example, &lt;code&gt;arn:aws:redshift:us-east-2:123456789:cluster:t1&lt;/code&gt;.  (required)
     * @param tagKeys The tag key that you want to delete. (required)
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> ResourceNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> InvalidTagFault </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call gETDeleteTagsAsync(String resourceName, List<String> tagKeys, String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, final ApiCallback<Void> _callback) throws ApiException {

        okhttp3.Call localVarCall = gETDeleteTagsValidateBeforeCall(resourceName, tagKeys, action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, _callback);
        localVarApiClient.executeAsync(localVarCall, _callback);
        return localVarCall;
    }
    /**
     * Build call for gETDeleteUsageLimit
     * @param usageLimitId The identifier of the usage limit to delete. (required)
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> UsageLimitNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> UnsupportedOperationFault </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call gETDeleteUsageLimitCall(String usageLimitId, String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/#Action=DeleteUsageLimit";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (usageLimitId != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("UsageLimitId", usageLimitId));
        }

        if (action != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("Action", action));
        }

        if (version != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("Version", version));
        }

        if (xAmzContentSha256 != null) {
            localVarHeaderParams.put("X-Amz-Content-Sha256", localVarApiClient.parameterToString(xAmzContentSha256));
        }

        if (xAmzDate != null) {
            localVarHeaderParams.put("X-Amz-Date", localVarApiClient.parameterToString(xAmzDate));
        }

        if (xAmzAlgorithm != null) {
            localVarHeaderParams.put("X-Amz-Algorithm", localVarApiClient.parameterToString(xAmzAlgorithm));
        }

        if (xAmzCredential != null) {
            localVarHeaderParams.put("X-Amz-Credential", localVarApiClient.parameterToString(xAmzCredential));
        }

        if (xAmzSecurityToken != null) {
            localVarHeaderParams.put("X-Amz-Security-Token", localVarApiClient.parameterToString(xAmzSecurityToken));
        }

        if (xAmzSignature != null) {
            localVarHeaderParams.put("X-Amz-Signature", localVarApiClient.parameterToString(xAmzSignature));
        }

        if (xAmzSignedHeaders != null) {
            localVarHeaderParams.put("X-Amz-SignedHeaders", localVarApiClient.parameterToString(xAmzSignedHeaders));
        }

        final String[] localVarAccepts = {
            "text/xml"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "hmac" };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call gETDeleteUsageLimitValidateBeforeCall(String usageLimitId, String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'usageLimitId' is set
        if (usageLimitId == null) {
            throw new ApiException("Missing the required parameter 'usageLimitId' when calling gETDeleteUsageLimit(Async)");
        }

        // verify the required parameter 'action' is set
        if (action == null) {
            throw new ApiException("Missing the required parameter 'action' when calling gETDeleteUsageLimit(Async)");
        }

        // verify the required parameter 'version' is set
        if (version == null) {
            throw new ApiException("Missing the required parameter 'version' when calling gETDeleteUsageLimit(Async)");
        }

        return gETDeleteUsageLimitCall(usageLimitId, action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, _callback);

    }

    /**
     * 
     * Deletes a usage limit from a cluster.
     * @param usageLimitId The identifier of the usage limit to delete. (required)
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> UsageLimitNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> UnsupportedOperationFault </td><td>  -  </td></tr>
     </table>
     */
    public void gETDeleteUsageLimit(String usageLimitId, String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders) throws ApiException {
        gETDeleteUsageLimitWithHttpInfo(usageLimitId, action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders);
    }

    /**
     * 
     * Deletes a usage limit from a cluster.
     * @param usageLimitId The identifier of the usage limit to delete. (required)
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @return ApiResponse&lt;Void&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> UsageLimitNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> UnsupportedOperationFault </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<Void> gETDeleteUsageLimitWithHttpInfo(String usageLimitId, String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders) throws ApiException {
        okhttp3.Call localVarCall = gETDeleteUsageLimitValidateBeforeCall(usageLimitId, action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, null);
        return localVarApiClient.execute(localVarCall);
    }

    /**
     *  (asynchronously)
     * Deletes a usage limit from a cluster.
     * @param usageLimitId The identifier of the usage limit to delete. (required)
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> UsageLimitNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> UnsupportedOperationFault </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call gETDeleteUsageLimitAsync(String usageLimitId, String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, final ApiCallback<Void> _callback) throws ApiException {

        okhttp3.Call localVarCall = gETDeleteUsageLimitValidateBeforeCall(usageLimitId, action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, _callback);
        localVarApiClient.executeAsync(localVarCall, _callback);
        return localVarCall;
    }
    /**
     * Build call for gETDescribeAccountAttributes
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param attributeNames A list of attribute names. (optional)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call gETDescribeAccountAttributesCall(String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, List<String> attributeNames, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/#Action=DescribeAccountAttributes";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (attributeNames != null) {
            localVarCollectionQueryParams.addAll(localVarApiClient.parameterToPairs("multi", "AttributeNames", attributeNames));
        }

        if (action != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("Action", action));
        }

        if (version != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("Version", version));
        }

        if (xAmzContentSha256 != null) {
            localVarHeaderParams.put("X-Amz-Content-Sha256", localVarApiClient.parameterToString(xAmzContentSha256));
        }

        if (xAmzDate != null) {
            localVarHeaderParams.put("X-Amz-Date", localVarApiClient.parameterToString(xAmzDate));
        }

        if (xAmzAlgorithm != null) {
            localVarHeaderParams.put("X-Amz-Algorithm", localVarApiClient.parameterToString(xAmzAlgorithm));
        }

        if (xAmzCredential != null) {
            localVarHeaderParams.put("X-Amz-Credential", localVarApiClient.parameterToString(xAmzCredential));
        }

        if (xAmzSecurityToken != null) {
            localVarHeaderParams.put("X-Amz-Security-Token", localVarApiClient.parameterToString(xAmzSecurityToken));
        }

        if (xAmzSignature != null) {
            localVarHeaderParams.put("X-Amz-Signature", localVarApiClient.parameterToString(xAmzSignature));
        }

        if (xAmzSignedHeaders != null) {
            localVarHeaderParams.put("X-Amz-SignedHeaders", localVarApiClient.parameterToString(xAmzSignedHeaders));
        }

        final String[] localVarAccepts = {
            "text/xml"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "hmac" };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call gETDescribeAccountAttributesValidateBeforeCall(String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, List<String> attributeNames, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'action' is set
        if (action == null) {
            throw new ApiException("Missing the required parameter 'action' when calling gETDescribeAccountAttributes(Async)");
        }

        // verify the required parameter 'version' is set
        if (version == null) {
            throw new ApiException("Missing the required parameter 'version' when calling gETDescribeAccountAttributes(Async)");
        }

        return gETDescribeAccountAttributesCall(action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, attributeNames, _callback);

    }

    /**
     * 
     * Returns a list of attributes attached to an account
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param attributeNames A list of attribute names. (optional)
     * @return AccountAttributeList
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
     </table>
     */
    public AccountAttributeList gETDescribeAccountAttributes(String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, List<String> attributeNames) throws ApiException {
        ApiResponse<AccountAttributeList> localVarResp = gETDescribeAccountAttributesWithHttpInfo(action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, attributeNames);
        return localVarResp.getData();
    }

    /**
     * 
     * Returns a list of attributes attached to an account
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param attributeNames A list of attribute names. (optional)
     * @return ApiResponse&lt;AccountAttributeList&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<AccountAttributeList> gETDescribeAccountAttributesWithHttpInfo(String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, List<String> attributeNames) throws ApiException {
        okhttp3.Call localVarCall = gETDescribeAccountAttributesValidateBeforeCall(action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, attributeNames, null);
        Type localVarReturnType = new TypeToken<AccountAttributeList>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     *  (asynchronously)
     * Returns a list of attributes attached to an account
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param attributeNames A list of attribute names. (optional)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call gETDescribeAccountAttributesAsync(String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, List<String> attributeNames, final ApiCallback<AccountAttributeList> _callback) throws ApiException {

        okhttp3.Call localVarCall = gETDescribeAccountAttributesValidateBeforeCall(action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, attributeNames, _callback);
        Type localVarReturnType = new TypeToken<AccountAttributeList>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for gETDescribeAuthenticationProfiles
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param authenticationProfileName The name of the authentication profile to describe. If not specified then all authentication profiles owned by the account are listed. (optional)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> AuthenticationProfileNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> InvalidAuthenticationProfileRequestFault </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call gETDescribeAuthenticationProfilesCall(String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, String authenticationProfileName, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/#Action=DescribeAuthenticationProfiles";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (authenticationProfileName != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("AuthenticationProfileName", authenticationProfileName));
        }

        if (action != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("Action", action));
        }

        if (version != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("Version", version));
        }

        if (xAmzContentSha256 != null) {
            localVarHeaderParams.put("X-Amz-Content-Sha256", localVarApiClient.parameterToString(xAmzContentSha256));
        }

        if (xAmzDate != null) {
            localVarHeaderParams.put("X-Amz-Date", localVarApiClient.parameterToString(xAmzDate));
        }

        if (xAmzAlgorithm != null) {
            localVarHeaderParams.put("X-Amz-Algorithm", localVarApiClient.parameterToString(xAmzAlgorithm));
        }

        if (xAmzCredential != null) {
            localVarHeaderParams.put("X-Amz-Credential", localVarApiClient.parameterToString(xAmzCredential));
        }

        if (xAmzSecurityToken != null) {
            localVarHeaderParams.put("X-Amz-Security-Token", localVarApiClient.parameterToString(xAmzSecurityToken));
        }

        if (xAmzSignature != null) {
            localVarHeaderParams.put("X-Amz-Signature", localVarApiClient.parameterToString(xAmzSignature));
        }

        if (xAmzSignedHeaders != null) {
            localVarHeaderParams.put("X-Amz-SignedHeaders", localVarApiClient.parameterToString(xAmzSignedHeaders));
        }

        final String[] localVarAccepts = {
            "text/xml"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "hmac" };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call gETDescribeAuthenticationProfilesValidateBeforeCall(String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, String authenticationProfileName, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'action' is set
        if (action == null) {
            throw new ApiException("Missing the required parameter 'action' when calling gETDescribeAuthenticationProfiles(Async)");
        }

        // verify the required parameter 'version' is set
        if (version == null) {
            throw new ApiException("Missing the required parameter 'version' when calling gETDescribeAuthenticationProfiles(Async)");
        }

        return gETDescribeAuthenticationProfilesCall(action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, authenticationProfileName, _callback);

    }

    /**
     * 
     * Describes an authentication profile.
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param authenticationProfileName The name of the authentication profile to describe. If not specified then all authentication profiles owned by the account are listed. (optional)
     * @return DescribeAuthenticationProfilesResult
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> AuthenticationProfileNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> InvalidAuthenticationProfileRequestFault </td><td>  -  </td></tr>
     </table>
     */
    public DescribeAuthenticationProfilesResult gETDescribeAuthenticationProfiles(String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, String authenticationProfileName) throws ApiException {
        ApiResponse<DescribeAuthenticationProfilesResult> localVarResp = gETDescribeAuthenticationProfilesWithHttpInfo(action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, authenticationProfileName);
        return localVarResp.getData();
    }

    /**
     * 
     * Describes an authentication profile.
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param authenticationProfileName The name of the authentication profile to describe. If not specified then all authentication profiles owned by the account are listed. (optional)
     * @return ApiResponse&lt;DescribeAuthenticationProfilesResult&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> AuthenticationProfileNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> InvalidAuthenticationProfileRequestFault </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<DescribeAuthenticationProfilesResult> gETDescribeAuthenticationProfilesWithHttpInfo(String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, String authenticationProfileName) throws ApiException {
        okhttp3.Call localVarCall = gETDescribeAuthenticationProfilesValidateBeforeCall(action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, authenticationProfileName, null);
        Type localVarReturnType = new TypeToken<DescribeAuthenticationProfilesResult>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     *  (asynchronously)
     * Describes an authentication profile.
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param authenticationProfileName The name of the authentication profile to describe. If not specified then all authentication profiles owned by the account are listed. (optional)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> AuthenticationProfileNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> InvalidAuthenticationProfileRequestFault </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call gETDescribeAuthenticationProfilesAsync(String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, String authenticationProfileName, final ApiCallback<DescribeAuthenticationProfilesResult> _callback) throws ApiException {

        okhttp3.Call localVarCall = gETDescribeAuthenticationProfilesValidateBeforeCall(action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, authenticationProfileName, _callback);
        Type localVarReturnType = new TypeToken<DescribeAuthenticationProfilesResult>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for gETDescribeClusterDbRevisions
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param clusterIdentifier A unique identifier for a cluster whose &lt;code&gt;ClusterDbRevisions&lt;/code&gt; you are requesting. This parameter is case sensitive. All clusters defined for an account are returned by default. (optional)
     * @param maxRecords &lt;p&gt;The maximum number of response records to return in each call. If the number of remaining response records exceeds the specified MaxRecords value, a value is returned in the &lt;code&gt;marker&lt;/code&gt; field of the response. You can retrieve the next set of response records by providing the returned &lt;code&gt;marker&lt;/code&gt; value in the &lt;code&gt;marker&lt;/code&gt; parameter and retrying the request. &lt;/p&gt; &lt;p&gt;Default: 100&lt;/p&gt; &lt;p&gt;Constraints: minimum 20, maximum 100.&lt;/p&gt; (optional)
     * @param marker &lt;p&gt;An optional parameter that specifies the starting point for returning a set of response records. When the results of a &lt;code&gt;DescribeClusterDbRevisions&lt;/code&gt; request exceed the value specified in &lt;code&gt;MaxRecords&lt;/code&gt;, Amazon Redshift returns a value in the &lt;code&gt;marker&lt;/code&gt; field of the response. You can retrieve the next set of response records by providing the returned &lt;code&gt;marker&lt;/code&gt; value in the &lt;code&gt;marker&lt;/code&gt; parameter and retrying the request. &lt;/p&gt; &lt;p&gt;Constraints: You can specify either the &lt;code&gt;ClusterIdentifier&lt;/code&gt; parameter, or the &lt;code&gt;marker&lt;/code&gt; parameter, but not both.&lt;/p&gt; (optional)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> ClusterNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> InvalidClusterStateFault </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call gETDescribeClusterDbRevisionsCall(String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, String clusterIdentifier, Integer maxRecords, String marker, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/#Action=DescribeClusterDbRevisions";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (clusterIdentifier != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("ClusterIdentifier", clusterIdentifier));
        }

        if (maxRecords != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("MaxRecords", maxRecords));
        }

        if (marker != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("Marker", marker));
        }

        if (action != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("Action", action));
        }

        if (version != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("Version", version));
        }

        if (xAmzContentSha256 != null) {
            localVarHeaderParams.put("X-Amz-Content-Sha256", localVarApiClient.parameterToString(xAmzContentSha256));
        }

        if (xAmzDate != null) {
            localVarHeaderParams.put("X-Amz-Date", localVarApiClient.parameterToString(xAmzDate));
        }

        if (xAmzAlgorithm != null) {
            localVarHeaderParams.put("X-Amz-Algorithm", localVarApiClient.parameterToString(xAmzAlgorithm));
        }

        if (xAmzCredential != null) {
            localVarHeaderParams.put("X-Amz-Credential", localVarApiClient.parameterToString(xAmzCredential));
        }

        if (xAmzSecurityToken != null) {
            localVarHeaderParams.put("X-Amz-Security-Token", localVarApiClient.parameterToString(xAmzSecurityToken));
        }

        if (xAmzSignature != null) {
            localVarHeaderParams.put("X-Amz-Signature", localVarApiClient.parameterToString(xAmzSignature));
        }

        if (xAmzSignedHeaders != null) {
            localVarHeaderParams.put("X-Amz-SignedHeaders", localVarApiClient.parameterToString(xAmzSignedHeaders));
        }

        final String[] localVarAccepts = {
            "text/xml"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "hmac" };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call gETDescribeClusterDbRevisionsValidateBeforeCall(String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, String clusterIdentifier, Integer maxRecords, String marker, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'action' is set
        if (action == null) {
            throw new ApiException("Missing the required parameter 'action' when calling gETDescribeClusterDbRevisions(Async)");
        }

        // verify the required parameter 'version' is set
        if (version == null) {
            throw new ApiException("Missing the required parameter 'version' when calling gETDescribeClusterDbRevisions(Async)");
        }

        return gETDescribeClusterDbRevisionsCall(action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, clusterIdentifier, maxRecords, marker, _callback);

    }

    /**
     * 
     * Returns an array of &lt;code&gt;ClusterDbRevision&lt;/code&gt; objects.
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param clusterIdentifier A unique identifier for a cluster whose &lt;code&gt;ClusterDbRevisions&lt;/code&gt; you are requesting. This parameter is case sensitive. All clusters defined for an account are returned by default. (optional)
     * @param maxRecords &lt;p&gt;The maximum number of response records to return in each call. If the number of remaining response records exceeds the specified MaxRecords value, a value is returned in the &lt;code&gt;marker&lt;/code&gt; field of the response. You can retrieve the next set of response records by providing the returned &lt;code&gt;marker&lt;/code&gt; value in the &lt;code&gt;marker&lt;/code&gt; parameter and retrying the request. &lt;/p&gt; &lt;p&gt;Default: 100&lt;/p&gt; &lt;p&gt;Constraints: minimum 20, maximum 100.&lt;/p&gt; (optional)
     * @param marker &lt;p&gt;An optional parameter that specifies the starting point for returning a set of response records. When the results of a &lt;code&gt;DescribeClusterDbRevisions&lt;/code&gt; request exceed the value specified in &lt;code&gt;MaxRecords&lt;/code&gt;, Amazon Redshift returns a value in the &lt;code&gt;marker&lt;/code&gt; field of the response. You can retrieve the next set of response records by providing the returned &lt;code&gt;marker&lt;/code&gt; value in the &lt;code&gt;marker&lt;/code&gt; parameter and retrying the request. &lt;/p&gt; &lt;p&gt;Constraints: You can specify either the &lt;code&gt;ClusterIdentifier&lt;/code&gt; parameter, or the &lt;code&gt;marker&lt;/code&gt; parameter, but not both.&lt;/p&gt; (optional)
     * @return ClusterDbRevisionsMessage
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> ClusterNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> InvalidClusterStateFault </td><td>  -  </td></tr>
     </table>
     */
    public ClusterDbRevisionsMessage gETDescribeClusterDbRevisions(String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, String clusterIdentifier, Integer maxRecords, String marker) throws ApiException {
        ApiResponse<ClusterDbRevisionsMessage> localVarResp = gETDescribeClusterDbRevisionsWithHttpInfo(action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, clusterIdentifier, maxRecords, marker);
        return localVarResp.getData();
    }

    /**
     * 
     * Returns an array of &lt;code&gt;ClusterDbRevision&lt;/code&gt; objects.
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param clusterIdentifier A unique identifier for a cluster whose &lt;code&gt;ClusterDbRevisions&lt;/code&gt; you are requesting. This parameter is case sensitive. All clusters defined for an account are returned by default. (optional)
     * @param maxRecords &lt;p&gt;The maximum number of response records to return in each call. If the number of remaining response records exceeds the specified MaxRecords value, a value is returned in the &lt;code&gt;marker&lt;/code&gt; field of the response. You can retrieve the next set of response records by providing the returned &lt;code&gt;marker&lt;/code&gt; value in the &lt;code&gt;marker&lt;/code&gt; parameter and retrying the request. &lt;/p&gt; &lt;p&gt;Default: 100&lt;/p&gt; &lt;p&gt;Constraints: minimum 20, maximum 100.&lt;/p&gt; (optional)
     * @param marker &lt;p&gt;An optional parameter that specifies the starting point for returning a set of response records. When the results of a &lt;code&gt;DescribeClusterDbRevisions&lt;/code&gt; request exceed the value specified in &lt;code&gt;MaxRecords&lt;/code&gt;, Amazon Redshift returns a value in the &lt;code&gt;marker&lt;/code&gt; field of the response. You can retrieve the next set of response records by providing the returned &lt;code&gt;marker&lt;/code&gt; value in the &lt;code&gt;marker&lt;/code&gt; parameter and retrying the request. &lt;/p&gt; &lt;p&gt;Constraints: You can specify either the &lt;code&gt;ClusterIdentifier&lt;/code&gt; parameter, or the &lt;code&gt;marker&lt;/code&gt; parameter, but not both.&lt;/p&gt; (optional)
     * @return ApiResponse&lt;ClusterDbRevisionsMessage&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> ClusterNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> InvalidClusterStateFault </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<ClusterDbRevisionsMessage> gETDescribeClusterDbRevisionsWithHttpInfo(String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, String clusterIdentifier, Integer maxRecords, String marker) throws ApiException {
        okhttp3.Call localVarCall = gETDescribeClusterDbRevisionsValidateBeforeCall(action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, clusterIdentifier, maxRecords, marker, null);
        Type localVarReturnType = new TypeToken<ClusterDbRevisionsMessage>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     *  (asynchronously)
     * Returns an array of &lt;code&gt;ClusterDbRevision&lt;/code&gt; objects.
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param clusterIdentifier A unique identifier for a cluster whose &lt;code&gt;ClusterDbRevisions&lt;/code&gt; you are requesting. This parameter is case sensitive. All clusters defined for an account are returned by default. (optional)
     * @param maxRecords &lt;p&gt;The maximum number of response records to return in each call. If the number of remaining response records exceeds the specified MaxRecords value, a value is returned in the &lt;code&gt;marker&lt;/code&gt; field of the response. You can retrieve the next set of response records by providing the returned &lt;code&gt;marker&lt;/code&gt; value in the &lt;code&gt;marker&lt;/code&gt; parameter and retrying the request. &lt;/p&gt; &lt;p&gt;Default: 100&lt;/p&gt; &lt;p&gt;Constraints: minimum 20, maximum 100.&lt;/p&gt; (optional)
     * @param marker &lt;p&gt;An optional parameter that specifies the starting point for returning a set of response records. When the results of a &lt;code&gt;DescribeClusterDbRevisions&lt;/code&gt; request exceed the value specified in &lt;code&gt;MaxRecords&lt;/code&gt;, Amazon Redshift returns a value in the &lt;code&gt;marker&lt;/code&gt; field of the response. You can retrieve the next set of response records by providing the returned &lt;code&gt;marker&lt;/code&gt; value in the &lt;code&gt;marker&lt;/code&gt; parameter and retrying the request. &lt;/p&gt; &lt;p&gt;Constraints: You can specify either the &lt;code&gt;ClusterIdentifier&lt;/code&gt; parameter, or the &lt;code&gt;marker&lt;/code&gt; parameter, but not both.&lt;/p&gt; (optional)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> ClusterNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> InvalidClusterStateFault </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call gETDescribeClusterDbRevisionsAsync(String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, String clusterIdentifier, Integer maxRecords, String marker, final ApiCallback<ClusterDbRevisionsMessage> _callback) throws ApiException {

        okhttp3.Call localVarCall = gETDescribeClusterDbRevisionsValidateBeforeCall(action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, clusterIdentifier, maxRecords, marker, _callback);
        Type localVarReturnType = new TypeToken<ClusterDbRevisionsMessage>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for gETDescribeClusterParameterGroups
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param parameterGroupName The name of a specific parameter group for which to return details. By default, details about all parameter groups and the default parameter group are returned. (optional)
     * @param maxRecords &lt;p&gt;The maximum number of response records to return in each call. If the number of remaining response records exceeds the specified &lt;code&gt;MaxRecords&lt;/code&gt; value, a value is returned in a &lt;code&gt;marker&lt;/code&gt; field of the response. You can retrieve the next set of records by retrying the command with the returned marker value. &lt;/p&gt; &lt;p&gt;Default: &lt;code&gt;100&lt;/code&gt; &lt;/p&gt; &lt;p&gt;Constraints: minimum 20, maximum 100.&lt;/p&gt; (optional)
     * @param marker An optional parameter that specifies the starting point to return a set of response records. When the results of a &lt;a&gt;DescribeClusterParameterGroups&lt;/a&gt; request exceed the value specified in &lt;code&gt;MaxRecords&lt;/code&gt;, Amazon Web Services returns a value in the &lt;code&gt;Marker&lt;/code&gt; field of the response. You can retrieve the next set of response records by providing the returned marker value in the &lt;code&gt;Marker&lt;/code&gt; parameter and retrying the request.  (optional)
     * @param tagKeys A tag key or keys for which you want to return all matching cluster parameter groups that are associated with the specified key or keys. For example, suppose that you have parameter groups that are tagged with keys called &lt;code&gt;owner&lt;/code&gt; and &lt;code&gt;environment&lt;/code&gt;. If you specify both of these tag keys in the request, Amazon Redshift returns a response with the parameter groups that have either or both of these tag keys associated with them. (optional)
     * @param tagValues A tag value or values for which you want to return all matching cluster parameter groups that are associated with the specified tag value or values. For example, suppose that you have parameter groups that are tagged with values called &lt;code&gt;admin&lt;/code&gt; and &lt;code&gt;test&lt;/code&gt;. If you specify both of these tag values in the request, Amazon Redshift returns a response with the parameter groups that have either or both of these tag values associated with them. (optional)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> ClusterParameterGroupNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> InvalidTagFault </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call gETDescribeClusterParameterGroupsCall(String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, String parameterGroupName, Integer maxRecords, String marker, List<String> tagKeys, List<String> tagValues, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/#Action=DescribeClusterParameterGroups";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (parameterGroupName != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("ParameterGroupName", parameterGroupName));
        }

        if (maxRecords != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("MaxRecords", maxRecords));
        }

        if (marker != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("Marker", marker));
        }

        if (tagKeys != null) {
            localVarCollectionQueryParams.addAll(localVarApiClient.parameterToPairs("multi", "TagKeys", tagKeys));
        }

        if (tagValues != null) {
            localVarCollectionQueryParams.addAll(localVarApiClient.parameterToPairs("multi", "TagValues", tagValues));
        }

        if (action != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("Action", action));
        }

        if (version != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("Version", version));
        }

        if (xAmzContentSha256 != null) {
            localVarHeaderParams.put("X-Amz-Content-Sha256", localVarApiClient.parameterToString(xAmzContentSha256));
        }

        if (xAmzDate != null) {
            localVarHeaderParams.put("X-Amz-Date", localVarApiClient.parameterToString(xAmzDate));
        }

        if (xAmzAlgorithm != null) {
            localVarHeaderParams.put("X-Amz-Algorithm", localVarApiClient.parameterToString(xAmzAlgorithm));
        }

        if (xAmzCredential != null) {
            localVarHeaderParams.put("X-Amz-Credential", localVarApiClient.parameterToString(xAmzCredential));
        }

        if (xAmzSecurityToken != null) {
            localVarHeaderParams.put("X-Amz-Security-Token", localVarApiClient.parameterToString(xAmzSecurityToken));
        }

        if (xAmzSignature != null) {
            localVarHeaderParams.put("X-Amz-Signature", localVarApiClient.parameterToString(xAmzSignature));
        }

        if (xAmzSignedHeaders != null) {
            localVarHeaderParams.put("X-Amz-SignedHeaders", localVarApiClient.parameterToString(xAmzSignedHeaders));
        }

        final String[] localVarAccepts = {
            "text/xml"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "hmac" };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call gETDescribeClusterParameterGroupsValidateBeforeCall(String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, String parameterGroupName, Integer maxRecords, String marker, List<String> tagKeys, List<String> tagValues, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'action' is set
        if (action == null) {
            throw new ApiException("Missing the required parameter 'action' when calling gETDescribeClusterParameterGroups(Async)");
        }

        // verify the required parameter 'version' is set
        if (version == null) {
            throw new ApiException("Missing the required parameter 'version' when calling gETDescribeClusterParameterGroups(Async)");
        }

        return gETDescribeClusterParameterGroupsCall(action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, parameterGroupName, maxRecords, marker, tagKeys, tagValues, _callback);

    }

    /**
     * 
     * &lt;p&gt;Returns a list of Amazon Redshift parameter groups, including parameter groups you created and the default parameter group. For each parameter group, the response includes the parameter group name, description, and parameter group family name. You can optionally specify a name to retrieve the description of a specific parameter group.&lt;/p&gt; &lt;p&gt; For more information about parameters and parameter groups, go to &lt;a href&#x3D;\&quot;https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-parameter-groups.html\&quot;&gt;Amazon Redshift Parameter Groups&lt;/a&gt; in the &lt;i&gt;Amazon Redshift Cluster Management Guide&lt;/i&gt;.&lt;/p&gt; &lt;p&gt;If you specify both tag keys and tag values in the same request, Amazon Redshift returns all parameter groups that match any combination of the specified keys and values. For example, if you have &lt;code&gt;owner&lt;/code&gt; and &lt;code&gt;environment&lt;/code&gt; for tag keys, and &lt;code&gt;admin&lt;/code&gt; and &lt;code&gt;test&lt;/code&gt; for tag values, all parameter groups that have any combination of those values are returned.&lt;/p&gt; &lt;p&gt;If both tag keys and values are omitted from the request, parameter groups are returned regardless of whether they have tag keys or values associated with them.&lt;/p&gt;
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param parameterGroupName The name of a specific parameter group for which to return details. By default, details about all parameter groups and the default parameter group are returned. (optional)
     * @param maxRecords &lt;p&gt;The maximum number of response records to return in each call. If the number of remaining response records exceeds the specified &lt;code&gt;MaxRecords&lt;/code&gt; value, a value is returned in a &lt;code&gt;marker&lt;/code&gt; field of the response. You can retrieve the next set of records by retrying the command with the returned marker value. &lt;/p&gt; &lt;p&gt;Default: &lt;code&gt;100&lt;/code&gt; &lt;/p&gt; &lt;p&gt;Constraints: minimum 20, maximum 100.&lt;/p&gt; (optional)
     * @param marker An optional parameter that specifies the starting point to return a set of response records. When the results of a &lt;a&gt;DescribeClusterParameterGroups&lt;/a&gt; request exceed the value specified in &lt;code&gt;MaxRecords&lt;/code&gt;, Amazon Web Services returns a value in the &lt;code&gt;Marker&lt;/code&gt; field of the response. You can retrieve the next set of response records by providing the returned marker value in the &lt;code&gt;Marker&lt;/code&gt; parameter and retrying the request.  (optional)
     * @param tagKeys A tag key or keys for which you want to return all matching cluster parameter groups that are associated with the specified key or keys. For example, suppose that you have parameter groups that are tagged with keys called &lt;code&gt;owner&lt;/code&gt; and &lt;code&gt;environment&lt;/code&gt;. If you specify both of these tag keys in the request, Amazon Redshift returns a response with the parameter groups that have either or both of these tag keys associated with them. (optional)
     * @param tagValues A tag value or values for which you want to return all matching cluster parameter groups that are associated with the specified tag value or values. For example, suppose that you have parameter groups that are tagged with values called &lt;code&gt;admin&lt;/code&gt; and &lt;code&gt;test&lt;/code&gt;. If you specify both of these tag values in the request, Amazon Redshift returns a response with the parameter groups that have either or both of these tag values associated with them. (optional)
     * @return ClusterParameterGroupsMessage
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> ClusterParameterGroupNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> InvalidTagFault </td><td>  -  </td></tr>
     </table>
     */
    public ClusterParameterGroupsMessage gETDescribeClusterParameterGroups(String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, String parameterGroupName, Integer maxRecords, String marker, List<String> tagKeys, List<String> tagValues) throws ApiException {
        ApiResponse<ClusterParameterGroupsMessage> localVarResp = gETDescribeClusterParameterGroupsWithHttpInfo(action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, parameterGroupName, maxRecords, marker, tagKeys, tagValues);
        return localVarResp.getData();
    }

    /**
     * 
     * &lt;p&gt;Returns a list of Amazon Redshift parameter groups, including parameter groups you created and the default parameter group. For each parameter group, the response includes the parameter group name, description, and parameter group family name. You can optionally specify a name to retrieve the description of a specific parameter group.&lt;/p&gt; &lt;p&gt; For more information about parameters and parameter groups, go to &lt;a href&#x3D;\&quot;https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-parameter-groups.html\&quot;&gt;Amazon Redshift Parameter Groups&lt;/a&gt; in the &lt;i&gt;Amazon Redshift Cluster Management Guide&lt;/i&gt;.&lt;/p&gt; &lt;p&gt;If you specify both tag keys and tag values in the same request, Amazon Redshift returns all parameter groups that match any combination of the specified keys and values. For example, if you have &lt;code&gt;owner&lt;/code&gt; and &lt;code&gt;environment&lt;/code&gt; for tag keys, and &lt;code&gt;admin&lt;/code&gt; and &lt;code&gt;test&lt;/code&gt; for tag values, all parameter groups that have any combination of those values are returned.&lt;/p&gt; &lt;p&gt;If both tag keys and values are omitted from the request, parameter groups are returned regardless of whether they have tag keys or values associated with them.&lt;/p&gt;
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param parameterGroupName The name of a specific parameter group for which to return details. By default, details about all parameter groups and the default parameter group are returned. (optional)
     * @param maxRecords &lt;p&gt;The maximum number of response records to return in each call. If the number of remaining response records exceeds the specified &lt;code&gt;MaxRecords&lt;/code&gt; value, a value is returned in a &lt;code&gt;marker&lt;/code&gt; field of the response. You can retrieve the next set of records by retrying the command with the returned marker value. &lt;/p&gt; &lt;p&gt;Default: &lt;code&gt;100&lt;/code&gt; &lt;/p&gt; &lt;p&gt;Constraints: minimum 20, maximum 100.&lt;/p&gt; (optional)
     * @param marker An optional parameter that specifies the starting point to return a set of response records. When the results of a &lt;a&gt;DescribeClusterParameterGroups&lt;/a&gt; request exceed the value specified in &lt;code&gt;MaxRecords&lt;/code&gt;, Amazon Web Services returns a value in the &lt;code&gt;Marker&lt;/code&gt; field of the response. You can retrieve the next set of response records by providing the returned marker value in the &lt;code&gt;Marker&lt;/code&gt; parameter and retrying the request.  (optional)
     * @param tagKeys A tag key or keys for which you want to return all matching cluster parameter groups that are associated with the specified key or keys. For example, suppose that you have parameter groups that are tagged with keys called &lt;code&gt;owner&lt;/code&gt; and &lt;code&gt;environment&lt;/code&gt;. If you specify both of these tag keys in the request, Amazon Redshift returns a response with the parameter groups that have either or both of these tag keys associated with them. (optional)
     * @param tagValues A tag value or values for which you want to return all matching cluster parameter groups that are associated with the specified tag value or values. For example, suppose that you have parameter groups that are tagged with values called &lt;code&gt;admin&lt;/code&gt; and &lt;code&gt;test&lt;/code&gt;. If you specify both of these tag values in the request, Amazon Redshift returns a response with the parameter groups that have either or both of these tag values associated with them. (optional)
     * @return ApiResponse&lt;ClusterParameterGroupsMessage&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> ClusterParameterGroupNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> InvalidTagFault </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<ClusterParameterGroupsMessage> gETDescribeClusterParameterGroupsWithHttpInfo(String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, String parameterGroupName, Integer maxRecords, String marker, List<String> tagKeys, List<String> tagValues) throws ApiException {
        okhttp3.Call localVarCall = gETDescribeClusterParameterGroupsValidateBeforeCall(action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, parameterGroupName, maxRecords, marker, tagKeys, tagValues, null);
        Type localVarReturnType = new TypeToken<ClusterParameterGroupsMessage>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     *  (asynchronously)
     * &lt;p&gt;Returns a list of Amazon Redshift parameter groups, including parameter groups you created and the default parameter group. For each parameter group, the response includes the parameter group name, description, and parameter group family name. You can optionally specify a name to retrieve the description of a specific parameter group.&lt;/p&gt; &lt;p&gt; For more information about parameters and parameter groups, go to &lt;a href&#x3D;\&quot;https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-parameter-groups.html\&quot;&gt;Amazon Redshift Parameter Groups&lt;/a&gt; in the &lt;i&gt;Amazon Redshift Cluster Management Guide&lt;/i&gt;.&lt;/p&gt; &lt;p&gt;If you specify both tag keys and tag values in the same request, Amazon Redshift returns all parameter groups that match any combination of the specified keys and values. For example, if you have &lt;code&gt;owner&lt;/code&gt; and &lt;code&gt;environment&lt;/code&gt; for tag keys, and &lt;code&gt;admin&lt;/code&gt; and &lt;code&gt;test&lt;/code&gt; for tag values, all parameter groups that have any combination of those values are returned.&lt;/p&gt; &lt;p&gt;If both tag keys and values are omitted from the request, parameter groups are returned regardless of whether they have tag keys or values associated with them.&lt;/p&gt;
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param parameterGroupName The name of a specific parameter group for which to return details. By default, details about all parameter groups and the default parameter group are returned. (optional)
     * @param maxRecords &lt;p&gt;The maximum number of response records to return in each call. If the number of remaining response records exceeds the specified &lt;code&gt;MaxRecords&lt;/code&gt; value, a value is returned in a &lt;code&gt;marker&lt;/code&gt; field of the response. You can retrieve the next set of records by retrying the command with the returned marker value. &lt;/p&gt; &lt;p&gt;Default: &lt;code&gt;100&lt;/code&gt; &lt;/p&gt; &lt;p&gt;Constraints: minimum 20, maximum 100.&lt;/p&gt; (optional)
     * @param marker An optional parameter that specifies the starting point to return a set of response records. When the results of a &lt;a&gt;DescribeClusterParameterGroups&lt;/a&gt; request exceed the value specified in &lt;code&gt;MaxRecords&lt;/code&gt;, Amazon Web Services returns a value in the &lt;code&gt;Marker&lt;/code&gt; field of the response. You can retrieve the next set of response records by providing the returned marker value in the &lt;code&gt;Marker&lt;/code&gt; parameter and retrying the request.  (optional)
     * @param tagKeys A tag key or keys for which you want to return all matching cluster parameter groups that are associated with the specified key or keys. For example, suppose that you have parameter groups that are tagged with keys called &lt;code&gt;owner&lt;/code&gt; and &lt;code&gt;environment&lt;/code&gt;. If you specify both of these tag keys in the request, Amazon Redshift returns a response with the parameter groups that have either or both of these tag keys associated with them. (optional)
     * @param tagValues A tag value or values for which you want to return all matching cluster parameter groups that are associated with the specified tag value or values. For example, suppose that you have parameter groups that are tagged with values called &lt;code&gt;admin&lt;/code&gt; and &lt;code&gt;test&lt;/code&gt;. If you specify both of these tag values in the request, Amazon Redshift returns a response with the parameter groups that have either or both of these tag values associated with them. (optional)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> ClusterParameterGroupNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> InvalidTagFault </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call gETDescribeClusterParameterGroupsAsync(String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, String parameterGroupName, Integer maxRecords, String marker, List<String> tagKeys, List<String> tagValues, final ApiCallback<ClusterParameterGroupsMessage> _callback) throws ApiException {

        okhttp3.Call localVarCall = gETDescribeClusterParameterGroupsValidateBeforeCall(action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, parameterGroupName, maxRecords, marker, tagKeys, tagValues, _callback);
        Type localVarReturnType = new TypeToken<ClusterParameterGroupsMessage>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for gETDescribeClusterParameters
     * @param parameterGroupName The name of a cluster parameter group for which to return details. (required)
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param source &lt;p&gt;The parameter types to return. Specify &lt;code&gt;user&lt;/code&gt; to show parameters that are different form the default. Similarly, specify &lt;code&gt;engine-default&lt;/code&gt; to show parameters that are the same as the default parameter group. &lt;/p&gt; &lt;p&gt;Default: All parameter types returned.&lt;/p&gt; &lt;p&gt;Valid Values: &lt;code&gt;user&lt;/code&gt; | &lt;code&gt;engine-default&lt;/code&gt; &lt;/p&gt; (optional)
     * @param maxRecords &lt;p&gt;The maximum number of response records to return in each call. If the number of remaining response records exceeds the specified &lt;code&gt;MaxRecords&lt;/code&gt; value, a value is returned in a &lt;code&gt;marker&lt;/code&gt; field of the response. You can retrieve the next set of records by retrying the command with the returned marker value. &lt;/p&gt; &lt;p&gt;Default: &lt;code&gt;100&lt;/code&gt; &lt;/p&gt; &lt;p&gt;Constraints: minimum 20, maximum 100.&lt;/p&gt; (optional)
     * @param marker An optional parameter that specifies the starting point to return a set of response records. When the results of a &lt;a&gt;DescribeClusterParameters&lt;/a&gt; request exceed the value specified in &lt;code&gt;MaxRecords&lt;/code&gt;, Amazon Web Services returns a value in the &lt;code&gt;Marker&lt;/code&gt; field of the response. You can retrieve the next set of response records by providing the returned marker value in the &lt;code&gt;Marker&lt;/code&gt; parameter and retrying the request.  (optional)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> ClusterParameterGroupNotFoundFault </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call gETDescribeClusterParametersCall(String parameterGroupName, String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, String source, Integer maxRecords, String marker, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/#Action=DescribeClusterParameters";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (parameterGroupName != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("ParameterGroupName", parameterGroupName));
        }

        if (source != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("Source", source));
        }

        if (maxRecords != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("MaxRecords", maxRecords));
        }

        if (marker != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("Marker", marker));
        }

        if (action != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("Action", action));
        }

        if (version != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("Version", version));
        }

        if (xAmzContentSha256 != null) {
            localVarHeaderParams.put("X-Amz-Content-Sha256", localVarApiClient.parameterToString(xAmzContentSha256));
        }

        if (xAmzDate != null) {
            localVarHeaderParams.put("X-Amz-Date", localVarApiClient.parameterToString(xAmzDate));
        }

        if (xAmzAlgorithm != null) {
            localVarHeaderParams.put("X-Amz-Algorithm", localVarApiClient.parameterToString(xAmzAlgorithm));
        }

        if (xAmzCredential != null) {
            localVarHeaderParams.put("X-Amz-Credential", localVarApiClient.parameterToString(xAmzCredential));
        }

        if (xAmzSecurityToken != null) {
            localVarHeaderParams.put("X-Amz-Security-Token", localVarApiClient.parameterToString(xAmzSecurityToken));
        }

        if (xAmzSignature != null) {
            localVarHeaderParams.put("X-Amz-Signature", localVarApiClient.parameterToString(xAmzSignature));
        }

        if (xAmzSignedHeaders != null) {
            localVarHeaderParams.put("X-Amz-SignedHeaders", localVarApiClient.parameterToString(xAmzSignedHeaders));
        }

        final String[] localVarAccepts = {
            "text/xml"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "hmac" };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call gETDescribeClusterParametersValidateBeforeCall(String parameterGroupName, String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, String source, Integer maxRecords, String marker, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'parameterGroupName' is set
        if (parameterGroupName == null) {
            throw new ApiException("Missing the required parameter 'parameterGroupName' when calling gETDescribeClusterParameters(Async)");
        }

        // verify the required parameter 'action' is set
        if (action == null) {
            throw new ApiException("Missing the required parameter 'action' when calling gETDescribeClusterParameters(Async)");
        }

        // verify the required parameter 'version' is set
        if (version == null) {
            throw new ApiException("Missing the required parameter 'version' when calling gETDescribeClusterParameters(Async)");
        }

        return gETDescribeClusterParametersCall(parameterGroupName, action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, source, maxRecords, marker, _callback);

    }

    /**
     * 
     * &lt;p&gt;Returns a detailed list of parameters contained within the specified Amazon Redshift parameter group. For each parameter the response includes information such as parameter name, description, data type, value, whether the parameter value is modifiable, and so on.&lt;/p&gt; &lt;p&gt;You can specify &lt;i&gt;source&lt;/i&gt; filter to retrieve parameters of only specific type. For example, to retrieve parameters that were modified by a user action such as from &lt;a&gt;ModifyClusterParameterGroup&lt;/a&gt;, you can specify &lt;i&gt;source&lt;/i&gt; equal to &lt;i&gt;user&lt;/i&gt;.&lt;/p&gt; &lt;p&gt; For more information about parameters and parameter groups, go to &lt;a href&#x3D;\&quot;https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-parameter-groups.html\&quot;&gt;Amazon Redshift Parameter Groups&lt;/a&gt; in the &lt;i&gt;Amazon Redshift Cluster Management Guide&lt;/i&gt;.&lt;/p&gt;
     * @param parameterGroupName The name of a cluster parameter group for which to return details. (required)
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param source &lt;p&gt;The parameter types to return. Specify &lt;code&gt;user&lt;/code&gt; to show parameters that are different form the default. Similarly, specify &lt;code&gt;engine-default&lt;/code&gt; to show parameters that are the same as the default parameter group. &lt;/p&gt; &lt;p&gt;Default: All parameter types returned.&lt;/p&gt; &lt;p&gt;Valid Values: &lt;code&gt;user&lt;/code&gt; | &lt;code&gt;engine-default&lt;/code&gt; &lt;/p&gt; (optional)
     * @param maxRecords &lt;p&gt;The maximum number of response records to return in each call. If the number of remaining response records exceeds the specified &lt;code&gt;MaxRecords&lt;/code&gt; value, a value is returned in a &lt;code&gt;marker&lt;/code&gt; field of the response. You can retrieve the next set of records by retrying the command with the returned marker value. &lt;/p&gt; &lt;p&gt;Default: &lt;code&gt;100&lt;/code&gt; &lt;/p&gt; &lt;p&gt;Constraints: minimum 20, maximum 100.&lt;/p&gt; (optional)
     * @param marker An optional parameter that specifies the starting point to return a set of response records. When the results of a &lt;a&gt;DescribeClusterParameters&lt;/a&gt; request exceed the value specified in &lt;code&gt;MaxRecords&lt;/code&gt;, Amazon Web Services returns a value in the &lt;code&gt;Marker&lt;/code&gt; field of the response. You can retrieve the next set of response records by providing the returned marker value in the &lt;code&gt;Marker&lt;/code&gt; parameter and retrying the request.  (optional)
     * @return ClusterParameterGroupDetails
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> ClusterParameterGroupNotFoundFault </td><td>  -  </td></tr>
     </table>
     */
    public ClusterParameterGroupDetails gETDescribeClusterParameters(String parameterGroupName, String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, String source, Integer maxRecords, String marker) throws ApiException {
        ApiResponse<ClusterParameterGroupDetails> localVarResp = gETDescribeClusterParametersWithHttpInfo(parameterGroupName, action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, source, maxRecords, marker);
        return localVarResp.getData();
    }

    /**
     * 
     * &lt;p&gt;Returns a detailed list of parameters contained within the specified Amazon Redshift parameter group. For each parameter the response includes information such as parameter name, description, data type, value, whether the parameter value is modifiable, and so on.&lt;/p&gt; &lt;p&gt;You can specify &lt;i&gt;source&lt;/i&gt; filter to retrieve parameters of only specific type. For example, to retrieve parameters that were modified by a user action such as from &lt;a&gt;ModifyClusterParameterGroup&lt;/a&gt;, you can specify &lt;i&gt;source&lt;/i&gt; equal to &lt;i&gt;user&lt;/i&gt;.&lt;/p&gt; &lt;p&gt; For more information about parameters and parameter groups, go to &lt;a href&#x3D;\&quot;https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-parameter-groups.html\&quot;&gt;Amazon Redshift Parameter Groups&lt;/a&gt; in the &lt;i&gt;Amazon Redshift Cluster Management Guide&lt;/i&gt;.&lt;/p&gt;
     * @param parameterGroupName The name of a cluster parameter group for which to return details. (required)
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param source &lt;p&gt;The parameter types to return. Specify &lt;code&gt;user&lt;/code&gt; to show parameters that are different form the default. Similarly, specify &lt;code&gt;engine-default&lt;/code&gt; to show parameters that are the same as the default parameter group. &lt;/p&gt; &lt;p&gt;Default: All parameter types returned.&lt;/p&gt; &lt;p&gt;Valid Values: &lt;code&gt;user&lt;/code&gt; | &lt;code&gt;engine-default&lt;/code&gt; &lt;/p&gt; (optional)
     * @param maxRecords &lt;p&gt;The maximum number of response records to return in each call. If the number of remaining response records exceeds the specified &lt;code&gt;MaxRecords&lt;/code&gt; value, a value is returned in a &lt;code&gt;marker&lt;/code&gt; field of the response. You can retrieve the next set of records by retrying the command with the returned marker value. &lt;/p&gt; &lt;p&gt;Default: &lt;code&gt;100&lt;/code&gt; &lt;/p&gt; &lt;p&gt;Constraints: minimum 20, maximum 100.&lt;/p&gt; (optional)
     * @param marker An optional parameter that specifies the starting point to return a set of response records. When the results of a &lt;a&gt;DescribeClusterParameters&lt;/a&gt; request exceed the value specified in &lt;code&gt;MaxRecords&lt;/code&gt;, Amazon Web Services returns a value in the &lt;code&gt;Marker&lt;/code&gt; field of the response. You can retrieve the next set of response records by providing the returned marker value in the &lt;code&gt;Marker&lt;/code&gt; parameter and retrying the request.  (optional)
     * @return ApiResponse&lt;ClusterParameterGroupDetails&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> ClusterParameterGroupNotFoundFault </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<ClusterParameterGroupDetails> gETDescribeClusterParametersWithHttpInfo(String parameterGroupName, String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, String source, Integer maxRecords, String marker) throws ApiException {
        okhttp3.Call localVarCall = gETDescribeClusterParametersValidateBeforeCall(parameterGroupName, action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, source, maxRecords, marker, null);
        Type localVarReturnType = new TypeToken<ClusterParameterGroupDetails>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     *  (asynchronously)
     * &lt;p&gt;Returns a detailed list of parameters contained within the specified Amazon Redshift parameter group. For each parameter the response includes information such as parameter name, description, data type, value, whether the parameter value is modifiable, and so on.&lt;/p&gt; &lt;p&gt;You can specify &lt;i&gt;source&lt;/i&gt; filter to retrieve parameters of only specific type. For example, to retrieve parameters that were modified by a user action such as from &lt;a&gt;ModifyClusterParameterGroup&lt;/a&gt;, you can specify &lt;i&gt;source&lt;/i&gt; equal to &lt;i&gt;user&lt;/i&gt;.&lt;/p&gt; &lt;p&gt; For more information about parameters and parameter groups, go to &lt;a href&#x3D;\&quot;https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-parameter-groups.html\&quot;&gt;Amazon Redshift Parameter Groups&lt;/a&gt; in the &lt;i&gt;Amazon Redshift Cluster Management Guide&lt;/i&gt;.&lt;/p&gt;
     * @param parameterGroupName The name of a cluster parameter group for which to return details. (required)
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param source &lt;p&gt;The parameter types to return. Specify &lt;code&gt;user&lt;/code&gt; to show parameters that are different form the default. Similarly, specify &lt;code&gt;engine-default&lt;/code&gt; to show parameters that are the same as the default parameter group. &lt;/p&gt; &lt;p&gt;Default: All parameter types returned.&lt;/p&gt; &lt;p&gt;Valid Values: &lt;code&gt;user&lt;/code&gt; | &lt;code&gt;engine-default&lt;/code&gt; &lt;/p&gt; (optional)
     * @param maxRecords &lt;p&gt;The maximum number of response records to return in each call. If the number of remaining response records exceeds the specified &lt;code&gt;MaxRecords&lt;/code&gt; value, a value is returned in a &lt;code&gt;marker&lt;/code&gt; field of the response. You can retrieve the next set of records by retrying the command with the returned marker value. &lt;/p&gt; &lt;p&gt;Default: &lt;code&gt;100&lt;/code&gt; &lt;/p&gt; &lt;p&gt;Constraints: minimum 20, maximum 100.&lt;/p&gt; (optional)
     * @param marker An optional parameter that specifies the starting point to return a set of response records. When the results of a &lt;a&gt;DescribeClusterParameters&lt;/a&gt; request exceed the value specified in &lt;code&gt;MaxRecords&lt;/code&gt;, Amazon Web Services returns a value in the &lt;code&gt;Marker&lt;/code&gt; field of the response. You can retrieve the next set of response records by providing the returned marker value in the &lt;code&gt;Marker&lt;/code&gt; parameter and retrying the request.  (optional)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> ClusterParameterGroupNotFoundFault </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call gETDescribeClusterParametersAsync(String parameterGroupName, String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, String source, Integer maxRecords, String marker, final ApiCallback<ClusterParameterGroupDetails> _callback) throws ApiException {

        okhttp3.Call localVarCall = gETDescribeClusterParametersValidateBeforeCall(parameterGroupName, action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, source, maxRecords, marker, _callback);
        Type localVarReturnType = new TypeToken<ClusterParameterGroupDetails>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for gETDescribeClusterSecurityGroups
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param clusterSecurityGroupName &lt;p&gt;The name of a cluster security group for which you are requesting details. You must specify either the &lt;b&gt;Marker&lt;/b&gt; parameter or a &lt;b&gt;ClusterSecurityGroupName&lt;/b&gt; parameter, but not both. &lt;/p&gt; &lt;p&gt; Example: &lt;code&gt;securitygroup1&lt;/code&gt; &lt;/p&gt; (optional)
     * @param maxRecords &lt;p&gt;The maximum number of response records to return in each call. If the number of remaining response records exceeds the specified &lt;code&gt;MaxRecords&lt;/code&gt; value, a value is returned in a &lt;code&gt;marker&lt;/code&gt; field of the response. You can retrieve the next set of records by retrying the command with the returned marker value. &lt;/p&gt; &lt;p&gt;Default: &lt;code&gt;100&lt;/code&gt; &lt;/p&gt; &lt;p&gt;Constraints: minimum 20, maximum 100.&lt;/p&gt; (optional)
     * @param marker &lt;p&gt;An optional parameter that specifies the starting point to return a set of response records. When the results of a &lt;a&gt;DescribeClusterSecurityGroups&lt;/a&gt; request exceed the value specified in &lt;code&gt;MaxRecords&lt;/code&gt;, Amazon Web Services returns a value in the &lt;code&gt;Marker&lt;/code&gt; field of the response. You can retrieve the next set of response records by providing the returned marker value in the &lt;code&gt;Marker&lt;/code&gt; parameter and retrying the request. &lt;/p&gt; &lt;p&gt;Constraints: You must specify either the &lt;b&gt;ClusterSecurityGroupName&lt;/b&gt; parameter or the &lt;b&gt;Marker&lt;/b&gt; parameter, but not both. &lt;/p&gt; (optional)
     * @param tagKeys A tag key or keys for which you want to return all matching cluster security groups that are associated with the specified key or keys. For example, suppose that you have security groups that are tagged with keys called &lt;code&gt;owner&lt;/code&gt; and &lt;code&gt;environment&lt;/code&gt;. If you specify both of these tag keys in the request, Amazon Redshift returns a response with the security groups that have either or both of these tag keys associated with them. (optional)
     * @param tagValues A tag value or values for which you want to return all matching cluster security groups that are associated with the specified tag value or values. For example, suppose that you have security groups that are tagged with values called &lt;code&gt;admin&lt;/code&gt; and &lt;code&gt;test&lt;/code&gt;. If you specify both of these tag values in the request, Amazon Redshift returns a response with the security groups that have either or both of these tag values associated with them. (optional)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> ClusterSecurityGroupNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> InvalidTagFault </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call gETDescribeClusterSecurityGroupsCall(String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, String clusterSecurityGroupName, Integer maxRecords, String marker, List<String> tagKeys, List<String> tagValues, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/#Action=DescribeClusterSecurityGroups";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (clusterSecurityGroupName != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("ClusterSecurityGroupName", clusterSecurityGroupName));
        }

        if (maxRecords != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("MaxRecords", maxRecords));
        }

        if (marker != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("Marker", marker));
        }

        if (tagKeys != null) {
            localVarCollectionQueryParams.addAll(localVarApiClient.parameterToPairs("multi", "TagKeys", tagKeys));
        }

        if (tagValues != null) {
            localVarCollectionQueryParams.addAll(localVarApiClient.parameterToPairs("multi", "TagValues", tagValues));
        }

        if (action != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("Action", action));
        }

        if (version != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("Version", version));
        }

        if (xAmzContentSha256 != null) {
            localVarHeaderParams.put("X-Amz-Content-Sha256", localVarApiClient.parameterToString(xAmzContentSha256));
        }

        if (xAmzDate != null) {
            localVarHeaderParams.put("X-Amz-Date", localVarApiClient.parameterToString(xAmzDate));
        }

        if (xAmzAlgorithm != null) {
            localVarHeaderParams.put("X-Amz-Algorithm", localVarApiClient.parameterToString(xAmzAlgorithm));
        }

        if (xAmzCredential != null) {
            localVarHeaderParams.put("X-Amz-Credential", localVarApiClient.parameterToString(xAmzCredential));
        }

        if (xAmzSecurityToken != null) {
            localVarHeaderParams.put("X-Amz-Security-Token", localVarApiClient.parameterToString(xAmzSecurityToken));
        }

        if (xAmzSignature != null) {
            localVarHeaderParams.put("X-Amz-Signature", localVarApiClient.parameterToString(xAmzSignature));
        }

        if (xAmzSignedHeaders != null) {
            localVarHeaderParams.put("X-Amz-SignedHeaders", localVarApiClient.parameterToString(xAmzSignedHeaders));
        }

        final String[] localVarAccepts = {
            "text/xml"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "hmac" };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call gETDescribeClusterSecurityGroupsValidateBeforeCall(String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, String clusterSecurityGroupName, Integer maxRecords, String marker, List<String> tagKeys, List<String> tagValues, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'action' is set
        if (action == null) {
            throw new ApiException("Missing the required parameter 'action' when calling gETDescribeClusterSecurityGroups(Async)");
        }

        // verify the required parameter 'version' is set
        if (version == null) {
            throw new ApiException("Missing the required parameter 'version' when calling gETDescribeClusterSecurityGroups(Async)");
        }

        return gETDescribeClusterSecurityGroupsCall(action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, clusterSecurityGroupName, maxRecords, marker, tagKeys, tagValues, _callback);

    }

    /**
     * 
     * &lt;p&gt;Returns information about Amazon Redshift security groups. If the name of a security group is specified, the response will contain only information about only that security group.&lt;/p&gt; &lt;p&gt; For information about managing security groups, go to &lt;a href&#x3D;\&quot;https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-security-groups.html\&quot;&gt;Amazon Redshift Cluster Security Groups&lt;/a&gt; in the &lt;i&gt;Amazon Redshift Cluster Management Guide&lt;/i&gt;.&lt;/p&gt; &lt;p&gt;If you specify both tag keys and tag values in the same request, Amazon Redshift returns all security groups that match any combination of the specified keys and values. For example, if you have &lt;code&gt;owner&lt;/code&gt; and &lt;code&gt;environment&lt;/code&gt; for tag keys, and &lt;code&gt;admin&lt;/code&gt; and &lt;code&gt;test&lt;/code&gt; for tag values, all security groups that have any combination of those values are returned.&lt;/p&gt; &lt;p&gt;If both tag keys and values are omitted from the request, security groups are returned regardless of whether they have tag keys or values associated with them.&lt;/p&gt;
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param clusterSecurityGroupName &lt;p&gt;The name of a cluster security group for which you are requesting details. You must specify either the &lt;b&gt;Marker&lt;/b&gt; parameter or a &lt;b&gt;ClusterSecurityGroupName&lt;/b&gt; parameter, but not both. &lt;/p&gt; &lt;p&gt; Example: &lt;code&gt;securitygroup1&lt;/code&gt; &lt;/p&gt; (optional)
     * @param maxRecords &lt;p&gt;The maximum number of response records to return in each call. If the number of remaining response records exceeds the specified &lt;code&gt;MaxRecords&lt;/code&gt; value, a value is returned in a &lt;code&gt;marker&lt;/code&gt; field of the response. You can retrieve the next set of records by retrying the command with the returned marker value. &lt;/p&gt; &lt;p&gt;Default: &lt;code&gt;100&lt;/code&gt; &lt;/p&gt; &lt;p&gt;Constraints: minimum 20, maximum 100.&lt;/p&gt; (optional)
     * @param marker &lt;p&gt;An optional parameter that specifies the starting point to return a set of response records. When the results of a &lt;a&gt;DescribeClusterSecurityGroups&lt;/a&gt; request exceed the value specified in &lt;code&gt;MaxRecords&lt;/code&gt;, Amazon Web Services returns a value in the &lt;code&gt;Marker&lt;/code&gt; field of the response. You can retrieve the next set of response records by providing the returned marker value in the &lt;code&gt;Marker&lt;/code&gt; parameter and retrying the request. &lt;/p&gt; &lt;p&gt;Constraints: You must specify either the &lt;b&gt;ClusterSecurityGroupName&lt;/b&gt; parameter or the &lt;b&gt;Marker&lt;/b&gt; parameter, but not both. &lt;/p&gt; (optional)
     * @param tagKeys A tag key or keys for which you want to return all matching cluster security groups that are associated with the specified key or keys. For example, suppose that you have security groups that are tagged with keys called &lt;code&gt;owner&lt;/code&gt; and &lt;code&gt;environment&lt;/code&gt;. If you specify both of these tag keys in the request, Amazon Redshift returns a response with the security groups that have either or both of these tag keys associated with them. (optional)
     * @param tagValues A tag value or values for which you want to return all matching cluster security groups that are associated with the specified tag value or values. For example, suppose that you have security groups that are tagged with values called &lt;code&gt;admin&lt;/code&gt; and &lt;code&gt;test&lt;/code&gt;. If you specify both of these tag values in the request, Amazon Redshift returns a response with the security groups that have either or both of these tag values associated with them. (optional)
     * @return ClusterSecurityGroupMessage
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> ClusterSecurityGroupNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> InvalidTagFault </td><td>  -  </td></tr>
     </table>
     */
    public ClusterSecurityGroupMessage gETDescribeClusterSecurityGroups(String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, String clusterSecurityGroupName, Integer maxRecords, String marker, List<String> tagKeys, List<String> tagValues) throws ApiException {
        ApiResponse<ClusterSecurityGroupMessage> localVarResp = gETDescribeClusterSecurityGroupsWithHttpInfo(action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, clusterSecurityGroupName, maxRecords, marker, tagKeys, tagValues);
        return localVarResp.getData();
    }

    /**
     * 
     * &lt;p&gt;Returns information about Amazon Redshift security groups. If the name of a security group is specified, the response will contain only information about only that security group.&lt;/p&gt; &lt;p&gt; For information about managing security groups, go to &lt;a href&#x3D;\&quot;https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-security-groups.html\&quot;&gt;Amazon Redshift Cluster Security Groups&lt;/a&gt; in the &lt;i&gt;Amazon Redshift Cluster Management Guide&lt;/i&gt;.&lt;/p&gt; &lt;p&gt;If you specify both tag keys and tag values in the same request, Amazon Redshift returns all security groups that match any combination of the specified keys and values. For example, if you have &lt;code&gt;owner&lt;/code&gt; and &lt;code&gt;environment&lt;/code&gt; for tag keys, and &lt;code&gt;admin&lt;/code&gt; and &lt;code&gt;test&lt;/code&gt; for tag values, all security groups that have any combination of those values are returned.&lt;/p&gt; &lt;p&gt;If both tag keys and values are omitted from the request, security groups are returned regardless of whether they have tag keys or values associated with them.&lt;/p&gt;
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param clusterSecurityGroupName &lt;p&gt;The name of a cluster security group for which you are requesting details. You must specify either the &lt;b&gt;Marker&lt;/b&gt; parameter or a &lt;b&gt;ClusterSecurityGroupName&lt;/b&gt; parameter, but not both. &lt;/p&gt; &lt;p&gt; Example: &lt;code&gt;securitygroup1&lt;/code&gt; &lt;/p&gt; (optional)
     * @param maxRecords &lt;p&gt;The maximum number of response records to return in each call. If the number of remaining response records exceeds the specified &lt;code&gt;MaxRecords&lt;/code&gt; value, a value is returned in a &lt;code&gt;marker&lt;/code&gt; field of the response. You can retrieve the next set of records by retrying the command with the returned marker value. &lt;/p&gt; &lt;p&gt;Default: &lt;code&gt;100&lt;/code&gt; &lt;/p&gt; &lt;p&gt;Constraints: minimum 20, maximum 100.&lt;/p&gt; (optional)
     * @param marker &lt;p&gt;An optional parameter that specifies the starting point to return a set of response records. When the results of a &lt;a&gt;DescribeClusterSecurityGroups&lt;/a&gt; request exceed the value specified in &lt;code&gt;MaxRecords&lt;/code&gt;, Amazon Web Services returns a value in the &lt;code&gt;Marker&lt;/code&gt; field of the response. You can retrieve the next set of response records by providing the returned marker value in the &lt;code&gt;Marker&lt;/code&gt; parameter and retrying the request. &lt;/p&gt; &lt;p&gt;Constraints: You must specify either the &lt;b&gt;ClusterSecurityGroupName&lt;/b&gt; parameter or the &lt;b&gt;Marker&lt;/b&gt; parameter, but not both. &lt;/p&gt; (optional)
     * @param tagKeys A tag key or keys for which you want to return all matching cluster security groups that are associated with the specified key or keys. For example, suppose that you have security groups that are tagged with keys called &lt;code&gt;owner&lt;/code&gt; and &lt;code&gt;environment&lt;/code&gt;. If you specify both of these tag keys in the request, Amazon Redshift returns a response with the security groups that have either or both of these tag keys associated with them. (optional)
     * @param tagValues A tag value or values for which you want to return all matching cluster security groups that are associated with the specified tag value or values. For example, suppose that you have security groups that are tagged with values called &lt;code&gt;admin&lt;/code&gt; and &lt;code&gt;test&lt;/code&gt;. If you specify both of these tag values in the request, Amazon Redshift returns a response with the security groups that have either or both of these tag values associated with them. (optional)
     * @return ApiResponse&lt;ClusterSecurityGroupMessage&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> ClusterSecurityGroupNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> InvalidTagFault </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<ClusterSecurityGroupMessage> gETDescribeClusterSecurityGroupsWithHttpInfo(String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, String clusterSecurityGroupName, Integer maxRecords, String marker, List<String> tagKeys, List<String> tagValues) throws ApiException {
        okhttp3.Call localVarCall = gETDescribeClusterSecurityGroupsValidateBeforeCall(action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, clusterSecurityGroupName, maxRecords, marker, tagKeys, tagValues, null);
        Type localVarReturnType = new TypeToken<ClusterSecurityGroupMessage>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     *  (asynchronously)
     * &lt;p&gt;Returns information about Amazon Redshift security groups. If the name of a security group is specified, the response will contain only information about only that security group.&lt;/p&gt; &lt;p&gt; For information about managing security groups, go to &lt;a href&#x3D;\&quot;https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-security-groups.html\&quot;&gt;Amazon Redshift Cluster Security Groups&lt;/a&gt; in the &lt;i&gt;Amazon Redshift Cluster Management Guide&lt;/i&gt;.&lt;/p&gt; &lt;p&gt;If you specify both tag keys and tag values in the same request, Amazon Redshift returns all security groups that match any combination of the specified keys and values. For example, if you have &lt;code&gt;owner&lt;/code&gt; and &lt;code&gt;environment&lt;/code&gt; for tag keys, and &lt;code&gt;admin&lt;/code&gt; and &lt;code&gt;test&lt;/code&gt; for tag values, all security groups that have any combination of those values are returned.&lt;/p&gt; &lt;p&gt;If both tag keys and values are omitted from the request, security groups are returned regardless of whether they have tag keys or values associated with them.&lt;/p&gt;
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param clusterSecurityGroupName &lt;p&gt;The name of a cluster security group for which you are requesting details. You must specify either the &lt;b&gt;Marker&lt;/b&gt; parameter or a &lt;b&gt;ClusterSecurityGroupName&lt;/b&gt; parameter, but not both. &lt;/p&gt; &lt;p&gt; Example: &lt;code&gt;securitygroup1&lt;/code&gt; &lt;/p&gt; (optional)
     * @param maxRecords &lt;p&gt;The maximum number of response records to return in each call. If the number of remaining response records exceeds the specified &lt;code&gt;MaxRecords&lt;/code&gt; value, a value is returned in a &lt;code&gt;marker&lt;/code&gt; field of the response. You can retrieve the next set of records by retrying the command with the returned marker value. &lt;/p&gt; &lt;p&gt;Default: &lt;code&gt;100&lt;/code&gt; &lt;/p&gt; &lt;p&gt;Constraints: minimum 20, maximum 100.&lt;/p&gt; (optional)
     * @param marker &lt;p&gt;An optional parameter that specifies the starting point to return a set of response records. When the results of a &lt;a&gt;DescribeClusterSecurityGroups&lt;/a&gt; request exceed the value specified in &lt;code&gt;MaxRecords&lt;/code&gt;, Amazon Web Services returns a value in the &lt;code&gt;Marker&lt;/code&gt; field of the response. You can retrieve the next set of response records by providing the returned marker value in the &lt;code&gt;Marker&lt;/code&gt; parameter and retrying the request. &lt;/p&gt; &lt;p&gt;Constraints: You must specify either the &lt;b&gt;ClusterSecurityGroupName&lt;/b&gt; parameter or the &lt;b&gt;Marker&lt;/b&gt; parameter, but not both. &lt;/p&gt; (optional)
     * @param tagKeys A tag key or keys for which you want to return all matching cluster security groups that are associated with the specified key or keys. For example, suppose that you have security groups that are tagged with keys called &lt;code&gt;owner&lt;/code&gt; and &lt;code&gt;environment&lt;/code&gt;. If you specify both of these tag keys in the request, Amazon Redshift returns a response with the security groups that have either or both of these tag keys associated with them. (optional)
     * @param tagValues A tag value or values for which you want to return all matching cluster security groups that are associated with the specified tag value or values. For example, suppose that you have security groups that are tagged with values called &lt;code&gt;admin&lt;/code&gt; and &lt;code&gt;test&lt;/code&gt;. If you specify both of these tag values in the request, Amazon Redshift returns a response with the security groups that have either or both of these tag values associated with them. (optional)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> ClusterSecurityGroupNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> InvalidTagFault </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call gETDescribeClusterSecurityGroupsAsync(String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, String clusterSecurityGroupName, Integer maxRecords, String marker, List<String> tagKeys, List<String> tagValues, final ApiCallback<ClusterSecurityGroupMessage> _callback) throws ApiException {

        okhttp3.Call localVarCall = gETDescribeClusterSecurityGroupsValidateBeforeCall(action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, clusterSecurityGroupName, maxRecords, marker, tagKeys, tagValues, _callback);
        Type localVarReturnType = new TypeToken<ClusterSecurityGroupMessage>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for gETDescribeClusterSnapshots
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param clusterIdentifier The identifier of the cluster which generated the requested snapshots. (optional)
     * @param snapshotIdentifier The snapshot identifier of the snapshot about which to return information. (optional)
     * @param snapshotArn The Amazon Resource Name (ARN) of the snapshot associated with the message to describe cluster snapshots. (optional)
     * @param snapshotType &lt;p&gt;The type of snapshots for which you are requesting information. By default, snapshots of all types are returned.&lt;/p&gt; &lt;p&gt;Valid Values: &lt;code&gt;automated&lt;/code&gt; | &lt;code&gt;manual&lt;/code&gt; &lt;/p&gt; (optional)
     * @param startTime &lt;p&gt;A value that requests only snapshots created at or after the specified time. The time value is specified in ISO 8601 format. For more information about ISO 8601, go to the &lt;a href&#x3D;\&quot;http://en.wikipedia.org/wiki/ISO_8601\&quot;&gt;ISO8601 Wikipedia page.&lt;/a&gt; &lt;/p&gt; &lt;p&gt;Example: &lt;code&gt;2012-07-16T18:00:00Z&lt;/code&gt; &lt;/p&gt; (optional)
     * @param endTime &lt;p&gt;A time value that requests only snapshots created at or before the specified time. The time value is specified in ISO 8601 format. For more information about ISO 8601, go to the &lt;a href&#x3D;\&quot;http://en.wikipedia.org/wiki/ISO_8601\&quot;&gt;ISO8601 Wikipedia page.&lt;/a&gt; &lt;/p&gt; &lt;p&gt;Example: &lt;code&gt;2012-07-16T18:00:00Z&lt;/code&gt; &lt;/p&gt; (optional)
     * @param maxRecords &lt;p&gt;The maximum number of response records to return in each call. If the number of remaining response records exceeds the specified &lt;code&gt;MaxRecords&lt;/code&gt; value, a value is returned in a &lt;code&gt;marker&lt;/code&gt; field of the response. You can retrieve the next set of records by retrying the command with the returned marker value. &lt;/p&gt; &lt;p&gt;Default: &lt;code&gt;100&lt;/code&gt; &lt;/p&gt; &lt;p&gt;Constraints: minimum 20, maximum 100.&lt;/p&gt; (optional)
     * @param marker An optional parameter that specifies the starting point to return a set of response records. When the results of a &lt;a&gt;DescribeClusterSnapshots&lt;/a&gt; request exceed the value specified in &lt;code&gt;MaxRecords&lt;/code&gt;, Amazon Web Services returns a value in the &lt;code&gt;Marker&lt;/code&gt; field of the response. You can retrieve the next set of response records by providing the returned marker value in the &lt;code&gt;Marker&lt;/code&gt; parameter and retrying the request.  (optional)
     * @param ownerAccount The Amazon Web Services account used to create or copy the snapshot. Use this field to filter the results to snapshots owned by a particular account. To describe snapshots you own, either specify your Amazon Web Services account, or do not specify the parameter. (optional)
     * @param tagKeys A tag key or keys for which you want to return all matching cluster snapshots that are associated with the specified key or keys. For example, suppose that you have snapshots that are tagged with keys called &lt;code&gt;owner&lt;/code&gt; and &lt;code&gt;environment&lt;/code&gt;. If you specify both of these tag keys in the request, Amazon Redshift returns a response with the snapshots that have either or both of these tag keys associated with them. (optional)
     * @param tagValues A tag value or values for which you want to return all matching cluster snapshots that are associated with the specified tag value or values. For example, suppose that you have snapshots that are tagged with values called &lt;code&gt;admin&lt;/code&gt; and &lt;code&gt;test&lt;/code&gt;. If you specify both of these tag values in the request, Amazon Redshift returns a response with the snapshots that have either or both of these tag values associated with them. (optional)
     * @param clusterExists &lt;p&gt;A value that indicates whether to return snapshots only for an existing cluster. You can perform table-level restore only by using a snapshot of an existing cluster, that is, a cluster that has not been deleted. Values for this parameter work as follows: &lt;/p&gt; &lt;ul&gt; &lt;li&gt; &lt;p&gt;If &lt;code&gt;ClusterExists&lt;/code&gt; is set to &lt;code&gt;true&lt;/code&gt;, &lt;code&gt;ClusterIdentifier&lt;/code&gt; is required.&lt;/p&gt; &lt;/li&gt; &lt;li&gt; &lt;p&gt;If &lt;code&gt;ClusterExists&lt;/code&gt; is set to &lt;code&gt;false&lt;/code&gt; and &lt;code&gt;ClusterIdentifier&lt;/code&gt; isn&#39;t specified, all snapshots associated with deleted clusters (orphaned snapshots) are returned. &lt;/p&gt; &lt;/li&gt; &lt;li&gt; &lt;p&gt;If &lt;code&gt;ClusterExists&lt;/code&gt; is set to &lt;code&gt;false&lt;/code&gt; and &lt;code&gt;ClusterIdentifier&lt;/code&gt; is specified for a deleted cluster, snapshots associated with that cluster are returned.&lt;/p&gt; &lt;/li&gt; &lt;li&gt; &lt;p&gt;If &lt;code&gt;ClusterExists&lt;/code&gt; is set to &lt;code&gt;false&lt;/code&gt; and &lt;code&gt;ClusterIdentifier&lt;/code&gt; is specified for an existing cluster, no snapshots are returned. &lt;/p&gt; &lt;/li&gt; &lt;/ul&gt; (optional)
     * @param sortingEntities &lt;p/&gt; (optional)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> ClusterNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> ClusterSnapshotNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 482 </td><td> InvalidTagFault </td><td>  -  </td></tr>
        <tr><td> 483 </td><td> UnsupportedOperationFault </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call gETDescribeClusterSnapshotsCall(String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, String clusterIdentifier, String snapshotIdentifier, String snapshotArn, String snapshotType, OffsetDateTime startTime, OffsetDateTime endTime, Integer maxRecords, String marker, String ownerAccount, List<String> tagKeys, List<String> tagValues, Boolean clusterExists, List<GETDescribeClusterSnapshotsSortingEntitiesParameterInner> sortingEntities, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/#Action=DescribeClusterSnapshots";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (clusterIdentifier != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("ClusterIdentifier", clusterIdentifier));
        }

        if (snapshotIdentifier != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("SnapshotIdentifier", snapshotIdentifier));
        }

        if (snapshotArn != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("SnapshotArn", snapshotArn));
        }

        if (snapshotType != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("SnapshotType", snapshotType));
        }

        if (startTime != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("StartTime", startTime));
        }

        if (endTime != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("EndTime", endTime));
        }

        if (maxRecords != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("MaxRecords", maxRecords));
        }

        if (marker != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("Marker", marker));
        }

        if (ownerAccount != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("OwnerAccount", ownerAccount));
        }

        if (tagKeys != null) {
            localVarCollectionQueryParams.addAll(localVarApiClient.parameterToPairs("multi", "TagKeys", tagKeys));
        }

        if (tagValues != null) {
            localVarCollectionQueryParams.addAll(localVarApiClient.parameterToPairs("multi", "TagValues", tagValues));
        }

        if (clusterExists != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("ClusterExists", clusterExists));
        }

        if (sortingEntities != null) {
            localVarCollectionQueryParams.addAll(localVarApiClient.parameterToPairs("multi", "SortingEntities", sortingEntities));
        }

        if (action != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("Action", action));
        }

        if (version != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("Version", version));
        }

        if (xAmzContentSha256 != null) {
            localVarHeaderParams.put("X-Amz-Content-Sha256", localVarApiClient.parameterToString(xAmzContentSha256));
        }

        if (xAmzDate != null) {
            localVarHeaderParams.put("X-Amz-Date", localVarApiClient.parameterToString(xAmzDate));
        }

        if (xAmzAlgorithm != null) {
            localVarHeaderParams.put("X-Amz-Algorithm", localVarApiClient.parameterToString(xAmzAlgorithm));
        }

        if (xAmzCredential != null) {
            localVarHeaderParams.put("X-Amz-Credential", localVarApiClient.parameterToString(xAmzCredential));
        }

        if (xAmzSecurityToken != null) {
            localVarHeaderParams.put("X-Amz-Security-Token", localVarApiClient.parameterToString(xAmzSecurityToken));
        }

        if (xAmzSignature != null) {
            localVarHeaderParams.put("X-Amz-Signature", localVarApiClient.parameterToString(xAmzSignature));
        }

        if (xAmzSignedHeaders != null) {
            localVarHeaderParams.put("X-Amz-SignedHeaders", localVarApiClient.parameterToString(xAmzSignedHeaders));
        }

        final String[] localVarAccepts = {
            "text/xml"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "hmac" };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call gETDescribeClusterSnapshotsValidateBeforeCall(String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, String clusterIdentifier, String snapshotIdentifier, String snapshotArn, String snapshotType, OffsetDateTime startTime, OffsetDateTime endTime, Integer maxRecords, String marker, String ownerAccount, List<String> tagKeys, List<String> tagValues, Boolean clusterExists, List<GETDescribeClusterSnapshotsSortingEntitiesParameterInner> sortingEntities, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'action' is set
        if (action == null) {
            throw new ApiException("Missing the required parameter 'action' when calling gETDescribeClusterSnapshots(Async)");
        }

        // verify the required parameter 'version' is set
        if (version == null) {
            throw new ApiException("Missing the required parameter 'version' when calling gETDescribeClusterSnapshots(Async)");
        }

        return gETDescribeClusterSnapshotsCall(action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, clusterIdentifier, snapshotIdentifier, snapshotArn, snapshotType, startTime, endTime, maxRecords, marker, ownerAccount, tagKeys, tagValues, clusterExists, sortingEntities, _callback);

    }

    /**
     * 
     * &lt;p&gt;Returns one or more snapshot objects, which contain metadata about your cluster snapshots. By default, this operation returns information about all snapshots of all clusters that are owned by your Amazon Web Services account. No information is returned for snapshots owned by inactive Amazon Web Services accounts.&lt;/p&gt; &lt;p&gt;If you specify both tag keys and tag values in the same request, Amazon Redshift returns all snapshots that match any combination of the specified keys and values. For example, if you have &lt;code&gt;owner&lt;/code&gt; and &lt;code&gt;environment&lt;/code&gt; for tag keys, and &lt;code&gt;admin&lt;/code&gt; and &lt;code&gt;test&lt;/code&gt; for tag values, all snapshots that have any combination of those values are returned. Only snapshots that you own are returned in the response; shared snapshots are not returned with the tag key and tag value request parameters.&lt;/p&gt; &lt;p&gt;If both tag keys and values are omitted from the request, snapshots are returned regardless of whether they have tag keys or values associated with them.&lt;/p&gt;
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param clusterIdentifier The identifier of the cluster which generated the requested snapshots. (optional)
     * @param snapshotIdentifier The snapshot identifier of the snapshot about which to return information. (optional)
     * @param snapshotArn The Amazon Resource Name (ARN) of the snapshot associated with the message to describe cluster snapshots. (optional)
     * @param snapshotType &lt;p&gt;The type of snapshots for which you are requesting information. By default, snapshots of all types are returned.&lt;/p&gt; &lt;p&gt;Valid Values: &lt;code&gt;automated&lt;/code&gt; | &lt;code&gt;manual&lt;/code&gt; &lt;/p&gt; (optional)
     * @param startTime &lt;p&gt;A value that requests only snapshots created at or after the specified time. The time value is specified in ISO 8601 format. For more information about ISO 8601, go to the &lt;a href&#x3D;\&quot;http://en.wikipedia.org/wiki/ISO_8601\&quot;&gt;ISO8601 Wikipedia page.&lt;/a&gt; &lt;/p&gt; &lt;p&gt;Example: &lt;code&gt;2012-07-16T18:00:00Z&lt;/code&gt; &lt;/p&gt; (optional)
     * @param endTime &lt;p&gt;A time value that requests only snapshots created at or before the specified time. The time value is specified in ISO 8601 format. For more information about ISO 8601, go to the &lt;a href&#x3D;\&quot;http://en.wikipedia.org/wiki/ISO_8601\&quot;&gt;ISO8601 Wikipedia page.&lt;/a&gt; &lt;/p&gt; &lt;p&gt;Example: &lt;code&gt;2012-07-16T18:00:00Z&lt;/code&gt; &lt;/p&gt; (optional)
     * @param maxRecords &lt;p&gt;The maximum number of response records to return in each call. If the number of remaining response records exceeds the specified &lt;code&gt;MaxRecords&lt;/code&gt; value, a value is returned in a &lt;code&gt;marker&lt;/code&gt; field of the response. You can retrieve the next set of records by retrying the command with the returned marker value. &lt;/p&gt; &lt;p&gt;Default: &lt;code&gt;100&lt;/code&gt; &lt;/p&gt; &lt;p&gt;Constraints: minimum 20, maximum 100.&lt;/p&gt; (optional)
     * @param marker An optional parameter that specifies the starting point to return a set of response records. When the results of a &lt;a&gt;DescribeClusterSnapshots&lt;/a&gt; request exceed the value specified in &lt;code&gt;MaxRecords&lt;/code&gt;, Amazon Web Services returns a value in the &lt;code&gt;Marker&lt;/code&gt; field of the response. You can retrieve the next set of response records by providing the returned marker value in the &lt;code&gt;Marker&lt;/code&gt; parameter and retrying the request.  (optional)
     * @param ownerAccount The Amazon Web Services account used to create or copy the snapshot. Use this field to filter the results to snapshots owned by a particular account. To describe snapshots you own, either specify your Amazon Web Services account, or do not specify the parameter. (optional)
     * @param tagKeys A tag key or keys for which you want to return all matching cluster snapshots that are associated with the specified key or keys. For example, suppose that you have snapshots that are tagged with keys called &lt;code&gt;owner&lt;/code&gt; and &lt;code&gt;environment&lt;/code&gt;. If you specify both of these tag keys in the request, Amazon Redshift returns a response with the snapshots that have either or both of these tag keys associated with them. (optional)
     * @param tagValues A tag value or values for which you want to return all matching cluster snapshots that are associated with the specified tag value or values. For example, suppose that you have snapshots that are tagged with values called &lt;code&gt;admin&lt;/code&gt; and &lt;code&gt;test&lt;/code&gt;. If you specify both of these tag values in the request, Amazon Redshift returns a response with the snapshots that have either or both of these tag values associated with them. (optional)
     * @param clusterExists &lt;p&gt;A value that indicates whether to return snapshots only for an existing cluster. You can perform table-level restore only by using a snapshot of an existing cluster, that is, a cluster that has not been deleted. Values for this parameter work as follows: &lt;/p&gt; &lt;ul&gt; &lt;li&gt; &lt;p&gt;If &lt;code&gt;ClusterExists&lt;/code&gt; is set to &lt;code&gt;true&lt;/code&gt;, &lt;code&gt;ClusterIdentifier&lt;/code&gt; is required.&lt;/p&gt; &lt;/li&gt; &lt;li&gt; &lt;p&gt;If &lt;code&gt;ClusterExists&lt;/code&gt; is set to &lt;code&gt;false&lt;/code&gt; and &lt;code&gt;ClusterIdentifier&lt;/code&gt; isn&#39;t specified, all snapshots associated with deleted clusters (orphaned snapshots) are returned. &lt;/p&gt; &lt;/li&gt; &lt;li&gt; &lt;p&gt;If &lt;code&gt;ClusterExists&lt;/code&gt; is set to &lt;code&gt;false&lt;/code&gt; and &lt;code&gt;ClusterIdentifier&lt;/code&gt; is specified for a deleted cluster, snapshots associated with that cluster are returned.&lt;/p&gt; &lt;/li&gt; &lt;li&gt; &lt;p&gt;If &lt;code&gt;ClusterExists&lt;/code&gt; is set to &lt;code&gt;false&lt;/code&gt; and &lt;code&gt;ClusterIdentifier&lt;/code&gt; is specified for an existing cluster, no snapshots are returned. &lt;/p&gt; &lt;/li&gt; &lt;/ul&gt; (optional)
     * @param sortingEntities &lt;p/&gt; (optional)
     * @return SnapshotMessage
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> ClusterNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> ClusterSnapshotNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 482 </td><td> InvalidTagFault </td><td>  -  </td></tr>
        <tr><td> 483 </td><td> UnsupportedOperationFault </td><td>  -  </td></tr>
     </table>
     */
    public SnapshotMessage gETDescribeClusterSnapshots(String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, String clusterIdentifier, String snapshotIdentifier, String snapshotArn, String snapshotType, OffsetDateTime startTime, OffsetDateTime endTime, Integer maxRecords, String marker, String ownerAccount, List<String> tagKeys, List<String> tagValues, Boolean clusterExists, List<GETDescribeClusterSnapshotsSortingEntitiesParameterInner> sortingEntities) throws ApiException {
        ApiResponse<SnapshotMessage> localVarResp = gETDescribeClusterSnapshotsWithHttpInfo(action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, clusterIdentifier, snapshotIdentifier, snapshotArn, snapshotType, startTime, endTime, maxRecords, marker, ownerAccount, tagKeys, tagValues, clusterExists, sortingEntities);
        return localVarResp.getData();
    }

    /**
     * 
     * &lt;p&gt;Returns one or more snapshot objects, which contain metadata about your cluster snapshots. By default, this operation returns information about all snapshots of all clusters that are owned by your Amazon Web Services account. No information is returned for snapshots owned by inactive Amazon Web Services accounts.&lt;/p&gt; &lt;p&gt;If you specify both tag keys and tag values in the same request, Amazon Redshift returns all snapshots that match any combination of the specified keys and values. For example, if you have &lt;code&gt;owner&lt;/code&gt; and &lt;code&gt;environment&lt;/code&gt; for tag keys, and &lt;code&gt;admin&lt;/code&gt; and &lt;code&gt;test&lt;/code&gt; for tag values, all snapshots that have any combination of those values are returned. Only snapshots that you own are returned in the response; shared snapshots are not returned with the tag key and tag value request parameters.&lt;/p&gt; &lt;p&gt;If both tag keys and values are omitted from the request, snapshots are returned regardless of whether they have tag keys or values associated with them.&lt;/p&gt;
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param clusterIdentifier The identifier of the cluster which generated the requested snapshots. (optional)
     * @param snapshotIdentifier The snapshot identifier of the snapshot about which to return information. (optional)
     * @param snapshotArn The Amazon Resource Name (ARN) of the snapshot associated with the message to describe cluster snapshots. (optional)
     * @param snapshotType &lt;p&gt;The type of snapshots for which you are requesting information. By default, snapshots of all types are returned.&lt;/p&gt; &lt;p&gt;Valid Values: &lt;code&gt;automated&lt;/code&gt; | &lt;code&gt;manual&lt;/code&gt; &lt;/p&gt; (optional)
     * @param startTime &lt;p&gt;A value that requests only snapshots created at or after the specified time. The time value is specified in ISO 8601 format. For more information about ISO 8601, go to the &lt;a href&#x3D;\&quot;http://en.wikipedia.org/wiki/ISO_8601\&quot;&gt;ISO8601 Wikipedia page.&lt;/a&gt; &lt;/p&gt; &lt;p&gt;Example: &lt;code&gt;2012-07-16T18:00:00Z&lt;/code&gt; &lt;/p&gt; (optional)
     * @param endTime &lt;p&gt;A time value that requests only snapshots created at or before the specified time. The time value is specified in ISO 8601 format. For more information about ISO 8601, go to the &lt;a href&#x3D;\&quot;http://en.wikipedia.org/wiki/ISO_8601\&quot;&gt;ISO8601 Wikipedia page.&lt;/a&gt; &lt;/p&gt; &lt;p&gt;Example: &lt;code&gt;2012-07-16T18:00:00Z&lt;/code&gt; &lt;/p&gt; (optional)
     * @param maxRecords &lt;p&gt;The maximum number of response records to return in each call. If the number of remaining response records exceeds the specified &lt;code&gt;MaxRecords&lt;/code&gt; value, a value is returned in a &lt;code&gt;marker&lt;/code&gt; field of the response. You can retrieve the next set of records by retrying the command with the returned marker value. &lt;/p&gt; &lt;p&gt;Default: &lt;code&gt;100&lt;/code&gt; &lt;/p&gt; &lt;p&gt;Constraints: minimum 20, maximum 100.&lt;/p&gt; (optional)
     * @param marker An optional parameter that specifies the starting point to return a set of response records. When the results of a &lt;a&gt;DescribeClusterSnapshots&lt;/a&gt; request exceed the value specified in &lt;code&gt;MaxRecords&lt;/code&gt;, Amazon Web Services returns a value in the &lt;code&gt;Marker&lt;/code&gt; field of the response. You can retrieve the next set of response records by providing the returned marker value in the &lt;code&gt;Marker&lt;/code&gt; parameter and retrying the request.  (optional)
     * @param ownerAccount The Amazon Web Services account used to create or copy the snapshot. Use this field to filter the results to snapshots owned by a particular account. To describe snapshots you own, either specify your Amazon Web Services account, or do not specify the parameter. (optional)
     * @param tagKeys A tag key or keys for which you want to return all matching cluster snapshots that are associated with the specified key or keys. For example, suppose that you have snapshots that are tagged with keys called &lt;code&gt;owner&lt;/code&gt; and &lt;code&gt;environment&lt;/code&gt;. If you specify both of these tag keys in the request, Amazon Redshift returns a response with the snapshots that have either or both of these tag keys associated with them. (optional)
     * @param tagValues A tag value or values for which you want to return all matching cluster snapshots that are associated with the specified tag value or values. For example, suppose that you have snapshots that are tagged with values called &lt;code&gt;admin&lt;/code&gt; and &lt;code&gt;test&lt;/code&gt;. If you specify both of these tag values in the request, Amazon Redshift returns a response with the snapshots that have either or both of these tag values associated with them. (optional)
     * @param clusterExists &lt;p&gt;A value that indicates whether to return snapshots only for an existing cluster. You can perform table-level restore only by using a snapshot of an existing cluster, that is, a cluster that has not been deleted. Values for this parameter work as follows: &lt;/p&gt; &lt;ul&gt; &lt;li&gt; &lt;p&gt;If &lt;code&gt;ClusterExists&lt;/code&gt; is set to &lt;code&gt;true&lt;/code&gt;, &lt;code&gt;ClusterIdentifier&lt;/code&gt; is required.&lt;/p&gt; &lt;/li&gt; &lt;li&gt; &lt;p&gt;If &lt;code&gt;ClusterExists&lt;/code&gt; is set to &lt;code&gt;false&lt;/code&gt; and &lt;code&gt;ClusterIdentifier&lt;/code&gt; isn&#39;t specified, all snapshots associated with deleted clusters (orphaned snapshots) are returned. &lt;/p&gt; &lt;/li&gt; &lt;li&gt; &lt;p&gt;If &lt;code&gt;ClusterExists&lt;/code&gt; is set to &lt;code&gt;false&lt;/code&gt; and &lt;code&gt;ClusterIdentifier&lt;/code&gt; is specified for a deleted cluster, snapshots associated with that cluster are returned.&lt;/p&gt; &lt;/li&gt; &lt;li&gt; &lt;p&gt;If &lt;code&gt;ClusterExists&lt;/code&gt; is set to &lt;code&gt;false&lt;/code&gt; and &lt;code&gt;ClusterIdentifier&lt;/code&gt; is specified for an existing cluster, no snapshots are returned. &lt;/p&gt; &lt;/li&gt; &lt;/ul&gt; (optional)
     * @param sortingEntities &lt;p/&gt; (optional)
     * @return ApiResponse&lt;SnapshotMessage&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> ClusterNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> ClusterSnapshotNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 482 </td><td> InvalidTagFault </td><td>  -  </td></tr>
        <tr><td> 483 </td><td> UnsupportedOperationFault </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<SnapshotMessage> gETDescribeClusterSnapshotsWithHttpInfo(String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, String clusterIdentifier, String snapshotIdentifier, String snapshotArn, String snapshotType, OffsetDateTime startTime, OffsetDateTime endTime, Integer maxRecords, String marker, String ownerAccount, List<String> tagKeys, List<String> tagValues, Boolean clusterExists, List<GETDescribeClusterSnapshotsSortingEntitiesParameterInner> sortingEntities) throws ApiException {
        okhttp3.Call localVarCall = gETDescribeClusterSnapshotsValidateBeforeCall(action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, clusterIdentifier, snapshotIdentifier, snapshotArn, snapshotType, startTime, endTime, maxRecords, marker, ownerAccount, tagKeys, tagValues, clusterExists, sortingEntities, null);
        Type localVarReturnType = new TypeToken<SnapshotMessage>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     *  (asynchronously)
     * &lt;p&gt;Returns one or more snapshot objects, which contain metadata about your cluster snapshots. By default, this operation returns information about all snapshots of all clusters that are owned by your Amazon Web Services account. No information is returned for snapshots owned by inactive Amazon Web Services accounts.&lt;/p&gt; &lt;p&gt;If you specify both tag keys and tag values in the same request, Amazon Redshift returns all snapshots that match any combination of the specified keys and values. For example, if you have &lt;code&gt;owner&lt;/code&gt; and &lt;code&gt;environment&lt;/code&gt; for tag keys, and &lt;code&gt;admin&lt;/code&gt; and &lt;code&gt;test&lt;/code&gt; for tag values, all snapshots that have any combination of those values are returned. Only snapshots that you own are returned in the response; shared snapshots are not returned with the tag key and tag value request parameters.&lt;/p&gt; &lt;p&gt;If both tag keys and values are omitted from the request, snapshots are returned regardless of whether they have tag keys or values associated with them.&lt;/p&gt;
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param clusterIdentifier The identifier of the cluster which generated the requested snapshots. (optional)
     * @param snapshotIdentifier The snapshot identifier of the snapshot about which to return information. (optional)
     * @param snapshotArn The Amazon Resource Name (ARN) of the snapshot associated with the message to describe cluster snapshots. (optional)
     * @param snapshotType &lt;p&gt;The type of snapshots for which you are requesting information. By default, snapshots of all types are returned.&lt;/p&gt; &lt;p&gt;Valid Values: &lt;code&gt;automated&lt;/code&gt; | &lt;code&gt;manual&lt;/code&gt; &lt;/p&gt; (optional)
     * @param startTime &lt;p&gt;A value that requests only snapshots created at or after the specified time. The time value is specified in ISO 8601 format. For more information about ISO 8601, go to the &lt;a href&#x3D;\&quot;http://en.wikipedia.org/wiki/ISO_8601\&quot;&gt;ISO8601 Wikipedia page.&lt;/a&gt; &lt;/p&gt; &lt;p&gt;Example: &lt;code&gt;2012-07-16T18:00:00Z&lt;/code&gt; &lt;/p&gt; (optional)
     * @param endTime &lt;p&gt;A time value that requests only snapshots created at or before the specified time. The time value is specified in ISO 8601 format. For more information about ISO 8601, go to the &lt;a href&#x3D;\&quot;http://en.wikipedia.org/wiki/ISO_8601\&quot;&gt;ISO8601 Wikipedia page.&lt;/a&gt; &lt;/p&gt; &lt;p&gt;Example: &lt;code&gt;2012-07-16T18:00:00Z&lt;/code&gt; &lt;/p&gt; (optional)
     * @param maxRecords &lt;p&gt;The maximum number of response records to return in each call. If the number of remaining response records exceeds the specified &lt;code&gt;MaxRecords&lt;/code&gt; value, a value is returned in a &lt;code&gt;marker&lt;/code&gt; field of the response. You can retrieve the next set of records by retrying the command with the returned marker value. &lt;/p&gt; &lt;p&gt;Default: &lt;code&gt;100&lt;/code&gt; &lt;/p&gt; &lt;p&gt;Constraints: minimum 20, maximum 100.&lt;/p&gt; (optional)
     * @param marker An optional parameter that specifies the starting point to return a set of response records. When the results of a &lt;a&gt;DescribeClusterSnapshots&lt;/a&gt; request exceed the value specified in &lt;code&gt;MaxRecords&lt;/code&gt;, Amazon Web Services returns a value in the &lt;code&gt;Marker&lt;/code&gt; field of the response. You can retrieve the next set of response records by providing the returned marker value in the &lt;code&gt;Marker&lt;/code&gt; parameter and retrying the request.  (optional)
     * @param ownerAccount The Amazon Web Services account used to create or copy the snapshot. Use this field to filter the results to snapshots owned by a particular account. To describe snapshots you own, either specify your Amazon Web Services account, or do not specify the parameter. (optional)
     * @param tagKeys A tag key or keys for which you want to return all matching cluster snapshots that are associated with the specified key or keys. For example, suppose that you have snapshots that are tagged with keys called &lt;code&gt;owner&lt;/code&gt; and &lt;code&gt;environment&lt;/code&gt;. If you specify both of these tag keys in the request, Amazon Redshift returns a response with the snapshots that have either or both of these tag keys associated with them. (optional)
     * @param tagValues A tag value or values for which you want to return all matching cluster snapshots that are associated with the specified tag value or values. For example, suppose that you have snapshots that are tagged with values called &lt;code&gt;admin&lt;/code&gt; and &lt;code&gt;test&lt;/code&gt;. If you specify both of these tag values in the request, Amazon Redshift returns a response with the snapshots that have either or both of these tag values associated with them. (optional)
     * @param clusterExists &lt;p&gt;A value that indicates whether to return snapshots only for an existing cluster. You can perform table-level restore only by using a snapshot of an existing cluster, that is, a cluster that has not been deleted. Values for this parameter work as follows: &lt;/p&gt; &lt;ul&gt; &lt;li&gt; &lt;p&gt;If &lt;code&gt;ClusterExists&lt;/code&gt; is set to &lt;code&gt;true&lt;/code&gt;, &lt;code&gt;ClusterIdentifier&lt;/code&gt; is required.&lt;/p&gt; &lt;/li&gt; &lt;li&gt; &lt;p&gt;If &lt;code&gt;ClusterExists&lt;/code&gt; is set to &lt;code&gt;false&lt;/code&gt; and &lt;code&gt;ClusterIdentifier&lt;/code&gt; isn&#39;t specified, all snapshots associated with deleted clusters (orphaned snapshots) are returned. &lt;/p&gt; &lt;/li&gt; &lt;li&gt; &lt;p&gt;If &lt;code&gt;ClusterExists&lt;/code&gt; is set to &lt;code&gt;false&lt;/code&gt; and &lt;code&gt;ClusterIdentifier&lt;/code&gt; is specified for a deleted cluster, snapshots associated with that cluster are returned.&lt;/p&gt; &lt;/li&gt; &lt;li&gt; &lt;p&gt;If &lt;code&gt;ClusterExists&lt;/code&gt; is set to &lt;code&gt;false&lt;/code&gt; and &lt;code&gt;ClusterIdentifier&lt;/code&gt; is specified for an existing cluster, no snapshots are returned. &lt;/p&gt; &lt;/li&gt; &lt;/ul&gt; (optional)
     * @param sortingEntities &lt;p/&gt; (optional)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> ClusterNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> ClusterSnapshotNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 482 </td><td> InvalidTagFault </td><td>  -  </td></tr>
        <tr><td> 483 </td><td> UnsupportedOperationFault </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call gETDescribeClusterSnapshotsAsync(String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, String clusterIdentifier, String snapshotIdentifier, String snapshotArn, String snapshotType, OffsetDateTime startTime, OffsetDateTime endTime, Integer maxRecords, String marker, String ownerAccount, List<String> tagKeys, List<String> tagValues, Boolean clusterExists, List<GETDescribeClusterSnapshotsSortingEntitiesParameterInner> sortingEntities, final ApiCallback<SnapshotMessage> _callback) throws ApiException {

        okhttp3.Call localVarCall = gETDescribeClusterSnapshotsValidateBeforeCall(action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, clusterIdentifier, snapshotIdentifier, snapshotArn, snapshotType, startTime, endTime, maxRecords, marker, ownerAccount, tagKeys, tagValues, clusterExists, sortingEntities, _callback);
        Type localVarReturnType = new TypeToken<SnapshotMessage>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for gETDescribeClusterSubnetGroups
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param clusterSubnetGroupName The name of the cluster subnet group for which information is requested. (optional)
     * @param maxRecords &lt;p&gt;The maximum number of response records to return in each call. If the number of remaining response records exceeds the specified &lt;code&gt;MaxRecords&lt;/code&gt; value, a value is returned in a &lt;code&gt;marker&lt;/code&gt; field of the response. You can retrieve the next set of records by retrying the command with the returned marker value. &lt;/p&gt; &lt;p&gt;Default: &lt;code&gt;100&lt;/code&gt; &lt;/p&gt; &lt;p&gt;Constraints: minimum 20, maximum 100.&lt;/p&gt; (optional)
     * @param marker An optional parameter that specifies the starting point to return a set of response records. When the results of a &lt;a&gt;DescribeClusterSubnetGroups&lt;/a&gt; request exceed the value specified in &lt;code&gt;MaxRecords&lt;/code&gt;, Amazon Web Services returns a value in the &lt;code&gt;Marker&lt;/code&gt; field of the response. You can retrieve the next set of response records by providing the returned marker value in the &lt;code&gt;Marker&lt;/code&gt; parameter and retrying the request.  (optional)
     * @param tagKeys A tag key or keys for which you want to return all matching cluster subnet groups that are associated with the specified key or keys. For example, suppose that you have subnet groups that are tagged with keys called &lt;code&gt;owner&lt;/code&gt; and &lt;code&gt;environment&lt;/code&gt;. If you specify both of these tag keys in the request, Amazon Redshift returns a response with the subnet groups that have either or both of these tag keys associated with them. (optional)
     * @param tagValues A tag value or values for which you want to return all matching cluster subnet groups that are associated with the specified tag value or values. For example, suppose that you have subnet groups that are tagged with values called &lt;code&gt;admin&lt;/code&gt; and &lt;code&gt;test&lt;/code&gt;. If you specify both of these tag values in the request, Amazon Redshift returns a response with the subnet groups that have either or both of these tag values associated with them. (optional)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> ClusterSubnetGroupNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> InvalidTagFault </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call gETDescribeClusterSubnetGroupsCall(String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, String clusterSubnetGroupName, Integer maxRecords, String marker, List<String> tagKeys, List<String> tagValues, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/#Action=DescribeClusterSubnetGroups";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (clusterSubnetGroupName != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("ClusterSubnetGroupName", clusterSubnetGroupName));
        }

        if (maxRecords != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("MaxRecords", maxRecords));
        }

        if (marker != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("Marker", marker));
        }

        if (tagKeys != null) {
            localVarCollectionQueryParams.addAll(localVarApiClient.parameterToPairs("multi", "TagKeys", tagKeys));
        }

        if (tagValues != null) {
            localVarCollectionQueryParams.addAll(localVarApiClient.parameterToPairs("multi", "TagValues", tagValues));
        }

        if (action != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("Action", action));
        }

        if (version != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("Version", version));
        }

        if (xAmzContentSha256 != null) {
            localVarHeaderParams.put("X-Amz-Content-Sha256", localVarApiClient.parameterToString(xAmzContentSha256));
        }

        if (xAmzDate != null) {
            localVarHeaderParams.put("X-Amz-Date", localVarApiClient.parameterToString(xAmzDate));
        }

        if (xAmzAlgorithm != null) {
            localVarHeaderParams.put("X-Amz-Algorithm", localVarApiClient.parameterToString(xAmzAlgorithm));
        }

        if (xAmzCredential != null) {
            localVarHeaderParams.put("X-Amz-Credential", localVarApiClient.parameterToString(xAmzCredential));
        }

        if (xAmzSecurityToken != null) {
            localVarHeaderParams.put("X-Amz-Security-Token", localVarApiClient.parameterToString(xAmzSecurityToken));
        }

        if (xAmzSignature != null) {
            localVarHeaderParams.put("X-Amz-Signature", localVarApiClient.parameterToString(xAmzSignature));
        }

        if (xAmzSignedHeaders != null) {
            localVarHeaderParams.put("X-Amz-SignedHeaders", localVarApiClient.parameterToString(xAmzSignedHeaders));
        }

        final String[] localVarAccepts = {
            "text/xml"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "hmac" };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call gETDescribeClusterSubnetGroupsValidateBeforeCall(String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, String clusterSubnetGroupName, Integer maxRecords, String marker, List<String> tagKeys, List<String> tagValues, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'action' is set
        if (action == null) {
            throw new ApiException("Missing the required parameter 'action' when calling gETDescribeClusterSubnetGroups(Async)");
        }

        // verify the required parameter 'version' is set
        if (version == null) {
            throw new ApiException("Missing the required parameter 'version' when calling gETDescribeClusterSubnetGroups(Async)");
        }

        return gETDescribeClusterSubnetGroupsCall(action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, clusterSubnetGroupName, maxRecords, marker, tagKeys, tagValues, _callback);

    }

    /**
     * 
     * &lt;p&gt;Returns one or more cluster subnet group objects, which contain metadata about your cluster subnet groups. By default, this operation returns information about all cluster subnet groups that are defined in your Amazon Web Services account.&lt;/p&gt; &lt;p&gt;If you specify both tag keys and tag values in the same request, Amazon Redshift returns all subnet groups that match any combination of the specified keys and values. For example, if you have &lt;code&gt;owner&lt;/code&gt; and &lt;code&gt;environment&lt;/code&gt; for tag keys, and &lt;code&gt;admin&lt;/code&gt; and &lt;code&gt;test&lt;/code&gt; for tag values, all subnet groups that have any combination of those values are returned.&lt;/p&gt; &lt;p&gt;If both tag keys and values are omitted from the request, subnet groups are returned regardless of whether they have tag keys or values associated with them.&lt;/p&gt;
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param clusterSubnetGroupName The name of the cluster subnet group for which information is requested. (optional)
     * @param maxRecords &lt;p&gt;The maximum number of response records to return in each call. If the number of remaining response records exceeds the specified &lt;code&gt;MaxRecords&lt;/code&gt; value, a value is returned in a &lt;code&gt;marker&lt;/code&gt; field of the response. You can retrieve the next set of records by retrying the command with the returned marker value. &lt;/p&gt; &lt;p&gt;Default: &lt;code&gt;100&lt;/code&gt; &lt;/p&gt; &lt;p&gt;Constraints: minimum 20, maximum 100.&lt;/p&gt; (optional)
     * @param marker An optional parameter that specifies the starting point to return a set of response records. When the results of a &lt;a&gt;DescribeClusterSubnetGroups&lt;/a&gt; request exceed the value specified in &lt;code&gt;MaxRecords&lt;/code&gt;, Amazon Web Services returns a value in the &lt;code&gt;Marker&lt;/code&gt; field of the response. You can retrieve the next set of response records by providing the returned marker value in the &lt;code&gt;Marker&lt;/code&gt; parameter and retrying the request.  (optional)
     * @param tagKeys A tag key or keys for which you want to return all matching cluster subnet groups that are associated with the specified key or keys. For example, suppose that you have subnet groups that are tagged with keys called &lt;code&gt;owner&lt;/code&gt; and &lt;code&gt;environment&lt;/code&gt;. If you specify both of these tag keys in the request, Amazon Redshift returns a response with the subnet groups that have either or both of these tag keys associated with them. (optional)
     * @param tagValues A tag value or values for which you want to return all matching cluster subnet groups that are associated with the specified tag value or values. For example, suppose that you have subnet groups that are tagged with values called &lt;code&gt;admin&lt;/code&gt; and &lt;code&gt;test&lt;/code&gt;. If you specify both of these tag values in the request, Amazon Redshift returns a response with the subnet groups that have either or both of these tag values associated with them. (optional)
     * @return ClusterSubnetGroupMessage
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> ClusterSubnetGroupNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> InvalidTagFault </td><td>  -  </td></tr>
     </table>
     */
    public ClusterSubnetGroupMessage gETDescribeClusterSubnetGroups(String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, String clusterSubnetGroupName, Integer maxRecords, String marker, List<String> tagKeys, List<String> tagValues) throws ApiException {
        ApiResponse<ClusterSubnetGroupMessage> localVarResp = gETDescribeClusterSubnetGroupsWithHttpInfo(action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, clusterSubnetGroupName, maxRecords, marker, tagKeys, tagValues);
        return localVarResp.getData();
    }

    /**
     * 
     * &lt;p&gt;Returns one or more cluster subnet group objects, which contain metadata about your cluster subnet groups. By default, this operation returns information about all cluster subnet groups that are defined in your Amazon Web Services account.&lt;/p&gt; &lt;p&gt;If you specify both tag keys and tag values in the same request, Amazon Redshift returns all subnet groups that match any combination of the specified keys and values. For example, if you have &lt;code&gt;owner&lt;/code&gt; and &lt;code&gt;environment&lt;/code&gt; for tag keys, and &lt;code&gt;admin&lt;/code&gt; and &lt;code&gt;test&lt;/code&gt; for tag values, all subnet groups that have any combination of those values are returned.&lt;/p&gt; &lt;p&gt;If both tag keys and values are omitted from the request, subnet groups are returned regardless of whether they have tag keys or values associated with them.&lt;/p&gt;
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param clusterSubnetGroupName The name of the cluster subnet group for which information is requested. (optional)
     * @param maxRecords &lt;p&gt;The maximum number of response records to return in each call. If the number of remaining response records exceeds the specified &lt;code&gt;MaxRecords&lt;/code&gt; value, a value is returned in a &lt;code&gt;marker&lt;/code&gt; field of the response. You can retrieve the next set of records by retrying the command with the returned marker value. &lt;/p&gt; &lt;p&gt;Default: &lt;code&gt;100&lt;/code&gt; &lt;/p&gt; &lt;p&gt;Constraints: minimum 20, maximum 100.&lt;/p&gt; (optional)
     * @param marker An optional parameter that specifies the starting point to return a set of response records. When the results of a &lt;a&gt;DescribeClusterSubnetGroups&lt;/a&gt; request exceed the value specified in &lt;code&gt;MaxRecords&lt;/code&gt;, Amazon Web Services returns a value in the &lt;code&gt;Marker&lt;/code&gt; field of the response. You can retrieve the next set of response records by providing the returned marker value in the &lt;code&gt;Marker&lt;/code&gt; parameter and retrying the request.  (optional)
     * @param tagKeys A tag key or keys for which you want to return all matching cluster subnet groups that are associated with the specified key or keys. For example, suppose that you have subnet groups that are tagged with keys called &lt;code&gt;owner&lt;/code&gt; and &lt;code&gt;environment&lt;/code&gt;. If you specify both of these tag keys in the request, Amazon Redshift returns a response with the subnet groups that have either or both of these tag keys associated with them. (optional)
     * @param tagValues A tag value or values for which you want to return all matching cluster subnet groups that are associated with the specified tag value or values. For example, suppose that you have subnet groups that are tagged with values called &lt;code&gt;admin&lt;/code&gt; and &lt;code&gt;test&lt;/code&gt;. If you specify both of these tag values in the request, Amazon Redshift returns a response with the subnet groups that have either or both of these tag values associated with them. (optional)
     * @return ApiResponse&lt;ClusterSubnetGroupMessage&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> ClusterSubnetGroupNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> InvalidTagFault </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<ClusterSubnetGroupMessage> gETDescribeClusterSubnetGroupsWithHttpInfo(String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, String clusterSubnetGroupName, Integer maxRecords, String marker, List<String> tagKeys, List<String> tagValues) throws ApiException {
        okhttp3.Call localVarCall = gETDescribeClusterSubnetGroupsValidateBeforeCall(action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, clusterSubnetGroupName, maxRecords, marker, tagKeys, tagValues, null);
        Type localVarReturnType = new TypeToken<ClusterSubnetGroupMessage>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     *  (asynchronously)
     * &lt;p&gt;Returns one or more cluster subnet group objects, which contain metadata about your cluster subnet groups. By default, this operation returns information about all cluster subnet groups that are defined in your Amazon Web Services account.&lt;/p&gt; &lt;p&gt;If you specify both tag keys and tag values in the same request, Amazon Redshift returns all subnet groups that match any combination of the specified keys and values. For example, if you have &lt;code&gt;owner&lt;/code&gt; and &lt;code&gt;environment&lt;/code&gt; for tag keys, and &lt;code&gt;admin&lt;/code&gt; and &lt;code&gt;test&lt;/code&gt; for tag values, all subnet groups that have any combination of those values are returned.&lt;/p&gt; &lt;p&gt;If both tag keys and values are omitted from the request, subnet groups are returned regardless of whether they have tag keys or values associated with them.&lt;/p&gt;
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param clusterSubnetGroupName The name of the cluster subnet group for which information is requested. (optional)
     * @param maxRecords &lt;p&gt;The maximum number of response records to return in each call. If the number of remaining response records exceeds the specified &lt;code&gt;MaxRecords&lt;/code&gt; value, a value is returned in a &lt;code&gt;marker&lt;/code&gt; field of the response. You can retrieve the next set of records by retrying the command with the returned marker value. &lt;/p&gt; &lt;p&gt;Default: &lt;code&gt;100&lt;/code&gt; &lt;/p&gt; &lt;p&gt;Constraints: minimum 20, maximum 100.&lt;/p&gt; (optional)
     * @param marker An optional parameter that specifies the starting point to return a set of response records. When the results of a &lt;a&gt;DescribeClusterSubnetGroups&lt;/a&gt; request exceed the value specified in &lt;code&gt;MaxRecords&lt;/code&gt;, Amazon Web Services returns a value in the &lt;code&gt;Marker&lt;/code&gt; field of the response. You can retrieve the next set of response records by providing the returned marker value in the &lt;code&gt;Marker&lt;/code&gt; parameter and retrying the request.  (optional)
     * @param tagKeys A tag key or keys for which you want to return all matching cluster subnet groups that are associated with the specified key or keys. For example, suppose that you have subnet groups that are tagged with keys called &lt;code&gt;owner&lt;/code&gt; and &lt;code&gt;environment&lt;/code&gt;. If you specify both of these tag keys in the request, Amazon Redshift returns a response with the subnet groups that have either or both of these tag keys associated with them. (optional)
     * @param tagValues A tag value or values for which you want to return all matching cluster subnet groups that are associated with the specified tag value or values. For example, suppose that you have subnet groups that are tagged with values called &lt;code&gt;admin&lt;/code&gt; and &lt;code&gt;test&lt;/code&gt;. If you specify both of these tag values in the request, Amazon Redshift returns a response with the subnet groups that have either or both of these tag values associated with them. (optional)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> ClusterSubnetGroupNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> InvalidTagFault </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call gETDescribeClusterSubnetGroupsAsync(String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, String clusterSubnetGroupName, Integer maxRecords, String marker, List<String> tagKeys, List<String> tagValues, final ApiCallback<ClusterSubnetGroupMessage> _callback) throws ApiException {

        okhttp3.Call localVarCall = gETDescribeClusterSubnetGroupsValidateBeforeCall(action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, clusterSubnetGroupName, maxRecords, marker, tagKeys, tagValues, _callback);
        Type localVarReturnType = new TypeToken<ClusterSubnetGroupMessage>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for gETDescribeClusterTracks
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param maintenanceTrackName The name of the maintenance track.  (optional)
     * @param maxRecords An integer value for the maximum number of maintenance tracks to return. (optional)
     * @param marker An optional parameter that specifies the starting point to return a set of response records. When the results of a &lt;code&gt;DescribeClusterTracks&lt;/code&gt; request exceed the value specified in &lt;code&gt;MaxRecords&lt;/code&gt;, Amazon Redshift returns a value in the &lt;code&gt;Marker&lt;/code&gt; field of the response. You can retrieve the next set of response records by providing the returned marker value in the &lt;code&gt;Marker&lt;/code&gt; parameter and retrying the request.  (optional)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> InvalidClusterTrackFault </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> UnauthorizedOperation </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call gETDescribeClusterTracksCall(String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, String maintenanceTrackName, Integer maxRecords, String marker, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/#Action=DescribeClusterTracks";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (maintenanceTrackName != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("MaintenanceTrackName", maintenanceTrackName));
        }

        if (maxRecords != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("MaxRecords", maxRecords));
        }

        if (marker != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("Marker", marker));
        }

        if (action != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("Action", action));
        }

        if (version != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("Version", version));
        }

        if (xAmzContentSha256 != null) {
            localVarHeaderParams.put("X-Amz-Content-Sha256", localVarApiClient.parameterToString(xAmzContentSha256));
        }

        if (xAmzDate != null) {
            localVarHeaderParams.put("X-Amz-Date", localVarApiClient.parameterToString(xAmzDate));
        }

        if (xAmzAlgorithm != null) {
            localVarHeaderParams.put("X-Amz-Algorithm", localVarApiClient.parameterToString(xAmzAlgorithm));
        }

        if (xAmzCredential != null) {
            localVarHeaderParams.put("X-Amz-Credential", localVarApiClient.parameterToString(xAmzCredential));
        }

        if (xAmzSecurityToken != null) {
            localVarHeaderParams.put("X-Amz-Security-Token", localVarApiClient.parameterToString(xAmzSecurityToken));
        }

        if (xAmzSignature != null) {
            localVarHeaderParams.put("X-Amz-Signature", localVarApiClient.parameterToString(xAmzSignature));
        }

        if (xAmzSignedHeaders != null) {
            localVarHeaderParams.put("X-Amz-SignedHeaders", localVarApiClient.parameterToString(xAmzSignedHeaders));
        }

        final String[] localVarAccepts = {
            "text/xml"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "hmac" };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call gETDescribeClusterTracksValidateBeforeCall(String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, String maintenanceTrackName, Integer maxRecords, String marker, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'action' is set
        if (action == null) {
            throw new ApiException("Missing the required parameter 'action' when calling gETDescribeClusterTracks(Async)");
        }

        // verify the required parameter 'version' is set
        if (version == null) {
            throw new ApiException("Missing the required parameter 'version' when calling gETDescribeClusterTracks(Async)");
        }

        return gETDescribeClusterTracksCall(action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, maintenanceTrackName, maxRecords, marker, _callback);

    }

    /**
     * 
     * Returns a list of all the available maintenance tracks.
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param maintenanceTrackName The name of the maintenance track.  (optional)
     * @param maxRecords An integer value for the maximum number of maintenance tracks to return. (optional)
     * @param marker An optional parameter that specifies the starting point to return a set of response records. When the results of a &lt;code&gt;DescribeClusterTracks&lt;/code&gt; request exceed the value specified in &lt;code&gt;MaxRecords&lt;/code&gt;, Amazon Redshift returns a value in the &lt;code&gt;Marker&lt;/code&gt; field of the response. You can retrieve the next set of response records by providing the returned marker value in the &lt;code&gt;Marker&lt;/code&gt; parameter and retrying the request.  (optional)
     * @return TrackListMessage
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> InvalidClusterTrackFault </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> UnauthorizedOperation </td><td>  -  </td></tr>
     </table>
     */
    public TrackListMessage gETDescribeClusterTracks(String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, String maintenanceTrackName, Integer maxRecords, String marker) throws ApiException {
        ApiResponse<TrackListMessage> localVarResp = gETDescribeClusterTracksWithHttpInfo(action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, maintenanceTrackName, maxRecords, marker);
        return localVarResp.getData();
    }

    /**
     * 
     * Returns a list of all the available maintenance tracks.
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param maintenanceTrackName The name of the maintenance track.  (optional)
     * @param maxRecords An integer value for the maximum number of maintenance tracks to return. (optional)
     * @param marker An optional parameter that specifies the starting point to return a set of response records. When the results of a &lt;code&gt;DescribeClusterTracks&lt;/code&gt; request exceed the value specified in &lt;code&gt;MaxRecords&lt;/code&gt;, Amazon Redshift returns a value in the &lt;code&gt;Marker&lt;/code&gt; field of the response. You can retrieve the next set of response records by providing the returned marker value in the &lt;code&gt;Marker&lt;/code&gt; parameter and retrying the request.  (optional)
     * @return ApiResponse&lt;TrackListMessage&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> InvalidClusterTrackFault </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> UnauthorizedOperation </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<TrackListMessage> gETDescribeClusterTracksWithHttpInfo(String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, String maintenanceTrackName, Integer maxRecords, String marker) throws ApiException {
        okhttp3.Call localVarCall = gETDescribeClusterTracksValidateBeforeCall(action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, maintenanceTrackName, maxRecords, marker, null);
        Type localVarReturnType = new TypeToken<TrackListMessage>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     *  (asynchronously)
     * Returns a list of all the available maintenance tracks.
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param maintenanceTrackName The name of the maintenance track.  (optional)
     * @param maxRecords An integer value for the maximum number of maintenance tracks to return. (optional)
     * @param marker An optional parameter that specifies the starting point to return a set of response records. When the results of a &lt;code&gt;DescribeClusterTracks&lt;/code&gt; request exceed the value specified in &lt;code&gt;MaxRecords&lt;/code&gt;, Amazon Redshift returns a value in the &lt;code&gt;Marker&lt;/code&gt; field of the response. You can retrieve the next set of response records by providing the returned marker value in the &lt;code&gt;Marker&lt;/code&gt; parameter and retrying the request.  (optional)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> InvalidClusterTrackFault </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> UnauthorizedOperation </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call gETDescribeClusterTracksAsync(String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, String maintenanceTrackName, Integer maxRecords, String marker, final ApiCallback<TrackListMessage> _callback) throws ApiException {

        okhttp3.Call localVarCall = gETDescribeClusterTracksValidateBeforeCall(action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, maintenanceTrackName, maxRecords, marker, _callback);
        Type localVarReturnType = new TypeToken<TrackListMessage>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for gETDescribeClusterVersions
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param clusterVersion &lt;p&gt;The specific cluster version to return.&lt;/p&gt; &lt;p&gt;Example: &lt;code&gt;1.0&lt;/code&gt; &lt;/p&gt; (optional)
     * @param clusterParameterGroupFamily &lt;p&gt;The name of a specific cluster parameter group family to return details for.&lt;/p&gt; &lt;p&gt;Constraints:&lt;/p&gt; &lt;ul&gt; &lt;li&gt; &lt;p&gt;Must be 1 to 255 alphanumeric characters&lt;/p&gt; &lt;/li&gt; &lt;li&gt; &lt;p&gt;First character must be a letter&lt;/p&gt; &lt;/li&gt; &lt;li&gt; &lt;p&gt;Cannot end with a hyphen or contain two consecutive hyphens&lt;/p&gt; &lt;/li&gt; &lt;/ul&gt; (optional)
     * @param maxRecords &lt;p&gt;The maximum number of response records to return in each call. If the number of remaining response records exceeds the specified &lt;code&gt;MaxRecords&lt;/code&gt; value, a value is returned in a &lt;code&gt;marker&lt;/code&gt; field of the response. You can retrieve the next set of records by retrying the command with the returned marker value. &lt;/p&gt; &lt;p&gt;Default: &lt;code&gt;100&lt;/code&gt; &lt;/p&gt; &lt;p&gt;Constraints: minimum 20, maximum 100.&lt;/p&gt; (optional)
     * @param marker An optional parameter that specifies the starting point to return a set of response records. When the results of a &lt;a&gt;DescribeClusterVersions&lt;/a&gt; request exceed the value specified in &lt;code&gt;MaxRecords&lt;/code&gt;, Amazon Web Services returns a value in the &lt;code&gt;Marker&lt;/code&gt; field of the response. You can retrieve the next set of response records by providing the returned marker value in the &lt;code&gt;Marker&lt;/code&gt; parameter and retrying the request.  (optional)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call gETDescribeClusterVersionsCall(String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, String clusterVersion, String clusterParameterGroupFamily, Integer maxRecords, String marker, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/#Action=DescribeClusterVersions";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (clusterVersion != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("ClusterVersion", clusterVersion));
        }

        if (clusterParameterGroupFamily != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("ClusterParameterGroupFamily", clusterParameterGroupFamily));
        }

        if (maxRecords != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("MaxRecords", maxRecords));
        }

        if (marker != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("Marker", marker));
        }

        if (action != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("Action", action));
        }

        if (version != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("Version", version));
        }

        if (xAmzContentSha256 != null) {
            localVarHeaderParams.put("X-Amz-Content-Sha256", localVarApiClient.parameterToString(xAmzContentSha256));
        }

        if (xAmzDate != null) {
            localVarHeaderParams.put("X-Amz-Date", localVarApiClient.parameterToString(xAmzDate));
        }

        if (xAmzAlgorithm != null) {
            localVarHeaderParams.put("X-Amz-Algorithm", localVarApiClient.parameterToString(xAmzAlgorithm));
        }

        if (xAmzCredential != null) {
            localVarHeaderParams.put("X-Amz-Credential", localVarApiClient.parameterToString(xAmzCredential));
        }

        if (xAmzSecurityToken != null) {
            localVarHeaderParams.put("X-Amz-Security-Token", localVarApiClient.parameterToString(xAmzSecurityToken));
        }

        if (xAmzSignature != null) {
            localVarHeaderParams.put("X-Amz-Signature", localVarApiClient.parameterToString(xAmzSignature));
        }

        if (xAmzSignedHeaders != null) {
            localVarHeaderParams.put("X-Amz-SignedHeaders", localVarApiClient.parameterToString(xAmzSignedHeaders));
        }

        final String[] localVarAccepts = {
            "text/xml"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "hmac" };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call gETDescribeClusterVersionsValidateBeforeCall(String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, String clusterVersion, String clusterParameterGroupFamily, Integer maxRecords, String marker, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'action' is set
        if (action == null) {
            throw new ApiException("Missing the required parameter 'action' when calling gETDescribeClusterVersions(Async)");
        }

        // verify the required parameter 'version' is set
        if (version == null) {
            throw new ApiException("Missing the required parameter 'version' when calling gETDescribeClusterVersions(Async)");
        }

        return gETDescribeClusterVersionsCall(action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, clusterVersion, clusterParameterGroupFamily, maxRecords, marker, _callback);

    }

    /**
     * 
     * Returns descriptions of the available Amazon Redshift cluster versions. You can call this operation even before creating any clusters to learn more about the Amazon Redshift versions. For more information about managing clusters, go to &lt;a href&#x3D;\&quot;https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html\&quot;&gt;Amazon Redshift Clusters&lt;/a&gt; in the &lt;i&gt;Amazon Redshift Cluster Management Guide&lt;/i&gt;.
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param clusterVersion &lt;p&gt;The specific cluster version to return.&lt;/p&gt; &lt;p&gt;Example: &lt;code&gt;1.0&lt;/code&gt; &lt;/p&gt; (optional)
     * @param clusterParameterGroupFamily &lt;p&gt;The name of a specific cluster parameter group family to return details for.&lt;/p&gt; &lt;p&gt;Constraints:&lt;/p&gt; &lt;ul&gt; &lt;li&gt; &lt;p&gt;Must be 1 to 255 alphanumeric characters&lt;/p&gt; &lt;/li&gt; &lt;li&gt; &lt;p&gt;First character must be a letter&lt;/p&gt; &lt;/li&gt; &lt;li&gt; &lt;p&gt;Cannot end with a hyphen or contain two consecutive hyphens&lt;/p&gt; &lt;/li&gt; &lt;/ul&gt; (optional)
     * @param maxRecords &lt;p&gt;The maximum number of response records to return in each call. If the number of remaining response records exceeds the specified &lt;code&gt;MaxRecords&lt;/code&gt; value, a value is returned in a &lt;code&gt;marker&lt;/code&gt; field of the response. You can retrieve the next set of records by retrying the command with the returned marker value. &lt;/p&gt; &lt;p&gt;Default: &lt;code&gt;100&lt;/code&gt; &lt;/p&gt; &lt;p&gt;Constraints: minimum 20, maximum 100.&lt;/p&gt; (optional)
     * @param marker An optional parameter that specifies the starting point to return a set of response records. When the results of a &lt;a&gt;DescribeClusterVersions&lt;/a&gt; request exceed the value specified in &lt;code&gt;MaxRecords&lt;/code&gt;, Amazon Web Services returns a value in the &lt;code&gt;Marker&lt;/code&gt; field of the response. You can retrieve the next set of response records by providing the returned marker value in the &lt;code&gt;Marker&lt;/code&gt; parameter and retrying the request.  (optional)
     * @return ClusterVersionsMessage
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
     </table>
     */
    public ClusterVersionsMessage gETDescribeClusterVersions(String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, String clusterVersion, String clusterParameterGroupFamily, Integer maxRecords, String marker) throws ApiException {
        ApiResponse<ClusterVersionsMessage> localVarResp = gETDescribeClusterVersionsWithHttpInfo(action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, clusterVersion, clusterParameterGroupFamily, maxRecords, marker);
        return localVarResp.getData();
    }

    /**
     * 
     * Returns descriptions of the available Amazon Redshift cluster versions. You can call this operation even before creating any clusters to learn more about the Amazon Redshift versions. For more information about managing clusters, go to &lt;a href&#x3D;\&quot;https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html\&quot;&gt;Amazon Redshift Clusters&lt;/a&gt; in the &lt;i&gt;Amazon Redshift Cluster Management Guide&lt;/i&gt;.
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param clusterVersion &lt;p&gt;The specific cluster version to return.&lt;/p&gt; &lt;p&gt;Example: &lt;code&gt;1.0&lt;/code&gt; &lt;/p&gt; (optional)
     * @param clusterParameterGroupFamily &lt;p&gt;The name of a specific cluster parameter group family to return details for.&lt;/p&gt; &lt;p&gt;Constraints:&lt;/p&gt; &lt;ul&gt; &lt;li&gt; &lt;p&gt;Must be 1 to 255 alphanumeric characters&lt;/p&gt; &lt;/li&gt; &lt;li&gt; &lt;p&gt;First character must be a letter&lt;/p&gt; &lt;/li&gt; &lt;li&gt; &lt;p&gt;Cannot end with a hyphen or contain two consecutive hyphens&lt;/p&gt; &lt;/li&gt; &lt;/ul&gt; (optional)
     * @param maxRecords &lt;p&gt;The maximum number of response records to return in each call. If the number of remaining response records exceeds the specified &lt;code&gt;MaxRecords&lt;/code&gt; value, a value is returned in a &lt;code&gt;marker&lt;/code&gt; field of the response. You can retrieve the next set of records by retrying the command with the returned marker value. &lt;/p&gt; &lt;p&gt;Default: &lt;code&gt;100&lt;/code&gt; &lt;/p&gt; &lt;p&gt;Constraints: minimum 20, maximum 100.&lt;/p&gt; (optional)
     * @param marker An optional parameter that specifies the starting point to return a set of response records. When the results of a &lt;a&gt;DescribeClusterVersions&lt;/a&gt; request exceed the value specified in &lt;code&gt;MaxRecords&lt;/code&gt;, Amazon Web Services returns a value in the &lt;code&gt;Marker&lt;/code&gt; field of the response. You can retrieve the next set of response records by providing the returned marker value in the &lt;code&gt;Marker&lt;/code&gt; parameter and retrying the request.  (optional)
     * @return ApiResponse&lt;ClusterVersionsMessage&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<ClusterVersionsMessage> gETDescribeClusterVersionsWithHttpInfo(String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, String clusterVersion, String clusterParameterGroupFamily, Integer maxRecords, String marker) throws ApiException {
        okhttp3.Call localVarCall = gETDescribeClusterVersionsValidateBeforeCall(action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, clusterVersion, clusterParameterGroupFamily, maxRecords, marker, null);
        Type localVarReturnType = new TypeToken<ClusterVersionsMessage>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     *  (asynchronously)
     * Returns descriptions of the available Amazon Redshift cluster versions. You can call this operation even before creating any clusters to learn more about the Amazon Redshift versions. For more information about managing clusters, go to &lt;a href&#x3D;\&quot;https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html\&quot;&gt;Amazon Redshift Clusters&lt;/a&gt; in the &lt;i&gt;Amazon Redshift Cluster Management Guide&lt;/i&gt;.
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param clusterVersion &lt;p&gt;The specific cluster version to return.&lt;/p&gt; &lt;p&gt;Example: &lt;code&gt;1.0&lt;/code&gt; &lt;/p&gt; (optional)
     * @param clusterParameterGroupFamily &lt;p&gt;The name of a specific cluster parameter group family to return details for.&lt;/p&gt; &lt;p&gt;Constraints:&lt;/p&gt; &lt;ul&gt; &lt;li&gt; &lt;p&gt;Must be 1 to 255 alphanumeric characters&lt;/p&gt; &lt;/li&gt; &lt;li&gt; &lt;p&gt;First character must be a letter&lt;/p&gt; &lt;/li&gt; &lt;li&gt; &lt;p&gt;Cannot end with a hyphen or contain two consecutive hyphens&lt;/p&gt; &lt;/li&gt; &lt;/ul&gt; (optional)
     * @param maxRecords &lt;p&gt;The maximum number of response records to return in each call. If the number of remaining response records exceeds the specified &lt;code&gt;MaxRecords&lt;/code&gt; value, a value is returned in a &lt;code&gt;marker&lt;/code&gt; field of the response. You can retrieve the next set of records by retrying the command with the returned marker value. &lt;/p&gt; &lt;p&gt;Default: &lt;code&gt;100&lt;/code&gt; &lt;/p&gt; &lt;p&gt;Constraints: minimum 20, maximum 100.&lt;/p&gt; (optional)
     * @param marker An optional parameter that specifies the starting point to return a set of response records. When the results of a &lt;a&gt;DescribeClusterVersions&lt;/a&gt; request exceed the value specified in &lt;code&gt;MaxRecords&lt;/code&gt;, Amazon Web Services returns a value in the &lt;code&gt;Marker&lt;/code&gt; field of the response. You can retrieve the next set of response records by providing the returned marker value in the &lt;code&gt;Marker&lt;/code&gt; parameter and retrying the request.  (optional)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call gETDescribeClusterVersionsAsync(String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, String clusterVersion, String clusterParameterGroupFamily, Integer maxRecords, String marker, final ApiCallback<ClusterVersionsMessage> _callback) throws ApiException {

        okhttp3.Call localVarCall = gETDescribeClusterVersionsValidateBeforeCall(action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, clusterVersion, clusterParameterGroupFamily, maxRecords, marker, _callback);
        Type localVarReturnType = new TypeToken<ClusterVersionsMessage>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for gETDescribeClusters
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param clusterIdentifier &lt;p&gt;The unique identifier of a cluster whose properties you are requesting. This parameter is case sensitive.&lt;/p&gt; &lt;p&gt;The default is that all clusters defined for an account are returned.&lt;/p&gt; (optional)
     * @param maxRecords &lt;p&gt;The maximum number of response records to return in each call. If the number of remaining response records exceeds the specified &lt;code&gt;MaxRecords&lt;/code&gt; value, a value is returned in a &lt;code&gt;marker&lt;/code&gt; field of the response. You can retrieve the next set of records by retrying the command with the returned marker value. &lt;/p&gt; &lt;p&gt;Default: &lt;code&gt;100&lt;/code&gt; &lt;/p&gt; &lt;p&gt;Constraints: minimum 20, maximum 100.&lt;/p&gt; (optional)
     * @param marker &lt;p&gt;An optional parameter that specifies the starting point to return a set of response records. When the results of a &lt;a&gt;DescribeClusters&lt;/a&gt; request exceed the value specified in &lt;code&gt;MaxRecords&lt;/code&gt;, Amazon Web Services returns a value in the &lt;code&gt;Marker&lt;/code&gt; field of the response. You can retrieve the next set of response records by providing the returned marker value in the &lt;code&gt;Marker&lt;/code&gt; parameter and retrying the request. &lt;/p&gt; &lt;p&gt;Constraints: You can specify either the &lt;b&gt;ClusterIdentifier&lt;/b&gt; parameter or the &lt;b&gt;Marker&lt;/b&gt; parameter, but not both. &lt;/p&gt; (optional)
     * @param tagKeys A tag key or keys for which you want to return all matching clusters that are associated with the specified key or keys. For example, suppose that you have clusters that are tagged with keys called &lt;code&gt;owner&lt;/code&gt; and &lt;code&gt;environment&lt;/code&gt;. If you specify both of these tag keys in the request, Amazon Redshift returns a response with the clusters that have either or both of these tag keys associated with them. (optional)
     * @param tagValues A tag value or values for which you want to return all matching clusters that are associated with the specified tag value or values. For example, suppose that you have clusters that are tagged with values called &lt;code&gt;admin&lt;/code&gt; and &lt;code&gt;test&lt;/code&gt;. If you specify both of these tag values in the request, Amazon Redshift returns a response with the clusters that have either or both of these tag values associated with them. (optional)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> ClusterNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> InvalidTagFault </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call gETDescribeClustersCall(String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, String clusterIdentifier, Integer maxRecords, String marker, List<String> tagKeys, List<String> tagValues, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/#Action=DescribeClusters";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (clusterIdentifier != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("ClusterIdentifier", clusterIdentifier));
        }

        if (maxRecords != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("MaxRecords", maxRecords));
        }

        if (marker != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("Marker", marker));
        }

        if (tagKeys != null) {
            localVarCollectionQueryParams.addAll(localVarApiClient.parameterToPairs("multi", "TagKeys", tagKeys));
        }

        if (tagValues != null) {
            localVarCollectionQueryParams.addAll(localVarApiClient.parameterToPairs("multi", "TagValues", tagValues));
        }

        if (action != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("Action", action));
        }

        if (version != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("Version", version));
        }

        if (xAmzContentSha256 != null) {
            localVarHeaderParams.put("X-Amz-Content-Sha256", localVarApiClient.parameterToString(xAmzContentSha256));
        }

        if (xAmzDate != null) {
            localVarHeaderParams.put("X-Amz-Date", localVarApiClient.parameterToString(xAmzDate));
        }

        if (xAmzAlgorithm != null) {
            localVarHeaderParams.put("X-Amz-Algorithm", localVarApiClient.parameterToString(xAmzAlgorithm));
        }

        if (xAmzCredential != null) {
            localVarHeaderParams.put("X-Amz-Credential", localVarApiClient.parameterToString(xAmzCredential));
        }

        if (xAmzSecurityToken != null) {
            localVarHeaderParams.put("X-Amz-Security-Token", localVarApiClient.parameterToString(xAmzSecurityToken));
        }

        if (xAmzSignature != null) {
            localVarHeaderParams.put("X-Amz-Signature", localVarApiClient.parameterToString(xAmzSignature));
        }

        if (xAmzSignedHeaders != null) {
            localVarHeaderParams.put("X-Amz-SignedHeaders", localVarApiClient.parameterToString(xAmzSignedHeaders));
        }

        final String[] localVarAccepts = {
            "text/xml"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "hmac" };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call gETDescribeClustersValidateBeforeCall(String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, String clusterIdentifier, Integer maxRecords, String marker, List<String> tagKeys, List<String> tagValues, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'action' is set
        if (action == null) {
            throw new ApiException("Missing the required parameter 'action' when calling gETDescribeClusters(Async)");
        }

        // verify the required parameter 'version' is set
        if (version == null) {
            throw new ApiException("Missing the required parameter 'version' when calling gETDescribeClusters(Async)");
        }

        return gETDescribeClustersCall(action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, clusterIdentifier, maxRecords, marker, tagKeys, tagValues, _callback);

    }

    /**
     * 
     * &lt;p&gt;Returns properties of provisioned clusters including general cluster properties, cluster database properties, maintenance and backup properties, and security and access properties. This operation supports pagination. For more information about managing clusters, go to &lt;a href&#x3D;\&quot;https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html\&quot;&gt;Amazon Redshift Clusters&lt;/a&gt; in the &lt;i&gt;Amazon Redshift Cluster Management Guide&lt;/i&gt;.&lt;/p&gt; &lt;p&gt;If you specify both tag keys and tag values in the same request, Amazon Redshift returns all clusters that match any combination of the specified keys and values. For example, if you have &lt;code&gt;owner&lt;/code&gt; and &lt;code&gt;environment&lt;/code&gt; for tag keys, and &lt;code&gt;admin&lt;/code&gt; and &lt;code&gt;test&lt;/code&gt; for tag values, all clusters that have any combination of those values are returned.&lt;/p&gt; &lt;p&gt;If both tag keys and values are omitted from the request, clusters are returned regardless of whether they have tag keys or values associated with them.&lt;/p&gt;
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param clusterIdentifier &lt;p&gt;The unique identifier of a cluster whose properties you are requesting. This parameter is case sensitive.&lt;/p&gt; &lt;p&gt;The default is that all clusters defined for an account are returned.&lt;/p&gt; (optional)
     * @param maxRecords &lt;p&gt;The maximum number of response records to return in each call. If the number of remaining response records exceeds the specified &lt;code&gt;MaxRecords&lt;/code&gt; value, a value is returned in a &lt;code&gt;marker&lt;/code&gt; field of the response. You can retrieve the next set of records by retrying the command with the returned marker value. &lt;/p&gt; &lt;p&gt;Default: &lt;code&gt;100&lt;/code&gt; &lt;/p&gt; &lt;p&gt;Constraints: minimum 20, maximum 100.&lt;/p&gt; (optional)
     * @param marker &lt;p&gt;An optional parameter that specifies the starting point to return a set of response records. When the results of a &lt;a&gt;DescribeClusters&lt;/a&gt; request exceed the value specified in &lt;code&gt;MaxRecords&lt;/code&gt;, Amazon Web Services returns a value in the &lt;code&gt;Marker&lt;/code&gt; field of the response. You can retrieve the next set of response records by providing the returned marker value in the &lt;code&gt;Marker&lt;/code&gt; parameter and retrying the request. &lt;/p&gt; &lt;p&gt;Constraints: You can specify either the &lt;b&gt;ClusterIdentifier&lt;/b&gt; parameter or the &lt;b&gt;Marker&lt;/b&gt; parameter, but not both. &lt;/p&gt; (optional)
     * @param tagKeys A tag key or keys for which you want to return all matching clusters that are associated with the specified key or keys. For example, suppose that you have clusters that are tagged with keys called &lt;code&gt;owner&lt;/code&gt; and &lt;code&gt;environment&lt;/code&gt;. If you specify both of these tag keys in the request, Amazon Redshift returns a response with the clusters that have either or both of these tag keys associated with them. (optional)
     * @param tagValues A tag value or values for which you want to return all matching clusters that are associated with the specified tag value or values. For example, suppose that you have clusters that are tagged with values called &lt;code&gt;admin&lt;/code&gt; and &lt;code&gt;test&lt;/code&gt;. If you specify both of these tag values in the request, Amazon Redshift returns a response with the clusters that have either or both of these tag values associated with them. (optional)
     * @return ClustersMessage
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> ClusterNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> InvalidTagFault </td><td>  -  </td></tr>
     </table>
     */
    public ClustersMessage gETDescribeClusters(String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, String clusterIdentifier, Integer maxRecords, String marker, List<String> tagKeys, List<String> tagValues) throws ApiException {
        ApiResponse<ClustersMessage> localVarResp = gETDescribeClustersWithHttpInfo(action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, clusterIdentifier, maxRecords, marker, tagKeys, tagValues);
        return localVarResp.getData();
    }

    /**
     * 
     * &lt;p&gt;Returns properties of provisioned clusters including general cluster properties, cluster database properties, maintenance and backup properties, and security and access properties. This operation supports pagination. For more information about managing clusters, go to &lt;a href&#x3D;\&quot;https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html\&quot;&gt;Amazon Redshift Clusters&lt;/a&gt; in the &lt;i&gt;Amazon Redshift Cluster Management Guide&lt;/i&gt;.&lt;/p&gt; &lt;p&gt;If you specify both tag keys and tag values in the same request, Amazon Redshift returns all clusters that match any combination of the specified keys and values. For example, if you have &lt;code&gt;owner&lt;/code&gt; and &lt;code&gt;environment&lt;/code&gt; for tag keys, and &lt;code&gt;admin&lt;/code&gt; and &lt;code&gt;test&lt;/code&gt; for tag values, all clusters that have any combination of those values are returned.&lt;/p&gt; &lt;p&gt;If both tag keys and values are omitted from the request, clusters are returned regardless of whether they have tag keys or values associated with them.&lt;/p&gt;
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param clusterIdentifier &lt;p&gt;The unique identifier of a cluster whose properties you are requesting. This parameter is case sensitive.&lt;/p&gt; &lt;p&gt;The default is that all clusters defined for an account are returned.&lt;/p&gt; (optional)
     * @param maxRecords &lt;p&gt;The maximum number of response records to return in each call. If the number of remaining response records exceeds the specified &lt;code&gt;MaxRecords&lt;/code&gt; value, a value is returned in a &lt;code&gt;marker&lt;/code&gt; field of the response. You can retrieve the next set of records by retrying the command with the returned marker value. &lt;/p&gt; &lt;p&gt;Default: &lt;code&gt;100&lt;/code&gt; &lt;/p&gt; &lt;p&gt;Constraints: minimum 20, maximum 100.&lt;/p&gt; (optional)
     * @param marker &lt;p&gt;An optional parameter that specifies the starting point to return a set of response records. When the results of a &lt;a&gt;DescribeClusters&lt;/a&gt; request exceed the value specified in &lt;code&gt;MaxRecords&lt;/code&gt;, Amazon Web Services returns a value in the &lt;code&gt;Marker&lt;/code&gt; field of the response. You can retrieve the next set of response records by providing the returned marker value in the &lt;code&gt;Marker&lt;/code&gt; parameter and retrying the request. &lt;/p&gt; &lt;p&gt;Constraints: You can specify either the &lt;b&gt;ClusterIdentifier&lt;/b&gt; parameter or the &lt;b&gt;Marker&lt;/b&gt; parameter, but not both. &lt;/p&gt; (optional)
     * @param tagKeys A tag key or keys for which you want to return all matching clusters that are associated with the specified key or keys. For example, suppose that you have clusters that are tagged with keys called &lt;code&gt;owner&lt;/code&gt; and &lt;code&gt;environment&lt;/code&gt;. If you specify both of these tag keys in the request, Amazon Redshift returns a response with the clusters that have either or both of these tag keys associated with them. (optional)
     * @param tagValues A tag value or values for which you want to return all matching clusters that are associated with the specified tag value or values. For example, suppose that you have clusters that are tagged with values called &lt;code&gt;admin&lt;/code&gt; and &lt;code&gt;test&lt;/code&gt;. If you specify both of these tag values in the request, Amazon Redshift returns a response with the clusters that have either or both of these tag values associated with them. (optional)
     * @return ApiResponse&lt;ClustersMessage&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> ClusterNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> InvalidTagFault </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<ClustersMessage> gETDescribeClustersWithHttpInfo(String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, String clusterIdentifier, Integer maxRecords, String marker, List<String> tagKeys, List<String> tagValues) throws ApiException {
        okhttp3.Call localVarCall = gETDescribeClustersValidateBeforeCall(action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, clusterIdentifier, maxRecords, marker, tagKeys, tagValues, null);
        Type localVarReturnType = new TypeToken<ClustersMessage>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     *  (asynchronously)
     * &lt;p&gt;Returns properties of provisioned clusters including general cluster properties, cluster database properties, maintenance and backup properties, and security and access properties. This operation supports pagination. For more information about managing clusters, go to &lt;a href&#x3D;\&quot;https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html\&quot;&gt;Amazon Redshift Clusters&lt;/a&gt; in the &lt;i&gt;Amazon Redshift Cluster Management Guide&lt;/i&gt;.&lt;/p&gt; &lt;p&gt;If you specify both tag keys and tag values in the same request, Amazon Redshift returns all clusters that match any combination of the specified keys and values. For example, if you have &lt;code&gt;owner&lt;/code&gt; and &lt;code&gt;environment&lt;/code&gt; for tag keys, and &lt;code&gt;admin&lt;/code&gt; and &lt;code&gt;test&lt;/code&gt; for tag values, all clusters that have any combination of those values are returned.&lt;/p&gt; &lt;p&gt;If both tag keys and values are omitted from the request, clusters are returned regardless of whether they have tag keys or values associated with them.&lt;/p&gt;
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param clusterIdentifier &lt;p&gt;The unique identifier of a cluster whose properties you are requesting. This parameter is case sensitive.&lt;/p&gt; &lt;p&gt;The default is that all clusters defined for an account are returned.&lt;/p&gt; (optional)
     * @param maxRecords &lt;p&gt;The maximum number of response records to return in each call. If the number of remaining response records exceeds the specified &lt;code&gt;MaxRecords&lt;/code&gt; value, a value is returned in a &lt;code&gt;marker&lt;/code&gt; field of the response. You can retrieve the next set of records by retrying the command with the returned marker value. &lt;/p&gt; &lt;p&gt;Default: &lt;code&gt;100&lt;/code&gt; &lt;/p&gt; &lt;p&gt;Constraints: minimum 20, maximum 100.&lt;/p&gt; (optional)
     * @param marker &lt;p&gt;An optional parameter that specifies the starting point to return a set of response records. When the results of a &lt;a&gt;DescribeClusters&lt;/a&gt; request exceed the value specified in &lt;code&gt;MaxRecords&lt;/code&gt;, Amazon Web Services returns a value in the &lt;code&gt;Marker&lt;/code&gt; field of the response. You can retrieve the next set of response records by providing the returned marker value in the &lt;code&gt;Marker&lt;/code&gt; parameter and retrying the request. &lt;/p&gt; &lt;p&gt;Constraints: You can specify either the &lt;b&gt;ClusterIdentifier&lt;/b&gt; parameter or the &lt;b&gt;Marker&lt;/b&gt; parameter, but not both. &lt;/p&gt; (optional)
     * @param tagKeys A tag key or keys for which you want to return all matching clusters that are associated with the specified key or keys. For example, suppose that you have clusters that are tagged with keys called &lt;code&gt;owner&lt;/code&gt; and &lt;code&gt;environment&lt;/code&gt;. If you specify both of these tag keys in the request, Amazon Redshift returns a response with the clusters that have either or both of these tag keys associated with them. (optional)
     * @param tagValues A tag value or values for which you want to return all matching clusters that are associated with the specified tag value or values. For example, suppose that you have clusters that are tagged with values called &lt;code&gt;admin&lt;/code&gt; and &lt;code&gt;test&lt;/code&gt;. If you specify both of these tag values in the request, Amazon Redshift returns a response with the clusters that have either or both of these tag values associated with them. (optional)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> ClusterNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> InvalidTagFault </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call gETDescribeClustersAsync(String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, String clusterIdentifier, Integer maxRecords, String marker, List<String> tagKeys, List<String> tagValues, final ApiCallback<ClustersMessage> _callback) throws ApiException {

        okhttp3.Call localVarCall = gETDescribeClustersValidateBeforeCall(action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, clusterIdentifier, maxRecords, marker, tagKeys, tagValues, _callback);
        Type localVarReturnType = new TypeToken<ClustersMessage>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for gETDescribeCustomDomainAssociations
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param customDomainName The custom domain name for the custom domain association. (optional)
     * @param customDomainCertificateArn The certificate Amazon Resource Name (ARN) for the custom domain association. (optional)
     * @param maxRecords The maximum records setting for the associated custom domain. (optional)
     * @param marker The marker for the custom domain association. (optional)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> CustomDomainAssociationNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> UnsupportedOperationFault </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call gETDescribeCustomDomainAssociationsCall(String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, String customDomainName, String customDomainCertificateArn, Integer maxRecords, String marker, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/#Action=DescribeCustomDomainAssociations";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (customDomainName != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("CustomDomainName", customDomainName));
        }

        if (customDomainCertificateArn != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("CustomDomainCertificateArn", customDomainCertificateArn));
        }

        if (maxRecords != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("MaxRecords", maxRecords));
        }

        if (marker != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("Marker", marker));
        }

        if (action != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("Action", action));
        }

        if (version != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("Version", version));
        }

        if (xAmzContentSha256 != null) {
            localVarHeaderParams.put("X-Amz-Content-Sha256", localVarApiClient.parameterToString(xAmzContentSha256));
        }

        if (xAmzDate != null) {
            localVarHeaderParams.put("X-Amz-Date", localVarApiClient.parameterToString(xAmzDate));
        }

        if (xAmzAlgorithm != null) {
            localVarHeaderParams.put("X-Amz-Algorithm", localVarApiClient.parameterToString(xAmzAlgorithm));
        }

        if (xAmzCredential != null) {
            localVarHeaderParams.put("X-Amz-Credential", localVarApiClient.parameterToString(xAmzCredential));
        }

        if (xAmzSecurityToken != null) {
            localVarHeaderParams.put("X-Amz-Security-Token", localVarApiClient.parameterToString(xAmzSecurityToken));
        }

        if (xAmzSignature != null) {
            localVarHeaderParams.put("X-Amz-Signature", localVarApiClient.parameterToString(xAmzSignature));
        }

        if (xAmzSignedHeaders != null) {
            localVarHeaderParams.put("X-Amz-SignedHeaders", localVarApiClient.parameterToString(xAmzSignedHeaders));
        }

        final String[] localVarAccepts = {
            "text/xml"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "hmac" };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call gETDescribeCustomDomainAssociationsValidateBeforeCall(String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, String customDomainName, String customDomainCertificateArn, Integer maxRecords, String marker, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'action' is set
        if (action == null) {
            throw new ApiException("Missing the required parameter 'action' when calling gETDescribeCustomDomainAssociations(Async)");
        }

        // verify the required parameter 'version' is set
        if (version == null) {
            throw new ApiException("Missing the required parameter 'version' when calling gETDescribeCustomDomainAssociations(Async)");
        }

        return gETDescribeCustomDomainAssociationsCall(action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, customDomainName, customDomainCertificateArn, maxRecords, marker, _callback);

    }

    /**
     * 
     * Contains information for custom domain associations for a cluster.
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param customDomainName The custom domain name for the custom domain association. (optional)
     * @param customDomainCertificateArn The certificate Amazon Resource Name (ARN) for the custom domain association. (optional)
     * @param maxRecords The maximum records setting for the associated custom domain. (optional)
     * @param marker The marker for the custom domain association. (optional)
     * @return CustomDomainAssociationsMessage
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> CustomDomainAssociationNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> UnsupportedOperationFault </td><td>  -  </td></tr>
     </table>
     */
    public CustomDomainAssociationsMessage gETDescribeCustomDomainAssociations(String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, String customDomainName, String customDomainCertificateArn, Integer maxRecords, String marker) throws ApiException {
        ApiResponse<CustomDomainAssociationsMessage> localVarResp = gETDescribeCustomDomainAssociationsWithHttpInfo(action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, customDomainName, customDomainCertificateArn, maxRecords, marker);
        return localVarResp.getData();
    }

    /**
     * 
     * Contains information for custom domain associations for a cluster.
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param customDomainName The custom domain name for the custom domain association. (optional)
     * @param customDomainCertificateArn The certificate Amazon Resource Name (ARN) for the custom domain association. (optional)
     * @param maxRecords The maximum records setting for the associated custom domain. (optional)
     * @param marker The marker for the custom domain association. (optional)
     * @return ApiResponse&lt;CustomDomainAssociationsMessage&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> CustomDomainAssociationNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> UnsupportedOperationFault </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<CustomDomainAssociationsMessage> gETDescribeCustomDomainAssociationsWithHttpInfo(String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, String customDomainName, String customDomainCertificateArn, Integer maxRecords, String marker) throws ApiException {
        okhttp3.Call localVarCall = gETDescribeCustomDomainAssociationsValidateBeforeCall(action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, customDomainName, customDomainCertificateArn, maxRecords, marker, null);
        Type localVarReturnType = new TypeToken<CustomDomainAssociationsMessage>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     *  (asynchronously)
     * Contains information for custom domain associations for a cluster.
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param customDomainName The custom domain name for the custom domain association. (optional)
     * @param customDomainCertificateArn The certificate Amazon Resource Name (ARN) for the custom domain association. (optional)
     * @param maxRecords The maximum records setting for the associated custom domain. (optional)
     * @param marker The marker for the custom domain association. (optional)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> CustomDomainAssociationNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> UnsupportedOperationFault </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call gETDescribeCustomDomainAssociationsAsync(String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, String customDomainName, String customDomainCertificateArn, Integer maxRecords, String marker, final ApiCallback<CustomDomainAssociationsMessage> _callback) throws ApiException {

        okhttp3.Call localVarCall = gETDescribeCustomDomainAssociationsValidateBeforeCall(action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, customDomainName, customDomainCertificateArn, maxRecords, marker, _callback);
        Type localVarReturnType = new TypeToken<CustomDomainAssociationsMessage>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for gETDescribeDataShares
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param dataShareArn The identifier of the datashare to describe details of. (optional)
     * @param maxRecords The maximum number of response records to return in each call. If the number of remaining response records exceeds the specified &lt;code&gt;MaxRecords&lt;/code&gt; value, a value is returned in a &lt;code&gt;marker&lt;/code&gt; field of the response. You can retrieve the next set of records by retrying the command with the returned marker value.  (optional)
     * @param marker An optional parameter that specifies the starting point to return a set of response records. When the results of a &lt;a&gt;DescribeDataShares&lt;/a&gt; request exceed the value specified in &lt;code&gt;MaxRecords&lt;/code&gt;, Amazon Web Services returns a value in the &lt;code&gt;Marker&lt;/code&gt; field of the response. You can retrieve the next set of response records by providing the returned marker value in the &lt;code&gt;Marker&lt;/code&gt; parameter and retrying the request.  (optional)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> InvalidDataShareFault </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call gETDescribeDataSharesCall(String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, String dataShareArn, Integer maxRecords, String marker, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/#Action=DescribeDataShares";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (dataShareArn != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("DataShareArn", dataShareArn));
        }

        if (maxRecords != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("MaxRecords", maxRecords));
        }

        if (marker != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("Marker", marker));
        }

        if (action != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("Action", action));
        }

        if (version != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("Version", version));
        }

        if (xAmzContentSha256 != null) {
            localVarHeaderParams.put("X-Amz-Content-Sha256", localVarApiClient.parameterToString(xAmzContentSha256));
        }

        if (xAmzDate != null) {
            localVarHeaderParams.put("X-Amz-Date", localVarApiClient.parameterToString(xAmzDate));
        }

        if (xAmzAlgorithm != null) {
            localVarHeaderParams.put("X-Amz-Algorithm", localVarApiClient.parameterToString(xAmzAlgorithm));
        }

        if (xAmzCredential != null) {
            localVarHeaderParams.put("X-Amz-Credential", localVarApiClient.parameterToString(xAmzCredential));
        }

        if (xAmzSecurityToken != null) {
            localVarHeaderParams.put("X-Amz-Security-Token", localVarApiClient.parameterToString(xAmzSecurityToken));
        }

        if (xAmzSignature != null) {
            localVarHeaderParams.put("X-Amz-Signature", localVarApiClient.parameterToString(xAmzSignature));
        }

        if (xAmzSignedHeaders != null) {
            localVarHeaderParams.put("X-Amz-SignedHeaders", localVarApiClient.parameterToString(xAmzSignedHeaders));
        }

        final String[] localVarAccepts = {
            "text/xml"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "hmac" };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call gETDescribeDataSharesValidateBeforeCall(String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, String dataShareArn, Integer maxRecords, String marker, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'action' is set
        if (action == null) {
            throw new ApiException("Missing the required parameter 'action' when calling gETDescribeDataShares(Async)");
        }

        // verify the required parameter 'version' is set
        if (version == null) {
            throw new ApiException("Missing the required parameter 'version' when calling gETDescribeDataShares(Async)");
        }

        return gETDescribeDataSharesCall(action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, dataShareArn, maxRecords, marker, _callback);

    }

    /**
     * 
     * Shows the status of any inbound or outbound datashares available in the specified account.
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param dataShareArn The identifier of the datashare to describe details of. (optional)
     * @param maxRecords The maximum number of response records to return in each call. If the number of remaining response records exceeds the specified &lt;code&gt;MaxRecords&lt;/code&gt; value, a value is returned in a &lt;code&gt;marker&lt;/code&gt; field of the response. You can retrieve the next set of records by retrying the command with the returned marker value.  (optional)
     * @param marker An optional parameter that specifies the starting point to return a set of response records. When the results of a &lt;a&gt;DescribeDataShares&lt;/a&gt; request exceed the value specified in &lt;code&gt;MaxRecords&lt;/code&gt;, Amazon Web Services returns a value in the &lt;code&gt;Marker&lt;/code&gt; field of the response. You can retrieve the next set of response records by providing the returned marker value in the &lt;code&gt;Marker&lt;/code&gt; parameter and retrying the request.  (optional)
     * @return DescribeDataSharesResult
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> InvalidDataShareFault </td><td>  -  </td></tr>
     </table>
     */
    public DescribeDataSharesResult gETDescribeDataShares(String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, String dataShareArn, Integer maxRecords, String marker) throws ApiException {
        ApiResponse<DescribeDataSharesResult> localVarResp = gETDescribeDataSharesWithHttpInfo(action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, dataShareArn, maxRecords, marker);
        return localVarResp.getData();
    }

    /**
     * 
     * Shows the status of any inbound or outbound datashares available in the specified account.
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param dataShareArn The identifier of the datashare to describe details of. (optional)
     * @param maxRecords The maximum number of response records to return in each call. If the number of remaining response records exceeds the specified &lt;code&gt;MaxRecords&lt;/code&gt; value, a value is returned in a &lt;code&gt;marker&lt;/code&gt; field of the response. You can retrieve the next set of records by retrying the command with the returned marker value.  (optional)
     * @param marker An optional parameter that specifies the starting point to return a set of response records. When the results of a &lt;a&gt;DescribeDataShares&lt;/a&gt; request exceed the value specified in &lt;code&gt;MaxRecords&lt;/code&gt;, Amazon Web Services returns a value in the &lt;code&gt;Marker&lt;/code&gt; field of the response. You can retrieve the next set of response records by providing the returned marker value in the &lt;code&gt;Marker&lt;/code&gt; parameter and retrying the request.  (optional)
     * @return ApiResponse&lt;DescribeDataSharesResult&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> InvalidDataShareFault </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<DescribeDataSharesResult> gETDescribeDataSharesWithHttpInfo(String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, String dataShareArn, Integer maxRecords, String marker) throws ApiException {
        okhttp3.Call localVarCall = gETDescribeDataSharesValidateBeforeCall(action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, dataShareArn, maxRecords, marker, null);
        Type localVarReturnType = new TypeToken<DescribeDataSharesResult>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     *  (asynchronously)
     * Shows the status of any inbound or outbound datashares available in the specified account.
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param dataShareArn The identifier of the datashare to describe details of. (optional)
     * @param maxRecords The maximum number of response records to return in each call. If the number of remaining response records exceeds the specified &lt;code&gt;MaxRecords&lt;/code&gt; value, a value is returned in a &lt;code&gt;marker&lt;/code&gt; field of the response. You can retrieve the next set of records by retrying the command with the returned marker value.  (optional)
     * @param marker An optional parameter that specifies the starting point to return a set of response records. When the results of a &lt;a&gt;DescribeDataShares&lt;/a&gt; request exceed the value specified in &lt;code&gt;MaxRecords&lt;/code&gt;, Amazon Web Services returns a value in the &lt;code&gt;Marker&lt;/code&gt; field of the response. You can retrieve the next set of response records by providing the returned marker value in the &lt;code&gt;Marker&lt;/code&gt; parameter and retrying the request.  (optional)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> InvalidDataShareFault </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call gETDescribeDataSharesAsync(String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, String dataShareArn, Integer maxRecords, String marker, final ApiCallback<DescribeDataSharesResult> _callback) throws ApiException {

        okhttp3.Call localVarCall = gETDescribeDataSharesValidateBeforeCall(action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, dataShareArn, maxRecords, marker, _callback);
        Type localVarReturnType = new TypeToken<DescribeDataSharesResult>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for gETDescribeDataSharesForConsumer
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param consumerArn The Amazon Resource Name (ARN) of the consumer that returns in the list of datashares. (optional)
     * @param status An identifier giving the status of a datashare in the consumer cluster. If this field is specified, Amazon Redshift returns the list of datashares that have the specified status. (optional)
     * @param maxRecords The maximum number of response records to return in each call. If the number of remaining response records exceeds the specified &lt;code&gt;MaxRecords&lt;/code&gt; value, a value is returned in a &lt;code&gt;marker&lt;/code&gt; field of the response. You can retrieve the next set of records by retrying the command with the returned marker value.  (optional)
     * @param marker An optional parameter that specifies the starting point to return a set of response records. When the results of a &lt;a&gt;DescribeDataSharesForConsumer&lt;/a&gt; request exceed the value specified in &lt;code&gt;MaxRecords&lt;/code&gt;, Amazon Web Services returns a value in the &lt;code&gt;Marker&lt;/code&gt; field of the response. You can retrieve the next set of response records by providing the returned marker value in the &lt;code&gt;Marker&lt;/code&gt; parameter and retrying the request.  (optional)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> InvalidNamespaceFault </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call gETDescribeDataSharesForConsumerCall(String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, String consumerArn, String status, Integer maxRecords, String marker, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/#Action=DescribeDataSharesForConsumer";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (consumerArn != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("ConsumerArn", consumerArn));
        }

        if (status != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("Status", status));
        }

        if (maxRecords != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("MaxRecords", maxRecords));
        }

        if (marker != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("Marker", marker));
        }

        if (action != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("Action", action));
        }

        if (version != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("Version", version));
        }

        if (xAmzContentSha256 != null) {
            localVarHeaderParams.put("X-Amz-Content-Sha256", localVarApiClient.parameterToString(xAmzContentSha256));
        }

        if (xAmzDate != null) {
            localVarHeaderParams.put("X-Amz-Date", localVarApiClient.parameterToString(xAmzDate));
        }

        if (xAmzAlgorithm != null) {
            localVarHeaderParams.put("X-Amz-Algorithm", localVarApiClient.parameterToString(xAmzAlgorithm));
        }

        if (xAmzCredential != null) {
            localVarHeaderParams.put("X-Amz-Credential", localVarApiClient.parameterToString(xAmzCredential));
        }

        if (xAmzSecurityToken != null) {
            localVarHeaderParams.put("X-Amz-Security-Token", localVarApiClient.parameterToString(xAmzSecurityToken));
        }

        if (xAmzSignature != null) {
            localVarHeaderParams.put("X-Amz-Signature", localVarApiClient.parameterToString(xAmzSignature));
        }

        if (xAmzSignedHeaders != null) {
            localVarHeaderParams.put("X-Amz-SignedHeaders", localVarApiClient.parameterToString(xAmzSignedHeaders));
        }

        final String[] localVarAccepts = {
            "text/xml"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "hmac" };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call gETDescribeDataSharesForConsumerValidateBeforeCall(String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, String consumerArn, String status, Integer maxRecords, String marker, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'action' is set
        if (action == null) {
            throw new ApiException("Missing the required parameter 'action' when calling gETDescribeDataSharesForConsumer(Async)");
        }

        // verify the required parameter 'version' is set
        if (version == null) {
            throw new ApiException("Missing the required parameter 'version' when calling gETDescribeDataSharesForConsumer(Async)");
        }

        return gETDescribeDataSharesForConsumerCall(action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, consumerArn, status, maxRecords, marker, _callback);

    }

    /**
     * 
     * Returns a list of datashares where the account identifier being called is a consumer account identifier.
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param consumerArn The Amazon Resource Name (ARN) of the consumer that returns in the list of datashares. (optional)
     * @param status An identifier giving the status of a datashare in the consumer cluster. If this field is specified, Amazon Redshift returns the list of datashares that have the specified status. (optional)
     * @param maxRecords The maximum number of response records to return in each call. If the number of remaining response records exceeds the specified &lt;code&gt;MaxRecords&lt;/code&gt; value, a value is returned in a &lt;code&gt;marker&lt;/code&gt; field of the response. You can retrieve the next set of records by retrying the command with the returned marker value.  (optional)
     * @param marker An optional parameter that specifies the starting point to return a set of response records. When the results of a &lt;a&gt;DescribeDataSharesForConsumer&lt;/a&gt; request exceed the value specified in &lt;code&gt;MaxRecords&lt;/code&gt;, Amazon Web Services returns a value in the &lt;code&gt;Marker&lt;/code&gt; field of the response. You can retrieve the next set of response records by providing the returned marker value in the &lt;code&gt;Marker&lt;/code&gt; parameter and retrying the request.  (optional)
     * @return DescribeDataSharesForConsumerResult
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> InvalidNamespaceFault </td><td>  -  </td></tr>
     </table>
     */
    public DescribeDataSharesForConsumerResult gETDescribeDataSharesForConsumer(String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, String consumerArn, String status, Integer maxRecords, String marker) throws ApiException {
        ApiResponse<DescribeDataSharesForConsumerResult> localVarResp = gETDescribeDataSharesForConsumerWithHttpInfo(action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, consumerArn, status, maxRecords, marker);
        return localVarResp.getData();
    }

    /**
     * 
     * Returns a list of datashares where the account identifier being called is a consumer account identifier.
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param consumerArn The Amazon Resource Name (ARN) of the consumer that returns in the list of datashares. (optional)
     * @param status An identifier giving the status of a datashare in the consumer cluster. If this field is specified, Amazon Redshift returns the list of datashares that have the specified status. (optional)
     * @param maxRecords The maximum number of response records to return in each call. If the number of remaining response records exceeds the specified &lt;code&gt;MaxRecords&lt;/code&gt; value, a value is returned in a &lt;code&gt;marker&lt;/code&gt; field of the response. You can retrieve the next set of records by retrying the command with the returned marker value.  (optional)
     * @param marker An optional parameter that specifies the starting point to return a set of response records. When the results of a &lt;a&gt;DescribeDataSharesForConsumer&lt;/a&gt; request exceed the value specified in &lt;code&gt;MaxRecords&lt;/code&gt;, Amazon Web Services returns a value in the &lt;code&gt;Marker&lt;/code&gt; field of the response. You can retrieve the next set of response records by providing the returned marker value in the &lt;code&gt;Marker&lt;/code&gt; parameter and retrying the request.  (optional)
     * @return ApiResponse&lt;DescribeDataSharesForConsumerResult&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> InvalidNamespaceFault </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<DescribeDataSharesForConsumerResult> gETDescribeDataSharesForConsumerWithHttpInfo(String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, String consumerArn, String status, Integer maxRecords, String marker) throws ApiException {
        okhttp3.Call localVarCall = gETDescribeDataSharesForConsumerValidateBeforeCall(action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, consumerArn, status, maxRecords, marker, null);
        Type localVarReturnType = new TypeToken<DescribeDataSharesForConsumerResult>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     *  (asynchronously)
     * Returns a list of datashares where the account identifier being called is a consumer account identifier.
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param consumerArn The Amazon Resource Name (ARN) of the consumer that returns in the list of datashares. (optional)
     * @param status An identifier giving the status of a datashare in the consumer cluster. If this field is specified, Amazon Redshift returns the list of datashares that have the specified status. (optional)
     * @param maxRecords The maximum number of response records to return in each call. If the number of remaining response records exceeds the specified &lt;code&gt;MaxRecords&lt;/code&gt; value, a value is returned in a &lt;code&gt;marker&lt;/code&gt; field of the response. You can retrieve the next set of records by retrying the command with the returned marker value.  (optional)
     * @param marker An optional parameter that specifies the starting point to return a set of response records. When the results of a &lt;a&gt;DescribeDataSharesForConsumer&lt;/a&gt; request exceed the value specified in &lt;code&gt;MaxRecords&lt;/code&gt;, Amazon Web Services returns a value in the &lt;code&gt;Marker&lt;/code&gt; field of the response. You can retrieve the next set of response records by providing the returned marker value in the &lt;code&gt;Marker&lt;/code&gt; parameter and retrying the request.  (optional)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> InvalidNamespaceFault </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call gETDescribeDataSharesForConsumerAsync(String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, String consumerArn, String status, Integer maxRecords, String marker, final ApiCallback<DescribeDataSharesForConsumerResult> _callback) throws ApiException {

        okhttp3.Call localVarCall = gETDescribeDataSharesForConsumerValidateBeforeCall(action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, consumerArn, status, maxRecords, marker, _callback);
        Type localVarReturnType = new TypeToken<DescribeDataSharesForConsumerResult>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for gETDescribeDataSharesForProducer
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param producerArn The Amazon Resource Name (ARN) of the producer that returns in the list of datashares. (optional)
     * @param status An identifier giving the status of a datashare in the producer. If this field is specified, Amazon Redshift returns the list of datashares that have the specified status. (optional)
     * @param maxRecords The maximum number of response records to return in each call. If the number of remaining response records exceeds the specified &lt;code&gt;MaxRecords&lt;/code&gt; value, a value is returned in a &lt;code&gt;marker&lt;/code&gt; field of the response. You can retrieve the next set of records by retrying the command with the returned marker value.  (optional)
     * @param marker An optional parameter that specifies the starting point to return a set of response records. When the results of a &lt;a&gt;DescribeDataSharesForProducer&lt;/a&gt; request exceed the value specified in &lt;code&gt;MaxRecords&lt;/code&gt;, Amazon Web Services returns a value in the &lt;code&gt;Marker&lt;/code&gt; field of the response. You can retrieve the next set of response records by providing the returned marker value in the &lt;code&gt;Marker&lt;/code&gt; parameter and retrying the request.  (optional)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> InvalidNamespaceFault </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call gETDescribeDataSharesForProducerCall(String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, String producerArn, String status, Integer maxRecords, String marker, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/#Action=DescribeDataSharesForProducer";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (producerArn != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("ProducerArn", producerArn));
        }

        if (status != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("Status", status));
        }

        if (maxRecords != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("MaxRecords", maxRecords));
        }

        if (marker != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("Marker", marker));
        }

        if (action != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("Action", action));
        }

        if (version != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("Version", version));
        }

        if (xAmzContentSha256 != null) {
            localVarHeaderParams.put("X-Amz-Content-Sha256", localVarApiClient.parameterToString(xAmzContentSha256));
        }

        if (xAmzDate != null) {
            localVarHeaderParams.put("X-Amz-Date", localVarApiClient.parameterToString(xAmzDate));
        }

        if (xAmzAlgorithm != null) {
            localVarHeaderParams.put("X-Amz-Algorithm", localVarApiClient.parameterToString(xAmzAlgorithm));
        }

        if (xAmzCredential != null) {
            localVarHeaderParams.put("X-Amz-Credential", localVarApiClient.parameterToString(xAmzCredential));
        }

        if (xAmzSecurityToken != null) {
            localVarHeaderParams.put("X-Amz-Security-Token", localVarApiClient.parameterToString(xAmzSecurityToken));
        }

        if (xAmzSignature != null) {
            localVarHeaderParams.put("X-Amz-Signature", localVarApiClient.parameterToString(xAmzSignature));
        }

        if (xAmzSignedHeaders != null) {
            localVarHeaderParams.put("X-Amz-SignedHeaders", localVarApiClient.parameterToString(xAmzSignedHeaders));
        }

        final String[] localVarAccepts = {
            "text/xml"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "hmac" };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call gETDescribeDataSharesForProducerValidateBeforeCall(String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, String producerArn, String status, Integer maxRecords, String marker, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'action' is set
        if (action == null) {
            throw new ApiException("Missing the required parameter 'action' when calling gETDescribeDataSharesForProducer(Async)");
        }

        // verify the required parameter 'version' is set
        if (version == null) {
            throw new ApiException("Missing the required parameter 'version' when calling gETDescribeDataSharesForProducer(Async)");
        }

        return gETDescribeDataSharesForProducerCall(action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, producerArn, status, maxRecords, marker, _callback);

    }

    /**
     * 
     * Returns a list of datashares when the account identifier being called is a producer account identifier.
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param producerArn The Amazon Resource Name (ARN) of the producer that returns in the list of datashares. (optional)
     * @param status An identifier giving the status of a datashare in the producer. If this field is specified, Amazon Redshift returns the list of datashares that have the specified status. (optional)
     * @param maxRecords The maximum number of response records to return in each call. If the number of remaining response records exceeds the specified &lt;code&gt;MaxRecords&lt;/code&gt; value, a value is returned in a &lt;code&gt;marker&lt;/code&gt; field of the response. You can retrieve the next set of records by retrying the command with the returned marker value.  (optional)
     * @param marker An optional parameter that specifies the starting point to return a set of response records. When the results of a &lt;a&gt;DescribeDataSharesForProducer&lt;/a&gt; request exceed the value specified in &lt;code&gt;MaxRecords&lt;/code&gt;, Amazon Web Services returns a value in the &lt;code&gt;Marker&lt;/code&gt; field of the response. You can retrieve the next set of response records by providing the returned marker value in the &lt;code&gt;Marker&lt;/code&gt; parameter and retrying the request.  (optional)
     * @return DescribeDataSharesForProducerResult
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> InvalidNamespaceFault </td><td>  -  </td></tr>
     </table>
     */
    public DescribeDataSharesForProducerResult gETDescribeDataSharesForProducer(String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, String producerArn, String status, Integer maxRecords, String marker) throws ApiException {
        ApiResponse<DescribeDataSharesForProducerResult> localVarResp = gETDescribeDataSharesForProducerWithHttpInfo(action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, producerArn, status, maxRecords, marker);
        return localVarResp.getData();
    }

    /**
     * 
     * Returns a list of datashares when the account identifier being called is a producer account identifier.
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param producerArn The Amazon Resource Name (ARN) of the producer that returns in the list of datashares. (optional)
     * @param status An identifier giving the status of a datashare in the producer. If this field is specified, Amazon Redshift returns the list of datashares that have the specified status. (optional)
     * @param maxRecords The maximum number of response records to return in each call. If the number of remaining response records exceeds the specified &lt;code&gt;MaxRecords&lt;/code&gt; value, a value is returned in a &lt;code&gt;marker&lt;/code&gt; field of the response. You can retrieve the next set of records by retrying the command with the returned marker value.  (optional)
     * @param marker An optional parameter that specifies the starting point to return a set of response records. When the results of a &lt;a&gt;DescribeDataSharesForProducer&lt;/a&gt; request exceed the value specified in &lt;code&gt;MaxRecords&lt;/code&gt;, Amazon Web Services returns a value in the &lt;code&gt;Marker&lt;/code&gt; field of the response. You can retrieve the next set of response records by providing the returned marker value in the &lt;code&gt;Marker&lt;/code&gt; parameter and retrying the request.  (optional)
     * @return ApiResponse&lt;DescribeDataSharesForProducerResult&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> InvalidNamespaceFault </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<DescribeDataSharesForProducerResult> gETDescribeDataSharesForProducerWithHttpInfo(String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, String producerArn, String status, Integer maxRecords, String marker) throws ApiException {
        okhttp3.Call localVarCall = gETDescribeDataSharesForProducerValidateBeforeCall(action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, producerArn, status, maxRecords, marker, null);
        Type localVarReturnType = new TypeToken<DescribeDataSharesForProducerResult>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     *  (asynchronously)
     * Returns a list of datashares when the account identifier being called is a producer account identifier.
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param producerArn The Amazon Resource Name (ARN) of the producer that returns in the list of datashares. (optional)
     * @param status An identifier giving the status of a datashare in the producer. If this field is specified, Amazon Redshift returns the list of datashares that have the specified status. (optional)
     * @param maxRecords The maximum number of response records to return in each call. If the number of remaining response records exceeds the specified &lt;code&gt;MaxRecords&lt;/code&gt; value, a value is returned in a &lt;code&gt;marker&lt;/code&gt; field of the response. You can retrieve the next set of records by retrying the command with the returned marker value.  (optional)
     * @param marker An optional parameter that specifies the starting point to return a set of response records. When the results of a &lt;a&gt;DescribeDataSharesForProducer&lt;/a&gt; request exceed the value specified in &lt;code&gt;MaxRecords&lt;/code&gt;, Amazon Web Services returns a value in the &lt;code&gt;Marker&lt;/code&gt; field of the response. You can retrieve the next set of response records by providing the returned marker value in the &lt;code&gt;Marker&lt;/code&gt; parameter and retrying the request.  (optional)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> InvalidNamespaceFault </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call gETDescribeDataSharesForProducerAsync(String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, String producerArn, String status, Integer maxRecords, String marker, final ApiCallback<DescribeDataSharesForProducerResult> _callback) throws ApiException {

        okhttp3.Call localVarCall = gETDescribeDataSharesForProducerValidateBeforeCall(action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, producerArn, status, maxRecords, marker, _callback);
        Type localVarReturnType = new TypeToken<DescribeDataSharesForProducerResult>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for gETDescribeDefaultClusterParameters
     * @param parameterGroupFamily The name of the cluster parameter group family. (required)
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param maxRecords &lt;p&gt;The maximum number of response records to return in each call. If the number of remaining response records exceeds the specified &lt;code&gt;MaxRecords&lt;/code&gt; value, a value is returned in a &lt;code&gt;marker&lt;/code&gt; field of the response. You can retrieve the next set of records by retrying the command with the returned marker value. &lt;/p&gt; &lt;p&gt;Default: &lt;code&gt;100&lt;/code&gt; &lt;/p&gt; &lt;p&gt;Constraints: minimum 20, maximum 100.&lt;/p&gt; (optional)
     * @param marker An optional parameter that specifies the starting point to return a set of response records. When the results of a &lt;a&gt;DescribeDefaultClusterParameters&lt;/a&gt; request exceed the value specified in &lt;code&gt;MaxRecords&lt;/code&gt;, Amazon Web Services returns a value in the &lt;code&gt;Marker&lt;/code&gt; field of the response. You can retrieve the next set of response records by providing the returned marker value in the &lt;code&gt;Marker&lt;/code&gt; parameter and retrying the request.  (optional)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call gETDescribeDefaultClusterParametersCall(String parameterGroupFamily, String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, Integer maxRecords, String marker, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/#Action=DescribeDefaultClusterParameters";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (parameterGroupFamily != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("ParameterGroupFamily", parameterGroupFamily));
        }

        if (maxRecords != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("MaxRecords", maxRecords));
        }

        if (marker != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("Marker", marker));
        }

        if (action != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("Action", action));
        }

        if (version != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("Version", version));
        }

        if (xAmzContentSha256 != null) {
            localVarHeaderParams.put("X-Amz-Content-Sha256", localVarApiClient.parameterToString(xAmzContentSha256));
        }

        if (xAmzDate != null) {
            localVarHeaderParams.put("X-Amz-Date", localVarApiClient.parameterToString(xAmzDate));
        }

        if (xAmzAlgorithm != null) {
            localVarHeaderParams.put("X-Amz-Algorithm", localVarApiClient.parameterToString(xAmzAlgorithm));
        }

        if (xAmzCredential != null) {
            localVarHeaderParams.put("X-Amz-Credential", localVarApiClient.parameterToString(xAmzCredential));
        }

        if (xAmzSecurityToken != null) {
            localVarHeaderParams.put("X-Amz-Security-Token", localVarApiClient.parameterToString(xAmzSecurityToken));
        }

        if (xAmzSignature != null) {
            localVarHeaderParams.put("X-Amz-Signature", localVarApiClient.parameterToString(xAmzSignature));
        }

        if (xAmzSignedHeaders != null) {
            localVarHeaderParams.put("X-Amz-SignedHeaders", localVarApiClient.parameterToString(xAmzSignedHeaders));
        }

        final String[] localVarAccepts = {
            "text/xml"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "hmac" };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call gETDescribeDefaultClusterParametersValidateBeforeCall(String parameterGroupFamily, String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, Integer maxRecords, String marker, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'parameterGroupFamily' is set
        if (parameterGroupFamily == null) {
            throw new ApiException("Missing the required parameter 'parameterGroupFamily' when calling gETDescribeDefaultClusterParameters(Async)");
        }

        // verify the required parameter 'action' is set
        if (action == null) {
            throw new ApiException("Missing the required parameter 'action' when calling gETDescribeDefaultClusterParameters(Async)");
        }

        // verify the required parameter 'version' is set
        if (version == null) {
            throw new ApiException("Missing the required parameter 'version' when calling gETDescribeDefaultClusterParameters(Async)");
        }

        return gETDescribeDefaultClusterParametersCall(parameterGroupFamily, action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, maxRecords, marker, _callback);

    }

    /**
     * 
     * &lt;p&gt;Returns a list of parameter settings for the specified parameter group family.&lt;/p&gt; &lt;p&gt; For more information about parameters and parameter groups, go to &lt;a href&#x3D;\&quot;https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-parameter-groups.html\&quot;&gt;Amazon Redshift Parameter Groups&lt;/a&gt; in the &lt;i&gt;Amazon Redshift Cluster Management Guide&lt;/i&gt;.&lt;/p&gt;
     * @param parameterGroupFamily The name of the cluster parameter group family. (required)
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param maxRecords &lt;p&gt;The maximum number of response records to return in each call. If the number of remaining response records exceeds the specified &lt;code&gt;MaxRecords&lt;/code&gt; value, a value is returned in a &lt;code&gt;marker&lt;/code&gt; field of the response. You can retrieve the next set of records by retrying the command with the returned marker value. &lt;/p&gt; &lt;p&gt;Default: &lt;code&gt;100&lt;/code&gt; &lt;/p&gt; &lt;p&gt;Constraints: minimum 20, maximum 100.&lt;/p&gt; (optional)
     * @param marker An optional parameter that specifies the starting point to return a set of response records. When the results of a &lt;a&gt;DescribeDefaultClusterParameters&lt;/a&gt; request exceed the value specified in &lt;code&gt;MaxRecords&lt;/code&gt;, Amazon Web Services returns a value in the &lt;code&gt;Marker&lt;/code&gt; field of the response. You can retrieve the next set of response records by providing the returned marker value in the &lt;code&gt;Marker&lt;/code&gt; parameter and retrying the request.  (optional)
     * @return DescribeDefaultClusterParametersResult
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
     </table>
     */
    public DescribeDefaultClusterParametersResult gETDescribeDefaultClusterParameters(String parameterGroupFamily, String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, Integer maxRecords, String marker) throws ApiException {
        ApiResponse<DescribeDefaultClusterParametersResult> localVarResp = gETDescribeDefaultClusterParametersWithHttpInfo(parameterGroupFamily, action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, maxRecords, marker);
        return localVarResp.getData();
    }

    /**
     * 
     * &lt;p&gt;Returns a list of parameter settings for the specified parameter group family.&lt;/p&gt; &lt;p&gt; For more information about parameters and parameter groups, go to &lt;a href&#x3D;\&quot;https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-parameter-groups.html\&quot;&gt;Amazon Redshift Parameter Groups&lt;/a&gt; in the &lt;i&gt;Amazon Redshift Cluster Management Guide&lt;/i&gt;.&lt;/p&gt;
     * @param parameterGroupFamily The name of the cluster parameter group family. (required)
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param maxRecords &lt;p&gt;The maximum number of response records to return in each call. If the number of remaining response records exceeds the specified &lt;code&gt;MaxRecords&lt;/code&gt; value, a value is returned in a &lt;code&gt;marker&lt;/code&gt; field of the response. You can retrieve the next set of records by retrying the command with the returned marker value. &lt;/p&gt; &lt;p&gt;Default: &lt;code&gt;100&lt;/code&gt; &lt;/p&gt; &lt;p&gt;Constraints: minimum 20, maximum 100.&lt;/p&gt; (optional)
     * @param marker An optional parameter that specifies the starting point to return a set of response records. When the results of a &lt;a&gt;DescribeDefaultClusterParameters&lt;/a&gt; request exceed the value specified in &lt;code&gt;MaxRecords&lt;/code&gt;, Amazon Web Services returns a value in the &lt;code&gt;Marker&lt;/code&gt; field of the response. You can retrieve the next set of response records by providing the returned marker value in the &lt;code&gt;Marker&lt;/code&gt; parameter and retrying the request.  (optional)
     * @return ApiResponse&lt;DescribeDefaultClusterParametersResult&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<DescribeDefaultClusterParametersResult> gETDescribeDefaultClusterParametersWithHttpInfo(String parameterGroupFamily, String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, Integer maxRecords, String marker) throws ApiException {
        okhttp3.Call localVarCall = gETDescribeDefaultClusterParametersValidateBeforeCall(parameterGroupFamily, action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, maxRecords, marker, null);
        Type localVarReturnType = new TypeToken<DescribeDefaultClusterParametersResult>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     *  (asynchronously)
     * &lt;p&gt;Returns a list of parameter settings for the specified parameter group family.&lt;/p&gt; &lt;p&gt; For more information about parameters and parameter groups, go to &lt;a href&#x3D;\&quot;https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-parameter-groups.html\&quot;&gt;Amazon Redshift Parameter Groups&lt;/a&gt; in the &lt;i&gt;Amazon Redshift Cluster Management Guide&lt;/i&gt;.&lt;/p&gt;
     * @param parameterGroupFamily The name of the cluster parameter group family. (required)
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param maxRecords &lt;p&gt;The maximum number of response records to return in each call. If the number of remaining response records exceeds the specified &lt;code&gt;MaxRecords&lt;/code&gt; value, a value is returned in a &lt;code&gt;marker&lt;/code&gt; field of the response. You can retrieve the next set of records by retrying the command with the returned marker value. &lt;/p&gt; &lt;p&gt;Default: &lt;code&gt;100&lt;/code&gt; &lt;/p&gt; &lt;p&gt;Constraints: minimum 20, maximum 100.&lt;/p&gt; (optional)
     * @param marker An optional parameter that specifies the starting point to return a set of response records. When the results of a &lt;a&gt;DescribeDefaultClusterParameters&lt;/a&gt; request exceed the value specified in &lt;code&gt;MaxRecords&lt;/code&gt;, Amazon Web Services returns a value in the &lt;code&gt;Marker&lt;/code&gt; field of the response. You can retrieve the next set of response records by providing the returned marker value in the &lt;code&gt;Marker&lt;/code&gt; parameter and retrying the request.  (optional)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call gETDescribeDefaultClusterParametersAsync(String parameterGroupFamily, String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, Integer maxRecords, String marker, final ApiCallback<DescribeDefaultClusterParametersResult> _callback) throws ApiException {

        okhttp3.Call localVarCall = gETDescribeDefaultClusterParametersValidateBeforeCall(parameterGroupFamily, action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, maxRecords, marker, _callback);
        Type localVarReturnType = new TypeToken<DescribeDefaultClusterParametersResult>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for gETDescribeEndpointAccess
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param clusterIdentifier The cluster identifier associated with the described endpoint. (optional)
     * @param resourceOwner The Amazon Web Services account ID of the owner of the cluster. (optional)
     * @param endpointName The name of the endpoint to be described. (optional)
     * @param vpcId The virtual private cloud (VPC) identifier with access to the cluster. (optional)
     * @param maxRecords The maximum number of records to include in the response. If more records exist than the specified &lt;code&gt;MaxRecords&lt;/code&gt; value, a pagination token called a &lt;code&gt;Marker&lt;/code&gt; is included in the response so that the remaining results can be retrieved. (optional)
     * @param marker An optional pagination token provided by a previous &lt;code&gt;DescribeEndpointAccess&lt;/code&gt; request. If this parameter is specified, the response includes only records beyond the marker, up to the value specified by the &lt;code&gt;MaxRecords&lt;/code&gt; parameter. (optional)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> ClusterNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> InvalidClusterStateFault </td><td>  -  </td></tr>
        <tr><td> 482 </td><td> EndpointNotFoundFault </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call gETDescribeEndpointAccessCall(String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, String clusterIdentifier, String resourceOwner, String endpointName, String vpcId, Integer maxRecords, String marker, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/#Action=DescribeEndpointAccess";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (clusterIdentifier != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("ClusterIdentifier", clusterIdentifier));
        }

        if (resourceOwner != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("ResourceOwner", resourceOwner));
        }

        if (endpointName != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("EndpointName", endpointName));
        }

        if (vpcId != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("VpcId", vpcId));
        }

        if (maxRecords != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("MaxRecords", maxRecords));
        }

        if (marker != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("Marker", marker));
        }

        if (action != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("Action", action));
        }

        if (version != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("Version", version));
        }

        if (xAmzContentSha256 != null) {
            localVarHeaderParams.put("X-Amz-Content-Sha256", localVarApiClient.parameterToString(xAmzContentSha256));
        }

        if (xAmzDate != null) {
            localVarHeaderParams.put("X-Amz-Date", localVarApiClient.parameterToString(xAmzDate));
        }

        if (xAmzAlgorithm != null) {
            localVarHeaderParams.put("X-Amz-Algorithm", localVarApiClient.parameterToString(xAmzAlgorithm));
        }

        if (xAmzCredential != null) {
            localVarHeaderParams.put("X-Amz-Credential", localVarApiClient.parameterToString(xAmzCredential));
        }

        if (xAmzSecurityToken != null) {
            localVarHeaderParams.put("X-Amz-Security-Token", localVarApiClient.parameterToString(xAmzSecurityToken));
        }

        if (xAmzSignature != null) {
            localVarHeaderParams.put("X-Amz-Signature", localVarApiClient.parameterToString(xAmzSignature));
        }

        if (xAmzSignedHeaders != null) {
            localVarHeaderParams.put("X-Amz-SignedHeaders", localVarApiClient.parameterToString(xAmzSignedHeaders));
        }

        final String[] localVarAccepts = {
            "text/xml"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "hmac" };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call gETDescribeEndpointAccessValidateBeforeCall(String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, String clusterIdentifier, String resourceOwner, String endpointName, String vpcId, Integer maxRecords, String marker, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'action' is set
        if (action == null) {
            throw new ApiException("Missing the required parameter 'action' when calling gETDescribeEndpointAccess(Async)");
        }

        // verify the required parameter 'version' is set
        if (version == null) {
            throw new ApiException("Missing the required parameter 'version' when calling gETDescribeEndpointAccess(Async)");
        }

        return gETDescribeEndpointAccessCall(action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, clusterIdentifier, resourceOwner, endpointName, vpcId, maxRecords, marker, _callback);

    }

    /**
     * 
     * Describes a Redshift-managed VPC endpoint.
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param clusterIdentifier The cluster identifier associated with the described endpoint. (optional)
     * @param resourceOwner The Amazon Web Services account ID of the owner of the cluster. (optional)
     * @param endpointName The name of the endpoint to be described. (optional)
     * @param vpcId The virtual private cloud (VPC) identifier with access to the cluster. (optional)
     * @param maxRecords The maximum number of records to include in the response. If more records exist than the specified &lt;code&gt;MaxRecords&lt;/code&gt; value, a pagination token called a &lt;code&gt;Marker&lt;/code&gt; is included in the response so that the remaining results can be retrieved. (optional)
     * @param marker An optional pagination token provided by a previous &lt;code&gt;DescribeEndpointAccess&lt;/code&gt; request. If this parameter is specified, the response includes only records beyond the marker, up to the value specified by the &lt;code&gt;MaxRecords&lt;/code&gt; parameter. (optional)
     * @return EndpointAccessList
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> ClusterNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> InvalidClusterStateFault </td><td>  -  </td></tr>
        <tr><td> 482 </td><td> EndpointNotFoundFault </td><td>  -  </td></tr>
     </table>
     */
    public EndpointAccessList gETDescribeEndpointAccess(String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, String clusterIdentifier, String resourceOwner, String endpointName, String vpcId, Integer maxRecords, String marker) throws ApiException {
        ApiResponse<EndpointAccessList> localVarResp = gETDescribeEndpointAccessWithHttpInfo(action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, clusterIdentifier, resourceOwner, endpointName, vpcId, maxRecords, marker);
        return localVarResp.getData();
    }

    /**
     * 
     * Describes a Redshift-managed VPC endpoint.
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param clusterIdentifier The cluster identifier associated with the described endpoint. (optional)
     * @param resourceOwner The Amazon Web Services account ID of the owner of the cluster. (optional)
     * @param endpointName The name of the endpoint to be described. (optional)
     * @param vpcId The virtual private cloud (VPC) identifier with access to the cluster. (optional)
     * @param maxRecords The maximum number of records to include in the response. If more records exist than the specified &lt;code&gt;MaxRecords&lt;/code&gt; value, a pagination token called a &lt;code&gt;Marker&lt;/code&gt; is included in the response so that the remaining results can be retrieved. (optional)
     * @param marker An optional pagination token provided by a previous &lt;code&gt;DescribeEndpointAccess&lt;/code&gt; request. If this parameter is specified, the response includes only records beyond the marker, up to the value specified by the &lt;code&gt;MaxRecords&lt;/code&gt; parameter. (optional)
     * @return ApiResponse&lt;EndpointAccessList&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> ClusterNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> InvalidClusterStateFault </td><td>  -  </td></tr>
        <tr><td> 482 </td><td> EndpointNotFoundFault </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<EndpointAccessList> gETDescribeEndpointAccessWithHttpInfo(String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, String clusterIdentifier, String resourceOwner, String endpointName, String vpcId, Integer maxRecords, String marker) throws ApiException {
        okhttp3.Call localVarCall = gETDescribeEndpointAccessValidateBeforeCall(action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, clusterIdentifier, resourceOwner, endpointName, vpcId, maxRecords, marker, null);
        Type localVarReturnType = new TypeToken<EndpointAccessList>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     *  (asynchronously)
     * Describes a Redshift-managed VPC endpoint.
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param clusterIdentifier The cluster identifier associated with the described endpoint. (optional)
     * @param resourceOwner The Amazon Web Services account ID of the owner of the cluster. (optional)
     * @param endpointName The name of the endpoint to be described. (optional)
     * @param vpcId The virtual private cloud (VPC) identifier with access to the cluster. (optional)
     * @param maxRecords The maximum number of records to include in the response. If more records exist than the specified &lt;code&gt;MaxRecords&lt;/code&gt; value, a pagination token called a &lt;code&gt;Marker&lt;/code&gt; is included in the response so that the remaining results can be retrieved. (optional)
     * @param marker An optional pagination token provided by a previous &lt;code&gt;DescribeEndpointAccess&lt;/code&gt; request. If this parameter is specified, the response includes only records beyond the marker, up to the value specified by the &lt;code&gt;MaxRecords&lt;/code&gt; parameter. (optional)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> ClusterNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> InvalidClusterStateFault </td><td>  -  </td></tr>
        <tr><td> 482 </td><td> EndpointNotFoundFault </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call gETDescribeEndpointAccessAsync(String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, String clusterIdentifier, String resourceOwner, String endpointName, String vpcId, Integer maxRecords, String marker, final ApiCallback<EndpointAccessList> _callback) throws ApiException {

        okhttp3.Call localVarCall = gETDescribeEndpointAccessValidateBeforeCall(action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, clusterIdentifier, resourceOwner, endpointName, vpcId, maxRecords, marker, _callback);
        Type localVarReturnType = new TypeToken<EndpointAccessList>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for gETDescribeEndpointAuthorization
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param clusterIdentifier The cluster identifier of the cluster to access. (optional)
     * @param account The Amazon Web Services account ID of either the cluster owner (grantor) or grantee. If &lt;code&gt;Grantee&lt;/code&gt; parameter is true, then the &lt;code&gt;Account&lt;/code&gt; value is of the grantor. (optional)
     * @param grantee Indicates whether to check authorization from a grantor or grantee point of view. If true, Amazon Redshift returns endpoint authorizations that you&#39;ve been granted. If false (default), checks authorization from a grantor point of view. (optional)
     * @param maxRecords The maximum number of records to include in the response. If more records exist than the specified &lt;code&gt;MaxRecords&lt;/code&gt; value, a pagination token called a &lt;code&gt;Marker&lt;/code&gt; is included in the response so that the remaining results can be retrieved. (optional)
     * @param marker An optional pagination token provided by a previous &lt;code&gt;DescribeEndpointAuthorization&lt;/code&gt; request. If this parameter is specified, the response includes only records beyond the marker, up to the value specified by the &lt;code&gt;MaxRecords&lt;/code&gt; parameter. (optional)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> ClusterNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> UnsupportedOperationFault </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call gETDescribeEndpointAuthorizationCall(String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, String clusterIdentifier, String account, Boolean grantee, Integer maxRecords, String marker, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/#Action=DescribeEndpointAuthorization";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (clusterIdentifier != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("ClusterIdentifier", clusterIdentifier));
        }

        if (account != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("Account", account));
        }

        if (grantee != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("Grantee", grantee));
        }

        if (maxRecords != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("MaxRecords", maxRecords));
        }

        if (marker != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("Marker", marker));
        }

        if (action != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("Action", action));
        }

        if (version != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("Version", version));
        }

        if (xAmzContentSha256 != null) {
            localVarHeaderParams.put("X-Amz-Content-Sha256", localVarApiClient.parameterToString(xAmzContentSha256));
        }

        if (xAmzDate != null) {
            localVarHeaderParams.put("X-Amz-Date", localVarApiClient.parameterToString(xAmzDate));
        }

        if (xAmzAlgorithm != null) {
            localVarHeaderParams.put("X-Amz-Algorithm", localVarApiClient.parameterToString(xAmzAlgorithm));
        }

        if (xAmzCredential != null) {
            localVarHeaderParams.put("X-Amz-Credential", localVarApiClient.parameterToString(xAmzCredential));
        }

        if (xAmzSecurityToken != null) {
            localVarHeaderParams.put("X-Amz-Security-Token", localVarApiClient.parameterToString(xAmzSecurityToken));
        }

        if (xAmzSignature != null) {
            localVarHeaderParams.put("X-Amz-Signature", localVarApiClient.parameterToString(xAmzSignature));
        }

        if (xAmzSignedHeaders != null) {
            localVarHeaderParams.put("X-Amz-SignedHeaders", localVarApiClient.parameterToString(xAmzSignedHeaders));
        }

        final String[] localVarAccepts = {
            "text/xml"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "hmac" };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call gETDescribeEndpointAuthorizationValidateBeforeCall(String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, String clusterIdentifier, String account, Boolean grantee, Integer maxRecords, String marker, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'action' is set
        if (action == null) {
            throw new ApiException("Missing the required parameter 'action' when calling gETDescribeEndpointAuthorization(Async)");
        }

        // verify the required parameter 'version' is set
        if (version == null) {
            throw new ApiException("Missing the required parameter 'version' when calling gETDescribeEndpointAuthorization(Async)");
        }

        return gETDescribeEndpointAuthorizationCall(action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, clusterIdentifier, account, grantee, maxRecords, marker, _callback);

    }

    /**
     * 
     * Describes an endpoint authorization.
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param clusterIdentifier The cluster identifier of the cluster to access. (optional)
     * @param account The Amazon Web Services account ID of either the cluster owner (grantor) or grantee. If &lt;code&gt;Grantee&lt;/code&gt; parameter is true, then the &lt;code&gt;Account&lt;/code&gt; value is of the grantor. (optional)
     * @param grantee Indicates whether to check authorization from a grantor or grantee point of view. If true, Amazon Redshift returns endpoint authorizations that you&#39;ve been granted. If false (default), checks authorization from a grantor point of view. (optional)
     * @param maxRecords The maximum number of records to include in the response. If more records exist than the specified &lt;code&gt;MaxRecords&lt;/code&gt; value, a pagination token called a &lt;code&gt;Marker&lt;/code&gt; is included in the response so that the remaining results can be retrieved. (optional)
     * @param marker An optional pagination token provided by a previous &lt;code&gt;DescribeEndpointAuthorization&lt;/code&gt; request. If this parameter is specified, the response includes only records beyond the marker, up to the value specified by the &lt;code&gt;MaxRecords&lt;/code&gt; parameter. (optional)
     * @return EndpointAuthorizationList
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> ClusterNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> UnsupportedOperationFault </td><td>  -  </td></tr>
     </table>
     */
    public EndpointAuthorizationList gETDescribeEndpointAuthorization(String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, String clusterIdentifier, String account, Boolean grantee, Integer maxRecords, String marker) throws ApiException {
        ApiResponse<EndpointAuthorizationList> localVarResp = gETDescribeEndpointAuthorizationWithHttpInfo(action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, clusterIdentifier, account, grantee, maxRecords, marker);
        return localVarResp.getData();
    }

    /**
     * 
     * Describes an endpoint authorization.
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param clusterIdentifier The cluster identifier of the cluster to access. (optional)
     * @param account The Amazon Web Services account ID of either the cluster owner (grantor) or grantee. If &lt;code&gt;Grantee&lt;/code&gt; parameter is true, then the &lt;code&gt;Account&lt;/code&gt; value is of the grantor. (optional)
     * @param grantee Indicates whether to check authorization from a grantor or grantee point of view. If true, Amazon Redshift returns endpoint authorizations that you&#39;ve been granted. If false (default), checks authorization from a grantor point of view. (optional)
     * @param maxRecords The maximum number of records to include in the response. If more records exist than the specified &lt;code&gt;MaxRecords&lt;/code&gt; value, a pagination token called a &lt;code&gt;Marker&lt;/code&gt; is included in the response so that the remaining results can be retrieved. (optional)
     * @param marker An optional pagination token provided by a previous &lt;code&gt;DescribeEndpointAuthorization&lt;/code&gt; request. If this parameter is specified, the response includes only records beyond the marker, up to the value specified by the &lt;code&gt;MaxRecords&lt;/code&gt; parameter. (optional)
     * @return ApiResponse&lt;EndpointAuthorizationList&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> ClusterNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> UnsupportedOperationFault </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<EndpointAuthorizationList> gETDescribeEndpointAuthorizationWithHttpInfo(String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, String clusterIdentifier, String account, Boolean grantee, Integer maxRecords, String marker) throws ApiException {
        okhttp3.Call localVarCall = gETDescribeEndpointAuthorizationValidateBeforeCall(action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, clusterIdentifier, account, grantee, maxRecords, marker, null);
        Type localVarReturnType = new TypeToken<EndpointAuthorizationList>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     *  (asynchronously)
     * Describes an endpoint authorization.
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param clusterIdentifier The cluster identifier of the cluster to access. (optional)
     * @param account The Amazon Web Services account ID of either the cluster owner (grantor) or grantee. If &lt;code&gt;Grantee&lt;/code&gt; parameter is true, then the &lt;code&gt;Account&lt;/code&gt; value is of the grantor. (optional)
     * @param grantee Indicates whether to check authorization from a grantor or grantee point of view. If true, Amazon Redshift returns endpoint authorizations that you&#39;ve been granted. If false (default), checks authorization from a grantor point of view. (optional)
     * @param maxRecords The maximum number of records to include in the response. If more records exist than the specified &lt;code&gt;MaxRecords&lt;/code&gt; value, a pagination token called a &lt;code&gt;Marker&lt;/code&gt; is included in the response so that the remaining results can be retrieved. (optional)
     * @param marker An optional pagination token provided by a previous &lt;code&gt;DescribeEndpointAuthorization&lt;/code&gt; request. If this parameter is specified, the response includes only records beyond the marker, up to the value specified by the &lt;code&gt;MaxRecords&lt;/code&gt; parameter. (optional)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> ClusterNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> UnsupportedOperationFault </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call gETDescribeEndpointAuthorizationAsync(String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, String clusterIdentifier, String account, Boolean grantee, Integer maxRecords, String marker, final ApiCallback<EndpointAuthorizationList> _callback) throws ApiException {

        okhttp3.Call localVarCall = gETDescribeEndpointAuthorizationValidateBeforeCall(action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, clusterIdentifier, account, grantee, maxRecords, marker, _callback);
        Type localVarReturnType = new TypeToken<EndpointAuthorizationList>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for gETDescribeEventCategories
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param sourceType &lt;p&gt;The source type, such as cluster or parameter group, to which the described event categories apply.&lt;/p&gt; &lt;p&gt;Valid values: cluster, cluster-snapshot, cluster-parameter-group, cluster-security-group, and scheduled-action.&lt;/p&gt; (optional)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call gETDescribeEventCategoriesCall(String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, String sourceType, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/#Action=DescribeEventCategories";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (sourceType != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("SourceType", sourceType));
        }

        if (action != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("Action", action));
        }

        if (version != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("Version", version));
        }

        if (xAmzContentSha256 != null) {
            localVarHeaderParams.put("X-Amz-Content-Sha256", localVarApiClient.parameterToString(xAmzContentSha256));
        }

        if (xAmzDate != null) {
            localVarHeaderParams.put("X-Amz-Date", localVarApiClient.parameterToString(xAmzDate));
        }

        if (xAmzAlgorithm != null) {
            localVarHeaderParams.put("X-Amz-Algorithm", localVarApiClient.parameterToString(xAmzAlgorithm));
        }

        if (xAmzCredential != null) {
            localVarHeaderParams.put("X-Amz-Credential", localVarApiClient.parameterToString(xAmzCredential));
        }

        if (xAmzSecurityToken != null) {
            localVarHeaderParams.put("X-Amz-Security-Token", localVarApiClient.parameterToString(xAmzSecurityToken));
        }

        if (xAmzSignature != null) {
            localVarHeaderParams.put("X-Amz-Signature", localVarApiClient.parameterToString(xAmzSignature));
        }

        if (xAmzSignedHeaders != null) {
            localVarHeaderParams.put("X-Amz-SignedHeaders", localVarApiClient.parameterToString(xAmzSignedHeaders));
        }

        final String[] localVarAccepts = {
            "text/xml"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "hmac" };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call gETDescribeEventCategoriesValidateBeforeCall(String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, String sourceType, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'action' is set
        if (action == null) {
            throw new ApiException("Missing the required parameter 'action' when calling gETDescribeEventCategories(Async)");
        }

        // verify the required parameter 'version' is set
        if (version == null) {
            throw new ApiException("Missing the required parameter 'version' when calling gETDescribeEventCategories(Async)");
        }

        return gETDescribeEventCategoriesCall(action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, sourceType, _callback);

    }

    /**
     * 
     * Displays a list of event categories for all event source types, or for a specified source type. For a list of the event categories and source types, go to &lt;a href&#x3D;\&quot;https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-event-notifications.html\&quot;&gt;Amazon Redshift Event Notifications&lt;/a&gt;.
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param sourceType &lt;p&gt;The source type, such as cluster or parameter group, to which the described event categories apply.&lt;/p&gt; &lt;p&gt;Valid values: cluster, cluster-snapshot, cluster-parameter-group, cluster-security-group, and scheduled-action.&lt;/p&gt; (optional)
     * @return EventCategoriesMessage
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
     </table>
     */
    public EventCategoriesMessage gETDescribeEventCategories(String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, String sourceType) throws ApiException {
        ApiResponse<EventCategoriesMessage> localVarResp = gETDescribeEventCategoriesWithHttpInfo(action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, sourceType);
        return localVarResp.getData();
    }

    /**
     * 
     * Displays a list of event categories for all event source types, or for a specified source type. For a list of the event categories and source types, go to &lt;a href&#x3D;\&quot;https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-event-notifications.html\&quot;&gt;Amazon Redshift Event Notifications&lt;/a&gt;.
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param sourceType &lt;p&gt;The source type, such as cluster or parameter group, to which the described event categories apply.&lt;/p&gt; &lt;p&gt;Valid values: cluster, cluster-snapshot, cluster-parameter-group, cluster-security-group, and scheduled-action.&lt;/p&gt; (optional)
     * @return ApiResponse&lt;EventCategoriesMessage&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<EventCategoriesMessage> gETDescribeEventCategoriesWithHttpInfo(String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, String sourceType) throws ApiException {
        okhttp3.Call localVarCall = gETDescribeEventCategoriesValidateBeforeCall(action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, sourceType, null);
        Type localVarReturnType = new TypeToken<EventCategoriesMessage>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     *  (asynchronously)
     * Displays a list of event categories for all event source types, or for a specified source type. For a list of the event categories and source types, go to &lt;a href&#x3D;\&quot;https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-event-notifications.html\&quot;&gt;Amazon Redshift Event Notifications&lt;/a&gt;.
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param sourceType &lt;p&gt;The source type, such as cluster or parameter group, to which the described event categories apply.&lt;/p&gt; &lt;p&gt;Valid values: cluster, cluster-snapshot, cluster-parameter-group, cluster-security-group, and scheduled-action.&lt;/p&gt; (optional)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call gETDescribeEventCategoriesAsync(String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, String sourceType, final ApiCallback<EventCategoriesMessage> _callback) throws ApiException {

        okhttp3.Call localVarCall = gETDescribeEventCategoriesValidateBeforeCall(action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, sourceType, _callback);
        Type localVarReturnType = new TypeToken<EventCategoriesMessage>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for gETDescribeEventSubscriptions
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param subscriptionName The name of the Amazon Redshift event notification subscription to be described. (optional)
     * @param maxRecords &lt;p&gt;The maximum number of response records to return in each call. If the number of remaining response records exceeds the specified &lt;code&gt;MaxRecords&lt;/code&gt; value, a value is returned in a &lt;code&gt;marker&lt;/code&gt; field of the response. You can retrieve the next set of records by retrying the command with the returned marker value. &lt;/p&gt; &lt;p&gt;Default: &lt;code&gt;100&lt;/code&gt; &lt;/p&gt; &lt;p&gt;Constraints: minimum 20, maximum 100.&lt;/p&gt; (optional)
     * @param marker An optional parameter that specifies the starting point to return a set of response records. When the results of a DescribeEventSubscriptions request exceed the value specified in &lt;code&gt;MaxRecords&lt;/code&gt;, Amazon Web Services returns a value in the &lt;code&gt;Marker&lt;/code&gt; field of the response. You can retrieve the next set of response records by providing the returned marker value in the &lt;code&gt;Marker&lt;/code&gt; parameter and retrying the request.  (optional)
     * @param tagKeys A tag key or keys for which you want to return all matching event notification subscriptions that are associated with the specified key or keys. For example, suppose that you have subscriptions that are tagged with keys called &lt;code&gt;owner&lt;/code&gt; and &lt;code&gt;environment&lt;/code&gt;. If you specify both of these tag keys in the request, Amazon Redshift returns a response with the subscriptions that have either or both of these tag keys associated with them. (optional)
     * @param tagValues A tag value or values for which you want to return all matching event notification subscriptions that are associated with the specified tag value or values. For example, suppose that you have subscriptions that are tagged with values called &lt;code&gt;admin&lt;/code&gt; and &lt;code&gt;test&lt;/code&gt;. If you specify both of these tag values in the request, Amazon Redshift returns a response with the subscriptions that have either or both of these tag values associated with them. (optional)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> SubscriptionNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> InvalidTagFault </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call gETDescribeEventSubscriptionsCall(String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, String subscriptionName, Integer maxRecords, String marker, List<String> tagKeys, List<String> tagValues, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/#Action=DescribeEventSubscriptions";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (subscriptionName != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("SubscriptionName", subscriptionName));
        }

        if (maxRecords != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("MaxRecords", maxRecords));
        }

        if (marker != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("Marker", marker));
        }

        if (tagKeys != null) {
            localVarCollectionQueryParams.addAll(localVarApiClient.parameterToPairs("multi", "TagKeys", tagKeys));
        }

        if (tagValues != null) {
            localVarCollectionQueryParams.addAll(localVarApiClient.parameterToPairs("multi", "TagValues", tagValues));
        }

        if (action != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("Action", action));
        }

        if (version != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("Version", version));
        }

        if (xAmzContentSha256 != null) {
            localVarHeaderParams.put("X-Amz-Content-Sha256", localVarApiClient.parameterToString(xAmzContentSha256));
        }

        if (xAmzDate != null) {
            localVarHeaderParams.put("X-Amz-Date", localVarApiClient.parameterToString(xAmzDate));
        }

        if (xAmzAlgorithm != null) {
            localVarHeaderParams.put("X-Amz-Algorithm", localVarApiClient.parameterToString(xAmzAlgorithm));
        }

        if (xAmzCredential != null) {
            localVarHeaderParams.put("X-Amz-Credential", localVarApiClient.parameterToString(xAmzCredential));
        }

        if (xAmzSecurityToken != null) {
            localVarHeaderParams.put("X-Amz-Security-Token", localVarApiClient.parameterToString(xAmzSecurityToken));
        }

        if (xAmzSignature != null) {
            localVarHeaderParams.put("X-Amz-Signature", localVarApiClient.parameterToString(xAmzSignature));
        }

        if (xAmzSignedHeaders != null) {
            localVarHeaderParams.put("X-Amz-SignedHeaders", localVarApiClient.parameterToString(xAmzSignedHeaders));
        }

        final String[] localVarAccepts = {
            "text/xml"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "hmac" };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call gETDescribeEventSubscriptionsValidateBeforeCall(String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, String subscriptionName, Integer maxRecords, String marker, List<String> tagKeys, List<String> tagValues, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'action' is set
        if (action == null) {
            throw new ApiException("Missing the required parameter 'action' when calling gETDescribeEventSubscriptions(Async)");
        }

        // verify the required parameter 'version' is set
        if (version == null) {
            throw new ApiException("Missing the required parameter 'version' when calling gETDescribeEventSubscriptions(Async)");
        }

        return gETDescribeEventSubscriptionsCall(action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, subscriptionName, maxRecords, marker, tagKeys, tagValues, _callback);

    }

    /**
     * 
     * &lt;p&gt;Lists descriptions of all the Amazon Redshift event notification subscriptions for a customer account. If you specify a subscription name, lists the description for that subscription.&lt;/p&gt; &lt;p&gt;If you specify both tag keys and tag values in the same request, Amazon Redshift returns all event notification subscriptions that match any combination of the specified keys and values. For example, if you have &lt;code&gt;owner&lt;/code&gt; and &lt;code&gt;environment&lt;/code&gt; for tag keys, and &lt;code&gt;admin&lt;/code&gt; and &lt;code&gt;test&lt;/code&gt; for tag values, all subscriptions that have any combination of those values are returned.&lt;/p&gt; &lt;p&gt;If both tag keys and values are omitted from the request, subscriptions are returned regardless of whether they have tag keys or values associated with them.&lt;/p&gt;
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param subscriptionName The name of the Amazon Redshift event notification subscription to be described. (optional)
     * @param maxRecords &lt;p&gt;The maximum number of response records to return in each call. If the number of remaining response records exceeds the specified &lt;code&gt;MaxRecords&lt;/code&gt; value, a value is returned in a &lt;code&gt;marker&lt;/code&gt; field of the response. You can retrieve the next set of records by retrying the command with the returned marker value. &lt;/p&gt; &lt;p&gt;Default: &lt;code&gt;100&lt;/code&gt; &lt;/p&gt; &lt;p&gt;Constraints: minimum 20, maximum 100.&lt;/p&gt; (optional)
     * @param marker An optional parameter that specifies the starting point to return a set of response records. When the results of a DescribeEventSubscriptions request exceed the value specified in &lt;code&gt;MaxRecords&lt;/code&gt;, Amazon Web Services returns a value in the &lt;code&gt;Marker&lt;/code&gt; field of the response. You can retrieve the next set of response records by providing the returned marker value in the &lt;code&gt;Marker&lt;/code&gt; parameter and retrying the request.  (optional)
     * @param tagKeys A tag key or keys for which you want to return all matching event notification subscriptions that are associated with the specified key or keys. For example, suppose that you have subscriptions that are tagged with keys called &lt;code&gt;owner&lt;/code&gt; and &lt;code&gt;environment&lt;/code&gt;. If you specify both of these tag keys in the request, Amazon Redshift returns a response with the subscriptions that have either or both of these tag keys associated with them. (optional)
     * @param tagValues A tag value or values for which you want to return all matching event notification subscriptions that are associated with the specified tag value or values. For example, suppose that you have subscriptions that are tagged with values called &lt;code&gt;admin&lt;/code&gt; and &lt;code&gt;test&lt;/code&gt;. If you specify both of these tag values in the request, Amazon Redshift returns a response with the subscriptions that have either or both of these tag values associated with them. (optional)
     * @return EventSubscriptionsMessage
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> SubscriptionNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> InvalidTagFault </td><td>  -  </td></tr>
     </table>
     */
    public EventSubscriptionsMessage gETDescribeEventSubscriptions(String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, String subscriptionName, Integer maxRecords, String marker, List<String> tagKeys, List<String> tagValues) throws ApiException {
        ApiResponse<EventSubscriptionsMessage> localVarResp = gETDescribeEventSubscriptionsWithHttpInfo(action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, subscriptionName, maxRecords, marker, tagKeys, tagValues);
        return localVarResp.getData();
    }

    /**
     * 
     * &lt;p&gt;Lists descriptions of all the Amazon Redshift event notification subscriptions for a customer account. If you specify a subscription name, lists the description for that subscription.&lt;/p&gt; &lt;p&gt;If you specify both tag keys and tag values in the same request, Amazon Redshift returns all event notification subscriptions that match any combination of the specified keys and values. For example, if you have &lt;code&gt;owner&lt;/code&gt; and &lt;code&gt;environment&lt;/code&gt; for tag keys, and &lt;code&gt;admin&lt;/code&gt; and &lt;code&gt;test&lt;/code&gt; for tag values, all subscriptions that have any combination of those values are returned.&lt;/p&gt; &lt;p&gt;If both tag keys and values are omitted from the request, subscriptions are returned regardless of whether they have tag keys or values associated with them.&lt;/p&gt;
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param subscriptionName The name of the Amazon Redshift event notification subscription to be described. (optional)
     * @param maxRecords &lt;p&gt;The maximum number of response records to return in each call. If the number of remaining response records exceeds the specified &lt;code&gt;MaxRecords&lt;/code&gt; value, a value is returned in a &lt;code&gt;marker&lt;/code&gt; field of the response. You can retrieve the next set of records by retrying the command with the returned marker value. &lt;/p&gt; &lt;p&gt;Default: &lt;code&gt;100&lt;/code&gt; &lt;/p&gt; &lt;p&gt;Constraints: minimum 20, maximum 100.&lt;/p&gt; (optional)
     * @param marker An optional parameter that specifies the starting point to return a set of response records. When the results of a DescribeEventSubscriptions request exceed the value specified in &lt;code&gt;MaxRecords&lt;/code&gt;, Amazon Web Services returns a value in the &lt;code&gt;Marker&lt;/code&gt; field of the response. You can retrieve the next set of response records by providing the returned marker value in the &lt;code&gt;Marker&lt;/code&gt; parameter and retrying the request.  (optional)
     * @param tagKeys A tag key or keys for which you want to return all matching event notification subscriptions that are associated with the specified key or keys. For example, suppose that you have subscriptions that are tagged with keys called &lt;code&gt;owner&lt;/code&gt; and &lt;code&gt;environment&lt;/code&gt;. If you specify both of these tag keys in the request, Amazon Redshift returns a response with the subscriptions that have either or both of these tag keys associated with them. (optional)
     * @param tagValues A tag value or values for which you want to return all matching event notification subscriptions that are associated with the specified tag value or values. For example, suppose that you have subscriptions that are tagged with values called &lt;code&gt;admin&lt;/code&gt; and &lt;code&gt;test&lt;/code&gt;. If you specify both of these tag values in the request, Amazon Redshift returns a response with the subscriptions that have either or both of these tag values associated with them. (optional)
     * @return ApiResponse&lt;EventSubscriptionsMessage&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> SubscriptionNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> InvalidTagFault </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<EventSubscriptionsMessage> gETDescribeEventSubscriptionsWithHttpInfo(String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, String subscriptionName, Integer maxRecords, String marker, List<String> tagKeys, List<String> tagValues) throws ApiException {
        okhttp3.Call localVarCall = gETDescribeEventSubscriptionsValidateBeforeCall(action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, subscriptionName, maxRecords, marker, tagKeys, tagValues, null);
        Type localVarReturnType = new TypeToken<EventSubscriptionsMessage>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     *  (asynchronously)
     * &lt;p&gt;Lists descriptions of all the Amazon Redshift event notification subscriptions for a customer account. If you specify a subscription name, lists the description for that subscription.&lt;/p&gt; &lt;p&gt;If you specify both tag keys and tag values in the same request, Amazon Redshift returns all event notification subscriptions that match any combination of the specified keys and values. For example, if you have &lt;code&gt;owner&lt;/code&gt; and &lt;code&gt;environment&lt;/code&gt; for tag keys, and &lt;code&gt;admin&lt;/code&gt; and &lt;code&gt;test&lt;/code&gt; for tag values, all subscriptions that have any combination of those values are returned.&lt;/p&gt; &lt;p&gt;If both tag keys and values are omitted from the request, subscriptions are returned regardless of whether they have tag keys or values associated with them.&lt;/p&gt;
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param subscriptionName The name of the Amazon Redshift event notification subscription to be described. (optional)
     * @param maxRecords &lt;p&gt;The maximum number of response records to return in each call. If the number of remaining response records exceeds the specified &lt;code&gt;MaxRecords&lt;/code&gt; value, a value is returned in a &lt;code&gt;marker&lt;/code&gt; field of the response. You can retrieve the next set of records by retrying the command with the returned marker value. &lt;/p&gt; &lt;p&gt;Default: &lt;code&gt;100&lt;/code&gt; &lt;/p&gt; &lt;p&gt;Constraints: minimum 20, maximum 100.&lt;/p&gt; (optional)
     * @param marker An optional parameter that specifies the starting point to return a set of response records. When the results of a DescribeEventSubscriptions request exceed the value specified in &lt;code&gt;MaxRecords&lt;/code&gt;, Amazon Web Services returns a value in the &lt;code&gt;Marker&lt;/code&gt; field of the response. You can retrieve the next set of response records by providing the returned marker value in the &lt;code&gt;Marker&lt;/code&gt; parameter and retrying the request.  (optional)
     * @param tagKeys A tag key or keys for which you want to return all matching event notification subscriptions that are associated with the specified key or keys. For example, suppose that you have subscriptions that are tagged with keys called &lt;code&gt;owner&lt;/code&gt; and &lt;code&gt;environment&lt;/code&gt;. If you specify both of these tag keys in the request, Amazon Redshift returns a response with the subscriptions that have either or both of these tag keys associated with them. (optional)
     * @param tagValues A tag value or values for which you want to return all matching event notification subscriptions that are associated with the specified tag value or values. For example, suppose that you have subscriptions that are tagged with values called &lt;code&gt;admin&lt;/code&gt; and &lt;code&gt;test&lt;/code&gt;. If you specify both of these tag values in the request, Amazon Redshift returns a response with the subscriptions that have either or both of these tag values associated with them. (optional)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> SubscriptionNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> InvalidTagFault </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call gETDescribeEventSubscriptionsAsync(String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, String subscriptionName, Integer maxRecords, String marker, List<String> tagKeys, List<String> tagValues, final ApiCallback<EventSubscriptionsMessage> _callback) throws ApiException {

        okhttp3.Call localVarCall = gETDescribeEventSubscriptionsValidateBeforeCall(action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, subscriptionName, maxRecords, marker, tagKeys, tagValues, _callback);
        Type localVarReturnType = new TypeToken<EventSubscriptionsMessage>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for gETDescribeEvents
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param sourceIdentifier &lt;p&gt;The identifier of the event source for which events will be returned. If this parameter is not specified, then all sources are included in the response.&lt;/p&gt; &lt;p&gt;Constraints:&lt;/p&gt; &lt;p&gt;If &lt;i&gt;SourceIdentifier&lt;/i&gt; is supplied, &lt;i&gt;SourceType&lt;/i&gt; must also be provided.&lt;/p&gt; &lt;ul&gt; &lt;li&gt; &lt;p&gt;Specify a cluster identifier when &lt;i&gt;SourceType&lt;/i&gt; is &lt;code&gt;cluster&lt;/code&gt;.&lt;/p&gt; &lt;/li&gt; &lt;li&gt; &lt;p&gt;Specify a cluster security group name when &lt;i&gt;SourceType&lt;/i&gt; is &lt;code&gt;cluster-security-group&lt;/code&gt;.&lt;/p&gt; &lt;/li&gt; &lt;li&gt; &lt;p&gt;Specify a cluster parameter group name when &lt;i&gt;SourceType&lt;/i&gt; is &lt;code&gt;cluster-parameter-group&lt;/code&gt;.&lt;/p&gt; &lt;/li&gt; &lt;li&gt; &lt;p&gt;Specify a cluster snapshot identifier when &lt;i&gt;SourceType&lt;/i&gt; is &lt;code&gt;cluster-snapshot&lt;/code&gt;.&lt;/p&gt; &lt;/li&gt; &lt;/ul&gt; (optional)
     * @param sourceType &lt;p&gt;The event source to retrieve events for. If no value is specified, all events are returned.&lt;/p&gt; &lt;p&gt;Constraints:&lt;/p&gt; &lt;p&gt;If &lt;i&gt;SourceType&lt;/i&gt; is supplied, &lt;i&gt;SourceIdentifier&lt;/i&gt; must also be provided.&lt;/p&gt; &lt;ul&gt; &lt;li&gt; &lt;p&gt;Specify &lt;code&gt;cluster&lt;/code&gt; when &lt;i&gt;SourceIdentifier&lt;/i&gt; is a cluster identifier.&lt;/p&gt; &lt;/li&gt; &lt;li&gt; &lt;p&gt;Specify &lt;code&gt;cluster-security-group&lt;/code&gt; when &lt;i&gt;SourceIdentifier&lt;/i&gt; is a cluster security group name.&lt;/p&gt; &lt;/li&gt; &lt;li&gt; &lt;p&gt;Specify &lt;code&gt;cluster-parameter-group&lt;/code&gt; when &lt;i&gt;SourceIdentifier&lt;/i&gt; is a cluster parameter group name.&lt;/p&gt; &lt;/li&gt; &lt;li&gt; &lt;p&gt;Specify &lt;code&gt;cluster-snapshot&lt;/code&gt; when &lt;i&gt;SourceIdentifier&lt;/i&gt; is a cluster snapshot identifier.&lt;/p&gt; &lt;/li&gt; &lt;/ul&gt; (optional)
     * @param startTime &lt;p&gt;The beginning of the time interval to retrieve events for, specified in ISO 8601 format. For more information about ISO 8601, go to the &lt;a href&#x3D;\&quot;http://en.wikipedia.org/wiki/ISO_8601\&quot;&gt;ISO8601 Wikipedia page.&lt;/a&gt; &lt;/p&gt; &lt;p&gt;Example: &lt;code&gt;2009-07-08T18:00Z&lt;/code&gt; &lt;/p&gt; (optional)
     * @param endTime &lt;p&gt;The end of the time interval for which to retrieve events, specified in ISO 8601 format. For more information about ISO 8601, go to the &lt;a href&#x3D;\&quot;http://en.wikipedia.org/wiki/ISO_8601\&quot;&gt;ISO8601 Wikipedia page.&lt;/a&gt; &lt;/p&gt; &lt;p&gt;Example: &lt;code&gt;2009-07-08T18:00Z&lt;/code&gt; &lt;/p&gt; (optional)
     * @param duration &lt;p&gt;The number of minutes prior to the time of the request for which to retrieve events. For example, if the request is sent at 18:00 and you specify a duration of 60, then only events which have occurred after 17:00 will be returned.&lt;/p&gt; &lt;p&gt;Default: &lt;code&gt;60&lt;/code&gt; &lt;/p&gt; (optional)
     * @param maxRecords &lt;p&gt;The maximum number of response records to return in each call. If the number of remaining response records exceeds the specified &lt;code&gt;MaxRecords&lt;/code&gt; value, a value is returned in a &lt;code&gt;marker&lt;/code&gt; field of the response. You can retrieve the next set of records by retrying the command with the returned marker value. &lt;/p&gt; &lt;p&gt;Default: &lt;code&gt;100&lt;/code&gt; &lt;/p&gt; &lt;p&gt;Constraints: minimum 20, maximum 100.&lt;/p&gt; (optional)
     * @param marker An optional parameter that specifies the starting point to return a set of response records. When the results of a &lt;a&gt;DescribeEvents&lt;/a&gt; request exceed the value specified in &lt;code&gt;MaxRecords&lt;/code&gt;, Amazon Web Services returns a value in the &lt;code&gt;Marker&lt;/code&gt; field of the response. You can retrieve the next set of response records by providing the returned marker value in the &lt;code&gt;Marker&lt;/code&gt; parameter and retrying the request.  (optional)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call gETDescribeEventsCall(String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, String sourceIdentifier, String sourceType, OffsetDateTime startTime, OffsetDateTime endTime, Integer duration, Integer maxRecords, String marker, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/#Action=DescribeEvents";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (sourceIdentifier != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("SourceIdentifier", sourceIdentifier));
        }

        if (sourceType != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("SourceType", sourceType));
        }

        if (startTime != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("StartTime", startTime));
        }

        if (endTime != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("EndTime", endTime));
        }

        if (duration != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("Duration", duration));
        }

        if (maxRecords != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("MaxRecords", maxRecords));
        }

        if (marker != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("Marker", marker));
        }

        if (action != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("Action", action));
        }

        if (version != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("Version", version));
        }

        if (xAmzContentSha256 != null) {
            localVarHeaderParams.put("X-Amz-Content-Sha256", localVarApiClient.parameterToString(xAmzContentSha256));
        }

        if (xAmzDate != null) {
            localVarHeaderParams.put("X-Amz-Date", localVarApiClient.parameterToString(xAmzDate));
        }

        if (xAmzAlgorithm != null) {
            localVarHeaderParams.put("X-Amz-Algorithm", localVarApiClient.parameterToString(xAmzAlgorithm));
        }

        if (xAmzCredential != null) {
            localVarHeaderParams.put("X-Amz-Credential", localVarApiClient.parameterToString(xAmzCredential));
        }

        if (xAmzSecurityToken != null) {
            localVarHeaderParams.put("X-Amz-Security-Token", localVarApiClient.parameterToString(xAmzSecurityToken));
        }

        if (xAmzSignature != null) {
            localVarHeaderParams.put("X-Amz-Signature", localVarApiClient.parameterToString(xAmzSignature));
        }

        if (xAmzSignedHeaders != null) {
            localVarHeaderParams.put("X-Amz-SignedHeaders", localVarApiClient.parameterToString(xAmzSignedHeaders));
        }

        final String[] localVarAccepts = {
            "text/xml"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "hmac" };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call gETDescribeEventsValidateBeforeCall(String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, String sourceIdentifier, String sourceType, OffsetDateTime startTime, OffsetDateTime endTime, Integer duration, Integer maxRecords, String marker, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'action' is set
        if (action == null) {
            throw new ApiException("Missing the required parameter 'action' when calling gETDescribeEvents(Async)");
        }

        // verify the required parameter 'version' is set
        if (version == null) {
            throw new ApiException("Missing the required parameter 'version' when calling gETDescribeEvents(Async)");
        }

        return gETDescribeEventsCall(action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, sourceIdentifier, sourceType, startTime, endTime, duration, maxRecords, marker, _callback);

    }

    /**
     * 
     * Returns events related to clusters, security groups, snapshots, and parameter groups for the past 14 days. Events specific to a particular cluster, security group, snapshot or parameter group can be obtained by providing the name as a parameter. By default, the past hour of events are returned.
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param sourceIdentifier &lt;p&gt;The identifier of the event source for which events will be returned. If this parameter is not specified, then all sources are included in the response.&lt;/p&gt; &lt;p&gt;Constraints:&lt;/p&gt; &lt;p&gt;If &lt;i&gt;SourceIdentifier&lt;/i&gt; is supplied, &lt;i&gt;SourceType&lt;/i&gt; must also be provided.&lt;/p&gt; &lt;ul&gt; &lt;li&gt; &lt;p&gt;Specify a cluster identifier when &lt;i&gt;SourceType&lt;/i&gt; is &lt;code&gt;cluster&lt;/code&gt;.&lt;/p&gt; &lt;/li&gt; &lt;li&gt; &lt;p&gt;Specify a cluster security group name when &lt;i&gt;SourceType&lt;/i&gt; is &lt;code&gt;cluster-security-group&lt;/code&gt;.&lt;/p&gt; &lt;/li&gt; &lt;li&gt; &lt;p&gt;Specify a cluster parameter group name when &lt;i&gt;SourceType&lt;/i&gt; is &lt;code&gt;cluster-parameter-group&lt;/code&gt;.&lt;/p&gt; &lt;/li&gt; &lt;li&gt; &lt;p&gt;Specify a cluster snapshot identifier when &lt;i&gt;SourceType&lt;/i&gt; is &lt;code&gt;cluster-snapshot&lt;/code&gt;.&lt;/p&gt; &lt;/li&gt; &lt;/ul&gt; (optional)
     * @param sourceType &lt;p&gt;The event source to retrieve events for. If no value is specified, all events are returned.&lt;/p&gt; &lt;p&gt;Constraints:&lt;/p&gt; &lt;p&gt;If &lt;i&gt;SourceType&lt;/i&gt; is supplied, &lt;i&gt;SourceIdentifier&lt;/i&gt; must also be provided.&lt;/p&gt; &lt;ul&gt; &lt;li&gt; &lt;p&gt;Specify &lt;code&gt;cluster&lt;/code&gt; when &lt;i&gt;SourceIdentifier&lt;/i&gt; is a cluster identifier.&lt;/p&gt; &lt;/li&gt; &lt;li&gt; &lt;p&gt;Specify &lt;code&gt;cluster-security-group&lt;/code&gt; when &lt;i&gt;SourceIdentifier&lt;/i&gt; is a cluster security group name.&lt;/p&gt; &lt;/li&gt; &lt;li&gt; &lt;p&gt;Specify &lt;code&gt;cluster-parameter-group&lt;/code&gt; when &lt;i&gt;SourceIdentifier&lt;/i&gt; is a cluster parameter group name.&lt;/p&gt; &lt;/li&gt; &lt;li&gt; &lt;p&gt;Specify &lt;code&gt;cluster-snapshot&lt;/code&gt; when &lt;i&gt;SourceIdentifier&lt;/i&gt; is a cluster snapshot identifier.&lt;/p&gt; &lt;/li&gt; &lt;/ul&gt; (optional)
     * @param startTime &lt;p&gt;The beginning of the time interval to retrieve events for, specified in ISO 8601 format. For more information about ISO 8601, go to the &lt;a href&#x3D;\&quot;http://en.wikipedia.org/wiki/ISO_8601\&quot;&gt;ISO8601 Wikipedia page.&lt;/a&gt; &lt;/p&gt; &lt;p&gt;Example: &lt;code&gt;2009-07-08T18:00Z&lt;/code&gt; &lt;/p&gt; (optional)
     * @param endTime &lt;p&gt;The end of the time interval for which to retrieve events, specified in ISO 8601 format. For more information about ISO 8601, go to the &lt;a href&#x3D;\&quot;http://en.wikipedia.org/wiki/ISO_8601\&quot;&gt;ISO8601 Wikipedia page.&lt;/a&gt; &lt;/p&gt; &lt;p&gt;Example: &lt;code&gt;2009-07-08T18:00Z&lt;/code&gt; &lt;/p&gt; (optional)
     * @param duration &lt;p&gt;The number of minutes prior to the time of the request for which to retrieve events. For example, if the request is sent at 18:00 and you specify a duration of 60, then only events which have occurred after 17:00 will be returned.&lt;/p&gt; &lt;p&gt;Default: &lt;code&gt;60&lt;/code&gt; &lt;/p&gt; (optional)
     * @param maxRecords &lt;p&gt;The maximum number of response records to return in each call. If the number of remaining response records exceeds the specified &lt;code&gt;MaxRecords&lt;/code&gt; value, a value is returned in a &lt;code&gt;marker&lt;/code&gt; field of the response. You can retrieve the next set of records by retrying the command with the returned marker value. &lt;/p&gt; &lt;p&gt;Default: &lt;code&gt;100&lt;/code&gt; &lt;/p&gt; &lt;p&gt;Constraints: minimum 20, maximum 100.&lt;/p&gt; (optional)
     * @param marker An optional parameter that specifies the starting point to return a set of response records. When the results of a &lt;a&gt;DescribeEvents&lt;/a&gt; request exceed the value specified in &lt;code&gt;MaxRecords&lt;/code&gt;, Amazon Web Services returns a value in the &lt;code&gt;Marker&lt;/code&gt; field of the response. You can retrieve the next set of response records by providing the returned marker value in the &lt;code&gt;Marker&lt;/code&gt; parameter and retrying the request.  (optional)
     * @return EventsMessage
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
     </table>
     */
    public EventsMessage gETDescribeEvents(String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, String sourceIdentifier, String sourceType, OffsetDateTime startTime, OffsetDateTime endTime, Integer duration, Integer maxRecords, String marker) throws ApiException {
        ApiResponse<EventsMessage> localVarResp = gETDescribeEventsWithHttpInfo(action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, sourceIdentifier, sourceType, startTime, endTime, duration, maxRecords, marker);
        return localVarResp.getData();
    }

    /**
     * 
     * Returns events related to clusters, security groups, snapshots, and parameter groups for the past 14 days. Events specific to a particular cluster, security group, snapshot or parameter group can be obtained by providing the name as a parameter. By default, the past hour of events are returned.
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param sourceIdentifier &lt;p&gt;The identifier of the event source for which events will be returned. If this parameter is not specified, then all sources are included in the response.&lt;/p&gt; &lt;p&gt;Constraints:&lt;/p&gt; &lt;p&gt;If &lt;i&gt;SourceIdentifier&lt;/i&gt; is supplied, &lt;i&gt;SourceType&lt;/i&gt; must also be provided.&lt;/p&gt; &lt;ul&gt; &lt;li&gt; &lt;p&gt;Specify a cluster identifier when &lt;i&gt;SourceType&lt;/i&gt; is &lt;code&gt;cluster&lt;/code&gt;.&lt;/p&gt; &lt;/li&gt; &lt;li&gt; &lt;p&gt;Specify a cluster security group name when &lt;i&gt;SourceType&lt;/i&gt; is &lt;code&gt;cluster-security-group&lt;/code&gt;.&lt;/p&gt; &lt;/li&gt; &lt;li&gt; &lt;p&gt;Specify a cluster parameter group name when &lt;i&gt;SourceType&lt;/i&gt; is &lt;code&gt;cluster-parameter-group&lt;/code&gt;.&lt;/p&gt; &lt;/li&gt; &lt;li&gt; &lt;p&gt;Specify a cluster snapshot identifier when &lt;i&gt;SourceType&lt;/i&gt; is &lt;code&gt;cluster-snapshot&lt;/code&gt;.&lt;/p&gt; &lt;/li&gt; &lt;/ul&gt; (optional)
     * @param sourceType &lt;p&gt;The event source to retrieve events for. If no value is specified, all events are returned.&lt;/p&gt; &lt;p&gt;Constraints:&lt;/p&gt; &lt;p&gt;If &lt;i&gt;SourceType&lt;/i&gt; is supplied, &lt;i&gt;SourceIdentifier&lt;/i&gt; must also be provided.&lt;/p&gt; &lt;ul&gt; &lt;li&gt; &lt;p&gt;Specify &lt;code&gt;cluster&lt;/code&gt; when &lt;i&gt;SourceIdentifier&lt;/i&gt; is a cluster identifier.&lt;/p&gt; &lt;/li&gt; &lt;li&gt; &lt;p&gt;Specify &lt;code&gt;cluster-security-group&lt;/code&gt; when &lt;i&gt;SourceIdentifier&lt;/i&gt; is a cluster security group name.&lt;/p&gt; &lt;/li&gt; &lt;li&gt; &lt;p&gt;Specify &lt;code&gt;cluster-parameter-group&lt;/code&gt; when &lt;i&gt;SourceIdentifier&lt;/i&gt; is a cluster parameter group name.&lt;/p&gt; &lt;/li&gt; &lt;li&gt; &lt;p&gt;Specify &lt;code&gt;cluster-snapshot&lt;/code&gt; when &lt;i&gt;SourceIdentifier&lt;/i&gt; is a cluster snapshot identifier.&lt;/p&gt; &lt;/li&gt; &lt;/ul&gt; (optional)
     * @param startTime &lt;p&gt;The beginning of the time interval to retrieve events for, specified in ISO 8601 format. For more information about ISO 8601, go to the &lt;a href&#x3D;\&quot;http://en.wikipedia.org/wiki/ISO_8601\&quot;&gt;ISO8601 Wikipedia page.&lt;/a&gt; &lt;/p&gt; &lt;p&gt;Example: &lt;code&gt;2009-07-08T18:00Z&lt;/code&gt; &lt;/p&gt; (optional)
     * @param endTime &lt;p&gt;The end of the time interval for which to retrieve events, specified in ISO 8601 format. For more information about ISO 8601, go to the &lt;a href&#x3D;\&quot;http://en.wikipedia.org/wiki/ISO_8601\&quot;&gt;ISO8601 Wikipedia page.&lt;/a&gt; &lt;/p&gt; &lt;p&gt;Example: &lt;code&gt;2009-07-08T18:00Z&lt;/code&gt; &lt;/p&gt; (optional)
     * @param duration &lt;p&gt;The number of minutes prior to the time of the request for which to retrieve events. For example, if the request is sent at 18:00 and you specify a duration of 60, then only events which have occurred after 17:00 will be returned.&lt;/p&gt; &lt;p&gt;Default: &lt;code&gt;60&lt;/code&gt; &lt;/p&gt; (optional)
     * @param maxRecords &lt;p&gt;The maximum number of response records to return in each call. If the number of remaining response records exceeds the specified &lt;code&gt;MaxRecords&lt;/code&gt; value, a value is returned in a &lt;code&gt;marker&lt;/code&gt; field of the response. You can retrieve the next set of records by retrying the command with the returned marker value. &lt;/p&gt; &lt;p&gt;Default: &lt;code&gt;100&lt;/code&gt; &lt;/p&gt; &lt;p&gt;Constraints: minimum 20, maximum 100.&lt;/p&gt; (optional)
     * @param marker An optional parameter that specifies the starting point to return a set of response records. When the results of a &lt;a&gt;DescribeEvents&lt;/a&gt; request exceed the value specified in &lt;code&gt;MaxRecords&lt;/code&gt;, Amazon Web Services returns a value in the &lt;code&gt;Marker&lt;/code&gt; field of the response. You can retrieve the next set of response records by providing the returned marker value in the &lt;code&gt;Marker&lt;/code&gt; parameter and retrying the request.  (optional)
     * @return ApiResponse&lt;EventsMessage&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<EventsMessage> gETDescribeEventsWithHttpInfo(String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, String sourceIdentifier, String sourceType, OffsetDateTime startTime, OffsetDateTime endTime, Integer duration, Integer maxRecords, String marker) throws ApiException {
        okhttp3.Call localVarCall = gETDescribeEventsValidateBeforeCall(action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, sourceIdentifier, sourceType, startTime, endTime, duration, maxRecords, marker, null);
        Type localVarReturnType = new TypeToken<EventsMessage>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     *  (asynchronously)
     * Returns events related to clusters, security groups, snapshots, and parameter groups for the past 14 days. Events specific to a particular cluster, security group, snapshot or parameter group can be obtained by providing the name as a parameter. By default, the past hour of events are returned.
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param sourceIdentifier &lt;p&gt;The identifier of the event source for which events will be returned. If this parameter is not specified, then all sources are included in the response.&lt;/p&gt; &lt;p&gt;Constraints:&lt;/p&gt; &lt;p&gt;If &lt;i&gt;SourceIdentifier&lt;/i&gt; is supplied, &lt;i&gt;SourceType&lt;/i&gt; must also be provided.&lt;/p&gt; &lt;ul&gt; &lt;li&gt; &lt;p&gt;Specify a cluster identifier when &lt;i&gt;SourceType&lt;/i&gt; is &lt;code&gt;cluster&lt;/code&gt;.&lt;/p&gt; &lt;/li&gt; &lt;li&gt; &lt;p&gt;Specify a cluster security group name when &lt;i&gt;SourceType&lt;/i&gt; is &lt;code&gt;cluster-security-group&lt;/code&gt;.&lt;/p&gt; &lt;/li&gt; &lt;li&gt; &lt;p&gt;Specify a cluster parameter group name when &lt;i&gt;SourceType&lt;/i&gt; is &lt;code&gt;cluster-parameter-group&lt;/code&gt;.&lt;/p&gt; &lt;/li&gt; &lt;li&gt; &lt;p&gt;Specify a cluster snapshot identifier when &lt;i&gt;SourceType&lt;/i&gt; is &lt;code&gt;cluster-snapshot&lt;/code&gt;.&lt;/p&gt; &lt;/li&gt; &lt;/ul&gt; (optional)
     * @param sourceType &lt;p&gt;The event source to retrieve events for. If no value is specified, all events are returned.&lt;/p&gt; &lt;p&gt;Constraints:&lt;/p&gt; &lt;p&gt;If &lt;i&gt;SourceType&lt;/i&gt; is supplied, &lt;i&gt;SourceIdentifier&lt;/i&gt; must also be provided.&lt;/p&gt; &lt;ul&gt; &lt;li&gt; &lt;p&gt;Specify &lt;code&gt;cluster&lt;/code&gt; when &lt;i&gt;SourceIdentifier&lt;/i&gt; is a cluster identifier.&lt;/p&gt; &lt;/li&gt; &lt;li&gt; &lt;p&gt;Specify &lt;code&gt;cluster-security-group&lt;/code&gt; when &lt;i&gt;SourceIdentifier&lt;/i&gt; is a cluster security group name.&lt;/p&gt; &lt;/li&gt; &lt;li&gt; &lt;p&gt;Specify &lt;code&gt;cluster-parameter-group&lt;/code&gt; when &lt;i&gt;SourceIdentifier&lt;/i&gt; is a cluster parameter group name.&lt;/p&gt; &lt;/li&gt; &lt;li&gt; &lt;p&gt;Specify &lt;code&gt;cluster-snapshot&lt;/code&gt; when &lt;i&gt;SourceIdentifier&lt;/i&gt; is a cluster snapshot identifier.&lt;/p&gt; &lt;/li&gt; &lt;/ul&gt; (optional)
     * @param startTime &lt;p&gt;The beginning of the time interval to retrieve events for, specified in ISO 8601 format. For more information about ISO 8601, go to the &lt;a href&#x3D;\&quot;http://en.wikipedia.org/wiki/ISO_8601\&quot;&gt;ISO8601 Wikipedia page.&lt;/a&gt; &lt;/p&gt; &lt;p&gt;Example: &lt;code&gt;2009-07-08T18:00Z&lt;/code&gt; &lt;/p&gt; (optional)
     * @param endTime &lt;p&gt;The end of the time interval for which to retrieve events, specified in ISO 8601 format. For more information about ISO 8601, go to the &lt;a href&#x3D;\&quot;http://en.wikipedia.org/wiki/ISO_8601\&quot;&gt;ISO8601 Wikipedia page.&lt;/a&gt; &lt;/p&gt; &lt;p&gt;Example: &lt;code&gt;2009-07-08T18:00Z&lt;/code&gt; &lt;/p&gt; (optional)
     * @param duration &lt;p&gt;The number of minutes prior to the time of the request for which to retrieve events. For example, if the request is sent at 18:00 and you specify a duration of 60, then only events which have occurred after 17:00 will be returned.&lt;/p&gt; &lt;p&gt;Default: &lt;code&gt;60&lt;/code&gt; &lt;/p&gt; (optional)
     * @param maxRecords &lt;p&gt;The maximum number of response records to return in each call. If the number of remaining response records exceeds the specified &lt;code&gt;MaxRecords&lt;/code&gt; value, a value is returned in a &lt;code&gt;marker&lt;/code&gt; field of the response. You can retrieve the next set of records by retrying the command with the returned marker value. &lt;/p&gt; &lt;p&gt;Default: &lt;code&gt;100&lt;/code&gt; &lt;/p&gt; &lt;p&gt;Constraints: minimum 20, maximum 100.&lt;/p&gt; (optional)
     * @param marker An optional parameter that specifies the starting point to return a set of response records. When the results of a &lt;a&gt;DescribeEvents&lt;/a&gt; request exceed the value specified in &lt;code&gt;MaxRecords&lt;/code&gt;, Amazon Web Services returns a value in the &lt;code&gt;Marker&lt;/code&gt; field of the response. You can retrieve the next set of response records by providing the returned marker value in the &lt;code&gt;Marker&lt;/code&gt; parameter and retrying the request.  (optional)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call gETDescribeEventsAsync(String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, String sourceIdentifier, String sourceType, OffsetDateTime startTime, OffsetDateTime endTime, Integer duration, Integer maxRecords, String marker, final ApiCallback<EventsMessage> _callback) throws ApiException {

        okhttp3.Call localVarCall = gETDescribeEventsValidateBeforeCall(action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, sourceIdentifier, sourceType, startTime, endTime, duration, maxRecords, marker, _callback);
        Type localVarReturnType = new TypeToken<EventsMessage>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for gETDescribeHsmClientCertificates
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param hsmClientCertificateIdentifier The identifier of a specific HSM client certificate for which you want information. If no identifier is specified, information is returned for all HSM client certificates owned by your Amazon Web Services account. (optional)
     * @param maxRecords &lt;p&gt;The maximum number of response records to return in each call. If the number of remaining response records exceeds the specified &lt;code&gt;MaxRecords&lt;/code&gt; value, a value is returned in a &lt;code&gt;marker&lt;/code&gt; field of the response. You can retrieve the next set of records by retrying the command with the returned marker value. &lt;/p&gt; &lt;p&gt;Default: &lt;code&gt;100&lt;/code&gt; &lt;/p&gt; &lt;p&gt;Constraints: minimum 20, maximum 100.&lt;/p&gt; (optional)
     * @param marker An optional parameter that specifies the starting point to return a set of response records. When the results of a &lt;a&gt;DescribeHsmClientCertificates&lt;/a&gt; request exceed the value specified in &lt;code&gt;MaxRecords&lt;/code&gt;, Amazon Web Services returns a value in the &lt;code&gt;Marker&lt;/code&gt; field of the response. You can retrieve the next set of response records by providing the returned marker value in the &lt;code&gt;Marker&lt;/code&gt; parameter and retrying the request.  (optional)
     * @param tagKeys A tag key or keys for which you want to return all matching HSM client certificates that are associated with the specified key or keys. For example, suppose that you have HSM client certificates that are tagged with keys called &lt;code&gt;owner&lt;/code&gt; and &lt;code&gt;environment&lt;/code&gt;. If you specify both of these tag keys in the request, Amazon Redshift returns a response with the HSM client certificates that have either or both of these tag keys associated with them. (optional)
     * @param tagValues A tag value or values for which you want to return all matching HSM client certificates that are associated with the specified tag value or values. For example, suppose that you have HSM client certificates that are tagged with values called &lt;code&gt;admin&lt;/code&gt; and &lt;code&gt;test&lt;/code&gt;. If you specify both of these tag values in the request, Amazon Redshift returns a response with the HSM client certificates that have either or both of these tag values associated with them. (optional)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> HsmClientCertificateNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> InvalidTagFault </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call gETDescribeHsmClientCertificatesCall(String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, String hsmClientCertificateIdentifier, Integer maxRecords, String marker, List<String> tagKeys, List<String> tagValues, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/#Action=DescribeHsmClientCertificates";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (hsmClientCertificateIdentifier != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("HsmClientCertificateIdentifier", hsmClientCertificateIdentifier));
        }

        if (maxRecords != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("MaxRecords", maxRecords));
        }

        if (marker != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("Marker", marker));
        }

        if (tagKeys != null) {
            localVarCollectionQueryParams.addAll(localVarApiClient.parameterToPairs("multi", "TagKeys", tagKeys));
        }

        if (tagValues != null) {
            localVarCollectionQueryParams.addAll(localVarApiClient.parameterToPairs("multi", "TagValues", tagValues));
        }

        if (action != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("Action", action));
        }

        if (version != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("Version", version));
        }

        if (xAmzContentSha256 != null) {
            localVarHeaderParams.put("X-Amz-Content-Sha256", localVarApiClient.parameterToString(xAmzContentSha256));
        }

        if (xAmzDate != null) {
            localVarHeaderParams.put("X-Amz-Date", localVarApiClient.parameterToString(xAmzDate));
        }

        if (xAmzAlgorithm != null) {
            localVarHeaderParams.put("X-Amz-Algorithm", localVarApiClient.parameterToString(xAmzAlgorithm));
        }

        if (xAmzCredential != null) {
            localVarHeaderParams.put("X-Amz-Credential", localVarApiClient.parameterToString(xAmzCredential));
        }

        if (xAmzSecurityToken != null) {
            localVarHeaderParams.put("X-Amz-Security-Token", localVarApiClient.parameterToString(xAmzSecurityToken));
        }

        if (xAmzSignature != null) {
            localVarHeaderParams.put("X-Amz-Signature", localVarApiClient.parameterToString(xAmzSignature));
        }

        if (xAmzSignedHeaders != null) {
            localVarHeaderParams.put("X-Amz-SignedHeaders", localVarApiClient.parameterToString(xAmzSignedHeaders));
        }

        final String[] localVarAccepts = {
            "text/xml"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "hmac" };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call gETDescribeHsmClientCertificatesValidateBeforeCall(String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, String hsmClientCertificateIdentifier, Integer maxRecords, String marker, List<String> tagKeys, List<String> tagValues, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'action' is set
        if (action == null) {
            throw new ApiException("Missing the required parameter 'action' when calling gETDescribeHsmClientCertificates(Async)");
        }

        // verify the required parameter 'version' is set
        if (version == null) {
            throw new ApiException("Missing the required parameter 'version' when calling gETDescribeHsmClientCertificates(Async)");
        }

        return gETDescribeHsmClientCertificatesCall(action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, hsmClientCertificateIdentifier, maxRecords, marker, tagKeys, tagValues, _callback);

    }

    /**
     * 
     * &lt;p&gt;Returns information about the specified HSM client certificate. If no certificate ID is specified, returns information about all the HSM certificates owned by your Amazon Web Services account.&lt;/p&gt; &lt;p&gt;If you specify both tag keys and tag values in the same request, Amazon Redshift returns all HSM client certificates that match any combination of the specified keys and values. For example, if you have &lt;code&gt;owner&lt;/code&gt; and &lt;code&gt;environment&lt;/code&gt; for tag keys, and &lt;code&gt;admin&lt;/code&gt; and &lt;code&gt;test&lt;/code&gt; for tag values, all HSM client certificates that have any combination of those values are returned.&lt;/p&gt; &lt;p&gt;If both tag keys and values are omitted from the request, HSM client certificates are returned regardless of whether they have tag keys or values associated with them.&lt;/p&gt;
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param hsmClientCertificateIdentifier The identifier of a specific HSM client certificate for which you want information. If no identifier is specified, information is returned for all HSM client certificates owned by your Amazon Web Services account. (optional)
     * @param maxRecords &lt;p&gt;The maximum number of response records to return in each call. If the number of remaining response records exceeds the specified &lt;code&gt;MaxRecords&lt;/code&gt; value, a value is returned in a &lt;code&gt;marker&lt;/code&gt; field of the response. You can retrieve the next set of records by retrying the command with the returned marker value. &lt;/p&gt; &lt;p&gt;Default: &lt;code&gt;100&lt;/code&gt; &lt;/p&gt; &lt;p&gt;Constraints: minimum 20, maximum 100.&lt;/p&gt; (optional)
     * @param marker An optional parameter that specifies the starting point to return a set of response records. When the results of a &lt;a&gt;DescribeHsmClientCertificates&lt;/a&gt; request exceed the value specified in &lt;code&gt;MaxRecords&lt;/code&gt;, Amazon Web Services returns a value in the &lt;code&gt;Marker&lt;/code&gt; field of the response. You can retrieve the next set of response records by providing the returned marker value in the &lt;code&gt;Marker&lt;/code&gt; parameter and retrying the request.  (optional)
     * @param tagKeys A tag key or keys for which you want to return all matching HSM client certificates that are associated with the specified key or keys. For example, suppose that you have HSM client certificates that are tagged with keys called &lt;code&gt;owner&lt;/code&gt; and &lt;code&gt;environment&lt;/code&gt;. If you specify both of these tag keys in the request, Amazon Redshift returns a response with the HSM client certificates that have either or both of these tag keys associated with them. (optional)
     * @param tagValues A tag value or values for which you want to return all matching HSM client certificates that are associated with the specified tag value or values. For example, suppose that you have HSM client certificates that are tagged with values called &lt;code&gt;admin&lt;/code&gt; and &lt;code&gt;test&lt;/code&gt;. If you specify both of these tag values in the request, Amazon Redshift returns a response with the HSM client certificates that have either or both of these tag values associated with them. (optional)
     * @return HsmClientCertificateMessage
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> HsmClientCertificateNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> InvalidTagFault </td><td>  -  </td></tr>
     </table>
     */
    public HsmClientCertificateMessage gETDescribeHsmClientCertificates(String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, String hsmClientCertificateIdentifier, Integer maxRecords, String marker, List<String> tagKeys, List<String> tagValues) throws ApiException {
        ApiResponse<HsmClientCertificateMessage> localVarResp = gETDescribeHsmClientCertificatesWithHttpInfo(action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, hsmClientCertificateIdentifier, maxRecords, marker, tagKeys, tagValues);
        return localVarResp.getData();
    }

    /**
     * 
     * &lt;p&gt;Returns information about the specified HSM client certificate. If no certificate ID is specified, returns information about all the HSM certificates owned by your Amazon Web Services account.&lt;/p&gt; &lt;p&gt;If you specify both tag keys and tag values in the same request, Amazon Redshift returns all HSM client certificates that match any combination of the specified keys and values. For example, if you have &lt;code&gt;owner&lt;/code&gt; and &lt;code&gt;environment&lt;/code&gt; for tag keys, and &lt;code&gt;admin&lt;/code&gt; and &lt;code&gt;test&lt;/code&gt; for tag values, all HSM client certificates that have any combination of those values are returned.&lt;/p&gt; &lt;p&gt;If both tag keys and values are omitted from the request, HSM client certificates are returned regardless of whether they have tag keys or values associated with them.&lt;/p&gt;
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param hsmClientCertificateIdentifier The identifier of a specific HSM client certificate for which you want information. If no identifier is specified, information is returned for all HSM client certificates owned by your Amazon Web Services account. (optional)
     * @param maxRecords &lt;p&gt;The maximum number of response records to return in each call. If the number of remaining response records exceeds the specified &lt;code&gt;MaxRecords&lt;/code&gt; value, a value is returned in a &lt;code&gt;marker&lt;/code&gt; field of the response. You can retrieve the next set of records by retrying the command with the returned marker value. &lt;/p&gt; &lt;p&gt;Default: &lt;code&gt;100&lt;/code&gt; &lt;/p&gt; &lt;p&gt;Constraints: minimum 20, maximum 100.&lt;/p&gt; (optional)
     * @param marker An optional parameter that specifies the starting point to return a set of response records. When the results of a &lt;a&gt;DescribeHsmClientCertificates&lt;/a&gt; request exceed the value specified in &lt;code&gt;MaxRecords&lt;/code&gt;, Amazon Web Services returns a value in the &lt;code&gt;Marker&lt;/code&gt; field of the response. You can retrieve the next set of response records by providing the returned marker value in the &lt;code&gt;Marker&lt;/code&gt; parameter and retrying the request.  (optional)
     * @param tagKeys A tag key or keys for which you want to return all matching HSM client certificates that are associated with the specified key or keys. For example, suppose that you have HSM client certificates that are tagged with keys called &lt;code&gt;owner&lt;/code&gt; and &lt;code&gt;environment&lt;/code&gt;. If you specify both of these tag keys in the request, Amazon Redshift returns a response with the HSM client certificates that have either or both of these tag keys associated with them. (optional)
     * @param tagValues A tag value or values for which you want to return all matching HSM client certificates that are associated with the specified tag value or values. For example, suppose that you have HSM client certificates that are tagged with values called &lt;code&gt;admin&lt;/code&gt; and &lt;code&gt;test&lt;/code&gt;. If you specify both of these tag values in the request, Amazon Redshift returns a response with the HSM client certificates that have either or both of these tag values associated with them. (optional)
     * @return ApiResponse&lt;HsmClientCertificateMessage&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> HsmClientCertificateNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> InvalidTagFault </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<HsmClientCertificateMessage> gETDescribeHsmClientCertificatesWithHttpInfo(String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, String hsmClientCertificateIdentifier, Integer maxRecords, String marker, List<String> tagKeys, List<String> tagValues) throws ApiException {
        okhttp3.Call localVarCall = gETDescribeHsmClientCertificatesValidateBeforeCall(action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, hsmClientCertificateIdentifier, maxRecords, marker, tagKeys, tagValues, null);
        Type localVarReturnType = new TypeToken<HsmClientCertificateMessage>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     *  (asynchronously)
     * &lt;p&gt;Returns information about the specified HSM client certificate. If no certificate ID is specified, returns information about all the HSM certificates owned by your Amazon Web Services account.&lt;/p&gt; &lt;p&gt;If you specify both tag keys and tag values in the same request, Amazon Redshift returns all HSM client certificates that match any combination of the specified keys and values. For example, if you have &lt;code&gt;owner&lt;/code&gt; and &lt;code&gt;environment&lt;/code&gt; for tag keys, and &lt;code&gt;admin&lt;/code&gt; and &lt;code&gt;test&lt;/code&gt; for tag values, all HSM client certificates that have any combination of those values are returned.&lt;/p&gt; &lt;p&gt;If both tag keys and values are omitted from the request, HSM client certificates are returned regardless of whether they have tag keys or values associated with them.&lt;/p&gt;
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param hsmClientCertificateIdentifier The identifier of a specific HSM client certificate for which you want information. If no identifier is specified, information is returned for all HSM client certificates owned by your Amazon Web Services account. (optional)
     * @param maxRecords &lt;p&gt;The maximum number of response records to return in each call. If the number of remaining response records exceeds the specified &lt;code&gt;MaxRecords&lt;/code&gt; value, a value is returned in a &lt;code&gt;marker&lt;/code&gt; field of the response. You can retrieve the next set of records by retrying the command with the returned marker value. &lt;/p&gt; &lt;p&gt;Default: &lt;code&gt;100&lt;/code&gt; &lt;/p&gt; &lt;p&gt;Constraints: minimum 20, maximum 100.&lt;/p&gt; (optional)
     * @param marker An optional parameter that specifies the starting point to return a set of response records. When the results of a &lt;a&gt;DescribeHsmClientCertificates&lt;/a&gt; request exceed the value specified in &lt;code&gt;MaxRecords&lt;/code&gt;, Amazon Web Services returns a value in the &lt;code&gt;Marker&lt;/code&gt; field of the response. You can retrieve the next set of response records by providing the returned marker value in the &lt;code&gt;Marker&lt;/code&gt; parameter and retrying the request.  (optional)
     * @param tagKeys A tag key or keys for which you want to return all matching HSM client certificates that are associated with the specified key or keys. For example, suppose that you have HSM client certificates that are tagged with keys called &lt;code&gt;owner&lt;/code&gt; and &lt;code&gt;environment&lt;/code&gt;. If you specify both of these tag keys in the request, Amazon Redshift returns a response with the HSM client certificates that have either or both of these tag keys associated with them. (optional)
     * @param tagValues A tag value or values for which you want to return all matching HSM client certificates that are associated with the specified tag value or values. For example, suppose that you have HSM client certificates that are tagged with values called &lt;code&gt;admin&lt;/code&gt; and &lt;code&gt;test&lt;/code&gt;. If you specify both of these tag values in the request, Amazon Redshift returns a response with the HSM client certificates that have either or both of these tag values associated with them. (optional)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> HsmClientCertificateNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> InvalidTagFault </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call gETDescribeHsmClientCertificatesAsync(String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, String hsmClientCertificateIdentifier, Integer maxRecords, String marker, List<String> tagKeys, List<String> tagValues, final ApiCallback<HsmClientCertificateMessage> _callback) throws ApiException {

        okhttp3.Call localVarCall = gETDescribeHsmClientCertificatesValidateBeforeCall(action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, hsmClientCertificateIdentifier, maxRecords, marker, tagKeys, tagValues, _callback);
        Type localVarReturnType = new TypeToken<HsmClientCertificateMessage>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for gETDescribeHsmConfigurations
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param hsmConfigurationIdentifier The identifier of a specific Amazon Redshift HSM configuration to be described. If no identifier is specified, information is returned for all HSM configurations owned by your Amazon Web Services account. (optional)
     * @param maxRecords &lt;p&gt;The maximum number of response records to return in each call. If the number of remaining response records exceeds the specified &lt;code&gt;MaxRecords&lt;/code&gt; value, a value is returned in a &lt;code&gt;marker&lt;/code&gt; field of the response. You can retrieve the next set of records by retrying the command with the returned marker value. &lt;/p&gt; &lt;p&gt;Default: &lt;code&gt;100&lt;/code&gt; &lt;/p&gt; &lt;p&gt;Constraints: minimum 20, maximum 100.&lt;/p&gt; (optional)
     * @param marker An optional parameter that specifies the starting point to return a set of response records. When the results of a &lt;a&gt;DescribeHsmConfigurations&lt;/a&gt; request exceed the value specified in &lt;code&gt;MaxRecords&lt;/code&gt;, Amazon Web Services returns a value in the &lt;code&gt;Marker&lt;/code&gt; field of the response. You can retrieve the next set of response records by providing the returned marker value in the &lt;code&gt;Marker&lt;/code&gt; parameter and retrying the request.  (optional)
     * @param tagKeys A tag key or keys for which you want to return all matching HSM configurations that are associated with the specified key or keys. For example, suppose that you have HSM configurations that are tagged with keys called &lt;code&gt;owner&lt;/code&gt; and &lt;code&gt;environment&lt;/code&gt;. If you specify both of these tag keys in the request, Amazon Redshift returns a response with the HSM configurations that have either or both of these tag keys associated with them. (optional)
     * @param tagValues A tag value or values for which you want to return all matching HSM configurations that are associated with the specified tag value or values. For example, suppose that you have HSM configurations that are tagged with values called &lt;code&gt;admin&lt;/code&gt; and &lt;code&gt;test&lt;/code&gt;. If you specify both of these tag values in the request, Amazon Redshift returns a response with the HSM configurations that have either or both of these tag values associated with them. (optional)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> HsmConfigurationNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> InvalidTagFault </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call gETDescribeHsmConfigurationsCall(String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, String hsmConfigurationIdentifier, Integer maxRecords, String marker, List<String> tagKeys, List<String> tagValues, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/#Action=DescribeHsmConfigurations";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (hsmConfigurationIdentifier != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("HsmConfigurationIdentifier", hsmConfigurationIdentifier));
        }

        if (maxRecords != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("MaxRecords", maxRecords));
        }

        if (marker != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("Marker", marker));
        }

        if (tagKeys != null) {
            localVarCollectionQueryParams.addAll(localVarApiClient.parameterToPairs("multi", "TagKeys", tagKeys));
        }

        if (tagValues != null) {
            localVarCollectionQueryParams.addAll(localVarApiClient.parameterToPairs("multi", "TagValues", tagValues));
        }

        if (action != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("Action", action));
        }

        if (version != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("Version", version));
        }

        if (xAmzContentSha256 != null) {
            localVarHeaderParams.put("X-Amz-Content-Sha256", localVarApiClient.parameterToString(xAmzContentSha256));
        }

        if (xAmzDate != null) {
            localVarHeaderParams.put("X-Amz-Date", localVarApiClient.parameterToString(xAmzDate));
        }

        if (xAmzAlgorithm != null) {
            localVarHeaderParams.put("X-Amz-Algorithm", localVarApiClient.parameterToString(xAmzAlgorithm));
        }

        if (xAmzCredential != null) {
            localVarHeaderParams.put("X-Amz-Credential", localVarApiClient.parameterToString(xAmzCredential));
        }

        if (xAmzSecurityToken != null) {
            localVarHeaderParams.put("X-Amz-Security-Token", localVarApiClient.parameterToString(xAmzSecurityToken));
        }

        if (xAmzSignature != null) {
            localVarHeaderParams.put("X-Amz-Signature", localVarApiClient.parameterToString(xAmzSignature));
        }

        if (xAmzSignedHeaders != null) {
            localVarHeaderParams.put("X-Amz-SignedHeaders", localVarApiClient.parameterToString(xAmzSignedHeaders));
        }

        final String[] localVarAccepts = {
            "text/xml"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "hmac" };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call gETDescribeHsmConfigurationsValidateBeforeCall(String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, String hsmConfigurationIdentifier, Integer maxRecords, String marker, List<String> tagKeys, List<String> tagValues, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'action' is set
        if (action == null) {
            throw new ApiException("Missing the required parameter 'action' when calling gETDescribeHsmConfigurations(Async)");
        }

        // verify the required parameter 'version' is set
        if (version == null) {
            throw new ApiException("Missing the required parameter 'version' when calling gETDescribeHsmConfigurations(Async)");
        }

        return gETDescribeHsmConfigurationsCall(action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, hsmConfigurationIdentifier, maxRecords, marker, tagKeys, tagValues, _callback);

    }

    /**
     * 
     * &lt;p&gt;Returns information about the specified Amazon Redshift HSM configuration. If no configuration ID is specified, returns information about all the HSM configurations owned by your Amazon Web Services account.&lt;/p&gt; &lt;p&gt;If you specify both tag keys and tag values in the same request, Amazon Redshift returns all HSM connections that match any combination of the specified keys and values. For example, if you have &lt;code&gt;owner&lt;/code&gt; and &lt;code&gt;environment&lt;/code&gt; for tag keys, and &lt;code&gt;admin&lt;/code&gt; and &lt;code&gt;test&lt;/code&gt; for tag values, all HSM connections that have any combination of those values are returned.&lt;/p&gt; &lt;p&gt;If both tag keys and values are omitted from the request, HSM connections are returned regardless of whether they have tag keys or values associated with them.&lt;/p&gt;
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param hsmConfigurationIdentifier The identifier of a specific Amazon Redshift HSM configuration to be described. If no identifier is specified, information is returned for all HSM configurations owned by your Amazon Web Services account. (optional)
     * @param maxRecords &lt;p&gt;The maximum number of response records to return in each call. If the number of remaining response records exceeds the specified &lt;code&gt;MaxRecords&lt;/code&gt; value, a value is returned in a &lt;code&gt;marker&lt;/code&gt; field of the response. You can retrieve the next set of records by retrying the command with the returned marker value. &lt;/p&gt; &lt;p&gt;Default: &lt;code&gt;100&lt;/code&gt; &lt;/p&gt; &lt;p&gt;Constraints: minimum 20, maximum 100.&lt;/p&gt; (optional)
     * @param marker An optional parameter that specifies the starting point to return a set of response records. When the results of a &lt;a&gt;DescribeHsmConfigurations&lt;/a&gt; request exceed the value specified in &lt;code&gt;MaxRecords&lt;/code&gt;, Amazon Web Services returns a value in the &lt;code&gt;Marker&lt;/code&gt; field of the response. You can retrieve the next set of response records by providing the returned marker value in the &lt;code&gt;Marker&lt;/code&gt; parameter and retrying the request.  (optional)
     * @param tagKeys A tag key or keys for which you want to return all matching HSM configurations that are associated with the specified key or keys. For example, suppose that you have HSM configurations that are tagged with keys called &lt;code&gt;owner&lt;/code&gt; and &lt;code&gt;environment&lt;/code&gt;. If you specify both of these tag keys in the request, Amazon Redshift returns a response with the HSM configurations that have either or both of these tag keys associated with them. (optional)
     * @param tagValues A tag value or values for which you want to return all matching HSM configurations that are associated with the specified tag value or values. For example, suppose that you have HSM configurations that are tagged with values called &lt;code&gt;admin&lt;/code&gt; and &lt;code&gt;test&lt;/code&gt;. If you specify both of these tag values in the request, Amazon Redshift returns a response with the HSM configurations that have either or both of these tag values associated with them. (optional)
     * @return HsmConfigurationMessage
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> HsmConfigurationNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> InvalidTagFault </td><td>  -  </td></tr>
     </table>
     */
    public HsmConfigurationMessage gETDescribeHsmConfigurations(String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, String hsmConfigurationIdentifier, Integer maxRecords, String marker, List<String> tagKeys, List<String> tagValues) throws ApiException {
        ApiResponse<HsmConfigurationMessage> localVarResp = gETDescribeHsmConfigurationsWithHttpInfo(action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, hsmConfigurationIdentifier, maxRecords, marker, tagKeys, tagValues);
        return localVarResp.getData();
    }

    /**
     * 
     * &lt;p&gt;Returns information about the specified Amazon Redshift HSM configuration. If no configuration ID is specified, returns information about all the HSM configurations owned by your Amazon Web Services account.&lt;/p&gt; &lt;p&gt;If you specify both tag keys and tag values in the same request, Amazon Redshift returns all HSM connections that match any combination of the specified keys and values. For example, if you have &lt;code&gt;owner&lt;/code&gt; and &lt;code&gt;environment&lt;/code&gt; for tag keys, and &lt;code&gt;admin&lt;/code&gt; and &lt;code&gt;test&lt;/code&gt; for tag values, all HSM connections that have any combination of those values are returned.&lt;/p&gt; &lt;p&gt;If both tag keys and values are omitted from the request, HSM connections are returned regardless of whether they have tag keys or values associated with them.&lt;/p&gt;
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param hsmConfigurationIdentifier The identifier of a specific Amazon Redshift HSM configuration to be described. If no identifier is specified, information is returned for all HSM configurations owned by your Amazon Web Services account. (optional)
     * @param maxRecords &lt;p&gt;The maximum number of response records to return in each call. If the number of remaining response records exceeds the specified &lt;code&gt;MaxRecords&lt;/code&gt; value, a value is returned in a &lt;code&gt;marker&lt;/code&gt; field of the response. You can retrieve the next set of records by retrying the command with the returned marker value. &lt;/p&gt; &lt;p&gt;Default: &lt;code&gt;100&lt;/code&gt; &lt;/p&gt; &lt;p&gt;Constraints: minimum 20, maximum 100.&lt;/p&gt; (optional)
     * @param marker An optional parameter that specifies the starting point to return a set of response records. When the results of a &lt;a&gt;DescribeHsmConfigurations&lt;/a&gt; request exceed the value specified in &lt;code&gt;MaxRecords&lt;/code&gt;, Amazon Web Services returns a value in the &lt;code&gt;Marker&lt;/code&gt; field of the response. You can retrieve the next set of response records by providing the returned marker value in the &lt;code&gt;Marker&lt;/code&gt; parameter and retrying the request.  (optional)
     * @param tagKeys A tag key or keys for which you want to return all matching HSM configurations that are associated with the specified key or keys. For example, suppose that you have HSM configurations that are tagged with keys called &lt;code&gt;owner&lt;/code&gt; and &lt;code&gt;environment&lt;/code&gt;. If you specify both of these tag keys in the request, Amazon Redshift returns a response with the HSM configurations that have either or both of these tag keys associated with them. (optional)
     * @param tagValues A tag value or values for which you want to return all matching HSM configurations that are associated with the specified tag value or values. For example, suppose that you have HSM configurations that are tagged with values called &lt;code&gt;admin&lt;/code&gt; and &lt;code&gt;test&lt;/code&gt;. If you specify both of these tag values in the request, Amazon Redshift returns a response with the HSM configurations that have either or both of these tag values associated with them. (optional)
     * @return ApiResponse&lt;HsmConfigurationMessage&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> HsmConfigurationNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> InvalidTagFault </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<HsmConfigurationMessage> gETDescribeHsmConfigurationsWithHttpInfo(String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, String hsmConfigurationIdentifier, Integer maxRecords, String marker, List<String> tagKeys, List<String> tagValues) throws ApiException {
        okhttp3.Call localVarCall = gETDescribeHsmConfigurationsValidateBeforeCall(action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, hsmConfigurationIdentifier, maxRecords, marker, tagKeys, tagValues, null);
        Type localVarReturnType = new TypeToken<HsmConfigurationMessage>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     *  (asynchronously)
     * &lt;p&gt;Returns information about the specified Amazon Redshift HSM configuration. If no configuration ID is specified, returns information about all the HSM configurations owned by your Amazon Web Services account.&lt;/p&gt; &lt;p&gt;If you specify both tag keys and tag values in the same request, Amazon Redshift returns all HSM connections that match any combination of the specified keys and values. For example, if you have &lt;code&gt;owner&lt;/code&gt; and &lt;code&gt;environment&lt;/code&gt; for tag keys, and &lt;code&gt;admin&lt;/code&gt; and &lt;code&gt;test&lt;/code&gt; for tag values, all HSM connections that have any combination of those values are returned.&lt;/p&gt; &lt;p&gt;If both tag keys and values are omitted from the request, HSM connections are returned regardless of whether they have tag keys or values associated with them.&lt;/p&gt;
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param hsmConfigurationIdentifier The identifier of a specific Amazon Redshift HSM configuration to be described. If no identifier is specified, information is returned for all HSM configurations owned by your Amazon Web Services account. (optional)
     * @param maxRecords &lt;p&gt;The maximum number of response records to return in each call. If the number of remaining response records exceeds the specified &lt;code&gt;MaxRecords&lt;/code&gt; value, a value is returned in a &lt;code&gt;marker&lt;/code&gt; field of the response. You can retrieve the next set of records by retrying the command with the returned marker value. &lt;/p&gt; &lt;p&gt;Default: &lt;code&gt;100&lt;/code&gt; &lt;/p&gt; &lt;p&gt;Constraints: minimum 20, maximum 100.&lt;/p&gt; (optional)
     * @param marker An optional parameter that specifies the starting point to return a set of response records. When the results of a &lt;a&gt;DescribeHsmConfigurations&lt;/a&gt; request exceed the value specified in &lt;code&gt;MaxRecords&lt;/code&gt;, Amazon Web Services returns a value in the &lt;code&gt;Marker&lt;/code&gt; field of the response. You can retrieve the next set of response records by providing the returned marker value in the &lt;code&gt;Marker&lt;/code&gt; parameter and retrying the request.  (optional)
     * @param tagKeys A tag key or keys for which you want to return all matching HSM configurations that are associated with the specified key or keys. For example, suppose that you have HSM configurations that are tagged with keys called &lt;code&gt;owner&lt;/code&gt; and &lt;code&gt;environment&lt;/code&gt;. If you specify both of these tag keys in the request, Amazon Redshift returns a response with the HSM configurations that have either or both of these tag keys associated with them. (optional)
     * @param tagValues A tag value or values for which you want to return all matching HSM configurations that are associated with the specified tag value or values. For example, suppose that you have HSM configurations that are tagged with values called &lt;code&gt;admin&lt;/code&gt; and &lt;code&gt;test&lt;/code&gt;. If you specify both of these tag values in the request, Amazon Redshift returns a response with the HSM configurations that have either or both of these tag values associated with them. (optional)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> HsmConfigurationNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> InvalidTagFault </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call gETDescribeHsmConfigurationsAsync(String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, String hsmConfigurationIdentifier, Integer maxRecords, String marker, List<String> tagKeys, List<String> tagValues, final ApiCallback<HsmConfigurationMessage> _callback) throws ApiException {

        okhttp3.Call localVarCall = gETDescribeHsmConfigurationsValidateBeforeCall(action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, hsmConfigurationIdentifier, maxRecords, marker, tagKeys, tagValues, _callback);
        Type localVarReturnType = new TypeToken<HsmConfigurationMessage>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for gETDescribeLoggingStatus
     * @param clusterIdentifier &lt;p&gt;The identifier of the cluster from which to get the logging status.&lt;/p&gt; &lt;p&gt;Example: &lt;code&gt;examplecluster&lt;/code&gt; &lt;/p&gt; (required)
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> ClusterNotFoundFault </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call gETDescribeLoggingStatusCall(String clusterIdentifier, String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/#Action=DescribeLoggingStatus";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (clusterIdentifier != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("ClusterIdentifier", clusterIdentifier));
        }

        if (action != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("Action", action));
        }

        if (version != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("Version", version));
        }

        if (xAmzContentSha256 != null) {
            localVarHeaderParams.put("X-Amz-Content-Sha256", localVarApiClient.parameterToString(xAmzContentSha256));
        }

        if (xAmzDate != null) {
            localVarHeaderParams.put("X-Amz-Date", localVarApiClient.parameterToString(xAmzDate));
        }

        if (xAmzAlgorithm != null) {
            localVarHeaderParams.put("X-Amz-Algorithm", localVarApiClient.parameterToString(xAmzAlgorithm));
        }

        if (xAmzCredential != null) {
            localVarHeaderParams.put("X-Amz-Credential", localVarApiClient.parameterToString(xAmzCredential));
        }

        if (xAmzSecurityToken != null) {
            localVarHeaderParams.put("X-Amz-Security-Token", localVarApiClient.parameterToString(xAmzSecurityToken));
        }

        if (xAmzSignature != null) {
            localVarHeaderParams.put("X-Amz-Signature", localVarApiClient.parameterToString(xAmzSignature));
        }

        if (xAmzSignedHeaders != null) {
            localVarHeaderParams.put("X-Amz-SignedHeaders", localVarApiClient.parameterToString(xAmzSignedHeaders));
        }

        final String[] localVarAccepts = {
            "text/xml"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "hmac" };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call gETDescribeLoggingStatusValidateBeforeCall(String clusterIdentifier, String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'clusterIdentifier' is set
        if (clusterIdentifier == null) {
            throw new ApiException("Missing the required parameter 'clusterIdentifier' when calling gETDescribeLoggingStatus(Async)");
        }

        // verify the required parameter 'action' is set
        if (action == null) {
            throw new ApiException("Missing the required parameter 'action' when calling gETDescribeLoggingStatus(Async)");
        }

        // verify the required parameter 'version' is set
        if (version == null) {
            throw new ApiException("Missing the required parameter 'version' when calling gETDescribeLoggingStatus(Async)");
        }

        return gETDescribeLoggingStatusCall(clusterIdentifier, action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, _callback);

    }

    /**
     * 
     * Describes whether information, such as queries and connection attempts, is being logged for the specified Amazon Redshift cluster.
     * @param clusterIdentifier &lt;p&gt;The identifier of the cluster from which to get the logging status.&lt;/p&gt; &lt;p&gt;Example: &lt;code&gt;examplecluster&lt;/code&gt; &lt;/p&gt; (required)
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @return LoggingStatus
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> ClusterNotFoundFault </td><td>  -  </td></tr>
     </table>
     */
    public LoggingStatus gETDescribeLoggingStatus(String clusterIdentifier, String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders) throws ApiException {
        ApiResponse<LoggingStatus> localVarResp = gETDescribeLoggingStatusWithHttpInfo(clusterIdentifier, action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders);
        return localVarResp.getData();
    }

    /**
     * 
     * Describes whether information, such as queries and connection attempts, is being logged for the specified Amazon Redshift cluster.
     * @param clusterIdentifier &lt;p&gt;The identifier of the cluster from which to get the logging status.&lt;/p&gt; &lt;p&gt;Example: &lt;code&gt;examplecluster&lt;/code&gt; &lt;/p&gt; (required)
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @return ApiResponse&lt;LoggingStatus&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> ClusterNotFoundFault </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<LoggingStatus> gETDescribeLoggingStatusWithHttpInfo(String clusterIdentifier, String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders) throws ApiException {
        okhttp3.Call localVarCall = gETDescribeLoggingStatusValidateBeforeCall(clusterIdentifier, action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, null);
        Type localVarReturnType = new TypeToken<LoggingStatus>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     *  (asynchronously)
     * Describes whether information, such as queries and connection attempts, is being logged for the specified Amazon Redshift cluster.
     * @param clusterIdentifier &lt;p&gt;The identifier of the cluster from which to get the logging status.&lt;/p&gt; &lt;p&gt;Example: &lt;code&gt;examplecluster&lt;/code&gt; &lt;/p&gt; (required)
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> ClusterNotFoundFault </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call gETDescribeLoggingStatusAsync(String clusterIdentifier, String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, final ApiCallback<LoggingStatus> _callback) throws ApiException {

        okhttp3.Call localVarCall = gETDescribeLoggingStatusValidateBeforeCall(clusterIdentifier, action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, _callback);
        Type localVarReturnType = new TypeToken<LoggingStatus>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for gETDescribeNodeConfigurationOptions
     * @param actionType The action type to evaluate for possible node configurations. Specify \&quot;restore-cluster\&quot; to get configuration combinations based on an existing snapshot. Specify \&quot;recommend-node-config\&quot; to get configuration recommendations based on an existing cluster or snapshot. Specify \&quot;resize-cluster\&quot; to get configuration combinations for elastic resize based on an existing cluster.  (required)
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param clusterIdentifier The identifier of the cluster to evaluate for possible node configurations. (optional)
     * @param snapshotIdentifier The identifier of the snapshot to evaluate for possible node configurations. (optional)
     * @param snapshotArn The Amazon Resource Name (ARN) of the snapshot associated with the message to describe node configuration. (optional)
     * @param ownerAccount The Amazon Web Services account used to create or copy the snapshot. Required if you are restoring a snapshot you do not own, optional if you own the snapshot. (optional)
     * @param filter A set of name, operator, and value items to filter the results. (optional)
     * @param marker An optional parameter that specifies the starting point to return a set of response records. When the results of a &lt;a&gt;DescribeNodeConfigurationOptions&lt;/a&gt; request exceed the value specified in &lt;code&gt;MaxRecords&lt;/code&gt;, Amazon Web Services returns a value in the &lt;code&gt;Marker&lt;/code&gt; field of the response. You can retrieve the next set of response records by providing the returned marker value in the &lt;code&gt;Marker&lt;/code&gt; parameter and retrying the request.  (optional)
     * @param maxRecords &lt;p&gt;The maximum number of response records to return in each call. If the number of remaining response records exceeds the specified &lt;code&gt;MaxRecords&lt;/code&gt; value, a value is returned in a &lt;code&gt;marker&lt;/code&gt; field of the response. You can retrieve the next set of records by retrying the command with the returned marker value. &lt;/p&gt; &lt;p&gt;Default: &lt;code&gt;500&lt;/code&gt; &lt;/p&gt; &lt;p&gt;Constraints: minimum 100, maximum 500.&lt;/p&gt; (optional)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> ClusterSnapshotNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> InvalidClusterSnapshotStateFault </td><td>  -  </td></tr>
        <tr><td> 482 </td><td> ClusterNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 483 </td><td> AccessToSnapshotDeniedFault </td><td>  -  </td></tr>
        <tr><td> 484 </td><td> UnsupportedOperationFault </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call gETDescribeNodeConfigurationOptionsCall(String actionType, String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, String clusterIdentifier, String snapshotIdentifier, String snapshotArn, String ownerAccount, List<GETDescribeNodeConfigurationOptionsFilterParameterInner> filter, String marker, Integer maxRecords, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/#Action=DescribeNodeConfigurationOptions";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (actionType != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("ActionType", actionType));
        }

        if (clusterIdentifier != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("ClusterIdentifier", clusterIdentifier));
        }

        if (snapshotIdentifier != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("SnapshotIdentifier", snapshotIdentifier));
        }

        if (snapshotArn != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("SnapshotArn", snapshotArn));
        }

        if (ownerAccount != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("OwnerAccount", ownerAccount));
        }

        if (filter != null) {
            localVarCollectionQueryParams.addAll(localVarApiClient.parameterToPairs("multi", "Filter", filter));
        }

        if (marker != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("Marker", marker));
        }

        if (maxRecords != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("MaxRecords", maxRecords));
        }

        if (action != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("Action", action));
        }

        if (version != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("Version", version));
        }

        if (xAmzContentSha256 != null) {
            localVarHeaderParams.put("X-Amz-Content-Sha256", localVarApiClient.parameterToString(xAmzContentSha256));
        }

        if (xAmzDate != null) {
            localVarHeaderParams.put("X-Amz-Date", localVarApiClient.parameterToString(xAmzDate));
        }

        if (xAmzAlgorithm != null) {
            localVarHeaderParams.put("X-Amz-Algorithm", localVarApiClient.parameterToString(xAmzAlgorithm));
        }

        if (xAmzCredential != null) {
            localVarHeaderParams.put("X-Amz-Credential", localVarApiClient.parameterToString(xAmzCredential));
        }

        if (xAmzSecurityToken != null) {
            localVarHeaderParams.put("X-Amz-Security-Token", localVarApiClient.parameterToString(xAmzSecurityToken));
        }

        if (xAmzSignature != null) {
            localVarHeaderParams.put("X-Amz-Signature", localVarApiClient.parameterToString(xAmzSignature));
        }

        if (xAmzSignedHeaders != null) {
            localVarHeaderParams.put("X-Amz-SignedHeaders", localVarApiClient.parameterToString(xAmzSignedHeaders));
        }

        final String[] localVarAccepts = {
            "text/xml"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "hmac" };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call gETDescribeNodeConfigurationOptionsValidateBeforeCall(String actionType, String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, String clusterIdentifier, String snapshotIdentifier, String snapshotArn, String ownerAccount, List<GETDescribeNodeConfigurationOptionsFilterParameterInner> filter, String marker, Integer maxRecords, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'actionType' is set
        if (actionType == null) {
            throw new ApiException("Missing the required parameter 'actionType' when calling gETDescribeNodeConfigurationOptions(Async)");
        }

        // verify the required parameter 'action' is set
        if (action == null) {
            throw new ApiException("Missing the required parameter 'action' when calling gETDescribeNodeConfigurationOptions(Async)");
        }

        // verify the required parameter 'version' is set
        if (version == null) {
            throw new ApiException("Missing the required parameter 'version' when calling gETDescribeNodeConfigurationOptions(Async)");
        }

        return gETDescribeNodeConfigurationOptionsCall(actionType, action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, clusterIdentifier, snapshotIdentifier, snapshotArn, ownerAccount, filter, marker, maxRecords, _callback);

    }

    /**
     * 
     * Returns properties of possible node configurations such as node type, number of nodes, and disk usage for the specified action type.
     * @param actionType The action type to evaluate for possible node configurations. Specify \&quot;restore-cluster\&quot; to get configuration combinations based on an existing snapshot. Specify \&quot;recommend-node-config\&quot; to get configuration recommendations based on an existing cluster or snapshot. Specify \&quot;resize-cluster\&quot; to get configuration combinations for elastic resize based on an existing cluster.  (required)
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param clusterIdentifier The identifier of the cluster to evaluate for possible node configurations. (optional)
     * @param snapshotIdentifier The identifier of the snapshot to evaluate for possible node configurations. (optional)
     * @param snapshotArn The Amazon Resource Name (ARN) of the snapshot associated with the message to describe node configuration. (optional)
     * @param ownerAccount The Amazon Web Services account used to create or copy the snapshot. Required if you are restoring a snapshot you do not own, optional if you own the snapshot. (optional)
     * @param filter A set of name, operator, and value items to filter the results. (optional)
     * @param marker An optional parameter that specifies the starting point to return a set of response records. When the results of a &lt;a&gt;DescribeNodeConfigurationOptions&lt;/a&gt; request exceed the value specified in &lt;code&gt;MaxRecords&lt;/code&gt;, Amazon Web Services returns a value in the &lt;code&gt;Marker&lt;/code&gt; field of the response. You can retrieve the next set of response records by providing the returned marker value in the &lt;code&gt;Marker&lt;/code&gt; parameter and retrying the request.  (optional)
     * @param maxRecords &lt;p&gt;The maximum number of response records to return in each call. If the number of remaining response records exceeds the specified &lt;code&gt;MaxRecords&lt;/code&gt; value, a value is returned in a &lt;code&gt;marker&lt;/code&gt; field of the response. You can retrieve the next set of records by retrying the command with the returned marker value. &lt;/p&gt; &lt;p&gt;Default: &lt;code&gt;500&lt;/code&gt; &lt;/p&gt; &lt;p&gt;Constraints: minimum 100, maximum 500.&lt;/p&gt; (optional)
     * @return NodeConfigurationOptionsMessage
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> ClusterSnapshotNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> InvalidClusterSnapshotStateFault </td><td>  -  </td></tr>
        <tr><td> 482 </td><td> ClusterNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 483 </td><td> AccessToSnapshotDeniedFault </td><td>  -  </td></tr>
        <tr><td> 484 </td><td> UnsupportedOperationFault </td><td>  -  </td></tr>
     </table>
     */
    public NodeConfigurationOptionsMessage gETDescribeNodeConfigurationOptions(String actionType, String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, String clusterIdentifier, String snapshotIdentifier, String snapshotArn, String ownerAccount, List<GETDescribeNodeConfigurationOptionsFilterParameterInner> filter, String marker, Integer maxRecords) throws ApiException {
        ApiResponse<NodeConfigurationOptionsMessage> localVarResp = gETDescribeNodeConfigurationOptionsWithHttpInfo(actionType, action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, clusterIdentifier, snapshotIdentifier, snapshotArn, ownerAccount, filter, marker, maxRecords);
        return localVarResp.getData();
    }

    /**
     * 
     * Returns properties of possible node configurations such as node type, number of nodes, and disk usage for the specified action type.
     * @param actionType The action type to evaluate for possible node configurations. Specify \&quot;restore-cluster\&quot; to get configuration combinations based on an existing snapshot. Specify \&quot;recommend-node-config\&quot; to get configuration recommendations based on an existing cluster or snapshot. Specify \&quot;resize-cluster\&quot; to get configuration combinations for elastic resize based on an existing cluster.  (required)
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param clusterIdentifier The identifier of the cluster to evaluate for possible node configurations. (optional)
     * @param snapshotIdentifier The identifier of the snapshot to evaluate for possible node configurations. (optional)
     * @param snapshotArn The Amazon Resource Name (ARN) of the snapshot associated with the message to describe node configuration. (optional)
     * @param ownerAccount The Amazon Web Services account used to create or copy the snapshot. Required if you are restoring a snapshot you do not own, optional if you own the snapshot. (optional)
     * @param filter A set of name, operator, and value items to filter the results. (optional)
     * @param marker An optional parameter that specifies the starting point to return a set of response records. When the results of a &lt;a&gt;DescribeNodeConfigurationOptions&lt;/a&gt; request exceed the value specified in &lt;code&gt;MaxRecords&lt;/code&gt;, Amazon Web Services returns a value in the &lt;code&gt;Marker&lt;/code&gt; field of the response. You can retrieve the next set of response records by providing the returned marker value in the &lt;code&gt;Marker&lt;/code&gt; parameter and retrying the request.  (optional)
     * @param maxRecords &lt;p&gt;The maximum number of response records to return in each call. If the number of remaining response records exceeds the specified &lt;code&gt;MaxRecords&lt;/code&gt; value, a value is returned in a &lt;code&gt;marker&lt;/code&gt; field of the response. You can retrieve the next set of records by retrying the command with the returned marker value. &lt;/p&gt; &lt;p&gt;Default: &lt;code&gt;500&lt;/code&gt; &lt;/p&gt; &lt;p&gt;Constraints: minimum 100, maximum 500.&lt;/p&gt; (optional)
     * @return ApiResponse&lt;NodeConfigurationOptionsMessage&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> ClusterSnapshotNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> InvalidClusterSnapshotStateFault </td><td>  -  </td></tr>
        <tr><td> 482 </td><td> ClusterNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 483 </td><td> AccessToSnapshotDeniedFault </td><td>  -  </td></tr>
        <tr><td> 484 </td><td> UnsupportedOperationFault </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<NodeConfigurationOptionsMessage> gETDescribeNodeConfigurationOptionsWithHttpInfo(String actionType, String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, String clusterIdentifier, String snapshotIdentifier, String snapshotArn, String ownerAccount, List<GETDescribeNodeConfigurationOptionsFilterParameterInner> filter, String marker, Integer maxRecords) throws ApiException {
        okhttp3.Call localVarCall = gETDescribeNodeConfigurationOptionsValidateBeforeCall(actionType, action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, clusterIdentifier, snapshotIdentifier, snapshotArn, ownerAccount, filter, marker, maxRecords, null);
        Type localVarReturnType = new TypeToken<NodeConfigurationOptionsMessage>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     *  (asynchronously)
     * Returns properties of possible node configurations such as node type, number of nodes, and disk usage for the specified action type.
     * @param actionType The action type to evaluate for possible node configurations. Specify \&quot;restore-cluster\&quot; to get configuration combinations based on an existing snapshot. Specify \&quot;recommend-node-config\&quot; to get configuration recommendations based on an existing cluster or snapshot. Specify \&quot;resize-cluster\&quot; to get configuration combinations for elastic resize based on an existing cluster.  (required)
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param clusterIdentifier The identifier of the cluster to evaluate for possible node configurations. (optional)
     * @param snapshotIdentifier The identifier of the snapshot to evaluate for possible node configurations. (optional)
     * @param snapshotArn The Amazon Resource Name (ARN) of the snapshot associated with the message to describe node configuration. (optional)
     * @param ownerAccount The Amazon Web Services account used to create or copy the snapshot. Required if you are restoring a snapshot you do not own, optional if you own the snapshot. (optional)
     * @param filter A set of name, operator, and value items to filter the results. (optional)
     * @param marker An optional parameter that specifies the starting point to return a set of response records. When the results of a &lt;a&gt;DescribeNodeConfigurationOptions&lt;/a&gt; request exceed the value specified in &lt;code&gt;MaxRecords&lt;/code&gt;, Amazon Web Services returns a value in the &lt;code&gt;Marker&lt;/code&gt; field of the response. You can retrieve the next set of response records by providing the returned marker value in the &lt;code&gt;Marker&lt;/code&gt; parameter and retrying the request.  (optional)
     * @param maxRecords &lt;p&gt;The maximum number of response records to return in each call. If the number of remaining response records exceeds the specified &lt;code&gt;MaxRecords&lt;/code&gt; value, a value is returned in a &lt;code&gt;marker&lt;/code&gt; field of the response. You can retrieve the next set of records by retrying the command with the returned marker value. &lt;/p&gt; &lt;p&gt;Default: &lt;code&gt;500&lt;/code&gt; &lt;/p&gt; &lt;p&gt;Constraints: minimum 100, maximum 500.&lt;/p&gt; (optional)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> ClusterSnapshotNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> InvalidClusterSnapshotStateFault </td><td>  -  </td></tr>
        <tr><td> 482 </td><td> ClusterNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 483 </td><td> AccessToSnapshotDeniedFault </td><td>  -  </td></tr>
        <tr><td> 484 </td><td> UnsupportedOperationFault </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call gETDescribeNodeConfigurationOptionsAsync(String actionType, String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, String clusterIdentifier, String snapshotIdentifier, String snapshotArn, String ownerAccount, List<GETDescribeNodeConfigurationOptionsFilterParameterInner> filter, String marker, Integer maxRecords, final ApiCallback<NodeConfigurationOptionsMessage> _callback) throws ApiException {

        okhttp3.Call localVarCall = gETDescribeNodeConfigurationOptionsValidateBeforeCall(actionType, action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, clusterIdentifier, snapshotIdentifier, snapshotArn, ownerAccount, filter, marker, maxRecords, _callback);
        Type localVarReturnType = new TypeToken<NodeConfigurationOptionsMessage>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for gETDescribeOrderableClusterOptions
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param clusterVersion &lt;p&gt;The version filter value. Specify this parameter to show only the available offerings matching the specified version.&lt;/p&gt; &lt;p&gt;Default: All versions.&lt;/p&gt; &lt;p&gt;Constraints: Must be one of the version returned from &lt;a&gt;DescribeClusterVersions&lt;/a&gt;.&lt;/p&gt; (optional)
     * @param nodeType The node type filter value. Specify this parameter to show only the available offerings matching the specified node type. (optional)
     * @param maxRecords &lt;p&gt;The maximum number of response records to return in each call. If the number of remaining response records exceeds the specified &lt;code&gt;MaxRecords&lt;/code&gt; value, a value is returned in a &lt;code&gt;marker&lt;/code&gt; field of the response. You can retrieve the next set of records by retrying the command with the returned marker value. &lt;/p&gt; &lt;p&gt;Default: &lt;code&gt;100&lt;/code&gt; &lt;/p&gt; &lt;p&gt;Constraints: minimum 20, maximum 100.&lt;/p&gt; (optional)
     * @param marker An optional parameter that specifies the starting point to return a set of response records. When the results of a &lt;a&gt;DescribeOrderableClusterOptions&lt;/a&gt; request exceed the value specified in &lt;code&gt;MaxRecords&lt;/code&gt;, Amazon Web Services returns a value in the &lt;code&gt;Marker&lt;/code&gt; field of the response. You can retrieve the next set of response records by providing the returned marker value in the &lt;code&gt;Marker&lt;/code&gt; parameter and retrying the request.  (optional)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call gETDescribeOrderableClusterOptionsCall(String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, String clusterVersion, String nodeType, Integer maxRecords, String marker, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/#Action=DescribeOrderableClusterOptions";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (clusterVersion != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("ClusterVersion", clusterVersion));
        }

        if (nodeType != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("NodeType", nodeType));
        }

        if (maxRecords != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("MaxRecords", maxRecords));
        }

        if (marker != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("Marker", marker));
        }

        if (action != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("Action", action));
        }

        if (version != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("Version", version));
        }

        if (xAmzContentSha256 != null) {
            localVarHeaderParams.put("X-Amz-Content-Sha256", localVarApiClient.parameterToString(xAmzContentSha256));
        }

        if (xAmzDate != null) {
            localVarHeaderParams.put("X-Amz-Date", localVarApiClient.parameterToString(xAmzDate));
        }

        if (xAmzAlgorithm != null) {
            localVarHeaderParams.put("X-Amz-Algorithm", localVarApiClient.parameterToString(xAmzAlgorithm));
        }

        if (xAmzCredential != null) {
            localVarHeaderParams.put("X-Amz-Credential", localVarApiClient.parameterToString(xAmzCredential));
        }

        if (xAmzSecurityToken != null) {
            localVarHeaderParams.put("X-Amz-Security-Token", localVarApiClient.parameterToString(xAmzSecurityToken));
        }

        if (xAmzSignature != null) {
            localVarHeaderParams.put("X-Amz-Signature", localVarApiClient.parameterToString(xAmzSignature));
        }

        if (xAmzSignedHeaders != null) {
            localVarHeaderParams.put("X-Amz-SignedHeaders", localVarApiClient.parameterToString(xAmzSignedHeaders));
        }

        final String[] localVarAccepts = {
            "text/xml"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "hmac" };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call gETDescribeOrderableClusterOptionsValidateBeforeCall(String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, String clusterVersion, String nodeType, Integer maxRecords, String marker, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'action' is set
        if (action == null) {
            throw new ApiException("Missing the required parameter 'action' when calling gETDescribeOrderableClusterOptions(Async)");
        }

        // verify the required parameter 'version' is set
        if (version == null) {
            throw new ApiException("Missing the required parameter 'version' when calling gETDescribeOrderableClusterOptions(Async)");
        }

        return gETDescribeOrderableClusterOptionsCall(action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, clusterVersion, nodeType, maxRecords, marker, _callback);

    }

    /**
     * 
     * Returns a list of orderable cluster options. Before you create a new cluster you can use this operation to find what options are available, such as the EC2 Availability Zones (AZ) in the specific Amazon Web Services Region that you can specify, and the node types you can request. The node types differ by available storage, memory, CPU and price. With the cost involved you might want to obtain a list of cluster options in the specific region and specify values when creating a cluster. For more information about managing clusters, go to &lt;a href&#x3D;\&quot;https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html\&quot;&gt;Amazon Redshift Clusters&lt;/a&gt; in the &lt;i&gt;Amazon Redshift Cluster Management Guide&lt;/i&gt;.
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param clusterVersion &lt;p&gt;The version filter value. Specify this parameter to show only the available offerings matching the specified version.&lt;/p&gt; &lt;p&gt;Default: All versions.&lt;/p&gt; &lt;p&gt;Constraints: Must be one of the version returned from &lt;a&gt;DescribeClusterVersions&lt;/a&gt;.&lt;/p&gt; (optional)
     * @param nodeType The node type filter value. Specify this parameter to show only the available offerings matching the specified node type. (optional)
     * @param maxRecords &lt;p&gt;The maximum number of response records to return in each call. If the number of remaining response records exceeds the specified &lt;code&gt;MaxRecords&lt;/code&gt; value, a value is returned in a &lt;code&gt;marker&lt;/code&gt; field of the response. You can retrieve the next set of records by retrying the command with the returned marker value. &lt;/p&gt; &lt;p&gt;Default: &lt;code&gt;100&lt;/code&gt; &lt;/p&gt; &lt;p&gt;Constraints: minimum 20, maximum 100.&lt;/p&gt; (optional)
     * @param marker An optional parameter that specifies the starting point to return a set of response records. When the results of a &lt;a&gt;DescribeOrderableClusterOptions&lt;/a&gt; request exceed the value specified in &lt;code&gt;MaxRecords&lt;/code&gt;, Amazon Web Services returns a value in the &lt;code&gt;Marker&lt;/code&gt; field of the response. You can retrieve the next set of response records by providing the returned marker value in the &lt;code&gt;Marker&lt;/code&gt; parameter and retrying the request.  (optional)
     * @return OrderableClusterOptionsMessage
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
     </table>
     */
    public OrderableClusterOptionsMessage gETDescribeOrderableClusterOptions(String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, String clusterVersion, String nodeType, Integer maxRecords, String marker) throws ApiException {
        ApiResponse<OrderableClusterOptionsMessage> localVarResp = gETDescribeOrderableClusterOptionsWithHttpInfo(action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, clusterVersion, nodeType, maxRecords, marker);
        return localVarResp.getData();
    }

    /**
     * 
     * Returns a list of orderable cluster options. Before you create a new cluster you can use this operation to find what options are available, such as the EC2 Availability Zones (AZ) in the specific Amazon Web Services Region that you can specify, and the node types you can request. The node types differ by available storage, memory, CPU and price. With the cost involved you might want to obtain a list of cluster options in the specific region and specify values when creating a cluster. For more information about managing clusters, go to &lt;a href&#x3D;\&quot;https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html\&quot;&gt;Amazon Redshift Clusters&lt;/a&gt; in the &lt;i&gt;Amazon Redshift Cluster Management Guide&lt;/i&gt;.
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param clusterVersion &lt;p&gt;The version filter value. Specify this parameter to show only the available offerings matching the specified version.&lt;/p&gt; &lt;p&gt;Default: All versions.&lt;/p&gt; &lt;p&gt;Constraints: Must be one of the version returned from &lt;a&gt;DescribeClusterVersions&lt;/a&gt;.&lt;/p&gt; (optional)
     * @param nodeType The node type filter value. Specify this parameter to show only the available offerings matching the specified node type. (optional)
     * @param maxRecords &lt;p&gt;The maximum number of response records to return in each call. If the number of remaining response records exceeds the specified &lt;code&gt;MaxRecords&lt;/code&gt; value, a value is returned in a &lt;code&gt;marker&lt;/code&gt; field of the response. You can retrieve the next set of records by retrying the command with the returned marker value. &lt;/p&gt; &lt;p&gt;Default: &lt;code&gt;100&lt;/code&gt; &lt;/p&gt; &lt;p&gt;Constraints: minimum 20, maximum 100.&lt;/p&gt; (optional)
     * @param marker An optional parameter that specifies the starting point to return a set of response records. When the results of a &lt;a&gt;DescribeOrderableClusterOptions&lt;/a&gt; request exceed the value specified in &lt;code&gt;MaxRecords&lt;/code&gt;, Amazon Web Services returns a value in the &lt;code&gt;Marker&lt;/code&gt; field of the response. You can retrieve the next set of response records by providing the returned marker value in the &lt;code&gt;Marker&lt;/code&gt; parameter and retrying the request.  (optional)
     * @return ApiResponse&lt;OrderableClusterOptionsMessage&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<OrderableClusterOptionsMessage> gETDescribeOrderableClusterOptionsWithHttpInfo(String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, String clusterVersion, String nodeType, Integer maxRecords, String marker) throws ApiException {
        okhttp3.Call localVarCall = gETDescribeOrderableClusterOptionsValidateBeforeCall(action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, clusterVersion, nodeType, maxRecords, marker, null);
        Type localVarReturnType = new TypeToken<OrderableClusterOptionsMessage>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     *  (asynchronously)
     * Returns a list of orderable cluster options. Before you create a new cluster you can use this operation to find what options are available, such as the EC2 Availability Zones (AZ) in the specific Amazon Web Services Region that you can specify, and the node types you can request. The node types differ by available storage, memory, CPU and price. With the cost involved you might want to obtain a list of cluster options in the specific region and specify values when creating a cluster. For more information about managing clusters, go to &lt;a href&#x3D;\&quot;https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html\&quot;&gt;Amazon Redshift Clusters&lt;/a&gt; in the &lt;i&gt;Amazon Redshift Cluster Management Guide&lt;/i&gt;.
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param clusterVersion &lt;p&gt;The version filter value. Specify this parameter to show only the available offerings matching the specified version.&lt;/p&gt; &lt;p&gt;Default: All versions.&lt;/p&gt; &lt;p&gt;Constraints: Must be one of the version returned from &lt;a&gt;DescribeClusterVersions&lt;/a&gt;.&lt;/p&gt; (optional)
     * @param nodeType The node type filter value. Specify this parameter to show only the available offerings matching the specified node type. (optional)
     * @param maxRecords &lt;p&gt;The maximum number of response records to return in each call. If the number of remaining response records exceeds the specified &lt;code&gt;MaxRecords&lt;/code&gt; value, a value is returned in a &lt;code&gt;marker&lt;/code&gt; field of the response. You can retrieve the next set of records by retrying the command with the returned marker value. &lt;/p&gt; &lt;p&gt;Default: &lt;code&gt;100&lt;/code&gt; &lt;/p&gt; &lt;p&gt;Constraints: minimum 20, maximum 100.&lt;/p&gt; (optional)
     * @param marker An optional parameter that specifies the starting point to return a set of response records. When the results of a &lt;a&gt;DescribeOrderableClusterOptions&lt;/a&gt; request exceed the value specified in &lt;code&gt;MaxRecords&lt;/code&gt;, Amazon Web Services returns a value in the &lt;code&gt;Marker&lt;/code&gt; field of the response. You can retrieve the next set of response records by providing the returned marker value in the &lt;code&gt;Marker&lt;/code&gt; parameter and retrying the request.  (optional)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call gETDescribeOrderableClusterOptionsAsync(String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, String clusterVersion, String nodeType, Integer maxRecords, String marker, final ApiCallback<OrderableClusterOptionsMessage> _callback) throws ApiException {

        okhttp3.Call localVarCall = gETDescribeOrderableClusterOptionsValidateBeforeCall(action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, clusterVersion, nodeType, maxRecords, marker, _callback);
        Type localVarReturnType = new TypeToken<OrderableClusterOptionsMessage>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for gETDescribePartners
     * @param accountId The Amazon Web Services account ID that owns the cluster. (required)
     * @param clusterIdentifier The cluster identifier of the cluster whose partner integration is being described. (required)
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param databaseName The name of the database whose partner integration is being described. If database name is not specified, then all databases in the cluster are described. (optional)
     * @param partnerName The name of the partner that is being described. If partner name is not specified, then all partner integrations are described. (optional)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> ClusterNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> UnauthorizedPartnerIntegrationFault </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call gETDescribePartnersCall(String accountId, String clusterIdentifier, String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, String databaseName, String partnerName, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/#Action=DescribePartners";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (accountId != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("AccountId", accountId));
        }

        if (clusterIdentifier != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("ClusterIdentifier", clusterIdentifier));
        }

        if (databaseName != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("DatabaseName", databaseName));
        }

        if (partnerName != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("PartnerName", partnerName));
        }

        if (action != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("Action", action));
        }

        if (version != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("Version", version));
        }

        if (xAmzContentSha256 != null) {
            localVarHeaderParams.put("X-Amz-Content-Sha256", localVarApiClient.parameterToString(xAmzContentSha256));
        }

        if (xAmzDate != null) {
            localVarHeaderParams.put("X-Amz-Date", localVarApiClient.parameterToString(xAmzDate));
        }

        if (xAmzAlgorithm != null) {
            localVarHeaderParams.put("X-Amz-Algorithm", localVarApiClient.parameterToString(xAmzAlgorithm));
        }

        if (xAmzCredential != null) {
            localVarHeaderParams.put("X-Amz-Credential", localVarApiClient.parameterToString(xAmzCredential));
        }

        if (xAmzSecurityToken != null) {
            localVarHeaderParams.put("X-Amz-Security-Token", localVarApiClient.parameterToString(xAmzSecurityToken));
        }

        if (xAmzSignature != null) {
            localVarHeaderParams.put("X-Amz-Signature", localVarApiClient.parameterToString(xAmzSignature));
        }

        if (xAmzSignedHeaders != null) {
            localVarHeaderParams.put("X-Amz-SignedHeaders", localVarApiClient.parameterToString(xAmzSignedHeaders));
        }

        final String[] localVarAccepts = {
            "text/xml"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "hmac" };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call gETDescribePartnersValidateBeforeCall(String accountId, String clusterIdentifier, String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, String databaseName, String partnerName, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'accountId' is set
        if (accountId == null) {
            throw new ApiException("Missing the required parameter 'accountId' when calling gETDescribePartners(Async)");
        }

        // verify the required parameter 'clusterIdentifier' is set
        if (clusterIdentifier == null) {
            throw new ApiException("Missing the required parameter 'clusterIdentifier' when calling gETDescribePartners(Async)");
        }

        // verify the required parameter 'action' is set
        if (action == null) {
            throw new ApiException("Missing the required parameter 'action' when calling gETDescribePartners(Async)");
        }

        // verify the required parameter 'version' is set
        if (version == null) {
            throw new ApiException("Missing the required parameter 'version' when calling gETDescribePartners(Async)");
        }

        return gETDescribePartnersCall(accountId, clusterIdentifier, action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, databaseName, partnerName, _callback);

    }

    /**
     * 
     * Returns information about the partner integrations defined for a cluster.
     * @param accountId The Amazon Web Services account ID that owns the cluster. (required)
     * @param clusterIdentifier The cluster identifier of the cluster whose partner integration is being described. (required)
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param databaseName The name of the database whose partner integration is being described. If database name is not specified, then all databases in the cluster are described. (optional)
     * @param partnerName The name of the partner that is being described. If partner name is not specified, then all partner integrations are described. (optional)
     * @return DescribePartnersOutputMessage
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> ClusterNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> UnauthorizedPartnerIntegrationFault </td><td>  -  </td></tr>
     </table>
     */
    public DescribePartnersOutputMessage gETDescribePartners(String accountId, String clusterIdentifier, String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, String databaseName, String partnerName) throws ApiException {
        ApiResponse<DescribePartnersOutputMessage> localVarResp = gETDescribePartnersWithHttpInfo(accountId, clusterIdentifier, action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, databaseName, partnerName);
        return localVarResp.getData();
    }

    /**
     * 
     * Returns information about the partner integrations defined for a cluster.
     * @param accountId The Amazon Web Services account ID that owns the cluster. (required)
     * @param clusterIdentifier The cluster identifier of the cluster whose partner integration is being described. (required)
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param databaseName The name of the database whose partner integration is being described. If database name is not specified, then all databases in the cluster are described. (optional)
     * @param partnerName The name of the partner that is being described. If partner name is not specified, then all partner integrations are described. (optional)
     * @return ApiResponse&lt;DescribePartnersOutputMessage&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> ClusterNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> UnauthorizedPartnerIntegrationFault </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<DescribePartnersOutputMessage> gETDescribePartnersWithHttpInfo(String accountId, String clusterIdentifier, String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, String databaseName, String partnerName) throws ApiException {
        okhttp3.Call localVarCall = gETDescribePartnersValidateBeforeCall(accountId, clusterIdentifier, action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, databaseName, partnerName, null);
        Type localVarReturnType = new TypeToken<DescribePartnersOutputMessage>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     *  (asynchronously)
     * Returns information about the partner integrations defined for a cluster.
     * @param accountId The Amazon Web Services account ID that owns the cluster. (required)
     * @param clusterIdentifier The cluster identifier of the cluster whose partner integration is being described. (required)
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param databaseName The name of the database whose partner integration is being described. If database name is not specified, then all databases in the cluster are described. (optional)
     * @param partnerName The name of the partner that is being described. If partner name is not specified, then all partner integrations are described. (optional)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> ClusterNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> UnauthorizedPartnerIntegrationFault </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call gETDescribePartnersAsync(String accountId, String clusterIdentifier, String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, String databaseName, String partnerName, final ApiCallback<DescribePartnersOutputMessage> _callback) throws ApiException {

        okhttp3.Call localVarCall = gETDescribePartnersValidateBeforeCall(accountId, clusterIdentifier, action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, databaseName, partnerName, _callback);
        Type localVarReturnType = new TypeToken<DescribePartnersOutputMessage>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for gETDescribeReservedNodeExchangeStatus
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param reservedNodeId The identifier of the source reserved node in a reserved-node exchange request. (optional)
     * @param reservedNodeExchangeRequestId The identifier of the reserved-node exchange request. (optional)
     * @param maxRecords The maximum number of response records to return in each call. If the number of remaining response records exceeds the specified &lt;code&gt;MaxRecords&lt;/code&gt; value, a value is returned in a &lt;code&gt;Marker&lt;/code&gt; field of the response. You can retrieve the next set of records by retrying the command with the returned marker value. (optional)
     * @param marker An optional pagination token provided by a previous &lt;code&gt;DescribeReservedNodeExchangeStatus&lt;/code&gt; request. If this parameter is specified, the response includes only records beyond the marker, up to the value specified by the &lt;code&gt;MaxRecords&lt;/code&gt; parameter. You can retrieve the next set of response records by providing the returned marker value in the &lt;code&gt;Marker&lt;/code&gt; parameter and retrying the request. (optional)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> ReservedNodeNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> ReservedNodeExchangeNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 482 </td><td> UnsupportedOperationFault </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call gETDescribeReservedNodeExchangeStatusCall(String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, String reservedNodeId, String reservedNodeExchangeRequestId, Integer maxRecords, String marker, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/#Action=DescribeReservedNodeExchangeStatus";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (reservedNodeId != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("ReservedNodeId", reservedNodeId));
        }

        if (reservedNodeExchangeRequestId != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("ReservedNodeExchangeRequestId", reservedNodeExchangeRequestId));
        }

        if (maxRecords != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("MaxRecords", maxRecords));
        }

        if (marker != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("Marker", marker));
        }

        if (action != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("Action", action));
        }

        if (version != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("Version", version));
        }

        if (xAmzContentSha256 != null) {
            localVarHeaderParams.put("X-Amz-Content-Sha256", localVarApiClient.parameterToString(xAmzContentSha256));
        }

        if (xAmzDate != null) {
            localVarHeaderParams.put("X-Amz-Date", localVarApiClient.parameterToString(xAmzDate));
        }

        if (xAmzAlgorithm != null) {
            localVarHeaderParams.put("X-Amz-Algorithm", localVarApiClient.parameterToString(xAmzAlgorithm));
        }

        if (xAmzCredential != null) {
            localVarHeaderParams.put("X-Amz-Credential", localVarApiClient.parameterToString(xAmzCredential));
        }

        if (xAmzSecurityToken != null) {
            localVarHeaderParams.put("X-Amz-Security-Token", localVarApiClient.parameterToString(xAmzSecurityToken));
        }

        if (xAmzSignature != null) {
            localVarHeaderParams.put("X-Amz-Signature", localVarApiClient.parameterToString(xAmzSignature));
        }

        if (xAmzSignedHeaders != null) {
            localVarHeaderParams.put("X-Amz-SignedHeaders", localVarApiClient.parameterToString(xAmzSignedHeaders));
        }

        final String[] localVarAccepts = {
            "text/xml"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "hmac" };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call gETDescribeReservedNodeExchangeStatusValidateBeforeCall(String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, String reservedNodeId, String reservedNodeExchangeRequestId, Integer maxRecords, String marker, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'action' is set
        if (action == null) {
            throw new ApiException("Missing the required parameter 'action' when calling gETDescribeReservedNodeExchangeStatus(Async)");
        }

        // verify the required parameter 'version' is set
        if (version == null) {
            throw new ApiException("Missing the required parameter 'version' when calling gETDescribeReservedNodeExchangeStatus(Async)");
        }

        return gETDescribeReservedNodeExchangeStatusCall(action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, reservedNodeId, reservedNodeExchangeRequestId, maxRecords, marker, _callback);

    }

    /**
     * 
     * Returns exchange status details and associated metadata for a reserved-node exchange. Statuses include such values as in progress and requested.
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param reservedNodeId The identifier of the source reserved node in a reserved-node exchange request. (optional)
     * @param reservedNodeExchangeRequestId The identifier of the reserved-node exchange request. (optional)
     * @param maxRecords The maximum number of response records to return in each call. If the number of remaining response records exceeds the specified &lt;code&gt;MaxRecords&lt;/code&gt; value, a value is returned in a &lt;code&gt;Marker&lt;/code&gt; field of the response. You can retrieve the next set of records by retrying the command with the returned marker value. (optional)
     * @param marker An optional pagination token provided by a previous &lt;code&gt;DescribeReservedNodeExchangeStatus&lt;/code&gt; request. If this parameter is specified, the response includes only records beyond the marker, up to the value specified by the &lt;code&gt;MaxRecords&lt;/code&gt; parameter. You can retrieve the next set of response records by providing the returned marker value in the &lt;code&gt;Marker&lt;/code&gt; parameter and retrying the request. (optional)
     * @return DescribeReservedNodeExchangeStatusOutputMessage
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> ReservedNodeNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> ReservedNodeExchangeNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 482 </td><td> UnsupportedOperationFault </td><td>  -  </td></tr>
     </table>
     */
    public DescribeReservedNodeExchangeStatusOutputMessage gETDescribeReservedNodeExchangeStatus(String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, String reservedNodeId, String reservedNodeExchangeRequestId, Integer maxRecords, String marker) throws ApiException {
        ApiResponse<DescribeReservedNodeExchangeStatusOutputMessage> localVarResp = gETDescribeReservedNodeExchangeStatusWithHttpInfo(action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, reservedNodeId, reservedNodeExchangeRequestId, maxRecords, marker);
        return localVarResp.getData();
    }

    /**
     * 
     * Returns exchange status details and associated metadata for a reserved-node exchange. Statuses include such values as in progress and requested.
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param reservedNodeId The identifier of the source reserved node in a reserved-node exchange request. (optional)
     * @param reservedNodeExchangeRequestId The identifier of the reserved-node exchange request. (optional)
     * @param maxRecords The maximum number of response records to return in each call. If the number of remaining response records exceeds the specified &lt;code&gt;MaxRecords&lt;/code&gt; value, a value is returned in a &lt;code&gt;Marker&lt;/code&gt; field of the response. You can retrieve the next set of records by retrying the command with the returned marker value. (optional)
     * @param marker An optional pagination token provided by a previous &lt;code&gt;DescribeReservedNodeExchangeStatus&lt;/code&gt; request. If this parameter is specified, the response includes only records beyond the marker, up to the value specified by the &lt;code&gt;MaxRecords&lt;/code&gt; parameter. You can retrieve the next set of response records by providing the returned marker value in the &lt;code&gt;Marker&lt;/code&gt; parameter and retrying the request. (optional)
     * @return ApiResponse&lt;DescribeReservedNodeExchangeStatusOutputMessage&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> ReservedNodeNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> ReservedNodeExchangeNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 482 </td><td> UnsupportedOperationFault </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<DescribeReservedNodeExchangeStatusOutputMessage> gETDescribeReservedNodeExchangeStatusWithHttpInfo(String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, String reservedNodeId, String reservedNodeExchangeRequestId, Integer maxRecords, String marker) throws ApiException {
        okhttp3.Call localVarCall = gETDescribeReservedNodeExchangeStatusValidateBeforeCall(action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, reservedNodeId, reservedNodeExchangeRequestId, maxRecords, marker, null);
        Type localVarReturnType = new TypeToken<DescribeReservedNodeExchangeStatusOutputMessage>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     *  (asynchronously)
     * Returns exchange status details and associated metadata for a reserved-node exchange. Statuses include such values as in progress and requested.
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param reservedNodeId The identifier of the source reserved node in a reserved-node exchange request. (optional)
     * @param reservedNodeExchangeRequestId The identifier of the reserved-node exchange request. (optional)
     * @param maxRecords The maximum number of response records to return in each call. If the number of remaining response records exceeds the specified &lt;code&gt;MaxRecords&lt;/code&gt; value, a value is returned in a &lt;code&gt;Marker&lt;/code&gt; field of the response. You can retrieve the next set of records by retrying the command with the returned marker value. (optional)
     * @param marker An optional pagination token provided by a previous &lt;code&gt;DescribeReservedNodeExchangeStatus&lt;/code&gt; request. If this parameter is specified, the response includes only records beyond the marker, up to the value specified by the &lt;code&gt;MaxRecords&lt;/code&gt; parameter. You can retrieve the next set of response records by providing the returned marker value in the &lt;code&gt;Marker&lt;/code&gt; parameter and retrying the request. (optional)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> ReservedNodeNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> ReservedNodeExchangeNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 482 </td><td> UnsupportedOperationFault </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call gETDescribeReservedNodeExchangeStatusAsync(String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, String reservedNodeId, String reservedNodeExchangeRequestId, Integer maxRecords, String marker, final ApiCallback<DescribeReservedNodeExchangeStatusOutputMessage> _callback) throws ApiException {

        okhttp3.Call localVarCall = gETDescribeReservedNodeExchangeStatusValidateBeforeCall(action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, reservedNodeId, reservedNodeExchangeRequestId, maxRecords, marker, _callback);
        Type localVarReturnType = new TypeToken<DescribeReservedNodeExchangeStatusOutputMessage>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for gETDescribeReservedNodeOfferings
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param reservedNodeOfferingId The unique identifier for the offering. (optional)
     * @param maxRecords &lt;p&gt;The maximum number of response records to return in each call. If the number of remaining response records exceeds the specified &lt;code&gt;MaxRecords&lt;/code&gt; value, a value is returned in a &lt;code&gt;marker&lt;/code&gt; field of the response. You can retrieve the next set of records by retrying the command with the returned marker value. &lt;/p&gt; &lt;p&gt;Default: &lt;code&gt;100&lt;/code&gt; &lt;/p&gt; &lt;p&gt;Constraints: minimum 20, maximum 100.&lt;/p&gt; (optional)
     * @param marker An optional parameter that specifies the starting point to return a set of response records. When the results of a &lt;a&gt;DescribeReservedNodeOfferings&lt;/a&gt; request exceed the value specified in &lt;code&gt;MaxRecords&lt;/code&gt;, Amazon Web Services returns a value in the &lt;code&gt;Marker&lt;/code&gt; field of the response. You can retrieve the next set of response records by providing the returned marker value in the &lt;code&gt;Marker&lt;/code&gt; parameter and retrying the request.  (optional)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> ReservedNodeOfferingNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> UnsupportedOperationFault </td><td>  -  </td></tr>
        <tr><td> 482 </td><td> DependentServiceUnavailableFault </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call gETDescribeReservedNodeOfferingsCall(String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, String reservedNodeOfferingId, Integer maxRecords, String marker, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/#Action=DescribeReservedNodeOfferings";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (reservedNodeOfferingId != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("ReservedNodeOfferingId", reservedNodeOfferingId));
        }

        if (maxRecords != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("MaxRecords", maxRecords));
        }

        if (marker != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("Marker", marker));
        }

        if (action != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("Action", action));
        }

        if (version != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("Version", version));
        }

        if (xAmzContentSha256 != null) {
            localVarHeaderParams.put("X-Amz-Content-Sha256", localVarApiClient.parameterToString(xAmzContentSha256));
        }

        if (xAmzDate != null) {
            localVarHeaderParams.put("X-Amz-Date", localVarApiClient.parameterToString(xAmzDate));
        }

        if (xAmzAlgorithm != null) {
            localVarHeaderParams.put("X-Amz-Algorithm", localVarApiClient.parameterToString(xAmzAlgorithm));
        }

        if (xAmzCredential != null) {
            localVarHeaderParams.put("X-Amz-Credential", localVarApiClient.parameterToString(xAmzCredential));
        }

        if (xAmzSecurityToken != null) {
            localVarHeaderParams.put("X-Amz-Security-Token", localVarApiClient.parameterToString(xAmzSecurityToken));
        }

        if (xAmzSignature != null) {
            localVarHeaderParams.put("X-Amz-Signature", localVarApiClient.parameterToString(xAmzSignature));
        }

        if (xAmzSignedHeaders != null) {
            localVarHeaderParams.put("X-Amz-SignedHeaders", localVarApiClient.parameterToString(xAmzSignedHeaders));
        }

        final String[] localVarAccepts = {
            "text/xml"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "hmac" };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call gETDescribeReservedNodeOfferingsValidateBeforeCall(String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, String reservedNodeOfferingId, Integer maxRecords, String marker, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'action' is set
        if (action == null) {
            throw new ApiException("Missing the required parameter 'action' when calling gETDescribeReservedNodeOfferings(Async)");
        }

        // verify the required parameter 'version' is set
        if (version == null) {
            throw new ApiException("Missing the required parameter 'version' when calling gETDescribeReservedNodeOfferings(Async)");
        }

        return gETDescribeReservedNodeOfferingsCall(action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, reservedNodeOfferingId, maxRecords, marker, _callback);

    }

    /**
     * 
     * &lt;p&gt;Returns a list of the available reserved node offerings by Amazon Redshift with their descriptions including the node type, the fixed and recurring costs of reserving the node and duration the node will be reserved for you. These descriptions help you determine which reserve node offering you want to purchase. You then use the unique offering ID in you call to &lt;a&gt;PurchaseReservedNodeOffering&lt;/a&gt; to reserve one or more nodes for your Amazon Redshift cluster. &lt;/p&gt; &lt;p&gt; For more information about reserved node offerings, go to &lt;a href&#x3D;\&quot;https://docs.aws.amazon.com/redshift/latest/mgmt/purchase-reserved-node-instance.html\&quot;&gt;Purchasing Reserved Nodes&lt;/a&gt; in the &lt;i&gt;Amazon Redshift Cluster Management Guide&lt;/i&gt;.&lt;/p&gt;
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param reservedNodeOfferingId The unique identifier for the offering. (optional)
     * @param maxRecords &lt;p&gt;The maximum number of response records to return in each call. If the number of remaining response records exceeds the specified &lt;code&gt;MaxRecords&lt;/code&gt; value, a value is returned in a &lt;code&gt;marker&lt;/code&gt; field of the response. You can retrieve the next set of records by retrying the command with the returned marker value. &lt;/p&gt; &lt;p&gt;Default: &lt;code&gt;100&lt;/code&gt; &lt;/p&gt; &lt;p&gt;Constraints: minimum 20, maximum 100.&lt;/p&gt; (optional)
     * @param marker An optional parameter that specifies the starting point to return a set of response records. When the results of a &lt;a&gt;DescribeReservedNodeOfferings&lt;/a&gt; request exceed the value specified in &lt;code&gt;MaxRecords&lt;/code&gt;, Amazon Web Services returns a value in the &lt;code&gt;Marker&lt;/code&gt; field of the response. You can retrieve the next set of response records by providing the returned marker value in the &lt;code&gt;Marker&lt;/code&gt; parameter and retrying the request.  (optional)
     * @return ReservedNodeOfferingsMessage
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> ReservedNodeOfferingNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> UnsupportedOperationFault </td><td>  -  </td></tr>
        <tr><td> 482 </td><td> DependentServiceUnavailableFault </td><td>  -  </td></tr>
     </table>
     */
    public ReservedNodeOfferingsMessage gETDescribeReservedNodeOfferings(String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, String reservedNodeOfferingId, Integer maxRecords, String marker) throws ApiException {
        ApiResponse<ReservedNodeOfferingsMessage> localVarResp = gETDescribeReservedNodeOfferingsWithHttpInfo(action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, reservedNodeOfferingId, maxRecords, marker);
        return localVarResp.getData();
    }

    /**
     * 
     * &lt;p&gt;Returns a list of the available reserved node offerings by Amazon Redshift with their descriptions including the node type, the fixed and recurring costs of reserving the node and duration the node will be reserved for you. These descriptions help you determine which reserve node offering you want to purchase. You then use the unique offering ID in you call to &lt;a&gt;PurchaseReservedNodeOffering&lt;/a&gt; to reserve one or more nodes for your Amazon Redshift cluster. &lt;/p&gt; &lt;p&gt; For more information about reserved node offerings, go to &lt;a href&#x3D;\&quot;https://docs.aws.amazon.com/redshift/latest/mgmt/purchase-reserved-node-instance.html\&quot;&gt;Purchasing Reserved Nodes&lt;/a&gt; in the &lt;i&gt;Amazon Redshift Cluster Management Guide&lt;/i&gt;.&lt;/p&gt;
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param reservedNodeOfferingId The unique identifier for the offering. (optional)
     * @param maxRecords &lt;p&gt;The maximum number of response records to return in each call. If the number of remaining response records exceeds the specified &lt;code&gt;MaxRecords&lt;/code&gt; value, a value is returned in a &lt;code&gt;marker&lt;/code&gt; field of the response. You can retrieve the next set of records by retrying the command with the returned marker value. &lt;/p&gt; &lt;p&gt;Default: &lt;code&gt;100&lt;/code&gt; &lt;/p&gt; &lt;p&gt;Constraints: minimum 20, maximum 100.&lt;/p&gt; (optional)
     * @param marker An optional parameter that specifies the starting point to return a set of response records. When the results of a &lt;a&gt;DescribeReservedNodeOfferings&lt;/a&gt; request exceed the value specified in &lt;code&gt;MaxRecords&lt;/code&gt;, Amazon Web Services returns a value in the &lt;code&gt;Marker&lt;/code&gt; field of the response. You can retrieve the next set of response records by providing the returned marker value in the &lt;code&gt;Marker&lt;/code&gt; parameter and retrying the request.  (optional)
     * @return ApiResponse&lt;ReservedNodeOfferingsMessage&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> ReservedNodeOfferingNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> UnsupportedOperationFault </td><td>  -  </td></tr>
        <tr><td> 482 </td><td> DependentServiceUnavailableFault </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<ReservedNodeOfferingsMessage> gETDescribeReservedNodeOfferingsWithHttpInfo(String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, String reservedNodeOfferingId, Integer maxRecords, String marker) throws ApiException {
        okhttp3.Call localVarCall = gETDescribeReservedNodeOfferingsValidateBeforeCall(action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, reservedNodeOfferingId, maxRecords, marker, null);
        Type localVarReturnType = new TypeToken<ReservedNodeOfferingsMessage>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     *  (asynchronously)
     * &lt;p&gt;Returns a list of the available reserved node offerings by Amazon Redshift with their descriptions including the node type, the fixed and recurring costs of reserving the node and duration the node will be reserved for you. These descriptions help you determine which reserve node offering you want to purchase. You then use the unique offering ID in you call to &lt;a&gt;PurchaseReservedNodeOffering&lt;/a&gt; to reserve one or more nodes for your Amazon Redshift cluster. &lt;/p&gt; &lt;p&gt; For more information about reserved node offerings, go to &lt;a href&#x3D;\&quot;https://docs.aws.amazon.com/redshift/latest/mgmt/purchase-reserved-node-instance.html\&quot;&gt;Purchasing Reserved Nodes&lt;/a&gt; in the &lt;i&gt;Amazon Redshift Cluster Management Guide&lt;/i&gt;.&lt;/p&gt;
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param reservedNodeOfferingId The unique identifier for the offering. (optional)
     * @param maxRecords &lt;p&gt;The maximum number of response records to return in each call. If the number of remaining response records exceeds the specified &lt;code&gt;MaxRecords&lt;/code&gt; value, a value is returned in a &lt;code&gt;marker&lt;/code&gt; field of the response. You can retrieve the next set of records by retrying the command with the returned marker value. &lt;/p&gt; &lt;p&gt;Default: &lt;code&gt;100&lt;/code&gt; &lt;/p&gt; &lt;p&gt;Constraints: minimum 20, maximum 100.&lt;/p&gt; (optional)
     * @param marker An optional parameter that specifies the starting point to return a set of response records. When the results of a &lt;a&gt;DescribeReservedNodeOfferings&lt;/a&gt; request exceed the value specified in &lt;code&gt;MaxRecords&lt;/code&gt;, Amazon Web Services returns a value in the &lt;code&gt;Marker&lt;/code&gt; field of the response. You can retrieve the next set of response records by providing the returned marker value in the &lt;code&gt;Marker&lt;/code&gt; parameter and retrying the request.  (optional)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> ReservedNodeOfferingNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> UnsupportedOperationFault </td><td>  -  </td></tr>
        <tr><td> 482 </td><td> DependentServiceUnavailableFault </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call gETDescribeReservedNodeOfferingsAsync(String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, String reservedNodeOfferingId, Integer maxRecords, String marker, final ApiCallback<ReservedNodeOfferingsMessage> _callback) throws ApiException {

        okhttp3.Call localVarCall = gETDescribeReservedNodeOfferingsValidateBeforeCall(action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, reservedNodeOfferingId, maxRecords, marker, _callback);
        Type localVarReturnType = new TypeToken<ReservedNodeOfferingsMessage>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for gETDescribeReservedNodes
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param reservedNodeId Identifier for the node reservation. (optional)
     * @param maxRecords &lt;p&gt;The maximum number of response records to return in each call. If the number of remaining response records exceeds the specified &lt;code&gt;MaxRecords&lt;/code&gt; value, a value is returned in a &lt;code&gt;marker&lt;/code&gt; field of the response. You can retrieve the next set of records by retrying the command with the returned marker value. &lt;/p&gt; &lt;p&gt;Default: &lt;code&gt;100&lt;/code&gt; &lt;/p&gt; &lt;p&gt;Constraints: minimum 20, maximum 100.&lt;/p&gt; (optional)
     * @param marker An optional parameter that specifies the starting point to return a set of response records. When the results of a &lt;a&gt;DescribeReservedNodes&lt;/a&gt; request exceed the value specified in &lt;code&gt;MaxRecords&lt;/code&gt;, Amazon Web Services returns a value in the &lt;code&gt;Marker&lt;/code&gt; field of the response. You can retrieve the next set of response records by providing the returned marker value in the &lt;code&gt;Marker&lt;/code&gt; parameter and retrying the request.  (optional)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> ReservedNodeNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> DependentServiceUnavailableFault </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call gETDescribeReservedNodesCall(String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, String reservedNodeId, Integer maxRecords, String marker, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/#Action=DescribeReservedNodes";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (reservedNodeId != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("ReservedNodeId", reservedNodeId));
        }

        if (maxRecords != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("MaxRecords", maxRecords));
        }

        if (marker != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("Marker", marker));
        }

        if (action != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("Action", action));
        }

        if (version != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("Version", version));
        }

        if (xAmzContentSha256 != null) {
            localVarHeaderParams.put("X-Amz-Content-Sha256", localVarApiClient.parameterToString(xAmzContentSha256));
        }

        if (xAmzDate != null) {
            localVarHeaderParams.put("X-Amz-Date", localVarApiClient.parameterToString(xAmzDate));
        }

        if (xAmzAlgorithm != null) {
            localVarHeaderParams.put("X-Amz-Algorithm", localVarApiClient.parameterToString(xAmzAlgorithm));
        }

        if (xAmzCredential != null) {
            localVarHeaderParams.put("X-Amz-Credential", localVarApiClient.parameterToString(xAmzCredential));
        }

        if (xAmzSecurityToken != null) {
            localVarHeaderParams.put("X-Amz-Security-Token", localVarApiClient.parameterToString(xAmzSecurityToken));
        }

        if (xAmzSignature != null) {
            localVarHeaderParams.put("X-Amz-Signature", localVarApiClient.parameterToString(xAmzSignature));
        }

        if (xAmzSignedHeaders != null) {
            localVarHeaderParams.put("X-Amz-SignedHeaders", localVarApiClient.parameterToString(xAmzSignedHeaders));
        }

        final String[] localVarAccepts = {
            "text/xml"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "hmac" };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call gETDescribeReservedNodesValidateBeforeCall(String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, String reservedNodeId, Integer maxRecords, String marker, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'action' is set
        if (action == null) {
            throw new ApiException("Missing the required parameter 'action' when calling gETDescribeReservedNodes(Async)");
        }

        // verify the required parameter 'version' is set
        if (version == null) {
            throw new ApiException("Missing the required parameter 'version' when calling gETDescribeReservedNodes(Async)");
        }

        return gETDescribeReservedNodesCall(action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, reservedNodeId, maxRecords, marker, _callback);

    }

    /**
     * 
     * Returns the descriptions of the reserved nodes.
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param reservedNodeId Identifier for the node reservation. (optional)
     * @param maxRecords &lt;p&gt;The maximum number of response records to return in each call. If the number of remaining response records exceeds the specified &lt;code&gt;MaxRecords&lt;/code&gt; value, a value is returned in a &lt;code&gt;marker&lt;/code&gt; field of the response. You can retrieve the next set of records by retrying the command with the returned marker value. &lt;/p&gt; &lt;p&gt;Default: &lt;code&gt;100&lt;/code&gt; &lt;/p&gt; &lt;p&gt;Constraints: minimum 20, maximum 100.&lt;/p&gt; (optional)
     * @param marker An optional parameter that specifies the starting point to return a set of response records. When the results of a &lt;a&gt;DescribeReservedNodes&lt;/a&gt; request exceed the value specified in &lt;code&gt;MaxRecords&lt;/code&gt;, Amazon Web Services returns a value in the &lt;code&gt;Marker&lt;/code&gt; field of the response. You can retrieve the next set of response records by providing the returned marker value in the &lt;code&gt;Marker&lt;/code&gt; parameter and retrying the request.  (optional)
     * @return ReservedNodesMessage
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> ReservedNodeNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> DependentServiceUnavailableFault </td><td>  -  </td></tr>
     </table>
     */
    public ReservedNodesMessage gETDescribeReservedNodes(String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, String reservedNodeId, Integer maxRecords, String marker) throws ApiException {
        ApiResponse<ReservedNodesMessage> localVarResp = gETDescribeReservedNodesWithHttpInfo(action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, reservedNodeId, maxRecords, marker);
        return localVarResp.getData();
    }

    /**
     * 
     * Returns the descriptions of the reserved nodes.
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param reservedNodeId Identifier for the node reservation. (optional)
     * @param maxRecords &lt;p&gt;The maximum number of response records to return in each call. If the number of remaining response records exceeds the specified &lt;code&gt;MaxRecords&lt;/code&gt; value, a value is returned in a &lt;code&gt;marker&lt;/code&gt; field of the response. You can retrieve the next set of records by retrying the command with the returned marker value. &lt;/p&gt; &lt;p&gt;Default: &lt;code&gt;100&lt;/code&gt; &lt;/p&gt; &lt;p&gt;Constraints: minimum 20, maximum 100.&lt;/p&gt; (optional)
     * @param marker An optional parameter that specifies the starting point to return a set of response records. When the results of a &lt;a&gt;DescribeReservedNodes&lt;/a&gt; request exceed the value specified in &lt;code&gt;MaxRecords&lt;/code&gt;, Amazon Web Services returns a value in the &lt;code&gt;Marker&lt;/code&gt; field of the response. You can retrieve the next set of response records by providing the returned marker value in the &lt;code&gt;Marker&lt;/code&gt; parameter and retrying the request.  (optional)
     * @return ApiResponse&lt;ReservedNodesMessage&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> ReservedNodeNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> DependentServiceUnavailableFault </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<ReservedNodesMessage> gETDescribeReservedNodesWithHttpInfo(String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, String reservedNodeId, Integer maxRecords, String marker) throws ApiException {
        okhttp3.Call localVarCall = gETDescribeReservedNodesValidateBeforeCall(action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, reservedNodeId, maxRecords, marker, null);
        Type localVarReturnType = new TypeToken<ReservedNodesMessage>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     *  (asynchronously)
     * Returns the descriptions of the reserved nodes.
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param reservedNodeId Identifier for the node reservation. (optional)
     * @param maxRecords &lt;p&gt;The maximum number of response records to return in each call. If the number of remaining response records exceeds the specified &lt;code&gt;MaxRecords&lt;/code&gt; value, a value is returned in a &lt;code&gt;marker&lt;/code&gt; field of the response. You can retrieve the next set of records by retrying the command with the returned marker value. &lt;/p&gt; &lt;p&gt;Default: &lt;code&gt;100&lt;/code&gt; &lt;/p&gt; &lt;p&gt;Constraints: minimum 20, maximum 100.&lt;/p&gt; (optional)
     * @param marker An optional parameter that specifies the starting point to return a set of response records. When the results of a &lt;a&gt;DescribeReservedNodes&lt;/a&gt; request exceed the value specified in &lt;code&gt;MaxRecords&lt;/code&gt;, Amazon Web Services returns a value in the &lt;code&gt;Marker&lt;/code&gt; field of the response. You can retrieve the next set of response records by providing the returned marker value in the &lt;code&gt;Marker&lt;/code&gt; parameter and retrying the request.  (optional)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> ReservedNodeNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> DependentServiceUnavailableFault </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call gETDescribeReservedNodesAsync(String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, String reservedNodeId, Integer maxRecords, String marker, final ApiCallback<ReservedNodesMessage> _callback) throws ApiException {

        okhttp3.Call localVarCall = gETDescribeReservedNodesValidateBeforeCall(action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, reservedNodeId, maxRecords, marker, _callback);
        Type localVarReturnType = new TypeToken<ReservedNodesMessage>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for gETDescribeResize
     * @param clusterIdentifier &lt;p&gt;The unique identifier of a cluster whose resize progress you are requesting. This parameter is case-sensitive.&lt;/p&gt; &lt;p&gt;By default, resize operations for all clusters defined for an Amazon Web Services account are returned.&lt;/p&gt; (required)
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> ClusterNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> ResizeNotFoundFault </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call gETDescribeResizeCall(String clusterIdentifier, String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/#Action=DescribeResize";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (clusterIdentifier != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("ClusterIdentifier", clusterIdentifier));
        }

        if (action != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("Action", action));
        }

        if (version != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("Version", version));
        }

        if (xAmzContentSha256 != null) {
            localVarHeaderParams.put("X-Amz-Content-Sha256", localVarApiClient.parameterToString(xAmzContentSha256));
        }

        if (xAmzDate != null) {
            localVarHeaderParams.put("X-Amz-Date", localVarApiClient.parameterToString(xAmzDate));
        }

        if (xAmzAlgorithm != null) {
            localVarHeaderParams.put("X-Amz-Algorithm", localVarApiClient.parameterToString(xAmzAlgorithm));
        }

        if (xAmzCredential != null) {
            localVarHeaderParams.put("X-Amz-Credential", localVarApiClient.parameterToString(xAmzCredential));
        }

        if (xAmzSecurityToken != null) {
            localVarHeaderParams.put("X-Amz-Security-Token", localVarApiClient.parameterToString(xAmzSecurityToken));
        }

        if (xAmzSignature != null) {
            localVarHeaderParams.put("X-Amz-Signature", localVarApiClient.parameterToString(xAmzSignature));
        }

        if (xAmzSignedHeaders != null) {
            localVarHeaderParams.put("X-Amz-SignedHeaders", localVarApiClient.parameterToString(xAmzSignedHeaders));
        }

        final String[] localVarAccepts = {
            "text/xml"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "hmac" };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call gETDescribeResizeValidateBeforeCall(String clusterIdentifier, String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'clusterIdentifier' is set
        if (clusterIdentifier == null) {
            throw new ApiException("Missing the required parameter 'clusterIdentifier' when calling gETDescribeResize(Async)");
        }

        // verify the required parameter 'action' is set
        if (action == null) {
            throw new ApiException("Missing the required parameter 'action' when calling gETDescribeResize(Async)");
        }

        // verify the required parameter 'version' is set
        if (version == null) {
            throw new ApiException("Missing the required parameter 'version' when calling gETDescribeResize(Async)");
        }

        return gETDescribeResizeCall(clusterIdentifier, action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, _callback);

    }

    /**
     * 
     * &lt;p&gt;Returns information about the last resize operation for the specified cluster. If no resize operation has ever been initiated for the specified cluster, a &lt;code&gt;HTTP 404&lt;/code&gt; error is returned. If a resize operation was initiated and completed, the status of the resize remains as &lt;code&gt;SUCCEEDED&lt;/code&gt; until the next resize. &lt;/p&gt; &lt;p&gt;A resize operation can be requested using &lt;a&gt;ModifyCluster&lt;/a&gt; and specifying a different number or type of nodes for the cluster. &lt;/p&gt;
     * @param clusterIdentifier &lt;p&gt;The unique identifier of a cluster whose resize progress you are requesting. This parameter is case-sensitive.&lt;/p&gt; &lt;p&gt;By default, resize operations for all clusters defined for an Amazon Web Services account are returned.&lt;/p&gt; (required)
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @return ResizeProgressMessage
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> ClusterNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> ResizeNotFoundFault </td><td>  -  </td></tr>
     </table>
     */
    public ResizeProgressMessage gETDescribeResize(String clusterIdentifier, String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders) throws ApiException {
        ApiResponse<ResizeProgressMessage> localVarResp = gETDescribeResizeWithHttpInfo(clusterIdentifier, action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders);
        return localVarResp.getData();
    }

    /**
     * 
     * &lt;p&gt;Returns information about the last resize operation for the specified cluster. If no resize operation has ever been initiated for the specified cluster, a &lt;code&gt;HTTP 404&lt;/code&gt; error is returned. If a resize operation was initiated and completed, the status of the resize remains as &lt;code&gt;SUCCEEDED&lt;/code&gt; until the next resize. &lt;/p&gt; &lt;p&gt;A resize operation can be requested using &lt;a&gt;ModifyCluster&lt;/a&gt; and specifying a different number or type of nodes for the cluster. &lt;/p&gt;
     * @param clusterIdentifier &lt;p&gt;The unique identifier of a cluster whose resize progress you are requesting. This parameter is case-sensitive.&lt;/p&gt; &lt;p&gt;By default, resize operations for all clusters defined for an Amazon Web Services account are returned.&lt;/p&gt; (required)
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @return ApiResponse&lt;ResizeProgressMessage&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> ClusterNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> ResizeNotFoundFault </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<ResizeProgressMessage> gETDescribeResizeWithHttpInfo(String clusterIdentifier, String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders) throws ApiException {
        okhttp3.Call localVarCall = gETDescribeResizeValidateBeforeCall(clusterIdentifier, action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, null);
        Type localVarReturnType = new TypeToken<ResizeProgressMessage>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     *  (asynchronously)
     * &lt;p&gt;Returns information about the last resize operation for the specified cluster. If no resize operation has ever been initiated for the specified cluster, a &lt;code&gt;HTTP 404&lt;/code&gt; error is returned. If a resize operation was initiated and completed, the status of the resize remains as &lt;code&gt;SUCCEEDED&lt;/code&gt; until the next resize. &lt;/p&gt; &lt;p&gt;A resize operation can be requested using &lt;a&gt;ModifyCluster&lt;/a&gt; and specifying a different number or type of nodes for the cluster. &lt;/p&gt;
     * @param clusterIdentifier &lt;p&gt;The unique identifier of a cluster whose resize progress you are requesting. This parameter is case-sensitive.&lt;/p&gt; &lt;p&gt;By default, resize operations for all clusters defined for an Amazon Web Services account are returned.&lt;/p&gt; (required)
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> ClusterNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> ResizeNotFoundFault </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call gETDescribeResizeAsync(String clusterIdentifier, String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, final ApiCallback<ResizeProgressMessage> _callback) throws ApiException {

        okhttp3.Call localVarCall = gETDescribeResizeValidateBeforeCall(clusterIdentifier, action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, _callback);
        Type localVarReturnType = new TypeToken<ResizeProgressMessage>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for gETDescribeScheduledActions
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param scheduledActionName The name of the scheduled action to retrieve.  (optional)
     * @param targetActionType The type of the scheduled actions to retrieve.  (optional)
     * @param startTime The start time in UTC of the scheduled actions to retrieve. Only active scheduled actions that have invocations after this time are retrieved. (optional)
     * @param endTime The end time in UTC of the scheduled action to retrieve. Only active scheduled actions that have invocations before this time are retrieved. (optional)
     * @param active If true, retrieve only active scheduled actions. If false, retrieve only disabled scheduled actions.  (optional)
     * @param filters List of scheduled action filters.  (optional)
     * @param marker An optional parameter that specifies the starting point to return a set of response records. When the results of a &lt;a&gt;DescribeScheduledActions&lt;/a&gt; request exceed the value specified in &lt;code&gt;MaxRecords&lt;/code&gt;, Amazon Web Services returns a value in the &lt;code&gt;Marker&lt;/code&gt; field of the response. You can retrieve the next set of response records by providing the returned marker value in the &lt;code&gt;Marker&lt;/code&gt; parameter and retrying the request.  (optional)
     * @param maxRecords &lt;p&gt;The maximum number of response records to return in each call. If the number of remaining response records exceeds the specified &lt;code&gt;MaxRecords&lt;/code&gt; value, a value is returned in a &lt;code&gt;marker&lt;/code&gt; field of the response. You can retrieve the next set of records by retrying the command with the returned marker value. &lt;/p&gt; &lt;p&gt;Default: &lt;code&gt;100&lt;/code&gt; &lt;/p&gt; &lt;p&gt;Constraints: minimum 20, maximum 100.&lt;/p&gt; (optional)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> ScheduledActionNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> UnauthorizedOperation </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call gETDescribeScheduledActionsCall(String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, String scheduledActionName, String targetActionType, OffsetDateTime startTime, OffsetDateTime endTime, Boolean active, List<GETDescribeScheduledActionsFiltersParameterInner> filters, String marker, Integer maxRecords, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/#Action=DescribeScheduledActions";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (scheduledActionName != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("ScheduledActionName", scheduledActionName));
        }

        if (targetActionType != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("TargetActionType", targetActionType));
        }

        if (startTime != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("StartTime", startTime));
        }

        if (endTime != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("EndTime", endTime));
        }

        if (active != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("Active", active));
        }

        if (filters != null) {
            localVarCollectionQueryParams.addAll(localVarApiClient.parameterToPairs("multi", "Filters", filters));
        }

        if (marker != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("Marker", marker));
        }

        if (maxRecords != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("MaxRecords", maxRecords));
        }

        if (action != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("Action", action));
        }

        if (version != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("Version", version));
        }

        if (xAmzContentSha256 != null) {
            localVarHeaderParams.put("X-Amz-Content-Sha256", localVarApiClient.parameterToString(xAmzContentSha256));
        }

        if (xAmzDate != null) {
            localVarHeaderParams.put("X-Amz-Date", localVarApiClient.parameterToString(xAmzDate));
        }

        if (xAmzAlgorithm != null) {
            localVarHeaderParams.put("X-Amz-Algorithm", localVarApiClient.parameterToString(xAmzAlgorithm));
        }

        if (xAmzCredential != null) {
            localVarHeaderParams.put("X-Amz-Credential", localVarApiClient.parameterToString(xAmzCredential));
        }

        if (xAmzSecurityToken != null) {
            localVarHeaderParams.put("X-Amz-Security-Token", localVarApiClient.parameterToString(xAmzSecurityToken));
        }

        if (xAmzSignature != null) {
            localVarHeaderParams.put("X-Amz-Signature", localVarApiClient.parameterToString(xAmzSignature));
        }

        if (xAmzSignedHeaders != null) {
            localVarHeaderParams.put("X-Amz-SignedHeaders", localVarApiClient.parameterToString(xAmzSignedHeaders));
        }

        final String[] localVarAccepts = {
            "text/xml"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "hmac" };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call gETDescribeScheduledActionsValidateBeforeCall(String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, String scheduledActionName, String targetActionType, OffsetDateTime startTime, OffsetDateTime endTime, Boolean active, List<GETDescribeScheduledActionsFiltersParameterInner> filters, String marker, Integer maxRecords, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'action' is set
        if (action == null) {
            throw new ApiException("Missing the required parameter 'action' when calling gETDescribeScheduledActions(Async)");
        }

        // verify the required parameter 'version' is set
        if (version == null) {
            throw new ApiException("Missing the required parameter 'version' when calling gETDescribeScheduledActions(Async)");
        }

        return gETDescribeScheduledActionsCall(action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, scheduledActionName, targetActionType, startTime, endTime, active, filters, marker, maxRecords, _callback);

    }

    /**
     * 
     * Describes properties of scheduled actions. 
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param scheduledActionName The name of the scheduled action to retrieve.  (optional)
     * @param targetActionType The type of the scheduled actions to retrieve.  (optional)
     * @param startTime The start time in UTC of the scheduled actions to retrieve. Only active scheduled actions that have invocations after this time are retrieved. (optional)
     * @param endTime The end time in UTC of the scheduled action to retrieve. Only active scheduled actions that have invocations before this time are retrieved. (optional)
     * @param active If true, retrieve only active scheduled actions. If false, retrieve only disabled scheduled actions.  (optional)
     * @param filters List of scheduled action filters.  (optional)
     * @param marker An optional parameter that specifies the starting point to return a set of response records. When the results of a &lt;a&gt;DescribeScheduledActions&lt;/a&gt; request exceed the value specified in &lt;code&gt;MaxRecords&lt;/code&gt;, Amazon Web Services returns a value in the &lt;code&gt;Marker&lt;/code&gt; field of the response. You can retrieve the next set of response records by providing the returned marker value in the &lt;code&gt;Marker&lt;/code&gt; parameter and retrying the request.  (optional)
     * @param maxRecords &lt;p&gt;The maximum number of response records to return in each call. If the number of remaining response records exceeds the specified &lt;code&gt;MaxRecords&lt;/code&gt; value, a value is returned in a &lt;code&gt;marker&lt;/code&gt; field of the response. You can retrieve the next set of records by retrying the command with the returned marker value. &lt;/p&gt; &lt;p&gt;Default: &lt;code&gt;100&lt;/code&gt; &lt;/p&gt; &lt;p&gt;Constraints: minimum 20, maximum 100.&lt;/p&gt; (optional)
     * @return ScheduledActionsMessage
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> ScheduledActionNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> UnauthorizedOperation </td><td>  -  </td></tr>
     </table>
     */
    public ScheduledActionsMessage gETDescribeScheduledActions(String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, String scheduledActionName, String targetActionType, OffsetDateTime startTime, OffsetDateTime endTime, Boolean active, List<GETDescribeScheduledActionsFiltersParameterInner> filters, String marker, Integer maxRecords) throws ApiException {
        ApiResponse<ScheduledActionsMessage> localVarResp = gETDescribeScheduledActionsWithHttpInfo(action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, scheduledActionName, targetActionType, startTime, endTime, active, filters, marker, maxRecords);
        return localVarResp.getData();
    }

    /**
     * 
     * Describes properties of scheduled actions. 
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param scheduledActionName The name of the scheduled action to retrieve.  (optional)
     * @param targetActionType The type of the scheduled actions to retrieve.  (optional)
     * @param startTime The start time in UTC of the scheduled actions to retrieve. Only active scheduled actions that have invocations after this time are retrieved. (optional)
     * @param endTime The end time in UTC of the scheduled action to retrieve. Only active scheduled actions that have invocations before this time are retrieved. (optional)
     * @param active If true, retrieve only active scheduled actions. If false, retrieve only disabled scheduled actions.  (optional)
     * @param filters List of scheduled action filters.  (optional)
     * @param marker An optional parameter that specifies the starting point to return a set of response records. When the results of a &lt;a&gt;DescribeScheduledActions&lt;/a&gt; request exceed the value specified in &lt;code&gt;MaxRecords&lt;/code&gt;, Amazon Web Services returns a value in the &lt;code&gt;Marker&lt;/code&gt; field of the response. You can retrieve the next set of response records by providing the returned marker value in the &lt;code&gt;Marker&lt;/code&gt; parameter and retrying the request.  (optional)
     * @param maxRecords &lt;p&gt;The maximum number of response records to return in each call. If the number of remaining response records exceeds the specified &lt;code&gt;MaxRecords&lt;/code&gt; value, a value is returned in a &lt;code&gt;marker&lt;/code&gt; field of the response. You can retrieve the next set of records by retrying the command with the returned marker value. &lt;/p&gt; &lt;p&gt;Default: &lt;code&gt;100&lt;/code&gt; &lt;/p&gt; &lt;p&gt;Constraints: minimum 20, maximum 100.&lt;/p&gt; (optional)
     * @return ApiResponse&lt;ScheduledActionsMessage&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> ScheduledActionNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> UnauthorizedOperation </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<ScheduledActionsMessage> gETDescribeScheduledActionsWithHttpInfo(String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, String scheduledActionName, String targetActionType, OffsetDateTime startTime, OffsetDateTime endTime, Boolean active, List<GETDescribeScheduledActionsFiltersParameterInner> filters, String marker, Integer maxRecords) throws ApiException {
        okhttp3.Call localVarCall = gETDescribeScheduledActionsValidateBeforeCall(action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, scheduledActionName, targetActionType, startTime, endTime, active, filters, marker, maxRecords, null);
        Type localVarReturnType = new TypeToken<ScheduledActionsMessage>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     *  (asynchronously)
     * Describes properties of scheduled actions. 
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param scheduledActionName The name of the scheduled action to retrieve.  (optional)
     * @param targetActionType The type of the scheduled actions to retrieve.  (optional)
     * @param startTime The start time in UTC of the scheduled actions to retrieve. Only active scheduled actions that have invocations after this time are retrieved. (optional)
     * @param endTime The end time in UTC of the scheduled action to retrieve. Only active scheduled actions that have invocations before this time are retrieved. (optional)
     * @param active If true, retrieve only active scheduled actions. If false, retrieve only disabled scheduled actions.  (optional)
     * @param filters List of scheduled action filters.  (optional)
     * @param marker An optional parameter that specifies the starting point to return a set of response records. When the results of a &lt;a&gt;DescribeScheduledActions&lt;/a&gt; request exceed the value specified in &lt;code&gt;MaxRecords&lt;/code&gt;, Amazon Web Services returns a value in the &lt;code&gt;Marker&lt;/code&gt; field of the response. You can retrieve the next set of response records by providing the returned marker value in the &lt;code&gt;Marker&lt;/code&gt; parameter and retrying the request.  (optional)
     * @param maxRecords &lt;p&gt;The maximum number of response records to return in each call. If the number of remaining response records exceeds the specified &lt;code&gt;MaxRecords&lt;/code&gt; value, a value is returned in a &lt;code&gt;marker&lt;/code&gt; field of the response. You can retrieve the next set of records by retrying the command with the returned marker value. &lt;/p&gt; &lt;p&gt;Default: &lt;code&gt;100&lt;/code&gt; &lt;/p&gt; &lt;p&gt;Constraints: minimum 20, maximum 100.&lt;/p&gt; (optional)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> ScheduledActionNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> UnauthorizedOperation </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call gETDescribeScheduledActionsAsync(String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, String scheduledActionName, String targetActionType, OffsetDateTime startTime, OffsetDateTime endTime, Boolean active, List<GETDescribeScheduledActionsFiltersParameterInner> filters, String marker, Integer maxRecords, final ApiCallback<ScheduledActionsMessage> _callback) throws ApiException {

        okhttp3.Call localVarCall = gETDescribeScheduledActionsValidateBeforeCall(action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, scheduledActionName, targetActionType, startTime, endTime, active, filters, marker, maxRecords, _callback);
        Type localVarReturnType = new TypeToken<ScheduledActionsMessage>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for gETDescribeSnapshotCopyGrants
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param snapshotCopyGrantName The name of the snapshot copy grant. (optional)
     * @param maxRecords &lt;p&gt;The maximum number of response records to return in each call. If the number of remaining response records exceeds the specified &lt;code&gt;MaxRecords&lt;/code&gt; value, a value is returned in a &lt;code&gt;marker&lt;/code&gt; field of the response. You can retrieve the next set of records by retrying the command with the returned marker value. &lt;/p&gt; &lt;p&gt;Default: &lt;code&gt;100&lt;/code&gt; &lt;/p&gt; &lt;p&gt;Constraints: minimum 20, maximum 100.&lt;/p&gt; (optional)
     * @param marker &lt;p&gt;An optional parameter that specifies the starting point to return a set of response records. When the results of a &lt;code&gt;DescribeSnapshotCopyGrant&lt;/code&gt; request exceed the value specified in &lt;code&gt;MaxRecords&lt;/code&gt;, Amazon Web Services returns a value in the &lt;code&gt;Marker&lt;/code&gt; field of the response. You can retrieve the next set of response records by providing the returned marker value in the &lt;code&gt;Marker&lt;/code&gt; parameter and retrying the request. &lt;/p&gt; &lt;p&gt;Constraints: You can specify either the &lt;b&gt;SnapshotCopyGrantName&lt;/b&gt; parameter or the &lt;b&gt;Marker&lt;/b&gt; parameter, but not both. &lt;/p&gt; (optional)
     * @param tagKeys A tag key or keys for which you want to return all matching resources that are associated with the specified key or keys. For example, suppose that you have resources tagged with keys called &lt;code&gt;owner&lt;/code&gt; and &lt;code&gt;environment&lt;/code&gt;. If you specify both of these tag keys in the request, Amazon Redshift returns a response with all resources that have either or both of these tag keys associated with them. (optional)
     * @param tagValues A tag value or values for which you want to return all matching resources that are associated with the specified value or values. For example, suppose that you have resources tagged with values called &lt;code&gt;admin&lt;/code&gt; and &lt;code&gt;test&lt;/code&gt;. If you specify both of these tag values in the request, Amazon Redshift returns a response with all resources that have either or both of these tag values associated with them. (optional)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> SnapshotCopyGrantNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> InvalidTagFault </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call gETDescribeSnapshotCopyGrantsCall(String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, String snapshotCopyGrantName, Integer maxRecords, String marker, List<String> tagKeys, List<String> tagValues, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/#Action=DescribeSnapshotCopyGrants";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (snapshotCopyGrantName != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("SnapshotCopyGrantName", snapshotCopyGrantName));
        }

        if (maxRecords != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("MaxRecords", maxRecords));
        }

        if (marker != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("Marker", marker));
        }

        if (tagKeys != null) {
            localVarCollectionQueryParams.addAll(localVarApiClient.parameterToPairs("multi", "TagKeys", tagKeys));
        }

        if (tagValues != null) {
            localVarCollectionQueryParams.addAll(localVarApiClient.parameterToPairs("multi", "TagValues", tagValues));
        }

        if (action != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("Action", action));
        }

        if (version != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("Version", version));
        }

        if (xAmzContentSha256 != null) {
            localVarHeaderParams.put("X-Amz-Content-Sha256", localVarApiClient.parameterToString(xAmzContentSha256));
        }

        if (xAmzDate != null) {
            localVarHeaderParams.put("X-Amz-Date", localVarApiClient.parameterToString(xAmzDate));
        }

        if (xAmzAlgorithm != null) {
            localVarHeaderParams.put("X-Amz-Algorithm", localVarApiClient.parameterToString(xAmzAlgorithm));
        }

        if (xAmzCredential != null) {
            localVarHeaderParams.put("X-Amz-Credential", localVarApiClient.parameterToString(xAmzCredential));
        }

        if (xAmzSecurityToken != null) {
            localVarHeaderParams.put("X-Amz-Security-Token", localVarApiClient.parameterToString(xAmzSecurityToken));
        }

        if (xAmzSignature != null) {
            localVarHeaderParams.put("X-Amz-Signature", localVarApiClient.parameterToString(xAmzSignature));
        }

        if (xAmzSignedHeaders != null) {
            localVarHeaderParams.put("X-Amz-SignedHeaders", localVarApiClient.parameterToString(xAmzSignedHeaders));
        }

        final String[] localVarAccepts = {
            "text/xml"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "hmac" };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call gETDescribeSnapshotCopyGrantsValidateBeforeCall(String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, String snapshotCopyGrantName, Integer maxRecords, String marker, List<String> tagKeys, List<String> tagValues, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'action' is set
        if (action == null) {
            throw new ApiException("Missing the required parameter 'action' when calling gETDescribeSnapshotCopyGrants(Async)");
        }

        // verify the required parameter 'version' is set
        if (version == null) {
            throw new ApiException("Missing the required parameter 'version' when calling gETDescribeSnapshotCopyGrants(Async)");
        }

        return gETDescribeSnapshotCopyGrantsCall(action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, snapshotCopyGrantName, maxRecords, marker, tagKeys, tagValues, _callback);

    }

    /**
     * 
     * &lt;p&gt;Returns a list of snapshot copy grants owned by the Amazon Web Services account in the destination region.&lt;/p&gt; &lt;p&gt; For more information about managing snapshot copy grants, go to &lt;a href&#x3D;\&quot;https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-db-encryption.html\&quot;&gt;Amazon Redshift Database Encryption&lt;/a&gt; in the &lt;i&gt;Amazon Redshift Cluster Management Guide&lt;/i&gt;. &lt;/p&gt;
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param snapshotCopyGrantName The name of the snapshot copy grant. (optional)
     * @param maxRecords &lt;p&gt;The maximum number of response records to return in each call. If the number of remaining response records exceeds the specified &lt;code&gt;MaxRecords&lt;/code&gt; value, a value is returned in a &lt;code&gt;marker&lt;/code&gt; field of the response. You can retrieve the next set of records by retrying the command with the returned marker value. &lt;/p&gt; &lt;p&gt;Default: &lt;code&gt;100&lt;/code&gt; &lt;/p&gt; &lt;p&gt;Constraints: minimum 20, maximum 100.&lt;/p&gt; (optional)
     * @param marker &lt;p&gt;An optional parameter that specifies the starting point to return a set of response records. When the results of a &lt;code&gt;DescribeSnapshotCopyGrant&lt;/code&gt; request exceed the value specified in &lt;code&gt;MaxRecords&lt;/code&gt;, Amazon Web Services returns a value in the &lt;code&gt;Marker&lt;/code&gt; field of the response. You can retrieve the next set of response records by providing the returned marker value in the &lt;code&gt;Marker&lt;/code&gt; parameter and retrying the request. &lt;/p&gt; &lt;p&gt;Constraints: You can specify either the &lt;b&gt;SnapshotCopyGrantName&lt;/b&gt; parameter or the &lt;b&gt;Marker&lt;/b&gt; parameter, but not both. &lt;/p&gt; (optional)
     * @param tagKeys A tag key or keys for which you want to return all matching resources that are associated with the specified key or keys. For example, suppose that you have resources tagged with keys called &lt;code&gt;owner&lt;/code&gt; and &lt;code&gt;environment&lt;/code&gt;. If you specify both of these tag keys in the request, Amazon Redshift returns a response with all resources that have either or both of these tag keys associated with them. (optional)
     * @param tagValues A tag value or values for which you want to return all matching resources that are associated with the specified value or values. For example, suppose that you have resources tagged with values called &lt;code&gt;admin&lt;/code&gt; and &lt;code&gt;test&lt;/code&gt;. If you specify both of these tag values in the request, Amazon Redshift returns a response with all resources that have either or both of these tag values associated with them. (optional)
     * @return SnapshotCopyGrantMessage
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> SnapshotCopyGrantNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> InvalidTagFault </td><td>  -  </td></tr>
     </table>
     */
    public SnapshotCopyGrantMessage gETDescribeSnapshotCopyGrants(String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, String snapshotCopyGrantName, Integer maxRecords, String marker, List<String> tagKeys, List<String> tagValues) throws ApiException {
        ApiResponse<SnapshotCopyGrantMessage> localVarResp = gETDescribeSnapshotCopyGrantsWithHttpInfo(action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, snapshotCopyGrantName, maxRecords, marker, tagKeys, tagValues);
        return localVarResp.getData();
    }

    /**
     * 
     * &lt;p&gt;Returns a list of snapshot copy grants owned by the Amazon Web Services account in the destination region.&lt;/p&gt; &lt;p&gt; For more information about managing snapshot copy grants, go to &lt;a href&#x3D;\&quot;https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-db-encryption.html\&quot;&gt;Amazon Redshift Database Encryption&lt;/a&gt; in the &lt;i&gt;Amazon Redshift Cluster Management Guide&lt;/i&gt;. &lt;/p&gt;
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param snapshotCopyGrantName The name of the snapshot copy grant. (optional)
     * @param maxRecords &lt;p&gt;The maximum number of response records to return in each call. If the number of remaining response records exceeds the specified &lt;code&gt;MaxRecords&lt;/code&gt; value, a value is returned in a &lt;code&gt;marker&lt;/code&gt; field of the response. You can retrieve the next set of records by retrying the command with the returned marker value. &lt;/p&gt; &lt;p&gt;Default: &lt;code&gt;100&lt;/code&gt; &lt;/p&gt; &lt;p&gt;Constraints: minimum 20, maximum 100.&lt;/p&gt; (optional)
     * @param marker &lt;p&gt;An optional parameter that specifies the starting point to return a set of response records. When the results of a &lt;code&gt;DescribeSnapshotCopyGrant&lt;/code&gt; request exceed the value specified in &lt;code&gt;MaxRecords&lt;/code&gt;, Amazon Web Services returns a value in the &lt;code&gt;Marker&lt;/code&gt; field of the response. You can retrieve the next set of response records by providing the returned marker value in the &lt;code&gt;Marker&lt;/code&gt; parameter and retrying the request. &lt;/p&gt; &lt;p&gt;Constraints: You can specify either the &lt;b&gt;SnapshotCopyGrantName&lt;/b&gt; parameter or the &lt;b&gt;Marker&lt;/b&gt; parameter, but not both. &lt;/p&gt; (optional)
     * @param tagKeys A tag key or keys for which you want to return all matching resources that are associated with the specified key or keys. For example, suppose that you have resources tagged with keys called &lt;code&gt;owner&lt;/code&gt; and &lt;code&gt;environment&lt;/code&gt;. If you specify both of these tag keys in the request, Amazon Redshift returns a response with all resources that have either or both of these tag keys associated with them. (optional)
     * @param tagValues A tag value or values for which you want to return all matching resources that are associated with the specified value or values. For example, suppose that you have resources tagged with values called &lt;code&gt;admin&lt;/code&gt; and &lt;code&gt;test&lt;/code&gt;. If you specify both of these tag values in the request, Amazon Redshift returns a response with all resources that have either or both of these tag values associated with them. (optional)
     * @return ApiResponse&lt;SnapshotCopyGrantMessage&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> SnapshotCopyGrantNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> InvalidTagFault </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<SnapshotCopyGrantMessage> gETDescribeSnapshotCopyGrantsWithHttpInfo(String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, String snapshotCopyGrantName, Integer maxRecords, String marker, List<String> tagKeys, List<String> tagValues) throws ApiException {
        okhttp3.Call localVarCall = gETDescribeSnapshotCopyGrantsValidateBeforeCall(action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, snapshotCopyGrantName, maxRecords, marker, tagKeys, tagValues, null);
        Type localVarReturnType = new TypeToken<SnapshotCopyGrantMessage>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     *  (asynchronously)
     * &lt;p&gt;Returns a list of snapshot copy grants owned by the Amazon Web Services account in the destination region.&lt;/p&gt; &lt;p&gt; For more information about managing snapshot copy grants, go to &lt;a href&#x3D;\&quot;https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-db-encryption.html\&quot;&gt;Amazon Redshift Database Encryption&lt;/a&gt; in the &lt;i&gt;Amazon Redshift Cluster Management Guide&lt;/i&gt;. &lt;/p&gt;
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param snapshotCopyGrantName The name of the snapshot copy grant. (optional)
     * @param maxRecords &lt;p&gt;The maximum number of response records to return in each call. If the number of remaining response records exceeds the specified &lt;code&gt;MaxRecords&lt;/code&gt; value, a value is returned in a &lt;code&gt;marker&lt;/code&gt; field of the response. You can retrieve the next set of records by retrying the command with the returned marker value. &lt;/p&gt; &lt;p&gt;Default: &lt;code&gt;100&lt;/code&gt; &lt;/p&gt; &lt;p&gt;Constraints: minimum 20, maximum 100.&lt;/p&gt; (optional)
     * @param marker &lt;p&gt;An optional parameter that specifies the starting point to return a set of response records. When the results of a &lt;code&gt;DescribeSnapshotCopyGrant&lt;/code&gt; request exceed the value specified in &lt;code&gt;MaxRecords&lt;/code&gt;, Amazon Web Services returns a value in the &lt;code&gt;Marker&lt;/code&gt; field of the response. You can retrieve the next set of response records by providing the returned marker value in the &lt;code&gt;Marker&lt;/code&gt; parameter and retrying the request. &lt;/p&gt; &lt;p&gt;Constraints: You can specify either the &lt;b&gt;SnapshotCopyGrantName&lt;/b&gt; parameter or the &lt;b&gt;Marker&lt;/b&gt; parameter, but not both. &lt;/p&gt; (optional)
     * @param tagKeys A tag key or keys for which you want to return all matching resources that are associated with the specified key or keys. For example, suppose that you have resources tagged with keys called &lt;code&gt;owner&lt;/code&gt; and &lt;code&gt;environment&lt;/code&gt;. If you specify both of these tag keys in the request, Amazon Redshift returns a response with all resources that have either or both of these tag keys associated with them. (optional)
     * @param tagValues A tag value or values for which you want to return all matching resources that are associated with the specified value or values. For example, suppose that you have resources tagged with values called &lt;code&gt;admin&lt;/code&gt; and &lt;code&gt;test&lt;/code&gt;. If you specify both of these tag values in the request, Amazon Redshift returns a response with all resources that have either or both of these tag values associated with them. (optional)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> SnapshotCopyGrantNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> InvalidTagFault </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call gETDescribeSnapshotCopyGrantsAsync(String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, String snapshotCopyGrantName, Integer maxRecords, String marker, List<String> tagKeys, List<String> tagValues, final ApiCallback<SnapshotCopyGrantMessage> _callback) throws ApiException {

        okhttp3.Call localVarCall = gETDescribeSnapshotCopyGrantsValidateBeforeCall(action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, snapshotCopyGrantName, maxRecords, marker, tagKeys, tagValues, _callback);
        Type localVarReturnType = new TypeToken<SnapshotCopyGrantMessage>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for gETDescribeSnapshotSchedules
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param clusterIdentifier The unique identifier for the cluster whose snapshot schedules you want to view. (optional)
     * @param scheduleIdentifier A unique identifier for a snapshot schedule. (optional)
     * @param tagKeys The key value for a snapshot schedule tag. (optional)
     * @param tagValues The value corresponding to the key of the snapshot schedule tag. (optional)
     * @param marker A value that indicates the starting point for the next set of response records in a subsequent request. If a value is returned in a response, you can retrieve the next set of records by providing this returned marker value in the &lt;code&gt;marker&lt;/code&gt; parameter and retrying the command. If the &lt;code&gt;marker&lt;/code&gt; field is empty, all response records have been retrieved for the request. (optional)
     * @param maxRecords The maximum number or response records to return in each call. If the number of remaining response records exceeds the specified &lt;code&gt;MaxRecords&lt;/code&gt; value, a value is returned in a &lt;code&gt;marker&lt;/code&gt; field of the response. You can retrieve the next set of records by retrying the command with the returned &lt;code&gt;marker&lt;/code&gt; value. (optional)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call gETDescribeSnapshotSchedulesCall(String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, String clusterIdentifier, String scheduleIdentifier, List<String> tagKeys, List<String> tagValues, String marker, Integer maxRecords, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/#Action=DescribeSnapshotSchedules";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (clusterIdentifier != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("ClusterIdentifier", clusterIdentifier));
        }

        if (scheduleIdentifier != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("ScheduleIdentifier", scheduleIdentifier));
        }

        if (tagKeys != null) {
            localVarCollectionQueryParams.addAll(localVarApiClient.parameterToPairs("multi", "TagKeys", tagKeys));
        }

        if (tagValues != null) {
            localVarCollectionQueryParams.addAll(localVarApiClient.parameterToPairs("multi", "TagValues", tagValues));
        }

        if (marker != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("Marker", marker));
        }

        if (maxRecords != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("MaxRecords", maxRecords));
        }

        if (action != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("Action", action));
        }

        if (version != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("Version", version));
        }

        if (xAmzContentSha256 != null) {
            localVarHeaderParams.put("X-Amz-Content-Sha256", localVarApiClient.parameterToString(xAmzContentSha256));
        }

        if (xAmzDate != null) {
            localVarHeaderParams.put("X-Amz-Date", localVarApiClient.parameterToString(xAmzDate));
        }

        if (xAmzAlgorithm != null) {
            localVarHeaderParams.put("X-Amz-Algorithm", localVarApiClient.parameterToString(xAmzAlgorithm));
        }

        if (xAmzCredential != null) {
            localVarHeaderParams.put("X-Amz-Credential", localVarApiClient.parameterToString(xAmzCredential));
        }

        if (xAmzSecurityToken != null) {
            localVarHeaderParams.put("X-Amz-Security-Token", localVarApiClient.parameterToString(xAmzSecurityToken));
        }

        if (xAmzSignature != null) {
            localVarHeaderParams.put("X-Amz-Signature", localVarApiClient.parameterToString(xAmzSignature));
        }

        if (xAmzSignedHeaders != null) {
            localVarHeaderParams.put("X-Amz-SignedHeaders", localVarApiClient.parameterToString(xAmzSignedHeaders));
        }

        final String[] localVarAccepts = {
            "text/xml"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "hmac" };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call gETDescribeSnapshotSchedulesValidateBeforeCall(String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, String clusterIdentifier, String scheduleIdentifier, List<String> tagKeys, List<String> tagValues, String marker, Integer maxRecords, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'action' is set
        if (action == null) {
            throw new ApiException("Missing the required parameter 'action' when calling gETDescribeSnapshotSchedules(Async)");
        }

        // verify the required parameter 'version' is set
        if (version == null) {
            throw new ApiException("Missing the required parameter 'version' when calling gETDescribeSnapshotSchedules(Async)");
        }

        return gETDescribeSnapshotSchedulesCall(action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, clusterIdentifier, scheduleIdentifier, tagKeys, tagValues, marker, maxRecords, _callback);

    }

    /**
     * 
     * Returns a list of snapshot schedules. 
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param clusterIdentifier The unique identifier for the cluster whose snapshot schedules you want to view. (optional)
     * @param scheduleIdentifier A unique identifier for a snapshot schedule. (optional)
     * @param tagKeys The key value for a snapshot schedule tag. (optional)
     * @param tagValues The value corresponding to the key of the snapshot schedule tag. (optional)
     * @param marker A value that indicates the starting point for the next set of response records in a subsequent request. If a value is returned in a response, you can retrieve the next set of records by providing this returned marker value in the &lt;code&gt;marker&lt;/code&gt; parameter and retrying the command. If the &lt;code&gt;marker&lt;/code&gt; field is empty, all response records have been retrieved for the request. (optional)
     * @param maxRecords The maximum number or response records to return in each call. If the number of remaining response records exceeds the specified &lt;code&gt;MaxRecords&lt;/code&gt; value, a value is returned in a &lt;code&gt;marker&lt;/code&gt; field of the response. You can retrieve the next set of records by retrying the command with the returned &lt;code&gt;marker&lt;/code&gt; value. (optional)
     * @return DescribeSnapshotSchedulesOutputMessage
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
     </table>
     */
    public DescribeSnapshotSchedulesOutputMessage gETDescribeSnapshotSchedules(String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, String clusterIdentifier, String scheduleIdentifier, List<String> tagKeys, List<String> tagValues, String marker, Integer maxRecords) throws ApiException {
        ApiResponse<DescribeSnapshotSchedulesOutputMessage> localVarResp = gETDescribeSnapshotSchedulesWithHttpInfo(action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, clusterIdentifier, scheduleIdentifier, tagKeys, tagValues, marker, maxRecords);
        return localVarResp.getData();
    }

    /**
     * 
     * Returns a list of snapshot schedules. 
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param clusterIdentifier The unique identifier for the cluster whose snapshot schedules you want to view. (optional)
     * @param scheduleIdentifier A unique identifier for a snapshot schedule. (optional)
     * @param tagKeys The key value for a snapshot schedule tag. (optional)
     * @param tagValues The value corresponding to the key of the snapshot schedule tag. (optional)
     * @param marker A value that indicates the starting point for the next set of response records in a subsequent request. If a value is returned in a response, you can retrieve the next set of records by providing this returned marker value in the &lt;code&gt;marker&lt;/code&gt; parameter and retrying the command. If the &lt;code&gt;marker&lt;/code&gt; field is empty, all response records have been retrieved for the request. (optional)
     * @param maxRecords The maximum number or response records to return in each call. If the number of remaining response records exceeds the specified &lt;code&gt;MaxRecords&lt;/code&gt; value, a value is returned in a &lt;code&gt;marker&lt;/code&gt; field of the response. You can retrieve the next set of records by retrying the command with the returned &lt;code&gt;marker&lt;/code&gt; value. (optional)
     * @return ApiResponse&lt;DescribeSnapshotSchedulesOutputMessage&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<DescribeSnapshotSchedulesOutputMessage> gETDescribeSnapshotSchedulesWithHttpInfo(String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, String clusterIdentifier, String scheduleIdentifier, List<String> tagKeys, List<String> tagValues, String marker, Integer maxRecords) throws ApiException {
        okhttp3.Call localVarCall = gETDescribeSnapshotSchedulesValidateBeforeCall(action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, clusterIdentifier, scheduleIdentifier, tagKeys, tagValues, marker, maxRecords, null);
        Type localVarReturnType = new TypeToken<DescribeSnapshotSchedulesOutputMessage>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     *  (asynchronously)
     * Returns a list of snapshot schedules. 
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param clusterIdentifier The unique identifier for the cluster whose snapshot schedules you want to view. (optional)
     * @param scheduleIdentifier A unique identifier for a snapshot schedule. (optional)
     * @param tagKeys The key value for a snapshot schedule tag. (optional)
     * @param tagValues The value corresponding to the key of the snapshot schedule tag. (optional)
     * @param marker A value that indicates the starting point for the next set of response records in a subsequent request. If a value is returned in a response, you can retrieve the next set of records by providing this returned marker value in the &lt;code&gt;marker&lt;/code&gt; parameter and retrying the command. If the &lt;code&gt;marker&lt;/code&gt; field is empty, all response records have been retrieved for the request. (optional)
     * @param maxRecords The maximum number or response records to return in each call. If the number of remaining response records exceeds the specified &lt;code&gt;MaxRecords&lt;/code&gt; value, a value is returned in a &lt;code&gt;marker&lt;/code&gt; field of the response. You can retrieve the next set of records by retrying the command with the returned &lt;code&gt;marker&lt;/code&gt; value. (optional)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call gETDescribeSnapshotSchedulesAsync(String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, String clusterIdentifier, String scheduleIdentifier, List<String> tagKeys, List<String> tagValues, String marker, Integer maxRecords, final ApiCallback<DescribeSnapshotSchedulesOutputMessage> _callback) throws ApiException {

        okhttp3.Call localVarCall = gETDescribeSnapshotSchedulesValidateBeforeCall(action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, clusterIdentifier, scheduleIdentifier, tagKeys, tagValues, marker, maxRecords, _callback);
        Type localVarReturnType = new TypeToken<DescribeSnapshotSchedulesOutputMessage>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for gETDescribeStorage
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call gETDescribeStorageCall(String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/#Action=DescribeStorage";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (action != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("Action", action));
        }

        if (version != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("Version", version));
        }

        if (xAmzContentSha256 != null) {
            localVarHeaderParams.put("X-Amz-Content-Sha256", localVarApiClient.parameterToString(xAmzContentSha256));
        }

        if (xAmzDate != null) {
            localVarHeaderParams.put("X-Amz-Date", localVarApiClient.parameterToString(xAmzDate));
        }

        if (xAmzAlgorithm != null) {
            localVarHeaderParams.put("X-Amz-Algorithm", localVarApiClient.parameterToString(xAmzAlgorithm));
        }

        if (xAmzCredential != null) {
            localVarHeaderParams.put("X-Amz-Credential", localVarApiClient.parameterToString(xAmzCredential));
        }

        if (xAmzSecurityToken != null) {
            localVarHeaderParams.put("X-Amz-Security-Token", localVarApiClient.parameterToString(xAmzSecurityToken));
        }

        if (xAmzSignature != null) {
            localVarHeaderParams.put("X-Amz-Signature", localVarApiClient.parameterToString(xAmzSignature));
        }

        if (xAmzSignedHeaders != null) {
            localVarHeaderParams.put("X-Amz-SignedHeaders", localVarApiClient.parameterToString(xAmzSignedHeaders));
        }

        final String[] localVarAccepts = {
            "text/xml"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "hmac" };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call gETDescribeStorageValidateBeforeCall(String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'action' is set
        if (action == null) {
            throw new ApiException("Missing the required parameter 'action' when calling gETDescribeStorage(Async)");
        }

        // verify the required parameter 'version' is set
        if (version == null) {
            throw new ApiException("Missing the required parameter 'version' when calling gETDescribeStorage(Async)");
        }

        return gETDescribeStorageCall(action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, _callback);

    }

    /**
     * 
     * Returns account level backups storage size and provisional storage.
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @return CustomerStorageMessage
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
     </table>
     */
    public CustomerStorageMessage gETDescribeStorage(String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders) throws ApiException {
        ApiResponse<CustomerStorageMessage> localVarResp = gETDescribeStorageWithHttpInfo(action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders);
        return localVarResp.getData();
    }

    /**
     * 
     * Returns account level backups storage size and provisional storage.
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @return ApiResponse&lt;CustomerStorageMessage&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<CustomerStorageMessage> gETDescribeStorageWithHttpInfo(String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders) throws ApiException {
        okhttp3.Call localVarCall = gETDescribeStorageValidateBeforeCall(action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, null);
        Type localVarReturnType = new TypeToken<CustomerStorageMessage>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     *  (asynchronously)
     * Returns account level backups storage size and provisional storage.
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call gETDescribeStorageAsync(String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, final ApiCallback<CustomerStorageMessage> _callback) throws ApiException {

        okhttp3.Call localVarCall = gETDescribeStorageValidateBeforeCall(action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, _callback);
        Type localVarReturnType = new TypeToken<CustomerStorageMessage>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for gETDescribeTableRestoreStatus
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param clusterIdentifier The Amazon Redshift cluster that the table is being restored to. (optional)
     * @param tableRestoreRequestId The identifier of the table restore request to return status for. If you don&#39;t specify a &lt;code&gt;TableRestoreRequestId&lt;/code&gt; value, then &lt;code&gt;DescribeTableRestoreStatus&lt;/code&gt; returns the status of all in-progress table restore requests. (optional)
     * @param maxRecords The maximum number of records to include in the response. If more records exist than the specified &lt;code&gt;MaxRecords&lt;/code&gt; value, a pagination token called a marker is included in the response so that the remaining results can be retrieved. (optional)
     * @param marker An optional pagination token provided by a previous &lt;code&gt;DescribeTableRestoreStatus&lt;/code&gt; request. If this parameter is specified, the response includes only records beyond the marker, up to the value specified by the &lt;code&gt;MaxRecords&lt;/code&gt; parameter. (optional)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> TableRestoreNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> ClusterNotFoundFault </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call gETDescribeTableRestoreStatusCall(String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, String clusterIdentifier, String tableRestoreRequestId, Integer maxRecords, String marker, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/#Action=DescribeTableRestoreStatus";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (clusterIdentifier != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("ClusterIdentifier", clusterIdentifier));
        }

        if (tableRestoreRequestId != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("TableRestoreRequestId", tableRestoreRequestId));
        }

        if (maxRecords != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("MaxRecords", maxRecords));
        }

        if (marker != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("Marker", marker));
        }

        if (action != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("Action", action));
        }

        if (version != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("Version", version));
        }

        if (xAmzContentSha256 != null) {
            localVarHeaderParams.put("X-Amz-Content-Sha256", localVarApiClient.parameterToString(xAmzContentSha256));
        }

        if (xAmzDate != null) {
            localVarHeaderParams.put("X-Amz-Date", localVarApiClient.parameterToString(xAmzDate));
        }

        if (xAmzAlgorithm != null) {
            localVarHeaderParams.put("X-Amz-Algorithm", localVarApiClient.parameterToString(xAmzAlgorithm));
        }

        if (xAmzCredential != null) {
            localVarHeaderParams.put("X-Amz-Credential", localVarApiClient.parameterToString(xAmzCredential));
        }

        if (xAmzSecurityToken != null) {
            localVarHeaderParams.put("X-Amz-Security-Token", localVarApiClient.parameterToString(xAmzSecurityToken));
        }

        if (xAmzSignature != null) {
            localVarHeaderParams.put("X-Amz-Signature", localVarApiClient.parameterToString(xAmzSignature));
        }

        if (xAmzSignedHeaders != null) {
            localVarHeaderParams.put("X-Amz-SignedHeaders", localVarApiClient.parameterToString(xAmzSignedHeaders));
        }

        final String[] localVarAccepts = {
            "text/xml"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "hmac" };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call gETDescribeTableRestoreStatusValidateBeforeCall(String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, String clusterIdentifier, String tableRestoreRequestId, Integer maxRecords, String marker, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'action' is set
        if (action == null) {
            throw new ApiException("Missing the required parameter 'action' when calling gETDescribeTableRestoreStatus(Async)");
        }

        // verify the required parameter 'version' is set
        if (version == null) {
            throw new ApiException("Missing the required parameter 'version' when calling gETDescribeTableRestoreStatus(Async)");
        }

        return gETDescribeTableRestoreStatusCall(action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, clusterIdentifier, tableRestoreRequestId, maxRecords, marker, _callback);

    }

    /**
     * 
     * Lists the status of one or more table restore requests made using the &lt;a&gt;RestoreTableFromClusterSnapshot&lt;/a&gt; API action. If you don&#39;t specify a value for the &lt;code&gt;TableRestoreRequestId&lt;/code&gt; parameter, then &lt;code&gt;DescribeTableRestoreStatus&lt;/code&gt; returns the status of all table restore requests ordered by the date and time of the request in ascending order. Otherwise &lt;code&gt;DescribeTableRestoreStatus&lt;/code&gt; returns the status of the table specified by &lt;code&gt;TableRestoreRequestId&lt;/code&gt;.
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param clusterIdentifier The Amazon Redshift cluster that the table is being restored to. (optional)
     * @param tableRestoreRequestId The identifier of the table restore request to return status for. If you don&#39;t specify a &lt;code&gt;TableRestoreRequestId&lt;/code&gt; value, then &lt;code&gt;DescribeTableRestoreStatus&lt;/code&gt; returns the status of all in-progress table restore requests. (optional)
     * @param maxRecords The maximum number of records to include in the response. If more records exist than the specified &lt;code&gt;MaxRecords&lt;/code&gt; value, a pagination token called a marker is included in the response so that the remaining results can be retrieved. (optional)
     * @param marker An optional pagination token provided by a previous &lt;code&gt;DescribeTableRestoreStatus&lt;/code&gt; request. If this parameter is specified, the response includes only records beyond the marker, up to the value specified by the &lt;code&gt;MaxRecords&lt;/code&gt; parameter. (optional)
     * @return TableRestoreStatusMessage
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> TableRestoreNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> ClusterNotFoundFault </td><td>  -  </td></tr>
     </table>
     */
    public TableRestoreStatusMessage gETDescribeTableRestoreStatus(String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, String clusterIdentifier, String tableRestoreRequestId, Integer maxRecords, String marker) throws ApiException {
        ApiResponse<TableRestoreStatusMessage> localVarResp = gETDescribeTableRestoreStatusWithHttpInfo(action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, clusterIdentifier, tableRestoreRequestId, maxRecords, marker);
        return localVarResp.getData();
    }

    /**
     * 
     * Lists the status of one or more table restore requests made using the &lt;a&gt;RestoreTableFromClusterSnapshot&lt;/a&gt; API action. If you don&#39;t specify a value for the &lt;code&gt;TableRestoreRequestId&lt;/code&gt; parameter, then &lt;code&gt;DescribeTableRestoreStatus&lt;/code&gt; returns the status of all table restore requests ordered by the date and time of the request in ascending order. Otherwise &lt;code&gt;DescribeTableRestoreStatus&lt;/code&gt; returns the status of the table specified by &lt;code&gt;TableRestoreRequestId&lt;/code&gt;.
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param clusterIdentifier The Amazon Redshift cluster that the table is being restored to. (optional)
     * @param tableRestoreRequestId The identifier of the table restore request to return status for. If you don&#39;t specify a &lt;code&gt;TableRestoreRequestId&lt;/code&gt; value, then &lt;code&gt;DescribeTableRestoreStatus&lt;/code&gt; returns the status of all in-progress table restore requests. (optional)
     * @param maxRecords The maximum number of records to include in the response. If more records exist than the specified &lt;code&gt;MaxRecords&lt;/code&gt; value, a pagination token called a marker is included in the response so that the remaining results can be retrieved. (optional)
     * @param marker An optional pagination token provided by a previous &lt;code&gt;DescribeTableRestoreStatus&lt;/code&gt; request. If this parameter is specified, the response includes only records beyond the marker, up to the value specified by the &lt;code&gt;MaxRecords&lt;/code&gt; parameter. (optional)
     * @return ApiResponse&lt;TableRestoreStatusMessage&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> TableRestoreNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> ClusterNotFoundFault </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<TableRestoreStatusMessage> gETDescribeTableRestoreStatusWithHttpInfo(String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, String clusterIdentifier, String tableRestoreRequestId, Integer maxRecords, String marker) throws ApiException {
        okhttp3.Call localVarCall = gETDescribeTableRestoreStatusValidateBeforeCall(action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, clusterIdentifier, tableRestoreRequestId, maxRecords, marker, null);
        Type localVarReturnType = new TypeToken<TableRestoreStatusMessage>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     *  (asynchronously)
     * Lists the status of one or more table restore requests made using the &lt;a&gt;RestoreTableFromClusterSnapshot&lt;/a&gt; API action. If you don&#39;t specify a value for the &lt;code&gt;TableRestoreRequestId&lt;/code&gt; parameter, then &lt;code&gt;DescribeTableRestoreStatus&lt;/code&gt; returns the status of all table restore requests ordered by the date and time of the request in ascending order. Otherwise &lt;code&gt;DescribeTableRestoreStatus&lt;/code&gt; returns the status of the table specified by &lt;code&gt;TableRestoreRequestId&lt;/code&gt;.
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param clusterIdentifier The Amazon Redshift cluster that the table is being restored to. (optional)
     * @param tableRestoreRequestId The identifier of the table restore request to return status for. If you don&#39;t specify a &lt;code&gt;TableRestoreRequestId&lt;/code&gt; value, then &lt;code&gt;DescribeTableRestoreStatus&lt;/code&gt; returns the status of all in-progress table restore requests. (optional)
     * @param maxRecords The maximum number of records to include in the response. If more records exist than the specified &lt;code&gt;MaxRecords&lt;/code&gt; value, a pagination token called a marker is included in the response so that the remaining results can be retrieved. (optional)
     * @param marker An optional pagination token provided by a previous &lt;code&gt;DescribeTableRestoreStatus&lt;/code&gt; request. If this parameter is specified, the response includes only records beyond the marker, up to the value specified by the &lt;code&gt;MaxRecords&lt;/code&gt; parameter. (optional)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> TableRestoreNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> ClusterNotFoundFault </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call gETDescribeTableRestoreStatusAsync(String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, String clusterIdentifier, String tableRestoreRequestId, Integer maxRecords, String marker, final ApiCallback<TableRestoreStatusMessage> _callback) throws ApiException {

        okhttp3.Call localVarCall = gETDescribeTableRestoreStatusValidateBeforeCall(action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, clusterIdentifier, tableRestoreRequestId, maxRecords, marker, _callback);
        Type localVarReturnType = new TypeToken<TableRestoreStatusMessage>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for gETDescribeTags
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param resourceName The Amazon Resource Name (ARN) for which you want to describe the tag or tags. For example, &lt;code&gt;arn:aws:redshift:us-east-2:123456789:cluster:t1&lt;/code&gt;.  (optional)
     * @param resourceType &lt;p&gt;The type of resource with which you want to view tags. Valid resource types are: &lt;/p&gt; &lt;ul&gt; &lt;li&gt; &lt;p&gt;Cluster&lt;/p&gt; &lt;/li&gt; &lt;li&gt; &lt;p&gt;CIDR/IP&lt;/p&gt; &lt;/li&gt; &lt;li&gt; &lt;p&gt;EC2 security group&lt;/p&gt; &lt;/li&gt; &lt;li&gt; &lt;p&gt;Snapshot&lt;/p&gt; &lt;/li&gt; &lt;li&gt; &lt;p&gt;Cluster security group&lt;/p&gt; &lt;/li&gt; &lt;li&gt; &lt;p&gt;Subnet group&lt;/p&gt; &lt;/li&gt; &lt;li&gt; &lt;p&gt;HSM connection&lt;/p&gt; &lt;/li&gt; &lt;li&gt; &lt;p&gt;HSM certificate&lt;/p&gt; &lt;/li&gt; &lt;li&gt; &lt;p&gt;Parameter group&lt;/p&gt; &lt;/li&gt; &lt;li&gt; &lt;p&gt;Snapshot copy grant&lt;/p&gt; &lt;/li&gt; &lt;/ul&gt; &lt;p&gt;For more information about Amazon Redshift resource types and constructing ARNs, go to &lt;a href&#x3D;\&quot;https://docs.aws.amazon.com/redshift/latest/mgmt/redshift-iam-access-control-overview.html#redshift-iam-access-control-specify-actions\&quot;&gt;Specifying Policy Elements: Actions, Effects, Resources, and Principals&lt;/a&gt; in the Amazon Redshift Cluster Management Guide. &lt;/p&gt; (optional)
     * @param maxRecords The maximum number or response records to return in each call. If the number of remaining response records exceeds the specified &lt;code&gt;MaxRecords&lt;/code&gt; value, a value is returned in a &lt;code&gt;marker&lt;/code&gt; field of the response. You can retrieve the next set of records by retrying the command with the returned &lt;code&gt;marker&lt;/code&gt; value.  (optional)
     * @param marker A value that indicates the starting point for the next set of response records in a subsequent request. If a value is returned in a response, you can retrieve the next set of records by providing this returned marker value in the &lt;code&gt;marker&lt;/code&gt; parameter and retrying the command. If the &lt;code&gt;marker&lt;/code&gt; field is empty, all response records have been retrieved for the request.  (optional)
     * @param tagKeys A tag key or keys for which you want to return all matching resources that are associated with the specified key or keys. For example, suppose that you have resources tagged with keys called &lt;code&gt;owner&lt;/code&gt; and &lt;code&gt;environment&lt;/code&gt;. If you specify both of these tag keys in the request, Amazon Redshift returns a response with all resources that have either or both of these tag keys associated with them. (optional)
     * @param tagValues A tag value or values for which you want to return all matching resources that are associated with the specified value or values. For example, suppose that you have resources tagged with values called &lt;code&gt;admin&lt;/code&gt; and &lt;code&gt;test&lt;/code&gt;. If you specify both of these tag values in the request, Amazon Redshift returns a response with all resources that have either or both of these tag values associated with them. (optional)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> ResourceNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> InvalidTagFault </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call gETDescribeTagsCall(String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, String resourceName, String resourceType, Integer maxRecords, String marker, List<String> tagKeys, List<String> tagValues, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/#Action=DescribeTags";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (resourceName != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("ResourceName", resourceName));
        }

        if (resourceType != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("ResourceType", resourceType));
        }

        if (maxRecords != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("MaxRecords", maxRecords));
        }

        if (marker != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("Marker", marker));
        }

        if (tagKeys != null) {
            localVarCollectionQueryParams.addAll(localVarApiClient.parameterToPairs("multi", "TagKeys", tagKeys));
        }

        if (tagValues != null) {
            localVarCollectionQueryParams.addAll(localVarApiClient.parameterToPairs("multi", "TagValues", tagValues));
        }

        if (action != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("Action", action));
        }

        if (version != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("Version", version));
        }

        if (xAmzContentSha256 != null) {
            localVarHeaderParams.put("X-Amz-Content-Sha256", localVarApiClient.parameterToString(xAmzContentSha256));
        }

        if (xAmzDate != null) {
            localVarHeaderParams.put("X-Amz-Date", localVarApiClient.parameterToString(xAmzDate));
        }

        if (xAmzAlgorithm != null) {
            localVarHeaderParams.put("X-Amz-Algorithm", localVarApiClient.parameterToString(xAmzAlgorithm));
        }

        if (xAmzCredential != null) {
            localVarHeaderParams.put("X-Amz-Credential", localVarApiClient.parameterToString(xAmzCredential));
        }

        if (xAmzSecurityToken != null) {
            localVarHeaderParams.put("X-Amz-Security-Token", localVarApiClient.parameterToString(xAmzSecurityToken));
        }

        if (xAmzSignature != null) {
            localVarHeaderParams.put("X-Amz-Signature", localVarApiClient.parameterToString(xAmzSignature));
        }

        if (xAmzSignedHeaders != null) {
            localVarHeaderParams.put("X-Amz-SignedHeaders", localVarApiClient.parameterToString(xAmzSignedHeaders));
        }

        final String[] localVarAccepts = {
            "text/xml"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "hmac" };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call gETDescribeTagsValidateBeforeCall(String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, String resourceName, String resourceType, Integer maxRecords, String marker, List<String> tagKeys, List<String> tagValues, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'action' is set
        if (action == null) {
            throw new ApiException("Missing the required parameter 'action' when calling gETDescribeTags(Async)");
        }

        // verify the required parameter 'version' is set
        if (version == null) {
            throw new ApiException("Missing the required parameter 'version' when calling gETDescribeTags(Async)");
        }

        return gETDescribeTagsCall(action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, resourceName, resourceType, maxRecords, marker, tagKeys, tagValues, _callback);

    }

    /**
     * 
     * &lt;p&gt;Returns a list of tags. You can return tags from a specific resource by specifying an ARN, or you can return all tags for a given type of resource, such as clusters, snapshots, and so on.&lt;/p&gt; &lt;p&gt;The following are limitations for &lt;code&gt;DescribeTags&lt;/code&gt;: &lt;/p&gt; &lt;ul&gt; &lt;li&gt; &lt;p&gt;You cannot specify an ARN and a resource-type value together in the same request.&lt;/p&gt; &lt;/li&gt; &lt;li&gt; &lt;p&gt;You cannot use the &lt;code&gt;MaxRecords&lt;/code&gt; and &lt;code&gt;Marker&lt;/code&gt; parameters together with the ARN parameter.&lt;/p&gt; &lt;/li&gt; &lt;li&gt; &lt;p&gt;The &lt;code&gt;MaxRecords&lt;/code&gt; parameter can be a range from 10 to 50 results to return in a request.&lt;/p&gt; &lt;/li&gt; &lt;/ul&gt; &lt;p&gt;If you specify both tag keys and tag values in the same request, Amazon Redshift returns all resources that match any combination of the specified keys and values. For example, if you have &lt;code&gt;owner&lt;/code&gt; and &lt;code&gt;environment&lt;/code&gt; for tag keys, and &lt;code&gt;admin&lt;/code&gt; and &lt;code&gt;test&lt;/code&gt; for tag values, all resources that have any combination of those values are returned.&lt;/p&gt; &lt;p&gt;If both tag keys and values are omitted from the request, resources are returned regardless of whether they have tag keys or values associated with them.&lt;/p&gt;
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param resourceName The Amazon Resource Name (ARN) for which you want to describe the tag or tags. For example, &lt;code&gt;arn:aws:redshift:us-east-2:123456789:cluster:t1&lt;/code&gt;.  (optional)
     * @param resourceType &lt;p&gt;The type of resource with which you want to view tags. Valid resource types are: &lt;/p&gt; &lt;ul&gt; &lt;li&gt; &lt;p&gt;Cluster&lt;/p&gt; &lt;/li&gt; &lt;li&gt; &lt;p&gt;CIDR/IP&lt;/p&gt; &lt;/li&gt; &lt;li&gt; &lt;p&gt;EC2 security group&lt;/p&gt; &lt;/li&gt; &lt;li&gt; &lt;p&gt;Snapshot&lt;/p&gt; &lt;/li&gt; &lt;li&gt; &lt;p&gt;Cluster security group&lt;/p&gt; &lt;/li&gt; &lt;li&gt; &lt;p&gt;Subnet group&lt;/p&gt; &lt;/li&gt; &lt;li&gt; &lt;p&gt;HSM connection&lt;/p&gt; &lt;/li&gt; &lt;li&gt; &lt;p&gt;HSM certificate&lt;/p&gt; &lt;/li&gt; &lt;li&gt; &lt;p&gt;Parameter group&lt;/p&gt; &lt;/li&gt; &lt;li&gt; &lt;p&gt;Snapshot copy grant&lt;/p&gt; &lt;/li&gt; &lt;/ul&gt; &lt;p&gt;For more information about Amazon Redshift resource types and constructing ARNs, go to &lt;a href&#x3D;\&quot;https://docs.aws.amazon.com/redshift/latest/mgmt/redshift-iam-access-control-overview.html#redshift-iam-access-control-specify-actions\&quot;&gt;Specifying Policy Elements: Actions, Effects, Resources, and Principals&lt;/a&gt; in the Amazon Redshift Cluster Management Guide. &lt;/p&gt; (optional)
     * @param maxRecords The maximum number or response records to return in each call. If the number of remaining response records exceeds the specified &lt;code&gt;MaxRecords&lt;/code&gt; value, a value is returned in a &lt;code&gt;marker&lt;/code&gt; field of the response. You can retrieve the next set of records by retrying the command with the returned &lt;code&gt;marker&lt;/code&gt; value.  (optional)
     * @param marker A value that indicates the starting point for the next set of response records in a subsequent request. If a value is returned in a response, you can retrieve the next set of records by providing this returned marker value in the &lt;code&gt;marker&lt;/code&gt; parameter and retrying the command. If the &lt;code&gt;marker&lt;/code&gt; field is empty, all response records have been retrieved for the request.  (optional)
     * @param tagKeys A tag key or keys for which you want to return all matching resources that are associated with the specified key or keys. For example, suppose that you have resources tagged with keys called &lt;code&gt;owner&lt;/code&gt; and &lt;code&gt;environment&lt;/code&gt;. If you specify both of these tag keys in the request, Amazon Redshift returns a response with all resources that have either or both of these tag keys associated with them. (optional)
     * @param tagValues A tag value or values for which you want to return all matching resources that are associated with the specified value or values. For example, suppose that you have resources tagged with values called &lt;code&gt;admin&lt;/code&gt; and &lt;code&gt;test&lt;/code&gt;. If you specify both of these tag values in the request, Amazon Redshift returns a response with all resources that have either or both of these tag values associated with them. (optional)
     * @return TaggedResourceListMessage
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> ResourceNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> InvalidTagFault </td><td>  -  </td></tr>
     </table>
     */
    public TaggedResourceListMessage gETDescribeTags(String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, String resourceName, String resourceType, Integer maxRecords, String marker, List<String> tagKeys, List<String> tagValues) throws ApiException {
        ApiResponse<TaggedResourceListMessage> localVarResp = gETDescribeTagsWithHttpInfo(action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, resourceName, resourceType, maxRecords, marker, tagKeys, tagValues);
        return localVarResp.getData();
    }

    /**
     * 
     * &lt;p&gt;Returns a list of tags. You can return tags from a specific resource by specifying an ARN, or you can return all tags for a given type of resource, such as clusters, snapshots, and so on.&lt;/p&gt; &lt;p&gt;The following are limitations for &lt;code&gt;DescribeTags&lt;/code&gt;: &lt;/p&gt; &lt;ul&gt; &lt;li&gt; &lt;p&gt;You cannot specify an ARN and a resource-type value together in the same request.&lt;/p&gt; &lt;/li&gt; &lt;li&gt; &lt;p&gt;You cannot use the &lt;code&gt;MaxRecords&lt;/code&gt; and &lt;code&gt;Marker&lt;/code&gt; parameters together with the ARN parameter.&lt;/p&gt; &lt;/li&gt; &lt;li&gt; &lt;p&gt;The &lt;code&gt;MaxRecords&lt;/code&gt; parameter can be a range from 10 to 50 results to return in a request.&lt;/p&gt; &lt;/li&gt; &lt;/ul&gt; &lt;p&gt;If you specify both tag keys and tag values in the same request, Amazon Redshift returns all resources that match any combination of the specified keys and values. For example, if you have &lt;code&gt;owner&lt;/code&gt; and &lt;code&gt;environment&lt;/code&gt; for tag keys, and &lt;code&gt;admin&lt;/code&gt; and &lt;code&gt;test&lt;/code&gt; for tag values, all resources that have any combination of those values are returned.&lt;/p&gt; &lt;p&gt;If both tag keys and values are omitted from the request, resources are returned regardless of whether they have tag keys or values associated with them.&lt;/p&gt;
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param resourceName The Amazon Resource Name (ARN) for which you want to describe the tag or tags. For example, &lt;code&gt;arn:aws:redshift:us-east-2:123456789:cluster:t1&lt;/code&gt;.  (optional)
     * @param resourceType &lt;p&gt;The type of resource with which you want to view tags. Valid resource types are: &lt;/p&gt; &lt;ul&gt; &lt;li&gt; &lt;p&gt;Cluster&lt;/p&gt; &lt;/li&gt; &lt;li&gt; &lt;p&gt;CIDR/IP&lt;/p&gt; &lt;/li&gt; &lt;li&gt; &lt;p&gt;EC2 security group&lt;/p&gt; &lt;/li&gt; &lt;li&gt; &lt;p&gt;Snapshot&lt;/p&gt; &lt;/li&gt; &lt;li&gt; &lt;p&gt;Cluster security group&lt;/p&gt; &lt;/li&gt; &lt;li&gt; &lt;p&gt;Subnet group&lt;/p&gt; &lt;/li&gt; &lt;li&gt; &lt;p&gt;HSM connection&lt;/p&gt; &lt;/li&gt; &lt;li&gt; &lt;p&gt;HSM certificate&lt;/p&gt; &lt;/li&gt; &lt;li&gt; &lt;p&gt;Parameter group&lt;/p&gt; &lt;/li&gt; &lt;li&gt; &lt;p&gt;Snapshot copy grant&lt;/p&gt; &lt;/li&gt; &lt;/ul&gt; &lt;p&gt;For more information about Amazon Redshift resource types and constructing ARNs, go to &lt;a href&#x3D;\&quot;https://docs.aws.amazon.com/redshift/latest/mgmt/redshift-iam-access-control-overview.html#redshift-iam-access-control-specify-actions\&quot;&gt;Specifying Policy Elements: Actions, Effects, Resources, and Principals&lt;/a&gt; in the Amazon Redshift Cluster Management Guide. &lt;/p&gt; (optional)
     * @param maxRecords The maximum number or response records to return in each call. If the number of remaining response records exceeds the specified &lt;code&gt;MaxRecords&lt;/code&gt; value, a value is returned in a &lt;code&gt;marker&lt;/code&gt; field of the response. You can retrieve the next set of records by retrying the command with the returned &lt;code&gt;marker&lt;/code&gt; value.  (optional)
     * @param marker A value that indicates the starting point for the next set of response records in a subsequent request. If a value is returned in a response, you can retrieve the next set of records by providing this returned marker value in the &lt;code&gt;marker&lt;/code&gt; parameter and retrying the command. If the &lt;code&gt;marker&lt;/code&gt; field is empty, all response records have been retrieved for the request.  (optional)
     * @param tagKeys A tag key or keys for which you want to return all matching resources that are associated with the specified key or keys. For example, suppose that you have resources tagged with keys called &lt;code&gt;owner&lt;/code&gt; and &lt;code&gt;environment&lt;/code&gt;. If you specify both of these tag keys in the request, Amazon Redshift returns a response with all resources that have either or both of these tag keys associated with them. (optional)
     * @param tagValues A tag value or values for which you want to return all matching resources that are associated with the specified value or values. For example, suppose that you have resources tagged with values called &lt;code&gt;admin&lt;/code&gt; and &lt;code&gt;test&lt;/code&gt;. If you specify both of these tag values in the request, Amazon Redshift returns a response with all resources that have either or both of these tag values associated with them. (optional)
     * @return ApiResponse&lt;TaggedResourceListMessage&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> ResourceNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> InvalidTagFault </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<TaggedResourceListMessage> gETDescribeTagsWithHttpInfo(String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, String resourceName, String resourceType, Integer maxRecords, String marker, List<String> tagKeys, List<String> tagValues) throws ApiException {
        okhttp3.Call localVarCall = gETDescribeTagsValidateBeforeCall(action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, resourceName, resourceType, maxRecords, marker, tagKeys, tagValues, null);
        Type localVarReturnType = new TypeToken<TaggedResourceListMessage>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     *  (asynchronously)
     * &lt;p&gt;Returns a list of tags. You can return tags from a specific resource by specifying an ARN, or you can return all tags for a given type of resource, such as clusters, snapshots, and so on.&lt;/p&gt; &lt;p&gt;The following are limitations for &lt;code&gt;DescribeTags&lt;/code&gt;: &lt;/p&gt; &lt;ul&gt; &lt;li&gt; &lt;p&gt;You cannot specify an ARN and a resource-type value together in the same request.&lt;/p&gt; &lt;/li&gt; &lt;li&gt; &lt;p&gt;You cannot use the &lt;code&gt;MaxRecords&lt;/code&gt; and &lt;code&gt;Marker&lt;/code&gt; parameters together with the ARN parameter.&lt;/p&gt; &lt;/li&gt; &lt;li&gt; &lt;p&gt;The &lt;code&gt;MaxRecords&lt;/code&gt; parameter can be a range from 10 to 50 results to return in a request.&lt;/p&gt; &lt;/li&gt; &lt;/ul&gt; &lt;p&gt;If you specify both tag keys and tag values in the same request, Amazon Redshift returns all resources that match any combination of the specified keys and values. For example, if you have &lt;code&gt;owner&lt;/code&gt; and &lt;code&gt;environment&lt;/code&gt; for tag keys, and &lt;code&gt;admin&lt;/code&gt; and &lt;code&gt;test&lt;/code&gt; for tag values, all resources that have any combination of those values are returned.&lt;/p&gt; &lt;p&gt;If both tag keys and values are omitted from the request, resources are returned regardless of whether they have tag keys or values associated with them.&lt;/p&gt;
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param resourceName The Amazon Resource Name (ARN) for which you want to describe the tag or tags. For example, &lt;code&gt;arn:aws:redshift:us-east-2:123456789:cluster:t1&lt;/code&gt;.  (optional)
     * @param resourceType &lt;p&gt;The type of resource with which you want to view tags. Valid resource types are: &lt;/p&gt; &lt;ul&gt; &lt;li&gt; &lt;p&gt;Cluster&lt;/p&gt; &lt;/li&gt; &lt;li&gt; &lt;p&gt;CIDR/IP&lt;/p&gt; &lt;/li&gt; &lt;li&gt; &lt;p&gt;EC2 security group&lt;/p&gt; &lt;/li&gt; &lt;li&gt; &lt;p&gt;Snapshot&lt;/p&gt; &lt;/li&gt; &lt;li&gt; &lt;p&gt;Cluster security group&lt;/p&gt; &lt;/li&gt; &lt;li&gt; &lt;p&gt;Subnet group&lt;/p&gt; &lt;/li&gt; &lt;li&gt; &lt;p&gt;HSM connection&lt;/p&gt; &lt;/li&gt; &lt;li&gt; &lt;p&gt;HSM certificate&lt;/p&gt; &lt;/li&gt; &lt;li&gt; &lt;p&gt;Parameter group&lt;/p&gt; &lt;/li&gt; &lt;li&gt; &lt;p&gt;Snapshot copy grant&lt;/p&gt; &lt;/li&gt; &lt;/ul&gt; &lt;p&gt;For more information about Amazon Redshift resource types and constructing ARNs, go to &lt;a href&#x3D;\&quot;https://docs.aws.amazon.com/redshift/latest/mgmt/redshift-iam-access-control-overview.html#redshift-iam-access-control-specify-actions\&quot;&gt;Specifying Policy Elements: Actions, Effects, Resources, and Principals&lt;/a&gt; in the Amazon Redshift Cluster Management Guide. &lt;/p&gt; (optional)
     * @param maxRecords The maximum number or response records to return in each call. If the number of remaining response records exceeds the specified &lt;code&gt;MaxRecords&lt;/code&gt; value, a value is returned in a &lt;code&gt;marker&lt;/code&gt; field of the response. You can retrieve the next set of records by retrying the command with the returned &lt;code&gt;marker&lt;/code&gt; value.  (optional)
     * @param marker A value that indicates the starting point for the next set of response records in a subsequent request. If a value is returned in a response, you can retrieve the next set of records by providing this returned marker value in the &lt;code&gt;marker&lt;/code&gt; parameter and retrying the command. If the &lt;code&gt;marker&lt;/code&gt; field is empty, all response records have been retrieved for the request.  (optional)
     * @param tagKeys A tag key or keys for which you want to return all matching resources that are associated with the specified key or keys. For example, suppose that you have resources tagged with keys called &lt;code&gt;owner&lt;/code&gt; and &lt;code&gt;environment&lt;/code&gt;. If you specify both of these tag keys in the request, Amazon Redshift returns a response with all resources that have either or both of these tag keys associated with them. (optional)
     * @param tagValues A tag value or values for which you want to return all matching resources that are associated with the specified value or values. For example, suppose that you have resources tagged with values called &lt;code&gt;admin&lt;/code&gt; and &lt;code&gt;test&lt;/code&gt;. If you specify both of these tag values in the request, Amazon Redshift returns a response with all resources that have either or both of these tag values associated with them. (optional)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> ResourceNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> InvalidTagFault </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call gETDescribeTagsAsync(String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, String resourceName, String resourceType, Integer maxRecords, String marker, List<String> tagKeys, List<String> tagValues, final ApiCallback<TaggedResourceListMessage> _callback) throws ApiException {

        okhttp3.Call localVarCall = gETDescribeTagsValidateBeforeCall(action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, resourceName, resourceType, maxRecords, marker, tagKeys, tagValues, _callback);
        Type localVarReturnType = new TypeToken<TaggedResourceListMessage>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for gETDescribeUsageLimits
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param usageLimitId The identifier of the usage limit to describe. (optional)
     * @param clusterIdentifier The identifier of the cluster for which you want to describe usage limits. (optional)
     * @param featureType The feature type for which you want to describe usage limits. (optional)
     * @param maxRecords &lt;p&gt;The maximum number of response records to return in each call. If the number of remaining response records exceeds the specified &lt;code&gt;MaxRecords&lt;/code&gt; value, a value is returned in a &lt;code&gt;marker&lt;/code&gt; field of the response. You can retrieve the next set of records by retrying the command with the returned marker value. &lt;/p&gt; &lt;p&gt;Default: &lt;code&gt;100&lt;/code&gt; &lt;/p&gt; &lt;p&gt;Constraints: minimum 20, maximum 100.&lt;/p&gt; (optional)
     * @param marker An optional parameter that specifies the starting point to return a set of response records. When the results of a &lt;a&gt;DescribeUsageLimits&lt;/a&gt; request exceed the value specified in &lt;code&gt;MaxRecords&lt;/code&gt;, Amazon Web Services returns a value in the &lt;code&gt;Marker&lt;/code&gt; field of the response. You can retrieve the next set of response records by providing the returned marker value in the &lt;code&gt;Marker&lt;/code&gt; parameter and retrying the request.  (optional)
     * @param tagKeys A tag key or keys for which you want to return all matching usage limit objects that are associated with the specified key or keys. For example, suppose that you have parameter groups that are tagged with keys called &lt;code&gt;owner&lt;/code&gt; and &lt;code&gt;environment&lt;/code&gt;. If you specify both of these tag keys in the request, Amazon Redshift returns a response with the usage limit objects have either or both of these tag keys associated with them. (optional)
     * @param tagValues A tag value or values for which you want to return all matching usage limit objects that are associated with the specified tag value or values. For example, suppose that you have parameter groups that are tagged with values called &lt;code&gt;admin&lt;/code&gt; and &lt;code&gt;test&lt;/code&gt;. If you specify both of these tag values in the request, Amazon Redshift returns a response with the usage limit objects that have either or both of these tag values associated with them. (optional)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> ClusterNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> UnsupportedOperationFault </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call gETDescribeUsageLimitsCall(String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, String usageLimitId, String clusterIdentifier, String featureType, Integer maxRecords, String marker, List<String> tagKeys, List<String> tagValues, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/#Action=DescribeUsageLimits";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (usageLimitId != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("UsageLimitId", usageLimitId));
        }

        if (clusterIdentifier != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("ClusterIdentifier", clusterIdentifier));
        }

        if (featureType != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("FeatureType", featureType));
        }

        if (maxRecords != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("MaxRecords", maxRecords));
        }

        if (marker != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("Marker", marker));
        }

        if (tagKeys != null) {
            localVarCollectionQueryParams.addAll(localVarApiClient.parameterToPairs("multi", "TagKeys", tagKeys));
        }

        if (tagValues != null) {
            localVarCollectionQueryParams.addAll(localVarApiClient.parameterToPairs("multi", "TagValues", tagValues));
        }

        if (action != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("Action", action));
        }

        if (version != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("Version", version));
        }

        if (xAmzContentSha256 != null) {
            localVarHeaderParams.put("X-Amz-Content-Sha256", localVarApiClient.parameterToString(xAmzContentSha256));
        }

        if (xAmzDate != null) {
            localVarHeaderParams.put("X-Amz-Date", localVarApiClient.parameterToString(xAmzDate));
        }

        if (xAmzAlgorithm != null) {
            localVarHeaderParams.put("X-Amz-Algorithm", localVarApiClient.parameterToString(xAmzAlgorithm));
        }

        if (xAmzCredential != null) {
            localVarHeaderParams.put("X-Amz-Credential", localVarApiClient.parameterToString(xAmzCredential));
        }

        if (xAmzSecurityToken != null) {
            localVarHeaderParams.put("X-Amz-Security-Token", localVarApiClient.parameterToString(xAmzSecurityToken));
        }

        if (xAmzSignature != null) {
            localVarHeaderParams.put("X-Amz-Signature", localVarApiClient.parameterToString(xAmzSignature));
        }

        if (xAmzSignedHeaders != null) {
            localVarHeaderParams.put("X-Amz-SignedHeaders", localVarApiClient.parameterToString(xAmzSignedHeaders));
        }

        final String[] localVarAccepts = {
            "text/xml"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "hmac" };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call gETDescribeUsageLimitsValidateBeforeCall(String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, String usageLimitId, String clusterIdentifier, String featureType, Integer maxRecords, String marker, List<String> tagKeys, List<String> tagValues, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'action' is set
        if (action == null) {
            throw new ApiException("Missing the required parameter 'action' when calling gETDescribeUsageLimits(Async)");
        }

        // verify the required parameter 'version' is set
        if (version == null) {
            throw new ApiException("Missing the required parameter 'version' when calling gETDescribeUsageLimits(Async)");
        }

        return gETDescribeUsageLimitsCall(action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, usageLimitId, clusterIdentifier, featureType, maxRecords, marker, tagKeys, tagValues, _callback);

    }

    /**
     * 
     * &lt;p&gt;Shows usage limits on a cluster. Results are filtered based on the combination of input usage limit identifier, cluster identifier, and feature type parameters:&lt;/p&gt; &lt;ul&gt; &lt;li&gt; &lt;p&gt;If usage limit identifier, cluster identifier, and feature type are not provided, then all usage limit objects for the current account in the current region are returned.&lt;/p&gt; &lt;/li&gt; &lt;li&gt; &lt;p&gt;If usage limit identifier is provided, then the corresponding usage limit object is returned.&lt;/p&gt; &lt;/li&gt; &lt;li&gt; &lt;p&gt;If cluster identifier is provided, then all usage limit objects for the specified cluster are returned.&lt;/p&gt; &lt;/li&gt; &lt;li&gt; &lt;p&gt;If cluster identifier and feature type are provided, then all usage limit objects for the combination of cluster and feature are returned.&lt;/p&gt; &lt;/li&gt; &lt;/ul&gt;
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param usageLimitId The identifier of the usage limit to describe. (optional)
     * @param clusterIdentifier The identifier of the cluster for which you want to describe usage limits. (optional)
     * @param featureType The feature type for which you want to describe usage limits. (optional)
     * @param maxRecords &lt;p&gt;The maximum number of response records to return in each call. If the number of remaining response records exceeds the specified &lt;code&gt;MaxRecords&lt;/code&gt; value, a value is returned in a &lt;code&gt;marker&lt;/code&gt; field of the response. You can retrieve the next set of records by retrying the command with the returned marker value. &lt;/p&gt; &lt;p&gt;Default: &lt;code&gt;100&lt;/code&gt; &lt;/p&gt; &lt;p&gt;Constraints: minimum 20, maximum 100.&lt;/p&gt; (optional)
     * @param marker An optional parameter that specifies the starting point to return a set of response records. When the results of a &lt;a&gt;DescribeUsageLimits&lt;/a&gt; request exceed the value specified in &lt;code&gt;MaxRecords&lt;/code&gt;, Amazon Web Services returns a value in the &lt;code&gt;Marker&lt;/code&gt; field of the response. You can retrieve the next set of response records by providing the returned marker value in the &lt;code&gt;Marker&lt;/code&gt; parameter and retrying the request.  (optional)
     * @param tagKeys A tag key or keys for which you want to return all matching usage limit objects that are associated with the specified key or keys. For example, suppose that you have parameter groups that are tagged with keys called &lt;code&gt;owner&lt;/code&gt; and &lt;code&gt;environment&lt;/code&gt;. If you specify both of these tag keys in the request, Amazon Redshift returns a response with the usage limit objects have either or both of these tag keys associated with them. (optional)
     * @param tagValues A tag value or values for which you want to return all matching usage limit objects that are associated with the specified tag value or values. For example, suppose that you have parameter groups that are tagged with values called &lt;code&gt;admin&lt;/code&gt; and &lt;code&gt;test&lt;/code&gt;. If you specify both of these tag values in the request, Amazon Redshift returns a response with the usage limit objects that have either or both of these tag values associated with them. (optional)
     * @return UsageLimitList
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> ClusterNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> UnsupportedOperationFault </td><td>  -  </td></tr>
     </table>
     */
    public UsageLimitList gETDescribeUsageLimits(String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, String usageLimitId, String clusterIdentifier, String featureType, Integer maxRecords, String marker, List<String> tagKeys, List<String> tagValues) throws ApiException {
        ApiResponse<UsageLimitList> localVarResp = gETDescribeUsageLimitsWithHttpInfo(action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, usageLimitId, clusterIdentifier, featureType, maxRecords, marker, tagKeys, tagValues);
        return localVarResp.getData();
    }

    /**
     * 
     * &lt;p&gt;Shows usage limits on a cluster. Results are filtered based on the combination of input usage limit identifier, cluster identifier, and feature type parameters:&lt;/p&gt; &lt;ul&gt; &lt;li&gt; &lt;p&gt;If usage limit identifier, cluster identifier, and feature type are not provided, then all usage limit objects for the current account in the current region are returned.&lt;/p&gt; &lt;/li&gt; &lt;li&gt; &lt;p&gt;If usage limit identifier is provided, then the corresponding usage limit object is returned.&lt;/p&gt; &lt;/li&gt; &lt;li&gt; &lt;p&gt;If cluster identifier is provided, then all usage limit objects for the specified cluster are returned.&lt;/p&gt; &lt;/li&gt; &lt;li&gt; &lt;p&gt;If cluster identifier and feature type are provided, then all usage limit objects for the combination of cluster and feature are returned.&lt;/p&gt; &lt;/li&gt; &lt;/ul&gt;
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param usageLimitId The identifier of the usage limit to describe. (optional)
     * @param clusterIdentifier The identifier of the cluster for which you want to describe usage limits. (optional)
     * @param featureType The feature type for which you want to describe usage limits. (optional)
     * @param maxRecords &lt;p&gt;The maximum number of response records to return in each call. If the number of remaining response records exceeds the specified &lt;code&gt;MaxRecords&lt;/code&gt; value, a value is returned in a &lt;code&gt;marker&lt;/code&gt; field of the response. You can retrieve the next set of records by retrying the command with the returned marker value. &lt;/p&gt; &lt;p&gt;Default: &lt;code&gt;100&lt;/code&gt; &lt;/p&gt; &lt;p&gt;Constraints: minimum 20, maximum 100.&lt;/p&gt; (optional)
     * @param marker An optional parameter that specifies the starting point to return a set of response records. When the results of a &lt;a&gt;DescribeUsageLimits&lt;/a&gt; request exceed the value specified in &lt;code&gt;MaxRecords&lt;/code&gt;, Amazon Web Services returns a value in the &lt;code&gt;Marker&lt;/code&gt; field of the response. You can retrieve the next set of response records by providing the returned marker value in the &lt;code&gt;Marker&lt;/code&gt; parameter and retrying the request.  (optional)
     * @param tagKeys A tag key or keys for which you want to return all matching usage limit objects that are associated with the specified key or keys. For example, suppose that you have parameter groups that are tagged with keys called &lt;code&gt;owner&lt;/code&gt; and &lt;code&gt;environment&lt;/code&gt;. If you specify both of these tag keys in the request, Amazon Redshift returns a response with the usage limit objects have either or both of these tag keys associated with them. (optional)
     * @param tagValues A tag value or values for which you want to return all matching usage limit objects that are associated with the specified tag value or values. For example, suppose that you have parameter groups that are tagged with values called &lt;code&gt;admin&lt;/code&gt; and &lt;code&gt;test&lt;/code&gt;. If you specify both of these tag values in the request, Amazon Redshift returns a response with the usage limit objects that have either or both of these tag values associated with them. (optional)
     * @return ApiResponse&lt;UsageLimitList&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> ClusterNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> UnsupportedOperationFault </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<UsageLimitList> gETDescribeUsageLimitsWithHttpInfo(String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, String usageLimitId, String clusterIdentifier, String featureType, Integer maxRecords, String marker, List<String> tagKeys, List<String> tagValues) throws ApiException {
        okhttp3.Call localVarCall = gETDescribeUsageLimitsValidateBeforeCall(action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, usageLimitId, clusterIdentifier, featureType, maxRecords, marker, tagKeys, tagValues, null);
        Type localVarReturnType = new TypeToken<UsageLimitList>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     *  (asynchronously)
     * &lt;p&gt;Shows usage limits on a cluster. Results are filtered based on the combination of input usage limit identifier, cluster identifier, and feature type parameters:&lt;/p&gt; &lt;ul&gt; &lt;li&gt; &lt;p&gt;If usage limit identifier, cluster identifier, and feature type are not provided, then all usage limit objects for the current account in the current region are returned.&lt;/p&gt; &lt;/li&gt; &lt;li&gt; &lt;p&gt;If usage limit identifier is provided, then the corresponding usage limit object is returned.&lt;/p&gt; &lt;/li&gt; &lt;li&gt; &lt;p&gt;If cluster identifier is provided, then all usage limit objects for the specified cluster are returned.&lt;/p&gt; &lt;/li&gt; &lt;li&gt; &lt;p&gt;If cluster identifier and feature type are provided, then all usage limit objects for the combination of cluster and feature are returned.&lt;/p&gt; &lt;/li&gt; &lt;/ul&gt;
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param usageLimitId The identifier of the usage limit to describe. (optional)
     * @param clusterIdentifier The identifier of the cluster for which you want to describe usage limits. (optional)
     * @param featureType The feature type for which you want to describe usage limits. (optional)
     * @param maxRecords &lt;p&gt;The maximum number of response records to return in each call. If the number of remaining response records exceeds the specified &lt;code&gt;MaxRecords&lt;/code&gt; value, a value is returned in a &lt;code&gt;marker&lt;/code&gt; field of the response. You can retrieve the next set of records by retrying the command with the returned marker value. &lt;/p&gt; &lt;p&gt;Default: &lt;code&gt;100&lt;/code&gt; &lt;/p&gt; &lt;p&gt;Constraints: minimum 20, maximum 100.&lt;/p&gt; (optional)
     * @param marker An optional parameter that specifies the starting point to return a set of response records. When the results of a &lt;a&gt;DescribeUsageLimits&lt;/a&gt; request exceed the value specified in &lt;code&gt;MaxRecords&lt;/code&gt;, Amazon Web Services returns a value in the &lt;code&gt;Marker&lt;/code&gt; field of the response. You can retrieve the next set of response records by providing the returned marker value in the &lt;code&gt;Marker&lt;/code&gt; parameter and retrying the request.  (optional)
     * @param tagKeys A tag key or keys for which you want to return all matching usage limit objects that are associated with the specified key or keys. For example, suppose that you have parameter groups that are tagged with keys called &lt;code&gt;owner&lt;/code&gt; and &lt;code&gt;environment&lt;/code&gt;. If you specify both of these tag keys in the request, Amazon Redshift returns a response with the usage limit objects have either or both of these tag keys associated with them. (optional)
     * @param tagValues A tag value or values for which you want to return all matching usage limit objects that are associated with the specified tag value or values. For example, suppose that you have parameter groups that are tagged with values called &lt;code&gt;admin&lt;/code&gt; and &lt;code&gt;test&lt;/code&gt;. If you specify both of these tag values in the request, Amazon Redshift returns a response with the usage limit objects that have either or both of these tag values associated with them. (optional)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> ClusterNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> UnsupportedOperationFault </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call gETDescribeUsageLimitsAsync(String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, String usageLimitId, String clusterIdentifier, String featureType, Integer maxRecords, String marker, List<String> tagKeys, List<String> tagValues, final ApiCallback<UsageLimitList> _callback) throws ApiException {

        okhttp3.Call localVarCall = gETDescribeUsageLimitsValidateBeforeCall(action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, usageLimitId, clusterIdentifier, featureType, maxRecords, marker, tagKeys, tagValues, _callback);
        Type localVarReturnType = new TypeToken<UsageLimitList>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for gETDisableLogging
     * @param clusterIdentifier &lt;p&gt;The identifier of the cluster on which logging is to be stopped.&lt;/p&gt; &lt;p&gt;Example: &lt;code&gt;examplecluster&lt;/code&gt; &lt;/p&gt; (required)
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> ClusterNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> InvalidClusterStateFault </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call gETDisableLoggingCall(String clusterIdentifier, String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/#Action=DisableLogging";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (clusterIdentifier != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("ClusterIdentifier", clusterIdentifier));
        }

        if (action != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("Action", action));
        }

        if (version != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("Version", version));
        }

        if (xAmzContentSha256 != null) {
            localVarHeaderParams.put("X-Amz-Content-Sha256", localVarApiClient.parameterToString(xAmzContentSha256));
        }

        if (xAmzDate != null) {
            localVarHeaderParams.put("X-Amz-Date", localVarApiClient.parameterToString(xAmzDate));
        }

        if (xAmzAlgorithm != null) {
            localVarHeaderParams.put("X-Amz-Algorithm", localVarApiClient.parameterToString(xAmzAlgorithm));
        }

        if (xAmzCredential != null) {
            localVarHeaderParams.put("X-Amz-Credential", localVarApiClient.parameterToString(xAmzCredential));
        }

        if (xAmzSecurityToken != null) {
            localVarHeaderParams.put("X-Amz-Security-Token", localVarApiClient.parameterToString(xAmzSecurityToken));
        }

        if (xAmzSignature != null) {
            localVarHeaderParams.put("X-Amz-Signature", localVarApiClient.parameterToString(xAmzSignature));
        }

        if (xAmzSignedHeaders != null) {
            localVarHeaderParams.put("X-Amz-SignedHeaders", localVarApiClient.parameterToString(xAmzSignedHeaders));
        }

        final String[] localVarAccepts = {
            "text/xml"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "hmac" };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call gETDisableLoggingValidateBeforeCall(String clusterIdentifier, String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'clusterIdentifier' is set
        if (clusterIdentifier == null) {
            throw new ApiException("Missing the required parameter 'clusterIdentifier' when calling gETDisableLogging(Async)");
        }

        // verify the required parameter 'action' is set
        if (action == null) {
            throw new ApiException("Missing the required parameter 'action' when calling gETDisableLogging(Async)");
        }

        // verify the required parameter 'version' is set
        if (version == null) {
            throw new ApiException("Missing the required parameter 'version' when calling gETDisableLogging(Async)");
        }

        return gETDisableLoggingCall(clusterIdentifier, action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, _callback);

    }

    /**
     * 
     * Stops logging information, such as queries and connection attempts, for the specified Amazon Redshift cluster.
     * @param clusterIdentifier &lt;p&gt;The identifier of the cluster on which logging is to be stopped.&lt;/p&gt; &lt;p&gt;Example: &lt;code&gt;examplecluster&lt;/code&gt; &lt;/p&gt; (required)
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @return LoggingStatus
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> ClusterNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> InvalidClusterStateFault </td><td>  -  </td></tr>
     </table>
     */
    public LoggingStatus gETDisableLogging(String clusterIdentifier, String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders) throws ApiException {
        ApiResponse<LoggingStatus> localVarResp = gETDisableLoggingWithHttpInfo(clusterIdentifier, action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders);
        return localVarResp.getData();
    }

    /**
     * 
     * Stops logging information, such as queries and connection attempts, for the specified Amazon Redshift cluster.
     * @param clusterIdentifier &lt;p&gt;The identifier of the cluster on which logging is to be stopped.&lt;/p&gt; &lt;p&gt;Example: &lt;code&gt;examplecluster&lt;/code&gt; &lt;/p&gt; (required)
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @return ApiResponse&lt;LoggingStatus&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> ClusterNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> InvalidClusterStateFault </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<LoggingStatus> gETDisableLoggingWithHttpInfo(String clusterIdentifier, String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders) throws ApiException {
        okhttp3.Call localVarCall = gETDisableLoggingValidateBeforeCall(clusterIdentifier, action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, null);
        Type localVarReturnType = new TypeToken<LoggingStatus>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     *  (asynchronously)
     * Stops logging information, such as queries and connection attempts, for the specified Amazon Redshift cluster.
     * @param clusterIdentifier &lt;p&gt;The identifier of the cluster on which logging is to be stopped.&lt;/p&gt; &lt;p&gt;Example: &lt;code&gt;examplecluster&lt;/code&gt; &lt;/p&gt; (required)
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> ClusterNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> InvalidClusterStateFault </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call gETDisableLoggingAsync(String clusterIdentifier, String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, final ApiCallback<LoggingStatus> _callback) throws ApiException {

        okhttp3.Call localVarCall = gETDisableLoggingValidateBeforeCall(clusterIdentifier, action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, _callback);
        Type localVarReturnType = new TypeToken<LoggingStatus>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for gETDisableSnapshotCopy
     * @param clusterIdentifier &lt;p&gt;The unique identifier of the source cluster that you want to disable copying of snapshots to a destination region.&lt;/p&gt; &lt;p&gt;Constraints: Must be the valid name of an existing cluster that has cross-region snapshot copy enabled.&lt;/p&gt; (required)
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> ClusterNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> SnapshotCopyAlreadyDisabledFault </td><td>  -  </td></tr>
        <tr><td> 482 </td><td> InvalidClusterStateFault </td><td>  -  </td></tr>
        <tr><td> 483 </td><td> UnauthorizedOperation </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call gETDisableSnapshotCopyCall(String clusterIdentifier, String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/#Action=DisableSnapshotCopy";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (clusterIdentifier != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("ClusterIdentifier", clusterIdentifier));
        }

        if (action != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("Action", action));
        }

        if (version != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("Version", version));
        }

        if (xAmzContentSha256 != null) {
            localVarHeaderParams.put("X-Amz-Content-Sha256", localVarApiClient.parameterToString(xAmzContentSha256));
        }

        if (xAmzDate != null) {
            localVarHeaderParams.put("X-Amz-Date", localVarApiClient.parameterToString(xAmzDate));
        }

        if (xAmzAlgorithm != null) {
            localVarHeaderParams.put("X-Amz-Algorithm", localVarApiClient.parameterToString(xAmzAlgorithm));
        }

        if (xAmzCredential != null) {
            localVarHeaderParams.put("X-Amz-Credential", localVarApiClient.parameterToString(xAmzCredential));
        }

        if (xAmzSecurityToken != null) {
            localVarHeaderParams.put("X-Amz-Security-Token", localVarApiClient.parameterToString(xAmzSecurityToken));
        }

        if (xAmzSignature != null) {
            localVarHeaderParams.put("X-Amz-Signature", localVarApiClient.parameterToString(xAmzSignature));
        }

        if (xAmzSignedHeaders != null) {
            localVarHeaderParams.put("X-Amz-SignedHeaders", localVarApiClient.parameterToString(xAmzSignedHeaders));
        }

        final String[] localVarAccepts = {
            "text/xml"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "hmac" };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call gETDisableSnapshotCopyValidateBeforeCall(String clusterIdentifier, String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'clusterIdentifier' is set
        if (clusterIdentifier == null) {
            throw new ApiException("Missing the required parameter 'clusterIdentifier' when calling gETDisableSnapshotCopy(Async)");
        }

        // verify the required parameter 'action' is set
        if (action == null) {
            throw new ApiException("Missing the required parameter 'action' when calling gETDisableSnapshotCopy(Async)");
        }

        // verify the required parameter 'version' is set
        if (version == null) {
            throw new ApiException("Missing the required parameter 'version' when calling gETDisableSnapshotCopy(Async)");
        }

        return gETDisableSnapshotCopyCall(clusterIdentifier, action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, _callback);

    }

    /**
     * 
     * &lt;p&gt;Disables the automatic copying of snapshots from one region to another region for a specified cluster.&lt;/p&gt; &lt;p&gt;If your cluster and its snapshots are encrypted using an encrypted symmetric key from Key Management Service, use &lt;a&gt;DeleteSnapshotCopyGrant&lt;/a&gt; to delete the grant that grants Amazon Redshift permission to the key in the destination region. &lt;/p&gt;
     * @param clusterIdentifier &lt;p&gt;The unique identifier of the source cluster that you want to disable copying of snapshots to a destination region.&lt;/p&gt; &lt;p&gt;Constraints: Must be the valid name of an existing cluster that has cross-region snapshot copy enabled.&lt;/p&gt; (required)
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @return DisableSnapshotCopyResult
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> ClusterNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> SnapshotCopyAlreadyDisabledFault </td><td>  -  </td></tr>
        <tr><td> 482 </td><td> InvalidClusterStateFault </td><td>  -  </td></tr>
        <tr><td> 483 </td><td> UnauthorizedOperation </td><td>  -  </td></tr>
     </table>
     */
    public DisableSnapshotCopyResult gETDisableSnapshotCopy(String clusterIdentifier, String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders) throws ApiException {
        ApiResponse<DisableSnapshotCopyResult> localVarResp = gETDisableSnapshotCopyWithHttpInfo(clusterIdentifier, action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders);
        return localVarResp.getData();
    }

    /**
     * 
     * &lt;p&gt;Disables the automatic copying of snapshots from one region to another region for a specified cluster.&lt;/p&gt; &lt;p&gt;If your cluster and its snapshots are encrypted using an encrypted symmetric key from Key Management Service, use &lt;a&gt;DeleteSnapshotCopyGrant&lt;/a&gt; to delete the grant that grants Amazon Redshift permission to the key in the destination region. &lt;/p&gt;
     * @param clusterIdentifier &lt;p&gt;The unique identifier of the source cluster that you want to disable copying of snapshots to a destination region.&lt;/p&gt; &lt;p&gt;Constraints: Must be the valid name of an existing cluster that has cross-region snapshot copy enabled.&lt;/p&gt; (required)
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @return ApiResponse&lt;DisableSnapshotCopyResult&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> ClusterNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> SnapshotCopyAlreadyDisabledFault </td><td>  -  </td></tr>
        <tr><td> 482 </td><td> InvalidClusterStateFault </td><td>  -  </td></tr>
        <tr><td> 483 </td><td> UnauthorizedOperation </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<DisableSnapshotCopyResult> gETDisableSnapshotCopyWithHttpInfo(String clusterIdentifier, String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders) throws ApiException {
        okhttp3.Call localVarCall = gETDisableSnapshotCopyValidateBeforeCall(clusterIdentifier, action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, null);
        Type localVarReturnType = new TypeToken<DisableSnapshotCopyResult>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     *  (asynchronously)
     * &lt;p&gt;Disables the automatic copying of snapshots from one region to another region for a specified cluster.&lt;/p&gt; &lt;p&gt;If your cluster and its snapshots are encrypted using an encrypted symmetric key from Key Management Service, use &lt;a&gt;DeleteSnapshotCopyGrant&lt;/a&gt; to delete the grant that grants Amazon Redshift permission to the key in the destination region. &lt;/p&gt;
     * @param clusterIdentifier &lt;p&gt;The unique identifier of the source cluster that you want to disable copying of snapshots to a destination region.&lt;/p&gt; &lt;p&gt;Constraints: Must be the valid name of an existing cluster that has cross-region snapshot copy enabled.&lt;/p&gt; (required)
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> ClusterNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> SnapshotCopyAlreadyDisabledFault </td><td>  -  </td></tr>
        <tr><td> 482 </td><td> InvalidClusterStateFault </td><td>  -  </td></tr>
        <tr><td> 483 </td><td> UnauthorizedOperation </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call gETDisableSnapshotCopyAsync(String clusterIdentifier, String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, final ApiCallback<DisableSnapshotCopyResult> _callback) throws ApiException {

        okhttp3.Call localVarCall = gETDisableSnapshotCopyValidateBeforeCall(clusterIdentifier, action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, _callback);
        Type localVarReturnType = new TypeToken<DisableSnapshotCopyResult>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for gETDisassociateDataShareConsumer
     * @param dataShareArn The Amazon Resource Name (ARN) of the datashare to remove association for.  (required)
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param disassociateEntireAccount A value that specifies whether association for the datashare is removed from the entire account. (optional)
     * @param consumerArn The Amazon Resource Name (ARN) of the consumer that association for the datashare is removed from. (optional)
     * @param consumerRegion From a datashare consumer account, removes association of a datashare from all the existing and future namespaces in the specified Amazon Web Services Region. (optional)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> InvalidDataShareFault </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> InvalidNamespaceFault </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call gETDisassociateDataShareConsumerCall(String dataShareArn, String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, Boolean disassociateEntireAccount, String consumerArn, String consumerRegion, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/#Action=DisassociateDataShareConsumer";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (dataShareArn != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("DataShareArn", dataShareArn));
        }

        if (disassociateEntireAccount != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("DisassociateEntireAccount", disassociateEntireAccount));
        }

        if (consumerArn != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("ConsumerArn", consumerArn));
        }

        if (consumerRegion != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("ConsumerRegion", consumerRegion));
        }

        if (action != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("Action", action));
        }

        if (version != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("Version", version));
        }

        if (xAmzContentSha256 != null) {
            localVarHeaderParams.put("X-Amz-Content-Sha256", localVarApiClient.parameterToString(xAmzContentSha256));
        }

        if (xAmzDate != null) {
            localVarHeaderParams.put("X-Amz-Date", localVarApiClient.parameterToString(xAmzDate));
        }

        if (xAmzAlgorithm != null) {
            localVarHeaderParams.put("X-Amz-Algorithm", localVarApiClient.parameterToString(xAmzAlgorithm));
        }

        if (xAmzCredential != null) {
            localVarHeaderParams.put("X-Amz-Credential", localVarApiClient.parameterToString(xAmzCredential));
        }

        if (xAmzSecurityToken != null) {
            localVarHeaderParams.put("X-Amz-Security-Token", localVarApiClient.parameterToString(xAmzSecurityToken));
        }

        if (xAmzSignature != null) {
            localVarHeaderParams.put("X-Amz-Signature", localVarApiClient.parameterToString(xAmzSignature));
        }

        if (xAmzSignedHeaders != null) {
            localVarHeaderParams.put("X-Amz-SignedHeaders", localVarApiClient.parameterToString(xAmzSignedHeaders));
        }

        final String[] localVarAccepts = {
            "text/xml"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "hmac" };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call gETDisassociateDataShareConsumerValidateBeforeCall(String dataShareArn, String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, Boolean disassociateEntireAccount, String consumerArn, String consumerRegion, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'dataShareArn' is set
        if (dataShareArn == null) {
            throw new ApiException("Missing the required parameter 'dataShareArn' when calling gETDisassociateDataShareConsumer(Async)");
        }

        // verify the required parameter 'action' is set
        if (action == null) {
            throw new ApiException("Missing the required parameter 'action' when calling gETDisassociateDataShareConsumer(Async)");
        }

        // verify the required parameter 'version' is set
        if (version == null) {
            throw new ApiException("Missing the required parameter 'version' when calling gETDisassociateDataShareConsumer(Async)");
        }

        return gETDisassociateDataShareConsumerCall(dataShareArn, action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, disassociateEntireAccount, consumerArn, consumerRegion, _callback);

    }

    /**
     * 
     * From a datashare consumer account, remove association for the specified datashare. 
     * @param dataShareArn The Amazon Resource Name (ARN) of the datashare to remove association for.  (required)
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param disassociateEntireAccount A value that specifies whether association for the datashare is removed from the entire account. (optional)
     * @param consumerArn The Amazon Resource Name (ARN) of the consumer that association for the datashare is removed from. (optional)
     * @param consumerRegion From a datashare consumer account, removes association of a datashare from all the existing and future namespaces in the specified Amazon Web Services Region. (optional)
     * @return DataShare
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> InvalidDataShareFault </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> InvalidNamespaceFault </td><td>  -  </td></tr>
     </table>
     */
    public DataShare gETDisassociateDataShareConsumer(String dataShareArn, String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, Boolean disassociateEntireAccount, String consumerArn, String consumerRegion) throws ApiException {
        ApiResponse<DataShare> localVarResp = gETDisassociateDataShareConsumerWithHttpInfo(dataShareArn, action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, disassociateEntireAccount, consumerArn, consumerRegion);
        return localVarResp.getData();
    }

    /**
     * 
     * From a datashare consumer account, remove association for the specified datashare. 
     * @param dataShareArn The Amazon Resource Name (ARN) of the datashare to remove association for.  (required)
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param disassociateEntireAccount A value that specifies whether association for the datashare is removed from the entire account. (optional)
     * @param consumerArn The Amazon Resource Name (ARN) of the consumer that association for the datashare is removed from. (optional)
     * @param consumerRegion From a datashare consumer account, removes association of a datashare from all the existing and future namespaces in the specified Amazon Web Services Region. (optional)
     * @return ApiResponse&lt;DataShare&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> InvalidDataShareFault </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> InvalidNamespaceFault </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<DataShare> gETDisassociateDataShareConsumerWithHttpInfo(String dataShareArn, String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, Boolean disassociateEntireAccount, String consumerArn, String consumerRegion) throws ApiException {
        okhttp3.Call localVarCall = gETDisassociateDataShareConsumerValidateBeforeCall(dataShareArn, action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, disassociateEntireAccount, consumerArn, consumerRegion, null);
        Type localVarReturnType = new TypeToken<DataShare>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     *  (asynchronously)
     * From a datashare consumer account, remove association for the specified datashare. 
     * @param dataShareArn The Amazon Resource Name (ARN) of the datashare to remove association for.  (required)
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param disassociateEntireAccount A value that specifies whether association for the datashare is removed from the entire account. (optional)
     * @param consumerArn The Amazon Resource Name (ARN) of the consumer that association for the datashare is removed from. (optional)
     * @param consumerRegion From a datashare consumer account, removes association of a datashare from all the existing and future namespaces in the specified Amazon Web Services Region. (optional)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> InvalidDataShareFault </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> InvalidNamespaceFault </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call gETDisassociateDataShareConsumerAsync(String dataShareArn, String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, Boolean disassociateEntireAccount, String consumerArn, String consumerRegion, final ApiCallback<DataShare> _callback) throws ApiException {

        okhttp3.Call localVarCall = gETDisassociateDataShareConsumerValidateBeforeCall(dataShareArn, action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, disassociateEntireAccount, consumerArn, consumerRegion, _callback);
        Type localVarReturnType = new TypeToken<DataShare>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for gETEnableLogging
     * @param clusterIdentifier &lt;p&gt;The identifier of the cluster on which logging is to be started.&lt;/p&gt; &lt;p&gt;Example: &lt;code&gt;examplecluster&lt;/code&gt; &lt;/p&gt; (required)
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param bucketName &lt;p&gt;The name of an existing S3 bucket where the log files are to be stored.&lt;/p&gt; &lt;p&gt;Constraints:&lt;/p&gt; &lt;ul&gt; &lt;li&gt; &lt;p&gt;Must be in the same region as the cluster&lt;/p&gt; &lt;/li&gt; &lt;li&gt; &lt;p&gt;The cluster must have read bucket and put object permissions&lt;/p&gt; &lt;/li&gt; &lt;/ul&gt; (optional)
     * @param s3KeyPrefix &lt;p&gt;The prefix applied to the log file names.&lt;/p&gt; &lt;p&gt;Constraints:&lt;/p&gt; &lt;ul&gt; &lt;li&gt; &lt;p&gt;Cannot exceed 512 characters&lt;/p&gt; &lt;/li&gt; &lt;li&gt; &lt;p&gt;Cannot contain spaces( ), double quotes (\&quot;), single quotes (&#39;), a backslash (\\), or control characters. The hexadecimal codes for invalid characters are: &lt;/p&gt; &lt;ul&gt; &lt;li&gt; &lt;p&gt;x00 to x20&lt;/p&gt; &lt;/li&gt; &lt;li&gt; &lt;p&gt;x22&lt;/p&gt; &lt;/li&gt; &lt;li&gt; &lt;p&gt;x27&lt;/p&gt; &lt;/li&gt; &lt;li&gt; &lt;p&gt;x5c&lt;/p&gt; &lt;/li&gt; &lt;li&gt; &lt;p&gt;x7f or larger&lt;/p&gt; &lt;/li&gt; &lt;/ul&gt; &lt;/li&gt; &lt;/ul&gt; (optional)
     * @param logDestinationType The log destination type. An enum with possible values of &lt;code&gt;s3&lt;/code&gt; and &lt;code&gt;cloudwatch&lt;/code&gt;. (optional)
     * @param logExports The collection of exported log types. Possible values are &lt;code&gt;connectionlog&lt;/code&gt;, &lt;code&gt;useractivitylog&lt;/code&gt;, and &lt;code&gt;userlog&lt;/code&gt;. (optional)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> ClusterNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> BucketNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 482 </td><td> InsufficientS3BucketPolicyFault </td><td>  -  </td></tr>
        <tr><td> 483 </td><td> InvalidS3KeyPrefixFault </td><td>  -  </td></tr>
        <tr><td> 484 </td><td> InvalidS3BucketNameFault </td><td>  -  </td></tr>
        <tr><td> 485 </td><td> InvalidClusterStateFault </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call gETEnableLoggingCall(String clusterIdentifier, String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, String bucketName, String s3KeyPrefix, String logDestinationType, List<String> logExports, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/#Action=EnableLogging";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (clusterIdentifier != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("ClusterIdentifier", clusterIdentifier));
        }

        if (bucketName != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("BucketName", bucketName));
        }

        if (s3KeyPrefix != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("S3KeyPrefix", s3KeyPrefix));
        }

        if (logDestinationType != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("LogDestinationType", logDestinationType));
        }

        if (logExports != null) {
            localVarCollectionQueryParams.addAll(localVarApiClient.parameterToPairs("multi", "LogExports", logExports));
        }

        if (action != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("Action", action));
        }

        if (version != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("Version", version));
        }

        if (xAmzContentSha256 != null) {
            localVarHeaderParams.put("X-Amz-Content-Sha256", localVarApiClient.parameterToString(xAmzContentSha256));
        }

        if (xAmzDate != null) {
            localVarHeaderParams.put("X-Amz-Date", localVarApiClient.parameterToString(xAmzDate));
        }

        if (xAmzAlgorithm != null) {
            localVarHeaderParams.put("X-Amz-Algorithm", localVarApiClient.parameterToString(xAmzAlgorithm));
        }

        if (xAmzCredential != null) {
            localVarHeaderParams.put("X-Amz-Credential", localVarApiClient.parameterToString(xAmzCredential));
        }

        if (xAmzSecurityToken != null) {
            localVarHeaderParams.put("X-Amz-Security-Token", localVarApiClient.parameterToString(xAmzSecurityToken));
        }

        if (xAmzSignature != null) {
            localVarHeaderParams.put("X-Amz-Signature", localVarApiClient.parameterToString(xAmzSignature));
        }

        if (xAmzSignedHeaders != null) {
            localVarHeaderParams.put("X-Amz-SignedHeaders", localVarApiClient.parameterToString(xAmzSignedHeaders));
        }

        final String[] localVarAccepts = {
            "text/xml"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "hmac" };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call gETEnableLoggingValidateBeforeCall(String clusterIdentifier, String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, String bucketName, String s3KeyPrefix, String logDestinationType, List<String> logExports, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'clusterIdentifier' is set
        if (clusterIdentifier == null) {
            throw new ApiException("Missing the required parameter 'clusterIdentifier' when calling gETEnableLogging(Async)");
        }

        // verify the required parameter 'action' is set
        if (action == null) {
            throw new ApiException("Missing the required parameter 'action' when calling gETEnableLogging(Async)");
        }

        // verify the required parameter 'version' is set
        if (version == null) {
            throw new ApiException("Missing the required parameter 'version' when calling gETEnableLogging(Async)");
        }

        return gETEnableLoggingCall(clusterIdentifier, action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, bucketName, s3KeyPrefix, logDestinationType, logExports, _callback);

    }

    /**
     * 
     * Starts logging information, such as queries and connection attempts, for the specified Amazon Redshift cluster.
     * @param clusterIdentifier &lt;p&gt;The identifier of the cluster on which logging is to be started.&lt;/p&gt; &lt;p&gt;Example: &lt;code&gt;examplecluster&lt;/code&gt; &lt;/p&gt; (required)
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param bucketName &lt;p&gt;The name of an existing S3 bucket where the log files are to be stored.&lt;/p&gt; &lt;p&gt;Constraints:&lt;/p&gt; &lt;ul&gt; &lt;li&gt; &lt;p&gt;Must be in the same region as the cluster&lt;/p&gt; &lt;/li&gt; &lt;li&gt; &lt;p&gt;The cluster must have read bucket and put object permissions&lt;/p&gt; &lt;/li&gt; &lt;/ul&gt; (optional)
     * @param s3KeyPrefix &lt;p&gt;The prefix applied to the log file names.&lt;/p&gt; &lt;p&gt;Constraints:&lt;/p&gt; &lt;ul&gt; &lt;li&gt; &lt;p&gt;Cannot exceed 512 characters&lt;/p&gt; &lt;/li&gt; &lt;li&gt; &lt;p&gt;Cannot contain spaces( ), double quotes (\&quot;), single quotes (&#39;), a backslash (\\), or control characters. The hexadecimal codes for invalid characters are: &lt;/p&gt; &lt;ul&gt; &lt;li&gt; &lt;p&gt;x00 to x20&lt;/p&gt; &lt;/li&gt; &lt;li&gt; &lt;p&gt;x22&lt;/p&gt; &lt;/li&gt; &lt;li&gt; &lt;p&gt;x27&lt;/p&gt; &lt;/li&gt; &lt;li&gt; &lt;p&gt;x5c&lt;/p&gt; &lt;/li&gt; &lt;li&gt; &lt;p&gt;x7f or larger&lt;/p&gt; &lt;/li&gt; &lt;/ul&gt; &lt;/li&gt; &lt;/ul&gt; (optional)
     * @param logDestinationType The log destination type. An enum with possible values of &lt;code&gt;s3&lt;/code&gt; and &lt;code&gt;cloudwatch&lt;/code&gt;. (optional)
     * @param logExports The collection of exported log types. Possible values are &lt;code&gt;connectionlog&lt;/code&gt;, &lt;code&gt;useractivitylog&lt;/code&gt;, and &lt;code&gt;userlog&lt;/code&gt;. (optional)
     * @return LoggingStatus
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> ClusterNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> BucketNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 482 </td><td> InsufficientS3BucketPolicyFault </td><td>  -  </td></tr>
        <tr><td> 483 </td><td> InvalidS3KeyPrefixFault </td><td>  -  </td></tr>
        <tr><td> 484 </td><td> InvalidS3BucketNameFault </td><td>  -  </td></tr>
        <tr><td> 485 </td><td> InvalidClusterStateFault </td><td>  -  </td></tr>
     </table>
     */
    public LoggingStatus gETEnableLogging(String clusterIdentifier, String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, String bucketName, String s3KeyPrefix, String logDestinationType, List<String> logExports) throws ApiException {
        ApiResponse<LoggingStatus> localVarResp = gETEnableLoggingWithHttpInfo(clusterIdentifier, action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, bucketName, s3KeyPrefix, logDestinationType, logExports);
        return localVarResp.getData();
    }

    /**
     * 
     * Starts logging information, such as queries and connection attempts, for the specified Amazon Redshift cluster.
     * @param clusterIdentifier &lt;p&gt;The identifier of the cluster on which logging is to be started.&lt;/p&gt; &lt;p&gt;Example: &lt;code&gt;examplecluster&lt;/code&gt; &lt;/p&gt; (required)
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param bucketName &lt;p&gt;The name of an existing S3 bucket where the log files are to be stored.&lt;/p&gt; &lt;p&gt;Constraints:&lt;/p&gt; &lt;ul&gt; &lt;li&gt; &lt;p&gt;Must be in the same region as the cluster&lt;/p&gt; &lt;/li&gt; &lt;li&gt; &lt;p&gt;The cluster must have read bucket and put object permissions&lt;/p&gt; &lt;/li&gt; &lt;/ul&gt; (optional)
     * @param s3KeyPrefix &lt;p&gt;The prefix applied to the log file names.&lt;/p&gt; &lt;p&gt;Constraints:&lt;/p&gt; &lt;ul&gt; &lt;li&gt; &lt;p&gt;Cannot exceed 512 characters&lt;/p&gt; &lt;/li&gt; &lt;li&gt; &lt;p&gt;Cannot contain spaces( ), double quotes (\&quot;), single quotes (&#39;), a backslash (\\), or control characters. The hexadecimal codes for invalid characters are: &lt;/p&gt; &lt;ul&gt; &lt;li&gt; &lt;p&gt;x00 to x20&lt;/p&gt; &lt;/li&gt; &lt;li&gt; &lt;p&gt;x22&lt;/p&gt; &lt;/li&gt; &lt;li&gt; &lt;p&gt;x27&lt;/p&gt; &lt;/li&gt; &lt;li&gt; &lt;p&gt;x5c&lt;/p&gt; &lt;/li&gt; &lt;li&gt; &lt;p&gt;x7f or larger&lt;/p&gt; &lt;/li&gt; &lt;/ul&gt; &lt;/li&gt; &lt;/ul&gt; (optional)
     * @param logDestinationType The log destination type. An enum with possible values of &lt;code&gt;s3&lt;/code&gt; and &lt;code&gt;cloudwatch&lt;/code&gt;. (optional)
     * @param logExports The collection of exported log types. Possible values are &lt;code&gt;connectionlog&lt;/code&gt;, &lt;code&gt;useractivitylog&lt;/code&gt;, and &lt;code&gt;userlog&lt;/code&gt;. (optional)
     * @return ApiResponse&lt;LoggingStatus&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> ClusterNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> BucketNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 482 </td><td> InsufficientS3BucketPolicyFault </td><td>  -  </td></tr>
        <tr><td> 483 </td><td> InvalidS3KeyPrefixFault </td><td>  -  </td></tr>
        <tr><td> 484 </td><td> InvalidS3BucketNameFault </td><td>  -  </td></tr>
        <tr><td> 485 </td><td> InvalidClusterStateFault </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<LoggingStatus> gETEnableLoggingWithHttpInfo(String clusterIdentifier, String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, String bucketName, String s3KeyPrefix, String logDestinationType, List<String> logExports) throws ApiException {
        okhttp3.Call localVarCall = gETEnableLoggingValidateBeforeCall(clusterIdentifier, action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, bucketName, s3KeyPrefix, logDestinationType, logExports, null);
        Type localVarReturnType = new TypeToken<LoggingStatus>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     *  (asynchronously)
     * Starts logging information, such as queries and connection attempts, for the specified Amazon Redshift cluster.
     * @param clusterIdentifier &lt;p&gt;The identifier of the cluster on which logging is to be started.&lt;/p&gt; &lt;p&gt;Example: &lt;code&gt;examplecluster&lt;/code&gt; &lt;/p&gt; (required)
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param bucketName &lt;p&gt;The name of an existing S3 bucket where the log files are to be stored.&lt;/p&gt; &lt;p&gt;Constraints:&lt;/p&gt; &lt;ul&gt; &lt;li&gt; &lt;p&gt;Must be in the same region as the cluster&lt;/p&gt; &lt;/li&gt; &lt;li&gt; &lt;p&gt;The cluster must have read bucket and put object permissions&lt;/p&gt; &lt;/li&gt; &lt;/ul&gt; (optional)
     * @param s3KeyPrefix &lt;p&gt;The prefix applied to the log file names.&lt;/p&gt; &lt;p&gt;Constraints:&lt;/p&gt; &lt;ul&gt; &lt;li&gt; &lt;p&gt;Cannot exceed 512 characters&lt;/p&gt; &lt;/li&gt; &lt;li&gt; &lt;p&gt;Cannot contain spaces( ), double quotes (\&quot;), single quotes (&#39;), a backslash (\\), or control characters. The hexadecimal codes for invalid characters are: &lt;/p&gt; &lt;ul&gt; &lt;li&gt; &lt;p&gt;x00 to x20&lt;/p&gt; &lt;/li&gt; &lt;li&gt; &lt;p&gt;x22&lt;/p&gt; &lt;/li&gt; &lt;li&gt; &lt;p&gt;x27&lt;/p&gt; &lt;/li&gt; &lt;li&gt; &lt;p&gt;x5c&lt;/p&gt; &lt;/li&gt; &lt;li&gt; &lt;p&gt;x7f or larger&lt;/p&gt; &lt;/li&gt; &lt;/ul&gt; &lt;/li&gt; &lt;/ul&gt; (optional)
     * @param logDestinationType The log destination type. An enum with possible values of &lt;code&gt;s3&lt;/code&gt; and &lt;code&gt;cloudwatch&lt;/code&gt;. (optional)
     * @param logExports The collection of exported log types. Possible values are &lt;code&gt;connectionlog&lt;/code&gt;, &lt;code&gt;useractivitylog&lt;/code&gt;, and &lt;code&gt;userlog&lt;/code&gt;. (optional)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> ClusterNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> BucketNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 482 </td><td> InsufficientS3BucketPolicyFault </td><td>  -  </td></tr>
        <tr><td> 483 </td><td> InvalidS3KeyPrefixFault </td><td>  -  </td></tr>
        <tr><td> 484 </td><td> InvalidS3BucketNameFault </td><td>  -  </td></tr>
        <tr><td> 485 </td><td> InvalidClusterStateFault </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call gETEnableLoggingAsync(String clusterIdentifier, String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, String bucketName, String s3KeyPrefix, String logDestinationType, List<String> logExports, final ApiCallback<LoggingStatus> _callback) throws ApiException {

        okhttp3.Call localVarCall = gETEnableLoggingValidateBeforeCall(clusterIdentifier, action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, bucketName, s3KeyPrefix, logDestinationType, logExports, _callback);
        Type localVarReturnType = new TypeToken<LoggingStatus>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for gETEnableSnapshotCopy
     * @param clusterIdentifier &lt;p&gt;The unique identifier of the source cluster to copy snapshots from.&lt;/p&gt; &lt;p&gt;Constraints: Must be the valid name of an existing cluster that does not already have cross-region snapshot copy enabled.&lt;/p&gt; (required)
     * @param destinationRegion &lt;p&gt;The destination Amazon Web Services Region that you want to copy snapshots to.&lt;/p&gt; &lt;p&gt;Constraints: Must be the name of a valid Amazon Web Services Region. For more information, see &lt;a href&#x3D;\&quot;https://docs.aws.amazon.com/general/latest/gr/rande.html#redshift_region\&quot;&gt;Regions and Endpoints&lt;/a&gt; in the Amazon Web Services General Reference. &lt;/p&gt; (required)
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param retentionPeriod &lt;p&gt;The number of days to retain automated snapshots in the destination region after they are copied from the source region.&lt;/p&gt; &lt;p&gt;Default: 7.&lt;/p&gt; &lt;p&gt;Constraints: Must be at least 1 and no more than 35.&lt;/p&gt; (optional)
     * @param snapshotCopyGrantName The name of the snapshot copy grant to use when snapshots of an Amazon Web Services KMS-encrypted cluster are copied to the destination region. (optional)
     * @param manualSnapshotRetentionPeriod &lt;p&gt;The number of days to retain newly copied snapshots in the destination Amazon Web Services Region after they are copied from the source Amazon Web Services Region. If the value is -1, the manual snapshot is retained indefinitely. &lt;/p&gt; &lt;p&gt;The value must be either -1 or an integer between 1 and 3,653.&lt;/p&gt; (optional)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> IncompatibleOrderableOptions </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> InvalidClusterStateFault </td><td>  -  </td></tr>
        <tr><td> 482 </td><td> ClusterNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 483 </td><td> CopyToRegionDisabledFault </td><td>  -  </td></tr>
        <tr><td> 484 </td><td> SnapshotCopyAlreadyEnabledFault </td><td>  -  </td></tr>
        <tr><td> 485 </td><td> UnknownSnapshotCopyRegionFault </td><td>  -  </td></tr>
        <tr><td> 486 </td><td> UnauthorizedOperation </td><td>  -  </td></tr>
        <tr><td> 487 </td><td> SnapshotCopyGrantNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 488 </td><td> LimitExceededFault </td><td>  -  </td></tr>
        <tr><td> 489 </td><td> DependentServiceRequestThrottlingFault </td><td>  -  </td></tr>
        <tr><td> 490 </td><td> InvalidRetentionPeriodFault </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call gETEnableSnapshotCopyCall(String clusterIdentifier, String destinationRegion, String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, Integer retentionPeriod, String snapshotCopyGrantName, Integer manualSnapshotRetentionPeriod, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/#Action=EnableSnapshotCopy";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (clusterIdentifier != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("ClusterIdentifier", clusterIdentifier));
        }

        if (destinationRegion != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("DestinationRegion", destinationRegion));
        }

        if (retentionPeriod != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("RetentionPeriod", retentionPeriod));
        }

        if (snapshotCopyGrantName != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("SnapshotCopyGrantName", snapshotCopyGrantName));
        }

        if (manualSnapshotRetentionPeriod != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("ManualSnapshotRetentionPeriod", manualSnapshotRetentionPeriod));
        }

        if (action != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("Action", action));
        }

        if (version != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("Version", version));
        }

        if (xAmzContentSha256 != null) {
            localVarHeaderParams.put("X-Amz-Content-Sha256", localVarApiClient.parameterToString(xAmzContentSha256));
        }

        if (xAmzDate != null) {
            localVarHeaderParams.put("X-Amz-Date", localVarApiClient.parameterToString(xAmzDate));
        }

        if (xAmzAlgorithm != null) {
            localVarHeaderParams.put("X-Amz-Algorithm", localVarApiClient.parameterToString(xAmzAlgorithm));
        }

        if (xAmzCredential != null) {
            localVarHeaderParams.put("X-Amz-Credential", localVarApiClient.parameterToString(xAmzCredential));
        }

        if (xAmzSecurityToken != null) {
            localVarHeaderParams.put("X-Amz-Security-Token", localVarApiClient.parameterToString(xAmzSecurityToken));
        }

        if (xAmzSignature != null) {
            localVarHeaderParams.put("X-Amz-Signature", localVarApiClient.parameterToString(xAmzSignature));
        }

        if (xAmzSignedHeaders != null) {
            localVarHeaderParams.put("X-Amz-SignedHeaders", localVarApiClient.parameterToString(xAmzSignedHeaders));
        }

        final String[] localVarAccepts = {
            "text/xml"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "hmac" };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call gETEnableSnapshotCopyValidateBeforeCall(String clusterIdentifier, String destinationRegion, String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, Integer retentionPeriod, String snapshotCopyGrantName, Integer manualSnapshotRetentionPeriod, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'clusterIdentifier' is set
        if (clusterIdentifier == null) {
            throw new ApiException("Missing the required parameter 'clusterIdentifier' when calling gETEnableSnapshotCopy(Async)");
        }

        // verify the required parameter 'destinationRegion' is set
        if (destinationRegion == null) {
            throw new ApiException("Missing the required parameter 'destinationRegion' when calling gETEnableSnapshotCopy(Async)");
        }

        // verify the required parameter 'action' is set
        if (action == null) {
            throw new ApiException("Missing the required parameter 'action' when calling gETEnableSnapshotCopy(Async)");
        }

        // verify the required parameter 'version' is set
        if (version == null) {
            throw new ApiException("Missing the required parameter 'version' when calling gETEnableSnapshotCopy(Async)");
        }

        return gETEnableSnapshotCopyCall(clusterIdentifier, destinationRegion, action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, retentionPeriod, snapshotCopyGrantName, manualSnapshotRetentionPeriod, _callback);

    }

    /**
     * 
     * Enables the automatic copy of snapshots from one region to another region for a specified cluster.
     * @param clusterIdentifier &lt;p&gt;The unique identifier of the source cluster to copy snapshots from.&lt;/p&gt; &lt;p&gt;Constraints: Must be the valid name of an existing cluster that does not already have cross-region snapshot copy enabled.&lt;/p&gt; (required)
     * @param destinationRegion &lt;p&gt;The destination Amazon Web Services Region that you want to copy snapshots to.&lt;/p&gt; &lt;p&gt;Constraints: Must be the name of a valid Amazon Web Services Region. For more information, see &lt;a href&#x3D;\&quot;https://docs.aws.amazon.com/general/latest/gr/rande.html#redshift_region\&quot;&gt;Regions and Endpoints&lt;/a&gt; in the Amazon Web Services General Reference. &lt;/p&gt; (required)
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param retentionPeriod &lt;p&gt;The number of days to retain automated snapshots in the destination region after they are copied from the source region.&lt;/p&gt; &lt;p&gt;Default: 7.&lt;/p&gt; &lt;p&gt;Constraints: Must be at least 1 and no more than 35.&lt;/p&gt; (optional)
     * @param snapshotCopyGrantName The name of the snapshot copy grant to use when snapshots of an Amazon Web Services KMS-encrypted cluster are copied to the destination region. (optional)
     * @param manualSnapshotRetentionPeriod &lt;p&gt;The number of days to retain newly copied snapshots in the destination Amazon Web Services Region after they are copied from the source Amazon Web Services Region. If the value is -1, the manual snapshot is retained indefinitely. &lt;/p&gt; &lt;p&gt;The value must be either -1 or an integer between 1 and 3,653.&lt;/p&gt; (optional)
     * @return EnableSnapshotCopyResult
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> IncompatibleOrderableOptions </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> InvalidClusterStateFault </td><td>  -  </td></tr>
        <tr><td> 482 </td><td> ClusterNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 483 </td><td> CopyToRegionDisabledFault </td><td>  -  </td></tr>
        <tr><td> 484 </td><td> SnapshotCopyAlreadyEnabledFault </td><td>  -  </td></tr>
        <tr><td> 485 </td><td> UnknownSnapshotCopyRegionFault </td><td>  -  </td></tr>
        <tr><td> 486 </td><td> UnauthorizedOperation </td><td>  -  </td></tr>
        <tr><td> 487 </td><td> SnapshotCopyGrantNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 488 </td><td> LimitExceededFault </td><td>  -  </td></tr>
        <tr><td> 489 </td><td> DependentServiceRequestThrottlingFault </td><td>  -  </td></tr>
        <tr><td> 490 </td><td> InvalidRetentionPeriodFault </td><td>  -  </td></tr>
     </table>
     */
    public EnableSnapshotCopyResult gETEnableSnapshotCopy(String clusterIdentifier, String destinationRegion, String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, Integer retentionPeriod, String snapshotCopyGrantName, Integer manualSnapshotRetentionPeriod) throws ApiException {
        ApiResponse<EnableSnapshotCopyResult> localVarResp = gETEnableSnapshotCopyWithHttpInfo(clusterIdentifier, destinationRegion, action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, retentionPeriod, snapshotCopyGrantName, manualSnapshotRetentionPeriod);
        return localVarResp.getData();
    }

    /**
     * 
     * Enables the automatic copy of snapshots from one region to another region for a specified cluster.
     * @param clusterIdentifier &lt;p&gt;The unique identifier of the source cluster to copy snapshots from.&lt;/p&gt; &lt;p&gt;Constraints: Must be the valid name of an existing cluster that does not already have cross-region snapshot copy enabled.&lt;/p&gt; (required)
     * @param destinationRegion &lt;p&gt;The destination Amazon Web Services Region that you want to copy snapshots to.&lt;/p&gt; &lt;p&gt;Constraints: Must be the name of a valid Amazon Web Services Region. For more information, see &lt;a href&#x3D;\&quot;https://docs.aws.amazon.com/general/latest/gr/rande.html#redshift_region\&quot;&gt;Regions and Endpoints&lt;/a&gt; in the Amazon Web Services General Reference. &lt;/p&gt; (required)
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param retentionPeriod &lt;p&gt;The number of days to retain automated snapshots in the destination region after they are copied from the source region.&lt;/p&gt; &lt;p&gt;Default: 7.&lt;/p&gt; &lt;p&gt;Constraints: Must be at least 1 and no more than 35.&lt;/p&gt; (optional)
     * @param snapshotCopyGrantName The name of the snapshot copy grant to use when snapshots of an Amazon Web Services KMS-encrypted cluster are copied to the destination region. (optional)
     * @param manualSnapshotRetentionPeriod &lt;p&gt;The number of days to retain newly copied snapshots in the destination Amazon Web Services Region after they are copied from the source Amazon Web Services Region. If the value is -1, the manual snapshot is retained indefinitely. &lt;/p&gt; &lt;p&gt;The value must be either -1 or an integer between 1 and 3,653.&lt;/p&gt; (optional)
     * @return ApiResponse&lt;EnableSnapshotCopyResult&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> IncompatibleOrderableOptions </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> InvalidClusterStateFault </td><td>  -  </td></tr>
        <tr><td> 482 </td><td> ClusterNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 483 </td><td> CopyToRegionDisabledFault </td><td>  -  </td></tr>
        <tr><td> 484 </td><td> SnapshotCopyAlreadyEnabledFault </td><td>  -  </td></tr>
        <tr><td> 485 </td><td> UnknownSnapshotCopyRegionFault </td><td>  -  </td></tr>
        <tr><td> 486 </td><td> UnauthorizedOperation </td><td>  -  </td></tr>
        <tr><td> 487 </td><td> SnapshotCopyGrantNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 488 </td><td> LimitExceededFault </td><td>  -  </td></tr>
        <tr><td> 489 </td><td> DependentServiceRequestThrottlingFault </td><td>  -  </td></tr>
        <tr><td> 490 </td><td> InvalidRetentionPeriodFault </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<EnableSnapshotCopyResult> gETEnableSnapshotCopyWithHttpInfo(String clusterIdentifier, String destinationRegion, String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, Integer retentionPeriod, String snapshotCopyGrantName, Integer manualSnapshotRetentionPeriod) throws ApiException {
        okhttp3.Call localVarCall = gETEnableSnapshotCopyValidateBeforeCall(clusterIdentifier, destinationRegion, action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, retentionPeriod, snapshotCopyGrantName, manualSnapshotRetentionPeriod, null);
        Type localVarReturnType = new TypeToken<EnableSnapshotCopyResult>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     *  (asynchronously)
     * Enables the automatic copy of snapshots from one region to another region for a specified cluster.
     * @param clusterIdentifier &lt;p&gt;The unique identifier of the source cluster to copy snapshots from.&lt;/p&gt; &lt;p&gt;Constraints: Must be the valid name of an existing cluster that does not already have cross-region snapshot copy enabled.&lt;/p&gt; (required)
     * @param destinationRegion &lt;p&gt;The destination Amazon Web Services Region that you want to copy snapshots to.&lt;/p&gt; &lt;p&gt;Constraints: Must be the name of a valid Amazon Web Services Region. For more information, see &lt;a href&#x3D;\&quot;https://docs.aws.amazon.com/general/latest/gr/rande.html#redshift_region\&quot;&gt;Regions and Endpoints&lt;/a&gt; in the Amazon Web Services General Reference. &lt;/p&gt; (required)
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param retentionPeriod &lt;p&gt;The number of days to retain automated snapshots in the destination region after they are copied from the source region.&lt;/p&gt; &lt;p&gt;Default: 7.&lt;/p&gt; &lt;p&gt;Constraints: Must be at least 1 and no more than 35.&lt;/p&gt; (optional)
     * @param snapshotCopyGrantName The name of the snapshot copy grant to use when snapshots of an Amazon Web Services KMS-encrypted cluster are copied to the destination region. (optional)
     * @param manualSnapshotRetentionPeriod &lt;p&gt;The number of days to retain newly copied snapshots in the destination Amazon Web Services Region after they are copied from the source Amazon Web Services Region. If the value is -1, the manual snapshot is retained indefinitely. &lt;/p&gt; &lt;p&gt;The value must be either -1 or an integer between 1 and 3,653.&lt;/p&gt; (optional)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> IncompatibleOrderableOptions </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> InvalidClusterStateFault </td><td>  -  </td></tr>
        <tr><td> 482 </td><td> ClusterNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 483 </td><td> CopyToRegionDisabledFault </td><td>  -  </td></tr>
        <tr><td> 484 </td><td> SnapshotCopyAlreadyEnabledFault </td><td>  -  </td></tr>
        <tr><td> 485 </td><td> UnknownSnapshotCopyRegionFault </td><td>  -  </td></tr>
        <tr><td> 486 </td><td> UnauthorizedOperation </td><td>  -  </td></tr>
        <tr><td> 487 </td><td> SnapshotCopyGrantNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 488 </td><td> LimitExceededFault </td><td>  -  </td></tr>
        <tr><td> 489 </td><td> DependentServiceRequestThrottlingFault </td><td>  -  </td></tr>
        <tr><td> 490 </td><td> InvalidRetentionPeriodFault </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call gETEnableSnapshotCopyAsync(String clusterIdentifier, String destinationRegion, String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, Integer retentionPeriod, String snapshotCopyGrantName, Integer manualSnapshotRetentionPeriod, final ApiCallback<EnableSnapshotCopyResult> _callback) throws ApiException {

        okhttp3.Call localVarCall = gETEnableSnapshotCopyValidateBeforeCall(clusterIdentifier, destinationRegion, action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, retentionPeriod, snapshotCopyGrantName, manualSnapshotRetentionPeriod, _callback);
        Type localVarReturnType = new TypeToken<EnableSnapshotCopyResult>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for gETGetClusterCredentials
     * @param dbUser &lt;p&gt;The name of a database user. If a user name matching &lt;code&gt;DbUser&lt;/code&gt; exists in the database, the temporary user credentials have the same permissions as the existing user. If &lt;code&gt;DbUser&lt;/code&gt; doesn&#39;t exist in the database and &lt;code&gt;Autocreate&lt;/code&gt; is &lt;code&gt;True&lt;/code&gt;, a new user is created using the value for &lt;code&gt;DbUser&lt;/code&gt; with PUBLIC permissions. If a database user matching the value for &lt;code&gt;DbUser&lt;/code&gt; doesn&#39;t exist and &lt;code&gt;Autocreate&lt;/code&gt; is &lt;code&gt;False&lt;/code&gt;, then the command succeeds but the connection attempt will fail because the user doesn&#39;t exist in the database.&lt;/p&gt; &lt;p&gt;For more information, see &lt;a href&#x3D;\&quot;https://docs.aws.amazon.com/redshift/latest/dg/r_CREATE_USER.html\&quot;&gt;CREATE USER&lt;/a&gt; in the Amazon Redshift Database Developer Guide. &lt;/p&gt; &lt;p&gt;Constraints:&lt;/p&gt; &lt;ul&gt; &lt;li&gt; &lt;p&gt;Must be 1 to 64 alphanumeric characters or hyphens. The user name can&#39;t be &lt;code&gt;PUBLIC&lt;/code&gt;.&lt;/p&gt; &lt;/li&gt; &lt;li&gt; &lt;p&gt;Must contain uppercase or lowercase letters, numbers, underscore, plus sign, period (dot), at symbol (@), or hyphen.&lt;/p&gt; &lt;/li&gt; &lt;li&gt; &lt;p&gt;First character must be a letter.&lt;/p&gt; &lt;/li&gt; &lt;li&gt; &lt;p&gt;Must not contain a colon ( : ) or slash ( / ). &lt;/p&gt; &lt;/li&gt; &lt;li&gt; &lt;p&gt;Cannot be a reserved word. A list of reserved words can be found in &lt;a href&#x3D;\&quot;http://docs.aws.amazon.com/redshift/latest/dg/r_pg_keywords.html\&quot;&gt;Reserved Words&lt;/a&gt; in the Amazon Redshift Database Developer Guide.&lt;/p&gt; &lt;/li&gt; &lt;/ul&gt; (required)
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param dbName &lt;p&gt;The name of a database that &lt;code&gt;DbUser&lt;/code&gt; is authorized to log on to. If &lt;code&gt;DbName&lt;/code&gt; is not specified, &lt;code&gt;DbUser&lt;/code&gt; can log on to any existing database.&lt;/p&gt; &lt;p&gt;Constraints:&lt;/p&gt; &lt;ul&gt; &lt;li&gt; &lt;p&gt;Must be 1 to 64 alphanumeric characters or hyphens&lt;/p&gt; &lt;/li&gt; &lt;li&gt; &lt;p&gt;Must contain uppercase or lowercase letters, numbers, underscore, plus sign, period (dot), at symbol (@), or hyphen.&lt;/p&gt; &lt;/li&gt; &lt;li&gt; &lt;p&gt;First character must be a letter.&lt;/p&gt; &lt;/li&gt; &lt;li&gt; &lt;p&gt;Must not contain a colon ( : ) or slash ( / ). &lt;/p&gt; &lt;/li&gt; &lt;li&gt; &lt;p&gt;Cannot be a reserved word. A list of reserved words can be found in &lt;a href&#x3D;\&quot;http://docs.aws.amazon.com/redshift/latest/dg/r_pg_keywords.html\&quot;&gt;Reserved Words&lt;/a&gt; in the Amazon Redshift Database Developer Guide.&lt;/p&gt; &lt;/li&gt; &lt;/ul&gt; (optional)
     * @param clusterIdentifier The unique identifier of the cluster that contains the database for which you are requesting credentials. This parameter is case sensitive. (optional)
     * @param durationSeconds &lt;p&gt;The number of seconds until the returned temporary password expires.&lt;/p&gt; &lt;p&gt;Constraint: minimum 900, maximum 3600.&lt;/p&gt; &lt;p&gt;Default: 900&lt;/p&gt; (optional)
     * @param autoCreate Create a database user with the name specified for the user named in &lt;code&gt;DbUser&lt;/code&gt; if one does not exist. (optional)
     * @param dbGroups &lt;p&gt;A list of the names of existing database groups that the user named in &lt;code&gt;DbUser&lt;/code&gt; will join for the current session, in addition to any group memberships for an existing user. If not specified, a new user is added only to PUBLIC.&lt;/p&gt; &lt;p&gt;Database group name constraints&lt;/p&gt; &lt;ul&gt; &lt;li&gt; &lt;p&gt;Must be 1 to 64 alphanumeric characters or hyphens&lt;/p&gt; &lt;/li&gt; &lt;li&gt; &lt;p&gt;Must contain only lowercase letters, numbers, underscore, plus sign, period (dot), at symbol (@), or hyphen.&lt;/p&gt; &lt;/li&gt; &lt;li&gt; &lt;p&gt;First character must be a letter.&lt;/p&gt; &lt;/li&gt; &lt;li&gt; &lt;p&gt;Must not contain a colon ( : ) or slash ( / ). &lt;/p&gt; &lt;/li&gt; &lt;li&gt; &lt;p&gt;Cannot be a reserved word. A list of reserved words can be found in &lt;a href&#x3D;\&quot;http://docs.aws.amazon.com/redshift/latest/dg/r_pg_keywords.html\&quot;&gt;Reserved Words&lt;/a&gt; in the Amazon Redshift Database Developer Guide.&lt;/p&gt; &lt;/li&gt; &lt;/ul&gt; (optional)
     * @param customDomainName The custom domain name for the cluster credentials. (optional)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> ClusterNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> UnsupportedOperationFault </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call gETGetClusterCredentialsCall(String dbUser, String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, String dbName, String clusterIdentifier, Integer durationSeconds, Boolean autoCreate, List<String> dbGroups, String customDomainName, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/#Action=GetClusterCredentials";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (dbUser != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("DbUser", dbUser));
        }

        if (dbName != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("DbName", dbName));
        }

        if (clusterIdentifier != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("ClusterIdentifier", clusterIdentifier));
        }

        if (durationSeconds != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("DurationSeconds", durationSeconds));
        }

        if (autoCreate != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("AutoCreate", autoCreate));
        }

        if (dbGroups != null) {
            localVarCollectionQueryParams.addAll(localVarApiClient.parameterToPairs("multi", "DbGroups", dbGroups));
        }

        if (customDomainName != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("CustomDomainName", customDomainName));
        }

        if (action != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("Action", action));
        }

        if (version != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("Version", version));
        }

        if (xAmzContentSha256 != null) {
            localVarHeaderParams.put("X-Amz-Content-Sha256", localVarApiClient.parameterToString(xAmzContentSha256));
        }

        if (xAmzDate != null) {
            localVarHeaderParams.put("X-Amz-Date", localVarApiClient.parameterToString(xAmzDate));
        }

        if (xAmzAlgorithm != null) {
            localVarHeaderParams.put("X-Amz-Algorithm", localVarApiClient.parameterToString(xAmzAlgorithm));
        }

        if (xAmzCredential != null) {
            localVarHeaderParams.put("X-Amz-Credential", localVarApiClient.parameterToString(xAmzCredential));
        }

        if (xAmzSecurityToken != null) {
            localVarHeaderParams.put("X-Amz-Security-Token", localVarApiClient.parameterToString(xAmzSecurityToken));
        }

        if (xAmzSignature != null) {
            localVarHeaderParams.put("X-Amz-Signature", localVarApiClient.parameterToString(xAmzSignature));
        }

        if (xAmzSignedHeaders != null) {
            localVarHeaderParams.put("X-Amz-SignedHeaders", localVarApiClient.parameterToString(xAmzSignedHeaders));
        }

        final String[] localVarAccepts = {
            "text/xml"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "hmac" };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call gETGetClusterCredentialsValidateBeforeCall(String dbUser, String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, String dbName, String clusterIdentifier, Integer durationSeconds, Boolean autoCreate, List<String> dbGroups, String customDomainName, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'dbUser' is set
        if (dbUser == null) {
            throw new ApiException("Missing the required parameter 'dbUser' when calling gETGetClusterCredentials(Async)");
        }

        // verify the required parameter 'action' is set
        if (action == null) {
            throw new ApiException("Missing the required parameter 'action' when calling gETGetClusterCredentials(Async)");
        }

        // verify the required parameter 'version' is set
        if (version == null) {
            throw new ApiException("Missing the required parameter 'version' when calling gETGetClusterCredentials(Async)");
        }

        return gETGetClusterCredentialsCall(dbUser, action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, dbName, clusterIdentifier, durationSeconds, autoCreate, dbGroups, customDomainName, _callback);

    }

    /**
     * 
     * &lt;p&gt;Returns a database user name and temporary password with temporary authorization to log on to an Amazon Redshift database. The action returns the database user name prefixed with &lt;code&gt;IAM:&lt;/code&gt; if &lt;code&gt;AutoCreate&lt;/code&gt; is &lt;code&gt;False&lt;/code&gt; or &lt;code&gt;IAMA:&lt;/code&gt; if &lt;code&gt;AutoCreate&lt;/code&gt; is &lt;code&gt;True&lt;/code&gt;. You can optionally specify one or more database user groups that the user will join at log on. By default, the temporary credentials expire in 900 seconds. You can optionally specify a duration between 900 seconds (15 minutes) and 3600 seconds (60 minutes). For more information, see &lt;a href&#x3D;\&quot;https://docs.aws.amazon.com/redshift/latest/mgmt/generating-user-credentials.html\&quot;&gt;Using IAM Authentication to Generate Database User Credentials&lt;/a&gt; in the Amazon Redshift Cluster Management Guide.&lt;/p&gt; &lt;p&gt;The Identity and Access Management (IAM) user or role that runs GetClusterCredentials must have an IAM policy attached that allows access to all necessary actions and resources. For more information about permissions, see &lt;a href&#x3D;\&quot;https://docs.aws.amazon.com/redshift/latest/mgmt/redshift-iam-access-control-identity-based.html#redshift-policy-resources.getclustercredentials-resources\&quot;&gt;Resource Policies for GetClusterCredentials&lt;/a&gt; in the Amazon Redshift Cluster Management Guide.&lt;/p&gt; &lt;p&gt;If the &lt;code&gt;DbGroups&lt;/code&gt; parameter is specified, the IAM policy must allow the &lt;code&gt;redshift:JoinGroup&lt;/code&gt; action with access to the listed &lt;code&gt;dbgroups&lt;/code&gt;. &lt;/p&gt; &lt;p&gt;In addition, if the &lt;code&gt;AutoCreate&lt;/code&gt; parameter is set to &lt;code&gt;True&lt;/code&gt;, then the policy must include the &lt;code&gt;redshift:CreateClusterUser&lt;/code&gt; permission.&lt;/p&gt; &lt;p&gt;If the &lt;code&gt;DbName&lt;/code&gt; parameter is specified, the IAM policy must allow access to the resource &lt;code&gt;dbname&lt;/code&gt; for the specified database name. &lt;/p&gt;
     * @param dbUser &lt;p&gt;The name of a database user. If a user name matching &lt;code&gt;DbUser&lt;/code&gt; exists in the database, the temporary user credentials have the same permissions as the existing user. If &lt;code&gt;DbUser&lt;/code&gt; doesn&#39;t exist in the database and &lt;code&gt;Autocreate&lt;/code&gt; is &lt;code&gt;True&lt;/code&gt;, a new user is created using the value for &lt;code&gt;DbUser&lt;/code&gt; with PUBLIC permissions. If a database user matching the value for &lt;code&gt;DbUser&lt;/code&gt; doesn&#39;t exist and &lt;code&gt;Autocreate&lt;/code&gt; is &lt;code&gt;False&lt;/code&gt;, then the command succeeds but the connection attempt will fail because the user doesn&#39;t exist in the database.&lt;/p&gt; &lt;p&gt;For more information, see &lt;a href&#x3D;\&quot;https://docs.aws.amazon.com/redshift/latest/dg/r_CREATE_USER.html\&quot;&gt;CREATE USER&lt;/a&gt; in the Amazon Redshift Database Developer Guide. &lt;/p&gt; &lt;p&gt;Constraints:&lt;/p&gt; &lt;ul&gt; &lt;li&gt; &lt;p&gt;Must be 1 to 64 alphanumeric characters or hyphens. The user name can&#39;t be &lt;code&gt;PUBLIC&lt;/code&gt;.&lt;/p&gt; &lt;/li&gt; &lt;li&gt; &lt;p&gt;Must contain uppercase or lowercase letters, numbers, underscore, plus sign, period (dot), at symbol (@), or hyphen.&lt;/p&gt; &lt;/li&gt; &lt;li&gt; &lt;p&gt;First character must be a letter.&lt;/p&gt; &lt;/li&gt; &lt;li&gt; &lt;p&gt;Must not contain a colon ( : ) or slash ( / ). &lt;/p&gt; &lt;/li&gt; &lt;li&gt; &lt;p&gt;Cannot be a reserved word. A list of reserved words can be found in &lt;a href&#x3D;\&quot;http://docs.aws.amazon.com/redshift/latest/dg/r_pg_keywords.html\&quot;&gt;Reserved Words&lt;/a&gt; in the Amazon Redshift Database Developer Guide.&lt;/p&gt; &lt;/li&gt; &lt;/ul&gt; (required)
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param dbName &lt;p&gt;The name of a database that &lt;code&gt;DbUser&lt;/code&gt; is authorized to log on to. If &lt;code&gt;DbName&lt;/code&gt; is not specified, &lt;code&gt;DbUser&lt;/code&gt; can log on to any existing database.&lt;/p&gt; &lt;p&gt;Constraints:&lt;/p&gt; &lt;ul&gt; &lt;li&gt; &lt;p&gt;Must be 1 to 64 alphanumeric characters or hyphens&lt;/p&gt; &lt;/li&gt; &lt;li&gt; &lt;p&gt;Must contain uppercase or lowercase letters, numbers, underscore, plus sign, period (dot), at symbol (@), or hyphen.&lt;/p&gt; &lt;/li&gt; &lt;li&gt; &lt;p&gt;First character must be a letter.&lt;/p&gt; &lt;/li&gt; &lt;li&gt; &lt;p&gt;Must not contain a colon ( : ) or slash ( / ). &lt;/p&gt; &lt;/li&gt; &lt;li&gt; &lt;p&gt;Cannot be a reserved word. A list of reserved words can be found in &lt;a href&#x3D;\&quot;http://docs.aws.amazon.com/redshift/latest/dg/r_pg_keywords.html\&quot;&gt;Reserved Words&lt;/a&gt; in the Amazon Redshift Database Developer Guide.&lt;/p&gt; &lt;/li&gt; &lt;/ul&gt; (optional)
     * @param clusterIdentifier The unique identifier of the cluster that contains the database for which you are requesting credentials. This parameter is case sensitive. (optional)
     * @param durationSeconds &lt;p&gt;The number of seconds until the returned temporary password expires.&lt;/p&gt; &lt;p&gt;Constraint: minimum 900, maximum 3600.&lt;/p&gt; &lt;p&gt;Default: 900&lt;/p&gt; (optional)
     * @param autoCreate Create a database user with the name specified for the user named in &lt;code&gt;DbUser&lt;/code&gt; if one does not exist. (optional)
     * @param dbGroups &lt;p&gt;A list of the names of existing database groups that the user named in &lt;code&gt;DbUser&lt;/code&gt; will join for the current session, in addition to any group memberships for an existing user. If not specified, a new user is added only to PUBLIC.&lt;/p&gt; &lt;p&gt;Database group name constraints&lt;/p&gt; &lt;ul&gt; &lt;li&gt; &lt;p&gt;Must be 1 to 64 alphanumeric characters or hyphens&lt;/p&gt; &lt;/li&gt; &lt;li&gt; &lt;p&gt;Must contain only lowercase letters, numbers, underscore, plus sign, period (dot), at symbol (@), or hyphen.&lt;/p&gt; &lt;/li&gt; &lt;li&gt; &lt;p&gt;First character must be a letter.&lt;/p&gt; &lt;/li&gt; &lt;li&gt; &lt;p&gt;Must not contain a colon ( : ) or slash ( / ). &lt;/p&gt; &lt;/li&gt; &lt;li&gt; &lt;p&gt;Cannot be a reserved word. A list of reserved words can be found in &lt;a href&#x3D;\&quot;http://docs.aws.amazon.com/redshift/latest/dg/r_pg_keywords.html\&quot;&gt;Reserved Words&lt;/a&gt; in the Amazon Redshift Database Developer Guide.&lt;/p&gt; &lt;/li&gt; &lt;/ul&gt; (optional)
     * @param customDomainName The custom domain name for the cluster credentials. (optional)
     * @return ClusterCredentials
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> ClusterNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> UnsupportedOperationFault </td><td>  -  </td></tr>
     </table>
     */
    public ClusterCredentials gETGetClusterCredentials(String dbUser, String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, String dbName, String clusterIdentifier, Integer durationSeconds, Boolean autoCreate, List<String> dbGroups, String customDomainName) throws ApiException {
        ApiResponse<ClusterCredentials> localVarResp = gETGetClusterCredentialsWithHttpInfo(dbUser, action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, dbName, clusterIdentifier, durationSeconds, autoCreate, dbGroups, customDomainName);
        return localVarResp.getData();
    }

    /**
     * 
     * &lt;p&gt;Returns a database user name and temporary password with temporary authorization to log on to an Amazon Redshift database. The action returns the database user name prefixed with &lt;code&gt;IAM:&lt;/code&gt; if &lt;code&gt;AutoCreate&lt;/code&gt; is &lt;code&gt;False&lt;/code&gt; or &lt;code&gt;IAMA:&lt;/code&gt; if &lt;code&gt;AutoCreate&lt;/code&gt; is &lt;code&gt;True&lt;/code&gt;. You can optionally specify one or more database user groups that the user will join at log on. By default, the temporary credentials expire in 900 seconds. You can optionally specify a duration between 900 seconds (15 minutes) and 3600 seconds (60 minutes). For more information, see &lt;a href&#x3D;\&quot;https://docs.aws.amazon.com/redshift/latest/mgmt/generating-user-credentials.html\&quot;&gt;Using IAM Authentication to Generate Database User Credentials&lt;/a&gt; in the Amazon Redshift Cluster Management Guide.&lt;/p&gt; &lt;p&gt;The Identity and Access Management (IAM) user or role that runs GetClusterCredentials must have an IAM policy attached that allows access to all necessary actions and resources. For more information about permissions, see &lt;a href&#x3D;\&quot;https://docs.aws.amazon.com/redshift/latest/mgmt/redshift-iam-access-control-identity-based.html#redshift-policy-resources.getclustercredentials-resources\&quot;&gt;Resource Policies for GetClusterCredentials&lt;/a&gt; in the Amazon Redshift Cluster Management Guide.&lt;/p&gt; &lt;p&gt;If the &lt;code&gt;DbGroups&lt;/code&gt; parameter is specified, the IAM policy must allow the &lt;code&gt;redshift:JoinGroup&lt;/code&gt; action with access to the listed &lt;code&gt;dbgroups&lt;/code&gt;. &lt;/p&gt; &lt;p&gt;In addition, if the &lt;code&gt;AutoCreate&lt;/code&gt; parameter is set to &lt;code&gt;True&lt;/code&gt;, then the policy must include the &lt;code&gt;redshift:CreateClusterUser&lt;/code&gt; permission.&lt;/p&gt; &lt;p&gt;If the &lt;code&gt;DbName&lt;/code&gt; parameter is specified, the IAM policy must allow access to the resource &lt;code&gt;dbname&lt;/code&gt; for the specified database name. &lt;/p&gt;
     * @param dbUser &lt;p&gt;The name of a database user. If a user name matching &lt;code&gt;DbUser&lt;/code&gt; exists in the database, the temporary user credentials have the same permissions as the existing user. If &lt;code&gt;DbUser&lt;/code&gt; doesn&#39;t exist in the database and &lt;code&gt;Autocreate&lt;/code&gt; is &lt;code&gt;True&lt;/code&gt;, a new user is created using the value for &lt;code&gt;DbUser&lt;/code&gt; with PUBLIC permissions. If a database user matching the value for &lt;code&gt;DbUser&lt;/code&gt; doesn&#39;t exist and &lt;code&gt;Autocreate&lt;/code&gt; is &lt;code&gt;False&lt;/code&gt;, then the command succeeds but the connection attempt will fail because the user doesn&#39;t exist in the database.&lt;/p&gt; &lt;p&gt;For more information, see &lt;a href&#x3D;\&quot;https://docs.aws.amazon.com/redshift/latest/dg/r_CREATE_USER.html\&quot;&gt;CREATE USER&lt;/a&gt; in the Amazon Redshift Database Developer Guide. &lt;/p&gt; &lt;p&gt;Constraints:&lt;/p&gt; &lt;ul&gt; &lt;li&gt; &lt;p&gt;Must be 1 to 64 alphanumeric characters or hyphens. The user name can&#39;t be &lt;code&gt;PUBLIC&lt;/code&gt;.&lt;/p&gt; &lt;/li&gt; &lt;li&gt; &lt;p&gt;Must contain uppercase or lowercase letters, numbers, underscore, plus sign, period (dot), at symbol (@), or hyphen.&lt;/p&gt; &lt;/li&gt; &lt;li&gt; &lt;p&gt;First character must be a letter.&lt;/p&gt; &lt;/li&gt; &lt;li&gt; &lt;p&gt;Must not contain a colon ( : ) or slash ( / ). &lt;/p&gt; &lt;/li&gt; &lt;li&gt; &lt;p&gt;Cannot be a reserved word. A list of reserved words can be found in &lt;a href&#x3D;\&quot;http://docs.aws.amazon.com/redshift/latest/dg/r_pg_keywords.html\&quot;&gt;Reserved Words&lt;/a&gt; in the Amazon Redshift Database Developer Guide.&lt;/p&gt; &lt;/li&gt; &lt;/ul&gt; (required)
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param dbName &lt;p&gt;The name of a database that &lt;code&gt;DbUser&lt;/code&gt; is authorized to log on to. If &lt;code&gt;DbName&lt;/code&gt; is not specified, &lt;code&gt;DbUser&lt;/code&gt; can log on to any existing database.&lt;/p&gt; &lt;p&gt;Constraints:&lt;/p&gt; &lt;ul&gt; &lt;li&gt; &lt;p&gt;Must be 1 to 64 alphanumeric characters or hyphens&lt;/p&gt; &lt;/li&gt; &lt;li&gt; &lt;p&gt;Must contain uppercase or lowercase letters, numbers, underscore, plus sign, period (dot), at symbol (@), or hyphen.&lt;/p&gt; &lt;/li&gt; &lt;li&gt; &lt;p&gt;First character must be a letter.&lt;/p&gt; &lt;/li&gt; &lt;li&gt; &lt;p&gt;Must not contain a colon ( : ) or slash ( / ). &lt;/p&gt; &lt;/li&gt; &lt;li&gt; &lt;p&gt;Cannot be a reserved word. A list of reserved words can be found in &lt;a href&#x3D;\&quot;http://docs.aws.amazon.com/redshift/latest/dg/r_pg_keywords.html\&quot;&gt;Reserved Words&lt;/a&gt; in the Amazon Redshift Database Developer Guide.&lt;/p&gt; &lt;/li&gt; &lt;/ul&gt; (optional)
     * @param clusterIdentifier The unique identifier of the cluster that contains the database for which you are requesting credentials. This parameter is case sensitive. (optional)
     * @param durationSeconds &lt;p&gt;The number of seconds until the returned temporary password expires.&lt;/p&gt; &lt;p&gt;Constraint: minimum 900, maximum 3600.&lt;/p&gt; &lt;p&gt;Default: 900&lt;/p&gt; (optional)
     * @param autoCreate Create a database user with the name specified for the user named in &lt;code&gt;DbUser&lt;/code&gt; if one does not exist. (optional)
     * @param dbGroups &lt;p&gt;A list of the names of existing database groups that the user named in &lt;code&gt;DbUser&lt;/code&gt; will join for the current session, in addition to any group memberships for an existing user. If not specified, a new user is added only to PUBLIC.&lt;/p&gt; &lt;p&gt;Database group name constraints&lt;/p&gt; &lt;ul&gt; &lt;li&gt; &lt;p&gt;Must be 1 to 64 alphanumeric characters or hyphens&lt;/p&gt; &lt;/li&gt; &lt;li&gt; &lt;p&gt;Must contain only lowercase letters, numbers, underscore, plus sign, period (dot), at symbol (@), or hyphen.&lt;/p&gt; &lt;/li&gt; &lt;li&gt; &lt;p&gt;First character must be a letter.&lt;/p&gt; &lt;/li&gt; &lt;li&gt; &lt;p&gt;Must not contain a colon ( : ) or slash ( / ). &lt;/p&gt; &lt;/li&gt; &lt;li&gt; &lt;p&gt;Cannot be a reserved word. A list of reserved words can be found in &lt;a href&#x3D;\&quot;http://docs.aws.amazon.com/redshift/latest/dg/r_pg_keywords.html\&quot;&gt;Reserved Words&lt;/a&gt; in the Amazon Redshift Database Developer Guide.&lt;/p&gt; &lt;/li&gt; &lt;/ul&gt; (optional)
     * @param customDomainName The custom domain name for the cluster credentials. (optional)
     * @return ApiResponse&lt;ClusterCredentials&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> ClusterNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> UnsupportedOperationFault </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<ClusterCredentials> gETGetClusterCredentialsWithHttpInfo(String dbUser, String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, String dbName, String clusterIdentifier, Integer durationSeconds, Boolean autoCreate, List<String> dbGroups, String customDomainName) throws ApiException {
        okhttp3.Call localVarCall = gETGetClusterCredentialsValidateBeforeCall(dbUser, action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, dbName, clusterIdentifier, durationSeconds, autoCreate, dbGroups, customDomainName, null);
        Type localVarReturnType = new TypeToken<ClusterCredentials>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     *  (asynchronously)
     * &lt;p&gt;Returns a database user name and temporary password with temporary authorization to log on to an Amazon Redshift database. The action returns the database user name prefixed with &lt;code&gt;IAM:&lt;/code&gt; if &lt;code&gt;AutoCreate&lt;/code&gt; is &lt;code&gt;False&lt;/code&gt; or &lt;code&gt;IAMA:&lt;/code&gt; if &lt;code&gt;AutoCreate&lt;/code&gt; is &lt;code&gt;True&lt;/code&gt;. You can optionally specify one or more database user groups that the user will join at log on. By default, the temporary credentials expire in 900 seconds. You can optionally specify a duration between 900 seconds (15 minutes) and 3600 seconds (60 minutes). For more information, see &lt;a href&#x3D;\&quot;https://docs.aws.amazon.com/redshift/latest/mgmt/generating-user-credentials.html\&quot;&gt;Using IAM Authentication to Generate Database User Credentials&lt;/a&gt; in the Amazon Redshift Cluster Management Guide.&lt;/p&gt; &lt;p&gt;The Identity and Access Management (IAM) user or role that runs GetClusterCredentials must have an IAM policy attached that allows access to all necessary actions and resources. For more information about permissions, see &lt;a href&#x3D;\&quot;https://docs.aws.amazon.com/redshift/latest/mgmt/redshift-iam-access-control-identity-based.html#redshift-policy-resources.getclustercredentials-resources\&quot;&gt;Resource Policies for GetClusterCredentials&lt;/a&gt; in the Amazon Redshift Cluster Management Guide.&lt;/p&gt; &lt;p&gt;If the &lt;code&gt;DbGroups&lt;/code&gt; parameter is specified, the IAM policy must allow the &lt;code&gt;redshift:JoinGroup&lt;/code&gt; action with access to the listed &lt;code&gt;dbgroups&lt;/code&gt;. &lt;/p&gt; &lt;p&gt;In addition, if the &lt;code&gt;AutoCreate&lt;/code&gt; parameter is set to &lt;code&gt;True&lt;/code&gt;, then the policy must include the &lt;code&gt;redshift:CreateClusterUser&lt;/code&gt; permission.&lt;/p&gt; &lt;p&gt;If the &lt;code&gt;DbName&lt;/code&gt; parameter is specified, the IAM policy must allow access to the resource &lt;code&gt;dbname&lt;/code&gt; for the specified database name. &lt;/p&gt;
     * @param dbUser &lt;p&gt;The name of a database user. If a user name matching &lt;code&gt;DbUser&lt;/code&gt; exists in the database, the temporary user credentials have the same permissions as the existing user. If &lt;code&gt;DbUser&lt;/code&gt; doesn&#39;t exist in the database and &lt;code&gt;Autocreate&lt;/code&gt; is &lt;code&gt;True&lt;/code&gt;, a new user is created using the value for &lt;code&gt;DbUser&lt;/code&gt; with PUBLIC permissions. If a database user matching the value for &lt;code&gt;DbUser&lt;/code&gt; doesn&#39;t exist and &lt;code&gt;Autocreate&lt;/code&gt; is &lt;code&gt;False&lt;/code&gt;, then the command succeeds but the connection attempt will fail because the user doesn&#39;t exist in the database.&lt;/p&gt; &lt;p&gt;For more information, see &lt;a href&#x3D;\&quot;https://docs.aws.amazon.com/redshift/latest/dg/r_CREATE_USER.html\&quot;&gt;CREATE USER&lt;/a&gt; in the Amazon Redshift Database Developer Guide. &lt;/p&gt; &lt;p&gt;Constraints:&lt;/p&gt; &lt;ul&gt; &lt;li&gt; &lt;p&gt;Must be 1 to 64 alphanumeric characters or hyphens. The user name can&#39;t be &lt;code&gt;PUBLIC&lt;/code&gt;.&lt;/p&gt; &lt;/li&gt; &lt;li&gt; &lt;p&gt;Must contain uppercase or lowercase letters, numbers, underscore, plus sign, period (dot), at symbol (@), or hyphen.&lt;/p&gt; &lt;/li&gt; &lt;li&gt; &lt;p&gt;First character must be a letter.&lt;/p&gt; &lt;/li&gt; &lt;li&gt; &lt;p&gt;Must not contain a colon ( : ) or slash ( / ). &lt;/p&gt; &lt;/li&gt; &lt;li&gt; &lt;p&gt;Cannot be a reserved word. A list of reserved words can be found in &lt;a href&#x3D;\&quot;http://docs.aws.amazon.com/redshift/latest/dg/r_pg_keywords.html\&quot;&gt;Reserved Words&lt;/a&gt; in the Amazon Redshift Database Developer Guide.&lt;/p&gt; &lt;/li&gt; &lt;/ul&gt; (required)
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param dbName &lt;p&gt;The name of a database that &lt;code&gt;DbUser&lt;/code&gt; is authorized to log on to. If &lt;code&gt;DbName&lt;/code&gt; is not specified, &lt;code&gt;DbUser&lt;/code&gt; can log on to any existing database.&lt;/p&gt; &lt;p&gt;Constraints:&lt;/p&gt; &lt;ul&gt; &lt;li&gt; &lt;p&gt;Must be 1 to 64 alphanumeric characters or hyphens&lt;/p&gt; &lt;/li&gt; &lt;li&gt; &lt;p&gt;Must contain uppercase or lowercase letters, numbers, underscore, plus sign, period (dot), at symbol (@), or hyphen.&lt;/p&gt; &lt;/li&gt; &lt;li&gt; &lt;p&gt;First character must be a letter.&lt;/p&gt; &lt;/li&gt; &lt;li&gt; &lt;p&gt;Must not contain a colon ( : ) or slash ( / ). &lt;/p&gt; &lt;/li&gt; &lt;li&gt; &lt;p&gt;Cannot be a reserved word. A list of reserved words can be found in &lt;a href&#x3D;\&quot;http://docs.aws.amazon.com/redshift/latest/dg/r_pg_keywords.html\&quot;&gt;Reserved Words&lt;/a&gt; in the Amazon Redshift Database Developer Guide.&lt;/p&gt; &lt;/li&gt; &lt;/ul&gt; (optional)
     * @param clusterIdentifier The unique identifier of the cluster that contains the database for which you are requesting credentials. This parameter is case sensitive. (optional)
     * @param durationSeconds &lt;p&gt;The number of seconds until the returned temporary password expires.&lt;/p&gt; &lt;p&gt;Constraint: minimum 900, maximum 3600.&lt;/p&gt; &lt;p&gt;Default: 900&lt;/p&gt; (optional)
     * @param autoCreate Create a database user with the name specified for the user named in &lt;code&gt;DbUser&lt;/code&gt; if one does not exist. (optional)
     * @param dbGroups &lt;p&gt;A list of the names of existing database groups that the user named in &lt;code&gt;DbUser&lt;/code&gt; will join for the current session, in addition to any group memberships for an existing user. If not specified, a new user is added only to PUBLIC.&lt;/p&gt; &lt;p&gt;Database group name constraints&lt;/p&gt; &lt;ul&gt; &lt;li&gt; &lt;p&gt;Must be 1 to 64 alphanumeric characters or hyphens&lt;/p&gt; &lt;/li&gt; &lt;li&gt; &lt;p&gt;Must contain only lowercase letters, numbers, underscore, plus sign, period (dot), at symbol (@), or hyphen.&lt;/p&gt; &lt;/li&gt; &lt;li&gt; &lt;p&gt;First character must be a letter.&lt;/p&gt; &lt;/li&gt; &lt;li&gt; &lt;p&gt;Must not contain a colon ( : ) or slash ( / ). &lt;/p&gt; &lt;/li&gt; &lt;li&gt; &lt;p&gt;Cannot be a reserved word. A list of reserved words can be found in &lt;a href&#x3D;\&quot;http://docs.aws.amazon.com/redshift/latest/dg/r_pg_keywords.html\&quot;&gt;Reserved Words&lt;/a&gt; in the Amazon Redshift Database Developer Guide.&lt;/p&gt; &lt;/li&gt; &lt;/ul&gt; (optional)
     * @param customDomainName The custom domain name for the cluster credentials. (optional)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> ClusterNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> UnsupportedOperationFault </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call gETGetClusterCredentialsAsync(String dbUser, String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, String dbName, String clusterIdentifier, Integer durationSeconds, Boolean autoCreate, List<String> dbGroups, String customDomainName, final ApiCallback<ClusterCredentials> _callback) throws ApiException {

        okhttp3.Call localVarCall = gETGetClusterCredentialsValidateBeforeCall(dbUser, action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, dbName, clusterIdentifier, durationSeconds, autoCreate, dbGroups, customDomainName, _callback);
        Type localVarReturnType = new TypeToken<ClusterCredentials>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for gETGetClusterCredentialsWithIAM
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param dbName The name of the database for which you are requesting credentials. If the database name is specified, the IAM policy must allow access to the resource &lt;code&gt;dbname&lt;/code&gt; for the specified database name. If the database name is not specified, access to all databases is allowed. (optional)
     * @param clusterIdentifier The unique identifier of the cluster that contains the database for which you are requesting credentials.  (optional)
     * @param durationSeconds &lt;p&gt;The number of seconds until the returned temporary password expires.&lt;/p&gt; &lt;p&gt;Range: 900-3600. Default: 900.&lt;/p&gt; (optional)
     * @param customDomainName The custom domain name for the IAM message cluster credentials. (optional)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> ClusterNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> UnsupportedOperationFault </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call gETGetClusterCredentialsWithIAMCall(String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, String dbName, String clusterIdentifier, Integer durationSeconds, String customDomainName, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/#Action=GetClusterCredentialsWithIAM";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (dbName != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("DbName", dbName));
        }

        if (clusterIdentifier != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("ClusterIdentifier", clusterIdentifier));
        }

        if (durationSeconds != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("DurationSeconds", durationSeconds));
        }

        if (customDomainName != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("CustomDomainName", customDomainName));
        }

        if (action != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("Action", action));
        }

        if (version != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("Version", version));
        }

        if (xAmzContentSha256 != null) {
            localVarHeaderParams.put("X-Amz-Content-Sha256", localVarApiClient.parameterToString(xAmzContentSha256));
        }

        if (xAmzDate != null) {
            localVarHeaderParams.put("X-Amz-Date", localVarApiClient.parameterToString(xAmzDate));
        }

        if (xAmzAlgorithm != null) {
            localVarHeaderParams.put("X-Amz-Algorithm", localVarApiClient.parameterToString(xAmzAlgorithm));
        }

        if (xAmzCredential != null) {
            localVarHeaderParams.put("X-Amz-Credential", localVarApiClient.parameterToString(xAmzCredential));
        }

        if (xAmzSecurityToken != null) {
            localVarHeaderParams.put("X-Amz-Security-Token", localVarApiClient.parameterToString(xAmzSecurityToken));
        }

        if (xAmzSignature != null) {
            localVarHeaderParams.put("X-Amz-Signature", localVarApiClient.parameterToString(xAmzSignature));
        }

        if (xAmzSignedHeaders != null) {
            localVarHeaderParams.put("X-Amz-SignedHeaders", localVarApiClient.parameterToString(xAmzSignedHeaders));
        }

        final String[] localVarAccepts = {
            "text/xml"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "hmac" };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call gETGetClusterCredentialsWithIAMValidateBeforeCall(String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, String dbName, String clusterIdentifier, Integer durationSeconds, String customDomainName, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'action' is set
        if (action == null) {
            throw new ApiException("Missing the required parameter 'action' when calling gETGetClusterCredentialsWithIAM(Async)");
        }

        // verify the required parameter 'version' is set
        if (version == null) {
            throw new ApiException("Missing the required parameter 'version' when calling gETGetClusterCredentialsWithIAM(Async)");
        }

        return gETGetClusterCredentialsWithIAMCall(action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, dbName, clusterIdentifier, durationSeconds, customDomainName, _callback);

    }

    /**
     * 
     * &lt;p&gt;Returns a database user name and temporary password with temporary authorization to log in to an Amazon Redshift database. The database user is mapped 1:1 to the source Identity and Access Management (IAM) identity. For more information about IAM identities, see &lt;a href&#x3D;\&quot;https://docs.aws.amazon.com/IAM/latest/UserGuide/id.html\&quot;&gt;IAM Identities (users, user groups, and roles)&lt;/a&gt; in the Amazon Web Services Identity and Access Management User Guide.&lt;/p&gt; &lt;p&gt;The Identity and Access Management (IAM) identity that runs this operation must have an IAM policy attached that allows access to all necessary actions and resources. For more information about permissions, see &lt;a href&#x3D;\&quot;https://docs.aws.amazon.com/redshift/latest/mgmt/redshift-iam-access-control-identity-based.html\&quot;&gt;Using identity-based policies (IAM policies)&lt;/a&gt; in the Amazon Redshift Cluster Management Guide. &lt;/p&gt;
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param dbName The name of the database for which you are requesting credentials. If the database name is specified, the IAM policy must allow access to the resource &lt;code&gt;dbname&lt;/code&gt; for the specified database name. If the database name is not specified, access to all databases is allowed. (optional)
     * @param clusterIdentifier The unique identifier of the cluster that contains the database for which you are requesting credentials.  (optional)
     * @param durationSeconds &lt;p&gt;The number of seconds until the returned temporary password expires.&lt;/p&gt; &lt;p&gt;Range: 900-3600. Default: 900.&lt;/p&gt; (optional)
     * @param customDomainName The custom domain name for the IAM message cluster credentials. (optional)
     * @return ClusterExtendedCredentials
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> ClusterNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> UnsupportedOperationFault </td><td>  -  </td></tr>
     </table>
     */
    public ClusterExtendedCredentials gETGetClusterCredentialsWithIAM(String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, String dbName, String clusterIdentifier, Integer durationSeconds, String customDomainName) throws ApiException {
        ApiResponse<ClusterExtendedCredentials> localVarResp = gETGetClusterCredentialsWithIAMWithHttpInfo(action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, dbName, clusterIdentifier, durationSeconds, customDomainName);
        return localVarResp.getData();
    }

    /**
     * 
     * &lt;p&gt;Returns a database user name and temporary password with temporary authorization to log in to an Amazon Redshift database. The database user is mapped 1:1 to the source Identity and Access Management (IAM) identity. For more information about IAM identities, see &lt;a href&#x3D;\&quot;https://docs.aws.amazon.com/IAM/latest/UserGuide/id.html\&quot;&gt;IAM Identities (users, user groups, and roles)&lt;/a&gt; in the Amazon Web Services Identity and Access Management User Guide.&lt;/p&gt; &lt;p&gt;The Identity and Access Management (IAM) identity that runs this operation must have an IAM policy attached that allows access to all necessary actions and resources. For more information about permissions, see &lt;a href&#x3D;\&quot;https://docs.aws.amazon.com/redshift/latest/mgmt/redshift-iam-access-control-identity-based.html\&quot;&gt;Using identity-based policies (IAM policies)&lt;/a&gt; in the Amazon Redshift Cluster Management Guide. &lt;/p&gt;
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param dbName The name of the database for which you are requesting credentials. If the database name is specified, the IAM policy must allow access to the resource &lt;code&gt;dbname&lt;/code&gt; for the specified database name. If the database name is not specified, access to all databases is allowed. (optional)
     * @param clusterIdentifier The unique identifier of the cluster that contains the database for which you are requesting credentials.  (optional)
     * @param durationSeconds &lt;p&gt;The number of seconds until the returned temporary password expires.&lt;/p&gt; &lt;p&gt;Range: 900-3600. Default: 900.&lt;/p&gt; (optional)
     * @param customDomainName The custom domain name for the IAM message cluster credentials. (optional)
     * @return ApiResponse&lt;ClusterExtendedCredentials&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> ClusterNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> UnsupportedOperationFault </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<ClusterExtendedCredentials> gETGetClusterCredentialsWithIAMWithHttpInfo(String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, String dbName, String clusterIdentifier, Integer durationSeconds, String customDomainName) throws ApiException {
        okhttp3.Call localVarCall = gETGetClusterCredentialsWithIAMValidateBeforeCall(action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, dbName, clusterIdentifier, durationSeconds, customDomainName, null);
        Type localVarReturnType = new TypeToken<ClusterExtendedCredentials>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     *  (asynchronously)
     * &lt;p&gt;Returns a database user name and temporary password with temporary authorization to log in to an Amazon Redshift database. The database user is mapped 1:1 to the source Identity and Access Management (IAM) identity. For more information about IAM identities, see &lt;a href&#x3D;\&quot;https://docs.aws.amazon.com/IAM/latest/UserGuide/id.html\&quot;&gt;IAM Identities (users, user groups, and roles)&lt;/a&gt; in the Amazon Web Services Identity and Access Management User Guide.&lt;/p&gt; &lt;p&gt;The Identity and Access Management (IAM) identity that runs this operation must have an IAM policy attached that allows access to all necessary actions and resources. For more information about permissions, see &lt;a href&#x3D;\&quot;https://docs.aws.amazon.com/redshift/latest/mgmt/redshift-iam-access-control-identity-based.html\&quot;&gt;Using identity-based policies (IAM policies)&lt;/a&gt; in the Amazon Redshift Cluster Management Guide. &lt;/p&gt;
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param dbName The name of the database for which you are requesting credentials. If the database name is specified, the IAM policy must allow access to the resource &lt;code&gt;dbname&lt;/code&gt; for the specified database name. If the database name is not specified, access to all databases is allowed. (optional)
     * @param clusterIdentifier The unique identifier of the cluster that contains the database for which you are requesting credentials.  (optional)
     * @param durationSeconds &lt;p&gt;The number of seconds until the returned temporary password expires.&lt;/p&gt; &lt;p&gt;Range: 900-3600. Default: 900.&lt;/p&gt; (optional)
     * @param customDomainName The custom domain name for the IAM message cluster credentials. (optional)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> ClusterNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> UnsupportedOperationFault </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call gETGetClusterCredentialsWithIAMAsync(String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, String dbName, String clusterIdentifier, Integer durationSeconds, String customDomainName, final ApiCallback<ClusterExtendedCredentials> _callback) throws ApiException {

        okhttp3.Call localVarCall = gETGetClusterCredentialsWithIAMValidateBeforeCall(action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, dbName, clusterIdentifier, durationSeconds, customDomainName, _callback);
        Type localVarReturnType = new TypeToken<ClusterExtendedCredentials>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for gETGetReservedNodeExchangeConfigurationOptions
     * @param actionType The action type of the reserved-node configuration. The action type can be an exchange initiated from either a snapshot or a resize. (required)
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param clusterIdentifier The identifier for the cluster that is the source for a reserved-node exchange. (optional)
     * @param snapshotIdentifier The identifier for the snapshot that is the source for the reserved-node exchange. (optional)
     * @param maxRecords The maximum number of response records to return in each call. If the number of remaining response records exceeds the specified &lt;code&gt;MaxRecords&lt;/code&gt; value, a value is returned in a &lt;code&gt;Marker&lt;/code&gt; field of the response. You can retrieve the next set of records by retrying the command with the returned marker value. (optional)
     * @param marker An optional pagination token provided by a previous &lt;code&gt;GetReservedNodeExchangeConfigurationOptions&lt;/code&gt; request. If this parameter is specified, the response includes only records beyond the marker, up to the value specified by the &lt;code&gt;MaxRecords&lt;/code&gt; parameter. You can retrieve the next set of response records by providing the returned marker value in the &lt;code&gt;Marker&lt;/code&gt; parameter and retrying the request. (optional)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> ReservedNodeNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> InvalidReservedNodeStateFault </td><td>  -  </td></tr>
        <tr><td> 482 </td><td> ReservedNodeAlreadyMigratedFault </td><td>  -  </td></tr>
        <tr><td> 483 </td><td> ReservedNodeOfferingNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 484 </td><td> UnsupportedOperationFault </td><td>  -  </td></tr>
        <tr><td> 485 </td><td> DependentServiceUnavailableFault </td><td>  -  </td></tr>
        <tr><td> 486 </td><td> ClusterNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 487 </td><td> ClusterSnapshotNotFoundFault </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call gETGetReservedNodeExchangeConfigurationOptionsCall(String actionType, String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, String clusterIdentifier, String snapshotIdentifier, Integer maxRecords, String marker, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/#Action=GetReservedNodeExchangeConfigurationOptions";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (actionType != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("ActionType", actionType));
        }

        if (clusterIdentifier != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("ClusterIdentifier", clusterIdentifier));
        }

        if (snapshotIdentifier != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("SnapshotIdentifier", snapshotIdentifier));
        }

        if (maxRecords != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("MaxRecords", maxRecords));
        }

        if (marker != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("Marker", marker));
        }

        if (action != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("Action", action));
        }

        if (version != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("Version", version));
        }

        if (xAmzContentSha256 != null) {
            localVarHeaderParams.put("X-Amz-Content-Sha256", localVarApiClient.parameterToString(xAmzContentSha256));
        }

        if (xAmzDate != null) {
            localVarHeaderParams.put("X-Amz-Date", localVarApiClient.parameterToString(xAmzDate));
        }

        if (xAmzAlgorithm != null) {
            localVarHeaderParams.put("X-Amz-Algorithm", localVarApiClient.parameterToString(xAmzAlgorithm));
        }

        if (xAmzCredential != null) {
            localVarHeaderParams.put("X-Amz-Credential", localVarApiClient.parameterToString(xAmzCredential));
        }

        if (xAmzSecurityToken != null) {
            localVarHeaderParams.put("X-Amz-Security-Token", localVarApiClient.parameterToString(xAmzSecurityToken));
        }

        if (xAmzSignature != null) {
            localVarHeaderParams.put("X-Amz-Signature", localVarApiClient.parameterToString(xAmzSignature));
        }

        if (xAmzSignedHeaders != null) {
            localVarHeaderParams.put("X-Amz-SignedHeaders", localVarApiClient.parameterToString(xAmzSignedHeaders));
        }

        final String[] localVarAccepts = {
            "text/xml"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "hmac" };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call gETGetReservedNodeExchangeConfigurationOptionsValidateBeforeCall(String actionType, String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, String clusterIdentifier, String snapshotIdentifier, Integer maxRecords, String marker, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'actionType' is set
        if (actionType == null) {
            throw new ApiException("Missing the required parameter 'actionType' when calling gETGetReservedNodeExchangeConfigurationOptions(Async)");
        }

        // verify the required parameter 'action' is set
        if (action == null) {
            throw new ApiException("Missing the required parameter 'action' when calling gETGetReservedNodeExchangeConfigurationOptions(Async)");
        }

        // verify the required parameter 'version' is set
        if (version == null) {
            throw new ApiException("Missing the required parameter 'version' when calling gETGetReservedNodeExchangeConfigurationOptions(Async)");
        }

        return gETGetReservedNodeExchangeConfigurationOptionsCall(actionType, action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, clusterIdentifier, snapshotIdentifier, maxRecords, marker, _callback);

    }

    /**
     * 
     * Gets the configuration options for the reserved-node exchange. These options include information about the source reserved node and target reserved node offering. Details include the node type, the price, the node count, and the offering type.
     * @param actionType The action type of the reserved-node configuration. The action type can be an exchange initiated from either a snapshot or a resize. (required)
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param clusterIdentifier The identifier for the cluster that is the source for a reserved-node exchange. (optional)
     * @param snapshotIdentifier The identifier for the snapshot that is the source for the reserved-node exchange. (optional)
     * @param maxRecords The maximum number of response records to return in each call. If the number of remaining response records exceeds the specified &lt;code&gt;MaxRecords&lt;/code&gt; value, a value is returned in a &lt;code&gt;Marker&lt;/code&gt; field of the response. You can retrieve the next set of records by retrying the command with the returned marker value. (optional)
     * @param marker An optional pagination token provided by a previous &lt;code&gt;GetReservedNodeExchangeConfigurationOptions&lt;/code&gt; request. If this parameter is specified, the response includes only records beyond the marker, up to the value specified by the &lt;code&gt;MaxRecords&lt;/code&gt; parameter. You can retrieve the next set of response records by providing the returned marker value in the &lt;code&gt;Marker&lt;/code&gt; parameter and retrying the request. (optional)
     * @return GetReservedNodeExchangeConfigurationOptionsOutputMessage
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> ReservedNodeNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> InvalidReservedNodeStateFault </td><td>  -  </td></tr>
        <tr><td> 482 </td><td> ReservedNodeAlreadyMigratedFault </td><td>  -  </td></tr>
        <tr><td> 483 </td><td> ReservedNodeOfferingNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 484 </td><td> UnsupportedOperationFault </td><td>  -  </td></tr>
        <tr><td> 485 </td><td> DependentServiceUnavailableFault </td><td>  -  </td></tr>
        <tr><td> 486 </td><td> ClusterNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 487 </td><td> ClusterSnapshotNotFoundFault </td><td>  -  </td></tr>
     </table>
     */
    public GetReservedNodeExchangeConfigurationOptionsOutputMessage gETGetReservedNodeExchangeConfigurationOptions(String actionType, String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, String clusterIdentifier, String snapshotIdentifier, Integer maxRecords, String marker) throws ApiException {
        ApiResponse<GetReservedNodeExchangeConfigurationOptionsOutputMessage> localVarResp = gETGetReservedNodeExchangeConfigurationOptionsWithHttpInfo(actionType, action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, clusterIdentifier, snapshotIdentifier, maxRecords, marker);
        return localVarResp.getData();
    }

    /**
     * 
     * Gets the configuration options for the reserved-node exchange. These options include information about the source reserved node and target reserved node offering. Details include the node type, the price, the node count, and the offering type.
     * @param actionType The action type of the reserved-node configuration. The action type can be an exchange initiated from either a snapshot or a resize. (required)
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param clusterIdentifier The identifier for the cluster that is the source for a reserved-node exchange. (optional)
     * @param snapshotIdentifier The identifier for the snapshot that is the source for the reserved-node exchange. (optional)
     * @param maxRecords The maximum number of response records to return in each call. If the number of remaining response records exceeds the specified &lt;code&gt;MaxRecords&lt;/code&gt; value, a value is returned in a &lt;code&gt;Marker&lt;/code&gt; field of the response. You can retrieve the next set of records by retrying the command with the returned marker value. (optional)
     * @param marker An optional pagination token provided by a previous &lt;code&gt;GetReservedNodeExchangeConfigurationOptions&lt;/code&gt; request. If this parameter is specified, the response includes only records beyond the marker, up to the value specified by the &lt;code&gt;MaxRecords&lt;/code&gt; parameter. You can retrieve the next set of response records by providing the returned marker value in the &lt;code&gt;Marker&lt;/code&gt; parameter and retrying the request. (optional)
     * @return ApiResponse&lt;GetReservedNodeExchangeConfigurationOptionsOutputMessage&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> ReservedNodeNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> InvalidReservedNodeStateFault </td><td>  -  </td></tr>
        <tr><td> 482 </td><td> ReservedNodeAlreadyMigratedFault </td><td>  -  </td></tr>
        <tr><td> 483 </td><td> ReservedNodeOfferingNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 484 </td><td> UnsupportedOperationFault </td><td>  -  </td></tr>
        <tr><td> 485 </td><td> DependentServiceUnavailableFault </td><td>  -  </td></tr>
        <tr><td> 486 </td><td> ClusterNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 487 </td><td> ClusterSnapshotNotFoundFault </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<GetReservedNodeExchangeConfigurationOptionsOutputMessage> gETGetReservedNodeExchangeConfigurationOptionsWithHttpInfo(String actionType, String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, String clusterIdentifier, String snapshotIdentifier, Integer maxRecords, String marker) throws ApiException {
        okhttp3.Call localVarCall = gETGetReservedNodeExchangeConfigurationOptionsValidateBeforeCall(actionType, action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, clusterIdentifier, snapshotIdentifier, maxRecords, marker, null);
        Type localVarReturnType = new TypeToken<GetReservedNodeExchangeConfigurationOptionsOutputMessage>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     *  (asynchronously)
     * Gets the configuration options for the reserved-node exchange. These options include information about the source reserved node and target reserved node offering. Details include the node type, the price, the node count, and the offering type.
     * @param actionType The action type of the reserved-node configuration. The action type can be an exchange initiated from either a snapshot or a resize. (required)
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param clusterIdentifier The identifier for the cluster that is the source for a reserved-node exchange. (optional)
     * @param snapshotIdentifier The identifier for the snapshot that is the source for the reserved-node exchange. (optional)
     * @param maxRecords The maximum number of response records to return in each call. If the number of remaining response records exceeds the specified &lt;code&gt;MaxRecords&lt;/code&gt; value, a value is returned in a &lt;code&gt;Marker&lt;/code&gt; field of the response. You can retrieve the next set of records by retrying the command with the returned marker value. (optional)
     * @param marker An optional pagination token provided by a previous &lt;code&gt;GetReservedNodeExchangeConfigurationOptions&lt;/code&gt; request. If this parameter is specified, the response includes only records beyond the marker, up to the value specified by the &lt;code&gt;MaxRecords&lt;/code&gt; parameter. You can retrieve the next set of response records by providing the returned marker value in the &lt;code&gt;Marker&lt;/code&gt; parameter and retrying the request. (optional)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> ReservedNodeNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> InvalidReservedNodeStateFault </td><td>  -  </td></tr>
        <tr><td> 482 </td><td> ReservedNodeAlreadyMigratedFault </td><td>  -  </td></tr>
        <tr><td> 483 </td><td> ReservedNodeOfferingNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 484 </td><td> UnsupportedOperationFault </td><td>  -  </td></tr>
        <tr><td> 485 </td><td> DependentServiceUnavailableFault </td><td>  -  </td></tr>
        <tr><td> 486 </td><td> ClusterNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 487 </td><td> ClusterSnapshotNotFoundFault </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call gETGetReservedNodeExchangeConfigurationOptionsAsync(String actionType, String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, String clusterIdentifier, String snapshotIdentifier, Integer maxRecords, String marker, final ApiCallback<GetReservedNodeExchangeConfigurationOptionsOutputMessage> _callback) throws ApiException {

        okhttp3.Call localVarCall = gETGetReservedNodeExchangeConfigurationOptionsValidateBeforeCall(actionType, action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, clusterIdentifier, snapshotIdentifier, maxRecords, marker, _callback);
        Type localVarReturnType = new TypeToken<GetReservedNodeExchangeConfigurationOptionsOutputMessage>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for gETGetReservedNodeExchangeOfferings
     * @param reservedNodeId A string representing the node identifier for the DC1 Reserved Node to be exchanged. (required)
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param maxRecords An integer setting the maximum number of ReservedNodeOfferings to retrieve. (optional)
     * @param marker A value that indicates the starting point for the next set of ReservedNodeOfferings. (optional)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> ReservedNodeNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> InvalidReservedNodeStateFault </td><td>  -  </td></tr>
        <tr><td> 482 </td><td> ReservedNodeAlreadyMigratedFault </td><td>  -  </td></tr>
        <tr><td> 483 </td><td> ReservedNodeOfferingNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 484 </td><td> UnsupportedOperationFault </td><td>  -  </td></tr>
        <tr><td> 485 </td><td> DependentServiceUnavailableFault </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call gETGetReservedNodeExchangeOfferingsCall(String reservedNodeId, String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, Integer maxRecords, String marker, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/#Action=GetReservedNodeExchangeOfferings";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (reservedNodeId != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("ReservedNodeId", reservedNodeId));
        }

        if (maxRecords != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("MaxRecords", maxRecords));
        }

        if (marker != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("Marker", marker));
        }

        if (action != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("Action", action));
        }

        if (version != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("Version", version));
        }

        if (xAmzContentSha256 != null) {
            localVarHeaderParams.put("X-Amz-Content-Sha256", localVarApiClient.parameterToString(xAmzContentSha256));
        }

        if (xAmzDate != null) {
            localVarHeaderParams.put("X-Amz-Date", localVarApiClient.parameterToString(xAmzDate));
        }

        if (xAmzAlgorithm != null) {
            localVarHeaderParams.put("X-Amz-Algorithm", localVarApiClient.parameterToString(xAmzAlgorithm));
        }

        if (xAmzCredential != null) {
            localVarHeaderParams.put("X-Amz-Credential", localVarApiClient.parameterToString(xAmzCredential));
        }

        if (xAmzSecurityToken != null) {
            localVarHeaderParams.put("X-Amz-Security-Token", localVarApiClient.parameterToString(xAmzSecurityToken));
        }

        if (xAmzSignature != null) {
            localVarHeaderParams.put("X-Amz-Signature", localVarApiClient.parameterToString(xAmzSignature));
        }

        if (xAmzSignedHeaders != null) {
            localVarHeaderParams.put("X-Amz-SignedHeaders", localVarApiClient.parameterToString(xAmzSignedHeaders));
        }

        final String[] localVarAccepts = {
            "text/xml"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "hmac" };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call gETGetReservedNodeExchangeOfferingsValidateBeforeCall(String reservedNodeId, String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, Integer maxRecords, String marker, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'reservedNodeId' is set
        if (reservedNodeId == null) {
            throw new ApiException("Missing the required parameter 'reservedNodeId' when calling gETGetReservedNodeExchangeOfferings(Async)");
        }

        // verify the required parameter 'action' is set
        if (action == null) {
            throw new ApiException("Missing the required parameter 'action' when calling gETGetReservedNodeExchangeOfferings(Async)");
        }

        // verify the required parameter 'version' is set
        if (version == null) {
            throw new ApiException("Missing the required parameter 'version' when calling gETGetReservedNodeExchangeOfferings(Async)");
        }

        return gETGetReservedNodeExchangeOfferingsCall(reservedNodeId, action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, maxRecords, marker, _callback);

    }

    /**
     * 
     * Returns an array of DC2 ReservedNodeOfferings that matches the payment type, term, and usage price of the given DC1 reserved node.
     * @param reservedNodeId A string representing the node identifier for the DC1 Reserved Node to be exchanged. (required)
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param maxRecords An integer setting the maximum number of ReservedNodeOfferings to retrieve. (optional)
     * @param marker A value that indicates the starting point for the next set of ReservedNodeOfferings. (optional)
     * @return GetReservedNodeExchangeOfferingsOutputMessage
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> ReservedNodeNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> InvalidReservedNodeStateFault </td><td>  -  </td></tr>
        <tr><td> 482 </td><td> ReservedNodeAlreadyMigratedFault </td><td>  -  </td></tr>
        <tr><td> 483 </td><td> ReservedNodeOfferingNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 484 </td><td> UnsupportedOperationFault </td><td>  -  </td></tr>
        <tr><td> 485 </td><td> DependentServiceUnavailableFault </td><td>  -  </td></tr>
     </table>
     */
    public GetReservedNodeExchangeOfferingsOutputMessage gETGetReservedNodeExchangeOfferings(String reservedNodeId, String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, Integer maxRecords, String marker) throws ApiException {
        ApiResponse<GetReservedNodeExchangeOfferingsOutputMessage> localVarResp = gETGetReservedNodeExchangeOfferingsWithHttpInfo(reservedNodeId, action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, maxRecords, marker);
        return localVarResp.getData();
    }

    /**
     * 
     * Returns an array of DC2 ReservedNodeOfferings that matches the payment type, term, and usage price of the given DC1 reserved node.
     * @param reservedNodeId A string representing the node identifier for the DC1 Reserved Node to be exchanged. (required)
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param maxRecords An integer setting the maximum number of ReservedNodeOfferings to retrieve. (optional)
     * @param marker A value that indicates the starting point for the next set of ReservedNodeOfferings. (optional)
     * @return ApiResponse&lt;GetReservedNodeExchangeOfferingsOutputMessage&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> ReservedNodeNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> InvalidReservedNodeStateFault </td><td>  -  </td></tr>
        <tr><td> 482 </td><td> ReservedNodeAlreadyMigratedFault </td><td>  -  </td></tr>
        <tr><td> 483 </td><td> ReservedNodeOfferingNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 484 </td><td> UnsupportedOperationFault </td><td>  -  </td></tr>
        <tr><td> 485 </td><td> DependentServiceUnavailableFault </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<GetReservedNodeExchangeOfferingsOutputMessage> gETGetReservedNodeExchangeOfferingsWithHttpInfo(String reservedNodeId, String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, Integer maxRecords, String marker) throws ApiException {
        okhttp3.Call localVarCall = gETGetReservedNodeExchangeOfferingsValidateBeforeCall(reservedNodeId, action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, maxRecords, marker, null);
        Type localVarReturnType = new TypeToken<GetReservedNodeExchangeOfferingsOutputMessage>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     *  (asynchronously)
     * Returns an array of DC2 ReservedNodeOfferings that matches the payment type, term, and usage price of the given DC1 reserved node.
     * @param reservedNodeId A string representing the node identifier for the DC1 Reserved Node to be exchanged. (required)
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param maxRecords An integer setting the maximum number of ReservedNodeOfferings to retrieve. (optional)
     * @param marker A value that indicates the starting point for the next set of ReservedNodeOfferings. (optional)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> ReservedNodeNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> InvalidReservedNodeStateFault </td><td>  -  </td></tr>
        <tr><td> 482 </td><td> ReservedNodeAlreadyMigratedFault </td><td>  -  </td></tr>
        <tr><td> 483 </td><td> ReservedNodeOfferingNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 484 </td><td> UnsupportedOperationFault </td><td>  -  </td></tr>
        <tr><td> 485 </td><td> DependentServiceUnavailableFault </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call gETGetReservedNodeExchangeOfferingsAsync(String reservedNodeId, String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, Integer maxRecords, String marker, final ApiCallback<GetReservedNodeExchangeOfferingsOutputMessage> _callback) throws ApiException {

        okhttp3.Call localVarCall = gETGetReservedNodeExchangeOfferingsValidateBeforeCall(reservedNodeId, action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, maxRecords, marker, _callback);
        Type localVarReturnType = new TypeToken<GetReservedNodeExchangeOfferingsOutputMessage>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for gETModifyAquaConfiguration
     * @param clusterIdentifier The identifier of the cluster to be modified. (required)
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param aquaConfigurationStatus This parameter is retired. Amazon Redshift automatically determines whether to use AQUA (Advanced Query Accelerator). (optional)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> ClusterNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> InvalidClusterStateFault </td><td>  -  </td></tr>
        <tr><td> 482 </td><td> UnsupportedOperationFault </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call gETModifyAquaConfigurationCall(String clusterIdentifier, String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, String aquaConfigurationStatus, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/#Action=ModifyAquaConfiguration";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (clusterIdentifier != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("ClusterIdentifier", clusterIdentifier));
        }

        if (aquaConfigurationStatus != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("AquaConfigurationStatus", aquaConfigurationStatus));
        }

        if (action != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("Action", action));
        }

        if (version != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("Version", version));
        }

        if (xAmzContentSha256 != null) {
            localVarHeaderParams.put("X-Amz-Content-Sha256", localVarApiClient.parameterToString(xAmzContentSha256));
        }

        if (xAmzDate != null) {
            localVarHeaderParams.put("X-Amz-Date", localVarApiClient.parameterToString(xAmzDate));
        }

        if (xAmzAlgorithm != null) {
            localVarHeaderParams.put("X-Amz-Algorithm", localVarApiClient.parameterToString(xAmzAlgorithm));
        }

        if (xAmzCredential != null) {
            localVarHeaderParams.put("X-Amz-Credential", localVarApiClient.parameterToString(xAmzCredential));
        }

        if (xAmzSecurityToken != null) {
            localVarHeaderParams.put("X-Amz-Security-Token", localVarApiClient.parameterToString(xAmzSecurityToken));
        }

        if (xAmzSignature != null) {
            localVarHeaderParams.put("X-Amz-Signature", localVarApiClient.parameterToString(xAmzSignature));
        }

        if (xAmzSignedHeaders != null) {
            localVarHeaderParams.put("X-Amz-SignedHeaders", localVarApiClient.parameterToString(xAmzSignedHeaders));
        }

        final String[] localVarAccepts = {
            "text/xml"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "hmac" };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call gETModifyAquaConfigurationValidateBeforeCall(String clusterIdentifier, String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, String aquaConfigurationStatus, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'clusterIdentifier' is set
        if (clusterIdentifier == null) {
            throw new ApiException("Missing the required parameter 'clusterIdentifier' when calling gETModifyAquaConfiguration(Async)");
        }

        // verify the required parameter 'action' is set
        if (action == null) {
            throw new ApiException("Missing the required parameter 'action' when calling gETModifyAquaConfiguration(Async)");
        }

        // verify the required parameter 'version' is set
        if (version == null) {
            throw new ApiException("Missing the required parameter 'version' when calling gETModifyAquaConfiguration(Async)");
        }

        return gETModifyAquaConfigurationCall(clusterIdentifier, action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, aquaConfigurationStatus, _callback);

    }

    /**
     * 
     * This operation is retired. Calling this operation does not change AQUA configuration. Amazon Redshift automatically determines whether to use AQUA (Advanced Query Accelerator). 
     * @param clusterIdentifier The identifier of the cluster to be modified. (required)
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param aquaConfigurationStatus This parameter is retired. Amazon Redshift automatically determines whether to use AQUA (Advanced Query Accelerator). (optional)
     * @return ModifyAquaOutputMessage
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> ClusterNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> InvalidClusterStateFault </td><td>  -  </td></tr>
        <tr><td> 482 </td><td> UnsupportedOperationFault </td><td>  -  </td></tr>
     </table>
     */
    public ModifyAquaOutputMessage gETModifyAquaConfiguration(String clusterIdentifier, String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, String aquaConfigurationStatus) throws ApiException {
        ApiResponse<ModifyAquaOutputMessage> localVarResp = gETModifyAquaConfigurationWithHttpInfo(clusterIdentifier, action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, aquaConfigurationStatus);
        return localVarResp.getData();
    }

    /**
     * 
     * This operation is retired. Calling this operation does not change AQUA configuration. Amazon Redshift automatically determines whether to use AQUA (Advanced Query Accelerator). 
     * @param clusterIdentifier The identifier of the cluster to be modified. (required)
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param aquaConfigurationStatus This parameter is retired. Amazon Redshift automatically determines whether to use AQUA (Advanced Query Accelerator). (optional)
     * @return ApiResponse&lt;ModifyAquaOutputMessage&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> ClusterNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> InvalidClusterStateFault </td><td>  -  </td></tr>
        <tr><td> 482 </td><td> UnsupportedOperationFault </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<ModifyAquaOutputMessage> gETModifyAquaConfigurationWithHttpInfo(String clusterIdentifier, String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, String aquaConfigurationStatus) throws ApiException {
        okhttp3.Call localVarCall = gETModifyAquaConfigurationValidateBeforeCall(clusterIdentifier, action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, aquaConfigurationStatus, null);
        Type localVarReturnType = new TypeToken<ModifyAquaOutputMessage>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     *  (asynchronously)
     * This operation is retired. Calling this operation does not change AQUA configuration. Amazon Redshift automatically determines whether to use AQUA (Advanced Query Accelerator). 
     * @param clusterIdentifier The identifier of the cluster to be modified. (required)
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param aquaConfigurationStatus This parameter is retired. Amazon Redshift automatically determines whether to use AQUA (Advanced Query Accelerator). (optional)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> ClusterNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> InvalidClusterStateFault </td><td>  -  </td></tr>
        <tr><td> 482 </td><td> UnsupportedOperationFault </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call gETModifyAquaConfigurationAsync(String clusterIdentifier, String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, String aquaConfigurationStatus, final ApiCallback<ModifyAquaOutputMessage> _callback) throws ApiException {

        okhttp3.Call localVarCall = gETModifyAquaConfigurationValidateBeforeCall(clusterIdentifier, action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, aquaConfigurationStatus, _callback);
        Type localVarReturnType = new TypeToken<ModifyAquaOutputMessage>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for gETModifyAuthenticationProfile
     * @param authenticationProfileName The name of the authentication profile to replace. (required)
     * @param authenticationProfileContent The new content of the authentication profile in JSON format. The maximum length of the JSON string is determined by a quota for your account. (required)
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> AuthenticationProfileNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> AuthenticationProfileQuotaExceededFault </td><td>  -  </td></tr>
        <tr><td> 482 </td><td> InvalidAuthenticationProfileRequestFault </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call gETModifyAuthenticationProfileCall(String authenticationProfileName, String authenticationProfileContent, String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/#Action=ModifyAuthenticationProfile";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (authenticationProfileName != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("AuthenticationProfileName", authenticationProfileName));
        }

        if (authenticationProfileContent != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("AuthenticationProfileContent", authenticationProfileContent));
        }

        if (action != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("Action", action));
        }

        if (version != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("Version", version));
        }

        if (xAmzContentSha256 != null) {
            localVarHeaderParams.put("X-Amz-Content-Sha256", localVarApiClient.parameterToString(xAmzContentSha256));
        }

        if (xAmzDate != null) {
            localVarHeaderParams.put("X-Amz-Date", localVarApiClient.parameterToString(xAmzDate));
        }

        if (xAmzAlgorithm != null) {
            localVarHeaderParams.put("X-Amz-Algorithm", localVarApiClient.parameterToString(xAmzAlgorithm));
        }

        if (xAmzCredential != null) {
            localVarHeaderParams.put("X-Amz-Credential", localVarApiClient.parameterToString(xAmzCredential));
        }

        if (xAmzSecurityToken != null) {
            localVarHeaderParams.put("X-Amz-Security-Token", localVarApiClient.parameterToString(xAmzSecurityToken));
        }

        if (xAmzSignature != null) {
            localVarHeaderParams.put("X-Amz-Signature", localVarApiClient.parameterToString(xAmzSignature));
        }

        if (xAmzSignedHeaders != null) {
            localVarHeaderParams.put("X-Amz-SignedHeaders", localVarApiClient.parameterToString(xAmzSignedHeaders));
        }

        final String[] localVarAccepts = {
            "text/xml"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "hmac" };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call gETModifyAuthenticationProfileValidateBeforeCall(String authenticationProfileName, String authenticationProfileContent, String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'authenticationProfileName' is set
        if (authenticationProfileName == null) {
            throw new ApiException("Missing the required parameter 'authenticationProfileName' when calling gETModifyAuthenticationProfile(Async)");
        }

        // verify the required parameter 'authenticationProfileContent' is set
        if (authenticationProfileContent == null) {
            throw new ApiException("Missing the required parameter 'authenticationProfileContent' when calling gETModifyAuthenticationProfile(Async)");
        }

        // verify the required parameter 'action' is set
        if (action == null) {
            throw new ApiException("Missing the required parameter 'action' when calling gETModifyAuthenticationProfile(Async)");
        }

        // verify the required parameter 'version' is set
        if (version == null) {
            throw new ApiException("Missing the required parameter 'version' when calling gETModifyAuthenticationProfile(Async)");
        }

        return gETModifyAuthenticationProfileCall(authenticationProfileName, authenticationProfileContent, action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, _callback);

    }

    /**
     * 
     * Modifies an authentication profile.
     * @param authenticationProfileName The name of the authentication profile to replace. (required)
     * @param authenticationProfileContent The new content of the authentication profile in JSON format. The maximum length of the JSON string is determined by a quota for your account. (required)
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @return ModifyAuthenticationProfileResult
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> AuthenticationProfileNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> AuthenticationProfileQuotaExceededFault </td><td>  -  </td></tr>
        <tr><td> 482 </td><td> InvalidAuthenticationProfileRequestFault </td><td>  -  </td></tr>
     </table>
     */
    public ModifyAuthenticationProfileResult gETModifyAuthenticationProfile(String authenticationProfileName, String authenticationProfileContent, String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders) throws ApiException {
        ApiResponse<ModifyAuthenticationProfileResult> localVarResp = gETModifyAuthenticationProfileWithHttpInfo(authenticationProfileName, authenticationProfileContent, action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders);
        return localVarResp.getData();
    }

    /**
     * 
     * Modifies an authentication profile.
     * @param authenticationProfileName The name of the authentication profile to replace. (required)
     * @param authenticationProfileContent The new content of the authentication profile in JSON format. The maximum length of the JSON string is determined by a quota for your account. (required)
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @return ApiResponse&lt;ModifyAuthenticationProfileResult&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> AuthenticationProfileNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> AuthenticationProfileQuotaExceededFault </td><td>  -  </td></tr>
        <tr><td> 482 </td><td> InvalidAuthenticationProfileRequestFault </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<ModifyAuthenticationProfileResult> gETModifyAuthenticationProfileWithHttpInfo(String authenticationProfileName, String authenticationProfileContent, String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders) throws ApiException {
        okhttp3.Call localVarCall = gETModifyAuthenticationProfileValidateBeforeCall(authenticationProfileName, authenticationProfileContent, action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, null);
        Type localVarReturnType = new TypeToken<ModifyAuthenticationProfileResult>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     *  (asynchronously)
     * Modifies an authentication profile.
     * @param authenticationProfileName The name of the authentication profile to replace. (required)
     * @param authenticationProfileContent The new content of the authentication profile in JSON format. The maximum length of the JSON string is determined by a quota for your account. (required)
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> AuthenticationProfileNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> AuthenticationProfileQuotaExceededFault </td><td>  -  </td></tr>
        <tr><td> 482 </td><td> InvalidAuthenticationProfileRequestFault </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call gETModifyAuthenticationProfileAsync(String authenticationProfileName, String authenticationProfileContent, String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, final ApiCallback<ModifyAuthenticationProfileResult> _callback) throws ApiException {

        okhttp3.Call localVarCall = gETModifyAuthenticationProfileValidateBeforeCall(authenticationProfileName, authenticationProfileContent, action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, _callback);
        Type localVarReturnType = new TypeToken<ModifyAuthenticationProfileResult>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for gETModifyCluster
     * @param clusterIdentifier &lt;p&gt;The unique identifier of the cluster to be modified.&lt;/p&gt; &lt;p&gt;Example: &lt;code&gt;examplecluster&lt;/code&gt; &lt;/p&gt; (required)
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param clusterType &lt;p&gt;The new cluster type.&lt;/p&gt; &lt;p&gt;When you submit your cluster resize request, your existing cluster goes into a read-only mode. After Amazon Redshift provisions a new cluster based on your resize requirements, there will be outage for a period while the old cluster is deleted and your connection is switched to the new cluster. You can use &lt;a&gt;DescribeResize&lt;/a&gt; to track the progress of the resize request. &lt;/p&gt; &lt;p&gt;Valid Values: &lt;code&gt; multi-node | single-node &lt;/code&gt; &lt;/p&gt; (optional)
     * @param nodeType &lt;p&gt;The new node type of the cluster. If you specify a new node type, you must also specify the number of nodes parameter.&lt;/p&gt; &lt;p&gt; For more information about resizing clusters, go to &lt;a href&#x3D;\&quot;https://docs.aws.amazon.com/redshift/latest/mgmt/rs-resize-tutorial.html\&quot;&gt;Resizing Clusters in Amazon Redshift&lt;/a&gt; in the &lt;i&gt;Amazon Redshift Cluster Management Guide&lt;/i&gt;.&lt;/p&gt; &lt;p&gt;Valid Values: &lt;code&gt;ds2.xlarge&lt;/code&gt; | &lt;code&gt;ds2.8xlarge&lt;/code&gt; | &lt;code&gt;dc1.large&lt;/code&gt; | &lt;code&gt;dc1.8xlarge&lt;/code&gt; | &lt;code&gt;dc2.large&lt;/code&gt; | &lt;code&gt;dc2.8xlarge&lt;/code&gt; | &lt;code&gt;ra3.xlplus&lt;/code&gt; | &lt;code&gt;ra3.4xlarge&lt;/code&gt; | &lt;code&gt;ra3.16xlarge&lt;/code&gt; &lt;/p&gt; (optional)
     * @param numberOfNodes &lt;p&gt;The new number of nodes of the cluster. If you specify a new number of nodes, you must also specify the node type parameter.&lt;/p&gt; &lt;p&gt; For more information about resizing clusters, go to &lt;a href&#x3D;\&quot;https://docs.aws.amazon.com/redshift/latest/mgmt/rs-resize-tutorial.html\&quot;&gt;Resizing Clusters in Amazon Redshift&lt;/a&gt; in the &lt;i&gt;Amazon Redshift Cluster Management Guide&lt;/i&gt;.&lt;/p&gt; &lt;p&gt;Valid Values: Integer greater than &lt;code&gt;0&lt;/code&gt;.&lt;/p&gt; (optional)
     * @param clusterSecurityGroups &lt;p&gt;A list of cluster security groups to be authorized on this cluster. This change is asynchronously applied as soon as possible.&lt;/p&gt; &lt;p&gt;Security groups currently associated with the cluster, and not in the list of groups to apply, will be revoked from the cluster.&lt;/p&gt; &lt;p&gt;Constraints:&lt;/p&gt; &lt;ul&gt; &lt;li&gt; &lt;p&gt;Must be 1 to 255 alphanumeric characters or hyphens&lt;/p&gt; &lt;/li&gt; &lt;li&gt; &lt;p&gt;First character must be a letter&lt;/p&gt; &lt;/li&gt; &lt;li&gt; &lt;p&gt;Cannot end with a hyphen or contain two consecutive hyphens&lt;/p&gt; &lt;/li&gt; &lt;/ul&gt; (optional)
     * @param vpcSecurityGroupIds A list of virtual private cloud (VPC) security groups to be associated with the cluster. This change is asynchronously applied as soon as possible. (optional)
     * @param masterUserPassword &lt;p&gt;The new password for the cluster admin user. This change is asynchronously applied as soon as possible. Between the time of the request and the completion of the request, the &lt;code&gt;MasterUserPassword&lt;/code&gt; element exists in the &lt;code&gt;PendingModifiedValues&lt;/code&gt; element of the operation response. &lt;/p&gt; &lt;note&gt; &lt;p&gt;Operations never return the password, so this operation provides a way to regain access to the admin user account for a cluster if the password is lost.&lt;/p&gt; &lt;/note&gt; &lt;p&gt;Default: Uses existing setting.&lt;/p&gt; &lt;p&gt;Constraints:&lt;/p&gt; &lt;ul&gt; &lt;li&gt; &lt;p&gt;Must be between 8 and 64 characters in length.&lt;/p&gt; &lt;/li&gt; &lt;li&gt; &lt;p&gt;Must contain at least one uppercase letter.&lt;/p&gt; &lt;/li&gt; &lt;li&gt; &lt;p&gt;Must contain at least one lowercase letter.&lt;/p&gt; &lt;/li&gt; &lt;li&gt; &lt;p&gt;Must contain one number.&lt;/p&gt; &lt;/li&gt; &lt;li&gt; &lt;p&gt;Can be any printable ASCII character (ASCII code 33-126) except &lt;code&gt;&#39;&lt;/code&gt; (single quote), &lt;code&gt;\&quot;&lt;/code&gt; (double quote), &lt;code&gt;\\&lt;/code&gt;, &lt;code&gt;/&lt;/code&gt;, or &lt;code&gt;@&lt;/code&gt;.&lt;/p&gt; &lt;/li&gt; &lt;/ul&gt; (optional)
     * @param clusterParameterGroupName &lt;p&gt;The name of the cluster parameter group to apply to this cluster. This change is applied only after the cluster is rebooted. To reboot a cluster use &lt;a&gt;RebootCluster&lt;/a&gt;. &lt;/p&gt; &lt;p&gt;Default: Uses existing setting.&lt;/p&gt; &lt;p&gt;Constraints: The cluster parameter group must be in the same parameter group family that matches the cluster version.&lt;/p&gt; (optional)
     * @param automatedSnapshotRetentionPeriod &lt;p&gt;The number of days that automated snapshots are retained. If the value is 0, automated snapshots are disabled. Even if automated snapshots are disabled, you can still create manual snapshots when you want with &lt;a&gt;CreateClusterSnapshot&lt;/a&gt;. &lt;/p&gt; &lt;p&gt;If you decrease the automated snapshot retention period from its current value, existing automated snapshots that fall outside of the new retention period will be immediately deleted.&lt;/p&gt; &lt;p&gt;You can&#39;t disable automated snapshots for RA3 node types. Set the automated retention period from 1-35 days.&lt;/p&gt; &lt;p&gt;Default: Uses existing setting.&lt;/p&gt; &lt;p&gt;Constraints: Must be a value from 0 to 35.&lt;/p&gt; (optional)
     * @param manualSnapshotRetentionPeriod &lt;p&gt;The default for number of days that a newly created manual snapshot is retained. If the value is -1, the manual snapshot is retained indefinitely. This value doesn&#39;t retroactively change the retention periods of existing manual snapshots.&lt;/p&gt; &lt;p&gt;The value must be either -1 or an integer between 1 and 3,653.&lt;/p&gt; &lt;p&gt;The default value is -1.&lt;/p&gt; (optional)
     * @param preferredMaintenanceWindow &lt;p&gt;The weekly time range (in UTC) during which system maintenance can occur, if necessary. If system maintenance is necessary during the window, it may result in an outage.&lt;/p&gt; &lt;p&gt;This maintenance window change is made immediately. If the new maintenance window indicates the current time, there must be at least 120 minutes between the current time and end of the window in order to ensure that pending changes are applied.&lt;/p&gt; &lt;p&gt;Default: Uses existing setting.&lt;/p&gt; &lt;p&gt;Format: ddd:hh24:mi-ddd:hh24:mi, for example &lt;code&gt;wed:07:30-wed:08:00&lt;/code&gt;.&lt;/p&gt; &lt;p&gt;Valid Days: Mon | Tue | Wed | Thu | Fri | Sat | Sun&lt;/p&gt; &lt;p&gt;Constraints: Must be at least 30 minutes.&lt;/p&gt; (optional)
     * @param clusterVersion &lt;p&gt;The new version number of the Amazon Redshift engine to upgrade to.&lt;/p&gt; &lt;p&gt;For major version upgrades, if a non-default cluster parameter group is currently in use, a new cluster parameter group in the cluster parameter group family for the new version must be specified. The new cluster parameter group can be the default for that cluster parameter group family. For more information about parameters and parameter groups, go to &lt;a href&#x3D;\&quot;https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-parameter-groups.html\&quot;&gt;Amazon Redshift Parameter Groups&lt;/a&gt; in the &lt;i&gt;Amazon Redshift Cluster Management Guide&lt;/i&gt;.&lt;/p&gt; &lt;p&gt;Example: &lt;code&gt;1.0&lt;/code&gt; &lt;/p&gt; (optional)
     * @param allowVersionUpgrade &lt;p&gt;If &lt;code&gt;true&lt;/code&gt;, major version upgrades will be applied automatically to the cluster during the maintenance window. &lt;/p&gt; &lt;p&gt;Default: &lt;code&gt;false&lt;/code&gt; &lt;/p&gt; (optional)
     * @param hsmClientCertificateIdentifier Specifies the name of the HSM client certificate the Amazon Redshift cluster uses to retrieve the data encryption keys stored in an HSM. (optional)
     * @param hsmConfigurationIdentifier Specifies the name of the HSM configuration that contains the information the Amazon Redshift cluster can use to retrieve and store keys in an HSM. (optional)
     * @param newClusterIdentifier &lt;p&gt;The new identifier for the cluster.&lt;/p&gt; &lt;p&gt;Constraints:&lt;/p&gt; &lt;ul&gt; &lt;li&gt; &lt;p&gt;Must contain from 1 to 63 alphanumeric characters or hyphens.&lt;/p&gt; &lt;/li&gt; &lt;li&gt; &lt;p&gt;Alphabetic characters must be lowercase.&lt;/p&gt; &lt;/li&gt; &lt;li&gt; &lt;p&gt;First character must be a letter.&lt;/p&gt; &lt;/li&gt; &lt;li&gt; &lt;p&gt;Cannot end with a hyphen or contain two consecutive hyphens.&lt;/p&gt; &lt;/li&gt; &lt;li&gt; &lt;p&gt;Must be unique for all clusters within an Amazon Web Services account.&lt;/p&gt; &lt;/li&gt; &lt;/ul&gt; &lt;p&gt;Example: &lt;code&gt;examplecluster&lt;/code&gt; &lt;/p&gt; (optional)
     * @param publiclyAccessible If &lt;code&gt;true&lt;/code&gt;, the cluster can be accessed from a public network. Only clusters in VPCs can be set to be publicly available. (optional)
     * @param elasticIp &lt;p&gt;The Elastic IP (EIP) address for the cluster.&lt;/p&gt; &lt;p&gt;Constraints: The cluster must be provisioned in EC2-VPC and publicly-accessible through an Internet gateway. For more information about provisioning clusters in EC2-VPC, go to &lt;a href&#x3D;\&quot;https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html#cluster-platforms\&quot;&gt;Supported Platforms to Launch Your Cluster&lt;/a&gt; in the Amazon Redshift Cluster Management Guide.&lt;/p&gt; (optional)
     * @param enhancedVpcRouting &lt;p&gt;An option that specifies whether to create the cluster with enhanced VPC routing enabled. To create a cluster that uses enhanced VPC routing, the cluster must be in a VPC. For more information, see &lt;a href&#x3D;\&quot;https://docs.aws.amazon.com/redshift/latest/mgmt/enhanced-vpc-routing.html\&quot;&gt;Enhanced VPC Routing&lt;/a&gt; in the Amazon Redshift Cluster Management Guide.&lt;/p&gt; &lt;p&gt;If this option is &lt;code&gt;true&lt;/code&gt;, enhanced VPC routing is enabled. &lt;/p&gt; &lt;p&gt;Default: false&lt;/p&gt; (optional)
     * @param maintenanceTrackName The name for the maintenance track that you want to assign for the cluster. This name change is asynchronous. The new track name stays in the &lt;code&gt;PendingModifiedValues&lt;/code&gt; for the cluster until the next maintenance window. When the maintenance track changes, the cluster is switched to the latest cluster release available for the maintenance track. At this point, the maintenance track name is applied. (optional)
     * @param encrypted &lt;p&gt;Indicates whether the cluster is encrypted. If the value is encrypted (true) and you provide a value for the &lt;code&gt;KmsKeyId&lt;/code&gt; parameter, we encrypt the cluster with the provided &lt;code&gt;KmsKeyId&lt;/code&gt;. If you don&#39;t provide a &lt;code&gt;KmsKeyId&lt;/code&gt;, we encrypt with the default key. &lt;/p&gt; &lt;p&gt;If the value is not encrypted (false), then the cluster is decrypted. &lt;/p&gt; (optional)
     * @param kmsKeyId The Key Management Service (KMS) key ID of the encryption key that you want to use to encrypt data in the cluster. (optional)
     * @param availabilityZoneRelocation The option to enable relocation for an Amazon Redshift cluster between Availability Zones after the cluster modification is complete. (optional)
     * @param availabilityZone The option to initiate relocation for an Amazon Redshift cluster to the target Availability Zone. (optional)
     * @param port The option to change the port of an Amazon Redshift cluster. (optional)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> InvalidClusterStateFault </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> InvalidClusterSecurityGroupStateFault </td><td>  -  </td></tr>
        <tr><td> 482 </td><td> ClusterNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 483 </td><td> NumberOfNodesQuotaExceededFault </td><td>  -  </td></tr>
        <tr><td> 484 </td><td> NumberOfNodesPerClusterLimitExceededFault </td><td>  -  </td></tr>
        <tr><td> 485 </td><td> ClusterSecurityGroupNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 486 </td><td> ClusterParameterGroupNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 487 </td><td> InsufficientClusterCapacityFault </td><td>  -  </td></tr>
        <tr><td> 488 </td><td> UnsupportedOptionFault </td><td>  -  </td></tr>
        <tr><td> 489 </td><td> UnauthorizedOperation </td><td>  -  </td></tr>
        <tr><td> 490 </td><td> HsmClientCertificateNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 491 </td><td> HsmConfigurationNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 492 </td><td> ClusterAlreadyExistsFault </td><td>  -  </td></tr>
        <tr><td> 493 </td><td> LimitExceededFault </td><td>  -  </td></tr>
        <tr><td> 494 </td><td> DependentServiceRequestThrottlingFault </td><td>  -  </td></tr>
        <tr><td> 495 </td><td> InvalidElasticIpFault </td><td>  -  </td></tr>
        <tr><td> 496 </td><td> TableLimitExceededFault </td><td>  -  </td></tr>
        <tr><td> 497 </td><td> InvalidClusterTrackFault </td><td>  -  </td></tr>
        <tr><td> 498 </td><td> InvalidRetentionPeriodFault </td><td>  -  </td></tr>
        <tr><td> 499 </td><td> UnsupportedOperationFault </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> CustomCnameAssociationFault </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call gETModifyClusterCall(String clusterIdentifier, String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, String clusterType, String nodeType, Integer numberOfNodes, List<String> clusterSecurityGroups, List<String> vpcSecurityGroupIds, String masterUserPassword, String clusterParameterGroupName, Integer automatedSnapshotRetentionPeriod, Integer manualSnapshotRetentionPeriod, String preferredMaintenanceWindow, String clusterVersion, Boolean allowVersionUpgrade, String hsmClientCertificateIdentifier, String hsmConfigurationIdentifier, String newClusterIdentifier, Boolean publiclyAccessible, String elasticIp, Boolean enhancedVpcRouting, String maintenanceTrackName, Boolean encrypted, String kmsKeyId, Boolean availabilityZoneRelocation, String availabilityZone, Integer port, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/#Action=ModifyCluster";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (clusterIdentifier != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("ClusterIdentifier", clusterIdentifier));
        }

        if (clusterType != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("ClusterType", clusterType));
        }

        if (nodeType != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("NodeType", nodeType));
        }

        if (numberOfNodes != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("NumberOfNodes", numberOfNodes));
        }

        if (clusterSecurityGroups != null) {
            localVarCollectionQueryParams.addAll(localVarApiClient.parameterToPairs("multi", "ClusterSecurityGroups", clusterSecurityGroups));
        }

        if (vpcSecurityGroupIds != null) {
            localVarCollectionQueryParams.addAll(localVarApiClient.parameterToPairs("multi", "VpcSecurityGroupIds", vpcSecurityGroupIds));
        }

        if (masterUserPassword != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("MasterUserPassword", masterUserPassword));
        }

        if (clusterParameterGroupName != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("ClusterParameterGroupName", clusterParameterGroupName));
        }

        if (automatedSnapshotRetentionPeriod != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("AutomatedSnapshotRetentionPeriod", automatedSnapshotRetentionPeriod));
        }

        if (manualSnapshotRetentionPeriod != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("ManualSnapshotRetentionPeriod", manualSnapshotRetentionPeriod));
        }

        if (preferredMaintenanceWindow != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("PreferredMaintenanceWindow", preferredMaintenanceWindow));
        }

        if (clusterVersion != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("ClusterVersion", clusterVersion));
        }

        if (allowVersionUpgrade != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("AllowVersionUpgrade", allowVersionUpgrade));
        }

        if (hsmClientCertificateIdentifier != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("HsmClientCertificateIdentifier", hsmClientCertificateIdentifier));
        }

        if (hsmConfigurationIdentifier != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("HsmConfigurationIdentifier", hsmConfigurationIdentifier));
        }

        if (newClusterIdentifier != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("NewClusterIdentifier", newClusterIdentifier));
        }

        if (publiclyAccessible != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("PubliclyAccessible", publiclyAccessible));
        }

        if (elasticIp != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("ElasticIp", elasticIp));
        }

        if (enhancedVpcRouting != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("EnhancedVpcRouting", enhancedVpcRouting));
        }

        if (maintenanceTrackName != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("MaintenanceTrackName", maintenanceTrackName));
        }

        if (encrypted != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("Encrypted", encrypted));
        }

        if (kmsKeyId != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("KmsKeyId", kmsKeyId));
        }

        if (availabilityZoneRelocation != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("AvailabilityZoneRelocation", availabilityZoneRelocation));
        }

        if (availabilityZone != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("AvailabilityZone", availabilityZone));
        }

        if (port != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("Port", port));
        }

        if (action != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("Action", action));
        }

        if (version != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("Version", version));
        }

        if (xAmzContentSha256 != null) {
            localVarHeaderParams.put("X-Amz-Content-Sha256", localVarApiClient.parameterToString(xAmzContentSha256));
        }

        if (xAmzDate != null) {
            localVarHeaderParams.put("X-Amz-Date", localVarApiClient.parameterToString(xAmzDate));
        }

        if (xAmzAlgorithm != null) {
            localVarHeaderParams.put("X-Amz-Algorithm", localVarApiClient.parameterToString(xAmzAlgorithm));
        }

        if (xAmzCredential != null) {
            localVarHeaderParams.put("X-Amz-Credential", localVarApiClient.parameterToString(xAmzCredential));
        }

        if (xAmzSecurityToken != null) {
            localVarHeaderParams.put("X-Amz-Security-Token", localVarApiClient.parameterToString(xAmzSecurityToken));
        }

        if (xAmzSignature != null) {
            localVarHeaderParams.put("X-Amz-Signature", localVarApiClient.parameterToString(xAmzSignature));
        }

        if (xAmzSignedHeaders != null) {
            localVarHeaderParams.put("X-Amz-SignedHeaders", localVarApiClient.parameterToString(xAmzSignedHeaders));
        }

        final String[] localVarAccepts = {
            "text/xml"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "hmac" };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call gETModifyClusterValidateBeforeCall(String clusterIdentifier, String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, String clusterType, String nodeType, Integer numberOfNodes, List<String> clusterSecurityGroups, List<String> vpcSecurityGroupIds, String masterUserPassword, String clusterParameterGroupName, Integer automatedSnapshotRetentionPeriod, Integer manualSnapshotRetentionPeriod, String preferredMaintenanceWindow, String clusterVersion, Boolean allowVersionUpgrade, String hsmClientCertificateIdentifier, String hsmConfigurationIdentifier, String newClusterIdentifier, Boolean publiclyAccessible, String elasticIp, Boolean enhancedVpcRouting, String maintenanceTrackName, Boolean encrypted, String kmsKeyId, Boolean availabilityZoneRelocation, String availabilityZone, Integer port, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'clusterIdentifier' is set
        if (clusterIdentifier == null) {
            throw new ApiException("Missing the required parameter 'clusterIdentifier' when calling gETModifyCluster(Async)");
        }

        // verify the required parameter 'action' is set
        if (action == null) {
            throw new ApiException("Missing the required parameter 'action' when calling gETModifyCluster(Async)");
        }

        // verify the required parameter 'version' is set
        if (version == null) {
            throw new ApiException("Missing the required parameter 'version' when calling gETModifyCluster(Async)");
        }

        return gETModifyClusterCall(clusterIdentifier, action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, clusterType, nodeType, numberOfNodes, clusterSecurityGroups, vpcSecurityGroupIds, masterUserPassword, clusterParameterGroupName, automatedSnapshotRetentionPeriod, manualSnapshotRetentionPeriod, preferredMaintenanceWindow, clusterVersion, allowVersionUpgrade, hsmClientCertificateIdentifier, hsmConfigurationIdentifier, newClusterIdentifier, publiclyAccessible, elasticIp, enhancedVpcRouting, maintenanceTrackName, encrypted, kmsKeyId, availabilityZoneRelocation, availabilityZone, port, _callback);

    }

    /**
     * 
     * &lt;p&gt;Modifies the settings for a cluster.&lt;/p&gt; &lt;p&gt;You can also change node type and the number of nodes to scale up or down the cluster. When resizing a cluster, you must specify both the number of nodes and the node type even if one of the parameters does not change.&lt;/p&gt; &lt;p&gt;You can add another security or parameter group, or change the admin user password. Resetting a cluster password or modifying the security groups associated with a cluster do not need a reboot. However, modifying a parameter group requires a reboot for parameters to take effect. For more information about managing clusters, go to &lt;a href&#x3D;\&quot;https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html\&quot;&gt;Amazon Redshift Clusters&lt;/a&gt; in the &lt;i&gt;Amazon Redshift Cluster Management Guide&lt;/i&gt;.&lt;/p&gt;
     * @param clusterIdentifier &lt;p&gt;The unique identifier of the cluster to be modified.&lt;/p&gt; &lt;p&gt;Example: &lt;code&gt;examplecluster&lt;/code&gt; &lt;/p&gt; (required)
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param clusterType &lt;p&gt;The new cluster type.&lt;/p&gt; &lt;p&gt;When you submit your cluster resize request, your existing cluster goes into a read-only mode. After Amazon Redshift provisions a new cluster based on your resize requirements, there will be outage for a period while the old cluster is deleted and your connection is switched to the new cluster. You can use &lt;a&gt;DescribeResize&lt;/a&gt; to track the progress of the resize request. &lt;/p&gt; &lt;p&gt;Valid Values: &lt;code&gt; multi-node | single-node &lt;/code&gt; &lt;/p&gt; (optional)
     * @param nodeType &lt;p&gt;The new node type of the cluster. If you specify a new node type, you must also specify the number of nodes parameter.&lt;/p&gt; &lt;p&gt; For more information about resizing clusters, go to &lt;a href&#x3D;\&quot;https://docs.aws.amazon.com/redshift/latest/mgmt/rs-resize-tutorial.html\&quot;&gt;Resizing Clusters in Amazon Redshift&lt;/a&gt; in the &lt;i&gt;Amazon Redshift Cluster Management Guide&lt;/i&gt;.&lt;/p&gt; &lt;p&gt;Valid Values: &lt;code&gt;ds2.xlarge&lt;/code&gt; | &lt;code&gt;ds2.8xlarge&lt;/code&gt; | &lt;code&gt;dc1.large&lt;/code&gt; | &lt;code&gt;dc1.8xlarge&lt;/code&gt; | &lt;code&gt;dc2.large&lt;/code&gt; | &lt;code&gt;dc2.8xlarge&lt;/code&gt; | &lt;code&gt;ra3.xlplus&lt;/code&gt; | &lt;code&gt;ra3.4xlarge&lt;/code&gt; | &lt;code&gt;ra3.16xlarge&lt;/code&gt; &lt;/p&gt; (optional)
     * @param numberOfNodes &lt;p&gt;The new number of nodes of the cluster. If you specify a new number of nodes, you must also specify the node type parameter.&lt;/p&gt; &lt;p&gt; For more information about resizing clusters, go to &lt;a href&#x3D;\&quot;https://docs.aws.amazon.com/redshift/latest/mgmt/rs-resize-tutorial.html\&quot;&gt;Resizing Clusters in Amazon Redshift&lt;/a&gt; in the &lt;i&gt;Amazon Redshift Cluster Management Guide&lt;/i&gt;.&lt;/p&gt; &lt;p&gt;Valid Values: Integer greater than &lt;code&gt;0&lt;/code&gt;.&lt;/p&gt; (optional)
     * @param clusterSecurityGroups &lt;p&gt;A list of cluster security groups to be authorized on this cluster. This change is asynchronously applied as soon as possible.&lt;/p&gt; &lt;p&gt;Security groups currently associated with the cluster, and not in the list of groups to apply, will be revoked from the cluster.&lt;/p&gt; &lt;p&gt;Constraints:&lt;/p&gt; &lt;ul&gt; &lt;li&gt; &lt;p&gt;Must be 1 to 255 alphanumeric characters or hyphens&lt;/p&gt; &lt;/li&gt; &lt;li&gt; &lt;p&gt;First character must be a letter&lt;/p&gt; &lt;/li&gt; &lt;li&gt; &lt;p&gt;Cannot end with a hyphen or contain two consecutive hyphens&lt;/p&gt; &lt;/li&gt; &lt;/ul&gt; (optional)
     * @param vpcSecurityGroupIds A list of virtual private cloud (VPC) security groups to be associated with the cluster. This change is asynchronously applied as soon as possible. (optional)
     * @param masterUserPassword &lt;p&gt;The new password for the cluster admin user. This change is asynchronously applied as soon as possible. Between the time of the request and the completion of the request, the &lt;code&gt;MasterUserPassword&lt;/code&gt; element exists in the &lt;code&gt;PendingModifiedValues&lt;/code&gt; element of the operation response. &lt;/p&gt; &lt;note&gt; &lt;p&gt;Operations never return the password, so this operation provides a way to regain access to the admin user account for a cluster if the password is lost.&lt;/p&gt; &lt;/note&gt; &lt;p&gt;Default: Uses existing setting.&lt;/p&gt; &lt;p&gt;Constraints:&lt;/p&gt; &lt;ul&gt; &lt;li&gt; &lt;p&gt;Must be between 8 and 64 characters in length.&lt;/p&gt; &lt;/li&gt; &lt;li&gt; &lt;p&gt;Must contain at least one uppercase letter.&lt;/p&gt; &lt;/li&gt; &lt;li&gt; &lt;p&gt;Must contain at least one lowercase letter.&lt;/p&gt; &lt;/li&gt; &lt;li&gt; &lt;p&gt;Must contain one number.&lt;/p&gt; &lt;/li&gt; &lt;li&gt; &lt;p&gt;Can be any printable ASCII character (ASCII code 33-126) except &lt;code&gt;&#39;&lt;/code&gt; (single quote), &lt;code&gt;\&quot;&lt;/code&gt; (double quote), &lt;code&gt;\\&lt;/code&gt;, &lt;code&gt;/&lt;/code&gt;, or &lt;code&gt;@&lt;/code&gt;.&lt;/p&gt; &lt;/li&gt; &lt;/ul&gt; (optional)
     * @param clusterParameterGroupName &lt;p&gt;The name of the cluster parameter group to apply to this cluster. This change is applied only after the cluster is rebooted. To reboot a cluster use &lt;a&gt;RebootCluster&lt;/a&gt;. &lt;/p&gt; &lt;p&gt;Default: Uses existing setting.&lt;/p&gt; &lt;p&gt;Constraints: The cluster parameter group must be in the same parameter group family that matches the cluster version.&lt;/p&gt; (optional)
     * @param automatedSnapshotRetentionPeriod &lt;p&gt;The number of days that automated snapshots are retained. If the value is 0, automated snapshots are disabled. Even if automated snapshots are disabled, you can still create manual snapshots when you want with &lt;a&gt;CreateClusterSnapshot&lt;/a&gt;. &lt;/p&gt; &lt;p&gt;If you decrease the automated snapshot retention period from its current value, existing automated snapshots that fall outside of the new retention period will be immediately deleted.&lt;/p&gt; &lt;p&gt;You can&#39;t disable automated snapshots for RA3 node types. Set the automated retention period from 1-35 days.&lt;/p&gt; &lt;p&gt;Default: Uses existing setting.&lt;/p&gt; &lt;p&gt;Constraints: Must be a value from 0 to 35.&lt;/p&gt; (optional)
     * @param manualSnapshotRetentionPeriod &lt;p&gt;The default for number of days that a newly created manual snapshot is retained. If the value is -1, the manual snapshot is retained indefinitely. This value doesn&#39;t retroactively change the retention periods of existing manual snapshots.&lt;/p&gt; &lt;p&gt;The value must be either -1 or an integer between 1 and 3,653.&lt;/p&gt; &lt;p&gt;The default value is -1.&lt;/p&gt; (optional)
     * @param preferredMaintenanceWindow &lt;p&gt;The weekly time range (in UTC) during which system maintenance can occur, if necessary. If system maintenance is necessary during the window, it may result in an outage.&lt;/p&gt; &lt;p&gt;This maintenance window change is made immediately. If the new maintenance window indicates the current time, there must be at least 120 minutes between the current time and end of the window in order to ensure that pending changes are applied.&lt;/p&gt; &lt;p&gt;Default: Uses existing setting.&lt;/p&gt; &lt;p&gt;Format: ddd:hh24:mi-ddd:hh24:mi, for example &lt;code&gt;wed:07:30-wed:08:00&lt;/code&gt;.&lt;/p&gt; &lt;p&gt;Valid Days: Mon | Tue | Wed | Thu | Fri | Sat | Sun&lt;/p&gt; &lt;p&gt;Constraints: Must be at least 30 minutes.&lt;/p&gt; (optional)
     * @param clusterVersion &lt;p&gt;The new version number of the Amazon Redshift engine to upgrade to.&lt;/p&gt; &lt;p&gt;For major version upgrades, if a non-default cluster parameter group is currently in use, a new cluster parameter group in the cluster parameter group family for the new version must be specified. The new cluster parameter group can be the default for that cluster parameter group family. For more information about parameters and parameter groups, go to &lt;a href&#x3D;\&quot;https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-parameter-groups.html\&quot;&gt;Amazon Redshift Parameter Groups&lt;/a&gt; in the &lt;i&gt;Amazon Redshift Cluster Management Guide&lt;/i&gt;.&lt;/p&gt; &lt;p&gt;Example: &lt;code&gt;1.0&lt;/code&gt; &lt;/p&gt; (optional)
     * @param allowVersionUpgrade &lt;p&gt;If &lt;code&gt;true&lt;/code&gt;, major version upgrades will be applied automatically to the cluster during the maintenance window. &lt;/p&gt; &lt;p&gt;Default: &lt;code&gt;false&lt;/code&gt; &lt;/p&gt; (optional)
     * @param hsmClientCertificateIdentifier Specifies the name of the HSM client certificate the Amazon Redshift cluster uses to retrieve the data encryption keys stored in an HSM. (optional)
     * @param hsmConfigurationIdentifier Specifies the name of the HSM configuration that contains the information the Amazon Redshift cluster can use to retrieve and store keys in an HSM. (optional)
     * @param newClusterIdentifier &lt;p&gt;The new identifier for the cluster.&lt;/p&gt; &lt;p&gt;Constraints:&lt;/p&gt; &lt;ul&gt; &lt;li&gt; &lt;p&gt;Must contain from 1 to 63 alphanumeric characters or hyphens.&lt;/p&gt; &lt;/li&gt; &lt;li&gt; &lt;p&gt;Alphabetic characters must be lowercase.&lt;/p&gt; &lt;/li&gt; &lt;li&gt; &lt;p&gt;First character must be a letter.&lt;/p&gt; &lt;/li&gt; &lt;li&gt; &lt;p&gt;Cannot end with a hyphen or contain two consecutive hyphens.&lt;/p&gt; &lt;/li&gt; &lt;li&gt; &lt;p&gt;Must be unique for all clusters within an Amazon Web Services account.&lt;/p&gt; &lt;/li&gt; &lt;/ul&gt; &lt;p&gt;Example: &lt;code&gt;examplecluster&lt;/code&gt; &lt;/p&gt; (optional)
     * @param publiclyAccessible If &lt;code&gt;true&lt;/code&gt;, the cluster can be accessed from a public network. Only clusters in VPCs can be set to be publicly available. (optional)
     * @param elasticIp &lt;p&gt;The Elastic IP (EIP) address for the cluster.&lt;/p&gt; &lt;p&gt;Constraints: The cluster must be provisioned in EC2-VPC and publicly-accessible through an Internet gateway. For more information about provisioning clusters in EC2-VPC, go to &lt;a href&#x3D;\&quot;https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html#cluster-platforms\&quot;&gt;Supported Platforms to Launch Your Cluster&lt;/a&gt; in the Amazon Redshift Cluster Management Guide.&lt;/p&gt; (optional)
     * @param enhancedVpcRouting &lt;p&gt;An option that specifies whether to create the cluster with enhanced VPC routing enabled. To create a cluster that uses enhanced VPC routing, the cluster must be in a VPC. For more information, see &lt;a href&#x3D;\&quot;https://docs.aws.amazon.com/redshift/latest/mgmt/enhanced-vpc-routing.html\&quot;&gt;Enhanced VPC Routing&lt;/a&gt; in the Amazon Redshift Cluster Management Guide.&lt;/p&gt; &lt;p&gt;If this option is &lt;code&gt;true&lt;/code&gt;, enhanced VPC routing is enabled. &lt;/p&gt; &lt;p&gt;Default: false&lt;/p&gt; (optional)
     * @param maintenanceTrackName The name for the maintenance track that you want to assign for the cluster. This name change is asynchronous. The new track name stays in the &lt;code&gt;PendingModifiedValues&lt;/code&gt; for the cluster until the next maintenance window. When the maintenance track changes, the cluster is switched to the latest cluster release available for the maintenance track. At this point, the maintenance track name is applied. (optional)
     * @param encrypted &lt;p&gt;Indicates whether the cluster is encrypted. If the value is encrypted (true) and you provide a value for the &lt;code&gt;KmsKeyId&lt;/code&gt; parameter, we encrypt the cluster with the provided &lt;code&gt;KmsKeyId&lt;/code&gt;. If you don&#39;t provide a &lt;code&gt;KmsKeyId&lt;/code&gt;, we encrypt with the default key. &lt;/p&gt; &lt;p&gt;If the value is not encrypted (false), then the cluster is decrypted. &lt;/p&gt; (optional)
     * @param kmsKeyId The Key Management Service (KMS) key ID of the encryption key that you want to use to encrypt data in the cluster. (optional)
     * @param availabilityZoneRelocation The option to enable relocation for an Amazon Redshift cluster between Availability Zones after the cluster modification is complete. (optional)
     * @param availabilityZone The option to initiate relocation for an Amazon Redshift cluster to the target Availability Zone. (optional)
     * @param port The option to change the port of an Amazon Redshift cluster. (optional)
     * @return ModifyClusterResult
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> InvalidClusterStateFault </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> InvalidClusterSecurityGroupStateFault </td><td>  -  </td></tr>
        <tr><td> 482 </td><td> ClusterNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 483 </td><td> NumberOfNodesQuotaExceededFault </td><td>  -  </td></tr>
        <tr><td> 484 </td><td> NumberOfNodesPerClusterLimitExceededFault </td><td>  -  </td></tr>
        <tr><td> 485 </td><td> ClusterSecurityGroupNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 486 </td><td> ClusterParameterGroupNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 487 </td><td> InsufficientClusterCapacityFault </td><td>  -  </td></tr>
        <tr><td> 488 </td><td> UnsupportedOptionFault </td><td>  -  </td></tr>
        <tr><td> 489 </td><td> UnauthorizedOperation </td><td>  -  </td></tr>
        <tr><td> 490 </td><td> HsmClientCertificateNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 491 </td><td> HsmConfigurationNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 492 </td><td> ClusterAlreadyExistsFault </td><td>  -  </td></tr>
        <tr><td> 493 </td><td> LimitExceededFault </td><td>  -  </td></tr>
        <tr><td> 494 </td><td> DependentServiceRequestThrottlingFault </td><td>  -  </td></tr>
        <tr><td> 495 </td><td> InvalidElasticIpFault </td><td>  -  </td></tr>
        <tr><td> 496 </td><td> TableLimitExceededFault </td><td>  -  </td></tr>
        <tr><td> 497 </td><td> InvalidClusterTrackFault </td><td>  -  </td></tr>
        <tr><td> 498 </td><td> InvalidRetentionPeriodFault </td><td>  -  </td></tr>
        <tr><td> 499 </td><td> UnsupportedOperationFault </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> CustomCnameAssociationFault </td><td>  -  </td></tr>
     </table>
     */
    public ModifyClusterResult gETModifyCluster(String clusterIdentifier, String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, String clusterType, String nodeType, Integer numberOfNodes, List<String> clusterSecurityGroups, List<String> vpcSecurityGroupIds, String masterUserPassword, String clusterParameterGroupName, Integer automatedSnapshotRetentionPeriod, Integer manualSnapshotRetentionPeriod, String preferredMaintenanceWindow, String clusterVersion, Boolean allowVersionUpgrade, String hsmClientCertificateIdentifier, String hsmConfigurationIdentifier, String newClusterIdentifier, Boolean publiclyAccessible, String elasticIp, Boolean enhancedVpcRouting, String maintenanceTrackName, Boolean encrypted, String kmsKeyId, Boolean availabilityZoneRelocation, String availabilityZone, Integer port) throws ApiException {
        ApiResponse<ModifyClusterResult> localVarResp = gETModifyClusterWithHttpInfo(clusterIdentifier, action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, clusterType, nodeType, numberOfNodes, clusterSecurityGroups, vpcSecurityGroupIds, masterUserPassword, clusterParameterGroupName, automatedSnapshotRetentionPeriod, manualSnapshotRetentionPeriod, preferredMaintenanceWindow, clusterVersion, allowVersionUpgrade, hsmClientCertificateIdentifier, hsmConfigurationIdentifier, newClusterIdentifier, publiclyAccessible, elasticIp, enhancedVpcRouting, maintenanceTrackName, encrypted, kmsKeyId, availabilityZoneRelocation, availabilityZone, port);
        return localVarResp.getData();
    }

    /**
     * 
     * &lt;p&gt;Modifies the settings for a cluster.&lt;/p&gt; &lt;p&gt;You can also change node type and the number of nodes to scale up or down the cluster. When resizing a cluster, you must specify both the number of nodes and the node type even if one of the parameters does not change.&lt;/p&gt; &lt;p&gt;You can add another security or parameter group, or change the admin user password. Resetting a cluster password or modifying the security groups associated with a cluster do not need a reboot. However, modifying a parameter group requires a reboot for parameters to take effect. For more information about managing clusters, go to &lt;a href&#x3D;\&quot;https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html\&quot;&gt;Amazon Redshift Clusters&lt;/a&gt; in the &lt;i&gt;Amazon Redshift Cluster Management Guide&lt;/i&gt;.&lt;/p&gt;
     * @param clusterIdentifier &lt;p&gt;The unique identifier of the cluster to be modified.&lt;/p&gt; &lt;p&gt;Example: &lt;code&gt;examplecluster&lt;/code&gt; &lt;/p&gt; (required)
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param clusterType &lt;p&gt;The new cluster type.&lt;/p&gt; &lt;p&gt;When you submit your cluster resize request, your existing cluster goes into a read-only mode. After Amazon Redshift provisions a new cluster based on your resize requirements, there will be outage for a period while the old cluster is deleted and your connection is switched to the new cluster. You can use &lt;a&gt;DescribeResize&lt;/a&gt; to track the progress of the resize request. &lt;/p&gt; &lt;p&gt;Valid Values: &lt;code&gt; multi-node | single-node &lt;/code&gt; &lt;/p&gt; (optional)
     * @param nodeType &lt;p&gt;The new node type of the cluster. If you specify a new node type, you must also specify the number of nodes parameter.&lt;/p&gt; &lt;p&gt; For more information about resizing clusters, go to &lt;a href&#x3D;\&quot;https://docs.aws.amazon.com/redshift/latest/mgmt/rs-resize-tutorial.html\&quot;&gt;Resizing Clusters in Amazon Redshift&lt;/a&gt; in the &lt;i&gt;Amazon Redshift Cluster Management Guide&lt;/i&gt;.&lt;/p&gt; &lt;p&gt;Valid Values: &lt;code&gt;ds2.xlarge&lt;/code&gt; | &lt;code&gt;ds2.8xlarge&lt;/code&gt; | &lt;code&gt;dc1.large&lt;/code&gt; | &lt;code&gt;dc1.8xlarge&lt;/code&gt; | &lt;code&gt;dc2.large&lt;/code&gt; | &lt;code&gt;dc2.8xlarge&lt;/code&gt; | &lt;code&gt;ra3.xlplus&lt;/code&gt; | &lt;code&gt;ra3.4xlarge&lt;/code&gt; | &lt;code&gt;ra3.16xlarge&lt;/code&gt; &lt;/p&gt; (optional)
     * @param numberOfNodes &lt;p&gt;The new number of nodes of the cluster. If you specify a new number of nodes, you must also specify the node type parameter.&lt;/p&gt; &lt;p&gt; For more information about resizing clusters, go to &lt;a href&#x3D;\&quot;https://docs.aws.amazon.com/redshift/latest/mgmt/rs-resize-tutorial.html\&quot;&gt;Resizing Clusters in Amazon Redshift&lt;/a&gt; in the &lt;i&gt;Amazon Redshift Cluster Management Guide&lt;/i&gt;.&lt;/p&gt; &lt;p&gt;Valid Values: Integer greater than &lt;code&gt;0&lt;/code&gt;.&lt;/p&gt; (optional)
     * @param clusterSecurityGroups &lt;p&gt;A list of cluster security groups to be authorized on this cluster. This change is asynchronously applied as soon as possible.&lt;/p&gt; &lt;p&gt;Security groups currently associated with the cluster, and not in the list of groups to apply, will be revoked from the cluster.&lt;/p&gt; &lt;p&gt;Constraints:&lt;/p&gt; &lt;ul&gt; &lt;li&gt; &lt;p&gt;Must be 1 to 255 alphanumeric characters or hyphens&lt;/p&gt; &lt;/li&gt; &lt;li&gt; &lt;p&gt;First character must be a letter&lt;/p&gt; &lt;/li&gt; &lt;li&gt; &lt;p&gt;Cannot end with a hyphen or contain two consecutive hyphens&lt;/p&gt; &lt;/li&gt; &lt;/ul&gt; (optional)
     * @param vpcSecurityGroupIds A list of virtual private cloud (VPC) security groups to be associated with the cluster. This change is asynchronously applied as soon as possible. (optional)
     * @param masterUserPassword &lt;p&gt;The new password for the cluster admin user. This change is asynchronously applied as soon as possible. Between the time of the request and the completion of the request, the &lt;code&gt;MasterUserPassword&lt;/code&gt; element exists in the &lt;code&gt;PendingModifiedValues&lt;/code&gt; element of the operation response. &lt;/p&gt; &lt;note&gt; &lt;p&gt;Operations never return the password, so this operation provides a way to regain access to the admin user account for a cluster if the password is lost.&lt;/p&gt; &lt;/note&gt; &lt;p&gt;Default: Uses existing setting.&lt;/p&gt; &lt;p&gt;Constraints:&lt;/p&gt; &lt;ul&gt; &lt;li&gt; &lt;p&gt;Must be between 8 and 64 characters in length.&lt;/p&gt; &lt;/li&gt; &lt;li&gt; &lt;p&gt;Must contain at least one uppercase letter.&lt;/p&gt; &lt;/li&gt; &lt;li&gt; &lt;p&gt;Must contain at least one lowercase letter.&lt;/p&gt; &lt;/li&gt; &lt;li&gt; &lt;p&gt;Must contain one number.&lt;/p&gt; &lt;/li&gt; &lt;li&gt; &lt;p&gt;Can be any printable ASCII character (ASCII code 33-126) except &lt;code&gt;&#39;&lt;/code&gt; (single quote), &lt;code&gt;\&quot;&lt;/code&gt; (double quote), &lt;code&gt;\\&lt;/code&gt;, &lt;code&gt;/&lt;/code&gt;, or &lt;code&gt;@&lt;/code&gt;.&lt;/p&gt; &lt;/li&gt; &lt;/ul&gt; (optional)
     * @param clusterParameterGroupName &lt;p&gt;The name of the cluster parameter group to apply to this cluster. This change is applied only after the cluster is rebooted. To reboot a cluster use &lt;a&gt;RebootCluster&lt;/a&gt;. &lt;/p&gt; &lt;p&gt;Default: Uses existing setting.&lt;/p&gt; &lt;p&gt;Constraints: The cluster parameter group must be in the same parameter group family that matches the cluster version.&lt;/p&gt; (optional)
     * @param automatedSnapshotRetentionPeriod &lt;p&gt;The number of days that automated snapshots are retained. If the value is 0, automated snapshots are disabled. Even if automated snapshots are disabled, you can still create manual snapshots when you want with &lt;a&gt;CreateClusterSnapshot&lt;/a&gt;. &lt;/p&gt; &lt;p&gt;If you decrease the automated snapshot retention period from its current value, existing automated snapshots that fall outside of the new retention period will be immediately deleted.&lt;/p&gt; &lt;p&gt;You can&#39;t disable automated snapshots for RA3 node types. Set the automated retention period from 1-35 days.&lt;/p&gt; &lt;p&gt;Default: Uses existing setting.&lt;/p&gt; &lt;p&gt;Constraints: Must be a value from 0 to 35.&lt;/p&gt; (optional)
     * @param manualSnapshotRetentionPeriod &lt;p&gt;The default for number of days that a newly created manual snapshot is retained. If the value is -1, the manual snapshot is retained indefinitely. This value doesn&#39;t retroactively change the retention periods of existing manual snapshots.&lt;/p&gt; &lt;p&gt;The value must be either -1 or an integer between 1 and 3,653.&lt;/p&gt; &lt;p&gt;The default value is -1.&lt;/p&gt; (optional)
     * @param preferredMaintenanceWindow &lt;p&gt;The weekly time range (in UTC) during which system maintenance can occur, if necessary. If system maintenance is necessary during the window, it may result in an outage.&lt;/p&gt; &lt;p&gt;This maintenance window change is made immediately. If the new maintenance window indicates the current time, there must be at least 120 minutes between the current time and end of the window in order to ensure that pending changes are applied.&lt;/p&gt; &lt;p&gt;Default: Uses existing setting.&lt;/p&gt; &lt;p&gt;Format: ddd:hh24:mi-ddd:hh24:mi, for example &lt;code&gt;wed:07:30-wed:08:00&lt;/code&gt;.&lt;/p&gt; &lt;p&gt;Valid Days: Mon | Tue | Wed | Thu | Fri | Sat | Sun&lt;/p&gt; &lt;p&gt;Constraints: Must be at least 30 minutes.&lt;/p&gt; (optional)
     * @param clusterVersion &lt;p&gt;The new version number of the Amazon Redshift engine to upgrade to.&lt;/p&gt; &lt;p&gt;For major version upgrades, if a non-default cluster parameter group is currently in use, a new cluster parameter group in the cluster parameter group family for the new version must be specified. The new cluster parameter group can be the default for that cluster parameter group family. For more information about parameters and parameter groups, go to &lt;a href&#x3D;\&quot;https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-parameter-groups.html\&quot;&gt;Amazon Redshift Parameter Groups&lt;/a&gt; in the &lt;i&gt;Amazon Redshift Cluster Management Guide&lt;/i&gt;.&lt;/p&gt; &lt;p&gt;Example: &lt;code&gt;1.0&lt;/code&gt; &lt;/p&gt; (optional)
     * @param allowVersionUpgrade &lt;p&gt;If &lt;code&gt;true&lt;/code&gt;, major version upgrades will be applied automatically to the cluster during the maintenance window. &lt;/p&gt; &lt;p&gt;Default: &lt;code&gt;false&lt;/code&gt; &lt;/p&gt; (optional)
     * @param hsmClientCertificateIdentifier Specifies the name of the HSM client certificate the Amazon Redshift cluster uses to retrieve the data encryption keys stored in an HSM. (optional)
     * @param hsmConfigurationIdentifier Specifies the name of the HSM configuration that contains the information the Amazon Redshift cluster can use to retrieve and store keys in an HSM. (optional)
     * @param newClusterIdentifier &lt;p&gt;The new identifier for the cluster.&lt;/p&gt; &lt;p&gt;Constraints:&lt;/p&gt; &lt;ul&gt; &lt;li&gt; &lt;p&gt;Must contain from 1 to 63 alphanumeric characters or hyphens.&lt;/p&gt; &lt;/li&gt; &lt;li&gt; &lt;p&gt;Alphabetic characters must be lowercase.&lt;/p&gt; &lt;/li&gt; &lt;li&gt; &lt;p&gt;First character must be a letter.&lt;/p&gt; &lt;/li&gt; &lt;li&gt; &lt;p&gt;Cannot end with a hyphen or contain two consecutive hyphens.&lt;/p&gt; &lt;/li&gt; &lt;li&gt; &lt;p&gt;Must be unique for all clusters within an Amazon Web Services account.&lt;/p&gt; &lt;/li&gt; &lt;/ul&gt; &lt;p&gt;Example: &lt;code&gt;examplecluster&lt;/code&gt; &lt;/p&gt; (optional)
     * @param publiclyAccessible If &lt;code&gt;true&lt;/code&gt;, the cluster can be accessed from a public network. Only clusters in VPCs can be set to be publicly available. (optional)
     * @param elasticIp &lt;p&gt;The Elastic IP (EIP) address for the cluster.&lt;/p&gt; &lt;p&gt;Constraints: The cluster must be provisioned in EC2-VPC and publicly-accessible through an Internet gateway. For more information about provisioning clusters in EC2-VPC, go to &lt;a href&#x3D;\&quot;https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html#cluster-platforms\&quot;&gt;Supported Platforms to Launch Your Cluster&lt;/a&gt; in the Amazon Redshift Cluster Management Guide.&lt;/p&gt; (optional)
     * @param enhancedVpcRouting &lt;p&gt;An option that specifies whether to create the cluster with enhanced VPC routing enabled. To create a cluster that uses enhanced VPC routing, the cluster must be in a VPC. For more information, see &lt;a href&#x3D;\&quot;https://docs.aws.amazon.com/redshift/latest/mgmt/enhanced-vpc-routing.html\&quot;&gt;Enhanced VPC Routing&lt;/a&gt; in the Amazon Redshift Cluster Management Guide.&lt;/p&gt; &lt;p&gt;If this option is &lt;code&gt;true&lt;/code&gt;, enhanced VPC routing is enabled. &lt;/p&gt; &lt;p&gt;Default: false&lt;/p&gt; (optional)
     * @param maintenanceTrackName The name for the maintenance track that you want to assign for the cluster. This name change is asynchronous. The new track name stays in the &lt;code&gt;PendingModifiedValues&lt;/code&gt; for the cluster until the next maintenance window. When the maintenance track changes, the cluster is switched to the latest cluster release available for the maintenance track. At this point, the maintenance track name is applied. (optional)
     * @param encrypted &lt;p&gt;Indicates whether the cluster is encrypted. If the value is encrypted (true) and you provide a value for the &lt;code&gt;KmsKeyId&lt;/code&gt; parameter, we encrypt the cluster with the provided &lt;code&gt;KmsKeyId&lt;/code&gt;. If you don&#39;t provide a &lt;code&gt;KmsKeyId&lt;/code&gt;, we encrypt with the default key. &lt;/p&gt; &lt;p&gt;If the value is not encrypted (false), then the cluster is decrypted. &lt;/p&gt; (optional)
     * @param kmsKeyId The Key Management Service (KMS) key ID of the encryption key that you want to use to encrypt data in the cluster. (optional)
     * @param availabilityZoneRelocation The option to enable relocation for an Amazon Redshift cluster between Availability Zones after the cluster modification is complete. (optional)
     * @param availabilityZone The option to initiate relocation for an Amazon Redshift cluster to the target Availability Zone. (optional)
     * @param port The option to change the port of an Amazon Redshift cluster. (optional)
     * @return ApiResponse&lt;ModifyClusterResult&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> InvalidClusterStateFault </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> InvalidClusterSecurityGroupStateFault </td><td>  -  </td></tr>
        <tr><td> 482 </td><td> ClusterNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 483 </td><td> NumberOfNodesQuotaExceededFault </td><td>  -  </td></tr>
        <tr><td> 484 </td><td> NumberOfNodesPerClusterLimitExceededFault </td><td>  -  </td></tr>
        <tr><td> 485 </td><td> ClusterSecurityGroupNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 486 </td><td> ClusterParameterGroupNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 487 </td><td> InsufficientClusterCapacityFault </td><td>  -  </td></tr>
        <tr><td> 488 </td><td> UnsupportedOptionFault </td><td>  -  </td></tr>
        <tr><td> 489 </td><td> UnauthorizedOperation </td><td>  -  </td></tr>
        <tr><td> 490 </td><td> HsmClientCertificateNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 491 </td><td> HsmConfigurationNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 492 </td><td> ClusterAlreadyExistsFault </td><td>  -  </td></tr>
        <tr><td> 493 </td><td> LimitExceededFault </td><td>  -  </td></tr>
        <tr><td> 494 </td><td> DependentServiceRequestThrottlingFault </td><td>  -  </td></tr>
        <tr><td> 495 </td><td> InvalidElasticIpFault </td><td>  -  </td></tr>
        <tr><td> 496 </td><td> TableLimitExceededFault </td><td>  -  </td></tr>
        <tr><td> 497 </td><td> InvalidClusterTrackFault </td><td>  -  </td></tr>
        <tr><td> 498 </td><td> InvalidRetentionPeriodFault </td><td>  -  </td></tr>
        <tr><td> 499 </td><td> UnsupportedOperationFault </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> CustomCnameAssociationFault </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<ModifyClusterResult> gETModifyClusterWithHttpInfo(String clusterIdentifier, String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, String clusterType, String nodeType, Integer numberOfNodes, List<String> clusterSecurityGroups, List<String> vpcSecurityGroupIds, String masterUserPassword, String clusterParameterGroupName, Integer automatedSnapshotRetentionPeriod, Integer manualSnapshotRetentionPeriod, String preferredMaintenanceWindow, String clusterVersion, Boolean allowVersionUpgrade, String hsmClientCertificateIdentifier, String hsmConfigurationIdentifier, String newClusterIdentifier, Boolean publiclyAccessible, String elasticIp, Boolean enhancedVpcRouting, String maintenanceTrackName, Boolean encrypted, String kmsKeyId, Boolean availabilityZoneRelocation, String availabilityZone, Integer port) throws ApiException {
        okhttp3.Call localVarCall = gETModifyClusterValidateBeforeCall(clusterIdentifier, action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, clusterType, nodeType, numberOfNodes, clusterSecurityGroups, vpcSecurityGroupIds, masterUserPassword, clusterParameterGroupName, automatedSnapshotRetentionPeriod, manualSnapshotRetentionPeriod, preferredMaintenanceWindow, clusterVersion, allowVersionUpgrade, hsmClientCertificateIdentifier, hsmConfigurationIdentifier, newClusterIdentifier, publiclyAccessible, elasticIp, enhancedVpcRouting, maintenanceTrackName, encrypted, kmsKeyId, availabilityZoneRelocation, availabilityZone, port, null);
        Type localVarReturnType = new TypeToken<ModifyClusterResult>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     *  (asynchronously)
     * &lt;p&gt;Modifies the settings for a cluster.&lt;/p&gt; &lt;p&gt;You can also change node type and the number of nodes to scale up or down the cluster. When resizing a cluster, you must specify both the number of nodes and the node type even if one of the parameters does not change.&lt;/p&gt; &lt;p&gt;You can add another security or parameter group, or change the admin user password. Resetting a cluster password or modifying the security groups associated with a cluster do not need a reboot. However, modifying a parameter group requires a reboot for parameters to take effect. For more information about managing clusters, go to &lt;a href&#x3D;\&quot;https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html\&quot;&gt;Amazon Redshift Clusters&lt;/a&gt; in the &lt;i&gt;Amazon Redshift Cluster Management Guide&lt;/i&gt;.&lt;/p&gt;
     * @param clusterIdentifier &lt;p&gt;The unique identifier of the cluster to be modified.&lt;/p&gt; &lt;p&gt;Example: &lt;code&gt;examplecluster&lt;/code&gt; &lt;/p&gt; (required)
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param clusterType &lt;p&gt;The new cluster type.&lt;/p&gt; &lt;p&gt;When you submit your cluster resize request, your existing cluster goes into a read-only mode. After Amazon Redshift provisions a new cluster based on your resize requirements, there will be outage for a period while the old cluster is deleted and your connection is switched to the new cluster. You can use &lt;a&gt;DescribeResize&lt;/a&gt; to track the progress of the resize request. &lt;/p&gt; &lt;p&gt;Valid Values: &lt;code&gt; multi-node | single-node &lt;/code&gt; &lt;/p&gt; (optional)
     * @param nodeType &lt;p&gt;The new node type of the cluster. If you specify a new node type, you must also specify the number of nodes parameter.&lt;/p&gt; &lt;p&gt; For more information about resizing clusters, go to &lt;a href&#x3D;\&quot;https://docs.aws.amazon.com/redshift/latest/mgmt/rs-resize-tutorial.html\&quot;&gt;Resizing Clusters in Amazon Redshift&lt;/a&gt; in the &lt;i&gt;Amazon Redshift Cluster Management Guide&lt;/i&gt;.&lt;/p&gt; &lt;p&gt;Valid Values: &lt;code&gt;ds2.xlarge&lt;/code&gt; | &lt;code&gt;ds2.8xlarge&lt;/code&gt; | &lt;code&gt;dc1.large&lt;/code&gt; | &lt;code&gt;dc1.8xlarge&lt;/code&gt; | &lt;code&gt;dc2.large&lt;/code&gt; | &lt;code&gt;dc2.8xlarge&lt;/code&gt; | &lt;code&gt;ra3.xlplus&lt;/code&gt; | &lt;code&gt;ra3.4xlarge&lt;/code&gt; | &lt;code&gt;ra3.16xlarge&lt;/code&gt; &lt;/p&gt; (optional)
     * @param numberOfNodes &lt;p&gt;The new number of nodes of the cluster. If you specify a new number of nodes, you must also specify the node type parameter.&lt;/p&gt; &lt;p&gt; For more information about resizing clusters, go to &lt;a href&#x3D;\&quot;https://docs.aws.amazon.com/redshift/latest/mgmt/rs-resize-tutorial.html\&quot;&gt;Resizing Clusters in Amazon Redshift&lt;/a&gt; in the &lt;i&gt;Amazon Redshift Cluster Management Guide&lt;/i&gt;.&lt;/p&gt; &lt;p&gt;Valid Values: Integer greater than &lt;code&gt;0&lt;/code&gt;.&lt;/p&gt; (optional)
     * @param clusterSecurityGroups &lt;p&gt;A list of cluster security groups to be authorized on this cluster. This change is asynchronously applied as soon as possible.&lt;/p&gt; &lt;p&gt;Security groups currently associated with the cluster, and not in the list of groups to apply, will be revoked from the cluster.&lt;/p&gt; &lt;p&gt;Constraints:&lt;/p&gt; &lt;ul&gt; &lt;li&gt; &lt;p&gt;Must be 1 to 255 alphanumeric characters or hyphens&lt;/p&gt; &lt;/li&gt; &lt;li&gt; &lt;p&gt;First character must be a letter&lt;/p&gt; &lt;/li&gt; &lt;li&gt; &lt;p&gt;Cannot end with a hyphen or contain two consecutive hyphens&lt;/p&gt; &lt;/li&gt; &lt;/ul&gt; (optional)
     * @param vpcSecurityGroupIds A list of virtual private cloud (VPC) security groups to be associated with the cluster. This change is asynchronously applied as soon as possible. (optional)
     * @param masterUserPassword &lt;p&gt;The new password for the cluster admin user. This change is asynchronously applied as soon as possible. Between the time of the request and the completion of the request, the &lt;code&gt;MasterUserPassword&lt;/code&gt; element exists in the &lt;code&gt;PendingModifiedValues&lt;/code&gt; element of the operation response. &lt;/p&gt; &lt;note&gt; &lt;p&gt;Operations never return the password, so this operation provides a way to regain access to the admin user account for a cluster if the password is lost.&lt;/p&gt; &lt;/note&gt; &lt;p&gt;Default: Uses existing setting.&lt;/p&gt; &lt;p&gt;Constraints:&lt;/p&gt; &lt;ul&gt; &lt;li&gt; &lt;p&gt;Must be between 8 and 64 characters in length.&lt;/p&gt; &lt;/li&gt; &lt;li&gt; &lt;p&gt;Must contain at least one uppercase letter.&lt;/p&gt; &lt;/li&gt; &lt;li&gt; &lt;p&gt;Must contain at least one lowercase letter.&lt;/p&gt; &lt;/li&gt; &lt;li&gt; &lt;p&gt;Must contain one number.&lt;/p&gt; &lt;/li&gt; &lt;li&gt; &lt;p&gt;Can be any printable ASCII character (ASCII code 33-126) except &lt;code&gt;&#39;&lt;/code&gt; (single quote), &lt;code&gt;\&quot;&lt;/code&gt; (double quote), &lt;code&gt;\\&lt;/code&gt;, &lt;code&gt;/&lt;/code&gt;, or &lt;code&gt;@&lt;/code&gt;.&lt;/p&gt; &lt;/li&gt; &lt;/ul&gt; (optional)
     * @param clusterParameterGroupName &lt;p&gt;The name of the cluster parameter group to apply to this cluster. This change is applied only after the cluster is rebooted. To reboot a cluster use &lt;a&gt;RebootCluster&lt;/a&gt;. &lt;/p&gt; &lt;p&gt;Default: Uses existing setting.&lt;/p&gt; &lt;p&gt;Constraints: The cluster parameter group must be in the same parameter group family that matches the cluster version.&lt;/p&gt; (optional)
     * @param automatedSnapshotRetentionPeriod &lt;p&gt;The number of days that automated snapshots are retained. If the value is 0, automated snapshots are disabled. Even if automated snapshots are disabled, you can still create manual snapshots when you want with &lt;a&gt;CreateClusterSnapshot&lt;/a&gt;. &lt;/p&gt; &lt;p&gt;If you decrease the automated snapshot retention period from its current value, existing automated snapshots that fall outside of the new retention period will be immediately deleted.&lt;/p&gt; &lt;p&gt;You can&#39;t disable automated snapshots for RA3 node types. Set the automated retention period from 1-35 days.&lt;/p&gt; &lt;p&gt;Default: Uses existing setting.&lt;/p&gt; &lt;p&gt;Constraints: Must be a value from 0 to 35.&lt;/p&gt; (optional)
     * @param manualSnapshotRetentionPeriod &lt;p&gt;The default for number of days that a newly created manual snapshot is retained. If the value is -1, the manual snapshot is retained indefinitely. This value doesn&#39;t retroactively change the retention periods of existing manual snapshots.&lt;/p&gt; &lt;p&gt;The value must be either -1 or an integer between 1 and 3,653.&lt;/p&gt; &lt;p&gt;The default value is -1.&lt;/p&gt; (optional)
     * @param preferredMaintenanceWindow &lt;p&gt;The weekly time range (in UTC) during which system maintenance can occur, if necessary. If system maintenance is necessary during the window, it may result in an outage.&lt;/p&gt; &lt;p&gt;This maintenance window change is made immediately. If the new maintenance window indicates the current time, there must be at least 120 minutes between the current time and end of the window in order to ensure that pending changes are applied.&lt;/p&gt; &lt;p&gt;Default: Uses existing setting.&lt;/p&gt; &lt;p&gt;Format: ddd:hh24:mi-ddd:hh24:mi, for example &lt;code&gt;wed:07:30-wed:08:00&lt;/code&gt;.&lt;/p&gt; &lt;p&gt;Valid Days: Mon | Tue | Wed | Thu | Fri | Sat | Sun&lt;/p&gt; &lt;p&gt;Constraints: Must be at least 30 minutes.&lt;/p&gt; (optional)
     * @param clusterVersion &lt;p&gt;The new version number of the Amazon Redshift engine to upgrade to.&lt;/p&gt; &lt;p&gt;For major version upgrades, if a non-default cluster parameter group is currently in use, a new cluster parameter group in the cluster parameter group family for the new version must be specified. The new cluster parameter group can be the default for that cluster parameter group family. For more information about parameters and parameter groups, go to &lt;a href&#x3D;\&quot;https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-parameter-groups.html\&quot;&gt;Amazon Redshift Parameter Groups&lt;/a&gt; in the &lt;i&gt;Amazon Redshift Cluster Management Guide&lt;/i&gt;.&lt;/p&gt; &lt;p&gt;Example: &lt;code&gt;1.0&lt;/code&gt; &lt;/p&gt; (optional)
     * @param allowVersionUpgrade &lt;p&gt;If &lt;code&gt;true&lt;/code&gt;, major version upgrades will be applied automatically to the cluster during the maintenance window. &lt;/p&gt; &lt;p&gt;Default: &lt;code&gt;false&lt;/code&gt; &lt;/p&gt; (optional)
     * @param hsmClientCertificateIdentifier Specifies the name of the HSM client certificate the Amazon Redshift cluster uses to retrieve the data encryption keys stored in an HSM. (optional)
     * @param hsmConfigurationIdentifier Specifies the name of the HSM configuration that contains the information the Amazon Redshift cluster can use to retrieve and store keys in an HSM. (optional)
     * @param newClusterIdentifier &lt;p&gt;The new identifier for the cluster.&lt;/p&gt; &lt;p&gt;Constraints:&lt;/p&gt; &lt;ul&gt; &lt;li&gt; &lt;p&gt;Must contain from 1 to 63 alphanumeric characters or hyphens.&lt;/p&gt; &lt;/li&gt; &lt;li&gt; &lt;p&gt;Alphabetic characters must be lowercase.&lt;/p&gt; &lt;/li&gt; &lt;li&gt; &lt;p&gt;First character must be a letter.&lt;/p&gt; &lt;/li&gt; &lt;li&gt; &lt;p&gt;Cannot end with a hyphen or contain two consecutive hyphens.&lt;/p&gt; &lt;/li&gt; &lt;li&gt; &lt;p&gt;Must be unique for all clusters within an Amazon Web Services account.&lt;/p&gt; &lt;/li&gt; &lt;/ul&gt; &lt;p&gt;Example: &lt;code&gt;examplecluster&lt;/code&gt; &lt;/p&gt; (optional)
     * @param publiclyAccessible If &lt;code&gt;true&lt;/code&gt;, the cluster can be accessed from a public network. Only clusters in VPCs can be set to be publicly available. (optional)
     * @param elasticIp &lt;p&gt;The Elastic IP (EIP) address for the cluster.&lt;/p&gt; &lt;p&gt;Constraints: The cluster must be provisioned in EC2-VPC and publicly-accessible through an Internet gateway. For more information about provisioning clusters in EC2-VPC, go to &lt;a href&#x3D;\&quot;https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html#cluster-platforms\&quot;&gt;Supported Platforms to Launch Your Cluster&lt;/a&gt; in the Amazon Redshift Cluster Management Guide.&lt;/p&gt; (optional)
     * @param enhancedVpcRouting &lt;p&gt;An option that specifies whether to create the cluster with enhanced VPC routing enabled. To create a cluster that uses enhanced VPC routing, the cluster must be in a VPC. For more information, see &lt;a href&#x3D;\&quot;https://docs.aws.amazon.com/redshift/latest/mgmt/enhanced-vpc-routing.html\&quot;&gt;Enhanced VPC Routing&lt;/a&gt; in the Amazon Redshift Cluster Management Guide.&lt;/p&gt; &lt;p&gt;If this option is &lt;code&gt;true&lt;/code&gt;, enhanced VPC routing is enabled. &lt;/p&gt; &lt;p&gt;Default: false&lt;/p&gt; (optional)
     * @param maintenanceTrackName The name for the maintenance track that you want to assign for the cluster. This name change is asynchronous. The new track name stays in the &lt;code&gt;PendingModifiedValues&lt;/code&gt; for the cluster until the next maintenance window. When the maintenance track changes, the cluster is switched to the latest cluster release available for the maintenance track. At this point, the maintenance track name is applied. (optional)
     * @param encrypted &lt;p&gt;Indicates whether the cluster is encrypted. If the value is encrypted (true) and you provide a value for the &lt;code&gt;KmsKeyId&lt;/code&gt; parameter, we encrypt the cluster with the provided &lt;code&gt;KmsKeyId&lt;/code&gt;. If you don&#39;t provide a &lt;code&gt;KmsKeyId&lt;/code&gt;, we encrypt with the default key. &lt;/p&gt; &lt;p&gt;If the value is not encrypted (false), then the cluster is decrypted. &lt;/p&gt; (optional)
     * @param kmsKeyId The Key Management Service (KMS) key ID of the encryption key that you want to use to encrypt data in the cluster. (optional)
     * @param availabilityZoneRelocation The option to enable relocation for an Amazon Redshift cluster between Availability Zones after the cluster modification is complete. (optional)
     * @param availabilityZone The option to initiate relocation for an Amazon Redshift cluster to the target Availability Zone. (optional)
     * @param port The option to change the port of an Amazon Redshift cluster. (optional)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> InvalidClusterStateFault </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> InvalidClusterSecurityGroupStateFault </td><td>  -  </td></tr>
        <tr><td> 482 </td><td> ClusterNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 483 </td><td> NumberOfNodesQuotaExceededFault </td><td>  -  </td></tr>
        <tr><td> 484 </td><td> NumberOfNodesPerClusterLimitExceededFault </td><td>  -  </td></tr>
        <tr><td> 485 </td><td> ClusterSecurityGroupNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 486 </td><td> ClusterParameterGroupNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 487 </td><td> InsufficientClusterCapacityFault </td><td>  -  </td></tr>
        <tr><td> 488 </td><td> UnsupportedOptionFault </td><td>  -  </td></tr>
        <tr><td> 489 </td><td> UnauthorizedOperation </td><td>  -  </td></tr>
        <tr><td> 490 </td><td> HsmClientCertificateNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 491 </td><td> HsmConfigurationNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 492 </td><td> ClusterAlreadyExistsFault </td><td>  -  </td></tr>
        <tr><td> 493 </td><td> LimitExceededFault </td><td>  -  </td></tr>
        <tr><td> 494 </td><td> DependentServiceRequestThrottlingFault </td><td>  -  </td></tr>
        <tr><td> 495 </td><td> InvalidElasticIpFault </td><td>  -  </td></tr>
        <tr><td> 496 </td><td> TableLimitExceededFault </td><td>  -  </td></tr>
        <tr><td> 497 </td><td> InvalidClusterTrackFault </td><td>  -  </td></tr>
        <tr><td> 498 </td><td> InvalidRetentionPeriodFault </td><td>  -  </td></tr>
        <tr><td> 499 </td><td> UnsupportedOperationFault </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> CustomCnameAssociationFault </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call gETModifyClusterAsync(String clusterIdentifier, String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, String clusterType, String nodeType, Integer numberOfNodes, List<String> clusterSecurityGroups, List<String> vpcSecurityGroupIds, String masterUserPassword, String clusterParameterGroupName, Integer automatedSnapshotRetentionPeriod, Integer manualSnapshotRetentionPeriod, String preferredMaintenanceWindow, String clusterVersion, Boolean allowVersionUpgrade, String hsmClientCertificateIdentifier, String hsmConfigurationIdentifier, String newClusterIdentifier, Boolean publiclyAccessible, String elasticIp, Boolean enhancedVpcRouting, String maintenanceTrackName, Boolean encrypted, String kmsKeyId, Boolean availabilityZoneRelocation, String availabilityZone, Integer port, final ApiCallback<ModifyClusterResult> _callback) throws ApiException {

        okhttp3.Call localVarCall = gETModifyClusterValidateBeforeCall(clusterIdentifier, action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, clusterType, nodeType, numberOfNodes, clusterSecurityGroups, vpcSecurityGroupIds, masterUserPassword, clusterParameterGroupName, automatedSnapshotRetentionPeriod, manualSnapshotRetentionPeriod, preferredMaintenanceWindow, clusterVersion, allowVersionUpgrade, hsmClientCertificateIdentifier, hsmConfigurationIdentifier, newClusterIdentifier, publiclyAccessible, elasticIp, enhancedVpcRouting, maintenanceTrackName, encrypted, kmsKeyId, availabilityZoneRelocation, availabilityZone, port, _callback);
        Type localVarReturnType = new TypeToken<ModifyClusterResult>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for gETModifyClusterDbRevision
     * @param clusterIdentifier &lt;p&gt;The unique identifier of a cluster whose database revision you want to modify. &lt;/p&gt; &lt;p&gt;Example: &lt;code&gt;examplecluster&lt;/code&gt; &lt;/p&gt; (required)
     * @param revisionTarget The identifier of the database revision. You can retrieve this value from the response to the &lt;a&gt;DescribeClusterDbRevisions&lt;/a&gt; request. (required)
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> ClusterNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> ClusterOnLatestRevisionFault </td><td>  -  </td></tr>
        <tr><td> 482 </td><td> InvalidClusterStateFault </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call gETModifyClusterDbRevisionCall(String clusterIdentifier, String revisionTarget, String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/#Action=ModifyClusterDbRevision";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (clusterIdentifier != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("ClusterIdentifier", clusterIdentifier));
        }

        if (revisionTarget != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("RevisionTarget", revisionTarget));
        }

        if (action != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("Action", action));
        }

        if (version != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("Version", version));
        }

        if (xAmzContentSha256 != null) {
            localVarHeaderParams.put("X-Amz-Content-Sha256", localVarApiClient.parameterToString(xAmzContentSha256));
        }

        if (xAmzDate != null) {
            localVarHeaderParams.put("X-Amz-Date", localVarApiClient.parameterToString(xAmzDate));
        }

        if (xAmzAlgorithm != null) {
            localVarHeaderParams.put("X-Amz-Algorithm", localVarApiClient.parameterToString(xAmzAlgorithm));
        }

        if (xAmzCredential != null) {
            localVarHeaderParams.put("X-Amz-Credential", localVarApiClient.parameterToString(xAmzCredential));
        }

        if (xAmzSecurityToken != null) {
            localVarHeaderParams.put("X-Amz-Security-Token", localVarApiClient.parameterToString(xAmzSecurityToken));
        }

        if (xAmzSignature != null) {
            localVarHeaderParams.put("X-Amz-Signature", localVarApiClient.parameterToString(xAmzSignature));
        }

        if (xAmzSignedHeaders != null) {
            localVarHeaderParams.put("X-Amz-SignedHeaders", localVarApiClient.parameterToString(xAmzSignedHeaders));
        }

        final String[] localVarAccepts = {
            "text/xml"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "hmac" };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call gETModifyClusterDbRevisionValidateBeforeCall(String clusterIdentifier, String revisionTarget, String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'clusterIdentifier' is set
        if (clusterIdentifier == null) {
            throw new ApiException("Missing the required parameter 'clusterIdentifier' when calling gETModifyClusterDbRevision(Async)");
        }

        // verify the required parameter 'revisionTarget' is set
        if (revisionTarget == null) {
            throw new ApiException("Missing the required parameter 'revisionTarget' when calling gETModifyClusterDbRevision(Async)");
        }

        // verify the required parameter 'action' is set
        if (action == null) {
            throw new ApiException("Missing the required parameter 'action' when calling gETModifyClusterDbRevision(Async)");
        }

        // verify the required parameter 'version' is set
        if (version == null) {
            throw new ApiException("Missing the required parameter 'version' when calling gETModifyClusterDbRevision(Async)");
        }

        return gETModifyClusterDbRevisionCall(clusterIdentifier, revisionTarget, action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, _callback);

    }

    /**
     * 
     * Modifies the database revision of a cluster. The database revision is a unique revision of the database running in a cluster.
     * @param clusterIdentifier &lt;p&gt;The unique identifier of a cluster whose database revision you want to modify. &lt;/p&gt; &lt;p&gt;Example: &lt;code&gt;examplecluster&lt;/code&gt; &lt;/p&gt; (required)
     * @param revisionTarget The identifier of the database revision. You can retrieve this value from the response to the &lt;a&gt;DescribeClusterDbRevisions&lt;/a&gt; request. (required)
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @return ModifyClusterDbRevisionResult
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> ClusterNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> ClusterOnLatestRevisionFault </td><td>  -  </td></tr>
        <tr><td> 482 </td><td> InvalidClusterStateFault </td><td>  -  </td></tr>
     </table>
     */
    public ModifyClusterDbRevisionResult gETModifyClusterDbRevision(String clusterIdentifier, String revisionTarget, String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders) throws ApiException {
        ApiResponse<ModifyClusterDbRevisionResult> localVarResp = gETModifyClusterDbRevisionWithHttpInfo(clusterIdentifier, revisionTarget, action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders);
        return localVarResp.getData();
    }

    /**
     * 
     * Modifies the database revision of a cluster. The database revision is a unique revision of the database running in a cluster.
     * @param clusterIdentifier &lt;p&gt;The unique identifier of a cluster whose database revision you want to modify. &lt;/p&gt; &lt;p&gt;Example: &lt;code&gt;examplecluster&lt;/code&gt; &lt;/p&gt; (required)
     * @param revisionTarget The identifier of the database revision. You can retrieve this value from the response to the &lt;a&gt;DescribeClusterDbRevisions&lt;/a&gt; request. (required)
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @return ApiResponse&lt;ModifyClusterDbRevisionResult&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> ClusterNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> ClusterOnLatestRevisionFault </td><td>  -  </td></tr>
        <tr><td> 482 </td><td> InvalidClusterStateFault </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<ModifyClusterDbRevisionResult> gETModifyClusterDbRevisionWithHttpInfo(String clusterIdentifier, String revisionTarget, String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders) throws ApiException {
        okhttp3.Call localVarCall = gETModifyClusterDbRevisionValidateBeforeCall(clusterIdentifier, revisionTarget, action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, null);
        Type localVarReturnType = new TypeToken<ModifyClusterDbRevisionResult>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     *  (asynchronously)
     * Modifies the database revision of a cluster. The database revision is a unique revision of the database running in a cluster.
     * @param clusterIdentifier &lt;p&gt;The unique identifier of a cluster whose database revision you want to modify. &lt;/p&gt; &lt;p&gt;Example: &lt;code&gt;examplecluster&lt;/code&gt; &lt;/p&gt; (required)
     * @param revisionTarget The identifier of the database revision. You can retrieve this value from the response to the &lt;a&gt;DescribeClusterDbRevisions&lt;/a&gt; request. (required)
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> ClusterNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> ClusterOnLatestRevisionFault </td><td>  -  </td></tr>
        <tr><td> 482 </td><td> InvalidClusterStateFault </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call gETModifyClusterDbRevisionAsync(String clusterIdentifier, String revisionTarget, String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, final ApiCallback<ModifyClusterDbRevisionResult> _callback) throws ApiException {

        okhttp3.Call localVarCall = gETModifyClusterDbRevisionValidateBeforeCall(clusterIdentifier, revisionTarget, action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, _callback);
        Type localVarReturnType = new TypeToken<ModifyClusterDbRevisionResult>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for gETModifyClusterIamRoles
     * @param clusterIdentifier The unique identifier of the cluster for which you want to associate or disassociate IAM roles. (required)
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param addIamRoles Zero or more IAM roles to associate with the cluster. The roles must be in their Amazon Resource Name (ARN) format.  (optional)
     * @param removeIamRoles Zero or more IAM roles in ARN format to disassociate from the cluster.  (optional)
     * @param defaultIamRoleArn The Amazon Resource Name (ARN) for the IAM role that was set as default for the cluster when the cluster was last modified. (optional)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> InvalidClusterStateFault </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> ClusterNotFoundFault </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call gETModifyClusterIamRolesCall(String clusterIdentifier, String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, List<String> addIamRoles, List<String> removeIamRoles, String defaultIamRoleArn, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/#Action=ModifyClusterIamRoles";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (clusterIdentifier != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("ClusterIdentifier", clusterIdentifier));
        }

        if (addIamRoles != null) {
            localVarCollectionQueryParams.addAll(localVarApiClient.parameterToPairs("multi", "AddIamRoles", addIamRoles));
        }

        if (removeIamRoles != null) {
            localVarCollectionQueryParams.addAll(localVarApiClient.parameterToPairs("multi", "RemoveIamRoles", removeIamRoles));
        }

        if (defaultIamRoleArn != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("DefaultIamRoleArn", defaultIamRoleArn));
        }

        if (action != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("Action", action));
        }

        if (version != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("Version", version));
        }

        if (xAmzContentSha256 != null) {
            localVarHeaderParams.put("X-Amz-Content-Sha256", localVarApiClient.parameterToString(xAmzContentSha256));
        }

        if (xAmzDate != null) {
            localVarHeaderParams.put("X-Amz-Date", localVarApiClient.parameterToString(xAmzDate));
        }

        if (xAmzAlgorithm != null) {
            localVarHeaderParams.put("X-Amz-Algorithm", localVarApiClient.parameterToString(xAmzAlgorithm));
        }

        if (xAmzCredential != null) {
            localVarHeaderParams.put("X-Amz-Credential", localVarApiClient.parameterToString(xAmzCredential));
        }

        if (xAmzSecurityToken != null) {
            localVarHeaderParams.put("X-Amz-Security-Token", localVarApiClient.parameterToString(xAmzSecurityToken));
        }

        if (xAmzSignature != null) {
            localVarHeaderParams.put("X-Amz-Signature", localVarApiClient.parameterToString(xAmzSignature));
        }

        if (xAmzSignedHeaders != null) {
            localVarHeaderParams.put("X-Amz-SignedHeaders", localVarApiClient.parameterToString(xAmzSignedHeaders));
        }

        final String[] localVarAccepts = {
            "text/xml"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "hmac" };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call gETModifyClusterIamRolesValidateBeforeCall(String clusterIdentifier, String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, List<String> addIamRoles, List<String> removeIamRoles, String defaultIamRoleArn, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'clusterIdentifier' is set
        if (clusterIdentifier == null) {
            throw new ApiException("Missing the required parameter 'clusterIdentifier' when calling gETModifyClusterIamRoles(Async)");
        }

        // verify the required parameter 'action' is set
        if (action == null) {
            throw new ApiException("Missing the required parameter 'action' when calling gETModifyClusterIamRoles(Async)");
        }

        // verify the required parameter 'version' is set
        if (version == null) {
            throw new ApiException("Missing the required parameter 'version' when calling gETModifyClusterIamRoles(Async)");
        }

        return gETModifyClusterIamRolesCall(clusterIdentifier, action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, addIamRoles, removeIamRoles, defaultIamRoleArn, _callback);

    }

    /**
     * 
     * &lt;p&gt;Modifies the list of Identity and Access Management (IAM) roles that can be used by the cluster to access other Amazon Web Services services.&lt;/p&gt; &lt;p&gt;The maximum number of IAM roles that you can associate is subject to a quota. For more information, go to &lt;a href&#x3D;\&quot;https://docs.aws.amazon.com/redshift/latest/mgmt/amazon-redshift-limits.html\&quot;&gt;Quotas and limits&lt;/a&gt; in the &lt;i&gt;Amazon Redshift Cluster Management Guide&lt;/i&gt;.&lt;/p&gt;
     * @param clusterIdentifier The unique identifier of the cluster for which you want to associate or disassociate IAM roles. (required)
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param addIamRoles Zero or more IAM roles to associate with the cluster. The roles must be in their Amazon Resource Name (ARN) format.  (optional)
     * @param removeIamRoles Zero or more IAM roles in ARN format to disassociate from the cluster.  (optional)
     * @param defaultIamRoleArn The Amazon Resource Name (ARN) for the IAM role that was set as default for the cluster when the cluster was last modified. (optional)
     * @return ModifyClusterIamRolesResult
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> InvalidClusterStateFault </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> ClusterNotFoundFault </td><td>  -  </td></tr>
     </table>
     */
    public ModifyClusterIamRolesResult gETModifyClusterIamRoles(String clusterIdentifier, String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, List<String> addIamRoles, List<String> removeIamRoles, String defaultIamRoleArn) throws ApiException {
        ApiResponse<ModifyClusterIamRolesResult> localVarResp = gETModifyClusterIamRolesWithHttpInfo(clusterIdentifier, action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, addIamRoles, removeIamRoles, defaultIamRoleArn);
        return localVarResp.getData();
    }

    /**
     * 
     * &lt;p&gt;Modifies the list of Identity and Access Management (IAM) roles that can be used by the cluster to access other Amazon Web Services services.&lt;/p&gt; &lt;p&gt;The maximum number of IAM roles that you can associate is subject to a quota. For more information, go to &lt;a href&#x3D;\&quot;https://docs.aws.amazon.com/redshift/latest/mgmt/amazon-redshift-limits.html\&quot;&gt;Quotas and limits&lt;/a&gt; in the &lt;i&gt;Amazon Redshift Cluster Management Guide&lt;/i&gt;.&lt;/p&gt;
     * @param clusterIdentifier The unique identifier of the cluster for which you want to associate or disassociate IAM roles. (required)
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param addIamRoles Zero or more IAM roles to associate with the cluster. The roles must be in their Amazon Resource Name (ARN) format.  (optional)
     * @param removeIamRoles Zero or more IAM roles in ARN format to disassociate from the cluster.  (optional)
     * @param defaultIamRoleArn The Amazon Resource Name (ARN) for the IAM role that was set as default for the cluster when the cluster was last modified. (optional)
     * @return ApiResponse&lt;ModifyClusterIamRolesResult&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> InvalidClusterStateFault </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> ClusterNotFoundFault </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<ModifyClusterIamRolesResult> gETModifyClusterIamRolesWithHttpInfo(String clusterIdentifier, String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, List<String> addIamRoles, List<String> removeIamRoles, String defaultIamRoleArn) throws ApiException {
        okhttp3.Call localVarCall = gETModifyClusterIamRolesValidateBeforeCall(clusterIdentifier, action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, addIamRoles, removeIamRoles, defaultIamRoleArn, null);
        Type localVarReturnType = new TypeToken<ModifyClusterIamRolesResult>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     *  (asynchronously)
     * &lt;p&gt;Modifies the list of Identity and Access Management (IAM) roles that can be used by the cluster to access other Amazon Web Services services.&lt;/p&gt; &lt;p&gt;The maximum number of IAM roles that you can associate is subject to a quota. For more information, go to &lt;a href&#x3D;\&quot;https://docs.aws.amazon.com/redshift/latest/mgmt/amazon-redshift-limits.html\&quot;&gt;Quotas and limits&lt;/a&gt; in the &lt;i&gt;Amazon Redshift Cluster Management Guide&lt;/i&gt;.&lt;/p&gt;
     * @param clusterIdentifier The unique identifier of the cluster for which you want to associate or disassociate IAM roles. (required)
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param addIamRoles Zero or more IAM roles to associate with the cluster. The roles must be in their Amazon Resource Name (ARN) format.  (optional)
     * @param removeIamRoles Zero or more IAM roles in ARN format to disassociate from the cluster.  (optional)
     * @param defaultIamRoleArn The Amazon Resource Name (ARN) for the IAM role that was set as default for the cluster when the cluster was last modified. (optional)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> InvalidClusterStateFault </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> ClusterNotFoundFault </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call gETModifyClusterIamRolesAsync(String clusterIdentifier, String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, List<String> addIamRoles, List<String> removeIamRoles, String defaultIamRoleArn, final ApiCallback<ModifyClusterIamRolesResult> _callback) throws ApiException {

        okhttp3.Call localVarCall = gETModifyClusterIamRolesValidateBeforeCall(clusterIdentifier, action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, addIamRoles, removeIamRoles, defaultIamRoleArn, _callback);
        Type localVarReturnType = new TypeToken<ModifyClusterIamRolesResult>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for gETModifyClusterMaintenance
     * @param clusterIdentifier A unique identifier for the cluster. (required)
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param deferMaintenance A boolean indicating whether to enable the deferred maintenance window.  (optional)
     * @param deferMaintenanceIdentifier A unique identifier for the deferred maintenance window. (optional)
     * @param deferMaintenanceStartTime A timestamp indicating the start time for the deferred maintenance window. (optional)
     * @param deferMaintenanceEndTime A timestamp indicating end time for the deferred maintenance window. If you specify an end time, you can&#39;t specify a duration. (optional)
     * @param deferMaintenanceDuration An integer indicating the duration of the maintenance window in days. If you specify a duration, you can&#39;t specify an end time. The duration must be 45 days or less. (optional)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> ClusterNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> InvalidClusterStateFault </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call gETModifyClusterMaintenanceCall(String clusterIdentifier, String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, Boolean deferMaintenance, String deferMaintenanceIdentifier, OffsetDateTime deferMaintenanceStartTime, OffsetDateTime deferMaintenanceEndTime, Integer deferMaintenanceDuration, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/#Action=ModifyClusterMaintenance";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (clusterIdentifier != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("ClusterIdentifier", clusterIdentifier));
        }

        if (deferMaintenance != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("DeferMaintenance", deferMaintenance));
        }

        if (deferMaintenanceIdentifier != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("DeferMaintenanceIdentifier", deferMaintenanceIdentifier));
        }

        if (deferMaintenanceStartTime != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("DeferMaintenanceStartTime", deferMaintenanceStartTime));
        }

        if (deferMaintenanceEndTime != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("DeferMaintenanceEndTime", deferMaintenanceEndTime));
        }

        if (deferMaintenanceDuration != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("DeferMaintenanceDuration", deferMaintenanceDuration));
        }

        if (action != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("Action", action));
        }

        if (version != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("Version", version));
        }

        if (xAmzContentSha256 != null) {
            localVarHeaderParams.put("X-Amz-Content-Sha256", localVarApiClient.parameterToString(xAmzContentSha256));
        }

        if (xAmzDate != null) {
            localVarHeaderParams.put("X-Amz-Date", localVarApiClient.parameterToString(xAmzDate));
        }

        if (xAmzAlgorithm != null) {
            localVarHeaderParams.put("X-Amz-Algorithm", localVarApiClient.parameterToString(xAmzAlgorithm));
        }

        if (xAmzCredential != null) {
            localVarHeaderParams.put("X-Amz-Credential", localVarApiClient.parameterToString(xAmzCredential));
        }

        if (xAmzSecurityToken != null) {
            localVarHeaderParams.put("X-Amz-Security-Token", localVarApiClient.parameterToString(xAmzSecurityToken));
        }

        if (xAmzSignature != null) {
            localVarHeaderParams.put("X-Amz-Signature", localVarApiClient.parameterToString(xAmzSignature));
        }

        if (xAmzSignedHeaders != null) {
            localVarHeaderParams.put("X-Amz-SignedHeaders", localVarApiClient.parameterToString(xAmzSignedHeaders));
        }

        final String[] localVarAccepts = {
            "text/xml"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "hmac" };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call gETModifyClusterMaintenanceValidateBeforeCall(String clusterIdentifier, String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, Boolean deferMaintenance, String deferMaintenanceIdentifier, OffsetDateTime deferMaintenanceStartTime, OffsetDateTime deferMaintenanceEndTime, Integer deferMaintenanceDuration, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'clusterIdentifier' is set
        if (clusterIdentifier == null) {
            throw new ApiException("Missing the required parameter 'clusterIdentifier' when calling gETModifyClusterMaintenance(Async)");
        }

        // verify the required parameter 'action' is set
        if (action == null) {
            throw new ApiException("Missing the required parameter 'action' when calling gETModifyClusterMaintenance(Async)");
        }

        // verify the required parameter 'version' is set
        if (version == null) {
            throw new ApiException("Missing the required parameter 'version' when calling gETModifyClusterMaintenance(Async)");
        }

        return gETModifyClusterMaintenanceCall(clusterIdentifier, action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, deferMaintenance, deferMaintenanceIdentifier, deferMaintenanceStartTime, deferMaintenanceEndTime, deferMaintenanceDuration, _callback);

    }

    /**
     * 
     * Modifies the maintenance settings of a cluster.
     * @param clusterIdentifier A unique identifier for the cluster. (required)
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param deferMaintenance A boolean indicating whether to enable the deferred maintenance window.  (optional)
     * @param deferMaintenanceIdentifier A unique identifier for the deferred maintenance window. (optional)
     * @param deferMaintenanceStartTime A timestamp indicating the start time for the deferred maintenance window. (optional)
     * @param deferMaintenanceEndTime A timestamp indicating end time for the deferred maintenance window. If you specify an end time, you can&#39;t specify a duration. (optional)
     * @param deferMaintenanceDuration An integer indicating the duration of the maintenance window in days. If you specify a duration, you can&#39;t specify an end time. The duration must be 45 days or less. (optional)
     * @return ModifyClusterMaintenanceResult
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> ClusterNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> InvalidClusterStateFault </td><td>  -  </td></tr>
     </table>
     */
    public ModifyClusterMaintenanceResult gETModifyClusterMaintenance(String clusterIdentifier, String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, Boolean deferMaintenance, String deferMaintenanceIdentifier, OffsetDateTime deferMaintenanceStartTime, OffsetDateTime deferMaintenanceEndTime, Integer deferMaintenanceDuration) throws ApiException {
        ApiResponse<ModifyClusterMaintenanceResult> localVarResp = gETModifyClusterMaintenanceWithHttpInfo(clusterIdentifier, action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, deferMaintenance, deferMaintenanceIdentifier, deferMaintenanceStartTime, deferMaintenanceEndTime, deferMaintenanceDuration);
        return localVarResp.getData();
    }

    /**
     * 
     * Modifies the maintenance settings of a cluster.
     * @param clusterIdentifier A unique identifier for the cluster. (required)
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param deferMaintenance A boolean indicating whether to enable the deferred maintenance window.  (optional)
     * @param deferMaintenanceIdentifier A unique identifier for the deferred maintenance window. (optional)
     * @param deferMaintenanceStartTime A timestamp indicating the start time for the deferred maintenance window. (optional)
     * @param deferMaintenanceEndTime A timestamp indicating end time for the deferred maintenance window. If you specify an end time, you can&#39;t specify a duration. (optional)
     * @param deferMaintenanceDuration An integer indicating the duration of the maintenance window in days. If you specify a duration, you can&#39;t specify an end time. The duration must be 45 days or less. (optional)
     * @return ApiResponse&lt;ModifyClusterMaintenanceResult&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> ClusterNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> InvalidClusterStateFault </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<ModifyClusterMaintenanceResult> gETModifyClusterMaintenanceWithHttpInfo(String clusterIdentifier, String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, Boolean deferMaintenance, String deferMaintenanceIdentifier, OffsetDateTime deferMaintenanceStartTime, OffsetDateTime deferMaintenanceEndTime, Integer deferMaintenanceDuration) throws ApiException {
        okhttp3.Call localVarCall = gETModifyClusterMaintenanceValidateBeforeCall(clusterIdentifier, action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, deferMaintenance, deferMaintenanceIdentifier, deferMaintenanceStartTime, deferMaintenanceEndTime, deferMaintenanceDuration, null);
        Type localVarReturnType = new TypeToken<ModifyClusterMaintenanceResult>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     *  (asynchronously)
     * Modifies the maintenance settings of a cluster.
     * @param clusterIdentifier A unique identifier for the cluster. (required)
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param deferMaintenance A boolean indicating whether to enable the deferred maintenance window.  (optional)
     * @param deferMaintenanceIdentifier A unique identifier for the deferred maintenance window. (optional)
     * @param deferMaintenanceStartTime A timestamp indicating the start time for the deferred maintenance window. (optional)
     * @param deferMaintenanceEndTime A timestamp indicating end time for the deferred maintenance window. If you specify an end time, you can&#39;t specify a duration. (optional)
     * @param deferMaintenanceDuration An integer indicating the duration of the maintenance window in days. If you specify a duration, you can&#39;t specify an end time. The duration must be 45 days or less. (optional)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> ClusterNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> InvalidClusterStateFault </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call gETModifyClusterMaintenanceAsync(String clusterIdentifier, String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, Boolean deferMaintenance, String deferMaintenanceIdentifier, OffsetDateTime deferMaintenanceStartTime, OffsetDateTime deferMaintenanceEndTime, Integer deferMaintenanceDuration, final ApiCallback<ModifyClusterMaintenanceResult> _callback) throws ApiException {

        okhttp3.Call localVarCall = gETModifyClusterMaintenanceValidateBeforeCall(clusterIdentifier, action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, deferMaintenance, deferMaintenanceIdentifier, deferMaintenanceStartTime, deferMaintenanceEndTime, deferMaintenanceDuration, _callback);
        Type localVarReturnType = new TypeToken<ModifyClusterMaintenanceResult>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for gETModifyClusterParameterGroup
     * @param parameterGroupName The name of the parameter group to be modified. (required)
     * @param parameters &lt;p&gt;An array of parameters to be modified. A maximum of 20 parameters can be modified in a single request.&lt;/p&gt; &lt;p&gt;For each parameter to be modified, you must supply at least the parameter name and parameter value; other name-value pairs of the parameter are optional.&lt;/p&gt; &lt;p&gt;For the workload management (WLM) configuration, you must supply all the name-value pairs in the wlm_json_configuration parameter.&lt;/p&gt; (required)
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> ClusterParameterGroupNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> InvalidClusterParameterGroupStateFault </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call gETModifyClusterParameterGroupCall(String parameterGroupName, List<GETModifyClusterParameterGroupParametersParameterInner> parameters, String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/#Action=ModifyClusterParameterGroup";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (parameterGroupName != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("ParameterGroupName", parameterGroupName));
        }

        if (parameters != null) {
            localVarCollectionQueryParams.addAll(localVarApiClient.parameterToPairs("multi", "Parameters", parameters));
        }

        if (action != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("Action", action));
        }

        if (version != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("Version", version));
        }

        if (xAmzContentSha256 != null) {
            localVarHeaderParams.put("X-Amz-Content-Sha256", localVarApiClient.parameterToString(xAmzContentSha256));
        }

        if (xAmzDate != null) {
            localVarHeaderParams.put("X-Amz-Date", localVarApiClient.parameterToString(xAmzDate));
        }

        if (xAmzAlgorithm != null) {
            localVarHeaderParams.put("X-Amz-Algorithm", localVarApiClient.parameterToString(xAmzAlgorithm));
        }

        if (xAmzCredential != null) {
            localVarHeaderParams.put("X-Amz-Credential", localVarApiClient.parameterToString(xAmzCredential));
        }

        if (xAmzSecurityToken != null) {
            localVarHeaderParams.put("X-Amz-Security-Token", localVarApiClient.parameterToString(xAmzSecurityToken));
        }

        if (xAmzSignature != null) {
            localVarHeaderParams.put("X-Amz-Signature", localVarApiClient.parameterToString(xAmzSignature));
        }

        if (xAmzSignedHeaders != null) {
            localVarHeaderParams.put("X-Amz-SignedHeaders", localVarApiClient.parameterToString(xAmzSignedHeaders));
        }

        final String[] localVarAccepts = {
            "text/xml"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "hmac" };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call gETModifyClusterParameterGroupValidateBeforeCall(String parameterGroupName, List<GETModifyClusterParameterGroupParametersParameterInner> parameters, String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'parameterGroupName' is set
        if (parameterGroupName == null) {
            throw new ApiException("Missing the required parameter 'parameterGroupName' when calling gETModifyClusterParameterGroup(Async)");
        }

        // verify the required parameter 'parameters' is set
        if (parameters == null) {
            throw new ApiException("Missing the required parameter 'parameters' when calling gETModifyClusterParameterGroup(Async)");
        }

        // verify the required parameter 'action' is set
        if (action == null) {
            throw new ApiException("Missing the required parameter 'action' when calling gETModifyClusterParameterGroup(Async)");
        }

        // verify the required parameter 'version' is set
        if (version == null) {
            throw new ApiException("Missing the required parameter 'version' when calling gETModifyClusterParameterGroup(Async)");
        }

        return gETModifyClusterParameterGroupCall(parameterGroupName, parameters, action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, _callback);

    }

    /**
     * 
     * &lt;p&gt;Modifies the parameters of a parameter group. For the parameters parameter, it can&#39;t contain ASCII characters.&lt;/p&gt; &lt;p&gt; For more information about parameters and parameter groups, go to &lt;a href&#x3D;\&quot;https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-parameter-groups.html\&quot;&gt;Amazon Redshift Parameter Groups&lt;/a&gt; in the &lt;i&gt;Amazon Redshift Cluster Management Guide&lt;/i&gt;.&lt;/p&gt;
     * @param parameterGroupName The name of the parameter group to be modified. (required)
     * @param parameters &lt;p&gt;An array of parameters to be modified. A maximum of 20 parameters can be modified in a single request.&lt;/p&gt; &lt;p&gt;For each parameter to be modified, you must supply at least the parameter name and parameter value; other name-value pairs of the parameter are optional.&lt;/p&gt; &lt;p&gt;For the workload management (WLM) configuration, you must supply all the name-value pairs in the wlm_json_configuration parameter.&lt;/p&gt; (required)
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @return ClusterParameterGroupNameMessage
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> ClusterParameterGroupNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> InvalidClusterParameterGroupStateFault </td><td>  -  </td></tr>
     </table>
     */
    public ClusterParameterGroupNameMessage gETModifyClusterParameterGroup(String parameterGroupName, List<GETModifyClusterParameterGroupParametersParameterInner> parameters, String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders) throws ApiException {
        ApiResponse<ClusterParameterGroupNameMessage> localVarResp = gETModifyClusterParameterGroupWithHttpInfo(parameterGroupName, parameters, action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders);
        return localVarResp.getData();
    }

    /**
     * 
     * &lt;p&gt;Modifies the parameters of a parameter group. For the parameters parameter, it can&#39;t contain ASCII characters.&lt;/p&gt; &lt;p&gt; For more information about parameters and parameter groups, go to &lt;a href&#x3D;\&quot;https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-parameter-groups.html\&quot;&gt;Amazon Redshift Parameter Groups&lt;/a&gt; in the &lt;i&gt;Amazon Redshift Cluster Management Guide&lt;/i&gt;.&lt;/p&gt;
     * @param parameterGroupName The name of the parameter group to be modified. (required)
     * @param parameters &lt;p&gt;An array of parameters to be modified. A maximum of 20 parameters can be modified in a single request.&lt;/p&gt; &lt;p&gt;For each parameter to be modified, you must supply at least the parameter name and parameter value; other name-value pairs of the parameter are optional.&lt;/p&gt; &lt;p&gt;For the workload management (WLM) configuration, you must supply all the name-value pairs in the wlm_json_configuration parameter.&lt;/p&gt; (required)
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @return ApiResponse&lt;ClusterParameterGroupNameMessage&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> ClusterParameterGroupNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> InvalidClusterParameterGroupStateFault </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<ClusterParameterGroupNameMessage> gETModifyClusterParameterGroupWithHttpInfo(String parameterGroupName, List<GETModifyClusterParameterGroupParametersParameterInner> parameters, String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders) throws ApiException {
        okhttp3.Call localVarCall = gETModifyClusterParameterGroupValidateBeforeCall(parameterGroupName, parameters, action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, null);
        Type localVarReturnType = new TypeToken<ClusterParameterGroupNameMessage>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     *  (asynchronously)
     * &lt;p&gt;Modifies the parameters of a parameter group. For the parameters parameter, it can&#39;t contain ASCII characters.&lt;/p&gt; &lt;p&gt; For more information about parameters and parameter groups, go to &lt;a href&#x3D;\&quot;https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-parameter-groups.html\&quot;&gt;Amazon Redshift Parameter Groups&lt;/a&gt; in the &lt;i&gt;Amazon Redshift Cluster Management Guide&lt;/i&gt;.&lt;/p&gt;
     * @param parameterGroupName The name of the parameter group to be modified. (required)
     * @param parameters &lt;p&gt;An array of parameters to be modified. A maximum of 20 parameters can be modified in a single request.&lt;/p&gt; &lt;p&gt;For each parameter to be modified, you must supply at least the parameter name and parameter value; other name-value pairs of the parameter are optional.&lt;/p&gt; &lt;p&gt;For the workload management (WLM) configuration, you must supply all the name-value pairs in the wlm_json_configuration parameter.&lt;/p&gt; (required)
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> ClusterParameterGroupNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> InvalidClusterParameterGroupStateFault </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call gETModifyClusterParameterGroupAsync(String parameterGroupName, List<GETModifyClusterParameterGroupParametersParameterInner> parameters, String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, final ApiCallback<ClusterParameterGroupNameMessage> _callback) throws ApiException {

        okhttp3.Call localVarCall = gETModifyClusterParameterGroupValidateBeforeCall(parameterGroupName, parameters, action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, _callback);
        Type localVarReturnType = new TypeToken<ClusterParameterGroupNameMessage>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for gETModifyClusterSnapshot
     * @param snapshotIdentifier The identifier of the snapshot whose setting you want to modify. (required)
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param manualSnapshotRetentionPeriod &lt;p&gt;The number of days that a manual snapshot is retained. If the value is -1, the manual snapshot is retained indefinitely.&lt;/p&gt; &lt;p&gt;If the manual snapshot falls outside of the new retention period, you can specify the force option to immediately delete the snapshot.&lt;/p&gt; &lt;p&gt;The value must be either -1 or an integer between 1 and 3,653.&lt;/p&gt; (optional)
     * @param force A Boolean option to override an exception if the retention period has already passed. (optional)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> InvalidClusterSnapshotStateFault </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> ClusterSnapshotNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 482 </td><td> InvalidRetentionPeriodFault </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call gETModifyClusterSnapshotCall(String snapshotIdentifier, String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, Integer manualSnapshotRetentionPeriod, Boolean force, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/#Action=ModifyClusterSnapshot";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (snapshotIdentifier != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("SnapshotIdentifier", snapshotIdentifier));
        }

        if (manualSnapshotRetentionPeriod != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("ManualSnapshotRetentionPeriod", manualSnapshotRetentionPeriod));
        }

        if (force != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("Force", force));
        }

        if (action != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("Action", action));
        }

        if (version != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("Version", version));
        }

        if (xAmzContentSha256 != null) {
            localVarHeaderParams.put("X-Amz-Content-Sha256", localVarApiClient.parameterToString(xAmzContentSha256));
        }

        if (xAmzDate != null) {
            localVarHeaderParams.put("X-Amz-Date", localVarApiClient.parameterToString(xAmzDate));
        }

        if (xAmzAlgorithm != null) {
            localVarHeaderParams.put("X-Amz-Algorithm", localVarApiClient.parameterToString(xAmzAlgorithm));
        }

        if (xAmzCredential != null) {
            localVarHeaderParams.put("X-Amz-Credential", localVarApiClient.parameterToString(xAmzCredential));
        }

        if (xAmzSecurityToken != null) {
            localVarHeaderParams.put("X-Amz-Security-Token", localVarApiClient.parameterToString(xAmzSecurityToken));
        }

        if (xAmzSignature != null) {
            localVarHeaderParams.put("X-Amz-Signature", localVarApiClient.parameterToString(xAmzSignature));
        }

        if (xAmzSignedHeaders != null) {
            localVarHeaderParams.put("X-Amz-SignedHeaders", localVarApiClient.parameterToString(xAmzSignedHeaders));
        }

        final String[] localVarAccepts = {
            "text/xml"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "hmac" };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call gETModifyClusterSnapshotValidateBeforeCall(String snapshotIdentifier, String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, Integer manualSnapshotRetentionPeriod, Boolean force, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'snapshotIdentifier' is set
        if (snapshotIdentifier == null) {
            throw new ApiException("Missing the required parameter 'snapshotIdentifier' when calling gETModifyClusterSnapshot(Async)");
        }

        // verify the required parameter 'action' is set
        if (action == null) {
            throw new ApiException("Missing the required parameter 'action' when calling gETModifyClusterSnapshot(Async)");
        }

        // verify the required parameter 'version' is set
        if (version == null) {
            throw new ApiException("Missing the required parameter 'version' when calling gETModifyClusterSnapshot(Async)");
        }

        return gETModifyClusterSnapshotCall(snapshotIdentifier, action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, manualSnapshotRetentionPeriod, force, _callback);

    }

    /**
     * 
     * &lt;p&gt;Modifies the settings for a snapshot.&lt;/p&gt; &lt;p&gt;This exanmple modifies the manual retention period setting for a cluster snapshot.&lt;/p&gt;
     * @param snapshotIdentifier The identifier of the snapshot whose setting you want to modify. (required)
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param manualSnapshotRetentionPeriod &lt;p&gt;The number of days that a manual snapshot is retained. If the value is -1, the manual snapshot is retained indefinitely.&lt;/p&gt; &lt;p&gt;If the manual snapshot falls outside of the new retention period, you can specify the force option to immediately delete the snapshot.&lt;/p&gt; &lt;p&gt;The value must be either -1 or an integer between 1 and 3,653.&lt;/p&gt; (optional)
     * @param force A Boolean option to override an exception if the retention period has already passed. (optional)
     * @return ModifyClusterSnapshotResult
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> InvalidClusterSnapshotStateFault </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> ClusterSnapshotNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 482 </td><td> InvalidRetentionPeriodFault </td><td>  -  </td></tr>
     </table>
     */
    public ModifyClusterSnapshotResult gETModifyClusterSnapshot(String snapshotIdentifier, String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, Integer manualSnapshotRetentionPeriod, Boolean force) throws ApiException {
        ApiResponse<ModifyClusterSnapshotResult> localVarResp = gETModifyClusterSnapshotWithHttpInfo(snapshotIdentifier, action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, manualSnapshotRetentionPeriod, force);
        return localVarResp.getData();
    }

    /**
     * 
     * &lt;p&gt;Modifies the settings for a snapshot.&lt;/p&gt; &lt;p&gt;This exanmple modifies the manual retention period setting for a cluster snapshot.&lt;/p&gt;
     * @param snapshotIdentifier The identifier of the snapshot whose setting you want to modify. (required)
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param manualSnapshotRetentionPeriod &lt;p&gt;The number of days that a manual snapshot is retained. If the value is -1, the manual snapshot is retained indefinitely.&lt;/p&gt; &lt;p&gt;If the manual snapshot falls outside of the new retention period, you can specify the force option to immediately delete the snapshot.&lt;/p&gt; &lt;p&gt;The value must be either -1 or an integer between 1 and 3,653.&lt;/p&gt; (optional)
     * @param force A Boolean option to override an exception if the retention period has already passed. (optional)
     * @return ApiResponse&lt;ModifyClusterSnapshotResult&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> InvalidClusterSnapshotStateFault </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> ClusterSnapshotNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 482 </td><td> InvalidRetentionPeriodFault </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<ModifyClusterSnapshotResult> gETModifyClusterSnapshotWithHttpInfo(String snapshotIdentifier, String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, Integer manualSnapshotRetentionPeriod, Boolean force) throws ApiException {
        okhttp3.Call localVarCall = gETModifyClusterSnapshotValidateBeforeCall(snapshotIdentifier, action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, manualSnapshotRetentionPeriod, force, null);
        Type localVarReturnType = new TypeToken<ModifyClusterSnapshotResult>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     *  (asynchronously)
     * &lt;p&gt;Modifies the settings for a snapshot.&lt;/p&gt; &lt;p&gt;This exanmple modifies the manual retention period setting for a cluster snapshot.&lt;/p&gt;
     * @param snapshotIdentifier The identifier of the snapshot whose setting you want to modify. (required)
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param manualSnapshotRetentionPeriod &lt;p&gt;The number of days that a manual snapshot is retained. If the value is -1, the manual snapshot is retained indefinitely.&lt;/p&gt; &lt;p&gt;If the manual snapshot falls outside of the new retention period, you can specify the force option to immediately delete the snapshot.&lt;/p&gt; &lt;p&gt;The value must be either -1 or an integer between 1 and 3,653.&lt;/p&gt; (optional)
     * @param force A Boolean option to override an exception if the retention period has already passed. (optional)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> InvalidClusterSnapshotStateFault </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> ClusterSnapshotNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 482 </td><td> InvalidRetentionPeriodFault </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call gETModifyClusterSnapshotAsync(String snapshotIdentifier, String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, Integer manualSnapshotRetentionPeriod, Boolean force, final ApiCallback<ModifyClusterSnapshotResult> _callback) throws ApiException {

        okhttp3.Call localVarCall = gETModifyClusterSnapshotValidateBeforeCall(snapshotIdentifier, action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, manualSnapshotRetentionPeriod, force, _callback);
        Type localVarReturnType = new TypeToken<ModifyClusterSnapshotResult>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for gETModifyClusterSnapshotSchedule
     * @param clusterIdentifier A unique identifier for the cluster whose snapshot schedule you want to modify.  (required)
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param scheduleIdentifier A unique alphanumeric identifier for the schedule that you want to associate with the cluster. (optional)
     * @param disassociateSchedule A boolean to indicate whether to remove the assoiciation between the cluster and the schedule. (optional)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> ClusterNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> SnapshotScheduleNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 482 </td><td> InvalidClusterSnapshotScheduleStateFault </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call gETModifyClusterSnapshotScheduleCall(String clusterIdentifier, String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, String scheduleIdentifier, Boolean disassociateSchedule, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/#Action=ModifyClusterSnapshotSchedule";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (clusterIdentifier != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("ClusterIdentifier", clusterIdentifier));
        }

        if (scheduleIdentifier != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("ScheduleIdentifier", scheduleIdentifier));
        }

        if (disassociateSchedule != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("DisassociateSchedule", disassociateSchedule));
        }

        if (action != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("Action", action));
        }

        if (version != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("Version", version));
        }

        if (xAmzContentSha256 != null) {
            localVarHeaderParams.put("X-Amz-Content-Sha256", localVarApiClient.parameterToString(xAmzContentSha256));
        }

        if (xAmzDate != null) {
            localVarHeaderParams.put("X-Amz-Date", localVarApiClient.parameterToString(xAmzDate));
        }

        if (xAmzAlgorithm != null) {
            localVarHeaderParams.put("X-Amz-Algorithm", localVarApiClient.parameterToString(xAmzAlgorithm));
        }

        if (xAmzCredential != null) {
            localVarHeaderParams.put("X-Amz-Credential", localVarApiClient.parameterToString(xAmzCredential));
        }

        if (xAmzSecurityToken != null) {
            localVarHeaderParams.put("X-Amz-Security-Token", localVarApiClient.parameterToString(xAmzSecurityToken));
        }

        if (xAmzSignature != null) {
            localVarHeaderParams.put("X-Amz-Signature", localVarApiClient.parameterToString(xAmzSignature));
        }

        if (xAmzSignedHeaders != null) {
            localVarHeaderParams.put("X-Amz-SignedHeaders", localVarApiClient.parameterToString(xAmzSignedHeaders));
        }

        final String[] localVarAccepts = {
            "text/xml"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "hmac" };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call gETModifyClusterSnapshotScheduleValidateBeforeCall(String clusterIdentifier, String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, String scheduleIdentifier, Boolean disassociateSchedule, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'clusterIdentifier' is set
        if (clusterIdentifier == null) {
            throw new ApiException("Missing the required parameter 'clusterIdentifier' when calling gETModifyClusterSnapshotSchedule(Async)");
        }

        // verify the required parameter 'action' is set
        if (action == null) {
            throw new ApiException("Missing the required parameter 'action' when calling gETModifyClusterSnapshotSchedule(Async)");
        }

        // verify the required parameter 'version' is set
        if (version == null) {
            throw new ApiException("Missing the required parameter 'version' when calling gETModifyClusterSnapshotSchedule(Async)");
        }

        return gETModifyClusterSnapshotScheduleCall(clusterIdentifier, action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, scheduleIdentifier, disassociateSchedule, _callback);

    }

    /**
     * 
     * Modifies a snapshot schedule for a cluster.
     * @param clusterIdentifier A unique identifier for the cluster whose snapshot schedule you want to modify.  (required)
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param scheduleIdentifier A unique alphanumeric identifier for the schedule that you want to associate with the cluster. (optional)
     * @param disassociateSchedule A boolean to indicate whether to remove the assoiciation between the cluster and the schedule. (optional)
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> ClusterNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> SnapshotScheduleNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 482 </td><td> InvalidClusterSnapshotScheduleStateFault </td><td>  -  </td></tr>
     </table>
     */
    public void gETModifyClusterSnapshotSchedule(String clusterIdentifier, String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, String scheduleIdentifier, Boolean disassociateSchedule) throws ApiException {
        gETModifyClusterSnapshotScheduleWithHttpInfo(clusterIdentifier, action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, scheduleIdentifier, disassociateSchedule);
    }

    /**
     * 
     * Modifies a snapshot schedule for a cluster.
     * @param clusterIdentifier A unique identifier for the cluster whose snapshot schedule you want to modify.  (required)
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param scheduleIdentifier A unique alphanumeric identifier for the schedule that you want to associate with the cluster. (optional)
     * @param disassociateSchedule A boolean to indicate whether to remove the assoiciation between the cluster and the schedule. (optional)
     * @return ApiResponse&lt;Void&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> ClusterNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> SnapshotScheduleNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 482 </td><td> InvalidClusterSnapshotScheduleStateFault </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<Void> gETModifyClusterSnapshotScheduleWithHttpInfo(String clusterIdentifier, String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, String scheduleIdentifier, Boolean disassociateSchedule) throws ApiException {
        okhttp3.Call localVarCall = gETModifyClusterSnapshotScheduleValidateBeforeCall(clusterIdentifier, action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, scheduleIdentifier, disassociateSchedule, null);
        return localVarApiClient.execute(localVarCall);
    }

    /**
     *  (asynchronously)
     * Modifies a snapshot schedule for a cluster.
     * @param clusterIdentifier A unique identifier for the cluster whose snapshot schedule you want to modify.  (required)
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param scheduleIdentifier A unique alphanumeric identifier for the schedule that you want to associate with the cluster. (optional)
     * @param disassociateSchedule A boolean to indicate whether to remove the assoiciation between the cluster and the schedule. (optional)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> ClusterNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> SnapshotScheduleNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 482 </td><td> InvalidClusterSnapshotScheduleStateFault </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call gETModifyClusterSnapshotScheduleAsync(String clusterIdentifier, String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, String scheduleIdentifier, Boolean disassociateSchedule, final ApiCallback<Void> _callback) throws ApiException {

        okhttp3.Call localVarCall = gETModifyClusterSnapshotScheduleValidateBeforeCall(clusterIdentifier, action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, scheduleIdentifier, disassociateSchedule, _callback);
        localVarApiClient.executeAsync(localVarCall, _callback);
        return localVarCall;
    }
    /**
     * Build call for gETModifyClusterSubnetGroup
     * @param clusterSubnetGroupName The name of the subnet group to be modified. (required)
     * @param subnetIds An array of VPC subnet IDs. A maximum of 20 subnets can be modified in a single request. (required)
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param description A text description of the subnet group to be modified. (optional)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> ClusterSubnetGroupNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> ClusterSubnetQuotaExceededFault </td><td>  -  </td></tr>
        <tr><td> 482 </td><td> SubnetAlreadyInUse </td><td>  -  </td></tr>
        <tr><td> 483 </td><td> InvalidSubnet </td><td>  -  </td></tr>
        <tr><td> 484 </td><td> UnauthorizedOperation </td><td>  -  </td></tr>
        <tr><td> 485 </td><td> DependentServiceRequestThrottlingFault </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call gETModifyClusterSubnetGroupCall(String clusterSubnetGroupName, List<String> subnetIds, String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, String description, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/#Action=ModifyClusterSubnetGroup";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (clusterSubnetGroupName != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("ClusterSubnetGroupName", clusterSubnetGroupName));
        }

        if (description != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("Description", description));
        }

        if (subnetIds != null) {
            localVarCollectionQueryParams.addAll(localVarApiClient.parameterToPairs("multi", "SubnetIds", subnetIds));
        }

        if (action != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("Action", action));
        }

        if (version != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("Version", version));
        }

        if (xAmzContentSha256 != null) {
            localVarHeaderParams.put("X-Amz-Content-Sha256", localVarApiClient.parameterToString(xAmzContentSha256));
        }

        if (xAmzDate != null) {
            localVarHeaderParams.put("X-Amz-Date", localVarApiClient.parameterToString(xAmzDate));
        }

        if (xAmzAlgorithm != null) {
            localVarHeaderParams.put("X-Amz-Algorithm", localVarApiClient.parameterToString(xAmzAlgorithm));
        }

        if (xAmzCredential != null) {
            localVarHeaderParams.put("X-Amz-Credential", localVarApiClient.parameterToString(xAmzCredential));
        }

        if (xAmzSecurityToken != null) {
            localVarHeaderParams.put("X-Amz-Security-Token", localVarApiClient.parameterToString(xAmzSecurityToken));
        }

        if (xAmzSignature != null) {
            localVarHeaderParams.put("X-Amz-Signature", localVarApiClient.parameterToString(xAmzSignature));
        }

        if (xAmzSignedHeaders != null) {
            localVarHeaderParams.put("X-Amz-SignedHeaders", localVarApiClient.parameterToString(xAmzSignedHeaders));
        }

        final String[] localVarAccepts = {
            "text/xml"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "hmac" };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call gETModifyClusterSubnetGroupValidateBeforeCall(String clusterSubnetGroupName, List<String> subnetIds, String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, String description, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'clusterSubnetGroupName' is set
        if (clusterSubnetGroupName == null) {
            throw new ApiException("Missing the required parameter 'clusterSubnetGroupName' when calling gETModifyClusterSubnetGroup(Async)");
        }

        // verify the required parameter 'subnetIds' is set
        if (subnetIds == null) {
            throw new ApiException("Missing the required parameter 'subnetIds' when calling gETModifyClusterSubnetGroup(Async)");
        }

        // verify the required parameter 'action' is set
        if (action == null) {
            throw new ApiException("Missing the required parameter 'action' when calling gETModifyClusterSubnetGroup(Async)");
        }

        // verify the required parameter 'version' is set
        if (version == null) {
            throw new ApiException("Missing the required parameter 'version' when calling gETModifyClusterSubnetGroup(Async)");
        }

        return gETModifyClusterSubnetGroupCall(clusterSubnetGroupName, subnetIds, action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, description, _callback);

    }

    /**
     * 
     * Modifies a cluster subnet group to include the specified list of VPC subnets. The operation replaces the existing list of subnets with the new list of subnets.
     * @param clusterSubnetGroupName The name of the subnet group to be modified. (required)
     * @param subnetIds An array of VPC subnet IDs. A maximum of 20 subnets can be modified in a single request. (required)
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param description A text description of the subnet group to be modified. (optional)
     * @return ModifyClusterSubnetGroupResult
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> ClusterSubnetGroupNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> ClusterSubnetQuotaExceededFault </td><td>  -  </td></tr>
        <tr><td> 482 </td><td> SubnetAlreadyInUse </td><td>  -  </td></tr>
        <tr><td> 483 </td><td> InvalidSubnet </td><td>  -  </td></tr>
        <tr><td> 484 </td><td> UnauthorizedOperation </td><td>  -  </td></tr>
        <tr><td> 485 </td><td> DependentServiceRequestThrottlingFault </td><td>  -  </td></tr>
     </table>
     */
    public ModifyClusterSubnetGroupResult gETModifyClusterSubnetGroup(String clusterSubnetGroupName, List<String> subnetIds, String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, String description) throws ApiException {
        ApiResponse<ModifyClusterSubnetGroupResult> localVarResp = gETModifyClusterSubnetGroupWithHttpInfo(clusterSubnetGroupName, subnetIds, action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, description);
        return localVarResp.getData();
    }

    /**
     * 
     * Modifies a cluster subnet group to include the specified list of VPC subnets. The operation replaces the existing list of subnets with the new list of subnets.
     * @param clusterSubnetGroupName The name of the subnet group to be modified. (required)
     * @param subnetIds An array of VPC subnet IDs. A maximum of 20 subnets can be modified in a single request. (required)
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param description A text description of the subnet group to be modified. (optional)
     * @return ApiResponse&lt;ModifyClusterSubnetGroupResult&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> ClusterSubnetGroupNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> ClusterSubnetQuotaExceededFault </td><td>  -  </td></tr>
        <tr><td> 482 </td><td> SubnetAlreadyInUse </td><td>  -  </td></tr>
        <tr><td> 483 </td><td> InvalidSubnet </td><td>  -  </td></tr>
        <tr><td> 484 </td><td> UnauthorizedOperation </td><td>  -  </td></tr>
        <tr><td> 485 </td><td> DependentServiceRequestThrottlingFault </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<ModifyClusterSubnetGroupResult> gETModifyClusterSubnetGroupWithHttpInfo(String clusterSubnetGroupName, List<String> subnetIds, String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, String description) throws ApiException {
        okhttp3.Call localVarCall = gETModifyClusterSubnetGroupValidateBeforeCall(clusterSubnetGroupName, subnetIds, action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, description, null);
        Type localVarReturnType = new TypeToken<ModifyClusterSubnetGroupResult>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     *  (asynchronously)
     * Modifies a cluster subnet group to include the specified list of VPC subnets. The operation replaces the existing list of subnets with the new list of subnets.
     * @param clusterSubnetGroupName The name of the subnet group to be modified. (required)
     * @param subnetIds An array of VPC subnet IDs. A maximum of 20 subnets can be modified in a single request. (required)
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param description A text description of the subnet group to be modified. (optional)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> ClusterSubnetGroupNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> ClusterSubnetQuotaExceededFault </td><td>  -  </td></tr>
        <tr><td> 482 </td><td> SubnetAlreadyInUse </td><td>  -  </td></tr>
        <tr><td> 483 </td><td> InvalidSubnet </td><td>  -  </td></tr>
        <tr><td> 484 </td><td> UnauthorizedOperation </td><td>  -  </td></tr>
        <tr><td> 485 </td><td> DependentServiceRequestThrottlingFault </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call gETModifyClusterSubnetGroupAsync(String clusterSubnetGroupName, List<String> subnetIds, String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, String description, final ApiCallback<ModifyClusterSubnetGroupResult> _callback) throws ApiException {

        okhttp3.Call localVarCall = gETModifyClusterSubnetGroupValidateBeforeCall(clusterSubnetGroupName, subnetIds, action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, description, _callback);
        Type localVarReturnType = new TypeToken<ModifyClusterSubnetGroupResult>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for gETModifyCustomDomainAssociation
     * @param clusterIdentifier The identifier of the cluster to change a custom domain association for. (required)
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param customDomainName The custom domain name for a changed custom domain association. (optional)
     * @param customDomainCertificateArn The certificate Amazon Resource Name (ARN) for the changed custom domain association. (optional)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> UnsupportedOperationFault </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> ClusterNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 482 </td><td> CustomCnameAssociationFault </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call gETModifyCustomDomainAssociationCall(String clusterIdentifier, String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, String customDomainName, String customDomainCertificateArn, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/#Action=ModifyCustomDomainAssociation";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (customDomainName != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("CustomDomainName", customDomainName));
        }

        if (customDomainCertificateArn != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("CustomDomainCertificateArn", customDomainCertificateArn));
        }

        if (clusterIdentifier != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("ClusterIdentifier", clusterIdentifier));
        }

        if (action != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("Action", action));
        }

        if (version != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("Version", version));
        }

        if (xAmzContentSha256 != null) {
            localVarHeaderParams.put("X-Amz-Content-Sha256", localVarApiClient.parameterToString(xAmzContentSha256));
        }

        if (xAmzDate != null) {
            localVarHeaderParams.put("X-Amz-Date", localVarApiClient.parameterToString(xAmzDate));
        }

        if (xAmzAlgorithm != null) {
            localVarHeaderParams.put("X-Amz-Algorithm", localVarApiClient.parameterToString(xAmzAlgorithm));
        }

        if (xAmzCredential != null) {
            localVarHeaderParams.put("X-Amz-Credential", localVarApiClient.parameterToString(xAmzCredential));
        }

        if (xAmzSecurityToken != null) {
            localVarHeaderParams.put("X-Amz-Security-Token", localVarApiClient.parameterToString(xAmzSecurityToken));
        }

        if (xAmzSignature != null) {
            localVarHeaderParams.put("X-Amz-Signature", localVarApiClient.parameterToString(xAmzSignature));
        }

        if (xAmzSignedHeaders != null) {
            localVarHeaderParams.put("X-Amz-SignedHeaders", localVarApiClient.parameterToString(xAmzSignedHeaders));
        }

        final String[] localVarAccepts = {
            "text/xml"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "hmac" };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call gETModifyCustomDomainAssociationValidateBeforeCall(String clusterIdentifier, String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, String customDomainName, String customDomainCertificateArn, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'clusterIdentifier' is set
        if (clusterIdentifier == null) {
            throw new ApiException("Missing the required parameter 'clusterIdentifier' when calling gETModifyCustomDomainAssociation(Async)");
        }

        // verify the required parameter 'action' is set
        if (action == null) {
            throw new ApiException("Missing the required parameter 'action' when calling gETModifyCustomDomainAssociation(Async)");
        }

        // verify the required parameter 'version' is set
        if (version == null) {
            throw new ApiException("Missing the required parameter 'version' when calling gETModifyCustomDomainAssociation(Async)");
        }

        return gETModifyCustomDomainAssociationCall(clusterIdentifier, action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, customDomainName, customDomainCertificateArn, _callback);

    }

    /**
     * 
     * Contains information for changing a custom domain association.
     * @param clusterIdentifier The identifier of the cluster to change a custom domain association for. (required)
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param customDomainName The custom domain name for a changed custom domain association. (optional)
     * @param customDomainCertificateArn The certificate Amazon Resource Name (ARN) for the changed custom domain association. (optional)
     * @return ModifyCustomDomainAssociationResult
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> UnsupportedOperationFault </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> ClusterNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 482 </td><td> CustomCnameAssociationFault </td><td>  -  </td></tr>
     </table>
     */
    public ModifyCustomDomainAssociationResult gETModifyCustomDomainAssociation(String clusterIdentifier, String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, String customDomainName, String customDomainCertificateArn) throws ApiException {
        ApiResponse<ModifyCustomDomainAssociationResult> localVarResp = gETModifyCustomDomainAssociationWithHttpInfo(clusterIdentifier, action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, customDomainName, customDomainCertificateArn);
        return localVarResp.getData();
    }

    /**
     * 
     * Contains information for changing a custom domain association.
     * @param clusterIdentifier The identifier of the cluster to change a custom domain association for. (required)
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param customDomainName The custom domain name for a changed custom domain association. (optional)
     * @param customDomainCertificateArn The certificate Amazon Resource Name (ARN) for the changed custom domain association. (optional)
     * @return ApiResponse&lt;ModifyCustomDomainAssociationResult&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> UnsupportedOperationFault </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> ClusterNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 482 </td><td> CustomCnameAssociationFault </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<ModifyCustomDomainAssociationResult> gETModifyCustomDomainAssociationWithHttpInfo(String clusterIdentifier, String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, String customDomainName, String customDomainCertificateArn) throws ApiException {
        okhttp3.Call localVarCall = gETModifyCustomDomainAssociationValidateBeforeCall(clusterIdentifier, action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, customDomainName, customDomainCertificateArn, null);
        Type localVarReturnType = new TypeToken<ModifyCustomDomainAssociationResult>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     *  (asynchronously)
     * Contains information for changing a custom domain association.
     * @param clusterIdentifier The identifier of the cluster to change a custom domain association for. (required)
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param customDomainName The custom domain name for a changed custom domain association. (optional)
     * @param customDomainCertificateArn The certificate Amazon Resource Name (ARN) for the changed custom domain association. (optional)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> UnsupportedOperationFault </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> ClusterNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 482 </td><td> CustomCnameAssociationFault </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call gETModifyCustomDomainAssociationAsync(String clusterIdentifier, String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, String customDomainName, String customDomainCertificateArn, final ApiCallback<ModifyCustomDomainAssociationResult> _callback) throws ApiException {

        okhttp3.Call localVarCall = gETModifyCustomDomainAssociationValidateBeforeCall(clusterIdentifier, action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, customDomainName, customDomainCertificateArn, _callback);
        Type localVarReturnType = new TypeToken<ModifyCustomDomainAssociationResult>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for gETModifyEndpointAccess
     * @param endpointName The endpoint to be modified. (required)
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param vpcSecurityGroupIds The complete list of VPC security groups associated with the endpoint after the endpoint is modified. (optional)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> InvalidClusterSecurityGroupStateFault </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> ClusterNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 482 </td><td> InvalidEndpointStateFault </td><td>  -  </td></tr>
        <tr><td> 483 </td><td> EndpointNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 484 </td><td> InvalidClusterStateFault </td><td>  -  </td></tr>
        <tr><td> 485 </td><td> UnauthorizedOperation </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call gETModifyEndpointAccessCall(String endpointName, String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, List<String> vpcSecurityGroupIds, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/#Action=ModifyEndpointAccess";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (endpointName != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("EndpointName", endpointName));
        }

        if (vpcSecurityGroupIds != null) {
            localVarCollectionQueryParams.addAll(localVarApiClient.parameterToPairs("multi", "VpcSecurityGroupIds", vpcSecurityGroupIds));
        }

        if (action != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("Action", action));
        }

        if (version != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("Version", version));
        }

        if (xAmzContentSha256 != null) {
            localVarHeaderParams.put("X-Amz-Content-Sha256", localVarApiClient.parameterToString(xAmzContentSha256));
        }

        if (xAmzDate != null) {
            localVarHeaderParams.put("X-Amz-Date", localVarApiClient.parameterToString(xAmzDate));
        }

        if (xAmzAlgorithm != null) {
            localVarHeaderParams.put("X-Amz-Algorithm", localVarApiClient.parameterToString(xAmzAlgorithm));
        }

        if (xAmzCredential != null) {
            localVarHeaderParams.put("X-Amz-Credential", localVarApiClient.parameterToString(xAmzCredential));
        }

        if (xAmzSecurityToken != null) {
            localVarHeaderParams.put("X-Amz-Security-Token", localVarApiClient.parameterToString(xAmzSecurityToken));
        }

        if (xAmzSignature != null) {
            localVarHeaderParams.put("X-Amz-Signature", localVarApiClient.parameterToString(xAmzSignature));
        }

        if (xAmzSignedHeaders != null) {
            localVarHeaderParams.put("X-Amz-SignedHeaders", localVarApiClient.parameterToString(xAmzSignedHeaders));
        }

        final String[] localVarAccepts = {
            "text/xml"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "hmac" };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call gETModifyEndpointAccessValidateBeforeCall(String endpointName, String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, List<String> vpcSecurityGroupIds, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'endpointName' is set
        if (endpointName == null) {
            throw new ApiException("Missing the required parameter 'endpointName' when calling gETModifyEndpointAccess(Async)");
        }

        // verify the required parameter 'action' is set
        if (action == null) {
            throw new ApiException("Missing the required parameter 'action' when calling gETModifyEndpointAccess(Async)");
        }

        // verify the required parameter 'version' is set
        if (version == null) {
            throw new ApiException("Missing the required parameter 'version' when calling gETModifyEndpointAccess(Async)");
        }

        return gETModifyEndpointAccessCall(endpointName, action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, vpcSecurityGroupIds, _callback);

    }

    /**
     * 
     * Modifies a Redshift-managed VPC endpoint.
     * @param endpointName The endpoint to be modified. (required)
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param vpcSecurityGroupIds The complete list of VPC security groups associated with the endpoint after the endpoint is modified. (optional)
     * @return EndpointAccess
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> InvalidClusterSecurityGroupStateFault </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> ClusterNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 482 </td><td> InvalidEndpointStateFault </td><td>  -  </td></tr>
        <tr><td> 483 </td><td> EndpointNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 484 </td><td> InvalidClusterStateFault </td><td>  -  </td></tr>
        <tr><td> 485 </td><td> UnauthorizedOperation </td><td>  -  </td></tr>
     </table>
     */
    public EndpointAccess gETModifyEndpointAccess(String endpointName, String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, List<String> vpcSecurityGroupIds) throws ApiException {
        ApiResponse<EndpointAccess> localVarResp = gETModifyEndpointAccessWithHttpInfo(endpointName, action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, vpcSecurityGroupIds);
        return localVarResp.getData();
    }

    /**
     * 
     * Modifies a Redshift-managed VPC endpoint.
     * @param endpointName The endpoint to be modified. (required)
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param vpcSecurityGroupIds The complete list of VPC security groups associated with the endpoint after the endpoint is modified. (optional)
     * @return ApiResponse&lt;EndpointAccess&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> InvalidClusterSecurityGroupStateFault </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> ClusterNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 482 </td><td> InvalidEndpointStateFault </td><td>  -  </td></tr>
        <tr><td> 483 </td><td> EndpointNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 484 </td><td> InvalidClusterStateFault </td><td>  -  </td></tr>
        <tr><td> 485 </td><td> UnauthorizedOperation </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<EndpointAccess> gETModifyEndpointAccessWithHttpInfo(String endpointName, String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, List<String> vpcSecurityGroupIds) throws ApiException {
        okhttp3.Call localVarCall = gETModifyEndpointAccessValidateBeforeCall(endpointName, action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, vpcSecurityGroupIds, null);
        Type localVarReturnType = new TypeToken<EndpointAccess>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     *  (asynchronously)
     * Modifies a Redshift-managed VPC endpoint.
     * @param endpointName The endpoint to be modified. (required)
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param vpcSecurityGroupIds The complete list of VPC security groups associated with the endpoint after the endpoint is modified. (optional)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> InvalidClusterSecurityGroupStateFault </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> ClusterNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 482 </td><td> InvalidEndpointStateFault </td><td>  -  </td></tr>
        <tr><td> 483 </td><td> EndpointNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 484 </td><td> InvalidClusterStateFault </td><td>  -  </td></tr>
        <tr><td> 485 </td><td> UnauthorizedOperation </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call gETModifyEndpointAccessAsync(String endpointName, String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, List<String> vpcSecurityGroupIds, final ApiCallback<EndpointAccess> _callback) throws ApiException {

        okhttp3.Call localVarCall = gETModifyEndpointAccessValidateBeforeCall(endpointName, action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, vpcSecurityGroupIds, _callback);
        Type localVarReturnType = new TypeToken<EndpointAccess>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for gETModifyEventSubscription
     * @param subscriptionName The name of the modified Amazon Redshift event notification subscription. (required)
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param snsTopicArn The Amazon Resource Name (ARN) of the SNS topic to be used by the event notification subscription. (optional)
     * @param sourceType &lt;p&gt;The type of source that will be generating the events. For example, if you want to be notified of events generated by a cluster, you would set this parameter to cluster. If this value is not specified, events are returned for all Amazon Redshift objects in your Amazon Web Services account. You must specify a source type in order to specify source IDs.&lt;/p&gt; &lt;p&gt;Valid values: cluster, cluster-parameter-group, cluster-security-group, cluster-snapshot, and scheduled-action.&lt;/p&gt; (optional)
     * @param sourceIds &lt;p&gt;A list of one or more identifiers of Amazon Redshift source objects. All of the objects must be of the same type as was specified in the source type parameter. The event subscription will return only events generated by the specified objects. If not specified, then events are returned for all objects within the source type specified.&lt;/p&gt; &lt;p&gt;Example: my-cluster-1, my-cluster-2&lt;/p&gt; &lt;p&gt;Example: my-snapshot-20131010&lt;/p&gt; (optional)
     * @param eventCategories &lt;p&gt;Specifies the Amazon Redshift event categories to be published by the event notification subscription.&lt;/p&gt; &lt;p&gt;Values: configuration, management, monitoring, security, pending&lt;/p&gt; (optional)
     * @param severity &lt;p&gt;Specifies the Amazon Redshift event severity to be published by the event notification subscription.&lt;/p&gt; &lt;p&gt;Values: ERROR, INFO&lt;/p&gt; (optional)
     * @param enabled A Boolean value indicating if the subscription is enabled. &lt;code&gt;true&lt;/code&gt; indicates the subscription is enabled  (optional)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> SubscriptionNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> SNSInvalidTopicFault </td><td>  -  </td></tr>
        <tr><td> 482 </td><td> SNSNoAuthorizationFault </td><td>  -  </td></tr>
        <tr><td> 483 </td><td> SNSTopicArnNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 484 </td><td> SubscriptionEventIdNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 485 </td><td> SubscriptionCategoryNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 486 </td><td> SubscriptionSeverityNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 487 </td><td> SourceNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 488 </td><td> InvalidSubscriptionStateFault </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call gETModifyEventSubscriptionCall(String subscriptionName, String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, String snsTopicArn, String sourceType, List<String> sourceIds, List<String> eventCategories, String severity, Boolean enabled, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/#Action=ModifyEventSubscription";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (subscriptionName != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("SubscriptionName", subscriptionName));
        }

        if (snsTopicArn != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("SnsTopicArn", snsTopicArn));
        }

        if (sourceType != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("SourceType", sourceType));
        }

        if (sourceIds != null) {
            localVarCollectionQueryParams.addAll(localVarApiClient.parameterToPairs("multi", "SourceIds", sourceIds));
        }

        if (eventCategories != null) {
            localVarCollectionQueryParams.addAll(localVarApiClient.parameterToPairs("multi", "EventCategories", eventCategories));
        }

        if (severity != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("Severity", severity));
        }

        if (enabled != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("Enabled", enabled));
        }

        if (action != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("Action", action));
        }

        if (version != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("Version", version));
        }

        if (xAmzContentSha256 != null) {
            localVarHeaderParams.put("X-Amz-Content-Sha256", localVarApiClient.parameterToString(xAmzContentSha256));
        }

        if (xAmzDate != null) {
            localVarHeaderParams.put("X-Amz-Date", localVarApiClient.parameterToString(xAmzDate));
        }

        if (xAmzAlgorithm != null) {
            localVarHeaderParams.put("X-Amz-Algorithm", localVarApiClient.parameterToString(xAmzAlgorithm));
        }

        if (xAmzCredential != null) {
            localVarHeaderParams.put("X-Amz-Credential", localVarApiClient.parameterToString(xAmzCredential));
        }

        if (xAmzSecurityToken != null) {
            localVarHeaderParams.put("X-Amz-Security-Token", localVarApiClient.parameterToString(xAmzSecurityToken));
        }

        if (xAmzSignature != null) {
            localVarHeaderParams.put("X-Amz-Signature", localVarApiClient.parameterToString(xAmzSignature));
        }

        if (xAmzSignedHeaders != null) {
            localVarHeaderParams.put("X-Amz-SignedHeaders", localVarApiClient.parameterToString(xAmzSignedHeaders));
        }

        final String[] localVarAccepts = {
            "text/xml"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "hmac" };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call gETModifyEventSubscriptionValidateBeforeCall(String subscriptionName, String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, String snsTopicArn, String sourceType, List<String> sourceIds, List<String> eventCategories, String severity, Boolean enabled, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'subscriptionName' is set
        if (subscriptionName == null) {
            throw new ApiException("Missing the required parameter 'subscriptionName' when calling gETModifyEventSubscription(Async)");
        }

        // verify the required parameter 'action' is set
        if (action == null) {
            throw new ApiException("Missing the required parameter 'action' when calling gETModifyEventSubscription(Async)");
        }

        // verify the required parameter 'version' is set
        if (version == null) {
            throw new ApiException("Missing the required parameter 'version' when calling gETModifyEventSubscription(Async)");
        }

        return gETModifyEventSubscriptionCall(subscriptionName, action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, snsTopicArn, sourceType, sourceIds, eventCategories, severity, enabled, _callback);

    }

    /**
     * 
     * Modifies an existing Amazon Redshift event notification subscription.
     * @param subscriptionName The name of the modified Amazon Redshift event notification subscription. (required)
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param snsTopicArn The Amazon Resource Name (ARN) of the SNS topic to be used by the event notification subscription. (optional)
     * @param sourceType &lt;p&gt;The type of source that will be generating the events. For example, if you want to be notified of events generated by a cluster, you would set this parameter to cluster. If this value is not specified, events are returned for all Amazon Redshift objects in your Amazon Web Services account. You must specify a source type in order to specify source IDs.&lt;/p&gt; &lt;p&gt;Valid values: cluster, cluster-parameter-group, cluster-security-group, cluster-snapshot, and scheduled-action.&lt;/p&gt; (optional)
     * @param sourceIds &lt;p&gt;A list of one or more identifiers of Amazon Redshift source objects. All of the objects must be of the same type as was specified in the source type parameter. The event subscription will return only events generated by the specified objects. If not specified, then events are returned for all objects within the source type specified.&lt;/p&gt; &lt;p&gt;Example: my-cluster-1, my-cluster-2&lt;/p&gt; &lt;p&gt;Example: my-snapshot-20131010&lt;/p&gt; (optional)
     * @param eventCategories &lt;p&gt;Specifies the Amazon Redshift event categories to be published by the event notification subscription.&lt;/p&gt; &lt;p&gt;Values: configuration, management, monitoring, security, pending&lt;/p&gt; (optional)
     * @param severity &lt;p&gt;Specifies the Amazon Redshift event severity to be published by the event notification subscription.&lt;/p&gt; &lt;p&gt;Values: ERROR, INFO&lt;/p&gt; (optional)
     * @param enabled A Boolean value indicating if the subscription is enabled. &lt;code&gt;true&lt;/code&gt; indicates the subscription is enabled  (optional)
     * @return ModifyEventSubscriptionResult
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> SubscriptionNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> SNSInvalidTopicFault </td><td>  -  </td></tr>
        <tr><td> 482 </td><td> SNSNoAuthorizationFault </td><td>  -  </td></tr>
        <tr><td> 483 </td><td> SNSTopicArnNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 484 </td><td> SubscriptionEventIdNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 485 </td><td> SubscriptionCategoryNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 486 </td><td> SubscriptionSeverityNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 487 </td><td> SourceNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 488 </td><td> InvalidSubscriptionStateFault </td><td>  -  </td></tr>
     </table>
     */
    public ModifyEventSubscriptionResult gETModifyEventSubscription(String subscriptionName, String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, String snsTopicArn, String sourceType, List<String> sourceIds, List<String> eventCategories, String severity, Boolean enabled) throws ApiException {
        ApiResponse<ModifyEventSubscriptionResult> localVarResp = gETModifyEventSubscriptionWithHttpInfo(subscriptionName, action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, snsTopicArn, sourceType, sourceIds, eventCategories, severity, enabled);
        return localVarResp.getData();
    }

    /**
     * 
     * Modifies an existing Amazon Redshift event notification subscription.
     * @param subscriptionName The name of the modified Amazon Redshift event notification subscription. (required)
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param snsTopicArn The Amazon Resource Name (ARN) of the SNS topic to be used by the event notification subscription. (optional)
     * @param sourceType &lt;p&gt;The type of source that will be generating the events. For example, if you want to be notified of events generated by a cluster, you would set this parameter to cluster. If this value is not specified, events are returned for all Amazon Redshift objects in your Amazon Web Services account. You must specify a source type in order to specify source IDs.&lt;/p&gt; &lt;p&gt;Valid values: cluster, cluster-parameter-group, cluster-security-group, cluster-snapshot, and scheduled-action.&lt;/p&gt; (optional)
     * @param sourceIds &lt;p&gt;A list of one or more identifiers of Amazon Redshift source objects. All of the objects must be of the same type as was specified in the source type parameter. The event subscription will return only events generated by the specified objects. If not specified, then events are returned for all objects within the source type specified.&lt;/p&gt; &lt;p&gt;Example: my-cluster-1, my-cluster-2&lt;/p&gt; &lt;p&gt;Example: my-snapshot-20131010&lt;/p&gt; (optional)
     * @param eventCategories &lt;p&gt;Specifies the Amazon Redshift event categories to be published by the event notification subscription.&lt;/p&gt; &lt;p&gt;Values: configuration, management, monitoring, security, pending&lt;/p&gt; (optional)
     * @param severity &lt;p&gt;Specifies the Amazon Redshift event severity to be published by the event notification subscription.&lt;/p&gt; &lt;p&gt;Values: ERROR, INFO&lt;/p&gt; (optional)
     * @param enabled A Boolean value indicating if the subscription is enabled. &lt;code&gt;true&lt;/code&gt; indicates the subscription is enabled  (optional)
     * @return ApiResponse&lt;ModifyEventSubscriptionResult&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> SubscriptionNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> SNSInvalidTopicFault </td><td>  -  </td></tr>
        <tr><td> 482 </td><td> SNSNoAuthorizationFault </td><td>  -  </td></tr>
        <tr><td> 483 </td><td> SNSTopicArnNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 484 </td><td> SubscriptionEventIdNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 485 </td><td> SubscriptionCategoryNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 486 </td><td> SubscriptionSeverityNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 487 </td><td> SourceNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 488 </td><td> InvalidSubscriptionStateFault </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<ModifyEventSubscriptionResult> gETModifyEventSubscriptionWithHttpInfo(String subscriptionName, String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, String snsTopicArn, String sourceType, List<String> sourceIds, List<String> eventCategories, String severity, Boolean enabled) throws ApiException {
        okhttp3.Call localVarCall = gETModifyEventSubscriptionValidateBeforeCall(subscriptionName, action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, snsTopicArn, sourceType, sourceIds, eventCategories, severity, enabled, null);
        Type localVarReturnType = new TypeToken<ModifyEventSubscriptionResult>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     *  (asynchronously)
     * Modifies an existing Amazon Redshift event notification subscription.
     * @param subscriptionName The name of the modified Amazon Redshift event notification subscription. (required)
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param snsTopicArn The Amazon Resource Name (ARN) of the SNS topic to be used by the event notification subscription. (optional)
     * @param sourceType &lt;p&gt;The type of source that will be generating the events. For example, if you want to be notified of events generated by a cluster, you would set this parameter to cluster. If this value is not specified, events are returned for all Amazon Redshift objects in your Amazon Web Services account. You must specify a source type in order to specify source IDs.&lt;/p&gt; &lt;p&gt;Valid values: cluster, cluster-parameter-group, cluster-security-group, cluster-snapshot, and scheduled-action.&lt;/p&gt; (optional)
     * @param sourceIds &lt;p&gt;A list of one or more identifiers of Amazon Redshift source objects. All of the objects must be of the same type as was specified in the source type parameter. The event subscription will return only events generated by the specified objects. If not specified, then events are returned for all objects within the source type specified.&lt;/p&gt; &lt;p&gt;Example: my-cluster-1, my-cluster-2&lt;/p&gt; &lt;p&gt;Example: my-snapshot-20131010&lt;/p&gt; (optional)
     * @param eventCategories &lt;p&gt;Specifies the Amazon Redshift event categories to be published by the event notification subscription.&lt;/p&gt; &lt;p&gt;Values: configuration, management, monitoring, security, pending&lt;/p&gt; (optional)
     * @param severity &lt;p&gt;Specifies the Amazon Redshift event severity to be published by the event notification subscription.&lt;/p&gt; &lt;p&gt;Values: ERROR, INFO&lt;/p&gt; (optional)
     * @param enabled A Boolean value indicating if the subscription is enabled. &lt;code&gt;true&lt;/code&gt; indicates the subscription is enabled  (optional)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> SubscriptionNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> SNSInvalidTopicFault </td><td>  -  </td></tr>
        <tr><td> 482 </td><td> SNSNoAuthorizationFault </td><td>  -  </td></tr>
        <tr><td> 483 </td><td> SNSTopicArnNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 484 </td><td> SubscriptionEventIdNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 485 </td><td> SubscriptionCategoryNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 486 </td><td> SubscriptionSeverityNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 487 </td><td> SourceNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 488 </td><td> InvalidSubscriptionStateFault </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call gETModifyEventSubscriptionAsync(String subscriptionName, String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, String snsTopicArn, String sourceType, List<String> sourceIds, List<String> eventCategories, String severity, Boolean enabled, final ApiCallback<ModifyEventSubscriptionResult> _callback) throws ApiException {

        okhttp3.Call localVarCall = gETModifyEventSubscriptionValidateBeforeCall(subscriptionName, action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, snsTopicArn, sourceType, sourceIds, eventCategories, severity, enabled, _callback);
        Type localVarReturnType = new TypeToken<ModifyEventSubscriptionResult>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for gETModifyScheduledAction
     * @param scheduledActionName The name of the scheduled action to modify.  (required)
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param targetAction A modified JSON format of the scheduled action. For more information about this parameter, see &lt;a&gt;ScheduledAction&lt;/a&gt;.  (optional)
     * @param schedule A modified schedule in either &lt;code&gt;at( )&lt;/code&gt; or &lt;code&gt;cron( )&lt;/code&gt; format. For more information about this parameter, see &lt;a&gt;ScheduledAction&lt;/a&gt;. (optional)
     * @param iamRole A different IAM role to assume to run the target action. For more information about this parameter, see &lt;a&gt;ScheduledAction&lt;/a&gt;. (optional)
     * @param scheduledActionDescription A modified description of the scheduled action.  (optional)
     * @param startTime A modified start time of the scheduled action. For more information about this parameter, see &lt;a&gt;ScheduledAction&lt;/a&gt;.  (optional)
     * @param endTime A modified end time of the scheduled action. For more information about this parameter, see &lt;a&gt;ScheduledAction&lt;/a&gt;.  (optional)
     * @param enable A modified enable flag of the scheduled action. If true, the scheduled action is active. If false, the scheduled action is disabled.  (optional)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> ScheduledActionNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> ScheduledActionTypeUnsupportedFault </td><td>  -  </td></tr>
        <tr><td> 482 </td><td> InvalidScheduleFault </td><td>  -  </td></tr>
        <tr><td> 483 </td><td> InvalidScheduledActionFault </td><td>  -  </td></tr>
        <tr><td> 484 </td><td> UnauthorizedOperation </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call gETModifyScheduledActionCall(String scheduledActionName, String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, GETCreateScheduledActionTargetActionParameter targetAction, String schedule, String iamRole, String scheduledActionDescription, OffsetDateTime startTime, OffsetDateTime endTime, Boolean enable, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/#Action=ModifyScheduledAction";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (scheduledActionName != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("ScheduledActionName", scheduledActionName));
        }

        if (targetAction != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("TargetAction", targetAction));
        }

        if (schedule != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("Schedule", schedule));
        }

        if (iamRole != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("IamRole", iamRole));
        }

        if (scheduledActionDescription != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("ScheduledActionDescription", scheduledActionDescription));
        }

        if (startTime != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("StartTime", startTime));
        }

        if (endTime != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("EndTime", endTime));
        }

        if (enable != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("Enable", enable));
        }

        if (action != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("Action", action));
        }

        if (version != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("Version", version));
        }

        if (xAmzContentSha256 != null) {
            localVarHeaderParams.put("X-Amz-Content-Sha256", localVarApiClient.parameterToString(xAmzContentSha256));
        }

        if (xAmzDate != null) {
            localVarHeaderParams.put("X-Amz-Date", localVarApiClient.parameterToString(xAmzDate));
        }

        if (xAmzAlgorithm != null) {
            localVarHeaderParams.put("X-Amz-Algorithm", localVarApiClient.parameterToString(xAmzAlgorithm));
        }

        if (xAmzCredential != null) {
            localVarHeaderParams.put("X-Amz-Credential", localVarApiClient.parameterToString(xAmzCredential));
        }

        if (xAmzSecurityToken != null) {
            localVarHeaderParams.put("X-Amz-Security-Token", localVarApiClient.parameterToString(xAmzSecurityToken));
        }

        if (xAmzSignature != null) {
            localVarHeaderParams.put("X-Amz-Signature", localVarApiClient.parameterToString(xAmzSignature));
        }

        if (xAmzSignedHeaders != null) {
            localVarHeaderParams.put("X-Amz-SignedHeaders", localVarApiClient.parameterToString(xAmzSignedHeaders));
        }

        final String[] localVarAccepts = {
            "text/xml"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "hmac" };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call gETModifyScheduledActionValidateBeforeCall(String scheduledActionName, String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, GETCreateScheduledActionTargetActionParameter targetAction, String schedule, String iamRole, String scheduledActionDescription, OffsetDateTime startTime, OffsetDateTime endTime, Boolean enable, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'scheduledActionName' is set
        if (scheduledActionName == null) {
            throw new ApiException("Missing the required parameter 'scheduledActionName' when calling gETModifyScheduledAction(Async)");
        }

        // verify the required parameter 'action' is set
        if (action == null) {
            throw new ApiException("Missing the required parameter 'action' when calling gETModifyScheduledAction(Async)");
        }

        // verify the required parameter 'version' is set
        if (version == null) {
            throw new ApiException("Missing the required parameter 'version' when calling gETModifyScheduledAction(Async)");
        }

        return gETModifyScheduledActionCall(scheduledActionName, action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, targetAction, schedule, iamRole, scheduledActionDescription, startTime, endTime, enable, _callback);

    }

    /**
     * 
     * Modifies a scheduled action. 
     * @param scheduledActionName The name of the scheduled action to modify.  (required)
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param targetAction A modified JSON format of the scheduled action. For more information about this parameter, see &lt;a&gt;ScheduledAction&lt;/a&gt;.  (optional)
     * @param schedule A modified schedule in either &lt;code&gt;at( )&lt;/code&gt; or &lt;code&gt;cron( )&lt;/code&gt; format. For more information about this parameter, see &lt;a&gt;ScheduledAction&lt;/a&gt;. (optional)
     * @param iamRole A different IAM role to assume to run the target action. For more information about this parameter, see &lt;a&gt;ScheduledAction&lt;/a&gt;. (optional)
     * @param scheduledActionDescription A modified description of the scheduled action.  (optional)
     * @param startTime A modified start time of the scheduled action. For more information about this parameter, see &lt;a&gt;ScheduledAction&lt;/a&gt;.  (optional)
     * @param endTime A modified end time of the scheduled action. For more information about this parameter, see &lt;a&gt;ScheduledAction&lt;/a&gt;.  (optional)
     * @param enable A modified enable flag of the scheduled action. If true, the scheduled action is active. If false, the scheduled action is disabled.  (optional)
     * @return ScheduledAction
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> ScheduledActionNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> ScheduledActionTypeUnsupportedFault </td><td>  -  </td></tr>
        <tr><td> 482 </td><td> InvalidScheduleFault </td><td>  -  </td></tr>
        <tr><td> 483 </td><td> InvalidScheduledActionFault </td><td>  -  </td></tr>
        <tr><td> 484 </td><td> UnauthorizedOperation </td><td>  -  </td></tr>
     </table>
     */
    public ScheduledAction gETModifyScheduledAction(String scheduledActionName, String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, GETCreateScheduledActionTargetActionParameter targetAction, String schedule, String iamRole, String scheduledActionDescription, OffsetDateTime startTime, OffsetDateTime endTime, Boolean enable) throws ApiException {
        ApiResponse<ScheduledAction> localVarResp = gETModifyScheduledActionWithHttpInfo(scheduledActionName, action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, targetAction, schedule, iamRole, scheduledActionDescription, startTime, endTime, enable);
        return localVarResp.getData();
    }

    /**
     * 
     * Modifies a scheduled action. 
     * @param scheduledActionName The name of the scheduled action to modify.  (required)
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param targetAction A modified JSON format of the scheduled action. For more information about this parameter, see &lt;a&gt;ScheduledAction&lt;/a&gt;.  (optional)
     * @param schedule A modified schedule in either &lt;code&gt;at( )&lt;/code&gt; or &lt;code&gt;cron( )&lt;/code&gt; format. For more information about this parameter, see &lt;a&gt;ScheduledAction&lt;/a&gt;. (optional)
     * @param iamRole A different IAM role to assume to run the target action. For more information about this parameter, see &lt;a&gt;ScheduledAction&lt;/a&gt;. (optional)
     * @param scheduledActionDescription A modified description of the scheduled action.  (optional)
     * @param startTime A modified start time of the scheduled action. For more information about this parameter, see &lt;a&gt;ScheduledAction&lt;/a&gt;.  (optional)
     * @param endTime A modified end time of the scheduled action. For more information about this parameter, see &lt;a&gt;ScheduledAction&lt;/a&gt;.  (optional)
     * @param enable A modified enable flag of the scheduled action. If true, the scheduled action is active. If false, the scheduled action is disabled.  (optional)
     * @return ApiResponse&lt;ScheduledAction&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> ScheduledActionNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> ScheduledActionTypeUnsupportedFault </td><td>  -  </td></tr>
        <tr><td> 482 </td><td> InvalidScheduleFault </td><td>  -  </td></tr>
        <tr><td> 483 </td><td> InvalidScheduledActionFault </td><td>  -  </td></tr>
        <tr><td> 484 </td><td> UnauthorizedOperation </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<ScheduledAction> gETModifyScheduledActionWithHttpInfo(String scheduledActionName, String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, GETCreateScheduledActionTargetActionParameter targetAction, String schedule, String iamRole, String scheduledActionDescription, OffsetDateTime startTime, OffsetDateTime endTime, Boolean enable) throws ApiException {
        okhttp3.Call localVarCall = gETModifyScheduledActionValidateBeforeCall(scheduledActionName, action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, targetAction, schedule, iamRole, scheduledActionDescription, startTime, endTime, enable, null);
        Type localVarReturnType = new TypeToken<ScheduledAction>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     *  (asynchronously)
     * Modifies a scheduled action. 
     * @param scheduledActionName The name of the scheduled action to modify.  (required)
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param targetAction A modified JSON format of the scheduled action. For more information about this parameter, see &lt;a&gt;ScheduledAction&lt;/a&gt;.  (optional)
     * @param schedule A modified schedule in either &lt;code&gt;at( )&lt;/code&gt; or &lt;code&gt;cron( )&lt;/code&gt; format. For more information about this parameter, see &lt;a&gt;ScheduledAction&lt;/a&gt;. (optional)
     * @param iamRole A different IAM role to assume to run the target action. For more information about this parameter, see &lt;a&gt;ScheduledAction&lt;/a&gt;. (optional)
     * @param scheduledActionDescription A modified description of the scheduled action.  (optional)
     * @param startTime A modified start time of the scheduled action. For more information about this parameter, see &lt;a&gt;ScheduledAction&lt;/a&gt;.  (optional)
     * @param endTime A modified end time of the scheduled action. For more information about this parameter, see &lt;a&gt;ScheduledAction&lt;/a&gt;.  (optional)
     * @param enable A modified enable flag of the scheduled action. If true, the scheduled action is active. If false, the scheduled action is disabled.  (optional)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> ScheduledActionNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> ScheduledActionTypeUnsupportedFault </td><td>  -  </td></tr>
        <tr><td> 482 </td><td> InvalidScheduleFault </td><td>  -  </td></tr>
        <tr><td> 483 </td><td> InvalidScheduledActionFault </td><td>  -  </td></tr>
        <tr><td> 484 </td><td> UnauthorizedOperation </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call gETModifyScheduledActionAsync(String scheduledActionName, String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, GETCreateScheduledActionTargetActionParameter targetAction, String schedule, String iamRole, String scheduledActionDescription, OffsetDateTime startTime, OffsetDateTime endTime, Boolean enable, final ApiCallback<ScheduledAction> _callback) throws ApiException {

        okhttp3.Call localVarCall = gETModifyScheduledActionValidateBeforeCall(scheduledActionName, action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, targetAction, schedule, iamRole, scheduledActionDescription, startTime, endTime, enable, _callback);
        Type localVarReturnType = new TypeToken<ScheduledAction>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for gETModifySnapshotCopyRetentionPeriod
     * @param clusterIdentifier &lt;p&gt;The unique identifier of the cluster for which you want to change the retention period for either automated or manual snapshots that are copied to a destination Amazon Web Services Region.&lt;/p&gt; &lt;p&gt;Constraints: Must be the valid name of an existing cluster that has cross-region snapshot copy enabled.&lt;/p&gt; (required)
     * @param retentionPeriod &lt;p&gt;The number of days to retain automated snapshots in the destination Amazon Web Services Region after they are copied from the source Amazon Web Services Region.&lt;/p&gt; &lt;p&gt;By default, this only changes the retention period of copied automated snapshots. &lt;/p&gt; &lt;p&gt;If you decrease the retention period for automated snapshots that are copied to a destination Amazon Web Services Region, Amazon Redshift deletes any existing automated snapshots that were copied to the destination Amazon Web Services Region and that fall outside of the new retention period.&lt;/p&gt; &lt;p&gt;Constraints: Must be at least 1 and no more than 35 for automated snapshots. &lt;/p&gt; &lt;p&gt;If you specify the &lt;code&gt;manual&lt;/code&gt; option, only newly copied manual snapshots will have the new retention period. &lt;/p&gt; &lt;p&gt;If you specify the value of -1 newly copied manual snapshots are retained indefinitely.&lt;/p&gt; &lt;p&gt;Constraints: The number of days must be either -1 or an integer between 1 and 3,653 for manual snapshots.&lt;/p&gt; (required)
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param manual Indicates whether to apply the snapshot retention period to newly copied manual snapshots instead of automated snapshots. (optional)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> ClusterNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> SnapshotCopyDisabledFault </td><td>  -  </td></tr>
        <tr><td> 482 </td><td> UnauthorizedOperation </td><td>  -  </td></tr>
        <tr><td> 483 </td><td> InvalidClusterStateFault </td><td>  -  </td></tr>
        <tr><td> 484 </td><td> InvalidRetentionPeriodFault </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call gETModifySnapshotCopyRetentionPeriodCall(String clusterIdentifier, Integer retentionPeriod, String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, Boolean manual, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/#Action=ModifySnapshotCopyRetentionPeriod";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (clusterIdentifier != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("ClusterIdentifier", clusterIdentifier));
        }

        if (retentionPeriod != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("RetentionPeriod", retentionPeriod));
        }

        if (manual != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("Manual", manual));
        }

        if (action != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("Action", action));
        }

        if (version != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("Version", version));
        }

        if (xAmzContentSha256 != null) {
            localVarHeaderParams.put("X-Amz-Content-Sha256", localVarApiClient.parameterToString(xAmzContentSha256));
        }

        if (xAmzDate != null) {
            localVarHeaderParams.put("X-Amz-Date", localVarApiClient.parameterToString(xAmzDate));
        }

        if (xAmzAlgorithm != null) {
            localVarHeaderParams.put("X-Amz-Algorithm", localVarApiClient.parameterToString(xAmzAlgorithm));
        }

        if (xAmzCredential != null) {
            localVarHeaderParams.put("X-Amz-Credential", localVarApiClient.parameterToString(xAmzCredential));
        }

        if (xAmzSecurityToken != null) {
            localVarHeaderParams.put("X-Amz-Security-Token", localVarApiClient.parameterToString(xAmzSecurityToken));
        }

        if (xAmzSignature != null) {
            localVarHeaderParams.put("X-Amz-Signature", localVarApiClient.parameterToString(xAmzSignature));
        }

        if (xAmzSignedHeaders != null) {
            localVarHeaderParams.put("X-Amz-SignedHeaders", localVarApiClient.parameterToString(xAmzSignedHeaders));
        }

        final String[] localVarAccepts = {
            "text/xml"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "hmac" };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call gETModifySnapshotCopyRetentionPeriodValidateBeforeCall(String clusterIdentifier, Integer retentionPeriod, String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, Boolean manual, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'clusterIdentifier' is set
        if (clusterIdentifier == null) {
            throw new ApiException("Missing the required parameter 'clusterIdentifier' when calling gETModifySnapshotCopyRetentionPeriod(Async)");
        }

        // verify the required parameter 'retentionPeriod' is set
        if (retentionPeriod == null) {
            throw new ApiException("Missing the required parameter 'retentionPeriod' when calling gETModifySnapshotCopyRetentionPeriod(Async)");
        }

        // verify the required parameter 'action' is set
        if (action == null) {
            throw new ApiException("Missing the required parameter 'action' when calling gETModifySnapshotCopyRetentionPeriod(Async)");
        }

        // verify the required parameter 'version' is set
        if (version == null) {
            throw new ApiException("Missing the required parameter 'version' when calling gETModifySnapshotCopyRetentionPeriod(Async)");
        }

        return gETModifySnapshotCopyRetentionPeriodCall(clusterIdentifier, retentionPeriod, action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, manual, _callback);

    }

    /**
     * 
     * Modifies the number of days to retain snapshots in the destination Amazon Web Services Region after they are copied from the source Amazon Web Services Region. By default, this operation only changes the retention period of copied automated snapshots. The retention periods for both new and existing copied automated snapshots are updated with the new retention period. You can set the manual option to change only the retention periods of copied manual snapshots. If you set this option, only newly copied manual snapshots have the new retention period. 
     * @param clusterIdentifier &lt;p&gt;The unique identifier of the cluster for which you want to change the retention period for either automated or manual snapshots that are copied to a destination Amazon Web Services Region.&lt;/p&gt; &lt;p&gt;Constraints: Must be the valid name of an existing cluster that has cross-region snapshot copy enabled.&lt;/p&gt; (required)
     * @param retentionPeriod &lt;p&gt;The number of days to retain automated snapshots in the destination Amazon Web Services Region after they are copied from the source Amazon Web Services Region.&lt;/p&gt; &lt;p&gt;By default, this only changes the retention period of copied automated snapshots. &lt;/p&gt; &lt;p&gt;If you decrease the retention period for automated snapshots that are copied to a destination Amazon Web Services Region, Amazon Redshift deletes any existing automated snapshots that were copied to the destination Amazon Web Services Region and that fall outside of the new retention period.&lt;/p&gt; &lt;p&gt;Constraints: Must be at least 1 and no more than 35 for automated snapshots. &lt;/p&gt; &lt;p&gt;If you specify the &lt;code&gt;manual&lt;/code&gt; option, only newly copied manual snapshots will have the new retention period. &lt;/p&gt; &lt;p&gt;If you specify the value of -1 newly copied manual snapshots are retained indefinitely.&lt;/p&gt; &lt;p&gt;Constraints: The number of days must be either -1 or an integer between 1 and 3,653 for manual snapshots.&lt;/p&gt; (required)
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param manual Indicates whether to apply the snapshot retention period to newly copied manual snapshots instead of automated snapshots. (optional)
     * @return ModifySnapshotCopyRetentionPeriodResult
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> ClusterNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> SnapshotCopyDisabledFault </td><td>  -  </td></tr>
        <tr><td> 482 </td><td> UnauthorizedOperation </td><td>  -  </td></tr>
        <tr><td> 483 </td><td> InvalidClusterStateFault </td><td>  -  </td></tr>
        <tr><td> 484 </td><td> InvalidRetentionPeriodFault </td><td>  -  </td></tr>
     </table>
     */
    public ModifySnapshotCopyRetentionPeriodResult gETModifySnapshotCopyRetentionPeriod(String clusterIdentifier, Integer retentionPeriod, String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, Boolean manual) throws ApiException {
        ApiResponse<ModifySnapshotCopyRetentionPeriodResult> localVarResp = gETModifySnapshotCopyRetentionPeriodWithHttpInfo(clusterIdentifier, retentionPeriod, action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, manual);
        return localVarResp.getData();
    }

    /**
     * 
     * Modifies the number of days to retain snapshots in the destination Amazon Web Services Region after they are copied from the source Amazon Web Services Region. By default, this operation only changes the retention period of copied automated snapshots. The retention periods for both new and existing copied automated snapshots are updated with the new retention period. You can set the manual option to change only the retention periods of copied manual snapshots. If you set this option, only newly copied manual snapshots have the new retention period. 
     * @param clusterIdentifier &lt;p&gt;The unique identifier of the cluster for which you want to change the retention period for either automated or manual snapshots that are copied to a destination Amazon Web Services Region.&lt;/p&gt; &lt;p&gt;Constraints: Must be the valid name of an existing cluster that has cross-region snapshot copy enabled.&lt;/p&gt; (required)
     * @param retentionPeriod &lt;p&gt;The number of days to retain automated snapshots in the destination Amazon Web Services Region after they are copied from the source Amazon Web Services Region.&lt;/p&gt; &lt;p&gt;By default, this only changes the retention period of copied automated snapshots. &lt;/p&gt; &lt;p&gt;If you decrease the retention period for automated snapshots that are copied to a destination Amazon Web Services Region, Amazon Redshift deletes any existing automated snapshots that were copied to the destination Amazon Web Services Region and that fall outside of the new retention period.&lt;/p&gt; &lt;p&gt;Constraints: Must be at least 1 and no more than 35 for automated snapshots. &lt;/p&gt; &lt;p&gt;If you specify the &lt;code&gt;manual&lt;/code&gt; option, only newly copied manual snapshots will have the new retention period. &lt;/p&gt; &lt;p&gt;If you specify the value of -1 newly copied manual snapshots are retained indefinitely.&lt;/p&gt; &lt;p&gt;Constraints: The number of days must be either -1 or an integer between 1 and 3,653 for manual snapshots.&lt;/p&gt; (required)
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param manual Indicates whether to apply the snapshot retention period to newly copied manual snapshots instead of automated snapshots. (optional)
     * @return ApiResponse&lt;ModifySnapshotCopyRetentionPeriodResult&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> ClusterNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> SnapshotCopyDisabledFault </td><td>  -  </td></tr>
        <tr><td> 482 </td><td> UnauthorizedOperation </td><td>  -  </td></tr>
        <tr><td> 483 </td><td> InvalidClusterStateFault </td><td>  -  </td></tr>
        <tr><td> 484 </td><td> InvalidRetentionPeriodFault </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<ModifySnapshotCopyRetentionPeriodResult> gETModifySnapshotCopyRetentionPeriodWithHttpInfo(String clusterIdentifier, Integer retentionPeriod, String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, Boolean manual) throws ApiException {
        okhttp3.Call localVarCall = gETModifySnapshotCopyRetentionPeriodValidateBeforeCall(clusterIdentifier, retentionPeriod, action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, manual, null);
        Type localVarReturnType = new TypeToken<ModifySnapshotCopyRetentionPeriodResult>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     *  (asynchronously)
     * Modifies the number of days to retain snapshots in the destination Amazon Web Services Region after they are copied from the source Amazon Web Services Region. By default, this operation only changes the retention period of copied automated snapshots. The retention periods for both new and existing copied automated snapshots are updated with the new retention period. You can set the manual option to change only the retention periods of copied manual snapshots. If you set this option, only newly copied manual snapshots have the new retention period. 
     * @param clusterIdentifier &lt;p&gt;The unique identifier of the cluster for which you want to change the retention period for either automated or manual snapshots that are copied to a destination Amazon Web Services Region.&lt;/p&gt; &lt;p&gt;Constraints: Must be the valid name of an existing cluster that has cross-region snapshot copy enabled.&lt;/p&gt; (required)
     * @param retentionPeriod &lt;p&gt;The number of days to retain automated snapshots in the destination Amazon Web Services Region after they are copied from the source Amazon Web Services Region.&lt;/p&gt; &lt;p&gt;By default, this only changes the retention period of copied automated snapshots. &lt;/p&gt; &lt;p&gt;If you decrease the retention period for automated snapshots that are copied to a destination Amazon Web Services Region, Amazon Redshift deletes any existing automated snapshots that were copied to the destination Amazon Web Services Region and that fall outside of the new retention period.&lt;/p&gt; &lt;p&gt;Constraints: Must be at least 1 and no more than 35 for automated snapshots. &lt;/p&gt; &lt;p&gt;If you specify the &lt;code&gt;manual&lt;/code&gt; option, only newly copied manual snapshots will have the new retention period. &lt;/p&gt; &lt;p&gt;If you specify the value of -1 newly copied manual snapshots are retained indefinitely.&lt;/p&gt; &lt;p&gt;Constraints: The number of days must be either -1 or an integer between 1 and 3,653 for manual snapshots.&lt;/p&gt; (required)
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param manual Indicates whether to apply the snapshot retention period to newly copied manual snapshots instead of automated snapshots. (optional)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> ClusterNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> SnapshotCopyDisabledFault </td><td>  -  </td></tr>
        <tr><td> 482 </td><td> UnauthorizedOperation </td><td>  -  </td></tr>
        <tr><td> 483 </td><td> InvalidClusterStateFault </td><td>  -  </td></tr>
        <tr><td> 484 </td><td> InvalidRetentionPeriodFault </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call gETModifySnapshotCopyRetentionPeriodAsync(String clusterIdentifier, Integer retentionPeriod, String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, Boolean manual, final ApiCallback<ModifySnapshotCopyRetentionPeriodResult> _callback) throws ApiException {

        okhttp3.Call localVarCall = gETModifySnapshotCopyRetentionPeriodValidateBeforeCall(clusterIdentifier, retentionPeriod, action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, manual, _callback);
        Type localVarReturnType = new TypeToken<ModifySnapshotCopyRetentionPeriodResult>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for gETModifySnapshotSchedule
     * @param scheduleIdentifier A unique alphanumeric identifier of the schedule to modify. (required)
     * @param scheduleDefinitions An updated list of schedule definitions. A schedule definition is made up of schedule expressions, for example, \&quot;cron(30 12 *)\&quot; or \&quot;rate(12 hours)\&quot;. (required)
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> InvalidScheduleFault </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> SnapshotScheduleNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 482 </td><td> SnapshotScheduleUpdateInProgressFault </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call gETModifySnapshotScheduleCall(String scheduleIdentifier, List<String> scheduleDefinitions, String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/#Action=ModifySnapshotSchedule";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (scheduleIdentifier != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("ScheduleIdentifier", scheduleIdentifier));
        }

        if (scheduleDefinitions != null) {
            localVarCollectionQueryParams.addAll(localVarApiClient.parameterToPairs("multi", "ScheduleDefinitions", scheduleDefinitions));
        }

        if (action != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("Action", action));
        }

        if (version != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("Version", version));
        }

        if (xAmzContentSha256 != null) {
            localVarHeaderParams.put("X-Amz-Content-Sha256", localVarApiClient.parameterToString(xAmzContentSha256));
        }

        if (xAmzDate != null) {
            localVarHeaderParams.put("X-Amz-Date", localVarApiClient.parameterToString(xAmzDate));
        }

        if (xAmzAlgorithm != null) {
            localVarHeaderParams.put("X-Amz-Algorithm", localVarApiClient.parameterToString(xAmzAlgorithm));
        }

        if (xAmzCredential != null) {
            localVarHeaderParams.put("X-Amz-Credential", localVarApiClient.parameterToString(xAmzCredential));
        }

        if (xAmzSecurityToken != null) {
            localVarHeaderParams.put("X-Amz-Security-Token", localVarApiClient.parameterToString(xAmzSecurityToken));
        }

        if (xAmzSignature != null) {
            localVarHeaderParams.put("X-Amz-Signature", localVarApiClient.parameterToString(xAmzSignature));
        }

        if (xAmzSignedHeaders != null) {
            localVarHeaderParams.put("X-Amz-SignedHeaders", localVarApiClient.parameterToString(xAmzSignedHeaders));
        }

        final String[] localVarAccepts = {
            "text/xml"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "hmac" };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call gETModifySnapshotScheduleValidateBeforeCall(String scheduleIdentifier, List<String> scheduleDefinitions, String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'scheduleIdentifier' is set
        if (scheduleIdentifier == null) {
            throw new ApiException("Missing the required parameter 'scheduleIdentifier' when calling gETModifySnapshotSchedule(Async)");
        }

        // verify the required parameter 'scheduleDefinitions' is set
        if (scheduleDefinitions == null) {
            throw new ApiException("Missing the required parameter 'scheduleDefinitions' when calling gETModifySnapshotSchedule(Async)");
        }

        // verify the required parameter 'action' is set
        if (action == null) {
            throw new ApiException("Missing the required parameter 'action' when calling gETModifySnapshotSchedule(Async)");
        }

        // verify the required parameter 'version' is set
        if (version == null) {
            throw new ApiException("Missing the required parameter 'version' when calling gETModifySnapshotSchedule(Async)");
        }

        return gETModifySnapshotScheduleCall(scheduleIdentifier, scheduleDefinitions, action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, _callback);

    }

    /**
     * 
     * Modifies a snapshot schedule. Any schedule associated with a cluster is modified asynchronously.
     * @param scheduleIdentifier A unique alphanumeric identifier of the schedule to modify. (required)
     * @param scheduleDefinitions An updated list of schedule definitions. A schedule definition is made up of schedule expressions, for example, \&quot;cron(30 12 *)\&quot; or \&quot;rate(12 hours)\&quot;. (required)
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @return SnapshotSchedule
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> InvalidScheduleFault </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> SnapshotScheduleNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 482 </td><td> SnapshotScheduleUpdateInProgressFault </td><td>  -  </td></tr>
     </table>
     */
    public SnapshotSchedule gETModifySnapshotSchedule(String scheduleIdentifier, List<String> scheduleDefinitions, String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders) throws ApiException {
        ApiResponse<SnapshotSchedule> localVarResp = gETModifySnapshotScheduleWithHttpInfo(scheduleIdentifier, scheduleDefinitions, action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders);
        return localVarResp.getData();
    }

    /**
     * 
     * Modifies a snapshot schedule. Any schedule associated with a cluster is modified asynchronously.
     * @param scheduleIdentifier A unique alphanumeric identifier of the schedule to modify. (required)
     * @param scheduleDefinitions An updated list of schedule definitions. A schedule definition is made up of schedule expressions, for example, \&quot;cron(30 12 *)\&quot; or \&quot;rate(12 hours)\&quot;. (required)
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @return ApiResponse&lt;SnapshotSchedule&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> InvalidScheduleFault </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> SnapshotScheduleNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 482 </td><td> SnapshotScheduleUpdateInProgressFault </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<SnapshotSchedule> gETModifySnapshotScheduleWithHttpInfo(String scheduleIdentifier, List<String> scheduleDefinitions, String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders) throws ApiException {
        okhttp3.Call localVarCall = gETModifySnapshotScheduleValidateBeforeCall(scheduleIdentifier, scheduleDefinitions, action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, null);
        Type localVarReturnType = new TypeToken<SnapshotSchedule>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     *  (asynchronously)
     * Modifies a snapshot schedule. Any schedule associated with a cluster is modified asynchronously.
     * @param scheduleIdentifier A unique alphanumeric identifier of the schedule to modify. (required)
     * @param scheduleDefinitions An updated list of schedule definitions. A schedule definition is made up of schedule expressions, for example, \&quot;cron(30 12 *)\&quot; or \&quot;rate(12 hours)\&quot;. (required)
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> InvalidScheduleFault </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> SnapshotScheduleNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 482 </td><td> SnapshotScheduleUpdateInProgressFault </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call gETModifySnapshotScheduleAsync(String scheduleIdentifier, List<String> scheduleDefinitions, String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, final ApiCallback<SnapshotSchedule> _callback) throws ApiException {

        okhttp3.Call localVarCall = gETModifySnapshotScheduleValidateBeforeCall(scheduleIdentifier, scheduleDefinitions, action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, _callback);
        Type localVarReturnType = new TypeToken<SnapshotSchedule>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for gETModifyUsageLimit
     * @param usageLimitId The identifier of the usage limit to modify. (required)
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param amount The new limit amount. For more information about this parameter, see &lt;a&gt;UsageLimit&lt;/a&gt;.  (optional)
     * @param breachAction The new action that Amazon Redshift takes when the limit is reached. For more information about this parameter, see &lt;a&gt;UsageLimit&lt;/a&gt;.  (optional)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> InvalidUsageLimitFault </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> UsageLimitNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 482 </td><td> UnsupportedOperationFault </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call gETModifyUsageLimitCall(String usageLimitId, String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, Integer amount, String breachAction, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/#Action=ModifyUsageLimit";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (usageLimitId != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("UsageLimitId", usageLimitId));
        }

        if (amount != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("Amount", amount));
        }

        if (breachAction != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("BreachAction", breachAction));
        }

        if (action != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("Action", action));
        }

        if (version != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("Version", version));
        }

        if (xAmzContentSha256 != null) {
            localVarHeaderParams.put("X-Amz-Content-Sha256", localVarApiClient.parameterToString(xAmzContentSha256));
        }

        if (xAmzDate != null) {
            localVarHeaderParams.put("X-Amz-Date", localVarApiClient.parameterToString(xAmzDate));
        }

        if (xAmzAlgorithm != null) {
            localVarHeaderParams.put("X-Amz-Algorithm", localVarApiClient.parameterToString(xAmzAlgorithm));
        }

        if (xAmzCredential != null) {
            localVarHeaderParams.put("X-Amz-Credential", localVarApiClient.parameterToString(xAmzCredential));
        }

        if (xAmzSecurityToken != null) {
            localVarHeaderParams.put("X-Amz-Security-Token", localVarApiClient.parameterToString(xAmzSecurityToken));
        }

        if (xAmzSignature != null) {
            localVarHeaderParams.put("X-Amz-Signature", localVarApiClient.parameterToString(xAmzSignature));
        }

        if (xAmzSignedHeaders != null) {
            localVarHeaderParams.put("X-Amz-SignedHeaders", localVarApiClient.parameterToString(xAmzSignedHeaders));
        }

        final String[] localVarAccepts = {
            "text/xml"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "hmac" };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call gETModifyUsageLimitValidateBeforeCall(String usageLimitId, String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, Integer amount, String breachAction, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'usageLimitId' is set
        if (usageLimitId == null) {
            throw new ApiException("Missing the required parameter 'usageLimitId' when calling gETModifyUsageLimit(Async)");
        }

        // verify the required parameter 'action' is set
        if (action == null) {
            throw new ApiException("Missing the required parameter 'action' when calling gETModifyUsageLimit(Async)");
        }

        // verify the required parameter 'version' is set
        if (version == null) {
            throw new ApiException("Missing the required parameter 'version' when calling gETModifyUsageLimit(Async)");
        }

        return gETModifyUsageLimitCall(usageLimitId, action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, amount, breachAction, _callback);

    }

    /**
     * 
     * Modifies a usage limit in a cluster. You can&#39;t modify the feature type or period of a usage limit.
     * @param usageLimitId The identifier of the usage limit to modify. (required)
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param amount The new limit amount. For more information about this parameter, see &lt;a&gt;UsageLimit&lt;/a&gt;.  (optional)
     * @param breachAction The new action that Amazon Redshift takes when the limit is reached. For more information about this parameter, see &lt;a&gt;UsageLimit&lt;/a&gt;.  (optional)
     * @return UsageLimit
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> InvalidUsageLimitFault </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> UsageLimitNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 482 </td><td> UnsupportedOperationFault </td><td>  -  </td></tr>
     </table>
     */
    public UsageLimit gETModifyUsageLimit(String usageLimitId, String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, Integer amount, String breachAction) throws ApiException {
        ApiResponse<UsageLimit> localVarResp = gETModifyUsageLimitWithHttpInfo(usageLimitId, action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, amount, breachAction);
        return localVarResp.getData();
    }

    /**
     * 
     * Modifies a usage limit in a cluster. You can&#39;t modify the feature type or period of a usage limit.
     * @param usageLimitId The identifier of the usage limit to modify. (required)
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param amount The new limit amount. For more information about this parameter, see &lt;a&gt;UsageLimit&lt;/a&gt;.  (optional)
     * @param breachAction The new action that Amazon Redshift takes when the limit is reached. For more information about this parameter, see &lt;a&gt;UsageLimit&lt;/a&gt;.  (optional)
     * @return ApiResponse&lt;UsageLimit&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> InvalidUsageLimitFault </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> UsageLimitNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 482 </td><td> UnsupportedOperationFault </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<UsageLimit> gETModifyUsageLimitWithHttpInfo(String usageLimitId, String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, Integer amount, String breachAction) throws ApiException {
        okhttp3.Call localVarCall = gETModifyUsageLimitValidateBeforeCall(usageLimitId, action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, amount, breachAction, null);
        Type localVarReturnType = new TypeToken<UsageLimit>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     *  (asynchronously)
     * Modifies a usage limit in a cluster. You can&#39;t modify the feature type or period of a usage limit.
     * @param usageLimitId The identifier of the usage limit to modify. (required)
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param amount The new limit amount. For more information about this parameter, see &lt;a&gt;UsageLimit&lt;/a&gt;.  (optional)
     * @param breachAction The new action that Amazon Redshift takes when the limit is reached. For more information about this parameter, see &lt;a&gt;UsageLimit&lt;/a&gt;.  (optional)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> InvalidUsageLimitFault </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> UsageLimitNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 482 </td><td> UnsupportedOperationFault </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call gETModifyUsageLimitAsync(String usageLimitId, String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, Integer amount, String breachAction, final ApiCallback<UsageLimit> _callback) throws ApiException {

        okhttp3.Call localVarCall = gETModifyUsageLimitValidateBeforeCall(usageLimitId, action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, amount, breachAction, _callback);
        Type localVarReturnType = new TypeToken<UsageLimit>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for gETPauseCluster
     * @param clusterIdentifier The identifier of the cluster to be paused. (required)
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> ClusterNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> InvalidClusterStateFault </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call gETPauseClusterCall(String clusterIdentifier, String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/#Action=PauseCluster";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (clusterIdentifier != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("ClusterIdentifier", clusterIdentifier));
        }

        if (action != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("Action", action));
        }

        if (version != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("Version", version));
        }

        if (xAmzContentSha256 != null) {
            localVarHeaderParams.put("X-Amz-Content-Sha256", localVarApiClient.parameterToString(xAmzContentSha256));
        }

        if (xAmzDate != null) {
            localVarHeaderParams.put("X-Amz-Date", localVarApiClient.parameterToString(xAmzDate));
        }

        if (xAmzAlgorithm != null) {
            localVarHeaderParams.put("X-Amz-Algorithm", localVarApiClient.parameterToString(xAmzAlgorithm));
        }

        if (xAmzCredential != null) {
            localVarHeaderParams.put("X-Amz-Credential", localVarApiClient.parameterToString(xAmzCredential));
        }

        if (xAmzSecurityToken != null) {
            localVarHeaderParams.put("X-Amz-Security-Token", localVarApiClient.parameterToString(xAmzSecurityToken));
        }

        if (xAmzSignature != null) {
            localVarHeaderParams.put("X-Amz-Signature", localVarApiClient.parameterToString(xAmzSignature));
        }

        if (xAmzSignedHeaders != null) {
            localVarHeaderParams.put("X-Amz-SignedHeaders", localVarApiClient.parameterToString(xAmzSignedHeaders));
        }

        final String[] localVarAccepts = {
            "text/xml"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "hmac" };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call gETPauseClusterValidateBeforeCall(String clusterIdentifier, String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'clusterIdentifier' is set
        if (clusterIdentifier == null) {
            throw new ApiException("Missing the required parameter 'clusterIdentifier' when calling gETPauseCluster(Async)");
        }

        // verify the required parameter 'action' is set
        if (action == null) {
            throw new ApiException("Missing the required parameter 'action' when calling gETPauseCluster(Async)");
        }

        // verify the required parameter 'version' is set
        if (version == null) {
            throw new ApiException("Missing the required parameter 'version' when calling gETPauseCluster(Async)");
        }

        return gETPauseClusterCall(clusterIdentifier, action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, _callback);

    }

    /**
     * 
     * Pauses a cluster.
     * @param clusterIdentifier The identifier of the cluster to be paused. (required)
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @return PauseClusterResult
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> ClusterNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> InvalidClusterStateFault </td><td>  -  </td></tr>
     </table>
     */
    public PauseClusterResult gETPauseCluster(String clusterIdentifier, String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders) throws ApiException {
        ApiResponse<PauseClusterResult> localVarResp = gETPauseClusterWithHttpInfo(clusterIdentifier, action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders);
        return localVarResp.getData();
    }

    /**
     * 
     * Pauses a cluster.
     * @param clusterIdentifier The identifier of the cluster to be paused. (required)
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @return ApiResponse&lt;PauseClusterResult&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> ClusterNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> InvalidClusterStateFault </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<PauseClusterResult> gETPauseClusterWithHttpInfo(String clusterIdentifier, String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders) throws ApiException {
        okhttp3.Call localVarCall = gETPauseClusterValidateBeforeCall(clusterIdentifier, action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, null);
        Type localVarReturnType = new TypeToken<PauseClusterResult>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     *  (asynchronously)
     * Pauses a cluster.
     * @param clusterIdentifier The identifier of the cluster to be paused. (required)
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> ClusterNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> InvalidClusterStateFault </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call gETPauseClusterAsync(String clusterIdentifier, String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, final ApiCallback<PauseClusterResult> _callback) throws ApiException {

        okhttp3.Call localVarCall = gETPauseClusterValidateBeforeCall(clusterIdentifier, action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, _callback);
        Type localVarReturnType = new TypeToken<PauseClusterResult>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for gETPurchaseReservedNodeOffering
     * @param reservedNodeOfferingId The unique identifier of the reserved node offering you want to purchase. (required)
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param nodeCount &lt;p&gt;The number of reserved nodes that you want to purchase.&lt;/p&gt; &lt;p&gt;Default: &lt;code&gt;1&lt;/code&gt; &lt;/p&gt; (optional)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> ReservedNodeOfferingNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> ReservedNodeAlreadyExistsFault </td><td>  -  </td></tr>
        <tr><td> 482 </td><td> ReservedNodeQuotaExceededFault </td><td>  -  </td></tr>
        <tr><td> 483 </td><td> UnsupportedOperationFault </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call gETPurchaseReservedNodeOfferingCall(String reservedNodeOfferingId, String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, Integer nodeCount, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/#Action=PurchaseReservedNodeOffering";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (reservedNodeOfferingId != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("ReservedNodeOfferingId", reservedNodeOfferingId));
        }

        if (nodeCount != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("NodeCount", nodeCount));
        }

        if (action != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("Action", action));
        }

        if (version != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("Version", version));
        }

        if (xAmzContentSha256 != null) {
            localVarHeaderParams.put("X-Amz-Content-Sha256", localVarApiClient.parameterToString(xAmzContentSha256));
        }

        if (xAmzDate != null) {
            localVarHeaderParams.put("X-Amz-Date", localVarApiClient.parameterToString(xAmzDate));
        }

        if (xAmzAlgorithm != null) {
            localVarHeaderParams.put("X-Amz-Algorithm", localVarApiClient.parameterToString(xAmzAlgorithm));
        }

        if (xAmzCredential != null) {
            localVarHeaderParams.put("X-Amz-Credential", localVarApiClient.parameterToString(xAmzCredential));
        }

        if (xAmzSecurityToken != null) {
            localVarHeaderParams.put("X-Amz-Security-Token", localVarApiClient.parameterToString(xAmzSecurityToken));
        }

        if (xAmzSignature != null) {
            localVarHeaderParams.put("X-Amz-Signature", localVarApiClient.parameterToString(xAmzSignature));
        }

        if (xAmzSignedHeaders != null) {
            localVarHeaderParams.put("X-Amz-SignedHeaders", localVarApiClient.parameterToString(xAmzSignedHeaders));
        }

        final String[] localVarAccepts = {
            "text/xml"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "hmac" };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call gETPurchaseReservedNodeOfferingValidateBeforeCall(String reservedNodeOfferingId, String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, Integer nodeCount, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'reservedNodeOfferingId' is set
        if (reservedNodeOfferingId == null) {
            throw new ApiException("Missing the required parameter 'reservedNodeOfferingId' when calling gETPurchaseReservedNodeOffering(Async)");
        }

        // verify the required parameter 'action' is set
        if (action == null) {
            throw new ApiException("Missing the required parameter 'action' when calling gETPurchaseReservedNodeOffering(Async)");
        }

        // verify the required parameter 'version' is set
        if (version == null) {
            throw new ApiException("Missing the required parameter 'version' when calling gETPurchaseReservedNodeOffering(Async)");
        }

        return gETPurchaseReservedNodeOfferingCall(reservedNodeOfferingId, action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, nodeCount, _callback);

    }

    /**
     * 
     * &lt;p&gt;Allows you to purchase reserved nodes. Amazon Redshift offers a predefined set of reserved node offerings. You can purchase one or more of the offerings. You can call the &lt;a&gt;DescribeReservedNodeOfferings&lt;/a&gt; API to obtain the available reserved node offerings. You can call this API by providing a specific reserved node offering and the number of nodes you want to reserve. &lt;/p&gt; &lt;p&gt; For more information about reserved node offerings, go to &lt;a href&#x3D;\&quot;https://docs.aws.amazon.com/redshift/latest/mgmt/purchase-reserved-node-instance.html\&quot;&gt;Purchasing Reserved Nodes&lt;/a&gt; in the &lt;i&gt;Amazon Redshift Cluster Management Guide&lt;/i&gt;.&lt;/p&gt;
     * @param reservedNodeOfferingId The unique identifier of the reserved node offering you want to purchase. (required)
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param nodeCount &lt;p&gt;The number of reserved nodes that you want to purchase.&lt;/p&gt; &lt;p&gt;Default: &lt;code&gt;1&lt;/code&gt; &lt;/p&gt; (optional)
     * @return PurchaseReservedNodeOfferingResult
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> ReservedNodeOfferingNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> ReservedNodeAlreadyExistsFault </td><td>  -  </td></tr>
        <tr><td> 482 </td><td> ReservedNodeQuotaExceededFault </td><td>  -  </td></tr>
        <tr><td> 483 </td><td> UnsupportedOperationFault </td><td>  -  </td></tr>
     </table>
     */
    public PurchaseReservedNodeOfferingResult gETPurchaseReservedNodeOffering(String reservedNodeOfferingId, String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, Integer nodeCount) throws ApiException {
        ApiResponse<PurchaseReservedNodeOfferingResult> localVarResp = gETPurchaseReservedNodeOfferingWithHttpInfo(reservedNodeOfferingId, action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, nodeCount);
        return localVarResp.getData();
    }

    /**
     * 
     * &lt;p&gt;Allows you to purchase reserved nodes. Amazon Redshift offers a predefined set of reserved node offerings. You can purchase one or more of the offerings. You can call the &lt;a&gt;DescribeReservedNodeOfferings&lt;/a&gt; API to obtain the available reserved node offerings. You can call this API by providing a specific reserved node offering and the number of nodes you want to reserve. &lt;/p&gt; &lt;p&gt; For more information about reserved node offerings, go to &lt;a href&#x3D;\&quot;https://docs.aws.amazon.com/redshift/latest/mgmt/purchase-reserved-node-instance.html\&quot;&gt;Purchasing Reserved Nodes&lt;/a&gt; in the &lt;i&gt;Amazon Redshift Cluster Management Guide&lt;/i&gt;.&lt;/p&gt;
     * @param reservedNodeOfferingId The unique identifier of the reserved node offering you want to purchase. (required)
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param nodeCount &lt;p&gt;The number of reserved nodes that you want to purchase.&lt;/p&gt; &lt;p&gt;Default: &lt;code&gt;1&lt;/code&gt; &lt;/p&gt; (optional)
     * @return ApiResponse&lt;PurchaseReservedNodeOfferingResult&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> ReservedNodeOfferingNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> ReservedNodeAlreadyExistsFault </td><td>  -  </td></tr>
        <tr><td> 482 </td><td> ReservedNodeQuotaExceededFault </td><td>  -  </td></tr>
        <tr><td> 483 </td><td> UnsupportedOperationFault </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<PurchaseReservedNodeOfferingResult> gETPurchaseReservedNodeOfferingWithHttpInfo(String reservedNodeOfferingId, String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, Integer nodeCount) throws ApiException {
        okhttp3.Call localVarCall = gETPurchaseReservedNodeOfferingValidateBeforeCall(reservedNodeOfferingId, action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, nodeCount, null);
        Type localVarReturnType = new TypeToken<PurchaseReservedNodeOfferingResult>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     *  (asynchronously)
     * &lt;p&gt;Allows you to purchase reserved nodes. Amazon Redshift offers a predefined set of reserved node offerings. You can purchase one or more of the offerings. You can call the &lt;a&gt;DescribeReservedNodeOfferings&lt;/a&gt; API to obtain the available reserved node offerings. You can call this API by providing a specific reserved node offering and the number of nodes you want to reserve. &lt;/p&gt; &lt;p&gt; For more information about reserved node offerings, go to &lt;a href&#x3D;\&quot;https://docs.aws.amazon.com/redshift/latest/mgmt/purchase-reserved-node-instance.html\&quot;&gt;Purchasing Reserved Nodes&lt;/a&gt; in the &lt;i&gt;Amazon Redshift Cluster Management Guide&lt;/i&gt;.&lt;/p&gt;
     * @param reservedNodeOfferingId The unique identifier of the reserved node offering you want to purchase. (required)
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param nodeCount &lt;p&gt;The number of reserved nodes that you want to purchase.&lt;/p&gt; &lt;p&gt;Default: &lt;code&gt;1&lt;/code&gt; &lt;/p&gt; (optional)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> ReservedNodeOfferingNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> ReservedNodeAlreadyExistsFault </td><td>  -  </td></tr>
        <tr><td> 482 </td><td> ReservedNodeQuotaExceededFault </td><td>  -  </td></tr>
        <tr><td> 483 </td><td> UnsupportedOperationFault </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call gETPurchaseReservedNodeOfferingAsync(String reservedNodeOfferingId, String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, Integer nodeCount, final ApiCallback<PurchaseReservedNodeOfferingResult> _callback) throws ApiException {

        okhttp3.Call localVarCall = gETPurchaseReservedNodeOfferingValidateBeforeCall(reservedNodeOfferingId, action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, nodeCount, _callback);
        Type localVarReturnType = new TypeToken<PurchaseReservedNodeOfferingResult>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for gETRebootCluster
     * @param clusterIdentifier The cluster identifier. (required)
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> InvalidClusterStateFault </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> ClusterNotFoundFault </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call gETRebootClusterCall(String clusterIdentifier, String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/#Action=RebootCluster";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (clusterIdentifier != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("ClusterIdentifier", clusterIdentifier));
        }

        if (action != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("Action", action));
        }

        if (version != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("Version", version));
        }

        if (xAmzContentSha256 != null) {
            localVarHeaderParams.put("X-Amz-Content-Sha256", localVarApiClient.parameterToString(xAmzContentSha256));
        }

        if (xAmzDate != null) {
            localVarHeaderParams.put("X-Amz-Date", localVarApiClient.parameterToString(xAmzDate));
        }

        if (xAmzAlgorithm != null) {
            localVarHeaderParams.put("X-Amz-Algorithm", localVarApiClient.parameterToString(xAmzAlgorithm));
        }

        if (xAmzCredential != null) {
            localVarHeaderParams.put("X-Amz-Credential", localVarApiClient.parameterToString(xAmzCredential));
        }

        if (xAmzSecurityToken != null) {
            localVarHeaderParams.put("X-Amz-Security-Token", localVarApiClient.parameterToString(xAmzSecurityToken));
        }

        if (xAmzSignature != null) {
            localVarHeaderParams.put("X-Amz-Signature", localVarApiClient.parameterToString(xAmzSignature));
        }

        if (xAmzSignedHeaders != null) {
            localVarHeaderParams.put("X-Amz-SignedHeaders", localVarApiClient.parameterToString(xAmzSignedHeaders));
        }

        final String[] localVarAccepts = {
            "text/xml"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "hmac" };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call gETRebootClusterValidateBeforeCall(String clusterIdentifier, String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'clusterIdentifier' is set
        if (clusterIdentifier == null) {
            throw new ApiException("Missing the required parameter 'clusterIdentifier' when calling gETRebootCluster(Async)");
        }

        // verify the required parameter 'action' is set
        if (action == null) {
            throw new ApiException("Missing the required parameter 'action' when calling gETRebootCluster(Async)");
        }

        // verify the required parameter 'version' is set
        if (version == null) {
            throw new ApiException("Missing the required parameter 'version' when calling gETRebootCluster(Async)");
        }

        return gETRebootClusterCall(clusterIdentifier, action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, _callback);

    }

    /**
     * 
     * Reboots a cluster. This action is taken as soon as possible. It results in a momentary outage to the cluster, during which the cluster status is set to &lt;code&gt;rebooting&lt;/code&gt;. A cluster event is created when the reboot is completed. Any pending cluster modifications (see &lt;a&gt;ModifyCluster&lt;/a&gt;) are applied at this reboot. For more information about managing clusters, go to &lt;a href&#x3D;\&quot;https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html\&quot;&gt;Amazon Redshift Clusters&lt;/a&gt; in the &lt;i&gt;Amazon Redshift Cluster Management Guide&lt;/i&gt;. 
     * @param clusterIdentifier The cluster identifier. (required)
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @return RebootClusterResult
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> InvalidClusterStateFault </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> ClusterNotFoundFault </td><td>  -  </td></tr>
     </table>
     */
    public RebootClusterResult gETRebootCluster(String clusterIdentifier, String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders) throws ApiException {
        ApiResponse<RebootClusterResult> localVarResp = gETRebootClusterWithHttpInfo(clusterIdentifier, action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders);
        return localVarResp.getData();
    }

    /**
     * 
     * Reboots a cluster. This action is taken as soon as possible. It results in a momentary outage to the cluster, during which the cluster status is set to &lt;code&gt;rebooting&lt;/code&gt;. A cluster event is created when the reboot is completed. Any pending cluster modifications (see &lt;a&gt;ModifyCluster&lt;/a&gt;) are applied at this reboot. For more information about managing clusters, go to &lt;a href&#x3D;\&quot;https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html\&quot;&gt;Amazon Redshift Clusters&lt;/a&gt; in the &lt;i&gt;Amazon Redshift Cluster Management Guide&lt;/i&gt;. 
     * @param clusterIdentifier The cluster identifier. (required)
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @return ApiResponse&lt;RebootClusterResult&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> InvalidClusterStateFault </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> ClusterNotFoundFault </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<RebootClusterResult> gETRebootClusterWithHttpInfo(String clusterIdentifier, String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders) throws ApiException {
        okhttp3.Call localVarCall = gETRebootClusterValidateBeforeCall(clusterIdentifier, action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, null);
        Type localVarReturnType = new TypeToken<RebootClusterResult>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     *  (asynchronously)
     * Reboots a cluster. This action is taken as soon as possible. It results in a momentary outage to the cluster, during which the cluster status is set to &lt;code&gt;rebooting&lt;/code&gt;. A cluster event is created when the reboot is completed. Any pending cluster modifications (see &lt;a&gt;ModifyCluster&lt;/a&gt;) are applied at this reboot. For more information about managing clusters, go to &lt;a href&#x3D;\&quot;https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html\&quot;&gt;Amazon Redshift Clusters&lt;/a&gt; in the &lt;i&gt;Amazon Redshift Cluster Management Guide&lt;/i&gt;. 
     * @param clusterIdentifier The cluster identifier. (required)
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> InvalidClusterStateFault </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> ClusterNotFoundFault </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call gETRebootClusterAsync(String clusterIdentifier, String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, final ApiCallback<RebootClusterResult> _callback) throws ApiException {

        okhttp3.Call localVarCall = gETRebootClusterValidateBeforeCall(clusterIdentifier, action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, _callback);
        Type localVarReturnType = new TypeToken<RebootClusterResult>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for gETRejectDataShare
     * @param dataShareArn The Amazon Resource Name (ARN) of the datashare to reject. (required)
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> InvalidDataShareFault </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call gETRejectDataShareCall(String dataShareArn, String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/#Action=RejectDataShare";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (dataShareArn != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("DataShareArn", dataShareArn));
        }

        if (action != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("Action", action));
        }

        if (version != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("Version", version));
        }

        if (xAmzContentSha256 != null) {
            localVarHeaderParams.put("X-Amz-Content-Sha256", localVarApiClient.parameterToString(xAmzContentSha256));
        }

        if (xAmzDate != null) {
            localVarHeaderParams.put("X-Amz-Date", localVarApiClient.parameterToString(xAmzDate));
        }

        if (xAmzAlgorithm != null) {
            localVarHeaderParams.put("X-Amz-Algorithm", localVarApiClient.parameterToString(xAmzAlgorithm));
        }

        if (xAmzCredential != null) {
            localVarHeaderParams.put("X-Amz-Credential", localVarApiClient.parameterToString(xAmzCredential));
        }

        if (xAmzSecurityToken != null) {
            localVarHeaderParams.put("X-Amz-Security-Token", localVarApiClient.parameterToString(xAmzSecurityToken));
        }

        if (xAmzSignature != null) {
            localVarHeaderParams.put("X-Amz-Signature", localVarApiClient.parameterToString(xAmzSignature));
        }

        if (xAmzSignedHeaders != null) {
            localVarHeaderParams.put("X-Amz-SignedHeaders", localVarApiClient.parameterToString(xAmzSignedHeaders));
        }

        final String[] localVarAccepts = {
            "text/xml"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "hmac" };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call gETRejectDataShareValidateBeforeCall(String dataShareArn, String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'dataShareArn' is set
        if (dataShareArn == null) {
            throw new ApiException("Missing the required parameter 'dataShareArn' when calling gETRejectDataShare(Async)");
        }

        // verify the required parameter 'action' is set
        if (action == null) {
            throw new ApiException("Missing the required parameter 'action' when calling gETRejectDataShare(Async)");
        }

        // verify the required parameter 'version' is set
        if (version == null) {
            throw new ApiException("Missing the required parameter 'version' when calling gETRejectDataShare(Async)");
        }

        return gETRejectDataShareCall(dataShareArn, action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, _callback);

    }

    /**
     * 
     * From a datashare consumer account, rejects the specified datashare.
     * @param dataShareArn The Amazon Resource Name (ARN) of the datashare to reject. (required)
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @return DataShare
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> InvalidDataShareFault </td><td>  -  </td></tr>
     </table>
     */
    public DataShare gETRejectDataShare(String dataShareArn, String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders) throws ApiException {
        ApiResponse<DataShare> localVarResp = gETRejectDataShareWithHttpInfo(dataShareArn, action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders);
        return localVarResp.getData();
    }

    /**
     * 
     * From a datashare consumer account, rejects the specified datashare.
     * @param dataShareArn The Amazon Resource Name (ARN) of the datashare to reject. (required)
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @return ApiResponse&lt;DataShare&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> InvalidDataShareFault </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<DataShare> gETRejectDataShareWithHttpInfo(String dataShareArn, String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders) throws ApiException {
        okhttp3.Call localVarCall = gETRejectDataShareValidateBeforeCall(dataShareArn, action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, null);
        Type localVarReturnType = new TypeToken<DataShare>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     *  (asynchronously)
     * From a datashare consumer account, rejects the specified datashare.
     * @param dataShareArn The Amazon Resource Name (ARN) of the datashare to reject. (required)
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> InvalidDataShareFault </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call gETRejectDataShareAsync(String dataShareArn, String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, final ApiCallback<DataShare> _callback) throws ApiException {

        okhttp3.Call localVarCall = gETRejectDataShareValidateBeforeCall(dataShareArn, action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, _callback);
        Type localVarReturnType = new TypeToken<DataShare>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for gETResetClusterParameterGroup
     * @param parameterGroupName The name of the cluster parameter group to be reset. (required)
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param resetAllParameters &lt;p&gt;If &lt;code&gt;true&lt;/code&gt;, all parameters in the specified parameter group will be reset to their default values. &lt;/p&gt; &lt;p&gt;Default: &lt;code&gt;true&lt;/code&gt; &lt;/p&gt; (optional)
     * @param parameters &lt;p&gt;An array of names of parameters to be reset. If &lt;i&gt;ResetAllParameters&lt;/i&gt; option is not used, then at least one parameter name must be supplied. &lt;/p&gt; &lt;p&gt;Constraints: A maximum of 20 parameters can be reset in a single request.&lt;/p&gt; (optional)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> InvalidClusterParameterGroupStateFault </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> ClusterParameterGroupNotFoundFault </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call gETResetClusterParameterGroupCall(String parameterGroupName, String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, Boolean resetAllParameters, List<GETModifyClusterParameterGroupParametersParameterInner> parameters, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/#Action=ResetClusterParameterGroup";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (parameterGroupName != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("ParameterGroupName", parameterGroupName));
        }

        if (resetAllParameters != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("ResetAllParameters", resetAllParameters));
        }

        if (parameters != null) {
            localVarCollectionQueryParams.addAll(localVarApiClient.parameterToPairs("multi", "Parameters", parameters));
        }

        if (action != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("Action", action));
        }

        if (version != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("Version", version));
        }

        if (xAmzContentSha256 != null) {
            localVarHeaderParams.put("X-Amz-Content-Sha256", localVarApiClient.parameterToString(xAmzContentSha256));
        }

        if (xAmzDate != null) {
            localVarHeaderParams.put("X-Amz-Date", localVarApiClient.parameterToString(xAmzDate));
        }

        if (xAmzAlgorithm != null) {
            localVarHeaderParams.put("X-Amz-Algorithm", localVarApiClient.parameterToString(xAmzAlgorithm));
        }

        if (xAmzCredential != null) {
            localVarHeaderParams.put("X-Amz-Credential", localVarApiClient.parameterToString(xAmzCredential));
        }

        if (xAmzSecurityToken != null) {
            localVarHeaderParams.put("X-Amz-Security-Token", localVarApiClient.parameterToString(xAmzSecurityToken));
        }

        if (xAmzSignature != null) {
            localVarHeaderParams.put("X-Amz-Signature", localVarApiClient.parameterToString(xAmzSignature));
        }

        if (xAmzSignedHeaders != null) {
            localVarHeaderParams.put("X-Amz-SignedHeaders", localVarApiClient.parameterToString(xAmzSignedHeaders));
        }

        final String[] localVarAccepts = {
            "text/xml"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "hmac" };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call gETResetClusterParameterGroupValidateBeforeCall(String parameterGroupName, String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, Boolean resetAllParameters, List<GETModifyClusterParameterGroupParametersParameterInner> parameters, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'parameterGroupName' is set
        if (parameterGroupName == null) {
            throw new ApiException("Missing the required parameter 'parameterGroupName' when calling gETResetClusterParameterGroup(Async)");
        }

        // verify the required parameter 'action' is set
        if (action == null) {
            throw new ApiException("Missing the required parameter 'action' when calling gETResetClusterParameterGroup(Async)");
        }

        // verify the required parameter 'version' is set
        if (version == null) {
            throw new ApiException("Missing the required parameter 'version' when calling gETResetClusterParameterGroup(Async)");
        }

        return gETResetClusterParameterGroupCall(parameterGroupName, action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, resetAllParameters, parameters, _callback);

    }

    /**
     * 
     * Sets one or more parameters of the specified parameter group to their default values and sets the source values of the parameters to \&quot;engine-default\&quot;. To reset the entire parameter group specify the &lt;i&gt;ResetAllParameters&lt;/i&gt; parameter. For parameter changes to take effect you must reboot any associated clusters. 
     * @param parameterGroupName The name of the cluster parameter group to be reset. (required)
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param resetAllParameters &lt;p&gt;If &lt;code&gt;true&lt;/code&gt;, all parameters in the specified parameter group will be reset to their default values. &lt;/p&gt; &lt;p&gt;Default: &lt;code&gt;true&lt;/code&gt; &lt;/p&gt; (optional)
     * @param parameters &lt;p&gt;An array of names of parameters to be reset. If &lt;i&gt;ResetAllParameters&lt;/i&gt; option is not used, then at least one parameter name must be supplied. &lt;/p&gt; &lt;p&gt;Constraints: A maximum of 20 parameters can be reset in a single request.&lt;/p&gt; (optional)
     * @return ClusterParameterGroupNameMessage
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> InvalidClusterParameterGroupStateFault </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> ClusterParameterGroupNotFoundFault </td><td>  -  </td></tr>
     </table>
     */
    public ClusterParameterGroupNameMessage gETResetClusterParameterGroup(String parameterGroupName, String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, Boolean resetAllParameters, List<GETModifyClusterParameterGroupParametersParameterInner> parameters) throws ApiException {
        ApiResponse<ClusterParameterGroupNameMessage> localVarResp = gETResetClusterParameterGroupWithHttpInfo(parameterGroupName, action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, resetAllParameters, parameters);
        return localVarResp.getData();
    }

    /**
     * 
     * Sets one or more parameters of the specified parameter group to their default values and sets the source values of the parameters to \&quot;engine-default\&quot;. To reset the entire parameter group specify the &lt;i&gt;ResetAllParameters&lt;/i&gt; parameter. For parameter changes to take effect you must reboot any associated clusters. 
     * @param parameterGroupName The name of the cluster parameter group to be reset. (required)
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param resetAllParameters &lt;p&gt;If &lt;code&gt;true&lt;/code&gt;, all parameters in the specified parameter group will be reset to their default values. &lt;/p&gt; &lt;p&gt;Default: &lt;code&gt;true&lt;/code&gt; &lt;/p&gt; (optional)
     * @param parameters &lt;p&gt;An array of names of parameters to be reset. If &lt;i&gt;ResetAllParameters&lt;/i&gt; option is not used, then at least one parameter name must be supplied. &lt;/p&gt; &lt;p&gt;Constraints: A maximum of 20 parameters can be reset in a single request.&lt;/p&gt; (optional)
     * @return ApiResponse&lt;ClusterParameterGroupNameMessage&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> InvalidClusterParameterGroupStateFault </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> ClusterParameterGroupNotFoundFault </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<ClusterParameterGroupNameMessage> gETResetClusterParameterGroupWithHttpInfo(String parameterGroupName, String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, Boolean resetAllParameters, List<GETModifyClusterParameterGroupParametersParameterInner> parameters) throws ApiException {
        okhttp3.Call localVarCall = gETResetClusterParameterGroupValidateBeforeCall(parameterGroupName, action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, resetAllParameters, parameters, null);
        Type localVarReturnType = new TypeToken<ClusterParameterGroupNameMessage>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     *  (asynchronously)
     * Sets one or more parameters of the specified parameter group to their default values and sets the source values of the parameters to \&quot;engine-default\&quot;. To reset the entire parameter group specify the &lt;i&gt;ResetAllParameters&lt;/i&gt; parameter. For parameter changes to take effect you must reboot any associated clusters. 
     * @param parameterGroupName The name of the cluster parameter group to be reset. (required)
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param resetAllParameters &lt;p&gt;If &lt;code&gt;true&lt;/code&gt;, all parameters in the specified parameter group will be reset to their default values. &lt;/p&gt; &lt;p&gt;Default: &lt;code&gt;true&lt;/code&gt; &lt;/p&gt; (optional)
     * @param parameters &lt;p&gt;An array of names of parameters to be reset. If &lt;i&gt;ResetAllParameters&lt;/i&gt; option is not used, then at least one parameter name must be supplied. &lt;/p&gt; &lt;p&gt;Constraints: A maximum of 20 parameters can be reset in a single request.&lt;/p&gt; (optional)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> InvalidClusterParameterGroupStateFault </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> ClusterParameterGroupNotFoundFault </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call gETResetClusterParameterGroupAsync(String parameterGroupName, String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, Boolean resetAllParameters, List<GETModifyClusterParameterGroupParametersParameterInner> parameters, final ApiCallback<ClusterParameterGroupNameMessage> _callback) throws ApiException {

        okhttp3.Call localVarCall = gETResetClusterParameterGroupValidateBeforeCall(parameterGroupName, action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, resetAllParameters, parameters, _callback);
        Type localVarReturnType = new TypeToken<ClusterParameterGroupNameMessage>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for gETResizeCluster
     * @param clusterIdentifier The unique identifier for the cluster to resize. (required)
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param clusterType The new cluster type for the specified cluster. (optional)
     * @param nodeType The new node type for the nodes you are adding. If not specified, the cluster&#39;s current node type is used. (optional)
     * @param numberOfNodes The new number of nodes for the cluster. If not specified, the cluster&#39;s current number of nodes is used. (optional)
     * @param classic A boolean value indicating whether the resize operation is using the classic resize process. If you don&#39;t provide this parameter or set the value to &lt;code&gt;false&lt;/code&gt;, the resize type is elastic.  (optional)
     * @param reservedNodeId The identifier of the reserved node. (optional)
     * @param targetReservedNodeOfferingId The identifier of the target reserved node offering. (optional)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> InvalidClusterStateFault </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> ClusterNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 482 </td><td> NumberOfNodesQuotaExceededFault </td><td>  -  </td></tr>
        <tr><td> 483 </td><td> NumberOfNodesPerClusterLimitExceededFault </td><td>  -  </td></tr>
        <tr><td> 484 </td><td> InsufficientClusterCapacityFault </td><td>  -  </td></tr>
        <tr><td> 485 </td><td> UnsupportedOptionFault </td><td>  -  </td></tr>
        <tr><td> 486 </td><td> UnsupportedOperationFault </td><td>  -  </td></tr>
        <tr><td> 487 </td><td> UnauthorizedOperation </td><td>  -  </td></tr>
        <tr><td> 488 </td><td> LimitExceededFault </td><td>  -  </td></tr>
        <tr><td> 489 </td><td> ReservedNodeNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 490 </td><td> InvalidReservedNodeStateFault </td><td>  -  </td></tr>
        <tr><td> 491 </td><td> ReservedNodeAlreadyMigratedFault </td><td>  -  </td></tr>
        <tr><td> 492 </td><td> ReservedNodeOfferingNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 493 </td><td> DependentServiceUnavailableFault </td><td>  -  </td></tr>
        <tr><td> 494 </td><td> ReservedNodeAlreadyExistsFault </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call gETResizeClusterCall(String clusterIdentifier, String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, String clusterType, String nodeType, Integer numberOfNodes, Boolean classic, String reservedNodeId, String targetReservedNodeOfferingId, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/#Action=ResizeCluster";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (clusterIdentifier != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("ClusterIdentifier", clusterIdentifier));
        }

        if (clusterType != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("ClusterType", clusterType));
        }

        if (nodeType != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("NodeType", nodeType));
        }

        if (numberOfNodes != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("NumberOfNodes", numberOfNodes));
        }

        if (classic != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("Classic", classic));
        }

        if (reservedNodeId != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("ReservedNodeId", reservedNodeId));
        }

        if (targetReservedNodeOfferingId != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("TargetReservedNodeOfferingId", targetReservedNodeOfferingId));
        }

        if (action != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("Action", action));
        }

        if (version != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("Version", version));
        }

        if (xAmzContentSha256 != null) {
            localVarHeaderParams.put("X-Amz-Content-Sha256", localVarApiClient.parameterToString(xAmzContentSha256));
        }

        if (xAmzDate != null) {
            localVarHeaderParams.put("X-Amz-Date", localVarApiClient.parameterToString(xAmzDate));
        }

        if (xAmzAlgorithm != null) {
            localVarHeaderParams.put("X-Amz-Algorithm", localVarApiClient.parameterToString(xAmzAlgorithm));
        }

        if (xAmzCredential != null) {
            localVarHeaderParams.put("X-Amz-Credential", localVarApiClient.parameterToString(xAmzCredential));
        }

        if (xAmzSecurityToken != null) {
            localVarHeaderParams.put("X-Amz-Security-Token", localVarApiClient.parameterToString(xAmzSecurityToken));
        }

        if (xAmzSignature != null) {
            localVarHeaderParams.put("X-Amz-Signature", localVarApiClient.parameterToString(xAmzSignature));
        }

        if (xAmzSignedHeaders != null) {
            localVarHeaderParams.put("X-Amz-SignedHeaders", localVarApiClient.parameterToString(xAmzSignedHeaders));
        }

        final String[] localVarAccepts = {
            "text/xml"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "hmac" };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call gETResizeClusterValidateBeforeCall(String clusterIdentifier, String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, String clusterType, String nodeType, Integer numberOfNodes, Boolean classic, String reservedNodeId, String targetReservedNodeOfferingId, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'clusterIdentifier' is set
        if (clusterIdentifier == null) {
            throw new ApiException("Missing the required parameter 'clusterIdentifier' when calling gETResizeCluster(Async)");
        }

        // verify the required parameter 'action' is set
        if (action == null) {
            throw new ApiException("Missing the required parameter 'action' when calling gETResizeCluster(Async)");
        }

        // verify the required parameter 'version' is set
        if (version == null) {
            throw new ApiException("Missing the required parameter 'version' when calling gETResizeCluster(Async)");
        }

        return gETResizeClusterCall(clusterIdentifier, action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, clusterType, nodeType, numberOfNodes, classic, reservedNodeId, targetReservedNodeOfferingId, _callback);

    }

    /**
     * 
     * &lt;p&gt;Changes the size of the cluster. You can change the cluster&#39;s type, or change the number or type of nodes. The default behavior is to use the elastic resize method. With an elastic resize, your cluster is available for read and write operations more quickly than with the classic resize method. &lt;/p&gt; &lt;p&gt;Elastic resize operations have the following restrictions:&lt;/p&gt; &lt;ul&gt; &lt;li&gt; &lt;p&gt;You can only resize clusters of the following types:&lt;/p&gt; &lt;ul&gt; &lt;li&gt; &lt;p&gt;dc1.large (if your cluster is in a VPC)&lt;/p&gt; &lt;/li&gt; &lt;li&gt; &lt;p&gt;dc1.8xlarge (if your cluster is in a VPC)&lt;/p&gt; &lt;/li&gt; &lt;li&gt; &lt;p&gt;dc2.large&lt;/p&gt; &lt;/li&gt; &lt;li&gt; &lt;p&gt;dc2.8xlarge&lt;/p&gt; &lt;/li&gt; &lt;li&gt; &lt;p&gt;ds2.xlarge&lt;/p&gt; &lt;/li&gt; &lt;li&gt; &lt;p&gt;ds2.8xlarge&lt;/p&gt; &lt;/li&gt; &lt;li&gt; &lt;p&gt;ra3.xlplus&lt;/p&gt; &lt;/li&gt; &lt;li&gt; &lt;p&gt;ra3.4xlarge&lt;/p&gt; &lt;/li&gt; &lt;li&gt; &lt;p&gt;ra3.16xlarge&lt;/p&gt; &lt;/li&gt; &lt;/ul&gt; &lt;/li&gt; &lt;li&gt; &lt;p&gt;The type of nodes that you add must match the node type for the cluster.&lt;/p&gt; &lt;/li&gt; &lt;/ul&gt;
     * @param clusterIdentifier The unique identifier for the cluster to resize. (required)
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param clusterType The new cluster type for the specified cluster. (optional)
     * @param nodeType The new node type for the nodes you are adding. If not specified, the cluster&#39;s current node type is used. (optional)
     * @param numberOfNodes The new number of nodes for the cluster. If not specified, the cluster&#39;s current number of nodes is used. (optional)
     * @param classic A boolean value indicating whether the resize operation is using the classic resize process. If you don&#39;t provide this parameter or set the value to &lt;code&gt;false&lt;/code&gt;, the resize type is elastic.  (optional)
     * @param reservedNodeId The identifier of the reserved node. (optional)
     * @param targetReservedNodeOfferingId The identifier of the target reserved node offering. (optional)
     * @return ResizeClusterResult
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> InvalidClusterStateFault </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> ClusterNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 482 </td><td> NumberOfNodesQuotaExceededFault </td><td>  -  </td></tr>
        <tr><td> 483 </td><td> NumberOfNodesPerClusterLimitExceededFault </td><td>  -  </td></tr>
        <tr><td> 484 </td><td> InsufficientClusterCapacityFault </td><td>  -  </td></tr>
        <tr><td> 485 </td><td> UnsupportedOptionFault </td><td>  -  </td></tr>
        <tr><td> 486 </td><td> UnsupportedOperationFault </td><td>  -  </td></tr>
        <tr><td> 487 </td><td> UnauthorizedOperation </td><td>  -  </td></tr>
        <tr><td> 488 </td><td> LimitExceededFault </td><td>  -  </td></tr>
        <tr><td> 489 </td><td> ReservedNodeNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 490 </td><td> InvalidReservedNodeStateFault </td><td>  -  </td></tr>
        <tr><td> 491 </td><td> ReservedNodeAlreadyMigratedFault </td><td>  -  </td></tr>
        <tr><td> 492 </td><td> ReservedNodeOfferingNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 493 </td><td> DependentServiceUnavailableFault </td><td>  -  </td></tr>
        <tr><td> 494 </td><td> ReservedNodeAlreadyExistsFault </td><td>  -  </td></tr>
     </table>
     */
    public ResizeClusterResult gETResizeCluster(String clusterIdentifier, String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, String clusterType, String nodeType, Integer numberOfNodes, Boolean classic, String reservedNodeId, String targetReservedNodeOfferingId) throws ApiException {
        ApiResponse<ResizeClusterResult> localVarResp = gETResizeClusterWithHttpInfo(clusterIdentifier, action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, clusterType, nodeType, numberOfNodes, classic, reservedNodeId, targetReservedNodeOfferingId);
        return localVarResp.getData();
    }

    /**
     * 
     * &lt;p&gt;Changes the size of the cluster. You can change the cluster&#39;s type, or change the number or type of nodes. The default behavior is to use the elastic resize method. With an elastic resize, your cluster is available for read and write operations more quickly than with the classic resize method. &lt;/p&gt; &lt;p&gt;Elastic resize operations have the following restrictions:&lt;/p&gt; &lt;ul&gt; &lt;li&gt; &lt;p&gt;You can only resize clusters of the following types:&lt;/p&gt; &lt;ul&gt; &lt;li&gt; &lt;p&gt;dc1.large (if your cluster is in a VPC)&lt;/p&gt; &lt;/li&gt; &lt;li&gt; &lt;p&gt;dc1.8xlarge (if your cluster is in a VPC)&lt;/p&gt; &lt;/li&gt; &lt;li&gt; &lt;p&gt;dc2.large&lt;/p&gt; &lt;/li&gt; &lt;li&gt; &lt;p&gt;dc2.8xlarge&lt;/p&gt; &lt;/li&gt; &lt;li&gt; &lt;p&gt;ds2.xlarge&lt;/p&gt; &lt;/li&gt; &lt;li&gt; &lt;p&gt;ds2.8xlarge&lt;/p&gt; &lt;/li&gt; &lt;li&gt; &lt;p&gt;ra3.xlplus&lt;/p&gt; &lt;/li&gt; &lt;li&gt; &lt;p&gt;ra3.4xlarge&lt;/p&gt; &lt;/li&gt; &lt;li&gt; &lt;p&gt;ra3.16xlarge&lt;/p&gt; &lt;/li&gt; &lt;/ul&gt; &lt;/li&gt; &lt;li&gt; &lt;p&gt;The type of nodes that you add must match the node type for the cluster.&lt;/p&gt; &lt;/li&gt; &lt;/ul&gt;
     * @param clusterIdentifier The unique identifier for the cluster to resize. (required)
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param clusterType The new cluster type for the specified cluster. (optional)
     * @param nodeType The new node type for the nodes you are adding. If not specified, the cluster&#39;s current node type is used. (optional)
     * @param numberOfNodes The new number of nodes for the cluster. If not specified, the cluster&#39;s current number of nodes is used. (optional)
     * @param classic A boolean value indicating whether the resize operation is using the classic resize process. If you don&#39;t provide this parameter or set the value to &lt;code&gt;false&lt;/code&gt;, the resize type is elastic.  (optional)
     * @param reservedNodeId The identifier of the reserved node. (optional)
     * @param targetReservedNodeOfferingId The identifier of the target reserved node offering. (optional)
     * @return ApiResponse&lt;ResizeClusterResult&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> InvalidClusterStateFault </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> ClusterNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 482 </td><td> NumberOfNodesQuotaExceededFault </td><td>  -  </td></tr>
        <tr><td> 483 </td><td> NumberOfNodesPerClusterLimitExceededFault </td><td>  -  </td></tr>
        <tr><td> 484 </td><td> InsufficientClusterCapacityFault </td><td>  -  </td></tr>
        <tr><td> 485 </td><td> UnsupportedOptionFault </td><td>  -  </td></tr>
        <tr><td> 486 </td><td> UnsupportedOperationFault </td><td>  -  </td></tr>
        <tr><td> 487 </td><td> UnauthorizedOperation </td><td>  -  </td></tr>
        <tr><td> 488 </td><td> LimitExceededFault </td><td>  -  </td></tr>
        <tr><td> 489 </td><td> ReservedNodeNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 490 </td><td> InvalidReservedNodeStateFault </td><td>  -  </td></tr>
        <tr><td> 491 </td><td> ReservedNodeAlreadyMigratedFault </td><td>  -  </td></tr>
        <tr><td> 492 </td><td> ReservedNodeOfferingNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 493 </td><td> DependentServiceUnavailableFault </td><td>  -  </td></tr>
        <tr><td> 494 </td><td> ReservedNodeAlreadyExistsFault </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<ResizeClusterResult> gETResizeClusterWithHttpInfo(String clusterIdentifier, String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, String clusterType, String nodeType, Integer numberOfNodes, Boolean classic, String reservedNodeId, String targetReservedNodeOfferingId) throws ApiException {
        okhttp3.Call localVarCall = gETResizeClusterValidateBeforeCall(clusterIdentifier, action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, clusterType, nodeType, numberOfNodes, classic, reservedNodeId, targetReservedNodeOfferingId, null);
        Type localVarReturnType = new TypeToken<ResizeClusterResult>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     *  (asynchronously)
     * &lt;p&gt;Changes the size of the cluster. You can change the cluster&#39;s type, or change the number or type of nodes. The default behavior is to use the elastic resize method. With an elastic resize, your cluster is available for read and write operations more quickly than with the classic resize method. &lt;/p&gt; &lt;p&gt;Elastic resize operations have the following restrictions:&lt;/p&gt; &lt;ul&gt; &lt;li&gt; &lt;p&gt;You can only resize clusters of the following types:&lt;/p&gt; &lt;ul&gt; &lt;li&gt; &lt;p&gt;dc1.large (if your cluster is in a VPC)&lt;/p&gt; &lt;/li&gt; &lt;li&gt; &lt;p&gt;dc1.8xlarge (if your cluster is in a VPC)&lt;/p&gt; &lt;/li&gt; &lt;li&gt; &lt;p&gt;dc2.large&lt;/p&gt; &lt;/li&gt; &lt;li&gt; &lt;p&gt;dc2.8xlarge&lt;/p&gt; &lt;/li&gt; &lt;li&gt; &lt;p&gt;ds2.xlarge&lt;/p&gt; &lt;/li&gt; &lt;li&gt; &lt;p&gt;ds2.8xlarge&lt;/p&gt; &lt;/li&gt; &lt;li&gt; &lt;p&gt;ra3.xlplus&lt;/p&gt; &lt;/li&gt; &lt;li&gt; &lt;p&gt;ra3.4xlarge&lt;/p&gt; &lt;/li&gt; &lt;li&gt; &lt;p&gt;ra3.16xlarge&lt;/p&gt; &lt;/li&gt; &lt;/ul&gt; &lt;/li&gt; &lt;li&gt; &lt;p&gt;The type of nodes that you add must match the node type for the cluster.&lt;/p&gt; &lt;/li&gt; &lt;/ul&gt;
     * @param clusterIdentifier The unique identifier for the cluster to resize. (required)
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param clusterType The new cluster type for the specified cluster. (optional)
     * @param nodeType The new node type for the nodes you are adding. If not specified, the cluster&#39;s current node type is used. (optional)
     * @param numberOfNodes The new number of nodes for the cluster. If not specified, the cluster&#39;s current number of nodes is used. (optional)
     * @param classic A boolean value indicating whether the resize operation is using the classic resize process. If you don&#39;t provide this parameter or set the value to &lt;code&gt;false&lt;/code&gt;, the resize type is elastic.  (optional)
     * @param reservedNodeId The identifier of the reserved node. (optional)
     * @param targetReservedNodeOfferingId The identifier of the target reserved node offering. (optional)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> InvalidClusterStateFault </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> ClusterNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 482 </td><td> NumberOfNodesQuotaExceededFault </td><td>  -  </td></tr>
        <tr><td> 483 </td><td> NumberOfNodesPerClusterLimitExceededFault </td><td>  -  </td></tr>
        <tr><td> 484 </td><td> InsufficientClusterCapacityFault </td><td>  -  </td></tr>
        <tr><td> 485 </td><td> UnsupportedOptionFault </td><td>  -  </td></tr>
        <tr><td> 486 </td><td> UnsupportedOperationFault </td><td>  -  </td></tr>
        <tr><td> 487 </td><td> UnauthorizedOperation </td><td>  -  </td></tr>
        <tr><td> 488 </td><td> LimitExceededFault </td><td>  -  </td></tr>
        <tr><td> 489 </td><td> ReservedNodeNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 490 </td><td> InvalidReservedNodeStateFault </td><td>  -  </td></tr>
        <tr><td> 491 </td><td> ReservedNodeAlreadyMigratedFault </td><td>  -  </td></tr>
        <tr><td> 492 </td><td> ReservedNodeOfferingNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 493 </td><td> DependentServiceUnavailableFault </td><td>  -  </td></tr>
        <tr><td> 494 </td><td> ReservedNodeAlreadyExistsFault </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call gETResizeClusterAsync(String clusterIdentifier, String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, String clusterType, String nodeType, Integer numberOfNodes, Boolean classic, String reservedNodeId, String targetReservedNodeOfferingId, final ApiCallback<ResizeClusterResult> _callback) throws ApiException {

        okhttp3.Call localVarCall = gETResizeClusterValidateBeforeCall(clusterIdentifier, action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, clusterType, nodeType, numberOfNodes, classic, reservedNodeId, targetReservedNodeOfferingId, _callback);
        Type localVarReturnType = new TypeToken<ResizeClusterResult>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for gETRestoreFromClusterSnapshot
     * @param clusterIdentifier &lt;p&gt;The identifier of the cluster that will be created from restoring the snapshot.&lt;/p&gt; &lt;p&gt;Constraints:&lt;/p&gt; &lt;ul&gt; &lt;li&gt; &lt;p&gt;Must contain from 1 to 63 alphanumeric characters or hyphens.&lt;/p&gt; &lt;/li&gt; &lt;li&gt; &lt;p&gt;Alphabetic characters must be lowercase.&lt;/p&gt; &lt;/li&gt; &lt;li&gt; &lt;p&gt;First character must be a letter.&lt;/p&gt; &lt;/li&gt; &lt;li&gt; &lt;p&gt;Cannot end with a hyphen or contain two consecutive hyphens.&lt;/p&gt; &lt;/li&gt; &lt;li&gt; &lt;p&gt;Must be unique for all clusters within an Amazon Web Services account.&lt;/p&gt; &lt;/li&gt; &lt;/ul&gt; (required)
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param snapshotIdentifier &lt;p&gt;The name of the snapshot from which to create the new cluster. This parameter isn&#39;t case sensitive. You must specify this parameter or &lt;code&gt;snapshotArn&lt;/code&gt;, but not both.&lt;/p&gt; &lt;p&gt;Example: &lt;code&gt;my-snapshot-id&lt;/code&gt; &lt;/p&gt; (optional)
     * @param snapshotArn The Amazon Resource Name (ARN) of the snapshot associated with the message to restore from a cluster. You must specify this parameter or &lt;code&gt;snapshotIdentifier&lt;/code&gt;, but not both. (optional)
     * @param snapshotClusterIdentifier The name of the cluster the source snapshot was created from. This parameter is required if your IAM user has a policy containing a snapshot resource element that specifies anything other than * for the cluster name. (optional)
     * @param port &lt;p&gt;The port number on which the cluster accepts connections.&lt;/p&gt; &lt;p&gt;Default: The same port as the original cluster.&lt;/p&gt; &lt;p&gt;Constraints: Must be between &lt;code&gt;1115&lt;/code&gt; and &lt;code&gt;65535&lt;/code&gt;.&lt;/p&gt; (optional)
     * @param availabilityZone &lt;p&gt;The Amazon EC2 Availability Zone in which to restore the cluster.&lt;/p&gt; &lt;p&gt;Default: A random, system-chosen Availability Zone.&lt;/p&gt; &lt;p&gt;Example: &lt;code&gt;us-east-2a&lt;/code&gt; &lt;/p&gt; (optional)
     * @param allowVersionUpgrade &lt;p&gt;If &lt;code&gt;true&lt;/code&gt;, major version upgrades can be applied during the maintenance window to the Amazon Redshift engine that is running on the cluster. &lt;/p&gt; &lt;p&gt;Default: &lt;code&gt;true&lt;/code&gt; &lt;/p&gt; (optional)
     * @param clusterSubnetGroupName &lt;p&gt;The name of the subnet group where you want to cluster restored.&lt;/p&gt; &lt;p&gt;A snapshot of cluster in VPC can be restored only in VPC. Therefore, you must provide subnet group name where you want the cluster restored.&lt;/p&gt; (optional)
     * @param publiclyAccessible If &lt;code&gt;true&lt;/code&gt;, the cluster can be accessed from a public network.  (optional)
     * @param ownerAccount The Amazon Web Services account used to create or copy the snapshot. Required if you are restoring a snapshot you do not own, optional if you own the snapshot. (optional)
     * @param hsmClientCertificateIdentifier Specifies the name of the HSM client certificate the Amazon Redshift cluster uses to retrieve the data encryption keys stored in an HSM. (optional)
     * @param hsmConfigurationIdentifier Specifies the name of the HSM configuration that contains the information the Amazon Redshift cluster can use to retrieve and store keys in an HSM. (optional)
     * @param elasticIp The Elastic IP (EIP) address for the cluster. Don&#39;t specify the Elastic IP address for a publicly accessible cluster with availability zone relocation turned on. (optional)
     * @param clusterParameterGroupName &lt;p&gt;The name of the parameter group to be associated with this cluster.&lt;/p&gt; &lt;p&gt;Default: The default Amazon Redshift cluster parameter group. For information about the default parameter group, go to &lt;a href&#x3D;\&quot;https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-parameter-groups.html\&quot;&gt;Working with Amazon Redshift Parameter Groups&lt;/a&gt;.&lt;/p&gt; &lt;p&gt;Constraints:&lt;/p&gt; &lt;ul&gt; &lt;li&gt; &lt;p&gt;Must be 1 to 255 alphanumeric characters or hyphens.&lt;/p&gt; &lt;/li&gt; &lt;li&gt; &lt;p&gt;First character must be a letter.&lt;/p&gt; &lt;/li&gt; &lt;li&gt; &lt;p&gt;Cannot end with a hyphen or contain two consecutive hyphens.&lt;/p&gt; &lt;/li&gt; &lt;/ul&gt; (optional)
     * @param clusterSecurityGroups &lt;p&gt;A list of security groups to be associated with this cluster.&lt;/p&gt; &lt;p&gt;Default: The default cluster security group for Amazon Redshift.&lt;/p&gt; &lt;p&gt;Cluster security groups only apply to clusters outside of VPCs.&lt;/p&gt; (optional)
     * @param vpcSecurityGroupIds &lt;p&gt;A list of Virtual Private Cloud (VPC) security groups to be associated with the cluster.&lt;/p&gt; &lt;p&gt;Default: The default VPC security group is associated with the cluster.&lt;/p&gt; &lt;p&gt;VPC security groups only apply to clusters in VPCs.&lt;/p&gt; (optional)
     * @param preferredMaintenanceWindow &lt;p&gt;The weekly time range (in UTC) during which automated cluster maintenance can occur.&lt;/p&gt; &lt;p&gt; Format: &lt;code&gt;ddd:hh24:mi-ddd:hh24:mi&lt;/code&gt; &lt;/p&gt; &lt;p&gt; Default: The value selected for the cluster from which the snapshot was taken. For more information about the time blocks for each region, see &lt;a href&#x3D;\&quot;https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html#rs-maintenance-windows\&quot;&gt;Maintenance Windows&lt;/a&gt; in Amazon Redshift Cluster Management Guide. &lt;/p&gt; &lt;p&gt;Valid Days: Mon | Tue | Wed | Thu | Fri | Sat | Sun&lt;/p&gt; &lt;p&gt;Constraints: Minimum 30-minute window.&lt;/p&gt; (optional)
     * @param automatedSnapshotRetentionPeriod &lt;p&gt;The number of days that automated snapshots are retained. If the value is 0, automated snapshots are disabled. Even if automated snapshots are disabled, you can still create manual snapshots when you want with &lt;a&gt;CreateClusterSnapshot&lt;/a&gt;. &lt;/p&gt; &lt;p&gt;You can&#39;t disable automated snapshots for RA3 node types. Set the automated retention period from 1-35 days.&lt;/p&gt; &lt;p&gt;Default: The value selected for the cluster from which the snapshot was taken.&lt;/p&gt; &lt;p&gt;Constraints: Must be a value from 0 to 35.&lt;/p&gt; (optional)
     * @param manualSnapshotRetentionPeriod &lt;p&gt;The default number of days to retain a manual snapshot. If the value is -1, the snapshot is retained indefinitely. This setting doesn&#39;t change the retention period of existing snapshots.&lt;/p&gt; &lt;p&gt;The value must be either -1 or an integer between 1 and 3,653.&lt;/p&gt; (optional)
     * @param kmsKeyId The Key Management Service (KMS) key ID of the encryption key that encrypts data in the cluster restored from a shared snapshot. You can also provide the key ID when you restore from an unencrypted snapshot to an encrypted cluster in the same account. Additionally, you can specify a new KMS key ID when you restore from an encrypted snapshot in the same account in order to change it. In that case, the restored cluster is encrypted with the new KMS key ID. (optional)
     * @param nodeType &lt;p&gt;The node type that the restored cluster will be provisioned with.&lt;/p&gt; &lt;p&gt;Default: The node type of the cluster from which the snapshot was taken. You can modify this if you are using any DS node type. In that case, you can choose to restore into another DS node type of the same size. For example, you can restore ds1.8xlarge into ds2.8xlarge, or ds1.xlarge into ds2.xlarge. If you have a DC instance type, you must restore into that same instance type and size. In other words, you can only restore a dc1.large instance type into another dc1.large instance type or dc2.large instance type. You can&#39;t restore dc1.8xlarge to dc2.8xlarge. First restore to a dc1.8xlarge cluster, then resize to a dc2.8large cluster. For more information about node types, see &lt;a href&#x3D;\&quot;https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html#rs-about-clusters-and-nodes\&quot;&gt; About Clusters and Nodes&lt;/a&gt; in the &lt;i&gt;Amazon Redshift Cluster Management Guide&lt;/i&gt;. &lt;/p&gt; (optional)
     * @param enhancedVpcRouting &lt;p&gt;An option that specifies whether to create the cluster with enhanced VPC routing enabled. To create a cluster that uses enhanced VPC routing, the cluster must be in a VPC. For more information, see &lt;a href&#x3D;\&quot;https://docs.aws.amazon.com/redshift/latest/mgmt/enhanced-vpc-routing.html\&quot;&gt;Enhanced VPC Routing&lt;/a&gt; in the Amazon Redshift Cluster Management Guide.&lt;/p&gt; &lt;p&gt;If this option is &lt;code&gt;true&lt;/code&gt;, enhanced VPC routing is enabled. &lt;/p&gt; &lt;p&gt;Default: false&lt;/p&gt; (optional)
     * @param additionalInfo Reserved. (optional)
     * @param iamRoles &lt;p&gt;A list of Identity and Access Management (IAM) roles that can be used by the cluster to access other Amazon Web Services services. You must supply the IAM roles in their Amazon Resource Name (ARN) format. &lt;/p&gt; &lt;p&gt;The maximum number of IAM roles that you can associate is subject to a quota. For more information, go to &lt;a href&#x3D;\&quot;https://docs.aws.amazon.com/redshift/latest/mgmt/amazon-redshift-limits.html\&quot;&gt;Quotas and limits&lt;/a&gt; in the &lt;i&gt;Amazon Redshift Cluster Management Guide&lt;/i&gt;.&lt;/p&gt; (optional)
     * @param maintenanceTrackName The name of the maintenance track for the restored cluster. When you take a snapshot, the snapshot inherits the &lt;code&gt;MaintenanceTrack&lt;/code&gt; value from the cluster. The snapshot might be on a different track than the cluster that was the source for the snapshot. For example, suppose that you take a snapshot of a cluster that is on the current track and then change the cluster to be on the trailing track. In this case, the snapshot and the source cluster are on different tracks. (optional)
     * @param snapshotScheduleIdentifier A unique identifier for the snapshot schedule. (optional)
     * @param numberOfNodes The number of nodes specified when provisioning the restored cluster. (optional)
     * @param availabilityZoneRelocation The option to enable relocation for an Amazon Redshift cluster between Availability Zones after the cluster is restored. (optional)
     * @param aquaConfigurationStatus This parameter is retired. It does not set the AQUA configuration status. Amazon Redshift automatically determines whether to use AQUA (Advanced Query Accelerator). (optional)
     * @param defaultIamRoleArn The Amazon Resource Name (ARN) for the IAM role that was set as default for the cluster when the cluster was last modified while it was restored from a snapshot. (optional)
     * @param reservedNodeId The identifier of the target reserved node offering. (optional)
     * @param targetReservedNodeOfferingId The identifier of the target reserved node offering. (optional)
     * @param encrypted Enables support for restoring an unencrypted snapshot to a cluster encrypted with Key Management Service (KMS) and a customer managed key. (optional)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> AccessToSnapshotDeniedFault </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> ClusterAlreadyExistsFault </td><td>  -  </td></tr>
        <tr><td> 482 </td><td> ClusterSnapshotNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 483 </td><td> ClusterQuotaExceededFault </td><td>  -  </td></tr>
        <tr><td> 484 </td><td> InsufficientClusterCapacityFault </td><td>  -  </td></tr>
        <tr><td> 485 </td><td> InvalidClusterSnapshotStateFault </td><td>  -  </td></tr>
        <tr><td> 486 </td><td> InvalidRestoreFault </td><td>  -  </td></tr>
        <tr><td> 487 </td><td> NumberOfNodesQuotaExceededFault </td><td>  -  </td></tr>
        <tr><td> 488 </td><td> NumberOfNodesPerClusterLimitExceededFault </td><td>  -  </td></tr>
        <tr><td> 489 </td><td> InvalidVPCNetworkStateFault </td><td>  -  </td></tr>
        <tr><td> 490 </td><td> InvalidClusterSubnetGroupStateFault </td><td>  -  </td></tr>
        <tr><td> 491 </td><td> InvalidSubnet </td><td>  -  </td></tr>
        <tr><td> 492 </td><td> ClusterSubnetGroupNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 493 </td><td> UnauthorizedOperation </td><td>  -  </td></tr>
        <tr><td> 494 </td><td> HsmClientCertificateNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 495 </td><td> HsmConfigurationNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 496 </td><td> InvalidElasticIpFault </td><td>  -  </td></tr>
        <tr><td> 497 </td><td> ClusterParameterGroupNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 498 </td><td> ClusterSecurityGroupNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 499 </td><td> LimitExceededFault </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> DependentServiceRequestThrottlingFault </td><td>  -  </td></tr>
        <tr><td> 501 </td><td> InvalidClusterTrackFault </td><td>  -  </td></tr>
        <tr><td> 502 </td><td> SnapshotScheduleNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 503 </td><td> TagLimitExceededFault </td><td>  -  </td></tr>
        <tr><td> 504 </td><td> InvalidTagFault </td><td>  -  </td></tr>
        <tr><td> 505 </td><td> ReservedNodeNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 506 </td><td> InvalidReservedNodeStateFault </td><td>  -  </td></tr>
        <tr><td> 507 </td><td> ReservedNodeAlreadyMigratedFault </td><td>  -  </td></tr>
        <tr><td> 508 </td><td> ReservedNodeOfferingNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 509 </td><td> DependentServiceUnavailableFault </td><td>  -  </td></tr>
        <tr><td> 510 </td><td> ReservedNodeAlreadyExistsFault </td><td>  -  </td></tr>
        <tr><td> 511 </td><td> UnsupportedOperationFault </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call gETRestoreFromClusterSnapshotCall(String clusterIdentifier, String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, String snapshotIdentifier, String snapshotArn, String snapshotClusterIdentifier, Integer port, String availabilityZone, Boolean allowVersionUpgrade, String clusterSubnetGroupName, Boolean publiclyAccessible, String ownerAccount, String hsmClientCertificateIdentifier, String hsmConfigurationIdentifier, String elasticIp, String clusterParameterGroupName, List<String> clusterSecurityGroups, List<String> vpcSecurityGroupIds, String preferredMaintenanceWindow, Integer automatedSnapshotRetentionPeriod, Integer manualSnapshotRetentionPeriod, String kmsKeyId, String nodeType, Boolean enhancedVpcRouting, String additionalInfo, List<String> iamRoles, String maintenanceTrackName, String snapshotScheduleIdentifier, Integer numberOfNodes, Boolean availabilityZoneRelocation, String aquaConfigurationStatus, String defaultIamRoleArn, String reservedNodeId, String targetReservedNodeOfferingId, Boolean encrypted, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/#Action=RestoreFromClusterSnapshot";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (clusterIdentifier != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("ClusterIdentifier", clusterIdentifier));
        }

        if (snapshotIdentifier != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("SnapshotIdentifier", snapshotIdentifier));
        }

        if (snapshotArn != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("SnapshotArn", snapshotArn));
        }

        if (snapshotClusterIdentifier != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("SnapshotClusterIdentifier", snapshotClusterIdentifier));
        }

        if (port != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("Port", port));
        }

        if (availabilityZone != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("AvailabilityZone", availabilityZone));
        }

        if (allowVersionUpgrade != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("AllowVersionUpgrade", allowVersionUpgrade));
        }

        if (clusterSubnetGroupName != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("ClusterSubnetGroupName", clusterSubnetGroupName));
        }

        if (publiclyAccessible != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("PubliclyAccessible", publiclyAccessible));
        }

        if (ownerAccount != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("OwnerAccount", ownerAccount));
        }

        if (hsmClientCertificateIdentifier != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("HsmClientCertificateIdentifier", hsmClientCertificateIdentifier));
        }

        if (hsmConfigurationIdentifier != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("HsmConfigurationIdentifier", hsmConfigurationIdentifier));
        }

        if (elasticIp != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("ElasticIp", elasticIp));
        }

        if (clusterParameterGroupName != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("ClusterParameterGroupName", clusterParameterGroupName));
        }

        if (clusterSecurityGroups != null) {
            localVarCollectionQueryParams.addAll(localVarApiClient.parameterToPairs("multi", "ClusterSecurityGroups", clusterSecurityGroups));
        }

        if (vpcSecurityGroupIds != null) {
            localVarCollectionQueryParams.addAll(localVarApiClient.parameterToPairs("multi", "VpcSecurityGroupIds", vpcSecurityGroupIds));
        }

        if (preferredMaintenanceWindow != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("PreferredMaintenanceWindow", preferredMaintenanceWindow));
        }

        if (automatedSnapshotRetentionPeriod != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("AutomatedSnapshotRetentionPeriod", automatedSnapshotRetentionPeriod));
        }

        if (manualSnapshotRetentionPeriod != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("ManualSnapshotRetentionPeriod", manualSnapshotRetentionPeriod));
        }

        if (kmsKeyId != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("KmsKeyId", kmsKeyId));
        }

        if (nodeType != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("NodeType", nodeType));
        }

        if (enhancedVpcRouting != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("EnhancedVpcRouting", enhancedVpcRouting));
        }

        if (additionalInfo != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("AdditionalInfo", additionalInfo));
        }

        if (iamRoles != null) {
            localVarCollectionQueryParams.addAll(localVarApiClient.parameterToPairs("multi", "IamRoles", iamRoles));
        }

        if (maintenanceTrackName != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("MaintenanceTrackName", maintenanceTrackName));
        }

        if (snapshotScheduleIdentifier != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("SnapshotScheduleIdentifier", snapshotScheduleIdentifier));
        }

        if (numberOfNodes != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("NumberOfNodes", numberOfNodes));
        }

        if (availabilityZoneRelocation != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("AvailabilityZoneRelocation", availabilityZoneRelocation));
        }

        if (aquaConfigurationStatus != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("AquaConfigurationStatus", aquaConfigurationStatus));
        }

        if (defaultIamRoleArn != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("DefaultIamRoleArn", defaultIamRoleArn));
        }

        if (reservedNodeId != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("ReservedNodeId", reservedNodeId));
        }

        if (targetReservedNodeOfferingId != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("TargetReservedNodeOfferingId", targetReservedNodeOfferingId));
        }

        if (encrypted != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("Encrypted", encrypted));
        }

        if (action != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("Action", action));
        }

        if (version != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("Version", version));
        }

        if (xAmzContentSha256 != null) {
            localVarHeaderParams.put("X-Amz-Content-Sha256", localVarApiClient.parameterToString(xAmzContentSha256));
        }

        if (xAmzDate != null) {
            localVarHeaderParams.put("X-Amz-Date", localVarApiClient.parameterToString(xAmzDate));
        }

        if (xAmzAlgorithm != null) {
            localVarHeaderParams.put("X-Amz-Algorithm", localVarApiClient.parameterToString(xAmzAlgorithm));
        }

        if (xAmzCredential != null) {
            localVarHeaderParams.put("X-Amz-Credential", localVarApiClient.parameterToString(xAmzCredential));
        }

        if (xAmzSecurityToken != null) {
            localVarHeaderParams.put("X-Amz-Security-Token", localVarApiClient.parameterToString(xAmzSecurityToken));
        }

        if (xAmzSignature != null) {
            localVarHeaderParams.put("X-Amz-Signature", localVarApiClient.parameterToString(xAmzSignature));
        }

        if (xAmzSignedHeaders != null) {
            localVarHeaderParams.put("X-Amz-SignedHeaders", localVarApiClient.parameterToString(xAmzSignedHeaders));
        }

        final String[] localVarAccepts = {
            "text/xml"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "hmac" };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call gETRestoreFromClusterSnapshotValidateBeforeCall(String clusterIdentifier, String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, String snapshotIdentifier, String snapshotArn, String snapshotClusterIdentifier, Integer port, String availabilityZone, Boolean allowVersionUpgrade, String clusterSubnetGroupName, Boolean publiclyAccessible, String ownerAccount, String hsmClientCertificateIdentifier, String hsmConfigurationIdentifier, String elasticIp, String clusterParameterGroupName, List<String> clusterSecurityGroups, List<String> vpcSecurityGroupIds, String preferredMaintenanceWindow, Integer automatedSnapshotRetentionPeriod, Integer manualSnapshotRetentionPeriod, String kmsKeyId, String nodeType, Boolean enhancedVpcRouting, String additionalInfo, List<String> iamRoles, String maintenanceTrackName, String snapshotScheduleIdentifier, Integer numberOfNodes, Boolean availabilityZoneRelocation, String aquaConfigurationStatus, String defaultIamRoleArn, String reservedNodeId, String targetReservedNodeOfferingId, Boolean encrypted, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'clusterIdentifier' is set
        if (clusterIdentifier == null) {
            throw new ApiException("Missing the required parameter 'clusterIdentifier' when calling gETRestoreFromClusterSnapshot(Async)");
        }

        // verify the required parameter 'action' is set
        if (action == null) {
            throw new ApiException("Missing the required parameter 'action' when calling gETRestoreFromClusterSnapshot(Async)");
        }

        // verify the required parameter 'version' is set
        if (version == null) {
            throw new ApiException("Missing the required parameter 'version' when calling gETRestoreFromClusterSnapshot(Async)");
        }

        return gETRestoreFromClusterSnapshotCall(clusterIdentifier, action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, snapshotIdentifier, snapshotArn, snapshotClusterIdentifier, port, availabilityZone, allowVersionUpgrade, clusterSubnetGroupName, publiclyAccessible, ownerAccount, hsmClientCertificateIdentifier, hsmConfigurationIdentifier, elasticIp, clusterParameterGroupName, clusterSecurityGroups, vpcSecurityGroupIds, preferredMaintenanceWindow, automatedSnapshotRetentionPeriod, manualSnapshotRetentionPeriod, kmsKeyId, nodeType, enhancedVpcRouting, additionalInfo, iamRoles, maintenanceTrackName, snapshotScheduleIdentifier, numberOfNodes, availabilityZoneRelocation, aquaConfigurationStatus, defaultIamRoleArn, reservedNodeId, targetReservedNodeOfferingId, encrypted, _callback);

    }

    /**
     * 
     * &lt;p&gt;Creates a new cluster from a snapshot. By default, Amazon Redshift creates the resulting cluster with the same configuration as the original cluster from which the snapshot was created, except that the new cluster is created with the default cluster security and parameter groups. After Amazon Redshift creates the cluster, you can use the &lt;a&gt;ModifyCluster&lt;/a&gt; API to associate a different security group and different parameter group with the restored cluster. If you are using a DS node type, you can also choose to change to another DS node type of the same size during restore.&lt;/p&gt; &lt;p&gt;If you restore a cluster into a VPC, you must provide a cluster subnet group where you want the cluster restored.&lt;/p&gt; &lt;p&gt; For more information about working with snapshots, go to &lt;a href&#x3D;\&quot;https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-snapshots.html\&quot;&gt;Amazon Redshift Snapshots&lt;/a&gt; in the &lt;i&gt;Amazon Redshift Cluster Management Guide&lt;/i&gt;.&lt;/p&gt;
     * @param clusterIdentifier &lt;p&gt;The identifier of the cluster that will be created from restoring the snapshot.&lt;/p&gt; &lt;p&gt;Constraints:&lt;/p&gt; &lt;ul&gt; &lt;li&gt; &lt;p&gt;Must contain from 1 to 63 alphanumeric characters or hyphens.&lt;/p&gt; &lt;/li&gt; &lt;li&gt; &lt;p&gt;Alphabetic characters must be lowercase.&lt;/p&gt; &lt;/li&gt; &lt;li&gt; &lt;p&gt;First character must be a letter.&lt;/p&gt; &lt;/li&gt; &lt;li&gt; &lt;p&gt;Cannot end with a hyphen or contain two consecutive hyphens.&lt;/p&gt; &lt;/li&gt; &lt;li&gt; &lt;p&gt;Must be unique for all clusters within an Amazon Web Services account.&lt;/p&gt; &lt;/li&gt; &lt;/ul&gt; (required)
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param snapshotIdentifier &lt;p&gt;The name of the snapshot from which to create the new cluster. This parameter isn&#39;t case sensitive. You must specify this parameter or &lt;code&gt;snapshotArn&lt;/code&gt;, but not both.&lt;/p&gt; &lt;p&gt;Example: &lt;code&gt;my-snapshot-id&lt;/code&gt; &lt;/p&gt; (optional)
     * @param snapshotArn The Amazon Resource Name (ARN) of the snapshot associated with the message to restore from a cluster. You must specify this parameter or &lt;code&gt;snapshotIdentifier&lt;/code&gt;, but not both. (optional)
     * @param snapshotClusterIdentifier The name of the cluster the source snapshot was created from. This parameter is required if your IAM user has a policy containing a snapshot resource element that specifies anything other than * for the cluster name. (optional)
     * @param port &lt;p&gt;The port number on which the cluster accepts connections.&lt;/p&gt; &lt;p&gt;Default: The same port as the original cluster.&lt;/p&gt; &lt;p&gt;Constraints: Must be between &lt;code&gt;1115&lt;/code&gt; and &lt;code&gt;65535&lt;/code&gt;.&lt;/p&gt; (optional)
     * @param availabilityZone &lt;p&gt;The Amazon EC2 Availability Zone in which to restore the cluster.&lt;/p&gt; &lt;p&gt;Default: A random, system-chosen Availability Zone.&lt;/p&gt; &lt;p&gt;Example: &lt;code&gt;us-east-2a&lt;/code&gt; &lt;/p&gt; (optional)
     * @param allowVersionUpgrade &lt;p&gt;If &lt;code&gt;true&lt;/code&gt;, major version upgrades can be applied during the maintenance window to the Amazon Redshift engine that is running on the cluster. &lt;/p&gt; &lt;p&gt;Default: &lt;code&gt;true&lt;/code&gt; &lt;/p&gt; (optional)
     * @param clusterSubnetGroupName &lt;p&gt;The name of the subnet group where you want to cluster restored.&lt;/p&gt; &lt;p&gt;A snapshot of cluster in VPC can be restored only in VPC. Therefore, you must provide subnet group name where you want the cluster restored.&lt;/p&gt; (optional)
     * @param publiclyAccessible If &lt;code&gt;true&lt;/code&gt;, the cluster can be accessed from a public network.  (optional)
     * @param ownerAccount The Amazon Web Services account used to create or copy the snapshot. Required if you are restoring a snapshot you do not own, optional if you own the snapshot. (optional)
     * @param hsmClientCertificateIdentifier Specifies the name of the HSM client certificate the Amazon Redshift cluster uses to retrieve the data encryption keys stored in an HSM. (optional)
     * @param hsmConfigurationIdentifier Specifies the name of the HSM configuration that contains the information the Amazon Redshift cluster can use to retrieve and store keys in an HSM. (optional)
     * @param elasticIp The Elastic IP (EIP) address for the cluster. Don&#39;t specify the Elastic IP address for a publicly accessible cluster with availability zone relocation turned on. (optional)
     * @param clusterParameterGroupName &lt;p&gt;The name of the parameter group to be associated with this cluster.&lt;/p&gt; &lt;p&gt;Default: The default Amazon Redshift cluster parameter group. For information about the default parameter group, go to &lt;a href&#x3D;\&quot;https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-parameter-groups.html\&quot;&gt;Working with Amazon Redshift Parameter Groups&lt;/a&gt;.&lt;/p&gt; &lt;p&gt;Constraints:&lt;/p&gt; &lt;ul&gt; &lt;li&gt; &lt;p&gt;Must be 1 to 255 alphanumeric characters or hyphens.&lt;/p&gt; &lt;/li&gt; &lt;li&gt; &lt;p&gt;First character must be a letter.&lt;/p&gt; &lt;/li&gt; &lt;li&gt; &lt;p&gt;Cannot end with a hyphen or contain two consecutive hyphens.&lt;/p&gt; &lt;/li&gt; &lt;/ul&gt; (optional)
     * @param clusterSecurityGroups &lt;p&gt;A list of security groups to be associated with this cluster.&lt;/p&gt; &lt;p&gt;Default: The default cluster security group for Amazon Redshift.&lt;/p&gt; &lt;p&gt;Cluster security groups only apply to clusters outside of VPCs.&lt;/p&gt; (optional)
     * @param vpcSecurityGroupIds &lt;p&gt;A list of Virtual Private Cloud (VPC) security groups to be associated with the cluster.&lt;/p&gt; &lt;p&gt;Default: The default VPC security group is associated with the cluster.&lt;/p&gt; &lt;p&gt;VPC security groups only apply to clusters in VPCs.&lt;/p&gt; (optional)
     * @param preferredMaintenanceWindow &lt;p&gt;The weekly time range (in UTC) during which automated cluster maintenance can occur.&lt;/p&gt; &lt;p&gt; Format: &lt;code&gt;ddd:hh24:mi-ddd:hh24:mi&lt;/code&gt; &lt;/p&gt; &lt;p&gt; Default: The value selected for the cluster from which the snapshot was taken. For more information about the time blocks for each region, see &lt;a href&#x3D;\&quot;https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html#rs-maintenance-windows\&quot;&gt;Maintenance Windows&lt;/a&gt; in Amazon Redshift Cluster Management Guide. &lt;/p&gt; &lt;p&gt;Valid Days: Mon | Tue | Wed | Thu | Fri | Sat | Sun&lt;/p&gt; &lt;p&gt;Constraints: Minimum 30-minute window.&lt;/p&gt; (optional)
     * @param automatedSnapshotRetentionPeriod &lt;p&gt;The number of days that automated snapshots are retained. If the value is 0, automated snapshots are disabled. Even if automated snapshots are disabled, you can still create manual snapshots when you want with &lt;a&gt;CreateClusterSnapshot&lt;/a&gt;. &lt;/p&gt; &lt;p&gt;You can&#39;t disable automated snapshots for RA3 node types. Set the automated retention period from 1-35 days.&lt;/p&gt; &lt;p&gt;Default: The value selected for the cluster from which the snapshot was taken.&lt;/p&gt; &lt;p&gt;Constraints: Must be a value from 0 to 35.&lt;/p&gt; (optional)
     * @param manualSnapshotRetentionPeriod &lt;p&gt;The default number of days to retain a manual snapshot. If the value is -1, the snapshot is retained indefinitely. This setting doesn&#39;t change the retention period of existing snapshots.&lt;/p&gt; &lt;p&gt;The value must be either -1 or an integer between 1 and 3,653.&lt;/p&gt; (optional)
     * @param kmsKeyId The Key Management Service (KMS) key ID of the encryption key that encrypts data in the cluster restored from a shared snapshot. You can also provide the key ID when you restore from an unencrypted snapshot to an encrypted cluster in the same account. Additionally, you can specify a new KMS key ID when you restore from an encrypted snapshot in the same account in order to change it. In that case, the restored cluster is encrypted with the new KMS key ID. (optional)
     * @param nodeType &lt;p&gt;The node type that the restored cluster will be provisioned with.&lt;/p&gt; &lt;p&gt;Default: The node type of the cluster from which the snapshot was taken. You can modify this if you are using any DS node type. In that case, you can choose to restore into another DS node type of the same size. For example, you can restore ds1.8xlarge into ds2.8xlarge, or ds1.xlarge into ds2.xlarge. If you have a DC instance type, you must restore into that same instance type and size. In other words, you can only restore a dc1.large instance type into another dc1.large instance type or dc2.large instance type. You can&#39;t restore dc1.8xlarge to dc2.8xlarge. First restore to a dc1.8xlarge cluster, then resize to a dc2.8large cluster. For more information about node types, see &lt;a href&#x3D;\&quot;https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html#rs-about-clusters-and-nodes\&quot;&gt; About Clusters and Nodes&lt;/a&gt; in the &lt;i&gt;Amazon Redshift Cluster Management Guide&lt;/i&gt;. &lt;/p&gt; (optional)
     * @param enhancedVpcRouting &lt;p&gt;An option that specifies whether to create the cluster with enhanced VPC routing enabled. To create a cluster that uses enhanced VPC routing, the cluster must be in a VPC. For more information, see &lt;a href&#x3D;\&quot;https://docs.aws.amazon.com/redshift/latest/mgmt/enhanced-vpc-routing.html\&quot;&gt;Enhanced VPC Routing&lt;/a&gt; in the Amazon Redshift Cluster Management Guide.&lt;/p&gt; &lt;p&gt;If this option is &lt;code&gt;true&lt;/code&gt;, enhanced VPC routing is enabled. &lt;/p&gt; &lt;p&gt;Default: false&lt;/p&gt; (optional)
     * @param additionalInfo Reserved. (optional)
     * @param iamRoles &lt;p&gt;A list of Identity and Access Management (IAM) roles that can be used by the cluster to access other Amazon Web Services services. You must supply the IAM roles in their Amazon Resource Name (ARN) format. &lt;/p&gt; &lt;p&gt;The maximum number of IAM roles that you can associate is subject to a quota. For more information, go to &lt;a href&#x3D;\&quot;https://docs.aws.amazon.com/redshift/latest/mgmt/amazon-redshift-limits.html\&quot;&gt;Quotas and limits&lt;/a&gt; in the &lt;i&gt;Amazon Redshift Cluster Management Guide&lt;/i&gt;.&lt;/p&gt; (optional)
     * @param maintenanceTrackName The name of the maintenance track for the restored cluster. When you take a snapshot, the snapshot inherits the &lt;code&gt;MaintenanceTrack&lt;/code&gt; value from the cluster. The snapshot might be on a different track than the cluster that was the source for the snapshot. For example, suppose that you take a snapshot of a cluster that is on the current track and then change the cluster to be on the trailing track. In this case, the snapshot and the source cluster are on different tracks. (optional)
     * @param snapshotScheduleIdentifier A unique identifier for the snapshot schedule. (optional)
     * @param numberOfNodes The number of nodes specified when provisioning the restored cluster. (optional)
     * @param availabilityZoneRelocation The option to enable relocation for an Amazon Redshift cluster between Availability Zones after the cluster is restored. (optional)
     * @param aquaConfigurationStatus This parameter is retired. It does not set the AQUA configuration status. Amazon Redshift automatically determines whether to use AQUA (Advanced Query Accelerator). (optional)
     * @param defaultIamRoleArn The Amazon Resource Name (ARN) for the IAM role that was set as default for the cluster when the cluster was last modified while it was restored from a snapshot. (optional)
     * @param reservedNodeId The identifier of the target reserved node offering. (optional)
     * @param targetReservedNodeOfferingId The identifier of the target reserved node offering. (optional)
     * @param encrypted Enables support for restoring an unencrypted snapshot to a cluster encrypted with Key Management Service (KMS) and a customer managed key. (optional)
     * @return RestoreFromClusterSnapshotResult
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> AccessToSnapshotDeniedFault </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> ClusterAlreadyExistsFault </td><td>  -  </td></tr>
        <tr><td> 482 </td><td> ClusterSnapshotNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 483 </td><td> ClusterQuotaExceededFault </td><td>  -  </td></tr>
        <tr><td> 484 </td><td> InsufficientClusterCapacityFault </td><td>  -  </td></tr>
        <tr><td> 485 </td><td> InvalidClusterSnapshotStateFault </td><td>  -  </td></tr>
        <tr><td> 486 </td><td> InvalidRestoreFault </td><td>  -  </td></tr>
        <tr><td> 487 </td><td> NumberOfNodesQuotaExceededFault </td><td>  -  </td></tr>
        <tr><td> 488 </td><td> NumberOfNodesPerClusterLimitExceededFault </td><td>  -  </td></tr>
        <tr><td> 489 </td><td> InvalidVPCNetworkStateFault </td><td>  -  </td></tr>
        <tr><td> 490 </td><td> InvalidClusterSubnetGroupStateFault </td><td>  -  </td></tr>
        <tr><td> 491 </td><td> InvalidSubnet </td><td>  -  </td></tr>
        <tr><td> 492 </td><td> ClusterSubnetGroupNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 493 </td><td> UnauthorizedOperation </td><td>  -  </td></tr>
        <tr><td> 494 </td><td> HsmClientCertificateNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 495 </td><td> HsmConfigurationNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 496 </td><td> InvalidElasticIpFault </td><td>  -  </td></tr>
        <tr><td> 497 </td><td> ClusterParameterGroupNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 498 </td><td> ClusterSecurityGroupNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 499 </td><td> LimitExceededFault </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> DependentServiceRequestThrottlingFault </td><td>  -  </td></tr>
        <tr><td> 501 </td><td> InvalidClusterTrackFault </td><td>  -  </td></tr>
        <tr><td> 502 </td><td> SnapshotScheduleNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 503 </td><td> TagLimitExceededFault </td><td>  -  </td></tr>
        <tr><td> 504 </td><td> InvalidTagFault </td><td>  -  </td></tr>
        <tr><td> 505 </td><td> ReservedNodeNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 506 </td><td> InvalidReservedNodeStateFault </td><td>  -  </td></tr>
        <tr><td> 507 </td><td> ReservedNodeAlreadyMigratedFault </td><td>  -  </td></tr>
        <tr><td> 508 </td><td> ReservedNodeOfferingNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 509 </td><td> DependentServiceUnavailableFault </td><td>  -  </td></tr>
        <tr><td> 510 </td><td> ReservedNodeAlreadyExistsFault </td><td>  -  </td></tr>
        <tr><td> 511 </td><td> UnsupportedOperationFault </td><td>  -  </td></tr>
     </table>
     */
    public RestoreFromClusterSnapshotResult gETRestoreFromClusterSnapshot(String clusterIdentifier, String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, String snapshotIdentifier, String snapshotArn, String snapshotClusterIdentifier, Integer port, String availabilityZone, Boolean allowVersionUpgrade, String clusterSubnetGroupName, Boolean publiclyAccessible, String ownerAccount, String hsmClientCertificateIdentifier, String hsmConfigurationIdentifier, String elasticIp, String clusterParameterGroupName, List<String> clusterSecurityGroups, List<String> vpcSecurityGroupIds, String preferredMaintenanceWindow, Integer automatedSnapshotRetentionPeriod, Integer manualSnapshotRetentionPeriod, String kmsKeyId, String nodeType, Boolean enhancedVpcRouting, String additionalInfo, List<String> iamRoles, String maintenanceTrackName, String snapshotScheduleIdentifier, Integer numberOfNodes, Boolean availabilityZoneRelocation, String aquaConfigurationStatus, String defaultIamRoleArn, String reservedNodeId, String targetReservedNodeOfferingId, Boolean encrypted) throws ApiException {
        ApiResponse<RestoreFromClusterSnapshotResult> localVarResp = gETRestoreFromClusterSnapshotWithHttpInfo(clusterIdentifier, action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, snapshotIdentifier, snapshotArn, snapshotClusterIdentifier, port, availabilityZone, allowVersionUpgrade, clusterSubnetGroupName, publiclyAccessible, ownerAccount, hsmClientCertificateIdentifier, hsmConfigurationIdentifier, elasticIp, clusterParameterGroupName, clusterSecurityGroups, vpcSecurityGroupIds, preferredMaintenanceWindow, automatedSnapshotRetentionPeriod, manualSnapshotRetentionPeriod, kmsKeyId, nodeType, enhancedVpcRouting, additionalInfo, iamRoles, maintenanceTrackName, snapshotScheduleIdentifier, numberOfNodes, availabilityZoneRelocation, aquaConfigurationStatus, defaultIamRoleArn, reservedNodeId, targetReservedNodeOfferingId, encrypted);
        return localVarResp.getData();
    }

    /**
     * 
     * &lt;p&gt;Creates a new cluster from a snapshot. By default, Amazon Redshift creates the resulting cluster with the same configuration as the original cluster from which the snapshot was created, except that the new cluster is created with the default cluster security and parameter groups. After Amazon Redshift creates the cluster, you can use the &lt;a&gt;ModifyCluster&lt;/a&gt; API to associate a different security group and different parameter group with the restored cluster. If you are using a DS node type, you can also choose to change to another DS node type of the same size during restore.&lt;/p&gt; &lt;p&gt;If you restore a cluster into a VPC, you must provide a cluster subnet group where you want the cluster restored.&lt;/p&gt; &lt;p&gt; For more information about working with snapshots, go to &lt;a href&#x3D;\&quot;https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-snapshots.html\&quot;&gt;Amazon Redshift Snapshots&lt;/a&gt; in the &lt;i&gt;Amazon Redshift Cluster Management Guide&lt;/i&gt;.&lt;/p&gt;
     * @param clusterIdentifier &lt;p&gt;The identifier of the cluster that will be created from restoring the snapshot.&lt;/p&gt; &lt;p&gt;Constraints:&lt;/p&gt; &lt;ul&gt; &lt;li&gt; &lt;p&gt;Must contain from 1 to 63 alphanumeric characters or hyphens.&lt;/p&gt; &lt;/li&gt; &lt;li&gt; &lt;p&gt;Alphabetic characters must be lowercase.&lt;/p&gt; &lt;/li&gt; &lt;li&gt; &lt;p&gt;First character must be a letter.&lt;/p&gt; &lt;/li&gt; &lt;li&gt; &lt;p&gt;Cannot end with a hyphen or contain two consecutive hyphens.&lt;/p&gt; &lt;/li&gt; &lt;li&gt; &lt;p&gt;Must be unique for all clusters within an Amazon Web Services account.&lt;/p&gt; &lt;/li&gt; &lt;/ul&gt; (required)
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param snapshotIdentifier &lt;p&gt;The name of the snapshot from which to create the new cluster. This parameter isn&#39;t case sensitive. You must specify this parameter or &lt;code&gt;snapshotArn&lt;/code&gt;, but not both.&lt;/p&gt; &lt;p&gt;Example: &lt;code&gt;my-snapshot-id&lt;/code&gt; &lt;/p&gt; (optional)
     * @param snapshotArn The Amazon Resource Name (ARN) of the snapshot associated with the message to restore from a cluster. You must specify this parameter or &lt;code&gt;snapshotIdentifier&lt;/code&gt;, but not both. (optional)
     * @param snapshotClusterIdentifier The name of the cluster the source snapshot was created from. This parameter is required if your IAM user has a policy containing a snapshot resource element that specifies anything other than * for the cluster name. (optional)
     * @param port &lt;p&gt;The port number on which the cluster accepts connections.&lt;/p&gt; &lt;p&gt;Default: The same port as the original cluster.&lt;/p&gt; &lt;p&gt;Constraints: Must be between &lt;code&gt;1115&lt;/code&gt; and &lt;code&gt;65535&lt;/code&gt;.&lt;/p&gt; (optional)
     * @param availabilityZone &lt;p&gt;The Amazon EC2 Availability Zone in which to restore the cluster.&lt;/p&gt; &lt;p&gt;Default: A random, system-chosen Availability Zone.&lt;/p&gt; &lt;p&gt;Example: &lt;code&gt;us-east-2a&lt;/code&gt; &lt;/p&gt; (optional)
     * @param allowVersionUpgrade &lt;p&gt;If &lt;code&gt;true&lt;/code&gt;, major version upgrades can be applied during the maintenance window to the Amazon Redshift engine that is running on the cluster. &lt;/p&gt; &lt;p&gt;Default: &lt;code&gt;true&lt;/code&gt; &lt;/p&gt; (optional)
     * @param clusterSubnetGroupName &lt;p&gt;The name of the subnet group where you want to cluster restored.&lt;/p&gt; &lt;p&gt;A snapshot of cluster in VPC can be restored only in VPC. Therefore, you must provide subnet group name where you want the cluster restored.&lt;/p&gt; (optional)
     * @param publiclyAccessible If &lt;code&gt;true&lt;/code&gt;, the cluster can be accessed from a public network.  (optional)
     * @param ownerAccount The Amazon Web Services account used to create or copy the snapshot. Required if you are restoring a snapshot you do not own, optional if you own the snapshot. (optional)
     * @param hsmClientCertificateIdentifier Specifies the name of the HSM client certificate the Amazon Redshift cluster uses to retrieve the data encryption keys stored in an HSM. (optional)
     * @param hsmConfigurationIdentifier Specifies the name of the HSM configuration that contains the information the Amazon Redshift cluster can use to retrieve and store keys in an HSM. (optional)
     * @param elasticIp The Elastic IP (EIP) address for the cluster. Don&#39;t specify the Elastic IP address for a publicly accessible cluster with availability zone relocation turned on. (optional)
     * @param clusterParameterGroupName &lt;p&gt;The name of the parameter group to be associated with this cluster.&lt;/p&gt; &lt;p&gt;Default: The default Amazon Redshift cluster parameter group. For information about the default parameter group, go to &lt;a href&#x3D;\&quot;https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-parameter-groups.html\&quot;&gt;Working with Amazon Redshift Parameter Groups&lt;/a&gt;.&lt;/p&gt; &lt;p&gt;Constraints:&lt;/p&gt; &lt;ul&gt; &lt;li&gt; &lt;p&gt;Must be 1 to 255 alphanumeric characters or hyphens.&lt;/p&gt; &lt;/li&gt; &lt;li&gt; &lt;p&gt;First character must be a letter.&lt;/p&gt; &lt;/li&gt; &lt;li&gt; &lt;p&gt;Cannot end with a hyphen or contain two consecutive hyphens.&lt;/p&gt; &lt;/li&gt; &lt;/ul&gt; (optional)
     * @param clusterSecurityGroups &lt;p&gt;A list of security groups to be associated with this cluster.&lt;/p&gt; &lt;p&gt;Default: The default cluster security group for Amazon Redshift.&lt;/p&gt; &lt;p&gt;Cluster security groups only apply to clusters outside of VPCs.&lt;/p&gt; (optional)
     * @param vpcSecurityGroupIds &lt;p&gt;A list of Virtual Private Cloud (VPC) security groups to be associated with the cluster.&lt;/p&gt; &lt;p&gt;Default: The default VPC security group is associated with the cluster.&lt;/p&gt; &lt;p&gt;VPC security groups only apply to clusters in VPCs.&lt;/p&gt; (optional)
     * @param preferredMaintenanceWindow &lt;p&gt;The weekly time range (in UTC) during which automated cluster maintenance can occur.&lt;/p&gt; &lt;p&gt; Format: &lt;code&gt;ddd:hh24:mi-ddd:hh24:mi&lt;/code&gt; &lt;/p&gt; &lt;p&gt; Default: The value selected for the cluster from which the snapshot was taken. For more information about the time blocks for each region, see &lt;a href&#x3D;\&quot;https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html#rs-maintenance-windows\&quot;&gt;Maintenance Windows&lt;/a&gt; in Amazon Redshift Cluster Management Guide. &lt;/p&gt; &lt;p&gt;Valid Days: Mon | Tue | Wed | Thu | Fri | Sat | Sun&lt;/p&gt; &lt;p&gt;Constraints: Minimum 30-minute window.&lt;/p&gt; (optional)
     * @param automatedSnapshotRetentionPeriod &lt;p&gt;The number of days that automated snapshots are retained. If the value is 0, automated snapshots are disabled. Even if automated snapshots are disabled, you can still create manual snapshots when you want with &lt;a&gt;CreateClusterSnapshot&lt;/a&gt;. &lt;/p&gt; &lt;p&gt;You can&#39;t disable automated snapshots for RA3 node types. Set the automated retention period from 1-35 days.&lt;/p&gt; &lt;p&gt;Default: The value selected for the cluster from which the snapshot was taken.&lt;/p&gt; &lt;p&gt;Constraints: Must be a value from 0 to 35.&lt;/p&gt; (optional)
     * @param manualSnapshotRetentionPeriod &lt;p&gt;The default number of days to retain a manual snapshot. If the value is -1, the snapshot is retained indefinitely. This setting doesn&#39;t change the retention period of existing snapshots.&lt;/p&gt; &lt;p&gt;The value must be either -1 or an integer between 1 and 3,653.&lt;/p&gt; (optional)
     * @param kmsKeyId The Key Management Service (KMS) key ID of the encryption key that encrypts data in the cluster restored from a shared snapshot. You can also provide the key ID when you restore from an unencrypted snapshot to an encrypted cluster in the same account. Additionally, you can specify a new KMS key ID when you restore from an encrypted snapshot in the same account in order to change it. In that case, the restored cluster is encrypted with the new KMS key ID. (optional)
     * @param nodeType &lt;p&gt;The node type that the restored cluster will be provisioned with.&lt;/p&gt; &lt;p&gt;Default: The node type of the cluster from which the snapshot was taken. You can modify this if you are using any DS node type. In that case, you can choose to restore into another DS node type of the same size. For example, you can restore ds1.8xlarge into ds2.8xlarge, or ds1.xlarge into ds2.xlarge. If you have a DC instance type, you must restore into that same instance type and size. In other words, you can only restore a dc1.large instance type into another dc1.large instance type or dc2.large instance type. You can&#39;t restore dc1.8xlarge to dc2.8xlarge. First restore to a dc1.8xlarge cluster, then resize to a dc2.8large cluster. For more information about node types, see &lt;a href&#x3D;\&quot;https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html#rs-about-clusters-and-nodes\&quot;&gt; About Clusters and Nodes&lt;/a&gt; in the &lt;i&gt;Amazon Redshift Cluster Management Guide&lt;/i&gt;. &lt;/p&gt; (optional)
     * @param enhancedVpcRouting &lt;p&gt;An option that specifies whether to create the cluster with enhanced VPC routing enabled. To create a cluster that uses enhanced VPC routing, the cluster must be in a VPC. For more information, see &lt;a href&#x3D;\&quot;https://docs.aws.amazon.com/redshift/latest/mgmt/enhanced-vpc-routing.html\&quot;&gt;Enhanced VPC Routing&lt;/a&gt; in the Amazon Redshift Cluster Management Guide.&lt;/p&gt; &lt;p&gt;If this option is &lt;code&gt;true&lt;/code&gt;, enhanced VPC routing is enabled. &lt;/p&gt; &lt;p&gt;Default: false&lt;/p&gt; (optional)
     * @param additionalInfo Reserved. (optional)
     * @param iamRoles &lt;p&gt;A list of Identity and Access Management (IAM) roles that can be used by the cluster to access other Amazon Web Services services. You must supply the IAM roles in their Amazon Resource Name (ARN) format. &lt;/p&gt; &lt;p&gt;The maximum number of IAM roles that you can associate is subject to a quota. For more information, go to &lt;a href&#x3D;\&quot;https://docs.aws.amazon.com/redshift/latest/mgmt/amazon-redshift-limits.html\&quot;&gt;Quotas and limits&lt;/a&gt; in the &lt;i&gt;Amazon Redshift Cluster Management Guide&lt;/i&gt;.&lt;/p&gt; (optional)
     * @param maintenanceTrackName The name of the maintenance track for the restored cluster. When you take a snapshot, the snapshot inherits the &lt;code&gt;MaintenanceTrack&lt;/code&gt; value from the cluster. The snapshot might be on a different track than the cluster that was the source for the snapshot. For example, suppose that you take a snapshot of a cluster that is on the current track and then change the cluster to be on the trailing track. In this case, the snapshot and the source cluster are on different tracks. (optional)
     * @param snapshotScheduleIdentifier A unique identifier for the snapshot schedule. (optional)
     * @param numberOfNodes The number of nodes specified when provisioning the restored cluster. (optional)
     * @param availabilityZoneRelocation The option to enable relocation for an Amazon Redshift cluster between Availability Zones after the cluster is restored. (optional)
     * @param aquaConfigurationStatus This parameter is retired. It does not set the AQUA configuration status. Amazon Redshift automatically determines whether to use AQUA (Advanced Query Accelerator). (optional)
     * @param defaultIamRoleArn The Amazon Resource Name (ARN) for the IAM role that was set as default for the cluster when the cluster was last modified while it was restored from a snapshot. (optional)
     * @param reservedNodeId The identifier of the target reserved node offering. (optional)
     * @param targetReservedNodeOfferingId The identifier of the target reserved node offering. (optional)
     * @param encrypted Enables support for restoring an unencrypted snapshot to a cluster encrypted with Key Management Service (KMS) and a customer managed key. (optional)
     * @return ApiResponse&lt;RestoreFromClusterSnapshotResult&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> AccessToSnapshotDeniedFault </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> ClusterAlreadyExistsFault </td><td>  -  </td></tr>
        <tr><td> 482 </td><td> ClusterSnapshotNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 483 </td><td> ClusterQuotaExceededFault </td><td>  -  </td></tr>
        <tr><td> 484 </td><td> InsufficientClusterCapacityFault </td><td>  -  </td></tr>
        <tr><td> 485 </td><td> InvalidClusterSnapshotStateFault </td><td>  -  </td></tr>
        <tr><td> 486 </td><td> InvalidRestoreFault </td><td>  -  </td></tr>
        <tr><td> 487 </td><td> NumberOfNodesQuotaExceededFault </td><td>  -  </td></tr>
        <tr><td> 488 </td><td> NumberOfNodesPerClusterLimitExceededFault </td><td>  -  </td></tr>
        <tr><td> 489 </td><td> InvalidVPCNetworkStateFault </td><td>  -  </td></tr>
        <tr><td> 490 </td><td> InvalidClusterSubnetGroupStateFault </td><td>  -  </td></tr>
        <tr><td> 491 </td><td> InvalidSubnet </td><td>  -  </td></tr>
        <tr><td> 492 </td><td> ClusterSubnetGroupNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 493 </td><td> UnauthorizedOperation </td><td>  -  </td></tr>
        <tr><td> 494 </td><td> HsmClientCertificateNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 495 </td><td> HsmConfigurationNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 496 </td><td> InvalidElasticIpFault </td><td>  -  </td></tr>
        <tr><td> 497 </td><td> ClusterParameterGroupNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 498 </td><td> ClusterSecurityGroupNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 499 </td><td> LimitExceededFault </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> DependentServiceRequestThrottlingFault </td><td>  -  </td></tr>
        <tr><td> 501 </td><td> InvalidClusterTrackFault </td><td>  -  </td></tr>
        <tr><td> 502 </td><td> SnapshotScheduleNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 503 </td><td> TagLimitExceededFault </td><td>  -  </td></tr>
        <tr><td> 504 </td><td> InvalidTagFault </td><td>  -  </td></tr>
        <tr><td> 505 </td><td> ReservedNodeNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 506 </td><td> InvalidReservedNodeStateFault </td><td>  -  </td></tr>
        <tr><td> 507 </td><td> ReservedNodeAlreadyMigratedFault </td><td>  -  </td></tr>
        <tr><td> 508 </td><td> ReservedNodeOfferingNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 509 </td><td> DependentServiceUnavailableFault </td><td>  -  </td></tr>
        <tr><td> 510 </td><td> ReservedNodeAlreadyExistsFault </td><td>  -  </td></tr>
        <tr><td> 511 </td><td> UnsupportedOperationFault </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<RestoreFromClusterSnapshotResult> gETRestoreFromClusterSnapshotWithHttpInfo(String clusterIdentifier, String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, String snapshotIdentifier, String snapshotArn, String snapshotClusterIdentifier, Integer port, String availabilityZone, Boolean allowVersionUpgrade, String clusterSubnetGroupName, Boolean publiclyAccessible, String ownerAccount, String hsmClientCertificateIdentifier, String hsmConfigurationIdentifier, String elasticIp, String clusterParameterGroupName, List<String> clusterSecurityGroups, List<String> vpcSecurityGroupIds, String preferredMaintenanceWindow, Integer automatedSnapshotRetentionPeriod, Integer manualSnapshotRetentionPeriod, String kmsKeyId, String nodeType, Boolean enhancedVpcRouting, String additionalInfo, List<String> iamRoles, String maintenanceTrackName, String snapshotScheduleIdentifier, Integer numberOfNodes, Boolean availabilityZoneRelocation, String aquaConfigurationStatus, String defaultIamRoleArn, String reservedNodeId, String targetReservedNodeOfferingId, Boolean encrypted) throws ApiException {
        okhttp3.Call localVarCall = gETRestoreFromClusterSnapshotValidateBeforeCall(clusterIdentifier, action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, snapshotIdentifier, snapshotArn, snapshotClusterIdentifier, port, availabilityZone, allowVersionUpgrade, clusterSubnetGroupName, publiclyAccessible, ownerAccount, hsmClientCertificateIdentifier, hsmConfigurationIdentifier, elasticIp, clusterParameterGroupName, clusterSecurityGroups, vpcSecurityGroupIds, preferredMaintenanceWindow, automatedSnapshotRetentionPeriod, manualSnapshotRetentionPeriod, kmsKeyId, nodeType, enhancedVpcRouting, additionalInfo, iamRoles, maintenanceTrackName, snapshotScheduleIdentifier, numberOfNodes, availabilityZoneRelocation, aquaConfigurationStatus, defaultIamRoleArn, reservedNodeId, targetReservedNodeOfferingId, encrypted, null);
        Type localVarReturnType = new TypeToken<RestoreFromClusterSnapshotResult>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     *  (asynchronously)
     * &lt;p&gt;Creates a new cluster from a snapshot. By default, Amazon Redshift creates the resulting cluster with the same configuration as the original cluster from which the snapshot was created, except that the new cluster is created with the default cluster security and parameter groups. After Amazon Redshift creates the cluster, you can use the &lt;a&gt;ModifyCluster&lt;/a&gt; API to associate a different security group and different parameter group with the restored cluster. If you are using a DS node type, you can also choose to change to another DS node type of the same size during restore.&lt;/p&gt; &lt;p&gt;If you restore a cluster into a VPC, you must provide a cluster subnet group where you want the cluster restored.&lt;/p&gt; &lt;p&gt; For more information about working with snapshots, go to &lt;a href&#x3D;\&quot;https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-snapshots.html\&quot;&gt;Amazon Redshift Snapshots&lt;/a&gt; in the &lt;i&gt;Amazon Redshift Cluster Management Guide&lt;/i&gt;.&lt;/p&gt;
     * @param clusterIdentifier &lt;p&gt;The identifier of the cluster that will be created from restoring the snapshot.&lt;/p&gt; &lt;p&gt;Constraints:&lt;/p&gt; &lt;ul&gt; &lt;li&gt; &lt;p&gt;Must contain from 1 to 63 alphanumeric characters or hyphens.&lt;/p&gt; &lt;/li&gt; &lt;li&gt; &lt;p&gt;Alphabetic characters must be lowercase.&lt;/p&gt; &lt;/li&gt; &lt;li&gt; &lt;p&gt;First character must be a letter.&lt;/p&gt; &lt;/li&gt; &lt;li&gt; &lt;p&gt;Cannot end with a hyphen or contain two consecutive hyphens.&lt;/p&gt; &lt;/li&gt; &lt;li&gt; &lt;p&gt;Must be unique for all clusters within an Amazon Web Services account.&lt;/p&gt; &lt;/li&gt; &lt;/ul&gt; (required)
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param snapshotIdentifier &lt;p&gt;The name of the snapshot from which to create the new cluster. This parameter isn&#39;t case sensitive. You must specify this parameter or &lt;code&gt;snapshotArn&lt;/code&gt;, but not both.&lt;/p&gt; &lt;p&gt;Example: &lt;code&gt;my-snapshot-id&lt;/code&gt; &lt;/p&gt; (optional)
     * @param snapshotArn The Amazon Resource Name (ARN) of the snapshot associated with the message to restore from a cluster. You must specify this parameter or &lt;code&gt;snapshotIdentifier&lt;/code&gt;, but not both. (optional)
     * @param snapshotClusterIdentifier The name of the cluster the source snapshot was created from. This parameter is required if your IAM user has a policy containing a snapshot resource element that specifies anything other than * for the cluster name. (optional)
     * @param port &lt;p&gt;The port number on which the cluster accepts connections.&lt;/p&gt; &lt;p&gt;Default: The same port as the original cluster.&lt;/p&gt; &lt;p&gt;Constraints: Must be between &lt;code&gt;1115&lt;/code&gt; and &lt;code&gt;65535&lt;/code&gt;.&lt;/p&gt; (optional)
     * @param availabilityZone &lt;p&gt;The Amazon EC2 Availability Zone in which to restore the cluster.&lt;/p&gt; &lt;p&gt;Default: A random, system-chosen Availability Zone.&lt;/p&gt; &lt;p&gt;Example: &lt;code&gt;us-east-2a&lt;/code&gt; &lt;/p&gt; (optional)
     * @param allowVersionUpgrade &lt;p&gt;If &lt;code&gt;true&lt;/code&gt;, major version upgrades can be applied during the maintenance window to the Amazon Redshift engine that is running on the cluster. &lt;/p&gt; &lt;p&gt;Default: &lt;code&gt;true&lt;/code&gt; &lt;/p&gt; (optional)
     * @param clusterSubnetGroupName &lt;p&gt;The name of the subnet group where you want to cluster restored.&lt;/p&gt; &lt;p&gt;A snapshot of cluster in VPC can be restored only in VPC. Therefore, you must provide subnet group name where you want the cluster restored.&lt;/p&gt; (optional)
     * @param publiclyAccessible If &lt;code&gt;true&lt;/code&gt;, the cluster can be accessed from a public network.  (optional)
     * @param ownerAccount The Amazon Web Services account used to create or copy the snapshot. Required if you are restoring a snapshot you do not own, optional if you own the snapshot. (optional)
     * @param hsmClientCertificateIdentifier Specifies the name of the HSM client certificate the Amazon Redshift cluster uses to retrieve the data encryption keys stored in an HSM. (optional)
     * @param hsmConfigurationIdentifier Specifies the name of the HSM configuration that contains the information the Amazon Redshift cluster can use to retrieve and store keys in an HSM. (optional)
     * @param elasticIp The Elastic IP (EIP) address for the cluster. Don&#39;t specify the Elastic IP address for a publicly accessible cluster with availability zone relocation turned on. (optional)
     * @param clusterParameterGroupName &lt;p&gt;The name of the parameter group to be associated with this cluster.&lt;/p&gt; &lt;p&gt;Default: The default Amazon Redshift cluster parameter group. For information about the default parameter group, go to &lt;a href&#x3D;\&quot;https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-parameter-groups.html\&quot;&gt;Working with Amazon Redshift Parameter Groups&lt;/a&gt;.&lt;/p&gt; &lt;p&gt;Constraints:&lt;/p&gt; &lt;ul&gt; &lt;li&gt; &lt;p&gt;Must be 1 to 255 alphanumeric characters or hyphens.&lt;/p&gt; &lt;/li&gt; &lt;li&gt; &lt;p&gt;First character must be a letter.&lt;/p&gt; &lt;/li&gt; &lt;li&gt; &lt;p&gt;Cannot end with a hyphen or contain two consecutive hyphens.&lt;/p&gt; &lt;/li&gt; &lt;/ul&gt; (optional)
     * @param clusterSecurityGroups &lt;p&gt;A list of security groups to be associated with this cluster.&lt;/p&gt; &lt;p&gt;Default: The default cluster security group for Amazon Redshift.&lt;/p&gt; &lt;p&gt;Cluster security groups only apply to clusters outside of VPCs.&lt;/p&gt; (optional)
     * @param vpcSecurityGroupIds &lt;p&gt;A list of Virtual Private Cloud (VPC) security groups to be associated with the cluster.&lt;/p&gt; &lt;p&gt;Default: The default VPC security group is associated with the cluster.&lt;/p&gt; &lt;p&gt;VPC security groups only apply to clusters in VPCs.&lt;/p&gt; (optional)
     * @param preferredMaintenanceWindow &lt;p&gt;The weekly time range (in UTC) during which automated cluster maintenance can occur.&lt;/p&gt; &lt;p&gt; Format: &lt;code&gt;ddd:hh24:mi-ddd:hh24:mi&lt;/code&gt; &lt;/p&gt; &lt;p&gt; Default: The value selected for the cluster from which the snapshot was taken. For more information about the time blocks for each region, see &lt;a href&#x3D;\&quot;https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html#rs-maintenance-windows\&quot;&gt;Maintenance Windows&lt;/a&gt; in Amazon Redshift Cluster Management Guide. &lt;/p&gt; &lt;p&gt;Valid Days: Mon | Tue | Wed | Thu | Fri | Sat | Sun&lt;/p&gt; &lt;p&gt;Constraints: Minimum 30-minute window.&lt;/p&gt; (optional)
     * @param automatedSnapshotRetentionPeriod &lt;p&gt;The number of days that automated snapshots are retained. If the value is 0, automated snapshots are disabled. Even if automated snapshots are disabled, you can still create manual snapshots when you want with &lt;a&gt;CreateClusterSnapshot&lt;/a&gt;. &lt;/p&gt; &lt;p&gt;You can&#39;t disable automated snapshots for RA3 node types. Set the automated retention period from 1-35 days.&lt;/p&gt; &lt;p&gt;Default: The value selected for the cluster from which the snapshot was taken.&lt;/p&gt; &lt;p&gt;Constraints: Must be a value from 0 to 35.&lt;/p&gt; (optional)
     * @param manualSnapshotRetentionPeriod &lt;p&gt;The default number of days to retain a manual snapshot. If the value is -1, the snapshot is retained indefinitely. This setting doesn&#39;t change the retention period of existing snapshots.&lt;/p&gt; &lt;p&gt;The value must be either -1 or an integer between 1 and 3,653.&lt;/p&gt; (optional)
     * @param kmsKeyId The Key Management Service (KMS) key ID of the encryption key that encrypts data in the cluster restored from a shared snapshot. You can also provide the key ID when you restore from an unencrypted snapshot to an encrypted cluster in the same account. Additionally, you can specify a new KMS key ID when you restore from an encrypted snapshot in the same account in order to change it. In that case, the restored cluster is encrypted with the new KMS key ID. (optional)
     * @param nodeType &lt;p&gt;The node type that the restored cluster will be provisioned with.&lt;/p&gt; &lt;p&gt;Default: The node type of the cluster from which the snapshot was taken. You can modify this if you are using any DS node type. In that case, you can choose to restore into another DS node type of the same size. For example, you can restore ds1.8xlarge into ds2.8xlarge, or ds1.xlarge into ds2.xlarge. If you have a DC instance type, you must restore into that same instance type and size. In other words, you can only restore a dc1.large instance type into another dc1.large instance type or dc2.large instance type. You can&#39;t restore dc1.8xlarge to dc2.8xlarge. First restore to a dc1.8xlarge cluster, then resize to a dc2.8large cluster. For more information about node types, see &lt;a href&#x3D;\&quot;https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html#rs-about-clusters-and-nodes\&quot;&gt; About Clusters and Nodes&lt;/a&gt; in the &lt;i&gt;Amazon Redshift Cluster Management Guide&lt;/i&gt;. &lt;/p&gt; (optional)
     * @param enhancedVpcRouting &lt;p&gt;An option that specifies whether to create the cluster with enhanced VPC routing enabled. To create a cluster that uses enhanced VPC routing, the cluster must be in a VPC. For more information, see &lt;a href&#x3D;\&quot;https://docs.aws.amazon.com/redshift/latest/mgmt/enhanced-vpc-routing.html\&quot;&gt;Enhanced VPC Routing&lt;/a&gt; in the Amazon Redshift Cluster Management Guide.&lt;/p&gt; &lt;p&gt;If this option is &lt;code&gt;true&lt;/code&gt;, enhanced VPC routing is enabled. &lt;/p&gt; &lt;p&gt;Default: false&lt;/p&gt; (optional)
     * @param additionalInfo Reserved. (optional)
     * @param iamRoles &lt;p&gt;A list of Identity and Access Management (IAM) roles that can be used by the cluster to access other Amazon Web Services services. You must supply the IAM roles in their Amazon Resource Name (ARN) format. &lt;/p&gt; &lt;p&gt;The maximum number of IAM roles that you can associate is subject to a quota. For more information, go to &lt;a href&#x3D;\&quot;https://docs.aws.amazon.com/redshift/latest/mgmt/amazon-redshift-limits.html\&quot;&gt;Quotas and limits&lt;/a&gt; in the &lt;i&gt;Amazon Redshift Cluster Management Guide&lt;/i&gt;.&lt;/p&gt; (optional)
     * @param maintenanceTrackName The name of the maintenance track for the restored cluster. When you take a snapshot, the snapshot inherits the &lt;code&gt;MaintenanceTrack&lt;/code&gt; value from the cluster. The snapshot might be on a different track than the cluster that was the source for the snapshot. For example, suppose that you take a snapshot of a cluster that is on the current track and then change the cluster to be on the trailing track. In this case, the snapshot and the source cluster are on different tracks. (optional)
     * @param snapshotScheduleIdentifier A unique identifier for the snapshot schedule. (optional)
     * @param numberOfNodes The number of nodes specified when provisioning the restored cluster. (optional)
     * @param availabilityZoneRelocation The option to enable relocation for an Amazon Redshift cluster between Availability Zones after the cluster is restored. (optional)
     * @param aquaConfigurationStatus This parameter is retired. It does not set the AQUA configuration status. Amazon Redshift automatically determines whether to use AQUA (Advanced Query Accelerator). (optional)
     * @param defaultIamRoleArn The Amazon Resource Name (ARN) for the IAM role that was set as default for the cluster when the cluster was last modified while it was restored from a snapshot. (optional)
     * @param reservedNodeId The identifier of the target reserved node offering. (optional)
     * @param targetReservedNodeOfferingId The identifier of the target reserved node offering. (optional)
     * @param encrypted Enables support for restoring an unencrypted snapshot to a cluster encrypted with Key Management Service (KMS) and a customer managed key. (optional)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> AccessToSnapshotDeniedFault </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> ClusterAlreadyExistsFault </td><td>  -  </td></tr>
        <tr><td> 482 </td><td> ClusterSnapshotNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 483 </td><td> ClusterQuotaExceededFault </td><td>  -  </td></tr>
        <tr><td> 484 </td><td> InsufficientClusterCapacityFault </td><td>  -  </td></tr>
        <tr><td> 485 </td><td> InvalidClusterSnapshotStateFault </td><td>  -  </td></tr>
        <tr><td> 486 </td><td> InvalidRestoreFault </td><td>  -  </td></tr>
        <tr><td> 487 </td><td> NumberOfNodesQuotaExceededFault </td><td>  -  </td></tr>
        <tr><td> 488 </td><td> NumberOfNodesPerClusterLimitExceededFault </td><td>  -  </td></tr>
        <tr><td> 489 </td><td> InvalidVPCNetworkStateFault </td><td>  -  </td></tr>
        <tr><td> 490 </td><td> InvalidClusterSubnetGroupStateFault </td><td>  -  </td></tr>
        <tr><td> 491 </td><td> InvalidSubnet </td><td>  -  </td></tr>
        <tr><td> 492 </td><td> ClusterSubnetGroupNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 493 </td><td> UnauthorizedOperation </td><td>  -  </td></tr>
        <tr><td> 494 </td><td> HsmClientCertificateNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 495 </td><td> HsmConfigurationNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 496 </td><td> InvalidElasticIpFault </td><td>  -  </td></tr>
        <tr><td> 497 </td><td> ClusterParameterGroupNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 498 </td><td> ClusterSecurityGroupNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 499 </td><td> LimitExceededFault </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> DependentServiceRequestThrottlingFault </td><td>  -  </td></tr>
        <tr><td> 501 </td><td> InvalidClusterTrackFault </td><td>  -  </td></tr>
        <tr><td> 502 </td><td> SnapshotScheduleNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 503 </td><td> TagLimitExceededFault </td><td>  -  </td></tr>
        <tr><td> 504 </td><td> InvalidTagFault </td><td>  -  </td></tr>
        <tr><td> 505 </td><td> ReservedNodeNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 506 </td><td> InvalidReservedNodeStateFault </td><td>  -  </td></tr>
        <tr><td> 507 </td><td> ReservedNodeAlreadyMigratedFault </td><td>  -  </td></tr>
        <tr><td> 508 </td><td> ReservedNodeOfferingNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 509 </td><td> DependentServiceUnavailableFault </td><td>  -  </td></tr>
        <tr><td> 510 </td><td> ReservedNodeAlreadyExistsFault </td><td>  -  </td></tr>
        <tr><td> 511 </td><td> UnsupportedOperationFault </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call gETRestoreFromClusterSnapshotAsync(String clusterIdentifier, String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, String snapshotIdentifier, String snapshotArn, String snapshotClusterIdentifier, Integer port, String availabilityZone, Boolean allowVersionUpgrade, String clusterSubnetGroupName, Boolean publiclyAccessible, String ownerAccount, String hsmClientCertificateIdentifier, String hsmConfigurationIdentifier, String elasticIp, String clusterParameterGroupName, List<String> clusterSecurityGroups, List<String> vpcSecurityGroupIds, String preferredMaintenanceWindow, Integer automatedSnapshotRetentionPeriod, Integer manualSnapshotRetentionPeriod, String kmsKeyId, String nodeType, Boolean enhancedVpcRouting, String additionalInfo, List<String> iamRoles, String maintenanceTrackName, String snapshotScheduleIdentifier, Integer numberOfNodes, Boolean availabilityZoneRelocation, String aquaConfigurationStatus, String defaultIamRoleArn, String reservedNodeId, String targetReservedNodeOfferingId, Boolean encrypted, final ApiCallback<RestoreFromClusterSnapshotResult> _callback) throws ApiException {

        okhttp3.Call localVarCall = gETRestoreFromClusterSnapshotValidateBeforeCall(clusterIdentifier, action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, snapshotIdentifier, snapshotArn, snapshotClusterIdentifier, port, availabilityZone, allowVersionUpgrade, clusterSubnetGroupName, publiclyAccessible, ownerAccount, hsmClientCertificateIdentifier, hsmConfigurationIdentifier, elasticIp, clusterParameterGroupName, clusterSecurityGroups, vpcSecurityGroupIds, preferredMaintenanceWindow, automatedSnapshotRetentionPeriod, manualSnapshotRetentionPeriod, kmsKeyId, nodeType, enhancedVpcRouting, additionalInfo, iamRoles, maintenanceTrackName, snapshotScheduleIdentifier, numberOfNodes, availabilityZoneRelocation, aquaConfigurationStatus, defaultIamRoleArn, reservedNodeId, targetReservedNodeOfferingId, encrypted, _callback);
        Type localVarReturnType = new TypeToken<RestoreFromClusterSnapshotResult>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for gETRestoreTableFromClusterSnapshot
     * @param clusterIdentifier The identifier of the Amazon Redshift cluster to restore the table to. (required)
     * @param snapshotIdentifier The identifier of the snapshot to restore the table from. This snapshot must have been created from the Amazon Redshift cluster specified by the &lt;code&gt;ClusterIdentifier&lt;/code&gt; parameter. (required)
     * @param sourceDatabaseName The name of the source database that contains the table to restore from. (required)
     * @param sourceTableName The name of the source table to restore from. (required)
     * @param newTableName The name of the table to create as a result of the current request. (required)
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param sourceSchemaName The name of the source schema that contains the table to restore from. If you do not specify a &lt;code&gt;SourceSchemaName&lt;/code&gt; value, the default is &lt;code&gt;public&lt;/code&gt;. (optional)
     * @param targetDatabaseName The name of the database to restore the table to. (optional)
     * @param targetSchemaName The name of the schema to restore the table to. (optional)
     * @param enableCaseSensitiveIdentifier Indicates whether name identifiers for database, schema, and table are case sensitive. If &lt;code&gt;true&lt;/code&gt;, the names are case sensitive. If &lt;code&gt;false&lt;/code&gt; (default), the names are not case sensitive. (optional)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> ClusterSnapshotNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> InProgressTableRestoreQuotaExceededFault </td><td>  -  </td></tr>
        <tr><td> 482 </td><td> InvalidClusterSnapshotStateFault </td><td>  -  </td></tr>
        <tr><td> 483 </td><td> InvalidTableRestoreArgumentFault </td><td>  -  </td></tr>
        <tr><td> 484 </td><td> ClusterNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 485 </td><td> InvalidClusterStateFault </td><td>  -  </td></tr>
        <tr><td> 486 </td><td> UnsupportedOperationFault </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call gETRestoreTableFromClusterSnapshotCall(String clusterIdentifier, String snapshotIdentifier, String sourceDatabaseName, String sourceTableName, String newTableName, String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, String sourceSchemaName, String targetDatabaseName, String targetSchemaName, Boolean enableCaseSensitiveIdentifier, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/#Action=RestoreTableFromClusterSnapshot";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (clusterIdentifier != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("ClusterIdentifier", clusterIdentifier));
        }

        if (snapshotIdentifier != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("SnapshotIdentifier", snapshotIdentifier));
        }

        if (sourceDatabaseName != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("SourceDatabaseName", sourceDatabaseName));
        }

        if (sourceSchemaName != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("SourceSchemaName", sourceSchemaName));
        }

        if (sourceTableName != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("SourceTableName", sourceTableName));
        }

        if (targetDatabaseName != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("TargetDatabaseName", targetDatabaseName));
        }

        if (targetSchemaName != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("TargetSchemaName", targetSchemaName));
        }

        if (newTableName != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("NewTableName", newTableName));
        }

        if (enableCaseSensitiveIdentifier != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("EnableCaseSensitiveIdentifier", enableCaseSensitiveIdentifier));
        }

        if (action != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("Action", action));
        }

        if (version != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("Version", version));
        }

        if (xAmzContentSha256 != null) {
            localVarHeaderParams.put("X-Amz-Content-Sha256", localVarApiClient.parameterToString(xAmzContentSha256));
        }

        if (xAmzDate != null) {
            localVarHeaderParams.put("X-Amz-Date", localVarApiClient.parameterToString(xAmzDate));
        }

        if (xAmzAlgorithm != null) {
            localVarHeaderParams.put("X-Amz-Algorithm", localVarApiClient.parameterToString(xAmzAlgorithm));
        }

        if (xAmzCredential != null) {
            localVarHeaderParams.put("X-Amz-Credential", localVarApiClient.parameterToString(xAmzCredential));
        }

        if (xAmzSecurityToken != null) {
            localVarHeaderParams.put("X-Amz-Security-Token", localVarApiClient.parameterToString(xAmzSecurityToken));
        }

        if (xAmzSignature != null) {
            localVarHeaderParams.put("X-Amz-Signature", localVarApiClient.parameterToString(xAmzSignature));
        }

        if (xAmzSignedHeaders != null) {
            localVarHeaderParams.put("X-Amz-SignedHeaders", localVarApiClient.parameterToString(xAmzSignedHeaders));
        }

        final String[] localVarAccepts = {
            "text/xml"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "hmac" };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call gETRestoreTableFromClusterSnapshotValidateBeforeCall(String clusterIdentifier, String snapshotIdentifier, String sourceDatabaseName, String sourceTableName, String newTableName, String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, String sourceSchemaName, String targetDatabaseName, String targetSchemaName, Boolean enableCaseSensitiveIdentifier, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'clusterIdentifier' is set
        if (clusterIdentifier == null) {
            throw new ApiException("Missing the required parameter 'clusterIdentifier' when calling gETRestoreTableFromClusterSnapshot(Async)");
        }

        // verify the required parameter 'snapshotIdentifier' is set
        if (snapshotIdentifier == null) {
            throw new ApiException("Missing the required parameter 'snapshotIdentifier' when calling gETRestoreTableFromClusterSnapshot(Async)");
        }

        // verify the required parameter 'sourceDatabaseName' is set
        if (sourceDatabaseName == null) {
            throw new ApiException("Missing the required parameter 'sourceDatabaseName' when calling gETRestoreTableFromClusterSnapshot(Async)");
        }

        // verify the required parameter 'sourceTableName' is set
        if (sourceTableName == null) {
            throw new ApiException("Missing the required parameter 'sourceTableName' when calling gETRestoreTableFromClusterSnapshot(Async)");
        }

        // verify the required parameter 'newTableName' is set
        if (newTableName == null) {
            throw new ApiException("Missing the required parameter 'newTableName' when calling gETRestoreTableFromClusterSnapshot(Async)");
        }

        // verify the required parameter 'action' is set
        if (action == null) {
            throw new ApiException("Missing the required parameter 'action' when calling gETRestoreTableFromClusterSnapshot(Async)");
        }

        // verify the required parameter 'version' is set
        if (version == null) {
            throw new ApiException("Missing the required parameter 'version' when calling gETRestoreTableFromClusterSnapshot(Async)");
        }

        return gETRestoreTableFromClusterSnapshotCall(clusterIdentifier, snapshotIdentifier, sourceDatabaseName, sourceTableName, newTableName, action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, sourceSchemaName, targetDatabaseName, targetSchemaName, enableCaseSensitiveIdentifier, _callback);

    }

    /**
     * 
     * &lt;p&gt;Creates a new table from a table in an Amazon Redshift cluster snapshot. You must create the new table within the Amazon Redshift cluster that the snapshot was taken from.&lt;/p&gt; &lt;p&gt;You cannot use &lt;code&gt;RestoreTableFromClusterSnapshot&lt;/code&gt; to restore a table with the same name as an existing table in an Amazon Redshift cluster. That is, you cannot overwrite an existing table in a cluster with a restored table. If you want to replace your original table with a new, restored table, then rename or drop your original table before you call &lt;code&gt;RestoreTableFromClusterSnapshot&lt;/code&gt;. When you have renamed your original table, then you can pass the original name of the table as the &lt;code&gt;NewTableName&lt;/code&gt; parameter value in the call to &lt;code&gt;RestoreTableFromClusterSnapshot&lt;/code&gt;. This way, you can replace the original table with the table created from the snapshot.&lt;/p&gt; &lt;p&gt;You can&#39;t use this operation to restore tables with &lt;a href&#x3D;\&quot;https://docs.aws.amazon.com/redshift/latest/dg/t_Sorting_data.html#t_Sorting_data-interleaved\&quot;&gt;interleaved sort keys&lt;/a&gt;.&lt;/p&gt;
     * @param clusterIdentifier The identifier of the Amazon Redshift cluster to restore the table to. (required)
     * @param snapshotIdentifier The identifier of the snapshot to restore the table from. This snapshot must have been created from the Amazon Redshift cluster specified by the &lt;code&gt;ClusterIdentifier&lt;/code&gt; parameter. (required)
     * @param sourceDatabaseName The name of the source database that contains the table to restore from. (required)
     * @param sourceTableName The name of the source table to restore from. (required)
     * @param newTableName The name of the table to create as a result of the current request. (required)
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param sourceSchemaName The name of the source schema that contains the table to restore from. If you do not specify a &lt;code&gt;SourceSchemaName&lt;/code&gt; value, the default is &lt;code&gt;public&lt;/code&gt;. (optional)
     * @param targetDatabaseName The name of the database to restore the table to. (optional)
     * @param targetSchemaName The name of the schema to restore the table to. (optional)
     * @param enableCaseSensitiveIdentifier Indicates whether name identifiers for database, schema, and table are case sensitive. If &lt;code&gt;true&lt;/code&gt;, the names are case sensitive. If &lt;code&gt;false&lt;/code&gt; (default), the names are not case sensitive. (optional)
     * @return RestoreTableFromClusterSnapshotResult
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> ClusterSnapshotNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> InProgressTableRestoreQuotaExceededFault </td><td>  -  </td></tr>
        <tr><td> 482 </td><td> InvalidClusterSnapshotStateFault </td><td>  -  </td></tr>
        <tr><td> 483 </td><td> InvalidTableRestoreArgumentFault </td><td>  -  </td></tr>
        <tr><td> 484 </td><td> ClusterNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 485 </td><td> InvalidClusterStateFault </td><td>  -  </td></tr>
        <tr><td> 486 </td><td> UnsupportedOperationFault </td><td>  -  </td></tr>
     </table>
     */
    public RestoreTableFromClusterSnapshotResult gETRestoreTableFromClusterSnapshot(String clusterIdentifier, String snapshotIdentifier, String sourceDatabaseName, String sourceTableName, String newTableName, String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, String sourceSchemaName, String targetDatabaseName, String targetSchemaName, Boolean enableCaseSensitiveIdentifier) throws ApiException {
        ApiResponse<RestoreTableFromClusterSnapshotResult> localVarResp = gETRestoreTableFromClusterSnapshotWithHttpInfo(clusterIdentifier, snapshotIdentifier, sourceDatabaseName, sourceTableName, newTableName, action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, sourceSchemaName, targetDatabaseName, targetSchemaName, enableCaseSensitiveIdentifier);
        return localVarResp.getData();
    }

    /**
     * 
     * &lt;p&gt;Creates a new table from a table in an Amazon Redshift cluster snapshot. You must create the new table within the Amazon Redshift cluster that the snapshot was taken from.&lt;/p&gt; &lt;p&gt;You cannot use &lt;code&gt;RestoreTableFromClusterSnapshot&lt;/code&gt; to restore a table with the same name as an existing table in an Amazon Redshift cluster. That is, you cannot overwrite an existing table in a cluster with a restored table. If you want to replace your original table with a new, restored table, then rename or drop your original table before you call &lt;code&gt;RestoreTableFromClusterSnapshot&lt;/code&gt;. When you have renamed your original table, then you can pass the original name of the table as the &lt;code&gt;NewTableName&lt;/code&gt; parameter value in the call to &lt;code&gt;RestoreTableFromClusterSnapshot&lt;/code&gt;. This way, you can replace the original table with the table created from the snapshot.&lt;/p&gt; &lt;p&gt;You can&#39;t use this operation to restore tables with &lt;a href&#x3D;\&quot;https://docs.aws.amazon.com/redshift/latest/dg/t_Sorting_data.html#t_Sorting_data-interleaved\&quot;&gt;interleaved sort keys&lt;/a&gt;.&lt;/p&gt;
     * @param clusterIdentifier The identifier of the Amazon Redshift cluster to restore the table to. (required)
     * @param snapshotIdentifier The identifier of the snapshot to restore the table from. This snapshot must have been created from the Amazon Redshift cluster specified by the &lt;code&gt;ClusterIdentifier&lt;/code&gt; parameter. (required)
     * @param sourceDatabaseName The name of the source database that contains the table to restore from. (required)
     * @param sourceTableName The name of the source table to restore from. (required)
     * @param newTableName The name of the table to create as a result of the current request. (required)
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param sourceSchemaName The name of the source schema that contains the table to restore from. If you do not specify a &lt;code&gt;SourceSchemaName&lt;/code&gt; value, the default is &lt;code&gt;public&lt;/code&gt;. (optional)
     * @param targetDatabaseName The name of the database to restore the table to. (optional)
     * @param targetSchemaName The name of the schema to restore the table to. (optional)
     * @param enableCaseSensitiveIdentifier Indicates whether name identifiers for database, schema, and table are case sensitive. If &lt;code&gt;true&lt;/code&gt;, the names are case sensitive. If &lt;code&gt;false&lt;/code&gt; (default), the names are not case sensitive. (optional)
     * @return ApiResponse&lt;RestoreTableFromClusterSnapshotResult&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> ClusterSnapshotNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> InProgressTableRestoreQuotaExceededFault </td><td>  -  </td></tr>
        <tr><td> 482 </td><td> InvalidClusterSnapshotStateFault </td><td>  -  </td></tr>
        <tr><td> 483 </td><td> InvalidTableRestoreArgumentFault </td><td>  -  </td></tr>
        <tr><td> 484 </td><td> ClusterNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 485 </td><td> InvalidClusterStateFault </td><td>  -  </td></tr>
        <tr><td> 486 </td><td> UnsupportedOperationFault </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<RestoreTableFromClusterSnapshotResult> gETRestoreTableFromClusterSnapshotWithHttpInfo(String clusterIdentifier, String snapshotIdentifier, String sourceDatabaseName, String sourceTableName, String newTableName, String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, String sourceSchemaName, String targetDatabaseName, String targetSchemaName, Boolean enableCaseSensitiveIdentifier) throws ApiException {
        okhttp3.Call localVarCall = gETRestoreTableFromClusterSnapshotValidateBeforeCall(clusterIdentifier, snapshotIdentifier, sourceDatabaseName, sourceTableName, newTableName, action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, sourceSchemaName, targetDatabaseName, targetSchemaName, enableCaseSensitiveIdentifier, null);
        Type localVarReturnType = new TypeToken<RestoreTableFromClusterSnapshotResult>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     *  (asynchronously)
     * &lt;p&gt;Creates a new table from a table in an Amazon Redshift cluster snapshot. You must create the new table within the Amazon Redshift cluster that the snapshot was taken from.&lt;/p&gt; &lt;p&gt;You cannot use &lt;code&gt;RestoreTableFromClusterSnapshot&lt;/code&gt; to restore a table with the same name as an existing table in an Amazon Redshift cluster. That is, you cannot overwrite an existing table in a cluster with a restored table. If you want to replace your original table with a new, restored table, then rename or drop your original table before you call &lt;code&gt;RestoreTableFromClusterSnapshot&lt;/code&gt;. When you have renamed your original table, then you can pass the original name of the table as the &lt;code&gt;NewTableName&lt;/code&gt; parameter value in the call to &lt;code&gt;RestoreTableFromClusterSnapshot&lt;/code&gt;. This way, you can replace the original table with the table created from the snapshot.&lt;/p&gt; &lt;p&gt;You can&#39;t use this operation to restore tables with &lt;a href&#x3D;\&quot;https://docs.aws.amazon.com/redshift/latest/dg/t_Sorting_data.html#t_Sorting_data-interleaved\&quot;&gt;interleaved sort keys&lt;/a&gt;.&lt;/p&gt;
     * @param clusterIdentifier The identifier of the Amazon Redshift cluster to restore the table to. (required)
     * @param snapshotIdentifier The identifier of the snapshot to restore the table from. This snapshot must have been created from the Amazon Redshift cluster specified by the &lt;code&gt;ClusterIdentifier&lt;/code&gt; parameter. (required)
     * @param sourceDatabaseName The name of the source database that contains the table to restore from. (required)
     * @param sourceTableName The name of the source table to restore from. (required)
     * @param newTableName The name of the table to create as a result of the current request. (required)
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param sourceSchemaName The name of the source schema that contains the table to restore from. If you do not specify a &lt;code&gt;SourceSchemaName&lt;/code&gt; value, the default is &lt;code&gt;public&lt;/code&gt;. (optional)
     * @param targetDatabaseName The name of the database to restore the table to. (optional)
     * @param targetSchemaName The name of the schema to restore the table to. (optional)
     * @param enableCaseSensitiveIdentifier Indicates whether name identifiers for database, schema, and table are case sensitive. If &lt;code&gt;true&lt;/code&gt;, the names are case sensitive. If &lt;code&gt;false&lt;/code&gt; (default), the names are not case sensitive. (optional)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> ClusterSnapshotNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> InProgressTableRestoreQuotaExceededFault </td><td>  -  </td></tr>
        <tr><td> 482 </td><td> InvalidClusterSnapshotStateFault </td><td>  -  </td></tr>
        <tr><td> 483 </td><td> InvalidTableRestoreArgumentFault </td><td>  -  </td></tr>
        <tr><td> 484 </td><td> ClusterNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 485 </td><td> InvalidClusterStateFault </td><td>  -  </td></tr>
        <tr><td> 486 </td><td> UnsupportedOperationFault </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call gETRestoreTableFromClusterSnapshotAsync(String clusterIdentifier, String snapshotIdentifier, String sourceDatabaseName, String sourceTableName, String newTableName, String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, String sourceSchemaName, String targetDatabaseName, String targetSchemaName, Boolean enableCaseSensitiveIdentifier, final ApiCallback<RestoreTableFromClusterSnapshotResult> _callback) throws ApiException {

        okhttp3.Call localVarCall = gETRestoreTableFromClusterSnapshotValidateBeforeCall(clusterIdentifier, snapshotIdentifier, sourceDatabaseName, sourceTableName, newTableName, action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, sourceSchemaName, targetDatabaseName, targetSchemaName, enableCaseSensitiveIdentifier, _callback);
        Type localVarReturnType = new TypeToken<RestoreTableFromClusterSnapshotResult>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for gETResumeCluster
     * @param clusterIdentifier The identifier of the cluster to be resumed. (required)
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> ClusterNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> InvalidClusterStateFault </td><td>  -  </td></tr>
        <tr><td> 482 </td><td> InsufficientClusterCapacityFault </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call gETResumeClusterCall(String clusterIdentifier, String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/#Action=ResumeCluster";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (clusterIdentifier != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("ClusterIdentifier", clusterIdentifier));
        }

        if (action != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("Action", action));
        }

        if (version != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("Version", version));
        }

        if (xAmzContentSha256 != null) {
            localVarHeaderParams.put("X-Amz-Content-Sha256", localVarApiClient.parameterToString(xAmzContentSha256));
        }

        if (xAmzDate != null) {
            localVarHeaderParams.put("X-Amz-Date", localVarApiClient.parameterToString(xAmzDate));
        }

        if (xAmzAlgorithm != null) {
            localVarHeaderParams.put("X-Amz-Algorithm", localVarApiClient.parameterToString(xAmzAlgorithm));
        }

        if (xAmzCredential != null) {
            localVarHeaderParams.put("X-Amz-Credential", localVarApiClient.parameterToString(xAmzCredential));
        }

        if (xAmzSecurityToken != null) {
            localVarHeaderParams.put("X-Amz-Security-Token", localVarApiClient.parameterToString(xAmzSecurityToken));
        }

        if (xAmzSignature != null) {
            localVarHeaderParams.put("X-Amz-Signature", localVarApiClient.parameterToString(xAmzSignature));
        }

        if (xAmzSignedHeaders != null) {
            localVarHeaderParams.put("X-Amz-SignedHeaders", localVarApiClient.parameterToString(xAmzSignedHeaders));
        }

        final String[] localVarAccepts = {
            "text/xml"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "hmac" };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call gETResumeClusterValidateBeforeCall(String clusterIdentifier, String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'clusterIdentifier' is set
        if (clusterIdentifier == null) {
            throw new ApiException("Missing the required parameter 'clusterIdentifier' when calling gETResumeCluster(Async)");
        }

        // verify the required parameter 'action' is set
        if (action == null) {
            throw new ApiException("Missing the required parameter 'action' when calling gETResumeCluster(Async)");
        }

        // verify the required parameter 'version' is set
        if (version == null) {
            throw new ApiException("Missing the required parameter 'version' when calling gETResumeCluster(Async)");
        }

        return gETResumeClusterCall(clusterIdentifier, action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, _callback);

    }

    /**
     * 
     * Resumes a paused cluster.
     * @param clusterIdentifier The identifier of the cluster to be resumed. (required)
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @return ResumeClusterResult
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> ClusterNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> InvalidClusterStateFault </td><td>  -  </td></tr>
        <tr><td> 482 </td><td> InsufficientClusterCapacityFault </td><td>  -  </td></tr>
     </table>
     */
    public ResumeClusterResult gETResumeCluster(String clusterIdentifier, String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders) throws ApiException {
        ApiResponse<ResumeClusterResult> localVarResp = gETResumeClusterWithHttpInfo(clusterIdentifier, action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders);
        return localVarResp.getData();
    }

    /**
     * 
     * Resumes a paused cluster.
     * @param clusterIdentifier The identifier of the cluster to be resumed. (required)
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @return ApiResponse&lt;ResumeClusterResult&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> ClusterNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> InvalidClusterStateFault </td><td>  -  </td></tr>
        <tr><td> 482 </td><td> InsufficientClusterCapacityFault </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<ResumeClusterResult> gETResumeClusterWithHttpInfo(String clusterIdentifier, String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders) throws ApiException {
        okhttp3.Call localVarCall = gETResumeClusterValidateBeforeCall(clusterIdentifier, action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, null);
        Type localVarReturnType = new TypeToken<ResumeClusterResult>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     *  (asynchronously)
     * Resumes a paused cluster.
     * @param clusterIdentifier The identifier of the cluster to be resumed. (required)
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> ClusterNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> InvalidClusterStateFault </td><td>  -  </td></tr>
        <tr><td> 482 </td><td> InsufficientClusterCapacityFault </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call gETResumeClusterAsync(String clusterIdentifier, String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, final ApiCallback<ResumeClusterResult> _callback) throws ApiException {

        okhttp3.Call localVarCall = gETResumeClusterValidateBeforeCall(clusterIdentifier, action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, _callback);
        Type localVarReturnType = new TypeToken<ResumeClusterResult>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for gETRevokeClusterSecurityGroupIngress
     * @param clusterSecurityGroupName The name of the security Group from which to revoke the ingress rule. (required)
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param CIDRIP The IP range for which to revoke access. This range must be a valid Classless Inter-Domain Routing (CIDR) block of IP addresses. If &lt;code&gt;CIDRIP&lt;/code&gt; is specified, &lt;code&gt;EC2SecurityGroupName&lt;/code&gt; and &lt;code&gt;EC2SecurityGroupOwnerId&lt;/code&gt; cannot be provided.  (optional)
     * @param ec2SecurityGroupName The name of the EC2 Security Group whose access is to be revoked. If &lt;code&gt;EC2SecurityGroupName&lt;/code&gt; is specified, &lt;code&gt;EC2SecurityGroupOwnerId&lt;/code&gt; must also be provided and &lt;code&gt;CIDRIP&lt;/code&gt; cannot be provided.  (optional)
     * @param ec2SecurityGroupOwnerId &lt;p&gt;The Amazon Web Services account number of the owner of the security group specified in the &lt;code&gt;EC2SecurityGroupName&lt;/code&gt; parameter. The Amazon Web Services access key ID is not an acceptable value. If &lt;code&gt;EC2SecurityGroupOwnerId&lt;/code&gt; is specified, &lt;code&gt;EC2SecurityGroupName&lt;/code&gt; must also be provided. and &lt;code&gt;CIDRIP&lt;/code&gt; cannot be provided. &lt;/p&gt; &lt;p&gt;Example: &lt;code&gt;111122223333&lt;/code&gt; &lt;/p&gt; (optional)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> ClusterSecurityGroupNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> AuthorizationNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 482 </td><td> InvalidClusterSecurityGroupStateFault </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call gETRevokeClusterSecurityGroupIngressCall(String clusterSecurityGroupName, String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, String CIDRIP, String ec2SecurityGroupName, String ec2SecurityGroupOwnerId, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/#Action=RevokeClusterSecurityGroupIngress";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (clusterSecurityGroupName != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("ClusterSecurityGroupName", clusterSecurityGroupName));
        }

        if (CIDRIP != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("CIDRIP", CIDRIP));
        }

        if (ec2SecurityGroupName != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("EC2SecurityGroupName", ec2SecurityGroupName));
        }

        if (ec2SecurityGroupOwnerId != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("EC2SecurityGroupOwnerId", ec2SecurityGroupOwnerId));
        }

        if (action != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("Action", action));
        }

        if (version != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("Version", version));
        }

        if (xAmzContentSha256 != null) {
            localVarHeaderParams.put("X-Amz-Content-Sha256", localVarApiClient.parameterToString(xAmzContentSha256));
        }

        if (xAmzDate != null) {
            localVarHeaderParams.put("X-Amz-Date", localVarApiClient.parameterToString(xAmzDate));
        }

        if (xAmzAlgorithm != null) {
            localVarHeaderParams.put("X-Amz-Algorithm", localVarApiClient.parameterToString(xAmzAlgorithm));
        }

        if (xAmzCredential != null) {
            localVarHeaderParams.put("X-Amz-Credential", localVarApiClient.parameterToString(xAmzCredential));
        }

        if (xAmzSecurityToken != null) {
            localVarHeaderParams.put("X-Amz-Security-Token", localVarApiClient.parameterToString(xAmzSecurityToken));
        }

        if (xAmzSignature != null) {
            localVarHeaderParams.put("X-Amz-Signature", localVarApiClient.parameterToString(xAmzSignature));
        }

        if (xAmzSignedHeaders != null) {
            localVarHeaderParams.put("X-Amz-SignedHeaders", localVarApiClient.parameterToString(xAmzSignedHeaders));
        }

        final String[] localVarAccepts = {
            "text/xml"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "hmac" };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call gETRevokeClusterSecurityGroupIngressValidateBeforeCall(String clusterSecurityGroupName, String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, String CIDRIP, String ec2SecurityGroupName, String ec2SecurityGroupOwnerId, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'clusterSecurityGroupName' is set
        if (clusterSecurityGroupName == null) {
            throw new ApiException("Missing the required parameter 'clusterSecurityGroupName' when calling gETRevokeClusterSecurityGroupIngress(Async)");
        }

        // verify the required parameter 'action' is set
        if (action == null) {
            throw new ApiException("Missing the required parameter 'action' when calling gETRevokeClusterSecurityGroupIngress(Async)");
        }

        // verify the required parameter 'version' is set
        if (version == null) {
            throw new ApiException("Missing the required parameter 'version' when calling gETRevokeClusterSecurityGroupIngress(Async)");
        }

        return gETRevokeClusterSecurityGroupIngressCall(clusterSecurityGroupName, action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, CIDRIP, ec2SecurityGroupName, ec2SecurityGroupOwnerId, _callback);

    }

    /**
     * 
     * Revokes an ingress rule in an Amazon Redshift security group for a previously authorized IP range or Amazon EC2 security group. To add an ingress rule, see &lt;a&gt;AuthorizeClusterSecurityGroupIngress&lt;/a&gt;. For information about managing security groups, go to &lt;a href&#x3D;\&quot;https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-security-groups.html\&quot;&gt;Amazon Redshift Cluster Security Groups&lt;/a&gt; in the &lt;i&gt;Amazon Redshift Cluster Management Guide&lt;/i&gt;. 
     * @param clusterSecurityGroupName The name of the security Group from which to revoke the ingress rule. (required)
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param CIDRIP The IP range for which to revoke access. This range must be a valid Classless Inter-Domain Routing (CIDR) block of IP addresses. If &lt;code&gt;CIDRIP&lt;/code&gt; is specified, &lt;code&gt;EC2SecurityGroupName&lt;/code&gt; and &lt;code&gt;EC2SecurityGroupOwnerId&lt;/code&gt; cannot be provided.  (optional)
     * @param ec2SecurityGroupName The name of the EC2 Security Group whose access is to be revoked. If &lt;code&gt;EC2SecurityGroupName&lt;/code&gt; is specified, &lt;code&gt;EC2SecurityGroupOwnerId&lt;/code&gt; must also be provided and &lt;code&gt;CIDRIP&lt;/code&gt; cannot be provided.  (optional)
     * @param ec2SecurityGroupOwnerId &lt;p&gt;The Amazon Web Services account number of the owner of the security group specified in the &lt;code&gt;EC2SecurityGroupName&lt;/code&gt; parameter. The Amazon Web Services access key ID is not an acceptable value. If &lt;code&gt;EC2SecurityGroupOwnerId&lt;/code&gt; is specified, &lt;code&gt;EC2SecurityGroupName&lt;/code&gt; must also be provided. and &lt;code&gt;CIDRIP&lt;/code&gt; cannot be provided. &lt;/p&gt; &lt;p&gt;Example: &lt;code&gt;111122223333&lt;/code&gt; &lt;/p&gt; (optional)
     * @return RevokeClusterSecurityGroupIngressResult
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> ClusterSecurityGroupNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> AuthorizationNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 482 </td><td> InvalidClusterSecurityGroupStateFault </td><td>  -  </td></tr>
     </table>
     */
    public RevokeClusterSecurityGroupIngressResult gETRevokeClusterSecurityGroupIngress(String clusterSecurityGroupName, String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, String CIDRIP, String ec2SecurityGroupName, String ec2SecurityGroupOwnerId) throws ApiException {
        ApiResponse<RevokeClusterSecurityGroupIngressResult> localVarResp = gETRevokeClusterSecurityGroupIngressWithHttpInfo(clusterSecurityGroupName, action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, CIDRIP, ec2SecurityGroupName, ec2SecurityGroupOwnerId);
        return localVarResp.getData();
    }

    /**
     * 
     * Revokes an ingress rule in an Amazon Redshift security group for a previously authorized IP range or Amazon EC2 security group. To add an ingress rule, see &lt;a&gt;AuthorizeClusterSecurityGroupIngress&lt;/a&gt;. For information about managing security groups, go to &lt;a href&#x3D;\&quot;https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-security-groups.html\&quot;&gt;Amazon Redshift Cluster Security Groups&lt;/a&gt; in the &lt;i&gt;Amazon Redshift Cluster Management Guide&lt;/i&gt;. 
     * @param clusterSecurityGroupName The name of the security Group from which to revoke the ingress rule. (required)
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param CIDRIP The IP range for which to revoke access. This range must be a valid Classless Inter-Domain Routing (CIDR) block of IP addresses. If &lt;code&gt;CIDRIP&lt;/code&gt; is specified, &lt;code&gt;EC2SecurityGroupName&lt;/code&gt; and &lt;code&gt;EC2SecurityGroupOwnerId&lt;/code&gt; cannot be provided.  (optional)
     * @param ec2SecurityGroupName The name of the EC2 Security Group whose access is to be revoked. If &lt;code&gt;EC2SecurityGroupName&lt;/code&gt; is specified, &lt;code&gt;EC2SecurityGroupOwnerId&lt;/code&gt; must also be provided and &lt;code&gt;CIDRIP&lt;/code&gt; cannot be provided.  (optional)
     * @param ec2SecurityGroupOwnerId &lt;p&gt;The Amazon Web Services account number of the owner of the security group specified in the &lt;code&gt;EC2SecurityGroupName&lt;/code&gt; parameter. The Amazon Web Services access key ID is not an acceptable value. If &lt;code&gt;EC2SecurityGroupOwnerId&lt;/code&gt; is specified, &lt;code&gt;EC2SecurityGroupName&lt;/code&gt; must also be provided. and &lt;code&gt;CIDRIP&lt;/code&gt; cannot be provided. &lt;/p&gt; &lt;p&gt;Example: &lt;code&gt;111122223333&lt;/code&gt; &lt;/p&gt; (optional)
     * @return ApiResponse&lt;RevokeClusterSecurityGroupIngressResult&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> ClusterSecurityGroupNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> AuthorizationNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 482 </td><td> InvalidClusterSecurityGroupStateFault </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<RevokeClusterSecurityGroupIngressResult> gETRevokeClusterSecurityGroupIngressWithHttpInfo(String clusterSecurityGroupName, String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, String CIDRIP, String ec2SecurityGroupName, String ec2SecurityGroupOwnerId) throws ApiException {
        okhttp3.Call localVarCall = gETRevokeClusterSecurityGroupIngressValidateBeforeCall(clusterSecurityGroupName, action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, CIDRIP, ec2SecurityGroupName, ec2SecurityGroupOwnerId, null);
        Type localVarReturnType = new TypeToken<RevokeClusterSecurityGroupIngressResult>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     *  (asynchronously)
     * Revokes an ingress rule in an Amazon Redshift security group for a previously authorized IP range or Amazon EC2 security group. To add an ingress rule, see &lt;a&gt;AuthorizeClusterSecurityGroupIngress&lt;/a&gt;. For information about managing security groups, go to &lt;a href&#x3D;\&quot;https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-security-groups.html\&quot;&gt;Amazon Redshift Cluster Security Groups&lt;/a&gt; in the &lt;i&gt;Amazon Redshift Cluster Management Guide&lt;/i&gt;. 
     * @param clusterSecurityGroupName The name of the security Group from which to revoke the ingress rule. (required)
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param CIDRIP The IP range for which to revoke access. This range must be a valid Classless Inter-Domain Routing (CIDR) block of IP addresses. If &lt;code&gt;CIDRIP&lt;/code&gt; is specified, &lt;code&gt;EC2SecurityGroupName&lt;/code&gt; and &lt;code&gt;EC2SecurityGroupOwnerId&lt;/code&gt; cannot be provided.  (optional)
     * @param ec2SecurityGroupName The name of the EC2 Security Group whose access is to be revoked. If &lt;code&gt;EC2SecurityGroupName&lt;/code&gt; is specified, &lt;code&gt;EC2SecurityGroupOwnerId&lt;/code&gt; must also be provided and &lt;code&gt;CIDRIP&lt;/code&gt; cannot be provided.  (optional)
     * @param ec2SecurityGroupOwnerId &lt;p&gt;The Amazon Web Services account number of the owner of the security group specified in the &lt;code&gt;EC2SecurityGroupName&lt;/code&gt; parameter. The Amazon Web Services access key ID is not an acceptable value. If &lt;code&gt;EC2SecurityGroupOwnerId&lt;/code&gt; is specified, &lt;code&gt;EC2SecurityGroupName&lt;/code&gt; must also be provided. and &lt;code&gt;CIDRIP&lt;/code&gt; cannot be provided. &lt;/p&gt; &lt;p&gt;Example: &lt;code&gt;111122223333&lt;/code&gt; &lt;/p&gt; (optional)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> ClusterSecurityGroupNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> AuthorizationNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 482 </td><td> InvalidClusterSecurityGroupStateFault </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call gETRevokeClusterSecurityGroupIngressAsync(String clusterSecurityGroupName, String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, String CIDRIP, String ec2SecurityGroupName, String ec2SecurityGroupOwnerId, final ApiCallback<RevokeClusterSecurityGroupIngressResult> _callback) throws ApiException {

        okhttp3.Call localVarCall = gETRevokeClusterSecurityGroupIngressValidateBeforeCall(clusterSecurityGroupName, action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, CIDRIP, ec2SecurityGroupName, ec2SecurityGroupOwnerId, _callback);
        Type localVarReturnType = new TypeToken<RevokeClusterSecurityGroupIngressResult>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for gETRevokeEndpointAccess
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param clusterIdentifier The cluster to revoke access from. (optional)
     * @param account The Amazon Web Services account ID whose access is to be revoked. (optional)
     * @param vpcIds The virtual private cloud (VPC) identifiers for which access is to be revoked. (optional)
     * @param force Indicates whether to force the revoke action. If true, the Redshift-managed VPC endpoints associated with the endpoint authorization are also deleted. (optional)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> ClusterNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> InvalidEndpointStateFault </td><td>  -  </td></tr>
        <tr><td> 482 </td><td> InvalidClusterSecurityGroupStateFault </td><td>  -  </td></tr>
        <tr><td> 483 </td><td> EndpointNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 484 </td><td> EndpointAuthorizationNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 485 </td><td> InvalidAuthorizationStateFault </td><td>  -  </td></tr>
        <tr><td> 486 </td><td> InvalidClusterStateFault </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call gETRevokeEndpointAccessCall(String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, String clusterIdentifier, String account, List<String> vpcIds, Boolean force, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/#Action=RevokeEndpointAccess";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (clusterIdentifier != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("ClusterIdentifier", clusterIdentifier));
        }

        if (account != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("Account", account));
        }

        if (vpcIds != null) {
            localVarCollectionQueryParams.addAll(localVarApiClient.parameterToPairs("multi", "VpcIds", vpcIds));
        }

        if (force != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("Force", force));
        }

        if (action != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("Action", action));
        }

        if (version != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("Version", version));
        }

        if (xAmzContentSha256 != null) {
            localVarHeaderParams.put("X-Amz-Content-Sha256", localVarApiClient.parameterToString(xAmzContentSha256));
        }

        if (xAmzDate != null) {
            localVarHeaderParams.put("X-Amz-Date", localVarApiClient.parameterToString(xAmzDate));
        }

        if (xAmzAlgorithm != null) {
            localVarHeaderParams.put("X-Amz-Algorithm", localVarApiClient.parameterToString(xAmzAlgorithm));
        }

        if (xAmzCredential != null) {
            localVarHeaderParams.put("X-Amz-Credential", localVarApiClient.parameterToString(xAmzCredential));
        }

        if (xAmzSecurityToken != null) {
            localVarHeaderParams.put("X-Amz-Security-Token", localVarApiClient.parameterToString(xAmzSecurityToken));
        }

        if (xAmzSignature != null) {
            localVarHeaderParams.put("X-Amz-Signature", localVarApiClient.parameterToString(xAmzSignature));
        }

        if (xAmzSignedHeaders != null) {
            localVarHeaderParams.put("X-Amz-SignedHeaders", localVarApiClient.parameterToString(xAmzSignedHeaders));
        }

        final String[] localVarAccepts = {
            "text/xml"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "hmac" };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call gETRevokeEndpointAccessValidateBeforeCall(String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, String clusterIdentifier, String account, List<String> vpcIds, Boolean force, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'action' is set
        if (action == null) {
            throw new ApiException("Missing the required parameter 'action' when calling gETRevokeEndpointAccess(Async)");
        }

        // verify the required parameter 'version' is set
        if (version == null) {
            throw new ApiException("Missing the required parameter 'version' when calling gETRevokeEndpointAccess(Async)");
        }

        return gETRevokeEndpointAccessCall(action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, clusterIdentifier, account, vpcIds, force, _callback);

    }

    /**
     * 
     * Revokes access to a cluster.
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param clusterIdentifier The cluster to revoke access from. (optional)
     * @param account The Amazon Web Services account ID whose access is to be revoked. (optional)
     * @param vpcIds The virtual private cloud (VPC) identifiers for which access is to be revoked. (optional)
     * @param force Indicates whether to force the revoke action. If true, the Redshift-managed VPC endpoints associated with the endpoint authorization are also deleted. (optional)
     * @return EndpointAuthorization
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> ClusterNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> InvalidEndpointStateFault </td><td>  -  </td></tr>
        <tr><td> 482 </td><td> InvalidClusterSecurityGroupStateFault </td><td>  -  </td></tr>
        <tr><td> 483 </td><td> EndpointNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 484 </td><td> EndpointAuthorizationNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 485 </td><td> InvalidAuthorizationStateFault </td><td>  -  </td></tr>
        <tr><td> 486 </td><td> InvalidClusterStateFault </td><td>  -  </td></tr>
     </table>
     */
    public EndpointAuthorization gETRevokeEndpointAccess(String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, String clusterIdentifier, String account, List<String> vpcIds, Boolean force) throws ApiException {
        ApiResponse<EndpointAuthorization> localVarResp = gETRevokeEndpointAccessWithHttpInfo(action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, clusterIdentifier, account, vpcIds, force);
        return localVarResp.getData();
    }

    /**
     * 
     * Revokes access to a cluster.
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param clusterIdentifier The cluster to revoke access from. (optional)
     * @param account The Amazon Web Services account ID whose access is to be revoked. (optional)
     * @param vpcIds The virtual private cloud (VPC) identifiers for which access is to be revoked. (optional)
     * @param force Indicates whether to force the revoke action. If true, the Redshift-managed VPC endpoints associated with the endpoint authorization are also deleted. (optional)
     * @return ApiResponse&lt;EndpointAuthorization&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> ClusterNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> InvalidEndpointStateFault </td><td>  -  </td></tr>
        <tr><td> 482 </td><td> InvalidClusterSecurityGroupStateFault </td><td>  -  </td></tr>
        <tr><td> 483 </td><td> EndpointNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 484 </td><td> EndpointAuthorizationNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 485 </td><td> InvalidAuthorizationStateFault </td><td>  -  </td></tr>
        <tr><td> 486 </td><td> InvalidClusterStateFault </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<EndpointAuthorization> gETRevokeEndpointAccessWithHttpInfo(String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, String clusterIdentifier, String account, List<String> vpcIds, Boolean force) throws ApiException {
        okhttp3.Call localVarCall = gETRevokeEndpointAccessValidateBeforeCall(action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, clusterIdentifier, account, vpcIds, force, null);
        Type localVarReturnType = new TypeToken<EndpointAuthorization>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     *  (asynchronously)
     * Revokes access to a cluster.
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param clusterIdentifier The cluster to revoke access from. (optional)
     * @param account The Amazon Web Services account ID whose access is to be revoked. (optional)
     * @param vpcIds The virtual private cloud (VPC) identifiers for which access is to be revoked. (optional)
     * @param force Indicates whether to force the revoke action. If true, the Redshift-managed VPC endpoints associated with the endpoint authorization are also deleted. (optional)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> ClusterNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> InvalidEndpointStateFault </td><td>  -  </td></tr>
        <tr><td> 482 </td><td> InvalidClusterSecurityGroupStateFault </td><td>  -  </td></tr>
        <tr><td> 483 </td><td> EndpointNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 484 </td><td> EndpointAuthorizationNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 485 </td><td> InvalidAuthorizationStateFault </td><td>  -  </td></tr>
        <tr><td> 486 </td><td> InvalidClusterStateFault </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call gETRevokeEndpointAccessAsync(String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, String clusterIdentifier, String account, List<String> vpcIds, Boolean force, final ApiCallback<EndpointAuthorization> _callback) throws ApiException {

        okhttp3.Call localVarCall = gETRevokeEndpointAccessValidateBeforeCall(action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, clusterIdentifier, account, vpcIds, force, _callback);
        Type localVarReturnType = new TypeToken<EndpointAuthorization>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for gETRevokeSnapshotAccess
     * @param accountWithRestoreAccess The identifier of the Amazon Web Services account that can no longer restore the specified snapshot. (required)
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param snapshotIdentifier The identifier of the snapshot that the account can no longer access. (optional)
     * @param snapshotArn The Amazon Resource Name (ARN) of the snapshot associated with the message to revoke access. (optional)
     * @param snapshotClusterIdentifier The identifier of the cluster the snapshot was created from. This parameter is required if your IAM user has a policy containing a snapshot resource element that specifies anything other than * for the cluster name. (optional)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> AccessToSnapshotDeniedFault </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> AuthorizationNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 482 </td><td> ClusterSnapshotNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 483 </td><td> UnsupportedOperationFault </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call gETRevokeSnapshotAccessCall(String accountWithRestoreAccess, String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, String snapshotIdentifier, String snapshotArn, String snapshotClusterIdentifier, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/#Action=RevokeSnapshotAccess";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (snapshotIdentifier != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("SnapshotIdentifier", snapshotIdentifier));
        }

        if (snapshotArn != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("SnapshotArn", snapshotArn));
        }

        if (snapshotClusterIdentifier != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("SnapshotClusterIdentifier", snapshotClusterIdentifier));
        }

        if (accountWithRestoreAccess != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("AccountWithRestoreAccess", accountWithRestoreAccess));
        }

        if (action != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("Action", action));
        }

        if (version != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("Version", version));
        }

        if (xAmzContentSha256 != null) {
            localVarHeaderParams.put("X-Amz-Content-Sha256", localVarApiClient.parameterToString(xAmzContentSha256));
        }

        if (xAmzDate != null) {
            localVarHeaderParams.put("X-Amz-Date", localVarApiClient.parameterToString(xAmzDate));
        }

        if (xAmzAlgorithm != null) {
            localVarHeaderParams.put("X-Amz-Algorithm", localVarApiClient.parameterToString(xAmzAlgorithm));
        }

        if (xAmzCredential != null) {
            localVarHeaderParams.put("X-Amz-Credential", localVarApiClient.parameterToString(xAmzCredential));
        }

        if (xAmzSecurityToken != null) {
            localVarHeaderParams.put("X-Amz-Security-Token", localVarApiClient.parameterToString(xAmzSecurityToken));
        }

        if (xAmzSignature != null) {
            localVarHeaderParams.put("X-Amz-Signature", localVarApiClient.parameterToString(xAmzSignature));
        }

        if (xAmzSignedHeaders != null) {
            localVarHeaderParams.put("X-Amz-SignedHeaders", localVarApiClient.parameterToString(xAmzSignedHeaders));
        }

        final String[] localVarAccepts = {
            "text/xml"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "hmac" };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call gETRevokeSnapshotAccessValidateBeforeCall(String accountWithRestoreAccess, String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, String snapshotIdentifier, String snapshotArn, String snapshotClusterIdentifier, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'accountWithRestoreAccess' is set
        if (accountWithRestoreAccess == null) {
            throw new ApiException("Missing the required parameter 'accountWithRestoreAccess' when calling gETRevokeSnapshotAccess(Async)");
        }

        // verify the required parameter 'action' is set
        if (action == null) {
            throw new ApiException("Missing the required parameter 'action' when calling gETRevokeSnapshotAccess(Async)");
        }

        // verify the required parameter 'version' is set
        if (version == null) {
            throw new ApiException("Missing the required parameter 'version' when calling gETRevokeSnapshotAccess(Async)");
        }

        return gETRevokeSnapshotAccessCall(accountWithRestoreAccess, action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, snapshotIdentifier, snapshotArn, snapshotClusterIdentifier, _callback);

    }

    /**
     * 
     * &lt;p&gt;Removes the ability of the specified Amazon Web Services account to restore the specified snapshot. If the account is currently restoring the snapshot, the restore will run to completion.&lt;/p&gt; &lt;p&gt; For more information about working with snapshots, go to &lt;a href&#x3D;\&quot;https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-snapshots.html\&quot;&gt;Amazon Redshift Snapshots&lt;/a&gt; in the &lt;i&gt;Amazon Redshift Cluster Management Guide&lt;/i&gt;.&lt;/p&gt;
     * @param accountWithRestoreAccess The identifier of the Amazon Web Services account that can no longer restore the specified snapshot. (required)
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param snapshotIdentifier The identifier of the snapshot that the account can no longer access. (optional)
     * @param snapshotArn The Amazon Resource Name (ARN) of the snapshot associated with the message to revoke access. (optional)
     * @param snapshotClusterIdentifier The identifier of the cluster the snapshot was created from. This parameter is required if your IAM user has a policy containing a snapshot resource element that specifies anything other than * for the cluster name. (optional)
     * @return RevokeSnapshotAccessResult
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> AccessToSnapshotDeniedFault </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> AuthorizationNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 482 </td><td> ClusterSnapshotNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 483 </td><td> UnsupportedOperationFault </td><td>  -  </td></tr>
     </table>
     */
    public RevokeSnapshotAccessResult gETRevokeSnapshotAccess(String accountWithRestoreAccess, String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, String snapshotIdentifier, String snapshotArn, String snapshotClusterIdentifier) throws ApiException {
        ApiResponse<RevokeSnapshotAccessResult> localVarResp = gETRevokeSnapshotAccessWithHttpInfo(accountWithRestoreAccess, action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, snapshotIdentifier, snapshotArn, snapshotClusterIdentifier);
        return localVarResp.getData();
    }

    /**
     * 
     * &lt;p&gt;Removes the ability of the specified Amazon Web Services account to restore the specified snapshot. If the account is currently restoring the snapshot, the restore will run to completion.&lt;/p&gt; &lt;p&gt; For more information about working with snapshots, go to &lt;a href&#x3D;\&quot;https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-snapshots.html\&quot;&gt;Amazon Redshift Snapshots&lt;/a&gt; in the &lt;i&gt;Amazon Redshift Cluster Management Guide&lt;/i&gt;.&lt;/p&gt;
     * @param accountWithRestoreAccess The identifier of the Amazon Web Services account that can no longer restore the specified snapshot. (required)
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param snapshotIdentifier The identifier of the snapshot that the account can no longer access. (optional)
     * @param snapshotArn The Amazon Resource Name (ARN) of the snapshot associated with the message to revoke access. (optional)
     * @param snapshotClusterIdentifier The identifier of the cluster the snapshot was created from. This parameter is required if your IAM user has a policy containing a snapshot resource element that specifies anything other than * for the cluster name. (optional)
     * @return ApiResponse&lt;RevokeSnapshotAccessResult&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> AccessToSnapshotDeniedFault </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> AuthorizationNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 482 </td><td> ClusterSnapshotNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 483 </td><td> UnsupportedOperationFault </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<RevokeSnapshotAccessResult> gETRevokeSnapshotAccessWithHttpInfo(String accountWithRestoreAccess, String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, String snapshotIdentifier, String snapshotArn, String snapshotClusterIdentifier) throws ApiException {
        okhttp3.Call localVarCall = gETRevokeSnapshotAccessValidateBeforeCall(accountWithRestoreAccess, action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, snapshotIdentifier, snapshotArn, snapshotClusterIdentifier, null);
        Type localVarReturnType = new TypeToken<RevokeSnapshotAccessResult>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     *  (asynchronously)
     * &lt;p&gt;Removes the ability of the specified Amazon Web Services account to restore the specified snapshot. If the account is currently restoring the snapshot, the restore will run to completion.&lt;/p&gt; &lt;p&gt; For more information about working with snapshots, go to &lt;a href&#x3D;\&quot;https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-snapshots.html\&quot;&gt;Amazon Redshift Snapshots&lt;/a&gt; in the &lt;i&gt;Amazon Redshift Cluster Management Guide&lt;/i&gt;.&lt;/p&gt;
     * @param accountWithRestoreAccess The identifier of the Amazon Web Services account that can no longer restore the specified snapshot. (required)
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param snapshotIdentifier The identifier of the snapshot that the account can no longer access. (optional)
     * @param snapshotArn The Amazon Resource Name (ARN) of the snapshot associated with the message to revoke access. (optional)
     * @param snapshotClusterIdentifier The identifier of the cluster the snapshot was created from. This parameter is required if your IAM user has a policy containing a snapshot resource element that specifies anything other than * for the cluster name. (optional)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> AccessToSnapshotDeniedFault </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> AuthorizationNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 482 </td><td> ClusterSnapshotNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 483 </td><td> UnsupportedOperationFault </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call gETRevokeSnapshotAccessAsync(String accountWithRestoreAccess, String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, String snapshotIdentifier, String snapshotArn, String snapshotClusterIdentifier, final ApiCallback<RevokeSnapshotAccessResult> _callback) throws ApiException {

        okhttp3.Call localVarCall = gETRevokeSnapshotAccessValidateBeforeCall(accountWithRestoreAccess, action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, snapshotIdentifier, snapshotArn, snapshotClusterIdentifier, _callback);
        Type localVarReturnType = new TypeToken<RevokeSnapshotAccessResult>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for gETRotateEncryptionKey
     * @param clusterIdentifier &lt;p&gt;The unique identifier of the cluster that you want to rotate the encryption keys for.&lt;/p&gt; &lt;p&gt;Constraints: Must be the name of valid cluster that has encryption enabled.&lt;/p&gt; (required)
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> ClusterNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> InvalidClusterStateFault </td><td>  -  </td></tr>
        <tr><td> 482 </td><td> DependentServiceRequestThrottlingFault </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call gETRotateEncryptionKeyCall(String clusterIdentifier, String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/#Action=RotateEncryptionKey";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (clusterIdentifier != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("ClusterIdentifier", clusterIdentifier));
        }

        if (action != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("Action", action));
        }

        if (version != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("Version", version));
        }

        if (xAmzContentSha256 != null) {
            localVarHeaderParams.put("X-Amz-Content-Sha256", localVarApiClient.parameterToString(xAmzContentSha256));
        }

        if (xAmzDate != null) {
            localVarHeaderParams.put("X-Amz-Date", localVarApiClient.parameterToString(xAmzDate));
        }

        if (xAmzAlgorithm != null) {
            localVarHeaderParams.put("X-Amz-Algorithm", localVarApiClient.parameterToString(xAmzAlgorithm));
        }

        if (xAmzCredential != null) {
            localVarHeaderParams.put("X-Amz-Credential", localVarApiClient.parameterToString(xAmzCredential));
        }

        if (xAmzSecurityToken != null) {
            localVarHeaderParams.put("X-Amz-Security-Token", localVarApiClient.parameterToString(xAmzSecurityToken));
        }

        if (xAmzSignature != null) {
            localVarHeaderParams.put("X-Amz-Signature", localVarApiClient.parameterToString(xAmzSignature));
        }

        if (xAmzSignedHeaders != null) {
            localVarHeaderParams.put("X-Amz-SignedHeaders", localVarApiClient.parameterToString(xAmzSignedHeaders));
        }

        final String[] localVarAccepts = {
            "text/xml"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "hmac" };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call gETRotateEncryptionKeyValidateBeforeCall(String clusterIdentifier, String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'clusterIdentifier' is set
        if (clusterIdentifier == null) {
            throw new ApiException("Missing the required parameter 'clusterIdentifier' when calling gETRotateEncryptionKey(Async)");
        }

        // verify the required parameter 'action' is set
        if (action == null) {
            throw new ApiException("Missing the required parameter 'action' when calling gETRotateEncryptionKey(Async)");
        }

        // verify the required parameter 'version' is set
        if (version == null) {
            throw new ApiException("Missing the required parameter 'version' when calling gETRotateEncryptionKey(Async)");
        }

        return gETRotateEncryptionKeyCall(clusterIdentifier, action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, _callback);

    }

    /**
     * 
     * Rotates the encryption keys for a cluster.
     * @param clusterIdentifier &lt;p&gt;The unique identifier of the cluster that you want to rotate the encryption keys for.&lt;/p&gt; &lt;p&gt;Constraints: Must be the name of valid cluster that has encryption enabled.&lt;/p&gt; (required)
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @return RotateEncryptionKeyResult
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> ClusterNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> InvalidClusterStateFault </td><td>  -  </td></tr>
        <tr><td> 482 </td><td> DependentServiceRequestThrottlingFault </td><td>  -  </td></tr>
     </table>
     */
    public RotateEncryptionKeyResult gETRotateEncryptionKey(String clusterIdentifier, String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders) throws ApiException {
        ApiResponse<RotateEncryptionKeyResult> localVarResp = gETRotateEncryptionKeyWithHttpInfo(clusterIdentifier, action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders);
        return localVarResp.getData();
    }

    /**
     * 
     * Rotates the encryption keys for a cluster.
     * @param clusterIdentifier &lt;p&gt;The unique identifier of the cluster that you want to rotate the encryption keys for.&lt;/p&gt; &lt;p&gt;Constraints: Must be the name of valid cluster that has encryption enabled.&lt;/p&gt; (required)
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @return ApiResponse&lt;RotateEncryptionKeyResult&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> ClusterNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> InvalidClusterStateFault </td><td>  -  </td></tr>
        <tr><td> 482 </td><td> DependentServiceRequestThrottlingFault </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<RotateEncryptionKeyResult> gETRotateEncryptionKeyWithHttpInfo(String clusterIdentifier, String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders) throws ApiException {
        okhttp3.Call localVarCall = gETRotateEncryptionKeyValidateBeforeCall(clusterIdentifier, action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, null);
        Type localVarReturnType = new TypeToken<RotateEncryptionKeyResult>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     *  (asynchronously)
     * Rotates the encryption keys for a cluster.
     * @param clusterIdentifier &lt;p&gt;The unique identifier of the cluster that you want to rotate the encryption keys for.&lt;/p&gt; &lt;p&gt;Constraints: Must be the name of valid cluster that has encryption enabled.&lt;/p&gt; (required)
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> ClusterNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> InvalidClusterStateFault </td><td>  -  </td></tr>
        <tr><td> 482 </td><td> DependentServiceRequestThrottlingFault </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call gETRotateEncryptionKeyAsync(String clusterIdentifier, String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, final ApiCallback<RotateEncryptionKeyResult> _callback) throws ApiException {

        okhttp3.Call localVarCall = gETRotateEncryptionKeyValidateBeforeCall(clusterIdentifier, action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, _callback);
        Type localVarReturnType = new TypeToken<RotateEncryptionKeyResult>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for gETUpdatePartnerStatus
     * @param accountId The Amazon Web Services account ID that owns the cluster. (required)
     * @param clusterIdentifier The cluster identifier of the cluster whose partner integration status is being updated. (required)
     * @param databaseName The name of the database whose partner integration status is being updated. (required)
     * @param partnerName The name of the partner whose integration status is being updated. (required)
     * @param status The value of the updated status. (required)
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param statusMessage The status message provided by the partner. (optional)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> PartnerNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> ClusterNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 482 </td><td> UnauthorizedPartnerIntegrationFault </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call gETUpdatePartnerStatusCall(String accountId, String clusterIdentifier, String databaseName, String partnerName, String status, String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, String statusMessage, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/#Action=UpdatePartnerStatus";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (accountId != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("AccountId", accountId));
        }

        if (clusterIdentifier != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("ClusterIdentifier", clusterIdentifier));
        }

        if (databaseName != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("DatabaseName", databaseName));
        }

        if (partnerName != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("PartnerName", partnerName));
        }

        if (status != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("Status", status));
        }

        if (statusMessage != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("StatusMessage", statusMessage));
        }

        if (action != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("Action", action));
        }

        if (version != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("Version", version));
        }

        if (xAmzContentSha256 != null) {
            localVarHeaderParams.put("X-Amz-Content-Sha256", localVarApiClient.parameterToString(xAmzContentSha256));
        }

        if (xAmzDate != null) {
            localVarHeaderParams.put("X-Amz-Date", localVarApiClient.parameterToString(xAmzDate));
        }

        if (xAmzAlgorithm != null) {
            localVarHeaderParams.put("X-Amz-Algorithm", localVarApiClient.parameterToString(xAmzAlgorithm));
        }

        if (xAmzCredential != null) {
            localVarHeaderParams.put("X-Amz-Credential", localVarApiClient.parameterToString(xAmzCredential));
        }

        if (xAmzSecurityToken != null) {
            localVarHeaderParams.put("X-Amz-Security-Token", localVarApiClient.parameterToString(xAmzSecurityToken));
        }

        if (xAmzSignature != null) {
            localVarHeaderParams.put("X-Amz-Signature", localVarApiClient.parameterToString(xAmzSignature));
        }

        if (xAmzSignedHeaders != null) {
            localVarHeaderParams.put("X-Amz-SignedHeaders", localVarApiClient.parameterToString(xAmzSignedHeaders));
        }

        final String[] localVarAccepts = {
            "text/xml"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "hmac" };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call gETUpdatePartnerStatusValidateBeforeCall(String accountId, String clusterIdentifier, String databaseName, String partnerName, String status, String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, String statusMessage, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'accountId' is set
        if (accountId == null) {
            throw new ApiException("Missing the required parameter 'accountId' when calling gETUpdatePartnerStatus(Async)");
        }

        // verify the required parameter 'clusterIdentifier' is set
        if (clusterIdentifier == null) {
            throw new ApiException("Missing the required parameter 'clusterIdentifier' when calling gETUpdatePartnerStatus(Async)");
        }

        // verify the required parameter 'databaseName' is set
        if (databaseName == null) {
            throw new ApiException("Missing the required parameter 'databaseName' when calling gETUpdatePartnerStatus(Async)");
        }

        // verify the required parameter 'partnerName' is set
        if (partnerName == null) {
            throw new ApiException("Missing the required parameter 'partnerName' when calling gETUpdatePartnerStatus(Async)");
        }

        // verify the required parameter 'status' is set
        if (status == null) {
            throw new ApiException("Missing the required parameter 'status' when calling gETUpdatePartnerStatus(Async)");
        }

        // verify the required parameter 'action' is set
        if (action == null) {
            throw new ApiException("Missing the required parameter 'action' when calling gETUpdatePartnerStatus(Async)");
        }

        // verify the required parameter 'version' is set
        if (version == null) {
            throw new ApiException("Missing the required parameter 'version' when calling gETUpdatePartnerStatus(Async)");
        }

        return gETUpdatePartnerStatusCall(accountId, clusterIdentifier, databaseName, partnerName, status, action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, statusMessage, _callback);

    }

    /**
     * 
     * Updates the status of a partner integration.
     * @param accountId The Amazon Web Services account ID that owns the cluster. (required)
     * @param clusterIdentifier The cluster identifier of the cluster whose partner integration status is being updated. (required)
     * @param databaseName The name of the database whose partner integration status is being updated. (required)
     * @param partnerName The name of the partner whose integration status is being updated. (required)
     * @param status The value of the updated status. (required)
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param statusMessage The status message provided by the partner. (optional)
     * @return PartnerIntegrationOutputMessage
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> PartnerNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> ClusterNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 482 </td><td> UnauthorizedPartnerIntegrationFault </td><td>  -  </td></tr>
     </table>
     */
    public PartnerIntegrationOutputMessage gETUpdatePartnerStatus(String accountId, String clusterIdentifier, String databaseName, String partnerName, String status, String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, String statusMessage) throws ApiException {
        ApiResponse<PartnerIntegrationOutputMessage> localVarResp = gETUpdatePartnerStatusWithHttpInfo(accountId, clusterIdentifier, databaseName, partnerName, status, action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, statusMessage);
        return localVarResp.getData();
    }

    /**
     * 
     * Updates the status of a partner integration.
     * @param accountId The Amazon Web Services account ID that owns the cluster. (required)
     * @param clusterIdentifier The cluster identifier of the cluster whose partner integration status is being updated. (required)
     * @param databaseName The name of the database whose partner integration status is being updated. (required)
     * @param partnerName The name of the partner whose integration status is being updated. (required)
     * @param status The value of the updated status. (required)
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param statusMessage The status message provided by the partner. (optional)
     * @return ApiResponse&lt;PartnerIntegrationOutputMessage&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> PartnerNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> ClusterNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 482 </td><td> UnauthorizedPartnerIntegrationFault </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<PartnerIntegrationOutputMessage> gETUpdatePartnerStatusWithHttpInfo(String accountId, String clusterIdentifier, String databaseName, String partnerName, String status, String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, String statusMessage) throws ApiException {
        okhttp3.Call localVarCall = gETUpdatePartnerStatusValidateBeforeCall(accountId, clusterIdentifier, databaseName, partnerName, status, action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, statusMessage, null);
        Type localVarReturnType = new TypeToken<PartnerIntegrationOutputMessage>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     *  (asynchronously)
     * Updates the status of a partner integration.
     * @param accountId The Amazon Web Services account ID that owns the cluster. (required)
     * @param clusterIdentifier The cluster identifier of the cluster whose partner integration status is being updated. (required)
     * @param databaseName The name of the database whose partner integration status is being updated. (required)
     * @param partnerName The name of the partner whose integration status is being updated. (required)
     * @param status The value of the updated status. (required)
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param statusMessage The status message provided by the partner. (optional)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> PartnerNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> ClusterNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 482 </td><td> UnauthorizedPartnerIntegrationFault </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call gETUpdatePartnerStatusAsync(String accountId, String clusterIdentifier, String databaseName, String partnerName, String status, String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, String statusMessage, final ApiCallback<PartnerIntegrationOutputMessage> _callback) throws ApiException {

        okhttp3.Call localVarCall = gETUpdatePartnerStatusValidateBeforeCall(accountId, clusterIdentifier, databaseName, partnerName, status, action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, statusMessage, _callback);
        Type localVarReturnType = new TypeToken<PartnerIntegrationOutputMessage>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for pOSTAcceptReservedNodeExchange
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param acceptReservedNodeExchangeInputMessage  (optional)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> ReservedNodeNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> InvalidReservedNodeStateFault </td><td>  -  </td></tr>
        <tr><td> 482 </td><td> ReservedNodeAlreadyMigratedFault </td><td>  -  </td></tr>
        <tr><td> 483 </td><td> ReservedNodeOfferingNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 484 </td><td> UnsupportedOperationFault </td><td>  -  </td></tr>
        <tr><td> 485 </td><td> DependentServiceUnavailableFault </td><td>  -  </td></tr>
        <tr><td> 486 </td><td> ReservedNodeAlreadyExistsFault </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call pOSTAcceptReservedNodeExchangeCall(String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, AcceptReservedNodeExchangeInputMessage acceptReservedNodeExchangeInputMessage, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = acceptReservedNodeExchangeInputMessage;

        // create path and map variables
        String localVarPath = "/#Action=AcceptReservedNodeExchange";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (action != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("Action", action));
        }

        if (version != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("Version", version));
        }

        if (xAmzContentSha256 != null) {
            localVarHeaderParams.put("X-Amz-Content-Sha256", localVarApiClient.parameterToString(xAmzContentSha256));
        }

        if (xAmzDate != null) {
            localVarHeaderParams.put("X-Amz-Date", localVarApiClient.parameterToString(xAmzDate));
        }

        if (xAmzAlgorithm != null) {
            localVarHeaderParams.put("X-Amz-Algorithm", localVarApiClient.parameterToString(xAmzAlgorithm));
        }

        if (xAmzCredential != null) {
            localVarHeaderParams.put("X-Amz-Credential", localVarApiClient.parameterToString(xAmzCredential));
        }

        if (xAmzSecurityToken != null) {
            localVarHeaderParams.put("X-Amz-Security-Token", localVarApiClient.parameterToString(xAmzSecurityToken));
        }

        if (xAmzSignature != null) {
            localVarHeaderParams.put("X-Amz-Signature", localVarApiClient.parameterToString(xAmzSignature));
        }

        if (xAmzSignedHeaders != null) {
            localVarHeaderParams.put("X-Amz-SignedHeaders", localVarApiClient.parameterToString(xAmzSignedHeaders));
        }

        final String[] localVarAccepts = {
            "text/xml"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            "text/xml"
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "hmac" };
        return localVarApiClient.buildCall(basePath, localVarPath, "POST", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call pOSTAcceptReservedNodeExchangeValidateBeforeCall(String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, AcceptReservedNodeExchangeInputMessage acceptReservedNodeExchangeInputMessage, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'action' is set
        if (action == null) {
            throw new ApiException("Missing the required parameter 'action' when calling pOSTAcceptReservedNodeExchange(Async)");
        }

        // verify the required parameter 'version' is set
        if (version == null) {
            throw new ApiException("Missing the required parameter 'version' when calling pOSTAcceptReservedNodeExchange(Async)");
        }

        return pOSTAcceptReservedNodeExchangeCall(action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, acceptReservedNodeExchangeInputMessage, _callback);

    }

    /**
     * 
     * Exchanges a DC1 Reserved Node for a DC2 Reserved Node with no changes to the configuration (term, payment type, or number of nodes) and no additional costs. 
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param acceptReservedNodeExchangeInputMessage  (optional)
     * @return AcceptReservedNodeExchangeOutputMessage
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> ReservedNodeNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> InvalidReservedNodeStateFault </td><td>  -  </td></tr>
        <tr><td> 482 </td><td> ReservedNodeAlreadyMigratedFault </td><td>  -  </td></tr>
        <tr><td> 483 </td><td> ReservedNodeOfferingNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 484 </td><td> UnsupportedOperationFault </td><td>  -  </td></tr>
        <tr><td> 485 </td><td> DependentServiceUnavailableFault </td><td>  -  </td></tr>
        <tr><td> 486 </td><td> ReservedNodeAlreadyExistsFault </td><td>  -  </td></tr>
     </table>
     */
    public AcceptReservedNodeExchangeOutputMessage pOSTAcceptReservedNodeExchange(String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, AcceptReservedNodeExchangeInputMessage acceptReservedNodeExchangeInputMessage) throws ApiException {
        ApiResponse<AcceptReservedNodeExchangeOutputMessage> localVarResp = pOSTAcceptReservedNodeExchangeWithHttpInfo(action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, acceptReservedNodeExchangeInputMessage);
        return localVarResp.getData();
    }

    /**
     * 
     * Exchanges a DC1 Reserved Node for a DC2 Reserved Node with no changes to the configuration (term, payment type, or number of nodes) and no additional costs. 
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param acceptReservedNodeExchangeInputMessage  (optional)
     * @return ApiResponse&lt;AcceptReservedNodeExchangeOutputMessage&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> ReservedNodeNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> InvalidReservedNodeStateFault </td><td>  -  </td></tr>
        <tr><td> 482 </td><td> ReservedNodeAlreadyMigratedFault </td><td>  -  </td></tr>
        <tr><td> 483 </td><td> ReservedNodeOfferingNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 484 </td><td> UnsupportedOperationFault </td><td>  -  </td></tr>
        <tr><td> 485 </td><td> DependentServiceUnavailableFault </td><td>  -  </td></tr>
        <tr><td> 486 </td><td> ReservedNodeAlreadyExistsFault </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<AcceptReservedNodeExchangeOutputMessage> pOSTAcceptReservedNodeExchangeWithHttpInfo(String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, AcceptReservedNodeExchangeInputMessage acceptReservedNodeExchangeInputMessage) throws ApiException {
        okhttp3.Call localVarCall = pOSTAcceptReservedNodeExchangeValidateBeforeCall(action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, acceptReservedNodeExchangeInputMessage, null);
        Type localVarReturnType = new TypeToken<AcceptReservedNodeExchangeOutputMessage>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     *  (asynchronously)
     * Exchanges a DC1 Reserved Node for a DC2 Reserved Node with no changes to the configuration (term, payment type, or number of nodes) and no additional costs. 
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param acceptReservedNodeExchangeInputMessage  (optional)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> ReservedNodeNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> InvalidReservedNodeStateFault </td><td>  -  </td></tr>
        <tr><td> 482 </td><td> ReservedNodeAlreadyMigratedFault </td><td>  -  </td></tr>
        <tr><td> 483 </td><td> ReservedNodeOfferingNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 484 </td><td> UnsupportedOperationFault </td><td>  -  </td></tr>
        <tr><td> 485 </td><td> DependentServiceUnavailableFault </td><td>  -  </td></tr>
        <tr><td> 486 </td><td> ReservedNodeAlreadyExistsFault </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call pOSTAcceptReservedNodeExchangeAsync(String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, AcceptReservedNodeExchangeInputMessage acceptReservedNodeExchangeInputMessage, final ApiCallback<AcceptReservedNodeExchangeOutputMessage> _callback) throws ApiException {

        okhttp3.Call localVarCall = pOSTAcceptReservedNodeExchangeValidateBeforeCall(action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, acceptReservedNodeExchangeInputMessage, _callback);
        Type localVarReturnType = new TypeToken<AcceptReservedNodeExchangeOutputMessage>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for pOSTAddPartner
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param partnerIntegrationInputMessage  (optional)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> PartnerNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> ClusterNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 482 </td><td> UnauthorizedPartnerIntegrationFault </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call pOSTAddPartnerCall(String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, PartnerIntegrationInputMessage partnerIntegrationInputMessage, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = partnerIntegrationInputMessage;

        // create path and map variables
        String localVarPath = "/#Action=AddPartner";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (action != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("Action", action));
        }

        if (version != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("Version", version));
        }

        if (xAmzContentSha256 != null) {
            localVarHeaderParams.put("X-Amz-Content-Sha256", localVarApiClient.parameterToString(xAmzContentSha256));
        }

        if (xAmzDate != null) {
            localVarHeaderParams.put("X-Amz-Date", localVarApiClient.parameterToString(xAmzDate));
        }

        if (xAmzAlgorithm != null) {
            localVarHeaderParams.put("X-Amz-Algorithm", localVarApiClient.parameterToString(xAmzAlgorithm));
        }

        if (xAmzCredential != null) {
            localVarHeaderParams.put("X-Amz-Credential", localVarApiClient.parameterToString(xAmzCredential));
        }

        if (xAmzSecurityToken != null) {
            localVarHeaderParams.put("X-Amz-Security-Token", localVarApiClient.parameterToString(xAmzSecurityToken));
        }

        if (xAmzSignature != null) {
            localVarHeaderParams.put("X-Amz-Signature", localVarApiClient.parameterToString(xAmzSignature));
        }

        if (xAmzSignedHeaders != null) {
            localVarHeaderParams.put("X-Amz-SignedHeaders", localVarApiClient.parameterToString(xAmzSignedHeaders));
        }

        final String[] localVarAccepts = {
            "text/xml"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            "text/xml"
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "hmac" };
        return localVarApiClient.buildCall(basePath, localVarPath, "POST", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call pOSTAddPartnerValidateBeforeCall(String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, PartnerIntegrationInputMessage partnerIntegrationInputMessage, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'action' is set
        if (action == null) {
            throw new ApiException("Missing the required parameter 'action' when calling pOSTAddPartner(Async)");
        }

        // verify the required parameter 'version' is set
        if (version == null) {
            throw new ApiException("Missing the required parameter 'version' when calling pOSTAddPartner(Async)");
        }

        return pOSTAddPartnerCall(action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, partnerIntegrationInputMessage, _callback);

    }

    /**
     * 
     * Adds a partner integration to a cluster. This operation authorizes a partner to push status updates for the specified database. To complete the integration, you also set up the integration on the partner website.
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param partnerIntegrationInputMessage  (optional)
     * @return PartnerIntegrationOutputMessage
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> PartnerNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> ClusterNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 482 </td><td> UnauthorizedPartnerIntegrationFault </td><td>  -  </td></tr>
     </table>
     */
    public PartnerIntegrationOutputMessage pOSTAddPartner(String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, PartnerIntegrationInputMessage partnerIntegrationInputMessage) throws ApiException {
        ApiResponse<PartnerIntegrationOutputMessage> localVarResp = pOSTAddPartnerWithHttpInfo(action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, partnerIntegrationInputMessage);
        return localVarResp.getData();
    }

    /**
     * 
     * Adds a partner integration to a cluster. This operation authorizes a partner to push status updates for the specified database. To complete the integration, you also set up the integration on the partner website.
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param partnerIntegrationInputMessage  (optional)
     * @return ApiResponse&lt;PartnerIntegrationOutputMessage&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> PartnerNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> ClusterNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 482 </td><td> UnauthorizedPartnerIntegrationFault </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<PartnerIntegrationOutputMessage> pOSTAddPartnerWithHttpInfo(String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, PartnerIntegrationInputMessage partnerIntegrationInputMessage) throws ApiException {
        okhttp3.Call localVarCall = pOSTAddPartnerValidateBeforeCall(action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, partnerIntegrationInputMessage, null);
        Type localVarReturnType = new TypeToken<PartnerIntegrationOutputMessage>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     *  (asynchronously)
     * Adds a partner integration to a cluster. This operation authorizes a partner to push status updates for the specified database. To complete the integration, you also set up the integration on the partner website.
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param partnerIntegrationInputMessage  (optional)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> PartnerNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> ClusterNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 482 </td><td> UnauthorizedPartnerIntegrationFault </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call pOSTAddPartnerAsync(String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, PartnerIntegrationInputMessage partnerIntegrationInputMessage, final ApiCallback<PartnerIntegrationOutputMessage> _callback) throws ApiException {

        okhttp3.Call localVarCall = pOSTAddPartnerValidateBeforeCall(action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, partnerIntegrationInputMessage, _callback);
        Type localVarReturnType = new TypeToken<PartnerIntegrationOutputMessage>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for pOSTAssociateDataShareConsumer
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param associateDataShareConsumerMessage  (optional)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> InvalidDataShareFault </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> InvalidNamespaceFault </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call pOSTAssociateDataShareConsumerCall(String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, AssociateDataShareConsumerMessage associateDataShareConsumerMessage, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = associateDataShareConsumerMessage;

        // create path and map variables
        String localVarPath = "/#Action=AssociateDataShareConsumer";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (action != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("Action", action));
        }

        if (version != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("Version", version));
        }

        if (xAmzContentSha256 != null) {
            localVarHeaderParams.put("X-Amz-Content-Sha256", localVarApiClient.parameterToString(xAmzContentSha256));
        }

        if (xAmzDate != null) {
            localVarHeaderParams.put("X-Amz-Date", localVarApiClient.parameterToString(xAmzDate));
        }

        if (xAmzAlgorithm != null) {
            localVarHeaderParams.put("X-Amz-Algorithm", localVarApiClient.parameterToString(xAmzAlgorithm));
        }

        if (xAmzCredential != null) {
            localVarHeaderParams.put("X-Amz-Credential", localVarApiClient.parameterToString(xAmzCredential));
        }

        if (xAmzSecurityToken != null) {
            localVarHeaderParams.put("X-Amz-Security-Token", localVarApiClient.parameterToString(xAmzSecurityToken));
        }

        if (xAmzSignature != null) {
            localVarHeaderParams.put("X-Amz-Signature", localVarApiClient.parameterToString(xAmzSignature));
        }

        if (xAmzSignedHeaders != null) {
            localVarHeaderParams.put("X-Amz-SignedHeaders", localVarApiClient.parameterToString(xAmzSignedHeaders));
        }

        final String[] localVarAccepts = {
            "text/xml"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            "text/xml"
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "hmac" };
        return localVarApiClient.buildCall(basePath, localVarPath, "POST", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call pOSTAssociateDataShareConsumerValidateBeforeCall(String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, AssociateDataShareConsumerMessage associateDataShareConsumerMessage, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'action' is set
        if (action == null) {
            throw new ApiException("Missing the required parameter 'action' when calling pOSTAssociateDataShareConsumer(Async)");
        }

        // verify the required parameter 'version' is set
        if (version == null) {
            throw new ApiException("Missing the required parameter 'version' when calling pOSTAssociateDataShareConsumer(Async)");
        }

        return pOSTAssociateDataShareConsumerCall(action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, associateDataShareConsumerMessage, _callback);

    }

    /**
     * 
     * From a datashare consumer account, associates a datashare with the account (AssociateEntireAccount) or the specified namespace (ConsumerArn). If you make this association, the consumer can consume the datashare.
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param associateDataShareConsumerMessage  (optional)
     * @return DataShare
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> InvalidDataShareFault </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> InvalidNamespaceFault </td><td>  -  </td></tr>
     </table>
     */
    public DataShare pOSTAssociateDataShareConsumer(String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, AssociateDataShareConsumerMessage associateDataShareConsumerMessage) throws ApiException {
        ApiResponse<DataShare> localVarResp = pOSTAssociateDataShareConsumerWithHttpInfo(action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, associateDataShareConsumerMessage);
        return localVarResp.getData();
    }

    /**
     * 
     * From a datashare consumer account, associates a datashare with the account (AssociateEntireAccount) or the specified namespace (ConsumerArn). If you make this association, the consumer can consume the datashare.
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param associateDataShareConsumerMessage  (optional)
     * @return ApiResponse&lt;DataShare&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> InvalidDataShareFault </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> InvalidNamespaceFault </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<DataShare> pOSTAssociateDataShareConsumerWithHttpInfo(String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, AssociateDataShareConsumerMessage associateDataShareConsumerMessage) throws ApiException {
        okhttp3.Call localVarCall = pOSTAssociateDataShareConsumerValidateBeforeCall(action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, associateDataShareConsumerMessage, null);
        Type localVarReturnType = new TypeToken<DataShare>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     *  (asynchronously)
     * From a datashare consumer account, associates a datashare with the account (AssociateEntireAccount) or the specified namespace (ConsumerArn). If you make this association, the consumer can consume the datashare.
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param associateDataShareConsumerMessage  (optional)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> InvalidDataShareFault </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> InvalidNamespaceFault </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call pOSTAssociateDataShareConsumerAsync(String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, AssociateDataShareConsumerMessage associateDataShareConsumerMessage, final ApiCallback<DataShare> _callback) throws ApiException {

        okhttp3.Call localVarCall = pOSTAssociateDataShareConsumerValidateBeforeCall(action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, associateDataShareConsumerMessage, _callback);
        Type localVarReturnType = new TypeToken<DataShare>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for pOSTAuthorizeClusterSecurityGroupIngress
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param authorizeClusterSecurityGroupIngressMessage  (optional)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> ClusterSecurityGroupNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> InvalidClusterSecurityGroupStateFault </td><td>  -  </td></tr>
        <tr><td> 482 </td><td> AuthorizationAlreadyExistsFault </td><td>  -  </td></tr>
        <tr><td> 483 </td><td> AuthorizationQuotaExceededFault </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call pOSTAuthorizeClusterSecurityGroupIngressCall(String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, AuthorizeClusterSecurityGroupIngressMessage authorizeClusterSecurityGroupIngressMessage, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = authorizeClusterSecurityGroupIngressMessage;

        // create path and map variables
        String localVarPath = "/#Action=AuthorizeClusterSecurityGroupIngress";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (action != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("Action", action));
        }

        if (version != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("Version", version));
        }

        if (xAmzContentSha256 != null) {
            localVarHeaderParams.put("X-Amz-Content-Sha256", localVarApiClient.parameterToString(xAmzContentSha256));
        }

        if (xAmzDate != null) {
            localVarHeaderParams.put("X-Amz-Date", localVarApiClient.parameterToString(xAmzDate));
        }

        if (xAmzAlgorithm != null) {
            localVarHeaderParams.put("X-Amz-Algorithm", localVarApiClient.parameterToString(xAmzAlgorithm));
        }

        if (xAmzCredential != null) {
            localVarHeaderParams.put("X-Amz-Credential", localVarApiClient.parameterToString(xAmzCredential));
        }

        if (xAmzSecurityToken != null) {
            localVarHeaderParams.put("X-Amz-Security-Token", localVarApiClient.parameterToString(xAmzSecurityToken));
        }

        if (xAmzSignature != null) {
            localVarHeaderParams.put("X-Amz-Signature", localVarApiClient.parameterToString(xAmzSignature));
        }

        if (xAmzSignedHeaders != null) {
            localVarHeaderParams.put("X-Amz-SignedHeaders", localVarApiClient.parameterToString(xAmzSignedHeaders));
        }

        final String[] localVarAccepts = {
            "text/xml"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            "text/xml"
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "hmac" };
        return localVarApiClient.buildCall(basePath, localVarPath, "POST", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call pOSTAuthorizeClusterSecurityGroupIngressValidateBeforeCall(String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, AuthorizeClusterSecurityGroupIngressMessage authorizeClusterSecurityGroupIngressMessage, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'action' is set
        if (action == null) {
            throw new ApiException("Missing the required parameter 'action' when calling pOSTAuthorizeClusterSecurityGroupIngress(Async)");
        }

        // verify the required parameter 'version' is set
        if (version == null) {
            throw new ApiException("Missing the required parameter 'version' when calling pOSTAuthorizeClusterSecurityGroupIngress(Async)");
        }

        return pOSTAuthorizeClusterSecurityGroupIngressCall(action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, authorizeClusterSecurityGroupIngressMessage, _callback);

    }

    /**
     * 
     * &lt;p&gt;Adds an inbound (ingress) rule to an Amazon Redshift security group. Depending on whether the application accessing your cluster is running on the Internet or an Amazon EC2 instance, you can authorize inbound access to either a Classless Interdomain Routing (CIDR)/Internet Protocol (IP) range or to an Amazon EC2 security group. You can add as many as 20 ingress rules to an Amazon Redshift security group.&lt;/p&gt; &lt;p&gt;If you authorize access to an Amazon EC2 security group, specify &lt;i&gt;EC2SecurityGroupName&lt;/i&gt; and &lt;i&gt;EC2SecurityGroupOwnerId&lt;/i&gt;. The Amazon EC2 security group and Amazon Redshift cluster must be in the same Amazon Web Services Region. &lt;/p&gt; &lt;p&gt;If you authorize access to a CIDR/IP address range, specify &lt;i&gt;CIDRIP&lt;/i&gt;. For an overview of CIDR blocks, see the Wikipedia article on &lt;a href&#x3D;\&quot;http://en.wikipedia.org/wiki/Classless_Inter-Domain_Routing\&quot;&gt;Classless Inter-Domain Routing&lt;/a&gt;. &lt;/p&gt; &lt;p&gt;You must also associate the security group with a cluster so that clients running on these IP addresses or the EC2 instance are authorized to connect to the cluster. For information about managing security groups, go to &lt;a href&#x3D;\&quot;https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-security-groups.html\&quot;&gt;Working with Security Groups&lt;/a&gt; in the &lt;i&gt;Amazon Redshift Cluster Management Guide&lt;/i&gt;.&lt;/p&gt;
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param authorizeClusterSecurityGroupIngressMessage  (optional)
     * @return AuthorizeClusterSecurityGroupIngressResult
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> ClusterSecurityGroupNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> InvalidClusterSecurityGroupStateFault </td><td>  -  </td></tr>
        <tr><td> 482 </td><td> AuthorizationAlreadyExistsFault </td><td>  -  </td></tr>
        <tr><td> 483 </td><td> AuthorizationQuotaExceededFault </td><td>  -  </td></tr>
     </table>
     */
    public AuthorizeClusterSecurityGroupIngressResult pOSTAuthorizeClusterSecurityGroupIngress(String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, AuthorizeClusterSecurityGroupIngressMessage authorizeClusterSecurityGroupIngressMessage) throws ApiException {
        ApiResponse<AuthorizeClusterSecurityGroupIngressResult> localVarResp = pOSTAuthorizeClusterSecurityGroupIngressWithHttpInfo(action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, authorizeClusterSecurityGroupIngressMessage);
        return localVarResp.getData();
    }

    /**
     * 
     * &lt;p&gt;Adds an inbound (ingress) rule to an Amazon Redshift security group. Depending on whether the application accessing your cluster is running on the Internet or an Amazon EC2 instance, you can authorize inbound access to either a Classless Interdomain Routing (CIDR)/Internet Protocol (IP) range or to an Amazon EC2 security group. You can add as many as 20 ingress rules to an Amazon Redshift security group.&lt;/p&gt; &lt;p&gt;If you authorize access to an Amazon EC2 security group, specify &lt;i&gt;EC2SecurityGroupName&lt;/i&gt; and &lt;i&gt;EC2SecurityGroupOwnerId&lt;/i&gt;. The Amazon EC2 security group and Amazon Redshift cluster must be in the same Amazon Web Services Region. &lt;/p&gt; &lt;p&gt;If you authorize access to a CIDR/IP address range, specify &lt;i&gt;CIDRIP&lt;/i&gt;. For an overview of CIDR blocks, see the Wikipedia article on &lt;a href&#x3D;\&quot;http://en.wikipedia.org/wiki/Classless_Inter-Domain_Routing\&quot;&gt;Classless Inter-Domain Routing&lt;/a&gt;. &lt;/p&gt; &lt;p&gt;You must also associate the security group with a cluster so that clients running on these IP addresses or the EC2 instance are authorized to connect to the cluster. For information about managing security groups, go to &lt;a href&#x3D;\&quot;https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-security-groups.html\&quot;&gt;Working with Security Groups&lt;/a&gt; in the &lt;i&gt;Amazon Redshift Cluster Management Guide&lt;/i&gt;.&lt;/p&gt;
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param authorizeClusterSecurityGroupIngressMessage  (optional)
     * @return ApiResponse&lt;AuthorizeClusterSecurityGroupIngressResult&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> ClusterSecurityGroupNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> InvalidClusterSecurityGroupStateFault </td><td>  -  </td></tr>
        <tr><td> 482 </td><td> AuthorizationAlreadyExistsFault </td><td>  -  </td></tr>
        <tr><td> 483 </td><td> AuthorizationQuotaExceededFault </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<AuthorizeClusterSecurityGroupIngressResult> pOSTAuthorizeClusterSecurityGroupIngressWithHttpInfo(String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, AuthorizeClusterSecurityGroupIngressMessage authorizeClusterSecurityGroupIngressMessage) throws ApiException {
        okhttp3.Call localVarCall = pOSTAuthorizeClusterSecurityGroupIngressValidateBeforeCall(action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, authorizeClusterSecurityGroupIngressMessage, null);
        Type localVarReturnType = new TypeToken<AuthorizeClusterSecurityGroupIngressResult>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     *  (asynchronously)
     * &lt;p&gt;Adds an inbound (ingress) rule to an Amazon Redshift security group. Depending on whether the application accessing your cluster is running on the Internet or an Amazon EC2 instance, you can authorize inbound access to either a Classless Interdomain Routing (CIDR)/Internet Protocol (IP) range or to an Amazon EC2 security group. You can add as many as 20 ingress rules to an Amazon Redshift security group.&lt;/p&gt; &lt;p&gt;If you authorize access to an Amazon EC2 security group, specify &lt;i&gt;EC2SecurityGroupName&lt;/i&gt; and &lt;i&gt;EC2SecurityGroupOwnerId&lt;/i&gt;. The Amazon EC2 security group and Amazon Redshift cluster must be in the same Amazon Web Services Region. &lt;/p&gt; &lt;p&gt;If you authorize access to a CIDR/IP address range, specify &lt;i&gt;CIDRIP&lt;/i&gt;. For an overview of CIDR blocks, see the Wikipedia article on &lt;a href&#x3D;\&quot;http://en.wikipedia.org/wiki/Classless_Inter-Domain_Routing\&quot;&gt;Classless Inter-Domain Routing&lt;/a&gt;. &lt;/p&gt; &lt;p&gt;You must also associate the security group with a cluster so that clients running on these IP addresses or the EC2 instance are authorized to connect to the cluster. For information about managing security groups, go to &lt;a href&#x3D;\&quot;https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-security-groups.html\&quot;&gt;Working with Security Groups&lt;/a&gt; in the &lt;i&gt;Amazon Redshift Cluster Management Guide&lt;/i&gt;.&lt;/p&gt;
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param authorizeClusterSecurityGroupIngressMessage  (optional)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> ClusterSecurityGroupNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> InvalidClusterSecurityGroupStateFault </td><td>  -  </td></tr>
        <tr><td> 482 </td><td> AuthorizationAlreadyExistsFault </td><td>  -  </td></tr>
        <tr><td> 483 </td><td> AuthorizationQuotaExceededFault </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call pOSTAuthorizeClusterSecurityGroupIngressAsync(String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, AuthorizeClusterSecurityGroupIngressMessage authorizeClusterSecurityGroupIngressMessage, final ApiCallback<AuthorizeClusterSecurityGroupIngressResult> _callback) throws ApiException {

        okhttp3.Call localVarCall = pOSTAuthorizeClusterSecurityGroupIngressValidateBeforeCall(action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, authorizeClusterSecurityGroupIngressMessage, _callback);
        Type localVarReturnType = new TypeToken<AuthorizeClusterSecurityGroupIngressResult>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for pOSTAuthorizeDataShare
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param authorizeDataShareMessage  (optional)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> InvalidDataShareFault </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call pOSTAuthorizeDataShareCall(String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, AuthorizeDataShareMessage authorizeDataShareMessage, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = authorizeDataShareMessage;

        // create path and map variables
        String localVarPath = "/#Action=AuthorizeDataShare";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (action != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("Action", action));
        }

        if (version != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("Version", version));
        }

        if (xAmzContentSha256 != null) {
            localVarHeaderParams.put("X-Amz-Content-Sha256", localVarApiClient.parameterToString(xAmzContentSha256));
        }

        if (xAmzDate != null) {
            localVarHeaderParams.put("X-Amz-Date", localVarApiClient.parameterToString(xAmzDate));
        }

        if (xAmzAlgorithm != null) {
            localVarHeaderParams.put("X-Amz-Algorithm", localVarApiClient.parameterToString(xAmzAlgorithm));
        }

        if (xAmzCredential != null) {
            localVarHeaderParams.put("X-Amz-Credential", localVarApiClient.parameterToString(xAmzCredential));
        }

        if (xAmzSecurityToken != null) {
            localVarHeaderParams.put("X-Amz-Security-Token", localVarApiClient.parameterToString(xAmzSecurityToken));
        }

        if (xAmzSignature != null) {
            localVarHeaderParams.put("X-Amz-Signature", localVarApiClient.parameterToString(xAmzSignature));
        }

        if (xAmzSignedHeaders != null) {
            localVarHeaderParams.put("X-Amz-SignedHeaders", localVarApiClient.parameterToString(xAmzSignedHeaders));
        }

        final String[] localVarAccepts = {
            "text/xml"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            "text/xml"
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "hmac" };
        return localVarApiClient.buildCall(basePath, localVarPath, "POST", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call pOSTAuthorizeDataShareValidateBeforeCall(String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, AuthorizeDataShareMessage authorizeDataShareMessage, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'action' is set
        if (action == null) {
            throw new ApiException("Missing the required parameter 'action' when calling pOSTAuthorizeDataShare(Async)");
        }

        // verify the required parameter 'version' is set
        if (version == null) {
            throw new ApiException("Missing the required parameter 'version' when calling pOSTAuthorizeDataShare(Async)");
        }

        return pOSTAuthorizeDataShareCall(action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, authorizeDataShareMessage, _callback);

    }

    /**
     * 
     * From a data producer account, authorizes the sharing of a datashare with one or more consumer accounts or managing entities. To authorize a datashare for a data consumer, the producer account must have the correct access permissions.
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param authorizeDataShareMessage  (optional)
     * @return DataShare
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> InvalidDataShareFault </td><td>  -  </td></tr>
     </table>
     */
    public DataShare pOSTAuthorizeDataShare(String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, AuthorizeDataShareMessage authorizeDataShareMessage) throws ApiException {
        ApiResponse<DataShare> localVarResp = pOSTAuthorizeDataShareWithHttpInfo(action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, authorizeDataShareMessage);
        return localVarResp.getData();
    }

    /**
     * 
     * From a data producer account, authorizes the sharing of a datashare with one or more consumer accounts or managing entities. To authorize a datashare for a data consumer, the producer account must have the correct access permissions.
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param authorizeDataShareMessage  (optional)
     * @return ApiResponse&lt;DataShare&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> InvalidDataShareFault </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<DataShare> pOSTAuthorizeDataShareWithHttpInfo(String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, AuthorizeDataShareMessage authorizeDataShareMessage) throws ApiException {
        okhttp3.Call localVarCall = pOSTAuthorizeDataShareValidateBeforeCall(action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, authorizeDataShareMessage, null);
        Type localVarReturnType = new TypeToken<DataShare>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     *  (asynchronously)
     * From a data producer account, authorizes the sharing of a datashare with one or more consumer accounts or managing entities. To authorize a datashare for a data consumer, the producer account must have the correct access permissions.
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param authorizeDataShareMessage  (optional)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> InvalidDataShareFault </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call pOSTAuthorizeDataShareAsync(String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, AuthorizeDataShareMessage authorizeDataShareMessage, final ApiCallback<DataShare> _callback) throws ApiException {

        okhttp3.Call localVarCall = pOSTAuthorizeDataShareValidateBeforeCall(action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, authorizeDataShareMessage, _callback);
        Type localVarReturnType = new TypeToken<DataShare>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for pOSTAuthorizeEndpointAccess
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param authorizeEndpointAccessMessage  (optional)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> ClusterNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> EndpointAuthorizationsPerClusterLimitExceededFault </td><td>  -  </td></tr>
        <tr><td> 482 </td><td> UnsupportedOperationFault </td><td>  -  </td></tr>
        <tr><td> 483 </td><td> EndpointAuthorizationAlreadyExistsFault </td><td>  -  </td></tr>
        <tr><td> 484 </td><td> InvalidAuthorizationStateFault </td><td>  -  </td></tr>
        <tr><td> 485 </td><td> InvalidClusterStateFault </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call pOSTAuthorizeEndpointAccessCall(String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, AuthorizeEndpointAccessMessage authorizeEndpointAccessMessage, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = authorizeEndpointAccessMessage;

        // create path and map variables
        String localVarPath = "/#Action=AuthorizeEndpointAccess";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (action != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("Action", action));
        }

        if (version != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("Version", version));
        }

        if (xAmzContentSha256 != null) {
            localVarHeaderParams.put("X-Amz-Content-Sha256", localVarApiClient.parameterToString(xAmzContentSha256));
        }

        if (xAmzDate != null) {
            localVarHeaderParams.put("X-Amz-Date", localVarApiClient.parameterToString(xAmzDate));
        }

        if (xAmzAlgorithm != null) {
            localVarHeaderParams.put("X-Amz-Algorithm", localVarApiClient.parameterToString(xAmzAlgorithm));
        }

        if (xAmzCredential != null) {
            localVarHeaderParams.put("X-Amz-Credential", localVarApiClient.parameterToString(xAmzCredential));
        }

        if (xAmzSecurityToken != null) {
            localVarHeaderParams.put("X-Amz-Security-Token", localVarApiClient.parameterToString(xAmzSecurityToken));
        }

        if (xAmzSignature != null) {
            localVarHeaderParams.put("X-Amz-Signature", localVarApiClient.parameterToString(xAmzSignature));
        }

        if (xAmzSignedHeaders != null) {
            localVarHeaderParams.put("X-Amz-SignedHeaders", localVarApiClient.parameterToString(xAmzSignedHeaders));
        }

        final String[] localVarAccepts = {
            "text/xml"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            "text/xml"
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "hmac" };
        return localVarApiClient.buildCall(basePath, localVarPath, "POST", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call pOSTAuthorizeEndpointAccessValidateBeforeCall(String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, AuthorizeEndpointAccessMessage authorizeEndpointAccessMessage, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'action' is set
        if (action == null) {
            throw new ApiException("Missing the required parameter 'action' when calling pOSTAuthorizeEndpointAccess(Async)");
        }

        // verify the required parameter 'version' is set
        if (version == null) {
            throw new ApiException("Missing the required parameter 'version' when calling pOSTAuthorizeEndpointAccess(Async)");
        }

        return pOSTAuthorizeEndpointAccessCall(action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, authorizeEndpointAccessMessage, _callback);

    }

    /**
     * 
     * Grants access to a cluster.
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param authorizeEndpointAccessMessage  (optional)
     * @return EndpointAuthorization
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> ClusterNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> EndpointAuthorizationsPerClusterLimitExceededFault </td><td>  -  </td></tr>
        <tr><td> 482 </td><td> UnsupportedOperationFault </td><td>  -  </td></tr>
        <tr><td> 483 </td><td> EndpointAuthorizationAlreadyExistsFault </td><td>  -  </td></tr>
        <tr><td> 484 </td><td> InvalidAuthorizationStateFault </td><td>  -  </td></tr>
        <tr><td> 485 </td><td> InvalidClusterStateFault </td><td>  -  </td></tr>
     </table>
     */
    public EndpointAuthorization pOSTAuthorizeEndpointAccess(String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, AuthorizeEndpointAccessMessage authorizeEndpointAccessMessage) throws ApiException {
        ApiResponse<EndpointAuthorization> localVarResp = pOSTAuthorizeEndpointAccessWithHttpInfo(action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, authorizeEndpointAccessMessage);
        return localVarResp.getData();
    }

    /**
     * 
     * Grants access to a cluster.
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param authorizeEndpointAccessMessage  (optional)
     * @return ApiResponse&lt;EndpointAuthorization&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> ClusterNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> EndpointAuthorizationsPerClusterLimitExceededFault </td><td>  -  </td></tr>
        <tr><td> 482 </td><td> UnsupportedOperationFault </td><td>  -  </td></tr>
        <tr><td> 483 </td><td> EndpointAuthorizationAlreadyExistsFault </td><td>  -  </td></tr>
        <tr><td> 484 </td><td> InvalidAuthorizationStateFault </td><td>  -  </td></tr>
        <tr><td> 485 </td><td> InvalidClusterStateFault </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<EndpointAuthorization> pOSTAuthorizeEndpointAccessWithHttpInfo(String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, AuthorizeEndpointAccessMessage authorizeEndpointAccessMessage) throws ApiException {
        okhttp3.Call localVarCall = pOSTAuthorizeEndpointAccessValidateBeforeCall(action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, authorizeEndpointAccessMessage, null);
        Type localVarReturnType = new TypeToken<EndpointAuthorization>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     *  (asynchronously)
     * Grants access to a cluster.
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param authorizeEndpointAccessMessage  (optional)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> ClusterNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> EndpointAuthorizationsPerClusterLimitExceededFault </td><td>  -  </td></tr>
        <tr><td> 482 </td><td> UnsupportedOperationFault </td><td>  -  </td></tr>
        <tr><td> 483 </td><td> EndpointAuthorizationAlreadyExistsFault </td><td>  -  </td></tr>
        <tr><td> 484 </td><td> InvalidAuthorizationStateFault </td><td>  -  </td></tr>
        <tr><td> 485 </td><td> InvalidClusterStateFault </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call pOSTAuthorizeEndpointAccessAsync(String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, AuthorizeEndpointAccessMessage authorizeEndpointAccessMessage, final ApiCallback<EndpointAuthorization> _callback) throws ApiException {

        okhttp3.Call localVarCall = pOSTAuthorizeEndpointAccessValidateBeforeCall(action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, authorizeEndpointAccessMessage, _callback);
        Type localVarReturnType = new TypeToken<EndpointAuthorization>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for pOSTAuthorizeSnapshotAccess
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param authorizeSnapshotAccessMessage  (optional)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> ClusterSnapshotNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> AuthorizationAlreadyExistsFault </td><td>  -  </td></tr>
        <tr><td> 482 </td><td> AuthorizationQuotaExceededFault </td><td>  -  </td></tr>
        <tr><td> 483 </td><td> DependentServiceRequestThrottlingFault </td><td>  -  </td></tr>
        <tr><td> 484 </td><td> InvalidClusterSnapshotStateFault </td><td>  -  </td></tr>
        <tr><td> 485 </td><td> LimitExceededFault </td><td>  -  </td></tr>
        <tr><td> 486 </td><td> UnsupportedOperationFault </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call pOSTAuthorizeSnapshotAccessCall(String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, AuthorizeSnapshotAccessMessage authorizeSnapshotAccessMessage, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = authorizeSnapshotAccessMessage;

        // create path and map variables
        String localVarPath = "/#Action=AuthorizeSnapshotAccess";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (action != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("Action", action));
        }

        if (version != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("Version", version));
        }

        if (xAmzContentSha256 != null) {
            localVarHeaderParams.put("X-Amz-Content-Sha256", localVarApiClient.parameterToString(xAmzContentSha256));
        }

        if (xAmzDate != null) {
            localVarHeaderParams.put("X-Amz-Date", localVarApiClient.parameterToString(xAmzDate));
        }

        if (xAmzAlgorithm != null) {
            localVarHeaderParams.put("X-Amz-Algorithm", localVarApiClient.parameterToString(xAmzAlgorithm));
        }

        if (xAmzCredential != null) {
            localVarHeaderParams.put("X-Amz-Credential", localVarApiClient.parameterToString(xAmzCredential));
        }

        if (xAmzSecurityToken != null) {
            localVarHeaderParams.put("X-Amz-Security-Token", localVarApiClient.parameterToString(xAmzSecurityToken));
        }

        if (xAmzSignature != null) {
            localVarHeaderParams.put("X-Amz-Signature", localVarApiClient.parameterToString(xAmzSignature));
        }

        if (xAmzSignedHeaders != null) {
            localVarHeaderParams.put("X-Amz-SignedHeaders", localVarApiClient.parameterToString(xAmzSignedHeaders));
        }

        final String[] localVarAccepts = {
            "text/xml"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            "text/xml"
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "hmac" };
        return localVarApiClient.buildCall(basePath, localVarPath, "POST", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call pOSTAuthorizeSnapshotAccessValidateBeforeCall(String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, AuthorizeSnapshotAccessMessage authorizeSnapshotAccessMessage, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'action' is set
        if (action == null) {
            throw new ApiException("Missing the required parameter 'action' when calling pOSTAuthorizeSnapshotAccess(Async)");
        }

        // verify the required parameter 'version' is set
        if (version == null) {
            throw new ApiException("Missing the required parameter 'version' when calling pOSTAuthorizeSnapshotAccess(Async)");
        }

        return pOSTAuthorizeSnapshotAccessCall(action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, authorizeSnapshotAccessMessage, _callback);

    }

    /**
     * 
     * &lt;p&gt;Authorizes the specified Amazon Web Services account to restore the specified snapshot.&lt;/p&gt; &lt;p&gt; For more information about working with snapshots, go to &lt;a href&#x3D;\&quot;https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-snapshots.html\&quot;&gt;Amazon Redshift Snapshots&lt;/a&gt; in the &lt;i&gt;Amazon Redshift Cluster Management Guide&lt;/i&gt;.&lt;/p&gt;
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param authorizeSnapshotAccessMessage  (optional)
     * @return AuthorizeSnapshotAccessResult
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> ClusterSnapshotNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> AuthorizationAlreadyExistsFault </td><td>  -  </td></tr>
        <tr><td> 482 </td><td> AuthorizationQuotaExceededFault </td><td>  -  </td></tr>
        <tr><td> 483 </td><td> DependentServiceRequestThrottlingFault </td><td>  -  </td></tr>
        <tr><td> 484 </td><td> InvalidClusterSnapshotStateFault </td><td>  -  </td></tr>
        <tr><td> 485 </td><td> LimitExceededFault </td><td>  -  </td></tr>
        <tr><td> 486 </td><td> UnsupportedOperationFault </td><td>  -  </td></tr>
     </table>
     */
    public AuthorizeSnapshotAccessResult pOSTAuthorizeSnapshotAccess(String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, AuthorizeSnapshotAccessMessage authorizeSnapshotAccessMessage) throws ApiException {
        ApiResponse<AuthorizeSnapshotAccessResult> localVarResp = pOSTAuthorizeSnapshotAccessWithHttpInfo(action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, authorizeSnapshotAccessMessage);
        return localVarResp.getData();
    }

    /**
     * 
     * &lt;p&gt;Authorizes the specified Amazon Web Services account to restore the specified snapshot.&lt;/p&gt; &lt;p&gt; For more information about working with snapshots, go to &lt;a href&#x3D;\&quot;https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-snapshots.html\&quot;&gt;Amazon Redshift Snapshots&lt;/a&gt; in the &lt;i&gt;Amazon Redshift Cluster Management Guide&lt;/i&gt;.&lt;/p&gt;
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param authorizeSnapshotAccessMessage  (optional)
     * @return ApiResponse&lt;AuthorizeSnapshotAccessResult&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> ClusterSnapshotNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> AuthorizationAlreadyExistsFault </td><td>  -  </td></tr>
        <tr><td> 482 </td><td> AuthorizationQuotaExceededFault </td><td>  -  </td></tr>
        <tr><td> 483 </td><td> DependentServiceRequestThrottlingFault </td><td>  -  </td></tr>
        <tr><td> 484 </td><td> InvalidClusterSnapshotStateFault </td><td>  -  </td></tr>
        <tr><td> 485 </td><td> LimitExceededFault </td><td>  -  </td></tr>
        <tr><td> 486 </td><td> UnsupportedOperationFault </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<AuthorizeSnapshotAccessResult> pOSTAuthorizeSnapshotAccessWithHttpInfo(String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, AuthorizeSnapshotAccessMessage authorizeSnapshotAccessMessage) throws ApiException {
        okhttp3.Call localVarCall = pOSTAuthorizeSnapshotAccessValidateBeforeCall(action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, authorizeSnapshotAccessMessage, null);
        Type localVarReturnType = new TypeToken<AuthorizeSnapshotAccessResult>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     *  (asynchronously)
     * &lt;p&gt;Authorizes the specified Amazon Web Services account to restore the specified snapshot.&lt;/p&gt; &lt;p&gt; For more information about working with snapshots, go to &lt;a href&#x3D;\&quot;https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-snapshots.html\&quot;&gt;Amazon Redshift Snapshots&lt;/a&gt; in the &lt;i&gt;Amazon Redshift Cluster Management Guide&lt;/i&gt;.&lt;/p&gt;
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param authorizeSnapshotAccessMessage  (optional)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> ClusterSnapshotNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> AuthorizationAlreadyExistsFault </td><td>  -  </td></tr>
        <tr><td> 482 </td><td> AuthorizationQuotaExceededFault </td><td>  -  </td></tr>
        <tr><td> 483 </td><td> DependentServiceRequestThrottlingFault </td><td>  -  </td></tr>
        <tr><td> 484 </td><td> InvalidClusterSnapshotStateFault </td><td>  -  </td></tr>
        <tr><td> 485 </td><td> LimitExceededFault </td><td>  -  </td></tr>
        <tr><td> 486 </td><td> UnsupportedOperationFault </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call pOSTAuthorizeSnapshotAccessAsync(String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, AuthorizeSnapshotAccessMessage authorizeSnapshotAccessMessage, final ApiCallback<AuthorizeSnapshotAccessResult> _callback) throws ApiException {

        okhttp3.Call localVarCall = pOSTAuthorizeSnapshotAccessValidateBeforeCall(action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, authorizeSnapshotAccessMessage, _callback);
        Type localVarReturnType = new TypeToken<AuthorizeSnapshotAccessResult>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for pOSTBatchDeleteClusterSnapshots
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param batchDeleteClusterSnapshotsRequest  (optional)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> BatchDeleteRequestSizeExceededFault </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call pOSTBatchDeleteClusterSnapshotsCall(String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, BatchDeleteClusterSnapshotsRequest batchDeleteClusterSnapshotsRequest, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = batchDeleteClusterSnapshotsRequest;

        // create path and map variables
        String localVarPath = "/#Action=BatchDeleteClusterSnapshots";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (action != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("Action", action));
        }

        if (version != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("Version", version));
        }

        if (xAmzContentSha256 != null) {
            localVarHeaderParams.put("X-Amz-Content-Sha256", localVarApiClient.parameterToString(xAmzContentSha256));
        }

        if (xAmzDate != null) {
            localVarHeaderParams.put("X-Amz-Date", localVarApiClient.parameterToString(xAmzDate));
        }

        if (xAmzAlgorithm != null) {
            localVarHeaderParams.put("X-Amz-Algorithm", localVarApiClient.parameterToString(xAmzAlgorithm));
        }

        if (xAmzCredential != null) {
            localVarHeaderParams.put("X-Amz-Credential", localVarApiClient.parameterToString(xAmzCredential));
        }

        if (xAmzSecurityToken != null) {
            localVarHeaderParams.put("X-Amz-Security-Token", localVarApiClient.parameterToString(xAmzSecurityToken));
        }

        if (xAmzSignature != null) {
            localVarHeaderParams.put("X-Amz-Signature", localVarApiClient.parameterToString(xAmzSignature));
        }

        if (xAmzSignedHeaders != null) {
            localVarHeaderParams.put("X-Amz-SignedHeaders", localVarApiClient.parameterToString(xAmzSignedHeaders));
        }

        final String[] localVarAccepts = {
            "text/xml"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            "text/xml"
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "hmac" };
        return localVarApiClient.buildCall(basePath, localVarPath, "POST", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call pOSTBatchDeleteClusterSnapshotsValidateBeforeCall(String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, BatchDeleteClusterSnapshotsRequest batchDeleteClusterSnapshotsRequest, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'action' is set
        if (action == null) {
            throw new ApiException("Missing the required parameter 'action' when calling pOSTBatchDeleteClusterSnapshots(Async)");
        }

        // verify the required parameter 'version' is set
        if (version == null) {
            throw new ApiException("Missing the required parameter 'version' when calling pOSTBatchDeleteClusterSnapshots(Async)");
        }

        return pOSTBatchDeleteClusterSnapshotsCall(action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, batchDeleteClusterSnapshotsRequest, _callback);

    }

    /**
     * 
     * Deletes a set of cluster snapshots.
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param batchDeleteClusterSnapshotsRequest  (optional)
     * @return BatchDeleteClusterSnapshotsResult
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> BatchDeleteRequestSizeExceededFault </td><td>  -  </td></tr>
     </table>
     */
    public BatchDeleteClusterSnapshotsResult pOSTBatchDeleteClusterSnapshots(String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, BatchDeleteClusterSnapshotsRequest batchDeleteClusterSnapshotsRequest) throws ApiException {
        ApiResponse<BatchDeleteClusterSnapshotsResult> localVarResp = pOSTBatchDeleteClusterSnapshotsWithHttpInfo(action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, batchDeleteClusterSnapshotsRequest);
        return localVarResp.getData();
    }

    /**
     * 
     * Deletes a set of cluster snapshots.
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param batchDeleteClusterSnapshotsRequest  (optional)
     * @return ApiResponse&lt;BatchDeleteClusterSnapshotsResult&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> BatchDeleteRequestSizeExceededFault </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<BatchDeleteClusterSnapshotsResult> pOSTBatchDeleteClusterSnapshotsWithHttpInfo(String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, BatchDeleteClusterSnapshotsRequest batchDeleteClusterSnapshotsRequest) throws ApiException {
        okhttp3.Call localVarCall = pOSTBatchDeleteClusterSnapshotsValidateBeforeCall(action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, batchDeleteClusterSnapshotsRequest, null);
        Type localVarReturnType = new TypeToken<BatchDeleteClusterSnapshotsResult>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     *  (asynchronously)
     * Deletes a set of cluster snapshots.
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param batchDeleteClusterSnapshotsRequest  (optional)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> BatchDeleteRequestSizeExceededFault </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call pOSTBatchDeleteClusterSnapshotsAsync(String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, BatchDeleteClusterSnapshotsRequest batchDeleteClusterSnapshotsRequest, final ApiCallback<BatchDeleteClusterSnapshotsResult> _callback) throws ApiException {

        okhttp3.Call localVarCall = pOSTBatchDeleteClusterSnapshotsValidateBeforeCall(action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, batchDeleteClusterSnapshotsRequest, _callback);
        Type localVarReturnType = new TypeToken<BatchDeleteClusterSnapshotsResult>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for pOSTBatchModifyClusterSnapshots
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param batchModifyClusterSnapshotsMessage  (optional)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> InvalidRetentionPeriodFault </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> BatchModifyClusterSnapshotsLimitExceededFault </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call pOSTBatchModifyClusterSnapshotsCall(String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, BatchModifyClusterSnapshotsMessage batchModifyClusterSnapshotsMessage, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = batchModifyClusterSnapshotsMessage;

        // create path and map variables
        String localVarPath = "/#Action=BatchModifyClusterSnapshots";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (action != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("Action", action));
        }

        if (version != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("Version", version));
        }

        if (xAmzContentSha256 != null) {
            localVarHeaderParams.put("X-Amz-Content-Sha256", localVarApiClient.parameterToString(xAmzContentSha256));
        }

        if (xAmzDate != null) {
            localVarHeaderParams.put("X-Amz-Date", localVarApiClient.parameterToString(xAmzDate));
        }

        if (xAmzAlgorithm != null) {
            localVarHeaderParams.put("X-Amz-Algorithm", localVarApiClient.parameterToString(xAmzAlgorithm));
        }

        if (xAmzCredential != null) {
            localVarHeaderParams.put("X-Amz-Credential", localVarApiClient.parameterToString(xAmzCredential));
        }

        if (xAmzSecurityToken != null) {
            localVarHeaderParams.put("X-Amz-Security-Token", localVarApiClient.parameterToString(xAmzSecurityToken));
        }

        if (xAmzSignature != null) {
            localVarHeaderParams.put("X-Amz-Signature", localVarApiClient.parameterToString(xAmzSignature));
        }

        if (xAmzSignedHeaders != null) {
            localVarHeaderParams.put("X-Amz-SignedHeaders", localVarApiClient.parameterToString(xAmzSignedHeaders));
        }

        final String[] localVarAccepts = {
            "text/xml"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            "text/xml"
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "hmac" };
        return localVarApiClient.buildCall(basePath, localVarPath, "POST", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call pOSTBatchModifyClusterSnapshotsValidateBeforeCall(String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, BatchModifyClusterSnapshotsMessage batchModifyClusterSnapshotsMessage, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'action' is set
        if (action == null) {
            throw new ApiException("Missing the required parameter 'action' when calling pOSTBatchModifyClusterSnapshots(Async)");
        }

        // verify the required parameter 'version' is set
        if (version == null) {
            throw new ApiException("Missing the required parameter 'version' when calling pOSTBatchModifyClusterSnapshots(Async)");
        }

        return pOSTBatchModifyClusterSnapshotsCall(action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, batchModifyClusterSnapshotsMessage, _callback);

    }

    /**
     * 
     * Modifies the settings for a set of cluster snapshots.
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param batchModifyClusterSnapshotsMessage  (optional)
     * @return BatchModifyClusterSnapshotsOutputMessage
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> InvalidRetentionPeriodFault </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> BatchModifyClusterSnapshotsLimitExceededFault </td><td>  -  </td></tr>
     </table>
     */
    public BatchModifyClusterSnapshotsOutputMessage pOSTBatchModifyClusterSnapshots(String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, BatchModifyClusterSnapshotsMessage batchModifyClusterSnapshotsMessage) throws ApiException {
        ApiResponse<BatchModifyClusterSnapshotsOutputMessage> localVarResp = pOSTBatchModifyClusterSnapshotsWithHttpInfo(action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, batchModifyClusterSnapshotsMessage);
        return localVarResp.getData();
    }

    /**
     * 
     * Modifies the settings for a set of cluster snapshots.
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param batchModifyClusterSnapshotsMessage  (optional)
     * @return ApiResponse&lt;BatchModifyClusterSnapshotsOutputMessage&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> InvalidRetentionPeriodFault </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> BatchModifyClusterSnapshotsLimitExceededFault </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<BatchModifyClusterSnapshotsOutputMessage> pOSTBatchModifyClusterSnapshotsWithHttpInfo(String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, BatchModifyClusterSnapshotsMessage batchModifyClusterSnapshotsMessage) throws ApiException {
        okhttp3.Call localVarCall = pOSTBatchModifyClusterSnapshotsValidateBeforeCall(action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, batchModifyClusterSnapshotsMessage, null);
        Type localVarReturnType = new TypeToken<BatchModifyClusterSnapshotsOutputMessage>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     *  (asynchronously)
     * Modifies the settings for a set of cluster snapshots.
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param batchModifyClusterSnapshotsMessage  (optional)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> InvalidRetentionPeriodFault </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> BatchModifyClusterSnapshotsLimitExceededFault </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call pOSTBatchModifyClusterSnapshotsAsync(String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, BatchModifyClusterSnapshotsMessage batchModifyClusterSnapshotsMessage, final ApiCallback<BatchModifyClusterSnapshotsOutputMessage> _callback) throws ApiException {

        okhttp3.Call localVarCall = pOSTBatchModifyClusterSnapshotsValidateBeforeCall(action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, batchModifyClusterSnapshotsMessage, _callback);
        Type localVarReturnType = new TypeToken<BatchModifyClusterSnapshotsOutputMessage>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for pOSTCancelResize
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param cancelResizeMessage  (optional)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> ClusterNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> ResizeNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 482 </td><td> InvalidClusterStateFault </td><td>  -  </td></tr>
        <tr><td> 483 </td><td> UnsupportedOperationFault </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call pOSTCancelResizeCall(String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, CancelResizeMessage cancelResizeMessage, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = cancelResizeMessage;

        // create path and map variables
        String localVarPath = "/#Action=CancelResize";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (action != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("Action", action));
        }

        if (version != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("Version", version));
        }

        if (xAmzContentSha256 != null) {
            localVarHeaderParams.put("X-Amz-Content-Sha256", localVarApiClient.parameterToString(xAmzContentSha256));
        }

        if (xAmzDate != null) {
            localVarHeaderParams.put("X-Amz-Date", localVarApiClient.parameterToString(xAmzDate));
        }

        if (xAmzAlgorithm != null) {
            localVarHeaderParams.put("X-Amz-Algorithm", localVarApiClient.parameterToString(xAmzAlgorithm));
        }

        if (xAmzCredential != null) {
            localVarHeaderParams.put("X-Amz-Credential", localVarApiClient.parameterToString(xAmzCredential));
        }

        if (xAmzSecurityToken != null) {
            localVarHeaderParams.put("X-Amz-Security-Token", localVarApiClient.parameterToString(xAmzSecurityToken));
        }

        if (xAmzSignature != null) {
            localVarHeaderParams.put("X-Amz-Signature", localVarApiClient.parameterToString(xAmzSignature));
        }

        if (xAmzSignedHeaders != null) {
            localVarHeaderParams.put("X-Amz-SignedHeaders", localVarApiClient.parameterToString(xAmzSignedHeaders));
        }

        final String[] localVarAccepts = {
            "text/xml"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            "text/xml"
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "hmac" };
        return localVarApiClient.buildCall(basePath, localVarPath, "POST", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call pOSTCancelResizeValidateBeforeCall(String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, CancelResizeMessage cancelResizeMessage, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'action' is set
        if (action == null) {
            throw new ApiException("Missing the required parameter 'action' when calling pOSTCancelResize(Async)");
        }

        // verify the required parameter 'version' is set
        if (version == null) {
            throw new ApiException("Missing the required parameter 'version' when calling pOSTCancelResize(Async)");
        }

        return pOSTCancelResizeCall(action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, cancelResizeMessage, _callback);

    }

    /**
     * 
     * Cancels a resize operation for a cluster.
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param cancelResizeMessage  (optional)
     * @return ResizeProgressMessage
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> ClusterNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> ResizeNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 482 </td><td> InvalidClusterStateFault </td><td>  -  </td></tr>
        <tr><td> 483 </td><td> UnsupportedOperationFault </td><td>  -  </td></tr>
     </table>
     */
    public ResizeProgressMessage pOSTCancelResize(String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, CancelResizeMessage cancelResizeMessage) throws ApiException {
        ApiResponse<ResizeProgressMessage> localVarResp = pOSTCancelResizeWithHttpInfo(action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, cancelResizeMessage);
        return localVarResp.getData();
    }

    /**
     * 
     * Cancels a resize operation for a cluster.
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param cancelResizeMessage  (optional)
     * @return ApiResponse&lt;ResizeProgressMessage&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> ClusterNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> ResizeNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 482 </td><td> InvalidClusterStateFault </td><td>  -  </td></tr>
        <tr><td> 483 </td><td> UnsupportedOperationFault </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<ResizeProgressMessage> pOSTCancelResizeWithHttpInfo(String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, CancelResizeMessage cancelResizeMessage) throws ApiException {
        okhttp3.Call localVarCall = pOSTCancelResizeValidateBeforeCall(action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, cancelResizeMessage, null);
        Type localVarReturnType = new TypeToken<ResizeProgressMessage>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     *  (asynchronously)
     * Cancels a resize operation for a cluster.
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param cancelResizeMessage  (optional)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> ClusterNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> ResizeNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 482 </td><td> InvalidClusterStateFault </td><td>  -  </td></tr>
        <tr><td> 483 </td><td> UnsupportedOperationFault </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call pOSTCancelResizeAsync(String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, CancelResizeMessage cancelResizeMessage, final ApiCallback<ResizeProgressMessage> _callback) throws ApiException {

        okhttp3.Call localVarCall = pOSTCancelResizeValidateBeforeCall(action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, cancelResizeMessage, _callback);
        Type localVarReturnType = new TypeToken<ResizeProgressMessage>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for pOSTCopyClusterSnapshot
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param copyClusterSnapshotMessage  (optional)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> ClusterSnapshotAlreadyExistsFault </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> ClusterSnapshotNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 482 </td><td> InvalidClusterSnapshotStateFault </td><td>  -  </td></tr>
        <tr><td> 483 </td><td> ClusterSnapshotQuotaExceededFault </td><td>  -  </td></tr>
        <tr><td> 484 </td><td> InvalidRetentionPeriodFault </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call pOSTCopyClusterSnapshotCall(String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, CopyClusterSnapshotMessage copyClusterSnapshotMessage, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = copyClusterSnapshotMessage;

        // create path and map variables
        String localVarPath = "/#Action=CopyClusterSnapshot";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (action != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("Action", action));
        }

        if (version != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("Version", version));
        }

        if (xAmzContentSha256 != null) {
            localVarHeaderParams.put("X-Amz-Content-Sha256", localVarApiClient.parameterToString(xAmzContentSha256));
        }

        if (xAmzDate != null) {
            localVarHeaderParams.put("X-Amz-Date", localVarApiClient.parameterToString(xAmzDate));
        }

        if (xAmzAlgorithm != null) {
            localVarHeaderParams.put("X-Amz-Algorithm", localVarApiClient.parameterToString(xAmzAlgorithm));
        }

        if (xAmzCredential != null) {
            localVarHeaderParams.put("X-Amz-Credential", localVarApiClient.parameterToString(xAmzCredential));
        }

        if (xAmzSecurityToken != null) {
            localVarHeaderParams.put("X-Amz-Security-Token", localVarApiClient.parameterToString(xAmzSecurityToken));
        }

        if (xAmzSignature != null) {
            localVarHeaderParams.put("X-Amz-Signature", localVarApiClient.parameterToString(xAmzSignature));
        }

        if (xAmzSignedHeaders != null) {
            localVarHeaderParams.put("X-Amz-SignedHeaders", localVarApiClient.parameterToString(xAmzSignedHeaders));
        }

        final String[] localVarAccepts = {
            "text/xml"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            "text/xml"
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "hmac" };
        return localVarApiClient.buildCall(basePath, localVarPath, "POST", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call pOSTCopyClusterSnapshotValidateBeforeCall(String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, CopyClusterSnapshotMessage copyClusterSnapshotMessage, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'action' is set
        if (action == null) {
            throw new ApiException("Missing the required parameter 'action' when calling pOSTCopyClusterSnapshot(Async)");
        }

        // verify the required parameter 'version' is set
        if (version == null) {
            throw new ApiException("Missing the required parameter 'version' when calling pOSTCopyClusterSnapshot(Async)");
        }

        return pOSTCopyClusterSnapshotCall(action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, copyClusterSnapshotMessage, _callback);

    }

    /**
     * 
     * &lt;p&gt;Copies the specified automated cluster snapshot to a new manual cluster snapshot. The source must be an automated snapshot and it must be in the available state.&lt;/p&gt; &lt;p&gt;When you delete a cluster, Amazon Redshift deletes any automated snapshots of the cluster. Also, when the retention period of the snapshot expires, Amazon Redshift automatically deletes it. If you want to keep an automated snapshot for a longer period, you can make a manual copy of the snapshot. Manual snapshots are retained until you delete them.&lt;/p&gt; &lt;p&gt; For more information about working with snapshots, go to &lt;a href&#x3D;\&quot;https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-snapshots.html\&quot;&gt;Amazon Redshift Snapshots&lt;/a&gt; in the &lt;i&gt;Amazon Redshift Cluster Management Guide&lt;/i&gt;.&lt;/p&gt;
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param copyClusterSnapshotMessage  (optional)
     * @return CopyClusterSnapshotResult
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> ClusterSnapshotAlreadyExistsFault </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> ClusterSnapshotNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 482 </td><td> InvalidClusterSnapshotStateFault </td><td>  -  </td></tr>
        <tr><td> 483 </td><td> ClusterSnapshotQuotaExceededFault </td><td>  -  </td></tr>
        <tr><td> 484 </td><td> InvalidRetentionPeriodFault </td><td>  -  </td></tr>
     </table>
     */
    public CopyClusterSnapshotResult pOSTCopyClusterSnapshot(String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, CopyClusterSnapshotMessage copyClusterSnapshotMessage) throws ApiException {
        ApiResponse<CopyClusterSnapshotResult> localVarResp = pOSTCopyClusterSnapshotWithHttpInfo(action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, copyClusterSnapshotMessage);
        return localVarResp.getData();
    }

    /**
     * 
     * &lt;p&gt;Copies the specified automated cluster snapshot to a new manual cluster snapshot. The source must be an automated snapshot and it must be in the available state.&lt;/p&gt; &lt;p&gt;When you delete a cluster, Amazon Redshift deletes any automated snapshots of the cluster. Also, when the retention period of the snapshot expires, Amazon Redshift automatically deletes it. If you want to keep an automated snapshot for a longer period, you can make a manual copy of the snapshot. Manual snapshots are retained until you delete them.&lt;/p&gt; &lt;p&gt; For more information about working with snapshots, go to &lt;a href&#x3D;\&quot;https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-snapshots.html\&quot;&gt;Amazon Redshift Snapshots&lt;/a&gt; in the &lt;i&gt;Amazon Redshift Cluster Management Guide&lt;/i&gt;.&lt;/p&gt;
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param copyClusterSnapshotMessage  (optional)
     * @return ApiResponse&lt;CopyClusterSnapshotResult&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> ClusterSnapshotAlreadyExistsFault </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> ClusterSnapshotNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 482 </td><td> InvalidClusterSnapshotStateFault </td><td>  -  </td></tr>
        <tr><td> 483 </td><td> ClusterSnapshotQuotaExceededFault </td><td>  -  </td></tr>
        <tr><td> 484 </td><td> InvalidRetentionPeriodFault </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<CopyClusterSnapshotResult> pOSTCopyClusterSnapshotWithHttpInfo(String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, CopyClusterSnapshotMessage copyClusterSnapshotMessage) throws ApiException {
        okhttp3.Call localVarCall = pOSTCopyClusterSnapshotValidateBeforeCall(action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, copyClusterSnapshotMessage, null);
        Type localVarReturnType = new TypeToken<CopyClusterSnapshotResult>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     *  (asynchronously)
     * &lt;p&gt;Copies the specified automated cluster snapshot to a new manual cluster snapshot. The source must be an automated snapshot and it must be in the available state.&lt;/p&gt; &lt;p&gt;When you delete a cluster, Amazon Redshift deletes any automated snapshots of the cluster. Also, when the retention period of the snapshot expires, Amazon Redshift automatically deletes it. If you want to keep an automated snapshot for a longer period, you can make a manual copy of the snapshot. Manual snapshots are retained until you delete them.&lt;/p&gt; &lt;p&gt; For more information about working with snapshots, go to &lt;a href&#x3D;\&quot;https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-snapshots.html\&quot;&gt;Amazon Redshift Snapshots&lt;/a&gt; in the &lt;i&gt;Amazon Redshift Cluster Management Guide&lt;/i&gt;.&lt;/p&gt;
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param copyClusterSnapshotMessage  (optional)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> ClusterSnapshotAlreadyExistsFault </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> ClusterSnapshotNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 482 </td><td> InvalidClusterSnapshotStateFault </td><td>  -  </td></tr>
        <tr><td> 483 </td><td> ClusterSnapshotQuotaExceededFault </td><td>  -  </td></tr>
        <tr><td> 484 </td><td> InvalidRetentionPeriodFault </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call pOSTCopyClusterSnapshotAsync(String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, CopyClusterSnapshotMessage copyClusterSnapshotMessage, final ApiCallback<CopyClusterSnapshotResult> _callback) throws ApiException {

        okhttp3.Call localVarCall = pOSTCopyClusterSnapshotValidateBeforeCall(action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, copyClusterSnapshotMessage, _callback);
        Type localVarReturnType = new TypeToken<CopyClusterSnapshotResult>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for pOSTCreateAuthenticationProfile
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param createAuthenticationProfileMessage  (optional)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> AuthenticationProfileAlreadyExistsFault </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> AuthenticationProfileQuotaExceededFault </td><td>  -  </td></tr>
        <tr><td> 482 </td><td> InvalidAuthenticationProfileRequestFault </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call pOSTCreateAuthenticationProfileCall(String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, CreateAuthenticationProfileMessage createAuthenticationProfileMessage, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = createAuthenticationProfileMessage;

        // create path and map variables
        String localVarPath = "/#Action=CreateAuthenticationProfile";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (action != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("Action", action));
        }

        if (version != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("Version", version));
        }

        if (xAmzContentSha256 != null) {
            localVarHeaderParams.put("X-Amz-Content-Sha256", localVarApiClient.parameterToString(xAmzContentSha256));
        }

        if (xAmzDate != null) {
            localVarHeaderParams.put("X-Amz-Date", localVarApiClient.parameterToString(xAmzDate));
        }

        if (xAmzAlgorithm != null) {
            localVarHeaderParams.put("X-Amz-Algorithm", localVarApiClient.parameterToString(xAmzAlgorithm));
        }

        if (xAmzCredential != null) {
            localVarHeaderParams.put("X-Amz-Credential", localVarApiClient.parameterToString(xAmzCredential));
        }

        if (xAmzSecurityToken != null) {
            localVarHeaderParams.put("X-Amz-Security-Token", localVarApiClient.parameterToString(xAmzSecurityToken));
        }

        if (xAmzSignature != null) {
            localVarHeaderParams.put("X-Amz-Signature", localVarApiClient.parameterToString(xAmzSignature));
        }

        if (xAmzSignedHeaders != null) {
            localVarHeaderParams.put("X-Amz-SignedHeaders", localVarApiClient.parameterToString(xAmzSignedHeaders));
        }

        final String[] localVarAccepts = {
            "text/xml"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            "text/xml"
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "hmac" };
        return localVarApiClient.buildCall(basePath, localVarPath, "POST", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call pOSTCreateAuthenticationProfileValidateBeforeCall(String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, CreateAuthenticationProfileMessage createAuthenticationProfileMessage, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'action' is set
        if (action == null) {
            throw new ApiException("Missing the required parameter 'action' when calling pOSTCreateAuthenticationProfile(Async)");
        }

        // verify the required parameter 'version' is set
        if (version == null) {
            throw new ApiException("Missing the required parameter 'version' when calling pOSTCreateAuthenticationProfile(Async)");
        }

        return pOSTCreateAuthenticationProfileCall(action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, createAuthenticationProfileMessage, _callback);

    }

    /**
     * 
     * Creates an authentication profile with the specified parameters.
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param createAuthenticationProfileMessage  (optional)
     * @return CreateAuthenticationProfileResult
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> AuthenticationProfileAlreadyExistsFault </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> AuthenticationProfileQuotaExceededFault </td><td>  -  </td></tr>
        <tr><td> 482 </td><td> InvalidAuthenticationProfileRequestFault </td><td>  -  </td></tr>
     </table>
     */
    public CreateAuthenticationProfileResult pOSTCreateAuthenticationProfile(String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, CreateAuthenticationProfileMessage createAuthenticationProfileMessage) throws ApiException {
        ApiResponse<CreateAuthenticationProfileResult> localVarResp = pOSTCreateAuthenticationProfileWithHttpInfo(action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, createAuthenticationProfileMessage);
        return localVarResp.getData();
    }

    /**
     * 
     * Creates an authentication profile with the specified parameters.
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param createAuthenticationProfileMessage  (optional)
     * @return ApiResponse&lt;CreateAuthenticationProfileResult&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> AuthenticationProfileAlreadyExistsFault </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> AuthenticationProfileQuotaExceededFault </td><td>  -  </td></tr>
        <tr><td> 482 </td><td> InvalidAuthenticationProfileRequestFault </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<CreateAuthenticationProfileResult> pOSTCreateAuthenticationProfileWithHttpInfo(String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, CreateAuthenticationProfileMessage createAuthenticationProfileMessage) throws ApiException {
        okhttp3.Call localVarCall = pOSTCreateAuthenticationProfileValidateBeforeCall(action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, createAuthenticationProfileMessage, null);
        Type localVarReturnType = new TypeToken<CreateAuthenticationProfileResult>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     *  (asynchronously)
     * Creates an authentication profile with the specified parameters.
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param createAuthenticationProfileMessage  (optional)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> AuthenticationProfileAlreadyExistsFault </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> AuthenticationProfileQuotaExceededFault </td><td>  -  </td></tr>
        <tr><td> 482 </td><td> InvalidAuthenticationProfileRequestFault </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call pOSTCreateAuthenticationProfileAsync(String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, CreateAuthenticationProfileMessage createAuthenticationProfileMessage, final ApiCallback<CreateAuthenticationProfileResult> _callback) throws ApiException {

        okhttp3.Call localVarCall = pOSTCreateAuthenticationProfileValidateBeforeCall(action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, createAuthenticationProfileMessage, _callback);
        Type localVarReturnType = new TypeToken<CreateAuthenticationProfileResult>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for pOSTCreateCluster
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param createClusterMessage  (optional)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> ClusterAlreadyExistsFault </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> InsufficientClusterCapacityFault </td><td>  -  </td></tr>
        <tr><td> 482 </td><td> ClusterParameterGroupNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 483 </td><td> ClusterSecurityGroupNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 484 </td><td> ClusterQuotaExceededFault </td><td>  -  </td></tr>
        <tr><td> 485 </td><td> NumberOfNodesQuotaExceededFault </td><td>  -  </td></tr>
        <tr><td> 486 </td><td> NumberOfNodesPerClusterLimitExceededFault </td><td>  -  </td></tr>
        <tr><td> 487 </td><td> ClusterSubnetGroupNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 488 </td><td> InvalidVPCNetworkStateFault </td><td>  -  </td></tr>
        <tr><td> 489 </td><td> InvalidClusterSubnetGroupStateFault </td><td>  -  </td></tr>
        <tr><td> 490 </td><td> InvalidSubnet </td><td>  -  </td></tr>
        <tr><td> 491 </td><td> UnauthorizedOperation </td><td>  -  </td></tr>
        <tr><td> 492 </td><td> HsmClientCertificateNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 493 </td><td> HsmConfigurationNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 494 </td><td> InvalidElasticIpFault </td><td>  -  </td></tr>
        <tr><td> 495 </td><td> TagLimitExceededFault </td><td>  -  </td></tr>
        <tr><td> 496 </td><td> InvalidTagFault </td><td>  -  </td></tr>
        <tr><td> 497 </td><td> LimitExceededFault </td><td>  -  </td></tr>
        <tr><td> 498 </td><td> DependentServiceRequestThrottlingFault </td><td>  -  </td></tr>
        <tr><td> 499 </td><td> InvalidClusterTrackFault </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> SnapshotScheduleNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 501 </td><td> InvalidRetentionPeriodFault </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call pOSTCreateClusterCall(String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, CreateClusterMessage createClusterMessage, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = createClusterMessage;

        // create path and map variables
        String localVarPath = "/#Action=CreateCluster";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (action != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("Action", action));
        }

        if (version != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("Version", version));
        }

        if (xAmzContentSha256 != null) {
            localVarHeaderParams.put("X-Amz-Content-Sha256", localVarApiClient.parameterToString(xAmzContentSha256));
        }

        if (xAmzDate != null) {
            localVarHeaderParams.put("X-Amz-Date", localVarApiClient.parameterToString(xAmzDate));
        }

        if (xAmzAlgorithm != null) {
            localVarHeaderParams.put("X-Amz-Algorithm", localVarApiClient.parameterToString(xAmzAlgorithm));
        }

        if (xAmzCredential != null) {
            localVarHeaderParams.put("X-Amz-Credential", localVarApiClient.parameterToString(xAmzCredential));
        }

        if (xAmzSecurityToken != null) {
            localVarHeaderParams.put("X-Amz-Security-Token", localVarApiClient.parameterToString(xAmzSecurityToken));
        }

        if (xAmzSignature != null) {
            localVarHeaderParams.put("X-Amz-Signature", localVarApiClient.parameterToString(xAmzSignature));
        }

        if (xAmzSignedHeaders != null) {
            localVarHeaderParams.put("X-Amz-SignedHeaders", localVarApiClient.parameterToString(xAmzSignedHeaders));
        }

        final String[] localVarAccepts = {
            "text/xml"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            "text/xml"
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "hmac" };
        return localVarApiClient.buildCall(basePath, localVarPath, "POST", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call pOSTCreateClusterValidateBeforeCall(String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, CreateClusterMessage createClusterMessage, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'action' is set
        if (action == null) {
            throw new ApiException("Missing the required parameter 'action' when calling pOSTCreateCluster(Async)");
        }

        // verify the required parameter 'version' is set
        if (version == null) {
            throw new ApiException("Missing the required parameter 'version' when calling pOSTCreateCluster(Async)");
        }

        return pOSTCreateClusterCall(action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, createClusterMessage, _callback);

    }

    /**
     * 
     * &lt;p&gt;Creates a new cluster with the specified parameters.&lt;/p&gt; &lt;p&gt;To create a cluster in Virtual Private Cloud (VPC), you must provide a cluster subnet group name. The cluster subnet group identifies the subnets of your VPC that Amazon Redshift uses when creating the cluster. For more information about managing clusters, go to &lt;a href&#x3D;\&quot;https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html\&quot;&gt;Amazon Redshift Clusters&lt;/a&gt; in the &lt;i&gt;Amazon Redshift Cluster Management Guide&lt;/i&gt;.&lt;/p&gt;
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param createClusterMessage  (optional)
     * @return CreateClusterResult
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> ClusterAlreadyExistsFault </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> InsufficientClusterCapacityFault </td><td>  -  </td></tr>
        <tr><td> 482 </td><td> ClusterParameterGroupNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 483 </td><td> ClusterSecurityGroupNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 484 </td><td> ClusterQuotaExceededFault </td><td>  -  </td></tr>
        <tr><td> 485 </td><td> NumberOfNodesQuotaExceededFault </td><td>  -  </td></tr>
        <tr><td> 486 </td><td> NumberOfNodesPerClusterLimitExceededFault </td><td>  -  </td></tr>
        <tr><td> 487 </td><td> ClusterSubnetGroupNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 488 </td><td> InvalidVPCNetworkStateFault </td><td>  -  </td></tr>
        <tr><td> 489 </td><td> InvalidClusterSubnetGroupStateFault </td><td>  -  </td></tr>
        <tr><td> 490 </td><td> InvalidSubnet </td><td>  -  </td></tr>
        <tr><td> 491 </td><td> UnauthorizedOperation </td><td>  -  </td></tr>
        <tr><td> 492 </td><td> HsmClientCertificateNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 493 </td><td> HsmConfigurationNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 494 </td><td> InvalidElasticIpFault </td><td>  -  </td></tr>
        <tr><td> 495 </td><td> TagLimitExceededFault </td><td>  -  </td></tr>
        <tr><td> 496 </td><td> InvalidTagFault </td><td>  -  </td></tr>
        <tr><td> 497 </td><td> LimitExceededFault </td><td>  -  </td></tr>
        <tr><td> 498 </td><td> DependentServiceRequestThrottlingFault </td><td>  -  </td></tr>
        <tr><td> 499 </td><td> InvalidClusterTrackFault </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> SnapshotScheduleNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 501 </td><td> InvalidRetentionPeriodFault </td><td>  -  </td></tr>
     </table>
     */
    public CreateClusterResult pOSTCreateCluster(String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, CreateClusterMessage createClusterMessage) throws ApiException {
        ApiResponse<CreateClusterResult> localVarResp = pOSTCreateClusterWithHttpInfo(action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, createClusterMessage);
        return localVarResp.getData();
    }

    /**
     * 
     * &lt;p&gt;Creates a new cluster with the specified parameters.&lt;/p&gt; &lt;p&gt;To create a cluster in Virtual Private Cloud (VPC), you must provide a cluster subnet group name. The cluster subnet group identifies the subnets of your VPC that Amazon Redshift uses when creating the cluster. For more information about managing clusters, go to &lt;a href&#x3D;\&quot;https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html\&quot;&gt;Amazon Redshift Clusters&lt;/a&gt; in the &lt;i&gt;Amazon Redshift Cluster Management Guide&lt;/i&gt;.&lt;/p&gt;
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param createClusterMessage  (optional)
     * @return ApiResponse&lt;CreateClusterResult&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> ClusterAlreadyExistsFault </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> InsufficientClusterCapacityFault </td><td>  -  </td></tr>
        <tr><td> 482 </td><td> ClusterParameterGroupNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 483 </td><td> ClusterSecurityGroupNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 484 </td><td> ClusterQuotaExceededFault </td><td>  -  </td></tr>
        <tr><td> 485 </td><td> NumberOfNodesQuotaExceededFault </td><td>  -  </td></tr>
        <tr><td> 486 </td><td> NumberOfNodesPerClusterLimitExceededFault </td><td>  -  </td></tr>
        <tr><td> 487 </td><td> ClusterSubnetGroupNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 488 </td><td> InvalidVPCNetworkStateFault </td><td>  -  </td></tr>
        <tr><td> 489 </td><td> InvalidClusterSubnetGroupStateFault </td><td>  -  </td></tr>
        <tr><td> 490 </td><td> InvalidSubnet </td><td>  -  </td></tr>
        <tr><td> 491 </td><td> UnauthorizedOperation </td><td>  -  </td></tr>
        <tr><td> 492 </td><td> HsmClientCertificateNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 493 </td><td> HsmConfigurationNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 494 </td><td> InvalidElasticIpFault </td><td>  -  </td></tr>
        <tr><td> 495 </td><td> TagLimitExceededFault </td><td>  -  </td></tr>
        <tr><td> 496 </td><td> InvalidTagFault </td><td>  -  </td></tr>
        <tr><td> 497 </td><td> LimitExceededFault </td><td>  -  </td></tr>
        <tr><td> 498 </td><td> DependentServiceRequestThrottlingFault </td><td>  -  </td></tr>
        <tr><td> 499 </td><td> InvalidClusterTrackFault </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> SnapshotScheduleNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 501 </td><td> InvalidRetentionPeriodFault </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<CreateClusterResult> pOSTCreateClusterWithHttpInfo(String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, CreateClusterMessage createClusterMessage) throws ApiException {
        okhttp3.Call localVarCall = pOSTCreateClusterValidateBeforeCall(action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, createClusterMessage, null);
        Type localVarReturnType = new TypeToken<CreateClusterResult>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     *  (asynchronously)
     * &lt;p&gt;Creates a new cluster with the specified parameters.&lt;/p&gt; &lt;p&gt;To create a cluster in Virtual Private Cloud (VPC), you must provide a cluster subnet group name. The cluster subnet group identifies the subnets of your VPC that Amazon Redshift uses when creating the cluster. For more information about managing clusters, go to &lt;a href&#x3D;\&quot;https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html\&quot;&gt;Amazon Redshift Clusters&lt;/a&gt; in the &lt;i&gt;Amazon Redshift Cluster Management Guide&lt;/i&gt;.&lt;/p&gt;
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param createClusterMessage  (optional)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> ClusterAlreadyExistsFault </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> InsufficientClusterCapacityFault </td><td>  -  </td></tr>
        <tr><td> 482 </td><td> ClusterParameterGroupNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 483 </td><td> ClusterSecurityGroupNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 484 </td><td> ClusterQuotaExceededFault </td><td>  -  </td></tr>
        <tr><td> 485 </td><td> NumberOfNodesQuotaExceededFault </td><td>  -  </td></tr>
        <tr><td> 486 </td><td> NumberOfNodesPerClusterLimitExceededFault </td><td>  -  </td></tr>
        <tr><td> 487 </td><td> ClusterSubnetGroupNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 488 </td><td> InvalidVPCNetworkStateFault </td><td>  -  </td></tr>
        <tr><td> 489 </td><td> InvalidClusterSubnetGroupStateFault </td><td>  -  </td></tr>
        <tr><td> 490 </td><td> InvalidSubnet </td><td>  -  </td></tr>
        <tr><td> 491 </td><td> UnauthorizedOperation </td><td>  -  </td></tr>
        <tr><td> 492 </td><td> HsmClientCertificateNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 493 </td><td> HsmConfigurationNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 494 </td><td> InvalidElasticIpFault </td><td>  -  </td></tr>
        <tr><td> 495 </td><td> TagLimitExceededFault </td><td>  -  </td></tr>
        <tr><td> 496 </td><td> InvalidTagFault </td><td>  -  </td></tr>
        <tr><td> 497 </td><td> LimitExceededFault </td><td>  -  </td></tr>
        <tr><td> 498 </td><td> DependentServiceRequestThrottlingFault </td><td>  -  </td></tr>
        <tr><td> 499 </td><td> InvalidClusterTrackFault </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> SnapshotScheduleNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 501 </td><td> InvalidRetentionPeriodFault </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call pOSTCreateClusterAsync(String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, CreateClusterMessage createClusterMessage, final ApiCallback<CreateClusterResult> _callback) throws ApiException {

        okhttp3.Call localVarCall = pOSTCreateClusterValidateBeforeCall(action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, createClusterMessage, _callback);
        Type localVarReturnType = new TypeToken<CreateClusterResult>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for pOSTCreateClusterParameterGroup
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param createClusterParameterGroupMessage  (optional)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> ClusterParameterGroupQuotaExceededFault </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> ClusterParameterGroupAlreadyExistsFault </td><td>  -  </td></tr>
        <tr><td> 482 </td><td> TagLimitExceededFault </td><td>  -  </td></tr>
        <tr><td> 483 </td><td> InvalidTagFault </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call pOSTCreateClusterParameterGroupCall(String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, CreateClusterParameterGroupMessage createClusterParameterGroupMessage, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = createClusterParameterGroupMessage;

        // create path and map variables
        String localVarPath = "/#Action=CreateClusterParameterGroup";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (action != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("Action", action));
        }

        if (version != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("Version", version));
        }

        if (xAmzContentSha256 != null) {
            localVarHeaderParams.put("X-Amz-Content-Sha256", localVarApiClient.parameterToString(xAmzContentSha256));
        }

        if (xAmzDate != null) {
            localVarHeaderParams.put("X-Amz-Date", localVarApiClient.parameterToString(xAmzDate));
        }

        if (xAmzAlgorithm != null) {
            localVarHeaderParams.put("X-Amz-Algorithm", localVarApiClient.parameterToString(xAmzAlgorithm));
        }

        if (xAmzCredential != null) {
            localVarHeaderParams.put("X-Amz-Credential", localVarApiClient.parameterToString(xAmzCredential));
        }

        if (xAmzSecurityToken != null) {
            localVarHeaderParams.put("X-Amz-Security-Token", localVarApiClient.parameterToString(xAmzSecurityToken));
        }

        if (xAmzSignature != null) {
            localVarHeaderParams.put("X-Amz-Signature", localVarApiClient.parameterToString(xAmzSignature));
        }

        if (xAmzSignedHeaders != null) {
            localVarHeaderParams.put("X-Amz-SignedHeaders", localVarApiClient.parameterToString(xAmzSignedHeaders));
        }

        final String[] localVarAccepts = {
            "text/xml"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            "text/xml"
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "hmac" };
        return localVarApiClient.buildCall(basePath, localVarPath, "POST", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call pOSTCreateClusterParameterGroupValidateBeforeCall(String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, CreateClusterParameterGroupMessage createClusterParameterGroupMessage, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'action' is set
        if (action == null) {
            throw new ApiException("Missing the required parameter 'action' when calling pOSTCreateClusterParameterGroup(Async)");
        }

        // verify the required parameter 'version' is set
        if (version == null) {
            throw new ApiException("Missing the required parameter 'version' when calling pOSTCreateClusterParameterGroup(Async)");
        }

        return pOSTCreateClusterParameterGroupCall(action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, createClusterParameterGroupMessage, _callback);

    }

    /**
     * 
     * &lt;p&gt;Creates an Amazon Redshift parameter group.&lt;/p&gt; &lt;p&gt;Creating parameter groups is independent of creating clusters. You can associate a cluster with a parameter group when you create the cluster. You can also associate an existing cluster with a parameter group after the cluster is created by using &lt;a&gt;ModifyCluster&lt;/a&gt;. &lt;/p&gt; &lt;p&gt;Parameters in the parameter group define specific behavior that applies to the databases you create on the cluster. For more information about parameters and parameter groups, go to &lt;a href&#x3D;\&quot;https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-parameter-groups.html\&quot;&gt;Amazon Redshift Parameter Groups&lt;/a&gt; in the &lt;i&gt;Amazon Redshift Cluster Management Guide&lt;/i&gt;.&lt;/p&gt;
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param createClusterParameterGroupMessage  (optional)
     * @return CreateClusterParameterGroupResult
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> ClusterParameterGroupQuotaExceededFault </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> ClusterParameterGroupAlreadyExistsFault </td><td>  -  </td></tr>
        <tr><td> 482 </td><td> TagLimitExceededFault </td><td>  -  </td></tr>
        <tr><td> 483 </td><td> InvalidTagFault </td><td>  -  </td></tr>
     </table>
     */
    public CreateClusterParameterGroupResult pOSTCreateClusterParameterGroup(String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, CreateClusterParameterGroupMessage createClusterParameterGroupMessage) throws ApiException {
        ApiResponse<CreateClusterParameterGroupResult> localVarResp = pOSTCreateClusterParameterGroupWithHttpInfo(action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, createClusterParameterGroupMessage);
        return localVarResp.getData();
    }

    /**
     * 
     * &lt;p&gt;Creates an Amazon Redshift parameter group.&lt;/p&gt; &lt;p&gt;Creating parameter groups is independent of creating clusters. You can associate a cluster with a parameter group when you create the cluster. You can also associate an existing cluster with a parameter group after the cluster is created by using &lt;a&gt;ModifyCluster&lt;/a&gt;. &lt;/p&gt; &lt;p&gt;Parameters in the parameter group define specific behavior that applies to the databases you create on the cluster. For more information about parameters and parameter groups, go to &lt;a href&#x3D;\&quot;https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-parameter-groups.html\&quot;&gt;Amazon Redshift Parameter Groups&lt;/a&gt; in the &lt;i&gt;Amazon Redshift Cluster Management Guide&lt;/i&gt;.&lt;/p&gt;
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param createClusterParameterGroupMessage  (optional)
     * @return ApiResponse&lt;CreateClusterParameterGroupResult&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> ClusterParameterGroupQuotaExceededFault </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> ClusterParameterGroupAlreadyExistsFault </td><td>  -  </td></tr>
        <tr><td> 482 </td><td> TagLimitExceededFault </td><td>  -  </td></tr>
        <tr><td> 483 </td><td> InvalidTagFault </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<CreateClusterParameterGroupResult> pOSTCreateClusterParameterGroupWithHttpInfo(String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, CreateClusterParameterGroupMessage createClusterParameterGroupMessage) throws ApiException {
        okhttp3.Call localVarCall = pOSTCreateClusterParameterGroupValidateBeforeCall(action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, createClusterParameterGroupMessage, null);
        Type localVarReturnType = new TypeToken<CreateClusterParameterGroupResult>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     *  (asynchronously)
     * &lt;p&gt;Creates an Amazon Redshift parameter group.&lt;/p&gt; &lt;p&gt;Creating parameter groups is independent of creating clusters. You can associate a cluster with a parameter group when you create the cluster. You can also associate an existing cluster with a parameter group after the cluster is created by using &lt;a&gt;ModifyCluster&lt;/a&gt;. &lt;/p&gt; &lt;p&gt;Parameters in the parameter group define specific behavior that applies to the databases you create on the cluster. For more information about parameters and parameter groups, go to &lt;a href&#x3D;\&quot;https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-parameter-groups.html\&quot;&gt;Amazon Redshift Parameter Groups&lt;/a&gt; in the &lt;i&gt;Amazon Redshift Cluster Management Guide&lt;/i&gt;.&lt;/p&gt;
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param createClusterParameterGroupMessage  (optional)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> ClusterParameterGroupQuotaExceededFault </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> ClusterParameterGroupAlreadyExistsFault </td><td>  -  </td></tr>
        <tr><td> 482 </td><td> TagLimitExceededFault </td><td>  -  </td></tr>
        <tr><td> 483 </td><td> InvalidTagFault </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call pOSTCreateClusterParameterGroupAsync(String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, CreateClusterParameterGroupMessage createClusterParameterGroupMessage, final ApiCallback<CreateClusterParameterGroupResult> _callback) throws ApiException {

        okhttp3.Call localVarCall = pOSTCreateClusterParameterGroupValidateBeforeCall(action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, createClusterParameterGroupMessage, _callback);
        Type localVarReturnType = new TypeToken<CreateClusterParameterGroupResult>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for pOSTCreateClusterSecurityGroup
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param createClusterSecurityGroupMessage  (optional)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> ClusterSecurityGroupAlreadyExistsFault </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> ClusterSecurityGroupQuotaExceededFault </td><td>  -  </td></tr>
        <tr><td> 482 </td><td> TagLimitExceededFault </td><td>  -  </td></tr>
        <tr><td> 483 </td><td> InvalidTagFault </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call pOSTCreateClusterSecurityGroupCall(String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, CreateClusterSecurityGroupMessage createClusterSecurityGroupMessage, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = createClusterSecurityGroupMessage;

        // create path and map variables
        String localVarPath = "/#Action=CreateClusterSecurityGroup";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (action != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("Action", action));
        }

        if (version != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("Version", version));
        }

        if (xAmzContentSha256 != null) {
            localVarHeaderParams.put("X-Amz-Content-Sha256", localVarApiClient.parameterToString(xAmzContentSha256));
        }

        if (xAmzDate != null) {
            localVarHeaderParams.put("X-Amz-Date", localVarApiClient.parameterToString(xAmzDate));
        }

        if (xAmzAlgorithm != null) {
            localVarHeaderParams.put("X-Amz-Algorithm", localVarApiClient.parameterToString(xAmzAlgorithm));
        }

        if (xAmzCredential != null) {
            localVarHeaderParams.put("X-Amz-Credential", localVarApiClient.parameterToString(xAmzCredential));
        }

        if (xAmzSecurityToken != null) {
            localVarHeaderParams.put("X-Amz-Security-Token", localVarApiClient.parameterToString(xAmzSecurityToken));
        }

        if (xAmzSignature != null) {
            localVarHeaderParams.put("X-Amz-Signature", localVarApiClient.parameterToString(xAmzSignature));
        }

        if (xAmzSignedHeaders != null) {
            localVarHeaderParams.put("X-Amz-SignedHeaders", localVarApiClient.parameterToString(xAmzSignedHeaders));
        }

        final String[] localVarAccepts = {
            "text/xml"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            "text/xml"
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "hmac" };
        return localVarApiClient.buildCall(basePath, localVarPath, "POST", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call pOSTCreateClusterSecurityGroupValidateBeforeCall(String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, CreateClusterSecurityGroupMessage createClusterSecurityGroupMessage, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'action' is set
        if (action == null) {
            throw new ApiException("Missing the required parameter 'action' when calling pOSTCreateClusterSecurityGroup(Async)");
        }

        // verify the required parameter 'version' is set
        if (version == null) {
            throw new ApiException("Missing the required parameter 'version' when calling pOSTCreateClusterSecurityGroup(Async)");
        }

        return pOSTCreateClusterSecurityGroupCall(action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, createClusterSecurityGroupMessage, _callback);

    }

    /**
     * 
     * &lt;p&gt;Creates a new Amazon Redshift security group. You use security groups to control access to non-VPC clusters.&lt;/p&gt; &lt;p&gt; For information about managing security groups, go to &lt;a href&#x3D;\&quot;https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-security-groups.html\&quot;&gt;Amazon Redshift Cluster Security Groups&lt;/a&gt; in the &lt;i&gt;Amazon Redshift Cluster Management Guide&lt;/i&gt;.&lt;/p&gt;
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param createClusterSecurityGroupMessage  (optional)
     * @return CreateClusterSecurityGroupResult
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> ClusterSecurityGroupAlreadyExistsFault </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> ClusterSecurityGroupQuotaExceededFault </td><td>  -  </td></tr>
        <tr><td> 482 </td><td> TagLimitExceededFault </td><td>  -  </td></tr>
        <tr><td> 483 </td><td> InvalidTagFault </td><td>  -  </td></tr>
     </table>
     */
    public CreateClusterSecurityGroupResult pOSTCreateClusterSecurityGroup(String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, CreateClusterSecurityGroupMessage createClusterSecurityGroupMessage) throws ApiException {
        ApiResponse<CreateClusterSecurityGroupResult> localVarResp = pOSTCreateClusterSecurityGroupWithHttpInfo(action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, createClusterSecurityGroupMessage);
        return localVarResp.getData();
    }

    /**
     * 
     * &lt;p&gt;Creates a new Amazon Redshift security group. You use security groups to control access to non-VPC clusters.&lt;/p&gt; &lt;p&gt; For information about managing security groups, go to &lt;a href&#x3D;\&quot;https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-security-groups.html\&quot;&gt;Amazon Redshift Cluster Security Groups&lt;/a&gt; in the &lt;i&gt;Amazon Redshift Cluster Management Guide&lt;/i&gt;.&lt;/p&gt;
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param createClusterSecurityGroupMessage  (optional)
     * @return ApiResponse&lt;CreateClusterSecurityGroupResult&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> ClusterSecurityGroupAlreadyExistsFault </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> ClusterSecurityGroupQuotaExceededFault </td><td>  -  </td></tr>
        <tr><td> 482 </td><td> TagLimitExceededFault </td><td>  -  </td></tr>
        <tr><td> 483 </td><td> InvalidTagFault </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<CreateClusterSecurityGroupResult> pOSTCreateClusterSecurityGroupWithHttpInfo(String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, CreateClusterSecurityGroupMessage createClusterSecurityGroupMessage) throws ApiException {
        okhttp3.Call localVarCall = pOSTCreateClusterSecurityGroupValidateBeforeCall(action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, createClusterSecurityGroupMessage, null);
        Type localVarReturnType = new TypeToken<CreateClusterSecurityGroupResult>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     *  (asynchronously)
     * &lt;p&gt;Creates a new Amazon Redshift security group. You use security groups to control access to non-VPC clusters.&lt;/p&gt; &lt;p&gt; For information about managing security groups, go to &lt;a href&#x3D;\&quot;https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-security-groups.html\&quot;&gt;Amazon Redshift Cluster Security Groups&lt;/a&gt; in the &lt;i&gt;Amazon Redshift Cluster Management Guide&lt;/i&gt;.&lt;/p&gt;
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param createClusterSecurityGroupMessage  (optional)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> ClusterSecurityGroupAlreadyExistsFault </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> ClusterSecurityGroupQuotaExceededFault </td><td>  -  </td></tr>
        <tr><td> 482 </td><td> TagLimitExceededFault </td><td>  -  </td></tr>
        <tr><td> 483 </td><td> InvalidTagFault </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call pOSTCreateClusterSecurityGroupAsync(String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, CreateClusterSecurityGroupMessage createClusterSecurityGroupMessage, final ApiCallback<CreateClusterSecurityGroupResult> _callback) throws ApiException {

        okhttp3.Call localVarCall = pOSTCreateClusterSecurityGroupValidateBeforeCall(action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, createClusterSecurityGroupMessage, _callback);
        Type localVarReturnType = new TypeToken<CreateClusterSecurityGroupResult>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for pOSTCreateClusterSnapshot
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param createClusterSnapshotMessage  (optional)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> ClusterSnapshotAlreadyExistsFault </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> InvalidClusterStateFault </td><td>  -  </td></tr>
        <tr><td> 482 </td><td> ClusterNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 483 </td><td> ClusterSnapshotQuotaExceededFault </td><td>  -  </td></tr>
        <tr><td> 484 </td><td> TagLimitExceededFault </td><td>  -  </td></tr>
        <tr><td> 485 </td><td> InvalidTagFault </td><td>  -  </td></tr>
        <tr><td> 486 </td><td> InvalidRetentionPeriodFault </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call pOSTCreateClusterSnapshotCall(String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, CreateClusterSnapshotMessage createClusterSnapshotMessage, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = createClusterSnapshotMessage;

        // create path and map variables
        String localVarPath = "/#Action=CreateClusterSnapshot";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (action != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("Action", action));
        }

        if (version != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("Version", version));
        }

        if (xAmzContentSha256 != null) {
            localVarHeaderParams.put("X-Amz-Content-Sha256", localVarApiClient.parameterToString(xAmzContentSha256));
        }

        if (xAmzDate != null) {
            localVarHeaderParams.put("X-Amz-Date", localVarApiClient.parameterToString(xAmzDate));
        }

        if (xAmzAlgorithm != null) {
            localVarHeaderParams.put("X-Amz-Algorithm", localVarApiClient.parameterToString(xAmzAlgorithm));
        }

        if (xAmzCredential != null) {
            localVarHeaderParams.put("X-Amz-Credential", localVarApiClient.parameterToString(xAmzCredential));
        }

        if (xAmzSecurityToken != null) {
            localVarHeaderParams.put("X-Amz-Security-Token", localVarApiClient.parameterToString(xAmzSecurityToken));
        }

        if (xAmzSignature != null) {
            localVarHeaderParams.put("X-Amz-Signature", localVarApiClient.parameterToString(xAmzSignature));
        }

        if (xAmzSignedHeaders != null) {
            localVarHeaderParams.put("X-Amz-SignedHeaders", localVarApiClient.parameterToString(xAmzSignedHeaders));
        }

        final String[] localVarAccepts = {
            "text/xml"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            "text/xml"
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "hmac" };
        return localVarApiClient.buildCall(basePath, localVarPath, "POST", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call pOSTCreateClusterSnapshotValidateBeforeCall(String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, CreateClusterSnapshotMessage createClusterSnapshotMessage, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'action' is set
        if (action == null) {
            throw new ApiException("Missing the required parameter 'action' when calling pOSTCreateClusterSnapshot(Async)");
        }

        // verify the required parameter 'version' is set
        if (version == null) {
            throw new ApiException("Missing the required parameter 'version' when calling pOSTCreateClusterSnapshot(Async)");
        }

        return pOSTCreateClusterSnapshotCall(action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, createClusterSnapshotMessage, _callback);

    }

    /**
     * 
     * &lt;p&gt;Creates a manual snapshot of the specified cluster. The cluster must be in the &lt;code&gt;available&lt;/code&gt; state. &lt;/p&gt; &lt;p&gt; For more information about working with snapshots, go to &lt;a href&#x3D;\&quot;https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-snapshots.html\&quot;&gt;Amazon Redshift Snapshots&lt;/a&gt; in the &lt;i&gt;Amazon Redshift Cluster Management Guide&lt;/i&gt;.&lt;/p&gt;
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param createClusterSnapshotMessage  (optional)
     * @return CreateClusterSnapshotResult
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> ClusterSnapshotAlreadyExistsFault </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> InvalidClusterStateFault </td><td>  -  </td></tr>
        <tr><td> 482 </td><td> ClusterNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 483 </td><td> ClusterSnapshotQuotaExceededFault </td><td>  -  </td></tr>
        <tr><td> 484 </td><td> TagLimitExceededFault </td><td>  -  </td></tr>
        <tr><td> 485 </td><td> InvalidTagFault </td><td>  -  </td></tr>
        <tr><td> 486 </td><td> InvalidRetentionPeriodFault </td><td>  -  </td></tr>
     </table>
     */
    public CreateClusterSnapshotResult pOSTCreateClusterSnapshot(String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, CreateClusterSnapshotMessage createClusterSnapshotMessage) throws ApiException {
        ApiResponse<CreateClusterSnapshotResult> localVarResp = pOSTCreateClusterSnapshotWithHttpInfo(action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, createClusterSnapshotMessage);
        return localVarResp.getData();
    }

    /**
     * 
     * &lt;p&gt;Creates a manual snapshot of the specified cluster. The cluster must be in the &lt;code&gt;available&lt;/code&gt; state. &lt;/p&gt; &lt;p&gt; For more information about working with snapshots, go to &lt;a href&#x3D;\&quot;https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-snapshots.html\&quot;&gt;Amazon Redshift Snapshots&lt;/a&gt; in the &lt;i&gt;Amazon Redshift Cluster Management Guide&lt;/i&gt;.&lt;/p&gt;
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param createClusterSnapshotMessage  (optional)
     * @return ApiResponse&lt;CreateClusterSnapshotResult&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> ClusterSnapshotAlreadyExistsFault </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> InvalidClusterStateFault </td><td>  -  </td></tr>
        <tr><td> 482 </td><td> ClusterNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 483 </td><td> ClusterSnapshotQuotaExceededFault </td><td>  -  </td></tr>
        <tr><td> 484 </td><td> TagLimitExceededFault </td><td>  -  </td></tr>
        <tr><td> 485 </td><td> InvalidTagFault </td><td>  -  </td></tr>
        <tr><td> 486 </td><td> InvalidRetentionPeriodFault </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<CreateClusterSnapshotResult> pOSTCreateClusterSnapshotWithHttpInfo(String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, CreateClusterSnapshotMessage createClusterSnapshotMessage) throws ApiException {
        okhttp3.Call localVarCall = pOSTCreateClusterSnapshotValidateBeforeCall(action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, createClusterSnapshotMessage, null);
        Type localVarReturnType = new TypeToken<CreateClusterSnapshotResult>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     *  (asynchronously)
     * &lt;p&gt;Creates a manual snapshot of the specified cluster. The cluster must be in the &lt;code&gt;available&lt;/code&gt; state. &lt;/p&gt; &lt;p&gt; For more information about working with snapshots, go to &lt;a href&#x3D;\&quot;https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-snapshots.html\&quot;&gt;Amazon Redshift Snapshots&lt;/a&gt; in the &lt;i&gt;Amazon Redshift Cluster Management Guide&lt;/i&gt;.&lt;/p&gt;
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param createClusterSnapshotMessage  (optional)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> ClusterSnapshotAlreadyExistsFault </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> InvalidClusterStateFault </td><td>  -  </td></tr>
        <tr><td> 482 </td><td> ClusterNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 483 </td><td> ClusterSnapshotQuotaExceededFault </td><td>  -  </td></tr>
        <tr><td> 484 </td><td> TagLimitExceededFault </td><td>  -  </td></tr>
        <tr><td> 485 </td><td> InvalidTagFault </td><td>  -  </td></tr>
        <tr><td> 486 </td><td> InvalidRetentionPeriodFault </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call pOSTCreateClusterSnapshotAsync(String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, CreateClusterSnapshotMessage createClusterSnapshotMessage, final ApiCallback<CreateClusterSnapshotResult> _callback) throws ApiException {

        okhttp3.Call localVarCall = pOSTCreateClusterSnapshotValidateBeforeCall(action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, createClusterSnapshotMessage, _callback);
        Type localVarReturnType = new TypeToken<CreateClusterSnapshotResult>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for pOSTCreateClusterSubnetGroup
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param createClusterSubnetGroupMessage  (optional)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> ClusterSubnetGroupAlreadyExistsFault </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> ClusterSubnetGroupQuotaExceededFault </td><td>  -  </td></tr>
        <tr><td> 482 </td><td> ClusterSubnetQuotaExceededFault </td><td>  -  </td></tr>
        <tr><td> 483 </td><td> InvalidSubnet </td><td>  -  </td></tr>
        <tr><td> 484 </td><td> UnauthorizedOperation </td><td>  -  </td></tr>
        <tr><td> 485 </td><td> TagLimitExceededFault </td><td>  -  </td></tr>
        <tr><td> 486 </td><td> InvalidTagFault </td><td>  -  </td></tr>
        <tr><td> 487 </td><td> DependentServiceRequestThrottlingFault </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call pOSTCreateClusterSubnetGroupCall(String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, CreateClusterSubnetGroupMessage createClusterSubnetGroupMessage, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = createClusterSubnetGroupMessage;

        // create path and map variables
        String localVarPath = "/#Action=CreateClusterSubnetGroup";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (action != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("Action", action));
        }

        if (version != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("Version", version));
        }

        if (xAmzContentSha256 != null) {
            localVarHeaderParams.put("X-Amz-Content-Sha256", localVarApiClient.parameterToString(xAmzContentSha256));
        }

        if (xAmzDate != null) {
            localVarHeaderParams.put("X-Amz-Date", localVarApiClient.parameterToString(xAmzDate));
        }

        if (xAmzAlgorithm != null) {
            localVarHeaderParams.put("X-Amz-Algorithm", localVarApiClient.parameterToString(xAmzAlgorithm));
        }

        if (xAmzCredential != null) {
            localVarHeaderParams.put("X-Amz-Credential", localVarApiClient.parameterToString(xAmzCredential));
        }

        if (xAmzSecurityToken != null) {
            localVarHeaderParams.put("X-Amz-Security-Token", localVarApiClient.parameterToString(xAmzSecurityToken));
        }

        if (xAmzSignature != null) {
            localVarHeaderParams.put("X-Amz-Signature", localVarApiClient.parameterToString(xAmzSignature));
        }

        if (xAmzSignedHeaders != null) {
            localVarHeaderParams.put("X-Amz-SignedHeaders", localVarApiClient.parameterToString(xAmzSignedHeaders));
        }

        final String[] localVarAccepts = {
            "text/xml"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            "text/xml"
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "hmac" };
        return localVarApiClient.buildCall(basePath, localVarPath, "POST", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call pOSTCreateClusterSubnetGroupValidateBeforeCall(String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, CreateClusterSubnetGroupMessage createClusterSubnetGroupMessage, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'action' is set
        if (action == null) {
            throw new ApiException("Missing the required parameter 'action' when calling pOSTCreateClusterSubnetGroup(Async)");
        }

        // verify the required parameter 'version' is set
        if (version == null) {
            throw new ApiException("Missing the required parameter 'version' when calling pOSTCreateClusterSubnetGroup(Async)");
        }

        return pOSTCreateClusterSubnetGroupCall(action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, createClusterSubnetGroupMessage, _callback);

    }

    /**
     * 
     * &lt;p&gt;Creates a new Amazon Redshift subnet group. You must provide a list of one or more subnets in your existing Amazon Virtual Private Cloud (Amazon VPC) when creating Amazon Redshift subnet group.&lt;/p&gt; &lt;p&gt; For information about subnet groups, go to &lt;a href&#x3D;\&quot;https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-cluster-subnet-groups.html\&quot;&gt;Amazon Redshift Cluster Subnet Groups&lt;/a&gt; in the &lt;i&gt;Amazon Redshift Cluster Management Guide&lt;/i&gt;.&lt;/p&gt;
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param createClusterSubnetGroupMessage  (optional)
     * @return CreateClusterSubnetGroupResult
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> ClusterSubnetGroupAlreadyExistsFault </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> ClusterSubnetGroupQuotaExceededFault </td><td>  -  </td></tr>
        <tr><td> 482 </td><td> ClusterSubnetQuotaExceededFault </td><td>  -  </td></tr>
        <tr><td> 483 </td><td> InvalidSubnet </td><td>  -  </td></tr>
        <tr><td> 484 </td><td> UnauthorizedOperation </td><td>  -  </td></tr>
        <tr><td> 485 </td><td> TagLimitExceededFault </td><td>  -  </td></tr>
        <tr><td> 486 </td><td> InvalidTagFault </td><td>  -  </td></tr>
        <tr><td> 487 </td><td> DependentServiceRequestThrottlingFault </td><td>  -  </td></tr>
     </table>
     */
    public CreateClusterSubnetGroupResult pOSTCreateClusterSubnetGroup(String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, CreateClusterSubnetGroupMessage createClusterSubnetGroupMessage) throws ApiException {
        ApiResponse<CreateClusterSubnetGroupResult> localVarResp = pOSTCreateClusterSubnetGroupWithHttpInfo(action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, createClusterSubnetGroupMessage);
        return localVarResp.getData();
    }

    /**
     * 
     * &lt;p&gt;Creates a new Amazon Redshift subnet group. You must provide a list of one or more subnets in your existing Amazon Virtual Private Cloud (Amazon VPC) when creating Amazon Redshift subnet group.&lt;/p&gt; &lt;p&gt; For information about subnet groups, go to &lt;a href&#x3D;\&quot;https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-cluster-subnet-groups.html\&quot;&gt;Amazon Redshift Cluster Subnet Groups&lt;/a&gt; in the &lt;i&gt;Amazon Redshift Cluster Management Guide&lt;/i&gt;.&lt;/p&gt;
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param createClusterSubnetGroupMessage  (optional)
     * @return ApiResponse&lt;CreateClusterSubnetGroupResult&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> ClusterSubnetGroupAlreadyExistsFault </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> ClusterSubnetGroupQuotaExceededFault </td><td>  -  </td></tr>
        <tr><td> 482 </td><td> ClusterSubnetQuotaExceededFault </td><td>  -  </td></tr>
        <tr><td> 483 </td><td> InvalidSubnet </td><td>  -  </td></tr>
        <tr><td> 484 </td><td> UnauthorizedOperation </td><td>  -  </td></tr>
        <tr><td> 485 </td><td> TagLimitExceededFault </td><td>  -  </td></tr>
        <tr><td> 486 </td><td> InvalidTagFault </td><td>  -  </td></tr>
        <tr><td> 487 </td><td> DependentServiceRequestThrottlingFault </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<CreateClusterSubnetGroupResult> pOSTCreateClusterSubnetGroupWithHttpInfo(String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, CreateClusterSubnetGroupMessage createClusterSubnetGroupMessage) throws ApiException {
        okhttp3.Call localVarCall = pOSTCreateClusterSubnetGroupValidateBeforeCall(action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, createClusterSubnetGroupMessage, null);
        Type localVarReturnType = new TypeToken<CreateClusterSubnetGroupResult>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     *  (asynchronously)
     * &lt;p&gt;Creates a new Amazon Redshift subnet group. You must provide a list of one or more subnets in your existing Amazon Virtual Private Cloud (Amazon VPC) when creating Amazon Redshift subnet group.&lt;/p&gt; &lt;p&gt; For information about subnet groups, go to &lt;a href&#x3D;\&quot;https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-cluster-subnet-groups.html\&quot;&gt;Amazon Redshift Cluster Subnet Groups&lt;/a&gt; in the &lt;i&gt;Amazon Redshift Cluster Management Guide&lt;/i&gt;.&lt;/p&gt;
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param createClusterSubnetGroupMessage  (optional)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> ClusterSubnetGroupAlreadyExistsFault </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> ClusterSubnetGroupQuotaExceededFault </td><td>  -  </td></tr>
        <tr><td> 482 </td><td> ClusterSubnetQuotaExceededFault </td><td>  -  </td></tr>
        <tr><td> 483 </td><td> InvalidSubnet </td><td>  -  </td></tr>
        <tr><td> 484 </td><td> UnauthorizedOperation </td><td>  -  </td></tr>
        <tr><td> 485 </td><td> TagLimitExceededFault </td><td>  -  </td></tr>
        <tr><td> 486 </td><td> InvalidTagFault </td><td>  -  </td></tr>
        <tr><td> 487 </td><td> DependentServiceRequestThrottlingFault </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call pOSTCreateClusterSubnetGroupAsync(String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, CreateClusterSubnetGroupMessage createClusterSubnetGroupMessage, final ApiCallback<CreateClusterSubnetGroupResult> _callback) throws ApiException {

        okhttp3.Call localVarCall = pOSTCreateClusterSubnetGroupValidateBeforeCall(action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, createClusterSubnetGroupMessage, _callback);
        Type localVarReturnType = new TypeToken<CreateClusterSubnetGroupResult>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for pOSTCreateCustomDomainAssociation
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param createCustomDomainAssociationMessage  (optional)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> UnsupportedOperationFault </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> ClusterNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 482 </td><td> CustomCnameAssociationFault </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call pOSTCreateCustomDomainAssociationCall(String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, CreateCustomDomainAssociationMessage createCustomDomainAssociationMessage, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = createCustomDomainAssociationMessage;

        // create path and map variables
        String localVarPath = "/#Action=CreateCustomDomainAssociation";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (action != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("Action", action));
        }

        if (version != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("Version", version));
        }

        if (xAmzContentSha256 != null) {
            localVarHeaderParams.put("X-Amz-Content-Sha256", localVarApiClient.parameterToString(xAmzContentSha256));
        }

        if (xAmzDate != null) {
            localVarHeaderParams.put("X-Amz-Date", localVarApiClient.parameterToString(xAmzDate));
        }

        if (xAmzAlgorithm != null) {
            localVarHeaderParams.put("X-Amz-Algorithm", localVarApiClient.parameterToString(xAmzAlgorithm));
        }

        if (xAmzCredential != null) {
            localVarHeaderParams.put("X-Amz-Credential", localVarApiClient.parameterToString(xAmzCredential));
        }

        if (xAmzSecurityToken != null) {
            localVarHeaderParams.put("X-Amz-Security-Token", localVarApiClient.parameterToString(xAmzSecurityToken));
        }

        if (xAmzSignature != null) {
            localVarHeaderParams.put("X-Amz-Signature", localVarApiClient.parameterToString(xAmzSignature));
        }

        if (xAmzSignedHeaders != null) {
            localVarHeaderParams.put("X-Amz-SignedHeaders", localVarApiClient.parameterToString(xAmzSignedHeaders));
        }

        final String[] localVarAccepts = {
            "text/xml"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            "text/xml"
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "hmac" };
        return localVarApiClient.buildCall(basePath, localVarPath, "POST", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call pOSTCreateCustomDomainAssociationValidateBeforeCall(String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, CreateCustomDomainAssociationMessage createCustomDomainAssociationMessage, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'action' is set
        if (action == null) {
            throw new ApiException("Missing the required parameter 'action' when calling pOSTCreateCustomDomainAssociation(Async)");
        }

        // verify the required parameter 'version' is set
        if (version == null) {
            throw new ApiException("Missing the required parameter 'version' when calling pOSTCreateCustomDomainAssociation(Async)");
        }

        return pOSTCreateCustomDomainAssociationCall(action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, createCustomDomainAssociationMessage, _callback);

    }

    /**
     * 
     * Used to create a custom domain name for a cluster. Properties include the custom domain name, the cluster the custom domain is associated with, and the certificate Amazon Resource Name (ARN).
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param createCustomDomainAssociationMessage  (optional)
     * @return CreateCustomDomainAssociationResult
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> UnsupportedOperationFault </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> ClusterNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 482 </td><td> CustomCnameAssociationFault </td><td>  -  </td></tr>
     </table>
     */
    public CreateCustomDomainAssociationResult pOSTCreateCustomDomainAssociation(String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, CreateCustomDomainAssociationMessage createCustomDomainAssociationMessage) throws ApiException {
        ApiResponse<CreateCustomDomainAssociationResult> localVarResp = pOSTCreateCustomDomainAssociationWithHttpInfo(action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, createCustomDomainAssociationMessage);
        return localVarResp.getData();
    }

    /**
     * 
     * Used to create a custom domain name for a cluster. Properties include the custom domain name, the cluster the custom domain is associated with, and the certificate Amazon Resource Name (ARN).
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param createCustomDomainAssociationMessage  (optional)
     * @return ApiResponse&lt;CreateCustomDomainAssociationResult&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> UnsupportedOperationFault </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> ClusterNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 482 </td><td> CustomCnameAssociationFault </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<CreateCustomDomainAssociationResult> pOSTCreateCustomDomainAssociationWithHttpInfo(String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, CreateCustomDomainAssociationMessage createCustomDomainAssociationMessage) throws ApiException {
        okhttp3.Call localVarCall = pOSTCreateCustomDomainAssociationValidateBeforeCall(action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, createCustomDomainAssociationMessage, null);
        Type localVarReturnType = new TypeToken<CreateCustomDomainAssociationResult>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     *  (asynchronously)
     * Used to create a custom domain name for a cluster. Properties include the custom domain name, the cluster the custom domain is associated with, and the certificate Amazon Resource Name (ARN).
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param createCustomDomainAssociationMessage  (optional)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> UnsupportedOperationFault </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> ClusterNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 482 </td><td> CustomCnameAssociationFault </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call pOSTCreateCustomDomainAssociationAsync(String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, CreateCustomDomainAssociationMessage createCustomDomainAssociationMessage, final ApiCallback<CreateCustomDomainAssociationResult> _callback) throws ApiException {

        okhttp3.Call localVarCall = pOSTCreateCustomDomainAssociationValidateBeforeCall(action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, createCustomDomainAssociationMessage, _callback);
        Type localVarReturnType = new TypeToken<CreateCustomDomainAssociationResult>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for pOSTCreateEndpointAccess
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param createEndpointAccessMessage  (optional)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> ClusterNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> AccessToClusterDeniedFault </td><td>  -  </td></tr>
        <tr><td> 482 </td><td> EndpointsPerClusterLimitExceededFault </td><td>  -  </td></tr>
        <tr><td> 483 </td><td> EndpointsPerAuthorizationLimitExceededFault </td><td>  -  </td></tr>
        <tr><td> 484 </td><td> InvalidClusterSecurityGroupStateFault </td><td>  -  </td></tr>
        <tr><td> 485 </td><td> ClusterSubnetGroupNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 486 </td><td> EndpointAlreadyExistsFault </td><td>  -  </td></tr>
        <tr><td> 487 </td><td> UnsupportedOperationFault </td><td>  -  </td></tr>
        <tr><td> 488 </td><td> InvalidClusterStateFault </td><td>  -  </td></tr>
        <tr><td> 489 </td><td> UnauthorizedOperation </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call pOSTCreateEndpointAccessCall(String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, CreateEndpointAccessMessage createEndpointAccessMessage, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = createEndpointAccessMessage;

        // create path and map variables
        String localVarPath = "/#Action=CreateEndpointAccess";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (action != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("Action", action));
        }

        if (version != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("Version", version));
        }

        if (xAmzContentSha256 != null) {
            localVarHeaderParams.put("X-Amz-Content-Sha256", localVarApiClient.parameterToString(xAmzContentSha256));
        }

        if (xAmzDate != null) {
            localVarHeaderParams.put("X-Amz-Date", localVarApiClient.parameterToString(xAmzDate));
        }

        if (xAmzAlgorithm != null) {
            localVarHeaderParams.put("X-Amz-Algorithm", localVarApiClient.parameterToString(xAmzAlgorithm));
        }

        if (xAmzCredential != null) {
            localVarHeaderParams.put("X-Amz-Credential", localVarApiClient.parameterToString(xAmzCredential));
        }

        if (xAmzSecurityToken != null) {
            localVarHeaderParams.put("X-Amz-Security-Token", localVarApiClient.parameterToString(xAmzSecurityToken));
        }

        if (xAmzSignature != null) {
            localVarHeaderParams.put("X-Amz-Signature", localVarApiClient.parameterToString(xAmzSignature));
        }

        if (xAmzSignedHeaders != null) {
            localVarHeaderParams.put("X-Amz-SignedHeaders", localVarApiClient.parameterToString(xAmzSignedHeaders));
        }

        final String[] localVarAccepts = {
            "text/xml"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            "text/xml"
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "hmac" };
        return localVarApiClient.buildCall(basePath, localVarPath, "POST", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call pOSTCreateEndpointAccessValidateBeforeCall(String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, CreateEndpointAccessMessage createEndpointAccessMessage, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'action' is set
        if (action == null) {
            throw new ApiException("Missing the required parameter 'action' when calling pOSTCreateEndpointAccess(Async)");
        }

        // verify the required parameter 'version' is set
        if (version == null) {
            throw new ApiException("Missing the required parameter 'version' when calling pOSTCreateEndpointAccess(Async)");
        }

        return pOSTCreateEndpointAccessCall(action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, createEndpointAccessMessage, _callback);

    }

    /**
     * 
     * Creates a Redshift-managed VPC endpoint.
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param createEndpointAccessMessage  (optional)
     * @return EndpointAccess
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> ClusterNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> AccessToClusterDeniedFault </td><td>  -  </td></tr>
        <tr><td> 482 </td><td> EndpointsPerClusterLimitExceededFault </td><td>  -  </td></tr>
        <tr><td> 483 </td><td> EndpointsPerAuthorizationLimitExceededFault </td><td>  -  </td></tr>
        <tr><td> 484 </td><td> InvalidClusterSecurityGroupStateFault </td><td>  -  </td></tr>
        <tr><td> 485 </td><td> ClusterSubnetGroupNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 486 </td><td> EndpointAlreadyExistsFault </td><td>  -  </td></tr>
        <tr><td> 487 </td><td> UnsupportedOperationFault </td><td>  -  </td></tr>
        <tr><td> 488 </td><td> InvalidClusterStateFault </td><td>  -  </td></tr>
        <tr><td> 489 </td><td> UnauthorizedOperation </td><td>  -  </td></tr>
     </table>
     */
    public EndpointAccess pOSTCreateEndpointAccess(String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, CreateEndpointAccessMessage createEndpointAccessMessage) throws ApiException {
        ApiResponse<EndpointAccess> localVarResp = pOSTCreateEndpointAccessWithHttpInfo(action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, createEndpointAccessMessage);
        return localVarResp.getData();
    }

    /**
     * 
     * Creates a Redshift-managed VPC endpoint.
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param createEndpointAccessMessage  (optional)
     * @return ApiResponse&lt;EndpointAccess&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> ClusterNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> AccessToClusterDeniedFault </td><td>  -  </td></tr>
        <tr><td> 482 </td><td> EndpointsPerClusterLimitExceededFault </td><td>  -  </td></tr>
        <tr><td> 483 </td><td> EndpointsPerAuthorizationLimitExceededFault </td><td>  -  </td></tr>
        <tr><td> 484 </td><td> InvalidClusterSecurityGroupStateFault </td><td>  -  </td></tr>
        <tr><td> 485 </td><td> ClusterSubnetGroupNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 486 </td><td> EndpointAlreadyExistsFault </td><td>  -  </td></tr>
        <tr><td> 487 </td><td> UnsupportedOperationFault </td><td>  -  </td></tr>
        <tr><td> 488 </td><td> InvalidClusterStateFault </td><td>  -  </td></tr>
        <tr><td> 489 </td><td> UnauthorizedOperation </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<EndpointAccess> pOSTCreateEndpointAccessWithHttpInfo(String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, CreateEndpointAccessMessage createEndpointAccessMessage) throws ApiException {
        okhttp3.Call localVarCall = pOSTCreateEndpointAccessValidateBeforeCall(action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, createEndpointAccessMessage, null);
        Type localVarReturnType = new TypeToken<EndpointAccess>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     *  (asynchronously)
     * Creates a Redshift-managed VPC endpoint.
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param createEndpointAccessMessage  (optional)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> ClusterNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> AccessToClusterDeniedFault </td><td>  -  </td></tr>
        <tr><td> 482 </td><td> EndpointsPerClusterLimitExceededFault </td><td>  -  </td></tr>
        <tr><td> 483 </td><td> EndpointsPerAuthorizationLimitExceededFault </td><td>  -  </td></tr>
        <tr><td> 484 </td><td> InvalidClusterSecurityGroupStateFault </td><td>  -  </td></tr>
        <tr><td> 485 </td><td> ClusterSubnetGroupNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 486 </td><td> EndpointAlreadyExistsFault </td><td>  -  </td></tr>
        <tr><td> 487 </td><td> UnsupportedOperationFault </td><td>  -  </td></tr>
        <tr><td> 488 </td><td> InvalidClusterStateFault </td><td>  -  </td></tr>
        <tr><td> 489 </td><td> UnauthorizedOperation </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call pOSTCreateEndpointAccessAsync(String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, CreateEndpointAccessMessage createEndpointAccessMessage, final ApiCallback<EndpointAccess> _callback) throws ApiException {

        okhttp3.Call localVarCall = pOSTCreateEndpointAccessValidateBeforeCall(action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, createEndpointAccessMessage, _callback);
        Type localVarReturnType = new TypeToken<EndpointAccess>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for pOSTCreateEventSubscription
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param createEventSubscriptionMessage  (optional)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> EventSubscriptionQuotaExceededFault </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> SubscriptionAlreadyExistFault </td><td>  -  </td></tr>
        <tr><td> 482 </td><td> SNSInvalidTopicFault </td><td>  -  </td></tr>
        <tr><td> 483 </td><td> SNSNoAuthorizationFault </td><td>  -  </td></tr>
        <tr><td> 484 </td><td> SNSTopicArnNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 485 </td><td> SubscriptionEventIdNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 486 </td><td> SubscriptionCategoryNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 487 </td><td> SubscriptionSeverityNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 488 </td><td> SourceNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 489 </td><td> TagLimitExceededFault </td><td>  -  </td></tr>
        <tr><td> 490 </td><td> InvalidTagFault </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call pOSTCreateEventSubscriptionCall(String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, CreateEventSubscriptionMessage createEventSubscriptionMessage, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = createEventSubscriptionMessage;

        // create path and map variables
        String localVarPath = "/#Action=CreateEventSubscription";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (action != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("Action", action));
        }

        if (version != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("Version", version));
        }

        if (xAmzContentSha256 != null) {
            localVarHeaderParams.put("X-Amz-Content-Sha256", localVarApiClient.parameterToString(xAmzContentSha256));
        }

        if (xAmzDate != null) {
            localVarHeaderParams.put("X-Amz-Date", localVarApiClient.parameterToString(xAmzDate));
        }

        if (xAmzAlgorithm != null) {
            localVarHeaderParams.put("X-Amz-Algorithm", localVarApiClient.parameterToString(xAmzAlgorithm));
        }

        if (xAmzCredential != null) {
            localVarHeaderParams.put("X-Amz-Credential", localVarApiClient.parameterToString(xAmzCredential));
        }

        if (xAmzSecurityToken != null) {
            localVarHeaderParams.put("X-Amz-Security-Token", localVarApiClient.parameterToString(xAmzSecurityToken));
        }

        if (xAmzSignature != null) {
            localVarHeaderParams.put("X-Amz-Signature", localVarApiClient.parameterToString(xAmzSignature));
        }

        if (xAmzSignedHeaders != null) {
            localVarHeaderParams.put("X-Amz-SignedHeaders", localVarApiClient.parameterToString(xAmzSignedHeaders));
        }

        final String[] localVarAccepts = {
            "text/xml"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            "text/xml"
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "hmac" };
        return localVarApiClient.buildCall(basePath, localVarPath, "POST", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call pOSTCreateEventSubscriptionValidateBeforeCall(String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, CreateEventSubscriptionMessage createEventSubscriptionMessage, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'action' is set
        if (action == null) {
            throw new ApiException("Missing the required parameter 'action' when calling pOSTCreateEventSubscription(Async)");
        }

        // verify the required parameter 'version' is set
        if (version == null) {
            throw new ApiException("Missing the required parameter 'version' when calling pOSTCreateEventSubscription(Async)");
        }

        return pOSTCreateEventSubscriptionCall(action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, createEventSubscriptionMessage, _callback);

    }

    /**
     * 
     * &lt;p&gt;Creates an Amazon Redshift event notification subscription. This action requires an ARN (Amazon Resource Name) of an Amazon SNS topic created by either the Amazon Redshift console, the Amazon SNS console, or the Amazon SNS API. To obtain an ARN with Amazon SNS, you must create a topic in Amazon SNS and subscribe to the topic. The ARN is displayed in the SNS console.&lt;/p&gt; &lt;p&gt;You can specify the source type, and lists of Amazon Redshift source IDs, event categories, and event severities. Notifications will be sent for all events you want that match those criteria. For example, you can specify source type &#x3D; cluster, source ID &#x3D; my-cluster-1 and mycluster2, event categories &#x3D; Availability, Backup, and severity &#x3D; ERROR. The subscription will only send notifications for those ERROR events in the Availability and Backup categories for the specified clusters.&lt;/p&gt; &lt;p&gt;If you specify both the source type and source IDs, such as source type &#x3D; cluster and source identifier &#x3D; my-cluster-1, notifications will be sent for all the cluster events for my-cluster-1. If you specify a source type but do not specify a source identifier, you will receive notice of the events for the objects of that type in your Amazon Web Services account. If you do not specify either the SourceType nor the SourceIdentifier, you will be notified of events generated from all Amazon Redshift sources belonging to your Amazon Web Services account. You must specify a source type if you specify a source ID.&lt;/p&gt;
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param createEventSubscriptionMessage  (optional)
     * @return CreateEventSubscriptionResult
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> EventSubscriptionQuotaExceededFault </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> SubscriptionAlreadyExistFault </td><td>  -  </td></tr>
        <tr><td> 482 </td><td> SNSInvalidTopicFault </td><td>  -  </td></tr>
        <tr><td> 483 </td><td> SNSNoAuthorizationFault </td><td>  -  </td></tr>
        <tr><td> 484 </td><td> SNSTopicArnNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 485 </td><td> SubscriptionEventIdNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 486 </td><td> SubscriptionCategoryNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 487 </td><td> SubscriptionSeverityNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 488 </td><td> SourceNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 489 </td><td> TagLimitExceededFault </td><td>  -  </td></tr>
        <tr><td> 490 </td><td> InvalidTagFault </td><td>  -  </td></tr>
     </table>
     */
    public CreateEventSubscriptionResult pOSTCreateEventSubscription(String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, CreateEventSubscriptionMessage createEventSubscriptionMessage) throws ApiException {
        ApiResponse<CreateEventSubscriptionResult> localVarResp = pOSTCreateEventSubscriptionWithHttpInfo(action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, createEventSubscriptionMessage);
        return localVarResp.getData();
    }

    /**
     * 
     * &lt;p&gt;Creates an Amazon Redshift event notification subscription. This action requires an ARN (Amazon Resource Name) of an Amazon SNS topic created by either the Amazon Redshift console, the Amazon SNS console, or the Amazon SNS API. To obtain an ARN with Amazon SNS, you must create a topic in Amazon SNS and subscribe to the topic. The ARN is displayed in the SNS console.&lt;/p&gt; &lt;p&gt;You can specify the source type, and lists of Amazon Redshift source IDs, event categories, and event severities. Notifications will be sent for all events you want that match those criteria. For example, you can specify source type &#x3D; cluster, source ID &#x3D; my-cluster-1 and mycluster2, event categories &#x3D; Availability, Backup, and severity &#x3D; ERROR. The subscription will only send notifications for those ERROR events in the Availability and Backup categories for the specified clusters.&lt;/p&gt; &lt;p&gt;If you specify both the source type and source IDs, such as source type &#x3D; cluster and source identifier &#x3D; my-cluster-1, notifications will be sent for all the cluster events for my-cluster-1. If you specify a source type but do not specify a source identifier, you will receive notice of the events for the objects of that type in your Amazon Web Services account. If you do not specify either the SourceType nor the SourceIdentifier, you will be notified of events generated from all Amazon Redshift sources belonging to your Amazon Web Services account. You must specify a source type if you specify a source ID.&lt;/p&gt;
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param createEventSubscriptionMessage  (optional)
     * @return ApiResponse&lt;CreateEventSubscriptionResult&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> EventSubscriptionQuotaExceededFault </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> SubscriptionAlreadyExistFault </td><td>  -  </td></tr>
        <tr><td> 482 </td><td> SNSInvalidTopicFault </td><td>  -  </td></tr>
        <tr><td> 483 </td><td> SNSNoAuthorizationFault </td><td>  -  </td></tr>
        <tr><td> 484 </td><td> SNSTopicArnNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 485 </td><td> SubscriptionEventIdNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 486 </td><td> SubscriptionCategoryNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 487 </td><td> SubscriptionSeverityNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 488 </td><td> SourceNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 489 </td><td> TagLimitExceededFault </td><td>  -  </td></tr>
        <tr><td> 490 </td><td> InvalidTagFault </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<CreateEventSubscriptionResult> pOSTCreateEventSubscriptionWithHttpInfo(String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, CreateEventSubscriptionMessage createEventSubscriptionMessage) throws ApiException {
        okhttp3.Call localVarCall = pOSTCreateEventSubscriptionValidateBeforeCall(action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, createEventSubscriptionMessage, null);
        Type localVarReturnType = new TypeToken<CreateEventSubscriptionResult>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     *  (asynchronously)
     * &lt;p&gt;Creates an Amazon Redshift event notification subscription. This action requires an ARN (Amazon Resource Name) of an Amazon SNS topic created by either the Amazon Redshift console, the Amazon SNS console, or the Amazon SNS API. To obtain an ARN with Amazon SNS, you must create a topic in Amazon SNS and subscribe to the topic. The ARN is displayed in the SNS console.&lt;/p&gt; &lt;p&gt;You can specify the source type, and lists of Amazon Redshift source IDs, event categories, and event severities. Notifications will be sent for all events you want that match those criteria. For example, you can specify source type &#x3D; cluster, source ID &#x3D; my-cluster-1 and mycluster2, event categories &#x3D; Availability, Backup, and severity &#x3D; ERROR. The subscription will only send notifications for those ERROR events in the Availability and Backup categories for the specified clusters.&lt;/p&gt; &lt;p&gt;If you specify both the source type and source IDs, such as source type &#x3D; cluster and source identifier &#x3D; my-cluster-1, notifications will be sent for all the cluster events for my-cluster-1. If you specify a source type but do not specify a source identifier, you will receive notice of the events for the objects of that type in your Amazon Web Services account. If you do not specify either the SourceType nor the SourceIdentifier, you will be notified of events generated from all Amazon Redshift sources belonging to your Amazon Web Services account. You must specify a source type if you specify a source ID.&lt;/p&gt;
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param createEventSubscriptionMessage  (optional)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> EventSubscriptionQuotaExceededFault </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> SubscriptionAlreadyExistFault </td><td>  -  </td></tr>
        <tr><td> 482 </td><td> SNSInvalidTopicFault </td><td>  -  </td></tr>
        <tr><td> 483 </td><td> SNSNoAuthorizationFault </td><td>  -  </td></tr>
        <tr><td> 484 </td><td> SNSTopicArnNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 485 </td><td> SubscriptionEventIdNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 486 </td><td> SubscriptionCategoryNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 487 </td><td> SubscriptionSeverityNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 488 </td><td> SourceNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 489 </td><td> TagLimitExceededFault </td><td>  -  </td></tr>
        <tr><td> 490 </td><td> InvalidTagFault </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call pOSTCreateEventSubscriptionAsync(String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, CreateEventSubscriptionMessage createEventSubscriptionMessage, final ApiCallback<CreateEventSubscriptionResult> _callback) throws ApiException {

        okhttp3.Call localVarCall = pOSTCreateEventSubscriptionValidateBeforeCall(action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, createEventSubscriptionMessage, _callback);
        Type localVarReturnType = new TypeToken<CreateEventSubscriptionResult>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for pOSTCreateHsmClientCertificate
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param createHsmClientCertificateMessage  (optional)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> HsmClientCertificateAlreadyExistsFault </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> HsmClientCertificateQuotaExceededFault </td><td>  -  </td></tr>
        <tr><td> 482 </td><td> TagLimitExceededFault </td><td>  -  </td></tr>
        <tr><td> 483 </td><td> InvalidTagFault </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call pOSTCreateHsmClientCertificateCall(String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, CreateHsmClientCertificateMessage createHsmClientCertificateMessage, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = createHsmClientCertificateMessage;

        // create path and map variables
        String localVarPath = "/#Action=CreateHsmClientCertificate";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (action != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("Action", action));
        }

        if (version != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("Version", version));
        }

        if (xAmzContentSha256 != null) {
            localVarHeaderParams.put("X-Amz-Content-Sha256", localVarApiClient.parameterToString(xAmzContentSha256));
        }

        if (xAmzDate != null) {
            localVarHeaderParams.put("X-Amz-Date", localVarApiClient.parameterToString(xAmzDate));
        }

        if (xAmzAlgorithm != null) {
            localVarHeaderParams.put("X-Amz-Algorithm", localVarApiClient.parameterToString(xAmzAlgorithm));
        }

        if (xAmzCredential != null) {
            localVarHeaderParams.put("X-Amz-Credential", localVarApiClient.parameterToString(xAmzCredential));
        }

        if (xAmzSecurityToken != null) {
            localVarHeaderParams.put("X-Amz-Security-Token", localVarApiClient.parameterToString(xAmzSecurityToken));
        }

        if (xAmzSignature != null) {
            localVarHeaderParams.put("X-Amz-Signature", localVarApiClient.parameterToString(xAmzSignature));
        }

        if (xAmzSignedHeaders != null) {
            localVarHeaderParams.put("X-Amz-SignedHeaders", localVarApiClient.parameterToString(xAmzSignedHeaders));
        }

        final String[] localVarAccepts = {
            "text/xml"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            "text/xml"
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "hmac" };
        return localVarApiClient.buildCall(basePath, localVarPath, "POST", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call pOSTCreateHsmClientCertificateValidateBeforeCall(String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, CreateHsmClientCertificateMessage createHsmClientCertificateMessage, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'action' is set
        if (action == null) {
            throw new ApiException("Missing the required parameter 'action' when calling pOSTCreateHsmClientCertificate(Async)");
        }

        // verify the required parameter 'version' is set
        if (version == null) {
            throw new ApiException("Missing the required parameter 'version' when calling pOSTCreateHsmClientCertificate(Async)");
        }

        return pOSTCreateHsmClientCertificateCall(action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, createHsmClientCertificateMessage, _callback);

    }

    /**
     * 
     * &lt;p&gt;Creates an HSM client certificate that an Amazon Redshift cluster will use to connect to the client&#39;s HSM in order to store and retrieve the keys used to encrypt the cluster databases.&lt;/p&gt; &lt;p&gt;The command returns a public key, which you must store in the HSM. In addition to creating the HSM certificate, you must create an Amazon Redshift HSM configuration that provides a cluster the information needed to store and use encryption keys in the HSM. For more information, go to &lt;a href&#x3D;\&quot;https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-db-encryption.html#working-with-HSM\&quot;&gt;Hardware Security Modules&lt;/a&gt; in the &lt;i&gt;Amazon Redshift Cluster Management Guide&lt;/i&gt;.&lt;/p&gt;
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param createHsmClientCertificateMessage  (optional)
     * @return CreateHsmClientCertificateResult
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> HsmClientCertificateAlreadyExistsFault </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> HsmClientCertificateQuotaExceededFault </td><td>  -  </td></tr>
        <tr><td> 482 </td><td> TagLimitExceededFault </td><td>  -  </td></tr>
        <tr><td> 483 </td><td> InvalidTagFault </td><td>  -  </td></tr>
     </table>
     */
    public CreateHsmClientCertificateResult pOSTCreateHsmClientCertificate(String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, CreateHsmClientCertificateMessage createHsmClientCertificateMessage) throws ApiException {
        ApiResponse<CreateHsmClientCertificateResult> localVarResp = pOSTCreateHsmClientCertificateWithHttpInfo(action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, createHsmClientCertificateMessage);
        return localVarResp.getData();
    }

    /**
     * 
     * &lt;p&gt;Creates an HSM client certificate that an Amazon Redshift cluster will use to connect to the client&#39;s HSM in order to store and retrieve the keys used to encrypt the cluster databases.&lt;/p&gt; &lt;p&gt;The command returns a public key, which you must store in the HSM. In addition to creating the HSM certificate, you must create an Amazon Redshift HSM configuration that provides a cluster the information needed to store and use encryption keys in the HSM. For more information, go to &lt;a href&#x3D;\&quot;https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-db-encryption.html#working-with-HSM\&quot;&gt;Hardware Security Modules&lt;/a&gt; in the &lt;i&gt;Amazon Redshift Cluster Management Guide&lt;/i&gt;.&lt;/p&gt;
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param createHsmClientCertificateMessage  (optional)
     * @return ApiResponse&lt;CreateHsmClientCertificateResult&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> HsmClientCertificateAlreadyExistsFault </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> HsmClientCertificateQuotaExceededFault </td><td>  -  </td></tr>
        <tr><td> 482 </td><td> TagLimitExceededFault </td><td>  -  </td></tr>
        <tr><td> 483 </td><td> InvalidTagFault </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<CreateHsmClientCertificateResult> pOSTCreateHsmClientCertificateWithHttpInfo(String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, CreateHsmClientCertificateMessage createHsmClientCertificateMessage) throws ApiException {
        okhttp3.Call localVarCall = pOSTCreateHsmClientCertificateValidateBeforeCall(action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, createHsmClientCertificateMessage, null);
        Type localVarReturnType = new TypeToken<CreateHsmClientCertificateResult>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     *  (asynchronously)
     * &lt;p&gt;Creates an HSM client certificate that an Amazon Redshift cluster will use to connect to the client&#39;s HSM in order to store and retrieve the keys used to encrypt the cluster databases.&lt;/p&gt; &lt;p&gt;The command returns a public key, which you must store in the HSM. In addition to creating the HSM certificate, you must create an Amazon Redshift HSM configuration that provides a cluster the information needed to store and use encryption keys in the HSM. For more information, go to &lt;a href&#x3D;\&quot;https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-db-encryption.html#working-with-HSM\&quot;&gt;Hardware Security Modules&lt;/a&gt; in the &lt;i&gt;Amazon Redshift Cluster Management Guide&lt;/i&gt;.&lt;/p&gt;
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param createHsmClientCertificateMessage  (optional)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> HsmClientCertificateAlreadyExistsFault </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> HsmClientCertificateQuotaExceededFault </td><td>  -  </td></tr>
        <tr><td> 482 </td><td> TagLimitExceededFault </td><td>  -  </td></tr>
        <tr><td> 483 </td><td> InvalidTagFault </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call pOSTCreateHsmClientCertificateAsync(String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, CreateHsmClientCertificateMessage createHsmClientCertificateMessage, final ApiCallback<CreateHsmClientCertificateResult> _callback) throws ApiException {

        okhttp3.Call localVarCall = pOSTCreateHsmClientCertificateValidateBeforeCall(action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, createHsmClientCertificateMessage, _callback);
        Type localVarReturnType = new TypeToken<CreateHsmClientCertificateResult>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for pOSTCreateHsmConfiguration
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param createHsmConfigurationMessage  (optional)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> HsmConfigurationAlreadyExistsFault </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> HsmConfigurationQuotaExceededFault </td><td>  -  </td></tr>
        <tr><td> 482 </td><td> TagLimitExceededFault </td><td>  -  </td></tr>
        <tr><td> 483 </td><td> InvalidTagFault </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call pOSTCreateHsmConfigurationCall(String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, CreateHsmConfigurationMessage createHsmConfigurationMessage, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = createHsmConfigurationMessage;

        // create path and map variables
        String localVarPath = "/#Action=CreateHsmConfiguration";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (action != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("Action", action));
        }

        if (version != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("Version", version));
        }

        if (xAmzContentSha256 != null) {
            localVarHeaderParams.put("X-Amz-Content-Sha256", localVarApiClient.parameterToString(xAmzContentSha256));
        }

        if (xAmzDate != null) {
            localVarHeaderParams.put("X-Amz-Date", localVarApiClient.parameterToString(xAmzDate));
        }

        if (xAmzAlgorithm != null) {
            localVarHeaderParams.put("X-Amz-Algorithm", localVarApiClient.parameterToString(xAmzAlgorithm));
        }

        if (xAmzCredential != null) {
            localVarHeaderParams.put("X-Amz-Credential", localVarApiClient.parameterToString(xAmzCredential));
        }

        if (xAmzSecurityToken != null) {
            localVarHeaderParams.put("X-Amz-Security-Token", localVarApiClient.parameterToString(xAmzSecurityToken));
        }

        if (xAmzSignature != null) {
            localVarHeaderParams.put("X-Amz-Signature", localVarApiClient.parameterToString(xAmzSignature));
        }

        if (xAmzSignedHeaders != null) {
            localVarHeaderParams.put("X-Amz-SignedHeaders", localVarApiClient.parameterToString(xAmzSignedHeaders));
        }

        final String[] localVarAccepts = {
            "text/xml"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            "text/xml"
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "hmac" };
        return localVarApiClient.buildCall(basePath, localVarPath, "POST", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call pOSTCreateHsmConfigurationValidateBeforeCall(String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, CreateHsmConfigurationMessage createHsmConfigurationMessage, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'action' is set
        if (action == null) {
            throw new ApiException("Missing the required parameter 'action' when calling pOSTCreateHsmConfiguration(Async)");
        }

        // verify the required parameter 'version' is set
        if (version == null) {
            throw new ApiException("Missing the required parameter 'version' when calling pOSTCreateHsmConfiguration(Async)");
        }

        return pOSTCreateHsmConfigurationCall(action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, createHsmConfigurationMessage, _callback);

    }

    /**
     * 
     * &lt;p&gt;Creates an HSM configuration that contains the information required by an Amazon Redshift cluster to store and use database encryption keys in a Hardware Security Module (HSM). After creating the HSM configuration, you can specify it as a parameter when creating a cluster. The cluster will then store its encryption keys in the HSM.&lt;/p&gt; &lt;p&gt;In addition to creating an HSM configuration, you must also create an HSM client certificate. For more information, go to &lt;a href&#x3D;\&quot;https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-HSM.html\&quot;&gt;Hardware Security Modules&lt;/a&gt; in the Amazon Redshift Cluster Management Guide.&lt;/p&gt;
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param createHsmConfigurationMessage  (optional)
     * @return CreateHsmConfigurationResult
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> HsmConfigurationAlreadyExistsFault </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> HsmConfigurationQuotaExceededFault </td><td>  -  </td></tr>
        <tr><td> 482 </td><td> TagLimitExceededFault </td><td>  -  </td></tr>
        <tr><td> 483 </td><td> InvalidTagFault </td><td>  -  </td></tr>
     </table>
     */
    public CreateHsmConfigurationResult pOSTCreateHsmConfiguration(String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, CreateHsmConfigurationMessage createHsmConfigurationMessage) throws ApiException {
        ApiResponse<CreateHsmConfigurationResult> localVarResp = pOSTCreateHsmConfigurationWithHttpInfo(action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, createHsmConfigurationMessage);
        return localVarResp.getData();
    }

    /**
     * 
     * &lt;p&gt;Creates an HSM configuration that contains the information required by an Amazon Redshift cluster to store and use database encryption keys in a Hardware Security Module (HSM). After creating the HSM configuration, you can specify it as a parameter when creating a cluster. The cluster will then store its encryption keys in the HSM.&lt;/p&gt; &lt;p&gt;In addition to creating an HSM configuration, you must also create an HSM client certificate. For more information, go to &lt;a href&#x3D;\&quot;https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-HSM.html\&quot;&gt;Hardware Security Modules&lt;/a&gt; in the Amazon Redshift Cluster Management Guide.&lt;/p&gt;
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param createHsmConfigurationMessage  (optional)
     * @return ApiResponse&lt;CreateHsmConfigurationResult&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> HsmConfigurationAlreadyExistsFault </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> HsmConfigurationQuotaExceededFault </td><td>  -  </td></tr>
        <tr><td> 482 </td><td> TagLimitExceededFault </td><td>  -  </td></tr>
        <tr><td> 483 </td><td> InvalidTagFault </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<CreateHsmConfigurationResult> pOSTCreateHsmConfigurationWithHttpInfo(String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, CreateHsmConfigurationMessage createHsmConfigurationMessage) throws ApiException {
        okhttp3.Call localVarCall = pOSTCreateHsmConfigurationValidateBeforeCall(action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, createHsmConfigurationMessage, null);
        Type localVarReturnType = new TypeToken<CreateHsmConfigurationResult>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     *  (asynchronously)
     * &lt;p&gt;Creates an HSM configuration that contains the information required by an Amazon Redshift cluster to store and use database encryption keys in a Hardware Security Module (HSM). After creating the HSM configuration, you can specify it as a parameter when creating a cluster. The cluster will then store its encryption keys in the HSM.&lt;/p&gt; &lt;p&gt;In addition to creating an HSM configuration, you must also create an HSM client certificate. For more information, go to &lt;a href&#x3D;\&quot;https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-HSM.html\&quot;&gt;Hardware Security Modules&lt;/a&gt; in the Amazon Redshift Cluster Management Guide.&lt;/p&gt;
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param createHsmConfigurationMessage  (optional)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> HsmConfigurationAlreadyExistsFault </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> HsmConfigurationQuotaExceededFault </td><td>  -  </td></tr>
        <tr><td> 482 </td><td> TagLimitExceededFault </td><td>  -  </td></tr>
        <tr><td> 483 </td><td> InvalidTagFault </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call pOSTCreateHsmConfigurationAsync(String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, CreateHsmConfigurationMessage createHsmConfigurationMessage, final ApiCallback<CreateHsmConfigurationResult> _callback) throws ApiException {

        okhttp3.Call localVarCall = pOSTCreateHsmConfigurationValidateBeforeCall(action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, createHsmConfigurationMessage, _callback);
        Type localVarReturnType = new TypeToken<CreateHsmConfigurationResult>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for pOSTCreateScheduledAction
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param createScheduledActionMessage  (optional)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> ScheduledActionAlreadyExistsFault </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> ScheduledActionQuotaExceededFault </td><td>  -  </td></tr>
        <tr><td> 482 </td><td> ScheduledActionTypeUnsupportedFault </td><td>  -  </td></tr>
        <tr><td> 483 </td><td> InvalidScheduleFault </td><td>  -  </td></tr>
        <tr><td> 484 </td><td> InvalidScheduledActionFault </td><td>  -  </td></tr>
        <tr><td> 485 </td><td> UnauthorizedOperation </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call pOSTCreateScheduledActionCall(String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, CreateScheduledActionMessage createScheduledActionMessage, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = createScheduledActionMessage;

        // create path and map variables
        String localVarPath = "/#Action=CreateScheduledAction";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (action != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("Action", action));
        }

        if (version != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("Version", version));
        }

        if (xAmzContentSha256 != null) {
            localVarHeaderParams.put("X-Amz-Content-Sha256", localVarApiClient.parameterToString(xAmzContentSha256));
        }

        if (xAmzDate != null) {
            localVarHeaderParams.put("X-Amz-Date", localVarApiClient.parameterToString(xAmzDate));
        }

        if (xAmzAlgorithm != null) {
            localVarHeaderParams.put("X-Amz-Algorithm", localVarApiClient.parameterToString(xAmzAlgorithm));
        }

        if (xAmzCredential != null) {
            localVarHeaderParams.put("X-Amz-Credential", localVarApiClient.parameterToString(xAmzCredential));
        }

        if (xAmzSecurityToken != null) {
            localVarHeaderParams.put("X-Amz-Security-Token", localVarApiClient.parameterToString(xAmzSecurityToken));
        }

        if (xAmzSignature != null) {
            localVarHeaderParams.put("X-Amz-Signature", localVarApiClient.parameterToString(xAmzSignature));
        }

        if (xAmzSignedHeaders != null) {
            localVarHeaderParams.put("X-Amz-SignedHeaders", localVarApiClient.parameterToString(xAmzSignedHeaders));
        }

        final String[] localVarAccepts = {
            "text/xml"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            "text/xml"
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "hmac" };
        return localVarApiClient.buildCall(basePath, localVarPath, "POST", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call pOSTCreateScheduledActionValidateBeforeCall(String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, CreateScheduledActionMessage createScheduledActionMessage, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'action' is set
        if (action == null) {
            throw new ApiException("Missing the required parameter 'action' when calling pOSTCreateScheduledAction(Async)");
        }

        // verify the required parameter 'version' is set
        if (version == null) {
            throw new ApiException("Missing the required parameter 'version' when calling pOSTCreateScheduledAction(Async)");
        }

        return pOSTCreateScheduledActionCall(action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, createScheduledActionMessage, _callback);

    }

    /**
     * 
     * Creates a scheduled action. A scheduled action contains a schedule and an Amazon Redshift API action. For example, you can create a schedule of when to run the &lt;code&gt;ResizeCluster&lt;/code&gt; API operation. 
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param createScheduledActionMessage  (optional)
     * @return ScheduledAction
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> ScheduledActionAlreadyExistsFault </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> ScheduledActionQuotaExceededFault </td><td>  -  </td></tr>
        <tr><td> 482 </td><td> ScheduledActionTypeUnsupportedFault </td><td>  -  </td></tr>
        <tr><td> 483 </td><td> InvalidScheduleFault </td><td>  -  </td></tr>
        <tr><td> 484 </td><td> InvalidScheduledActionFault </td><td>  -  </td></tr>
        <tr><td> 485 </td><td> UnauthorizedOperation </td><td>  -  </td></tr>
     </table>
     */
    public ScheduledAction pOSTCreateScheduledAction(String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, CreateScheduledActionMessage createScheduledActionMessage) throws ApiException {
        ApiResponse<ScheduledAction> localVarResp = pOSTCreateScheduledActionWithHttpInfo(action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, createScheduledActionMessage);
        return localVarResp.getData();
    }

    /**
     * 
     * Creates a scheduled action. A scheduled action contains a schedule and an Amazon Redshift API action. For example, you can create a schedule of when to run the &lt;code&gt;ResizeCluster&lt;/code&gt; API operation. 
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param createScheduledActionMessage  (optional)
     * @return ApiResponse&lt;ScheduledAction&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> ScheduledActionAlreadyExistsFault </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> ScheduledActionQuotaExceededFault </td><td>  -  </td></tr>
        <tr><td> 482 </td><td> ScheduledActionTypeUnsupportedFault </td><td>  -  </td></tr>
        <tr><td> 483 </td><td> InvalidScheduleFault </td><td>  -  </td></tr>
        <tr><td> 484 </td><td> InvalidScheduledActionFault </td><td>  -  </td></tr>
        <tr><td> 485 </td><td> UnauthorizedOperation </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<ScheduledAction> pOSTCreateScheduledActionWithHttpInfo(String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, CreateScheduledActionMessage createScheduledActionMessage) throws ApiException {
        okhttp3.Call localVarCall = pOSTCreateScheduledActionValidateBeforeCall(action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, createScheduledActionMessage, null);
        Type localVarReturnType = new TypeToken<ScheduledAction>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     *  (asynchronously)
     * Creates a scheduled action. A scheduled action contains a schedule and an Amazon Redshift API action. For example, you can create a schedule of when to run the &lt;code&gt;ResizeCluster&lt;/code&gt; API operation. 
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param createScheduledActionMessage  (optional)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> ScheduledActionAlreadyExistsFault </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> ScheduledActionQuotaExceededFault </td><td>  -  </td></tr>
        <tr><td> 482 </td><td> ScheduledActionTypeUnsupportedFault </td><td>  -  </td></tr>
        <tr><td> 483 </td><td> InvalidScheduleFault </td><td>  -  </td></tr>
        <tr><td> 484 </td><td> InvalidScheduledActionFault </td><td>  -  </td></tr>
        <tr><td> 485 </td><td> UnauthorizedOperation </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call pOSTCreateScheduledActionAsync(String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, CreateScheduledActionMessage createScheduledActionMessage, final ApiCallback<ScheduledAction> _callback) throws ApiException {

        okhttp3.Call localVarCall = pOSTCreateScheduledActionValidateBeforeCall(action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, createScheduledActionMessage, _callback);
        Type localVarReturnType = new TypeToken<ScheduledAction>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for pOSTCreateSnapshotCopyGrant
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param createSnapshotCopyGrantMessage  (optional)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> SnapshotCopyGrantAlreadyExistsFault </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> SnapshotCopyGrantQuotaExceededFault </td><td>  -  </td></tr>
        <tr><td> 482 </td><td> LimitExceededFault </td><td>  -  </td></tr>
        <tr><td> 483 </td><td> TagLimitExceededFault </td><td>  -  </td></tr>
        <tr><td> 484 </td><td> InvalidTagFault </td><td>  -  </td></tr>
        <tr><td> 485 </td><td> DependentServiceRequestThrottlingFault </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call pOSTCreateSnapshotCopyGrantCall(String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, CreateSnapshotCopyGrantMessage createSnapshotCopyGrantMessage, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = createSnapshotCopyGrantMessage;

        // create path and map variables
        String localVarPath = "/#Action=CreateSnapshotCopyGrant";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (action != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("Action", action));
        }

        if (version != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("Version", version));
        }

        if (xAmzContentSha256 != null) {
            localVarHeaderParams.put("X-Amz-Content-Sha256", localVarApiClient.parameterToString(xAmzContentSha256));
        }

        if (xAmzDate != null) {
            localVarHeaderParams.put("X-Amz-Date", localVarApiClient.parameterToString(xAmzDate));
        }

        if (xAmzAlgorithm != null) {
            localVarHeaderParams.put("X-Amz-Algorithm", localVarApiClient.parameterToString(xAmzAlgorithm));
        }

        if (xAmzCredential != null) {
            localVarHeaderParams.put("X-Amz-Credential", localVarApiClient.parameterToString(xAmzCredential));
        }

        if (xAmzSecurityToken != null) {
            localVarHeaderParams.put("X-Amz-Security-Token", localVarApiClient.parameterToString(xAmzSecurityToken));
        }

        if (xAmzSignature != null) {
            localVarHeaderParams.put("X-Amz-Signature", localVarApiClient.parameterToString(xAmzSignature));
        }

        if (xAmzSignedHeaders != null) {
            localVarHeaderParams.put("X-Amz-SignedHeaders", localVarApiClient.parameterToString(xAmzSignedHeaders));
        }

        final String[] localVarAccepts = {
            "text/xml"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            "text/xml"
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "hmac" };
        return localVarApiClient.buildCall(basePath, localVarPath, "POST", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call pOSTCreateSnapshotCopyGrantValidateBeforeCall(String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, CreateSnapshotCopyGrantMessage createSnapshotCopyGrantMessage, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'action' is set
        if (action == null) {
            throw new ApiException("Missing the required parameter 'action' when calling pOSTCreateSnapshotCopyGrant(Async)");
        }

        // verify the required parameter 'version' is set
        if (version == null) {
            throw new ApiException("Missing the required parameter 'version' when calling pOSTCreateSnapshotCopyGrant(Async)");
        }

        return pOSTCreateSnapshotCopyGrantCall(action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, createSnapshotCopyGrantMessage, _callback);

    }

    /**
     * 
     * &lt;p&gt;Creates a snapshot copy grant that permits Amazon Redshift to use an encrypted symmetric key from Key Management Service (KMS) to encrypt copied snapshots in a destination region.&lt;/p&gt; &lt;p&gt; For more information about managing snapshot copy grants, go to &lt;a href&#x3D;\&quot;https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-db-encryption.html\&quot;&gt;Amazon Redshift Database Encryption&lt;/a&gt; in the &lt;i&gt;Amazon Redshift Cluster Management Guide&lt;/i&gt;. &lt;/p&gt;
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param createSnapshotCopyGrantMessage  (optional)
     * @return CreateSnapshotCopyGrantResult
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> SnapshotCopyGrantAlreadyExistsFault </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> SnapshotCopyGrantQuotaExceededFault </td><td>  -  </td></tr>
        <tr><td> 482 </td><td> LimitExceededFault </td><td>  -  </td></tr>
        <tr><td> 483 </td><td> TagLimitExceededFault </td><td>  -  </td></tr>
        <tr><td> 484 </td><td> InvalidTagFault </td><td>  -  </td></tr>
        <tr><td> 485 </td><td> DependentServiceRequestThrottlingFault </td><td>  -  </td></tr>
     </table>
     */
    public CreateSnapshotCopyGrantResult pOSTCreateSnapshotCopyGrant(String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, CreateSnapshotCopyGrantMessage createSnapshotCopyGrantMessage) throws ApiException {
        ApiResponse<CreateSnapshotCopyGrantResult> localVarResp = pOSTCreateSnapshotCopyGrantWithHttpInfo(action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, createSnapshotCopyGrantMessage);
        return localVarResp.getData();
    }

    /**
     * 
     * &lt;p&gt;Creates a snapshot copy grant that permits Amazon Redshift to use an encrypted symmetric key from Key Management Service (KMS) to encrypt copied snapshots in a destination region.&lt;/p&gt; &lt;p&gt; For more information about managing snapshot copy grants, go to &lt;a href&#x3D;\&quot;https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-db-encryption.html\&quot;&gt;Amazon Redshift Database Encryption&lt;/a&gt; in the &lt;i&gt;Amazon Redshift Cluster Management Guide&lt;/i&gt;. &lt;/p&gt;
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param createSnapshotCopyGrantMessage  (optional)
     * @return ApiResponse&lt;CreateSnapshotCopyGrantResult&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> SnapshotCopyGrantAlreadyExistsFault </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> SnapshotCopyGrantQuotaExceededFault </td><td>  -  </td></tr>
        <tr><td> 482 </td><td> LimitExceededFault </td><td>  -  </td></tr>
        <tr><td> 483 </td><td> TagLimitExceededFault </td><td>  -  </td></tr>
        <tr><td> 484 </td><td> InvalidTagFault </td><td>  -  </td></tr>
        <tr><td> 485 </td><td> DependentServiceRequestThrottlingFault </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<CreateSnapshotCopyGrantResult> pOSTCreateSnapshotCopyGrantWithHttpInfo(String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, CreateSnapshotCopyGrantMessage createSnapshotCopyGrantMessage) throws ApiException {
        okhttp3.Call localVarCall = pOSTCreateSnapshotCopyGrantValidateBeforeCall(action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, createSnapshotCopyGrantMessage, null);
        Type localVarReturnType = new TypeToken<CreateSnapshotCopyGrantResult>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     *  (asynchronously)
     * &lt;p&gt;Creates a snapshot copy grant that permits Amazon Redshift to use an encrypted symmetric key from Key Management Service (KMS) to encrypt copied snapshots in a destination region.&lt;/p&gt; &lt;p&gt; For more information about managing snapshot copy grants, go to &lt;a href&#x3D;\&quot;https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-db-encryption.html\&quot;&gt;Amazon Redshift Database Encryption&lt;/a&gt; in the &lt;i&gt;Amazon Redshift Cluster Management Guide&lt;/i&gt;. &lt;/p&gt;
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param createSnapshotCopyGrantMessage  (optional)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> SnapshotCopyGrantAlreadyExistsFault </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> SnapshotCopyGrantQuotaExceededFault </td><td>  -  </td></tr>
        <tr><td> 482 </td><td> LimitExceededFault </td><td>  -  </td></tr>
        <tr><td> 483 </td><td> TagLimitExceededFault </td><td>  -  </td></tr>
        <tr><td> 484 </td><td> InvalidTagFault </td><td>  -  </td></tr>
        <tr><td> 485 </td><td> DependentServiceRequestThrottlingFault </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call pOSTCreateSnapshotCopyGrantAsync(String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, CreateSnapshotCopyGrantMessage createSnapshotCopyGrantMessage, final ApiCallback<CreateSnapshotCopyGrantResult> _callback) throws ApiException {

        okhttp3.Call localVarCall = pOSTCreateSnapshotCopyGrantValidateBeforeCall(action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, createSnapshotCopyGrantMessage, _callback);
        Type localVarReturnType = new TypeToken<CreateSnapshotCopyGrantResult>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for pOSTCreateSnapshotSchedule
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param createSnapshotScheduleMessage  (optional)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> SnapshotScheduleAlreadyExistsFault </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> InvalidScheduleFault </td><td>  -  </td></tr>
        <tr><td> 482 </td><td> SnapshotScheduleQuotaExceededFault </td><td>  -  </td></tr>
        <tr><td> 483 </td><td> TagLimitExceededFault </td><td>  -  </td></tr>
        <tr><td> 484 </td><td> ScheduleDefinitionTypeUnsupportedFault </td><td>  -  </td></tr>
        <tr><td> 485 </td><td> InvalidTagFault </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call pOSTCreateSnapshotScheduleCall(String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, CreateSnapshotScheduleMessage createSnapshotScheduleMessage, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = createSnapshotScheduleMessage;

        // create path and map variables
        String localVarPath = "/#Action=CreateSnapshotSchedule";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (action != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("Action", action));
        }

        if (version != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("Version", version));
        }

        if (xAmzContentSha256 != null) {
            localVarHeaderParams.put("X-Amz-Content-Sha256", localVarApiClient.parameterToString(xAmzContentSha256));
        }

        if (xAmzDate != null) {
            localVarHeaderParams.put("X-Amz-Date", localVarApiClient.parameterToString(xAmzDate));
        }

        if (xAmzAlgorithm != null) {
            localVarHeaderParams.put("X-Amz-Algorithm", localVarApiClient.parameterToString(xAmzAlgorithm));
        }

        if (xAmzCredential != null) {
            localVarHeaderParams.put("X-Amz-Credential", localVarApiClient.parameterToString(xAmzCredential));
        }

        if (xAmzSecurityToken != null) {
            localVarHeaderParams.put("X-Amz-Security-Token", localVarApiClient.parameterToString(xAmzSecurityToken));
        }

        if (xAmzSignature != null) {
            localVarHeaderParams.put("X-Amz-Signature", localVarApiClient.parameterToString(xAmzSignature));
        }

        if (xAmzSignedHeaders != null) {
            localVarHeaderParams.put("X-Amz-SignedHeaders", localVarApiClient.parameterToString(xAmzSignedHeaders));
        }

        final String[] localVarAccepts = {
            "text/xml"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            "text/xml"
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "hmac" };
        return localVarApiClient.buildCall(basePath, localVarPath, "POST", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call pOSTCreateSnapshotScheduleValidateBeforeCall(String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, CreateSnapshotScheduleMessage createSnapshotScheduleMessage, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'action' is set
        if (action == null) {
            throw new ApiException("Missing the required parameter 'action' when calling pOSTCreateSnapshotSchedule(Async)");
        }

        // verify the required parameter 'version' is set
        if (version == null) {
            throw new ApiException("Missing the required parameter 'version' when calling pOSTCreateSnapshotSchedule(Async)");
        }

        return pOSTCreateSnapshotScheduleCall(action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, createSnapshotScheduleMessage, _callback);

    }

    /**
     * 
     * Create a snapshot schedule that can be associated to a cluster and which overrides the default system backup schedule. 
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param createSnapshotScheduleMessage  (optional)
     * @return SnapshotSchedule
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> SnapshotScheduleAlreadyExistsFault </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> InvalidScheduleFault </td><td>  -  </td></tr>
        <tr><td> 482 </td><td> SnapshotScheduleQuotaExceededFault </td><td>  -  </td></tr>
        <tr><td> 483 </td><td> TagLimitExceededFault </td><td>  -  </td></tr>
        <tr><td> 484 </td><td> ScheduleDefinitionTypeUnsupportedFault </td><td>  -  </td></tr>
        <tr><td> 485 </td><td> InvalidTagFault </td><td>  -  </td></tr>
     </table>
     */
    public SnapshotSchedule pOSTCreateSnapshotSchedule(String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, CreateSnapshotScheduleMessage createSnapshotScheduleMessage) throws ApiException {
        ApiResponse<SnapshotSchedule> localVarResp = pOSTCreateSnapshotScheduleWithHttpInfo(action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, createSnapshotScheduleMessage);
        return localVarResp.getData();
    }

    /**
     * 
     * Create a snapshot schedule that can be associated to a cluster and which overrides the default system backup schedule. 
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param createSnapshotScheduleMessage  (optional)
     * @return ApiResponse&lt;SnapshotSchedule&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> SnapshotScheduleAlreadyExistsFault </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> InvalidScheduleFault </td><td>  -  </td></tr>
        <tr><td> 482 </td><td> SnapshotScheduleQuotaExceededFault </td><td>  -  </td></tr>
        <tr><td> 483 </td><td> TagLimitExceededFault </td><td>  -  </td></tr>
        <tr><td> 484 </td><td> ScheduleDefinitionTypeUnsupportedFault </td><td>  -  </td></tr>
        <tr><td> 485 </td><td> InvalidTagFault </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<SnapshotSchedule> pOSTCreateSnapshotScheduleWithHttpInfo(String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, CreateSnapshotScheduleMessage createSnapshotScheduleMessage) throws ApiException {
        okhttp3.Call localVarCall = pOSTCreateSnapshotScheduleValidateBeforeCall(action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, createSnapshotScheduleMessage, null);
        Type localVarReturnType = new TypeToken<SnapshotSchedule>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     *  (asynchronously)
     * Create a snapshot schedule that can be associated to a cluster and which overrides the default system backup schedule. 
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param createSnapshotScheduleMessage  (optional)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> SnapshotScheduleAlreadyExistsFault </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> InvalidScheduleFault </td><td>  -  </td></tr>
        <tr><td> 482 </td><td> SnapshotScheduleQuotaExceededFault </td><td>  -  </td></tr>
        <tr><td> 483 </td><td> TagLimitExceededFault </td><td>  -  </td></tr>
        <tr><td> 484 </td><td> ScheduleDefinitionTypeUnsupportedFault </td><td>  -  </td></tr>
        <tr><td> 485 </td><td> InvalidTagFault </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call pOSTCreateSnapshotScheduleAsync(String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, CreateSnapshotScheduleMessage createSnapshotScheduleMessage, final ApiCallback<SnapshotSchedule> _callback) throws ApiException {

        okhttp3.Call localVarCall = pOSTCreateSnapshotScheduleValidateBeforeCall(action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, createSnapshotScheduleMessage, _callback);
        Type localVarReturnType = new TypeToken<SnapshotSchedule>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for pOSTCreateTags
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param createTagsMessage  (optional)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> TagLimitExceededFault </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> ResourceNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 482 </td><td> InvalidTagFault </td><td>  -  </td></tr>
        <tr><td> 483 </td><td> InvalidClusterStateFault </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call pOSTCreateTagsCall(String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, CreateTagsMessage createTagsMessage, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = createTagsMessage;

        // create path and map variables
        String localVarPath = "/#Action=CreateTags";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (action != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("Action", action));
        }

        if (version != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("Version", version));
        }

        if (xAmzContentSha256 != null) {
            localVarHeaderParams.put("X-Amz-Content-Sha256", localVarApiClient.parameterToString(xAmzContentSha256));
        }

        if (xAmzDate != null) {
            localVarHeaderParams.put("X-Amz-Date", localVarApiClient.parameterToString(xAmzDate));
        }

        if (xAmzAlgorithm != null) {
            localVarHeaderParams.put("X-Amz-Algorithm", localVarApiClient.parameterToString(xAmzAlgorithm));
        }

        if (xAmzCredential != null) {
            localVarHeaderParams.put("X-Amz-Credential", localVarApiClient.parameterToString(xAmzCredential));
        }

        if (xAmzSecurityToken != null) {
            localVarHeaderParams.put("X-Amz-Security-Token", localVarApiClient.parameterToString(xAmzSecurityToken));
        }

        if (xAmzSignature != null) {
            localVarHeaderParams.put("X-Amz-Signature", localVarApiClient.parameterToString(xAmzSignature));
        }

        if (xAmzSignedHeaders != null) {
            localVarHeaderParams.put("X-Amz-SignedHeaders", localVarApiClient.parameterToString(xAmzSignedHeaders));
        }

        final String[] localVarAccepts = {
            "text/xml"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            "text/xml"
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "hmac" };
        return localVarApiClient.buildCall(basePath, localVarPath, "POST", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call pOSTCreateTagsValidateBeforeCall(String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, CreateTagsMessage createTagsMessage, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'action' is set
        if (action == null) {
            throw new ApiException("Missing the required parameter 'action' when calling pOSTCreateTags(Async)");
        }

        // verify the required parameter 'version' is set
        if (version == null) {
            throw new ApiException("Missing the required parameter 'version' when calling pOSTCreateTags(Async)");
        }

        return pOSTCreateTagsCall(action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, createTagsMessage, _callback);

    }

    /**
     * 
     * &lt;p&gt;Adds tags to a cluster.&lt;/p&gt; &lt;p&gt;A resource can have up to 50 tags. If you try to create more than 50 tags for a resource, you will receive an error and the attempt will fail.&lt;/p&gt; &lt;p&gt;If you specify a key that already exists for the resource, the value for that key will be updated with the new value.&lt;/p&gt;
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param createTagsMessage  (optional)
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> TagLimitExceededFault </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> ResourceNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 482 </td><td> InvalidTagFault </td><td>  -  </td></tr>
        <tr><td> 483 </td><td> InvalidClusterStateFault </td><td>  -  </td></tr>
     </table>
     */
    public void pOSTCreateTags(String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, CreateTagsMessage createTagsMessage) throws ApiException {
        pOSTCreateTagsWithHttpInfo(action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, createTagsMessage);
    }

    /**
     * 
     * &lt;p&gt;Adds tags to a cluster.&lt;/p&gt; &lt;p&gt;A resource can have up to 50 tags. If you try to create more than 50 tags for a resource, you will receive an error and the attempt will fail.&lt;/p&gt; &lt;p&gt;If you specify a key that already exists for the resource, the value for that key will be updated with the new value.&lt;/p&gt;
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param createTagsMessage  (optional)
     * @return ApiResponse&lt;Void&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> TagLimitExceededFault </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> ResourceNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 482 </td><td> InvalidTagFault </td><td>  -  </td></tr>
        <tr><td> 483 </td><td> InvalidClusterStateFault </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<Void> pOSTCreateTagsWithHttpInfo(String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, CreateTagsMessage createTagsMessage) throws ApiException {
        okhttp3.Call localVarCall = pOSTCreateTagsValidateBeforeCall(action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, createTagsMessage, null);
        return localVarApiClient.execute(localVarCall);
    }

    /**
     *  (asynchronously)
     * &lt;p&gt;Adds tags to a cluster.&lt;/p&gt; &lt;p&gt;A resource can have up to 50 tags. If you try to create more than 50 tags for a resource, you will receive an error and the attempt will fail.&lt;/p&gt; &lt;p&gt;If you specify a key that already exists for the resource, the value for that key will be updated with the new value.&lt;/p&gt;
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param createTagsMessage  (optional)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> TagLimitExceededFault </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> ResourceNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 482 </td><td> InvalidTagFault </td><td>  -  </td></tr>
        <tr><td> 483 </td><td> InvalidClusterStateFault </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call pOSTCreateTagsAsync(String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, CreateTagsMessage createTagsMessage, final ApiCallback<Void> _callback) throws ApiException {

        okhttp3.Call localVarCall = pOSTCreateTagsValidateBeforeCall(action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, createTagsMessage, _callback);
        localVarApiClient.executeAsync(localVarCall, _callback);
        return localVarCall;
    }
    /**
     * Build call for pOSTCreateUsageLimit
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param createUsageLimitMessage  (optional)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> ClusterNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> InvalidClusterStateFault </td><td>  -  </td></tr>
        <tr><td> 482 </td><td> LimitExceededFault </td><td>  -  </td></tr>
        <tr><td> 483 </td><td> UsageLimitAlreadyExistsFault </td><td>  -  </td></tr>
        <tr><td> 484 </td><td> InvalidUsageLimitFault </td><td>  -  </td></tr>
        <tr><td> 485 </td><td> TagLimitExceededFault </td><td>  -  </td></tr>
        <tr><td> 486 </td><td> UnsupportedOperationFault </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call pOSTCreateUsageLimitCall(String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, CreateUsageLimitMessage createUsageLimitMessage, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = createUsageLimitMessage;

        // create path and map variables
        String localVarPath = "/#Action=CreateUsageLimit";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (action != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("Action", action));
        }

        if (version != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("Version", version));
        }

        if (xAmzContentSha256 != null) {
            localVarHeaderParams.put("X-Amz-Content-Sha256", localVarApiClient.parameterToString(xAmzContentSha256));
        }

        if (xAmzDate != null) {
            localVarHeaderParams.put("X-Amz-Date", localVarApiClient.parameterToString(xAmzDate));
        }

        if (xAmzAlgorithm != null) {
            localVarHeaderParams.put("X-Amz-Algorithm", localVarApiClient.parameterToString(xAmzAlgorithm));
        }

        if (xAmzCredential != null) {
            localVarHeaderParams.put("X-Amz-Credential", localVarApiClient.parameterToString(xAmzCredential));
        }

        if (xAmzSecurityToken != null) {
            localVarHeaderParams.put("X-Amz-Security-Token", localVarApiClient.parameterToString(xAmzSecurityToken));
        }

        if (xAmzSignature != null) {
            localVarHeaderParams.put("X-Amz-Signature", localVarApiClient.parameterToString(xAmzSignature));
        }

        if (xAmzSignedHeaders != null) {
            localVarHeaderParams.put("X-Amz-SignedHeaders", localVarApiClient.parameterToString(xAmzSignedHeaders));
        }

        final String[] localVarAccepts = {
            "text/xml"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            "text/xml"
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "hmac" };
        return localVarApiClient.buildCall(basePath, localVarPath, "POST", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call pOSTCreateUsageLimitValidateBeforeCall(String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, CreateUsageLimitMessage createUsageLimitMessage, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'action' is set
        if (action == null) {
            throw new ApiException("Missing the required parameter 'action' when calling pOSTCreateUsageLimit(Async)");
        }

        // verify the required parameter 'version' is set
        if (version == null) {
            throw new ApiException("Missing the required parameter 'version' when calling pOSTCreateUsageLimit(Async)");
        }

        return pOSTCreateUsageLimitCall(action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, createUsageLimitMessage, _callback);

    }

    /**
     * 
     * Creates a usage limit for a specified Amazon Redshift feature on a cluster. The usage limit is identified by the returned usage limit identifier.
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param createUsageLimitMessage  (optional)
     * @return UsageLimit
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> ClusterNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> InvalidClusterStateFault </td><td>  -  </td></tr>
        <tr><td> 482 </td><td> LimitExceededFault </td><td>  -  </td></tr>
        <tr><td> 483 </td><td> UsageLimitAlreadyExistsFault </td><td>  -  </td></tr>
        <tr><td> 484 </td><td> InvalidUsageLimitFault </td><td>  -  </td></tr>
        <tr><td> 485 </td><td> TagLimitExceededFault </td><td>  -  </td></tr>
        <tr><td> 486 </td><td> UnsupportedOperationFault </td><td>  -  </td></tr>
     </table>
     */
    public UsageLimit pOSTCreateUsageLimit(String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, CreateUsageLimitMessage createUsageLimitMessage) throws ApiException {
        ApiResponse<UsageLimit> localVarResp = pOSTCreateUsageLimitWithHttpInfo(action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, createUsageLimitMessage);
        return localVarResp.getData();
    }

    /**
     * 
     * Creates a usage limit for a specified Amazon Redshift feature on a cluster. The usage limit is identified by the returned usage limit identifier.
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param createUsageLimitMessage  (optional)
     * @return ApiResponse&lt;UsageLimit&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> ClusterNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> InvalidClusterStateFault </td><td>  -  </td></tr>
        <tr><td> 482 </td><td> LimitExceededFault </td><td>  -  </td></tr>
        <tr><td> 483 </td><td> UsageLimitAlreadyExistsFault </td><td>  -  </td></tr>
        <tr><td> 484 </td><td> InvalidUsageLimitFault </td><td>  -  </td></tr>
        <tr><td> 485 </td><td> TagLimitExceededFault </td><td>  -  </td></tr>
        <tr><td> 486 </td><td> UnsupportedOperationFault </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<UsageLimit> pOSTCreateUsageLimitWithHttpInfo(String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, CreateUsageLimitMessage createUsageLimitMessage) throws ApiException {
        okhttp3.Call localVarCall = pOSTCreateUsageLimitValidateBeforeCall(action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, createUsageLimitMessage, null);
        Type localVarReturnType = new TypeToken<UsageLimit>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     *  (asynchronously)
     * Creates a usage limit for a specified Amazon Redshift feature on a cluster. The usage limit is identified by the returned usage limit identifier.
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param createUsageLimitMessage  (optional)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> ClusterNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> InvalidClusterStateFault </td><td>  -  </td></tr>
        <tr><td> 482 </td><td> LimitExceededFault </td><td>  -  </td></tr>
        <tr><td> 483 </td><td> UsageLimitAlreadyExistsFault </td><td>  -  </td></tr>
        <tr><td> 484 </td><td> InvalidUsageLimitFault </td><td>  -  </td></tr>
        <tr><td> 485 </td><td> TagLimitExceededFault </td><td>  -  </td></tr>
        <tr><td> 486 </td><td> UnsupportedOperationFault </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call pOSTCreateUsageLimitAsync(String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, CreateUsageLimitMessage createUsageLimitMessage, final ApiCallback<UsageLimit> _callback) throws ApiException {

        okhttp3.Call localVarCall = pOSTCreateUsageLimitValidateBeforeCall(action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, createUsageLimitMessage, _callback);
        Type localVarReturnType = new TypeToken<UsageLimit>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for pOSTDeauthorizeDataShare
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param deauthorizeDataShareMessage  (optional)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> InvalidDataShareFault </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call pOSTDeauthorizeDataShareCall(String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, DeauthorizeDataShareMessage deauthorizeDataShareMessage, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = deauthorizeDataShareMessage;

        // create path and map variables
        String localVarPath = "/#Action=DeauthorizeDataShare";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (action != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("Action", action));
        }

        if (version != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("Version", version));
        }

        if (xAmzContentSha256 != null) {
            localVarHeaderParams.put("X-Amz-Content-Sha256", localVarApiClient.parameterToString(xAmzContentSha256));
        }

        if (xAmzDate != null) {
            localVarHeaderParams.put("X-Amz-Date", localVarApiClient.parameterToString(xAmzDate));
        }

        if (xAmzAlgorithm != null) {
            localVarHeaderParams.put("X-Amz-Algorithm", localVarApiClient.parameterToString(xAmzAlgorithm));
        }

        if (xAmzCredential != null) {
            localVarHeaderParams.put("X-Amz-Credential", localVarApiClient.parameterToString(xAmzCredential));
        }

        if (xAmzSecurityToken != null) {
            localVarHeaderParams.put("X-Amz-Security-Token", localVarApiClient.parameterToString(xAmzSecurityToken));
        }

        if (xAmzSignature != null) {
            localVarHeaderParams.put("X-Amz-Signature", localVarApiClient.parameterToString(xAmzSignature));
        }

        if (xAmzSignedHeaders != null) {
            localVarHeaderParams.put("X-Amz-SignedHeaders", localVarApiClient.parameterToString(xAmzSignedHeaders));
        }

        final String[] localVarAccepts = {
            "text/xml"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            "text/xml"
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "hmac" };
        return localVarApiClient.buildCall(basePath, localVarPath, "POST", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call pOSTDeauthorizeDataShareValidateBeforeCall(String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, DeauthorizeDataShareMessage deauthorizeDataShareMessage, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'action' is set
        if (action == null) {
            throw new ApiException("Missing the required parameter 'action' when calling pOSTDeauthorizeDataShare(Async)");
        }

        // verify the required parameter 'version' is set
        if (version == null) {
            throw new ApiException("Missing the required parameter 'version' when calling pOSTDeauthorizeDataShare(Async)");
        }

        return pOSTDeauthorizeDataShareCall(action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, deauthorizeDataShareMessage, _callback);

    }

    /**
     * 
     * From a datashare producer account, removes authorization from the specified datashare. 
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param deauthorizeDataShareMessage  (optional)
     * @return DataShare
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> InvalidDataShareFault </td><td>  -  </td></tr>
     </table>
     */
    public DataShare pOSTDeauthorizeDataShare(String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, DeauthorizeDataShareMessage deauthorizeDataShareMessage) throws ApiException {
        ApiResponse<DataShare> localVarResp = pOSTDeauthorizeDataShareWithHttpInfo(action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, deauthorizeDataShareMessage);
        return localVarResp.getData();
    }

    /**
     * 
     * From a datashare producer account, removes authorization from the specified datashare. 
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param deauthorizeDataShareMessage  (optional)
     * @return ApiResponse&lt;DataShare&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> InvalidDataShareFault </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<DataShare> pOSTDeauthorizeDataShareWithHttpInfo(String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, DeauthorizeDataShareMessage deauthorizeDataShareMessage) throws ApiException {
        okhttp3.Call localVarCall = pOSTDeauthorizeDataShareValidateBeforeCall(action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, deauthorizeDataShareMessage, null);
        Type localVarReturnType = new TypeToken<DataShare>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     *  (asynchronously)
     * From a datashare producer account, removes authorization from the specified datashare. 
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param deauthorizeDataShareMessage  (optional)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> InvalidDataShareFault </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call pOSTDeauthorizeDataShareAsync(String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, DeauthorizeDataShareMessage deauthorizeDataShareMessage, final ApiCallback<DataShare> _callback) throws ApiException {

        okhttp3.Call localVarCall = pOSTDeauthorizeDataShareValidateBeforeCall(action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, deauthorizeDataShareMessage, _callback);
        Type localVarReturnType = new TypeToken<DataShare>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for pOSTDeleteAuthenticationProfile
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param deleteAuthenticationProfileMessage  (optional)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> AuthenticationProfileNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> InvalidAuthenticationProfileRequestFault </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call pOSTDeleteAuthenticationProfileCall(String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, DeleteAuthenticationProfileMessage deleteAuthenticationProfileMessage, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = deleteAuthenticationProfileMessage;

        // create path and map variables
        String localVarPath = "/#Action=DeleteAuthenticationProfile";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (action != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("Action", action));
        }

        if (version != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("Version", version));
        }

        if (xAmzContentSha256 != null) {
            localVarHeaderParams.put("X-Amz-Content-Sha256", localVarApiClient.parameterToString(xAmzContentSha256));
        }

        if (xAmzDate != null) {
            localVarHeaderParams.put("X-Amz-Date", localVarApiClient.parameterToString(xAmzDate));
        }

        if (xAmzAlgorithm != null) {
            localVarHeaderParams.put("X-Amz-Algorithm", localVarApiClient.parameterToString(xAmzAlgorithm));
        }

        if (xAmzCredential != null) {
            localVarHeaderParams.put("X-Amz-Credential", localVarApiClient.parameterToString(xAmzCredential));
        }

        if (xAmzSecurityToken != null) {
            localVarHeaderParams.put("X-Amz-Security-Token", localVarApiClient.parameterToString(xAmzSecurityToken));
        }

        if (xAmzSignature != null) {
            localVarHeaderParams.put("X-Amz-Signature", localVarApiClient.parameterToString(xAmzSignature));
        }

        if (xAmzSignedHeaders != null) {
            localVarHeaderParams.put("X-Amz-SignedHeaders", localVarApiClient.parameterToString(xAmzSignedHeaders));
        }

        final String[] localVarAccepts = {
            "text/xml"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            "text/xml"
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "hmac" };
        return localVarApiClient.buildCall(basePath, localVarPath, "POST", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call pOSTDeleteAuthenticationProfileValidateBeforeCall(String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, DeleteAuthenticationProfileMessage deleteAuthenticationProfileMessage, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'action' is set
        if (action == null) {
            throw new ApiException("Missing the required parameter 'action' when calling pOSTDeleteAuthenticationProfile(Async)");
        }

        // verify the required parameter 'version' is set
        if (version == null) {
            throw new ApiException("Missing the required parameter 'version' when calling pOSTDeleteAuthenticationProfile(Async)");
        }

        return pOSTDeleteAuthenticationProfileCall(action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, deleteAuthenticationProfileMessage, _callback);

    }

    /**
     * 
     * Deletes an authentication profile.
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param deleteAuthenticationProfileMessage  (optional)
     * @return DeleteAuthenticationProfileResult
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> AuthenticationProfileNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> InvalidAuthenticationProfileRequestFault </td><td>  -  </td></tr>
     </table>
     */
    public DeleteAuthenticationProfileResult pOSTDeleteAuthenticationProfile(String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, DeleteAuthenticationProfileMessage deleteAuthenticationProfileMessage) throws ApiException {
        ApiResponse<DeleteAuthenticationProfileResult> localVarResp = pOSTDeleteAuthenticationProfileWithHttpInfo(action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, deleteAuthenticationProfileMessage);
        return localVarResp.getData();
    }

    /**
     * 
     * Deletes an authentication profile.
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param deleteAuthenticationProfileMessage  (optional)
     * @return ApiResponse&lt;DeleteAuthenticationProfileResult&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> AuthenticationProfileNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> InvalidAuthenticationProfileRequestFault </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<DeleteAuthenticationProfileResult> pOSTDeleteAuthenticationProfileWithHttpInfo(String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, DeleteAuthenticationProfileMessage deleteAuthenticationProfileMessage) throws ApiException {
        okhttp3.Call localVarCall = pOSTDeleteAuthenticationProfileValidateBeforeCall(action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, deleteAuthenticationProfileMessage, null);
        Type localVarReturnType = new TypeToken<DeleteAuthenticationProfileResult>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     *  (asynchronously)
     * Deletes an authentication profile.
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param deleteAuthenticationProfileMessage  (optional)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> AuthenticationProfileNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> InvalidAuthenticationProfileRequestFault </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call pOSTDeleteAuthenticationProfileAsync(String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, DeleteAuthenticationProfileMessage deleteAuthenticationProfileMessage, final ApiCallback<DeleteAuthenticationProfileResult> _callback) throws ApiException {

        okhttp3.Call localVarCall = pOSTDeleteAuthenticationProfileValidateBeforeCall(action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, deleteAuthenticationProfileMessage, _callback);
        Type localVarReturnType = new TypeToken<DeleteAuthenticationProfileResult>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for pOSTDeleteCluster
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param deleteClusterMessage  (optional)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> ClusterNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> InvalidClusterStateFault </td><td>  -  </td></tr>
        <tr><td> 482 </td><td> ClusterSnapshotAlreadyExistsFault </td><td>  -  </td></tr>
        <tr><td> 483 </td><td> ClusterSnapshotQuotaExceededFault </td><td>  -  </td></tr>
        <tr><td> 484 </td><td> InvalidRetentionPeriodFault </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call pOSTDeleteClusterCall(String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, DeleteClusterMessage deleteClusterMessage, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = deleteClusterMessage;

        // create path and map variables
        String localVarPath = "/#Action=DeleteCluster";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (action != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("Action", action));
        }

        if (version != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("Version", version));
        }

        if (xAmzContentSha256 != null) {
            localVarHeaderParams.put("X-Amz-Content-Sha256", localVarApiClient.parameterToString(xAmzContentSha256));
        }

        if (xAmzDate != null) {
            localVarHeaderParams.put("X-Amz-Date", localVarApiClient.parameterToString(xAmzDate));
        }

        if (xAmzAlgorithm != null) {
            localVarHeaderParams.put("X-Amz-Algorithm", localVarApiClient.parameterToString(xAmzAlgorithm));
        }

        if (xAmzCredential != null) {
            localVarHeaderParams.put("X-Amz-Credential", localVarApiClient.parameterToString(xAmzCredential));
        }

        if (xAmzSecurityToken != null) {
            localVarHeaderParams.put("X-Amz-Security-Token", localVarApiClient.parameterToString(xAmzSecurityToken));
        }

        if (xAmzSignature != null) {
            localVarHeaderParams.put("X-Amz-Signature", localVarApiClient.parameterToString(xAmzSignature));
        }

        if (xAmzSignedHeaders != null) {
            localVarHeaderParams.put("X-Amz-SignedHeaders", localVarApiClient.parameterToString(xAmzSignedHeaders));
        }

        final String[] localVarAccepts = {
            "text/xml"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            "text/xml"
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "hmac" };
        return localVarApiClient.buildCall(basePath, localVarPath, "POST", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call pOSTDeleteClusterValidateBeforeCall(String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, DeleteClusterMessage deleteClusterMessage, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'action' is set
        if (action == null) {
            throw new ApiException("Missing the required parameter 'action' when calling pOSTDeleteCluster(Async)");
        }

        // verify the required parameter 'version' is set
        if (version == null) {
            throw new ApiException("Missing the required parameter 'version' when calling pOSTDeleteCluster(Async)");
        }

        return pOSTDeleteClusterCall(action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, deleteClusterMessage, _callback);

    }

    /**
     * 
     * &lt;p&gt;Deletes a previously provisioned cluster without its final snapshot being created. A successful response from the web service indicates that the request was received correctly. Use &lt;a&gt;DescribeClusters&lt;/a&gt; to monitor the status of the deletion. The delete operation cannot be canceled or reverted once submitted. For more information about managing clusters, go to &lt;a href&#x3D;\&quot;https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html\&quot;&gt;Amazon Redshift Clusters&lt;/a&gt; in the &lt;i&gt;Amazon Redshift Cluster Management Guide&lt;/i&gt;.&lt;/p&gt; &lt;p&gt;If you want to shut down the cluster and retain it for future use, set &lt;i&gt;SkipFinalClusterSnapshot&lt;/i&gt; to &lt;code&gt;false&lt;/code&gt; and specify a name for &lt;i&gt;FinalClusterSnapshotIdentifier&lt;/i&gt;. You can later restore this snapshot to resume using the cluster. If a final cluster snapshot is requested, the status of the cluster will be \&quot;final-snapshot\&quot; while the snapshot is being taken, then it&#39;s \&quot;deleting\&quot; once Amazon Redshift begins deleting the cluster. &lt;/p&gt; &lt;p&gt; For more information about managing clusters, go to &lt;a href&#x3D;\&quot;https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html\&quot;&gt;Amazon Redshift Clusters&lt;/a&gt; in the &lt;i&gt;Amazon Redshift Cluster Management Guide&lt;/i&gt;.&lt;/p&gt;
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param deleteClusterMessage  (optional)
     * @return DeleteClusterResult
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> ClusterNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> InvalidClusterStateFault </td><td>  -  </td></tr>
        <tr><td> 482 </td><td> ClusterSnapshotAlreadyExistsFault </td><td>  -  </td></tr>
        <tr><td> 483 </td><td> ClusterSnapshotQuotaExceededFault </td><td>  -  </td></tr>
        <tr><td> 484 </td><td> InvalidRetentionPeriodFault </td><td>  -  </td></tr>
     </table>
     */
    public DeleteClusterResult pOSTDeleteCluster(String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, DeleteClusterMessage deleteClusterMessage) throws ApiException {
        ApiResponse<DeleteClusterResult> localVarResp = pOSTDeleteClusterWithHttpInfo(action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, deleteClusterMessage);
        return localVarResp.getData();
    }

    /**
     * 
     * &lt;p&gt;Deletes a previously provisioned cluster without its final snapshot being created. A successful response from the web service indicates that the request was received correctly. Use &lt;a&gt;DescribeClusters&lt;/a&gt; to monitor the status of the deletion. The delete operation cannot be canceled or reverted once submitted. For more information about managing clusters, go to &lt;a href&#x3D;\&quot;https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html\&quot;&gt;Amazon Redshift Clusters&lt;/a&gt; in the &lt;i&gt;Amazon Redshift Cluster Management Guide&lt;/i&gt;.&lt;/p&gt; &lt;p&gt;If you want to shut down the cluster and retain it for future use, set &lt;i&gt;SkipFinalClusterSnapshot&lt;/i&gt; to &lt;code&gt;false&lt;/code&gt; and specify a name for &lt;i&gt;FinalClusterSnapshotIdentifier&lt;/i&gt;. You can later restore this snapshot to resume using the cluster. If a final cluster snapshot is requested, the status of the cluster will be \&quot;final-snapshot\&quot; while the snapshot is being taken, then it&#39;s \&quot;deleting\&quot; once Amazon Redshift begins deleting the cluster. &lt;/p&gt; &lt;p&gt; For more information about managing clusters, go to &lt;a href&#x3D;\&quot;https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html\&quot;&gt;Amazon Redshift Clusters&lt;/a&gt; in the &lt;i&gt;Amazon Redshift Cluster Management Guide&lt;/i&gt;.&lt;/p&gt;
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param deleteClusterMessage  (optional)
     * @return ApiResponse&lt;DeleteClusterResult&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> ClusterNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> InvalidClusterStateFault </td><td>  -  </td></tr>
        <tr><td> 482 </td><td> ClusterSnapshotAlreadyExistsFault </td><td>  -  </td></tr>
        <tr><td> 483 </td><td> ClusterSnapshotQuotaExceededFault </td><td>  -  </td></tr>
        <tr><td> 484 </td><td> InvalidRetentionPeriodFault </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<DeleteClusterResult> pOSTDeleteClusterWithHttpInfo(String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, DeleteClusterMessage deleteClusterMessage) throws ApiException {
        okhttp3.Call localVarCall = pOSTDeleteClusterValidateBeforeCall(action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, deleteClusterMessage, null);
        Type localVarReturnType = new TypeToken<DeleteClusterResult>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     *  (asynchronously)
     * &lt;p&gt;Deletes a previously provisioned cluster without its final snapshot being created. A successful response from the web service indicates that the request was received correctly. Use &lt;a&gt;DescribeClusters&lt;/a&gt; to monitor the status of the deletion. The delete operation cannot be canceled or reverted once submitted. For more information about managing clusters, go to &lt;a href&#x3D;\&quot;https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html\&quot;&gt;Amazon Redshift Clusters&lt;/a&gt; in the &lt;i&gt;Amazon Redshift Cluster Management Guide&lt;/i&gt;.&lt;/p&gt; &lt;p&gt;If you want to shut down the cluster and retain it for future use, set &lt;i&gt;SkipFinalClusterSnapshot&lt;/i&gt; to &lt;code&gt;false&lt;/code&gt; and specify a name for &lt;i&gt;FinalClusterSnapshotIdentifier&lt;/i&gt;. You can later restore this snapshot to resume using the cluster. If a final cluster snapshot is requested, the status of the cluster will be \&quot;final-snapshot\&quot; while the snapshot is being taken, then it&#39;s \&quot;deleting\&quot; once Amazon Redshift begins deleting the cluster. &lt;/p&gt; &lt;p&gt; For more information about managing clusters, go to &lt;a href&#x3D;\&quot;https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html\&quot;&gt;Amazon Redshift Clusters&lt;/a&gt; in the &lt;i&gt;Amazon Redshift Cluster Management Guide&lt;/i&gt;.&lt;/p&gt;
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param deleteClusterMessage  (optional)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> ClusterNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> InvalidClusterStateFault </td><td>  -  </td></tr>
        <tr><td> 482 </td><td> ClusterSnapshotAlreadyExistsFault </td><td>  -  </td></tr>
        <tr><td> 483 </td><td> ClusterSnapshotQuotaExceededFault </td><td>  -  </td></tr>
        <tr><td> 484 </td><td> InvalidRetentionPeriodFault </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call pOSTDeleteClusterAsync(String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, DeleteClusterMessage deleteClusterMessage, final ApiCallback<DeleteClusterResult> _callback) throws ApiException {

        okhttp3.Call localVarCall = pOSTDeleteClusterValidateBeforeCall(action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, deleteClusterMessage, _callback);
        Type localVarReturnType = new TypeToken<DeleteClusterResult>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for pOSTDeleteClusterParameterGroup
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param deleteClusterParameterGroupMessage  (optional)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> InvalidClusterParameterGroupStateFault </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> ClusterParameterGroupNotFoundFault </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call pOSTDeleteClusterParameterGroupCall(String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, DeleteClusterParameterGroupMessage deleteClusterParameterGroupMessage, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = deleteClusterParameterGroupMessage;

        // create path and map variables
        String localVarPath = "/#Action=DeleteClusterParameterGroup";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (action != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("Action", action));
        }

        if (version != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("Version", version));
        }

        if (xAmzContentSha256 != null) {
            localVarHeaderParams.put("X-Amz-Content-Sha256", localVarApiClient.parameterToString(xAmzContentSha256));
        }

        if (xAmzDate != null) {
            localVarHeaderParams.put("X-Amz-Date", localVarApiClient.parameterToString(xAmzDate));
        }

        if (xAmzAlgorithm != null) {
            localVarHeaderParams.put("X-Amz-Algorithm", localVarApiClient.parameterToString(xAmzAlgorithm));
        }

        if (xAmzCredential != null) {
            localVarHeaderParams.put("X-Amz-Credential", localVarApiClient.parameterToString(xAmzCredential));
        }

        if (xAmzSecurityToken != null) {
            localVarHeaderParams.put("X-Amz-Security-Token", localVarApiClient.parameterToString(xAmzSecurityToken));
        }

        if (xAmzSignature != null) {
            localVarHeaderParams.put("X-Amz-Signature", localVarApiClient.parameterToString(xAmzSignature));
        }

        if (xAmzSignedHeaders != null) {
            localVarHeaderParams.put("X-Amz-SignedHeaders", localVarApiClient.parameterToString(xAmzSignedHeaders));
        }

        final String[] localVarAccepts = {
            "text/xml"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            "text/xml"
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "hmac" };
        return localVarApiClient.buildCall(basePath, localVarPath, "POST", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call pOSTDeleteClusterParameterGroupValidateBeforeCall(String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, DeleteClusterParameterGroupMessage deleteClusterParameterGroupMessage, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'action' is set
        if (action == null) {
            throw new ApiException("Missing the required parameter 'action' when calling pOSTDeleteClusterParameterGroup(Async)");
        }

        // verify the required parameter 'version' is set
        if (version == null) {
            throw new ApiException("Missing the required parameter 'version' when calling pOSTDeleteClusterParameterGroup(Async)");
        }

        return pOSTDeleteClusterParameterGroupCall(action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, deleteClusterParameterGroupMessage, _callback);

    }

    /**
     * 
     * &lt;p&gt;Deletes a specified Amazon Redshift parameter group.&lt;/p&gt; &lt;note&gt; &lt;p&gt;You cannot delete a parameter group if it is associated with a cluster.&lt;/p&gt; &lt;/note&gt;
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param deleteClusterParameterGroupMessage  (optional)
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> InvalidClusterParameterGroupStateFault </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> ClusterParameterGroupNotFoundFault </td><td>  -  </td></tr>
     </table>
     */
    public void pOSTDeleteClusterParameterGroup(String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, DeleteClusterParameterGroupMessage deleteClusterParameterGroupMessage) throws ApiException {
        pOSTDeleteClusterParameterGroupWithHttpInfo(action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, deleteClusterParameterGroupMessage);
    }

    /**
     * 
     * &lt;p&gt;Deletes a specified Amazon Redshift parameter group.&lt;/p&gt; &lt;note&gt; &lt;p&gt;You cannot delete a parameter group if it is associated with a cluster.&lt;/p&gt; &lt;/note&gt;
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param deleteClusterParameterGroupMessage  (optional)
     * @return ApiResponse&lt;Void&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> InvalidClusterParameterGroupStateFault </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> ClusterParameterGroupNotFoundFault </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<Void> pOSTDeleteClusterParameterGroupWithHttpInfo(String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, DeleteClusterParameterGroupMessage deleteClusterParameterGroupMessage) throws ApiException {
        okhttp3.Call localVarCall = pOSTDeleteClusterParameterGroupValidateBeforeCall(action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, deleteClusterParameterGroupMessage, null);
        return localVarApiClient.execute(localVarCall);
    }

    /**
     *  (asynchronously)
     * &lt;p&gt;Deletes a specified Amazon Redshift parameter group.&lt;/p&gt; &lt;note&gt; &lt;p&gt;You cannot delete a parameter group if it is associated with a cluster.&lt;/p&gt; &lt;/note&gt;
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param deleteClusterParameterGroupMessage  (optional)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> InvalidClusterParameterGroupStateFault </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> ClusterParameterGroupNotFoundFault </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call pOSTDeleteClusterParameterGroupAsync(String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, DeleteClusterParameterGroupMessage deleteClusterParameterGroupMessage, final ApiCallback<Void> _callback) throws ApiException {

        okhttp3.Call localVarCall = pOSTDeleteClusterParameterGroupValidateBeforeCall(action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, deleteClusterParameterGroupMessage, _callback);
        localVarApiClient.executeAsync(localVarCall, _callback);
        return localVarCall;
    }
    /**
     * Build call for pOSTDeleteClusterSecurityGroup
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param deleteClusterSecurityGroupMessage  (optional)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> InvalidClusterSecurityGroupStateFault </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> ClusterSecurityGroupNotFoundFault </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call pOSTDeleteClusterSecurityGroupCall(String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, DeleteClusterSecurityGroupMessage deleteClusterSecurityGroupMessage, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = deleteClusterSecurityGroupMessage;

        // create path and map variables
        String localVarPath = "/#Action=DeleteClusterSecurityGroup";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (action != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("Action", action));
        }

        if (version != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("Version", version));
        }

        if (xAmzContentSha256 != null) {
            localVarHeaderParams.put("X-Amz-Content-Sha256", localVarApiClient.parameterToString(xAmzContentSha256));
        }

        if (xAmzDate != null) {
            localVarHeaderParams.put("X-Amz-Date", localVarApiClient.parameterToString(xAmzDate));
        }

        if (xAmzAlgorithm != null) {
            localVarHeaderParams.put("X-Amz-Algorithm", localVarApiClient.parameterToString(xAmzAlgorithm));
        }

        if (xAmzCredential != null) {
            localVarHeaderParams.put("X-Amz-Credential", localVarApiClient.parameterToString(xAmzCredential));
        }

        if (xAmzSecurityToken != null) {
            localVarHeaderParams.put("X-Amz-Security-Token", localVarApiClient.parameterToString(xAmzSecurityToken));
        }

        if (xAmzSignature != null) {
            localVarHeaderParams.put("X-Amz-Signature", localVarApiClient.parameterToString(xAmzSignature));
        }

        if (xAmzSignedHeaders != null) {
            localVarHeaderParams.put("X-Amz-SignedHeaders", localVarApiClient.parameterToString(xAmzSignedHeaders));
        }

        final String[] localVarAccepts = {
            "text/xml"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            "text/xml"
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "hmac" };
        return localVarApiClient.buildCall(basePath, localVarPath, "POST", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call pOSTDeleteClusterSecurityGroupValidateBeforeCall(String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, DeleteClusterSecurityGroupMessage deleteClusterSecurityGroupMessage, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'action' is set
        if (action == null) {
            throw new ApiException("Missing the required parameter 'action' when calling pOSTDeleteClusterSecurityGroup(Async)");
        }

        // verify the required parameter 'version' is set
        if (version == null) {
            throw new ApiException("Missing the required parameter 'version' when calling pOSTDeleteClusterSecurityGroup(Async)");
        }

        return pOSTDeleteClusterSecurityGroupCall(action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, deleteClusterSecurityGroupMessage, _callback);

    }

    /**
     * 
     * &lt;p&gt;Deletes an Amazon Redshift security group.&lt;/p&gt; &lt;note&gt; &lt;p&gt;You cannot delete a security group that is associated with any clusters. You cannot delete the default security group.&lt;/p&gt; &lt;/note&gt; &lt;p&gt; For information about managing security groups, go to &lt;a href&#x3D;\&quot;https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-security-groups.html\&quot;&gt;Amazon Redshift Cluster Security Groups&lt;/a&gt; in the &lt;i&gt;Amazon Redshift Cluster Management Guide&lt;/i&gt;.&lt;/p&gt;
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param deleteClusterSecurityGroupMessage  (optional)
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> InvalidClusterSecurityGroupStateFault </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> ClusterSecurityGroupNotFoundFault </td><td>  -  </td></tr>
     </table>
     */
    public void pOSTDeleteClusterSecurityGroup(String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, DeleteClusterSecurityGroupMessage deleteClusterSecurityGroupMessage) throws ApiException {
        pOSTDeleteClusterSecurityGroupWithHttpInfo(action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, deleteClusterSecurityGroupMessage);
    }

    /**
     * 
     * &lt;p&gt;Deletes an Amazon Redshift security group.&lt;/p&gt; &lt;note&gt; &lt;p&gt;You cannot delete a security group that is associated with any clusters. You cannot delete the default security group.&lt;/p&gt; &lt;/note&gt; &lt;p&gt; For information about managing security groups, go to &lt;a href&#x3D;\&quot;https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-security-groups.html\&quot;&gt;Amazon Redshift Cluster Security Groups&lt;/a&gt; in the &lt;i&gt;Amazon Redshift Cluster Management Guide&lt;/i&gt;.&lt;/p&gt;
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param deleteClusterSecurityGroupMessage  (optional)
     * @return ApiResponse&lt;Void&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> InvalidClusterSecurityGroupStateFault </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> ClusterSecurityGroupNotFoundFault </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<Void> pOSTDeleteClusterSecurityGroupWithHttpInfo(String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, DeleteClusterSecurityGroupMessage deleteClusterSecurityGroupMessage) throws ApiException {
        okhttp3.Call localVarCall = pOSTDeleteClusterSecurityGroupValidateBeforeCall(action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, deleteClusterSecurityGroupMessage, null);
        return localVarApiClient.execute(localVarCall);
    }

    /**
     *  (asynchronously)
     * &lt;p&gt;Deletes an Amazon Redshift security group.&lt;/p&gt; &lt;note&gt; &lt;p&gt;You cannot delete a security group that is associated with any clusters. You cannot delete the default security group.&lt;/p&gt; &lt;/note&gt; &lt;p&gt; For information about managing security groups, go to &lt;a href&#x3D;\&quot;https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-security-groups.html\&quot;&gt;Amazon Redshift Cluster Security Groups&lt;/a&gt; in the &lt;i&gt;Amazon Redshift Cluster Management Guide&lt;/i&gt;.&lt;/p&gt;
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param deleteClusterSecurityGroupMessage  (optional)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> InvalidClusterSecurityGroupStateFault </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> ClusterSecurityGroupNotFoundFault </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call pOSTDeleteClusterSecurityGroupAsync(String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, DeleteClusterSecurityGroupMessage deleteClusterSecurityGroupMessage, final ApiCallback<Void> _callback) throws ApiException {

        okhttp3.Call localVarCall = pOSTDeleteClusterSecurityGroupValidateBeforeCall(action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, deleteClusterSecurityGroupMessage, _callback);
        localVarApiClient.executeAsync(localVarCall, _callback);
        return localVarCall;
    }
    /**
     * Build call for pOSTDeleteClusterSnapshot
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param deleteClusterSnapshotMessage  (optional)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> InvalidClusterSnapshotStateFault </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> ClusterSnapshotNotFoundFault </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call pOSTDeleteClusterSnapshotCall(String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, DeleteClusterSnapshotMessage deleteClusterSnapshotMessage, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = deleteClusterSnapshotMessage;

        // create path and map variables
        String localVarPath = "/#Action=DeleteClusterSnapshot";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (action != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("Action", action));
        }

        if (version != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("Version", version));
        }

        if (xAmzContentSha256 != null) {
            localVarHeaderParams.put("X-Amz-Content-Sha256", localVarApiClient.parameterToString(xAmzContentSha256));
        }

        if (xAmzDate != null) {
            localVarHeaderParams.put("X-Amz-Date", localVarApiClient.parameterToString(xAmzDate));
        }

        if (xAmzAlgorithm != null) {
            localVarHeaderParams.put("X-Amz-Algorithm", localVarApiClient.parameterToString(xAmzAlgorithm));
        }

        if (xAmzCredential != null) {
            localVarHeaderParams.put("X-Amz-Credential", localVarApiClient.parameterToString(xAmzCredential));
        }

        if (xAmzSecurityToken != null) {
            localVarHeaderParams.put("X-Amz-Security-Token", localVarApiClient.parameterToString(xAmzSecurityToken));
        }

        if (xAmzSignature != null) {
            localVarHeaderParams.put("X-Amz-Signature", localVarApiClient.parameterToString(xAmzSignature));
        }

        if (xAmzSignedHeaders != null) {
            localVarHeaderParams.put("X-Amz-SignedHeaders", localVarApiClient.parameterToString(xAmzSignedHeaders));
        }

        final String[] localVarAccepts = {
            "text/xml"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            "text/xml"
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "hmac" };
        return localVarApiClient.buildCall(basePath, localVarPath, "POST", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call pOSTDeleteClusterSnapshotValidateBeforeCall(String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, DeleteClusterSnapshotMessage deleteClusterSnapshotMessage, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'action' is set
        if (action == null) {
            throw new ApiException("Missing the required parameter 'action' when calling pOSTDeleteClusterSnapshot(Async)");
        }

        // verify the required parameter 'version' is set
        if (version == null) {
            throw new ApiException("Missing the required parameter 'version' when calling pOSTDeleteClusterSnapshot(Async)");
        }

        return pOSTDeleteClusterSnapshotCall(action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, deleteClusterSnapshotMessage, _callback);

    }

    /**
     * 
     * &lt;p&gt;Deletes the specified manual snapshot. The snapshot must be in the &lt;code&gt;available&lt;/code&gt; state, with no other users authorized to access the snapshot. &lt;/p&gt; &lt;p&gt;Unlike automated snapshots, manual snapshots are retained even after you delete your cluster. Amazon Redshift does not delete your manual snapshots. You must delete manual snapshot explicitly to avoid getting charged. If other accounts are authorized to access the snapshot, you must revoke all of the authorizations before you can delete the snapshot.&lt;/p&gt;
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param deleteClusterSnapshotMessage  (optional)
     * @return DeleteClusterSnapshotResult
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> InvalidClusterSnapshotStateFault </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> ClusterSnapshotNotFoundFault </td><td>  -  </td></tr>
     </table>
     */
    public DeleteClusterSnapshotResult pOSTDeleteClusterSnapshot(String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, DeleteClusterSnapshotMessage deleteClusterSnapshotMessage) throws ApiException {
        ApiResponse<DeleteClusterSnapshotResult> localVarResp = pOSTDeleteClusterSnapshotWithHttpInfo(action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, deleteClusterSnapshotMessage);
        return localVarResp.getData();
    }

    /**
     * 
     * &lt;p&gt;Deletes the specified manual snapshot. The snapshot must be in the &lt;code&gt;available&lt;/code&gt; state, with no other users authorized to access the snapshot. &lt;/p&gt; &lt;p&gt;Unlike automated snapshots, manual snapshots are retained even after you delete your cluster. Amazon Redshift does not delete your manual snapshots. You must delete manual snapshot explicitly to avoid getting charged. If other accounts are authorized to access the snapshot, you must revoke all of the authorizations before you can delete the snapshot.&lt;/p&gt;
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param deleteClusterSnapshotMessage  (optional)
     * @return ApiResponse&lt;DeleteClusterSnapshotResult&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> InvalidClusterSnapshotStateFault </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> ClusterSnapshotNotFoundFault </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<DeleteClusterSnapshotResult> pOSTDeleteClusterSnapshotWithHttpInfo(String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, DeleteClusterSnapshotMessage deleteClusterSnapshotMessage) throws ApiException {
        okhttp3.Call localVarCall = pOSTDeleteClusterSnapshotValidateBeforeCall(action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, deleteClusterSnapshotMessage, null);
        Type localVarReturnType = new TypeToken<DeleteClusterSnapshotResult>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     *  (asynchronously)
     * &lt;p&gt;Deletes the specified manual snapshot. The snapshot must be in the &lt;code&gt;available&lt;/code&gt; state, with no other users authorized to access the snapshot. &lt;/p&gt; &lt;p&gt;Unlike automated snapshots, manual snapshots are retained even after you delete your cluster. Amazon Redshift does not delete your manual snapshots. You must delete manual snapshot explicitly to avoid getting charged. If other accounts are authorized to access the snapshot, you must revoke all of the authorizations before you can delete the snapshot.&lt;/p&gt;
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param deleteClusterSnapshotMessage  (optional)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> InvalidClusterSnapshotStateFault </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> ClusterSnapshotNotFoundFault </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call pOSTDeleteClusterSnapshotAsync(String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, DeleteClusterSnapshotMessage deleteClusterSnapshotMessage, final ApiCallback<DeleteClusterSnapshotResult> _callback) throws ApiException {

        okhttp3.Call localVarCall = pOSTDeleteClusterSnapshotValidateBeforeCall(action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, deleteClusterSnapshotMessage, _callback);
        Type localVarReturnType = new TypeToken<DeleteClusterSnapshotResult>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for pOSTDeleteClusterSubnetGroup
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param deleteClusterSubnetGroupMessage  (optional)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> InvalidClusterSubnetGroupStateFault </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> InvalidClusterSubnetStateFault </td><td>  -  </td></tr>
        <tr><td> 482 </td><td> ClusterSubnetGroupNotFoundFault </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call pOSTDeleteClusterSubnetGroupCall(String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, DeleteClusterSubnetGroupMessage deleteClusterSubnetGroupMessage, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = deleteClusterSubnetGroupMessage;

        // create path and map variables
        String localVarPath = "/#Action=DeleteClusterSubnetGroup";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (action != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("Action", action));
        }

        if (version != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("Version", version));
        }

        if (xAmzContentSha256 != null) {
            localVarHeaderParams.put("X-Amz-Content-Sha256", localVarApiClient.parameterToString(xAmzContentSha256));
        }

        if (xAmzDate != null) {
            localVarHeaderParams.put("X-Amz-Date", localVarApiClient.parameterToString(xAmzDate));
        }

        if (xAmzAlgorithm != null) {
            localVarHeaderParams.put("X-Amz-Algorithm", localVarApiClient.parameterToString(xAmzAlgorithm));
        }

        if (xAmzCredential != null) {
            localVarHeaderParams.put("X-Amz-Credential", localVarApiClient.parameterToString(xAmzCredential));
        }

        if (xAmzSecurityToken != null) {
            localVarHeaderParams.put("X-Amz-Security-Token", localVarApiClient.parameterToString(xAmzSecurityToken));
        }

        if (xAmzSignature != null) {
            localVarHeaderParams.put("X-Amz-Signature", localVarApiClient.parameterToString(xAmzSignature));
        }

        if (xAmzSignedHeaders != null) {
            localVarHeaderParams.put("X-Amz-SignedHeaders", localVarApiClient.parameterToString(xAmzSignedHeaders));
        }

        final String[] localVarAccepts = {
            "text/xml"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            "text/xml"
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "hmac" };
        return localVarApiClient.buildCall(basePath, localVarPath, "POST", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call pOSTDeleteClusterSubnetGroupValidateBeforeCall(String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, DeleteClusterSubnetGroupMessage deleteClusterSubnetGroupMessage, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'action' is set
        if (action == null) {
            throw new ApiException("Missing the required parameter 'action' when calling pOSTDeleteClusterSubnetGroup(Async)");
        }

        // verify the required parameter 'version' is set
        if (version == null) {
            throw new ApiException("Missing the required parameter 'version' when calling pOSTDeleteClusterSubnetGroup(Async)");
        }

        return pOSTDeleteClusterSubnetGroupCall(action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, deleteClusterSubnetGroupMessage, _callback);

    }

    /**
     * 
     * Deletes the specified cluster subnet group.
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param deleteClusterSubnetGroupMessage  (optional)
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> InvalidClusterSubnetGroupStateFault </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> InvalidClusterSubnetStateFault </td><td>  -  </td></tr>
        <tr><td> 482 </td><td> ClusterSubnetGroupNotFoundFault </td><td>  -  </td></tr>
     </table>
     */
    public void pOSTDeleteClusterSubnetGroup(String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, DeleteClusterSubnetGroupMessage deleteClusterSubnetGroupMessage) throws ApiException {
        pOSTDeleteClusterSubnetGroupWithHttpInfo(action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, deleteClusterSubnetGroupMessage);
    }

    /**
     * 
     * Deletes the specified cluster subnet group.
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param deleteClusterSubnetGroupMessage  (optional)
     * @return ApiResponse&lt;Void&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> InvalidClusterSubnetGroupStateFault </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> InvalidClusterSubnetStateFault </td><td>  -  </td></tr>
        <tr><td> 482 </td><td> ClusterSubnetGroupNotFoundFault </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<Void> pOSTDeleteClusterSubnetGroupWithHttpInfo(String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, DeleteClusterSubnetGroupMessage deleteClusterSubnetGroupMessage) throws ApiException {
        okhttp3.Call localVarCall = pOSTDeleteClusterSubnetGroupValidateBeforeCall(action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, deleteClusterSubnetGroupMessage, null);
        return localVarApiClient.execute(localVarCall);
    }

    /**
     *  (asynchronously)
     * Deletes the specified cluster subnet group.
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param deleteClusterSubnetGroupMessage  (optional)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> InvalidClusterSubnetGroupStateFault </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> InvalidClusterSubnetStateFault </td><td>  -  </td></tr>
        <tr><td> 482 </td><td> ClusterSubnetGroupNotFoundFault </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call pOSTDeleteClusterSubnetGroupAsync(String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, DeleteClusterSubnetGroupMessage deleteClusterSubnetGroupMessage, final ApiCallback<Void> _callback) throws ApiException {

        okhttp3.Call localVarCall = pOSTDeleteClusterSubnetGroupValidateBeforeCall(action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, deleteClusterSubnetGroupMessage, _callback);
        localVarApiClient.executeAsync(localVarCall, _callback);
        return localVarCall;
    }
    /**
     * Build call for pOSTDeleteCustomDomainAssociation
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param deleteCustomDomainAssociationMessage  (optional)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> UnsupportedOperationFault </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> ClusterNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 482 </td><td> CustomCnameAssociationFault </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call pOSTDeleteCustomDomainAssociationCall(String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, DeleteCustomDomainAssociationMessage deleteCustomDomainAssociationMessage, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = deleteCustomDomainAssociationMessage;

        // create path and map variables
        String localVarPath = "/#Action=DeleteCustomDomainAssociation";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (action != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("Action", action));
        }

        if (version != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("Version", version));
        }

        if (xAmzContentSha256 != null) {
            localVarHeaderParams.put("X-Amz-Content-Sha256", localVarApiClient.parameterToString(xAmzContentSha256));
        }

        if (xAmzDate != null) {
            localVarHeaderParams.put("X-Amz-Date", localVarApiClient.parameterToString(xAmzDate));
        }

        if (xAmzAlgorithm != null) {
            localVarHeaderParams.put("X-Amz-Algorithm", localVarApiClient.parameterToString(xAmzAlgorithm));
        }

        if (xAmzCredential != null) {
            localVarHeaderParams.put("X-Amz-Credential", localVarApiClient.parameterToString(xAmzCredential));
        }

        if (xAmzSecurityToken != null) {
            localVarHeaderParams.put("X-Amz-Security-Token", localVarApiClient.parameterToString(xAmzSecurityToken));
        }

        if (xAmzSignature != null) {
            localVarHeaderParams.put("X-Amz-Signature", localVarApiClient.parameterToString(xAmzSignature));
        }

        if (xAmzSignedHeaders != null) {
            localVarHeaderParams.put("X-Amz-SignedHeaders", localVarApiClient.parameterToString(xAmzSignedHeaders));
        }

        final String[] localVarAccepts = {
            "text/xml"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            "text/xml"
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "hmac" };
        return localVarApiClient.buildCall(basePath, localVarPath, "POST", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call pOSTDeleteCustomDomainAssociationValidateBeforeCall(String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, DeleteCustomDomainAssociationMessage deleteCustomDomainAssociationMessage, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'action' is set
        if (action == null) {
            throw new ApiException("Missing the required parameter 'action' when calling pOSTDeleteCustomDomainAssociation(Async)");
        }

        // verify the required parameter 'version' is set
        if (version == null) {
            throw new ApiException("Missing the required parameter 'version' when calling pOSTDeleteCustomDomainAssociation(Async)");
        }

        return pOSTDeleteCustomDomainAssociationCall(action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, deleteCustomDomainAssociationMessage, _callback);

    }

    /**
     * 
     * Contains information about deleting a custom domain association for a cluster.
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param deleteCustomDomainAssociationMessage  (optional)
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> UnsupportedOperationFault </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> ClusterNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 482 </td><td> CustomCnameAssociationFault </td><td>  -  </td></tr>
     </table>
     */
    public void pOSTDeleteCustomDomainAssociation(String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, DeleteCustomDomainAssociationMessage deleteCustomDomainAssociationMessage) throws ApiException {
        pOSTDeleteCustomDomainAssociationWithHttpInfo(action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, deleteCustomDomainAssociationMessage);
    }

    /**
     * 
     * Contains information about deleting a custom domain association for a cluster.
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param deleteCustomDomainAssociationMessage  (optional)
     * @return ApiResponse&lt;Void&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> UnsupportedOperationFault </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> ClusterNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 482 </td><td> CustomCnameAssociationFault </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<Void> pOSTDeleteCustomDomainAssociationWithHttpInfo(String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, DeleteCustomDomainAssociationMessage deleteCustomDomainAssociationMessage) throws ApiException {
        okhttp3.Call localVarCall = pOSTDeleteCustomDomainAssociationValidateBeforeCall(action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, deleteCustomDomainAssociationMessage, null);
        return localVarApiClient.execute(localVarCall);
    }

    /**
     *  (asynchronously)
     * Contains information about deleting a custom domain association for a cluster.
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param deleteCustomDomainAssociationMessage  (optional)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> UnsupportedOperationFault </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> ClusterNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 482 </td><td> CustomCnameAssociationFault </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call pOSTDeleteCustomDomainAssociationAsync(String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, DeleteCustomDomainAssociationMessage deleteCustomDomainAssociationMessage, final ApiCallback<Void> _callback) throws ApiException {

        okhttp3.Call localVarCall = pOSTDeleteCustomDomainAssociationValidateBeforeCall(action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, deleteCustomDomainAssociationMessage, _callback);
        localVarApiClient.executeAsync(localVarCall, _callback);
        return localVarCall;
    }
    /**
     * Build call for pOSTDeleteEndpointAccess
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param deleteEndpointAccessMessage  (optional)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> ClusterNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> InvalidEndpointStateFault </td><td>  -  </td></tr>
        <tr><td> 482 </td><td> InvalidClusterSecurityGroupStateFault </td><td>  -  </td></tr>
        <tr><td> 483 </td><td> EndpointNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 484 </td><td> InvalidClusterStateFault </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call pOSTDeleteEndpointAccessCall(String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, DeleteEndpointAccessMessage deleteEndpointAccessMessage, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = deleteEndpointAccessMessage;

        // create path and map variables
        String localVarPath = "/#Action=DeleteEndpointAccess";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (action != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("Action", action));
        }

        if (version != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("Version", version));
        }

        if (xAmzContentSha256 != null) {
            localVarHeaderParams.put("X-Amz-Content-Sha256", localVarApiClient.parameterToString(xAmzContentSha256));
        }

        if (xAmzDate != null) {
            localVarHeaderParams.put("X-Amz-Date", localVarApiClient.parameterToString(xAmzDate));
        }

        if (xAmzAlgorithm != null) {
            localVarHeaderParams.put("X-Amz-Algorithm", localVarApiClient.parameterToString(xAmzAlgorithm));
        }

        if (xAmzCredential != null) {
            localVarHeaderParams.put("X-Amz-Credential", localVarApiClient.parameterToString(xAmzCredential));
        }

        if (xAmzSecurityToken != null) {
            localVarHeaderParams.put("X-Amz-Security-Token", localVarApiClient.parameterToString(xAmzSecurityToken));
        }

        if (xAmzSignature != null) {
            localVarHeaderParams.put("X-Amz-Signature", localVarApiClient.parameterToString(xAmzSignature));
        }

        if (xAmzSignedHeaders != null) {
            localVarHeaderParams.put("X-Amz-SignedHeaders", localVarApiClient.parameterToString(xAmzSignedHeaders));
        }

        final String[] localVarAccepts = {
            "text/xml"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            "text/xml"
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "hmac" };
        return localVarApiClient.buildCall(basePath, localVarPath, "POST", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call pOSTDeleteEndpointAccessValidateBeforeCall(String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, DeleteEndpointAccessMessage deleteEndpointAccessMessage, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'action' is set
        if (action == null) {
            throw new ApiException("Missing the required parameter 'action' when calling pOSTDeleteEndpointAccess(Async)");
        }

        // verify the required parameter 'version' is set
        if (version == null) {
            throw new ApiException("Missing the required parameter 'version' when calling pOSTDeleteEndpointAccess(Async)");
        }

        return pOSTDeleteEndpointAccessCall(action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, deleteEndpointAccessMessage, _callback);

    }

    /**
     * 
     * Deletes a Redshift-managed VPC endpoint.
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param deleteEndpointAccessMessage  (optional)
     * @return EndpointAccess
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> ClusterNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> InvalidEndpointStateFault </td><td>  -  </td></tr>
        <tr><td> 482 </td><td> InvalidClusterSecurityGroupStateFault </td><td>  -  </td></tr>
        <tr><td> 483 </td><td> EndpointNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 484 </td><td> InvalidClusterStateFault </td><td>  -  </td></tr>
     </table>
     */
    public EndpointAccess pOSTDeleteEndpointAccess(String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, DeleteEndpointAccessMessage deleteEndpointAccessMessage) throws ApiException {
        ApiResponse<EndpointAccess> localVarResp = pOSTDeleteEndpointAccessWithHttpInfo(action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, deleteEndpointAccessMessage);
        return localVarResp.getData();
    }

    /**
     * 
     * Deletes a Redshift-managed VPC endpoint.
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param deleteEndpointAccessMessage  (optional)
     * @return ApiResponse&lt;EndpointAccess&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> ClusterNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> InvalidEndpointStateFault </td><td>  -  </td></tr>
        <tr><td> 482 </td><td> InvalidClusterSecurityGroupStateFault </td><td>  -  </td></tr>
        <tr><td> 483 </td><td> EndpointNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 484 </td><td> InvalidClusterStateFault </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<EndpointAccess> pOSTDeleteEndpointAccessWithHttpInfo(String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, DeleteEndpointAccessMessage deleteEndpointAccessMessage) throws ApiException {
        okhttp3.Call localVarCall = pOSTDeleteEndpointAccessValidateBeforeCall(action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, deleteEndpointAccessMessage, null);
        Type localVarReturnType = new TypeToken<EndpointAccess>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     *  (asynchronously)
     * Deletes a Redshift-managed VPC endpoint.
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param deleteEndpointAccessMessage  (optional)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> ClusterNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> InvalidEndpointStateFault </td><td>  -  </td></tr>
        <tr><td> 482 </td><td> InvalidClusterSecurityGroupStateFault </td><td>  -  </td></tr>
        <tr><td> 483 </td><td> EndpointNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 484 </td><td> InvalidClusterStateFault </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call pOSTDeleteEndpointAccessAsync(String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, DeleteEndpointAccessMessage deleteEndpointAccessMessage, final ApiCallback<EndpointAccess> _callback) throws ApiException {

        okhttp3.Call localVarCall = pOSTDeleteEndpointAccessValidateBeforeCall(action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, deleteEndpointAccessMessage, _callback);
        Type localVarReturnType = new TypeToken<EndpointAccess>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for pOSTDeleteEventSubscription
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param deleteEventSubscriptionMessage  (optional)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> SubscriptionNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> InvalidSubscriptionStateFault </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call pOSTDeleteEventSubscriptionCall(String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, DeleteEventSubscriptionMessage deleteEventSubscriptionMessage, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = deleteEventSubscriptionMessage;

        // create path and map variables
        String localVarPath = "/#Action=DeleteEventSubscription";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (action != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("Action", action));
        }

        if (version != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("Version", version));
        }

        if (xAmzContentSha256 != null) {
            localVarHeaderParams.put("X-Amz-Content-Sha256", localVarApiClient.parameterToString(xAmzContentSha256));
        }

        if (xAmzDate != null) {
            localVarHeaderParams.put("X-Amz-Date", localVarApiClient.parameterToString(xAmzDate));
        }

        if (xAmzAlgorithm != null) {
            localVarHeaderParams.put("X-Amz-Algorithm", localVarApiClient.parameterToString(xAmzAlgorithm));
        }

        if (xAmzCredential != null) {
            localVarHeaderParams.put("X-Amz-Credential", localVarApiClient.parameterToString(xAmzCredential));
        }

        if (xAmzSecurityToken != null) {
            localVarHeaderParams.put("X-Amz-Security-Token", localVarApiClient.parameterToString(xAmzSecurityToken));
        }

        if (xAmzSignature != null) {
            localVarHeaderParams.put("X-Amz-Signature", localVarApiClient.parameterToString(xAmzSignature));
        }

        if (xAmzSignedHeaders != null) {
            localVarHeaderParams.put("X-Amz-SignedHeaders", localVarApiClient.parameterToString(xAmzSignedHeaders));
        }

        final String[] localVarAccepts = {
            "text/xml"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            "text/xml"
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "hmac" };
        return localVarApiClient.buildCall(basePath, localVarPath, "POST", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call pOSTDeleteEventSubscriptionValidateBeforeCall(String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, DeleteEventSubscriptionMessage deleteEventSubscriptionMessage, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'action' is set
        if (action == null) {
            throw new ApiException("Missing the required parameter 'action' when calling pOSTDeleteEventSubscription(Async)");
        }

        // verify the required parameter 'version' is set
        if (version == null) {
            throw new ApiException("Missing the required parameter 'version' when calling pOSTDeleteEventSubscription(Async)");
        }

        return pOSTDeleteEventSubscriptionCall(action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, deleteEventSubscriptionMessage, _callback);

    }

    /**
     * 
     * Deletes an Amazon Redshift event notification subscription.
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param deleteEventSubscriptionMessage  (optional)
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> SubscriptionNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> InvalidSubscriptionStateFault </td><td>  -  </td></tr>
     </table>
     */
    public void pOSTDeleteEventSubscription(String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, DeleteEventSubscriptionMessage deleteEventSubscriptionMessage) throws ApiException {
        pOSTDeleteEventSubscriptionWithHttpInfo(action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, deleteEventSubscriptionMessage);
    }

    /**
     * 
     * Deletes an Amazon Redshift event notification subscription.
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param deleteEventSubscriptionMessage  (optional)
     * @return ApiResponse&lt;Void&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> SubscriptionNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> InvalidSubscriptionStateFault </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<Void> pOSTDeleteEventSubscriptionWithHttpInfo(String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, DeleteEventSubscriptionMessage deleteEventSubscriptionMessage) throws ApiException {
        okhttp3.Call localVarCall = pOSTDeleteEventSubscriptionValidateBeforeCall(action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, deleteEventSubscriptionMessage, null);
        return localVarApiClient.execute(localVarCall);
    }

    /**
     *  (asynchronously)
     * Deletes an Amazon Redshift event notification subscription.
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param deleteEventSubscriptionMessage  (optional)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> SubscriptionNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> InvalidSubscriptionStateFault </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call pOSTDeleteEventSubscriptionAsync(String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, DeleteEventSubscriptionMessage deleteEventSubscriptionMessage, final ApiCallback<Void> _callback) throws ApiException {

        okhttp3.Call localVarCall = pOSTDeleteEventSubscriptionValidateBeforeCall(action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, deleteEventSubscriptionMessage, _callback);
        localVarApiClient.executeAsync(localVarCall, _callback);
        return localVarCall;
    }
    /**
     * Build call for pOSTDeleteHsmClientCertificate
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param deleteHsmClientCertificateMessage  (optional)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> InvalidHsmClientCertificateStateFault </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> HsmClientCertificateNotFoundFault </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call pOSTDeleteHsmClientCertificateCall(String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, DeleteHsmClientCertificateMessage deleteHsmClientCertificateMessage, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = deleteHsmClientCertificateMessage;

        // create path and map variables
        String localVarPath = "/#Action=DeleteHsmClientCertificate";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (action != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("Action", action));
        }

        if (version != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("Version", version));
        }

        if (xAmzContentSha256 != null) {
            localVarHeaderParams.put("X-Amz-Content-Sha256", localVarApiClient.parameterToString(xAmzContentSha256));
        }

        if (xAmzDate != null) {
            localVarHeaderParams.put("X-Amz-Date", localVarApiClient.parameterToString(xAmzDate));
        }

        if (xAmzAlgorithm != null) {
            localVarHeaderParams.put("X-Amz-Algorithm", localVarApiClient.parameterToString(xAmzAlgorithm));
        }

        if (xAmzCredential != null) {
            localVarHeaderParams.put("X-Amz-Credential", localVarApiClient.parameterToString(xAmzCredential));
        }

        if (xAmzSecurityToken != null) {
            localVarHeaderParams.put("X-Amz-Security-Token", localVarApiClient.parameterToString(xAmzSecurityToken));
        }

        if (xAmzSignature != null) {
            localVarHeaderParams.put("X-Amz-Signature", localVarApiClient.parameterToString(xAmzSignature));
        }

        if (xAmzSignedHeaders != null) {
            localVarHeaderParams.put("X-Amz-SignedHeaders", localVarApiClient.parameterToString(xAmzSignedHeaders));
        }

        final String[] localVarAccepts = {
            "text/xml"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            "text/xml"
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "hmac" };
        return localVarApiClient.buildCall(basePath, localVarPath, "POST", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call pOSTDeleteHsmClientCertificateValidateBeforeCall(String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, DeleteHsmClientCertificateMessage deleteHsmClientCertificateMessage, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'action' is set
        if (action == null) {
            throw new ApiException("Missing the required parameter 'action' when calling pOSTDeleteHsmClientCertificate(Async)");
        }

        // verify the required parameter 'version' is set
        if (version == null) {
            throw new ApiException("Missing the required parameter 'version' when calling pOSTDeleteHsmClientCertificate(Async)");
        }

        return pOSTDeleteHsmClientCertificateCall(action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, deleteHsmClientCertificateMessage, _callback);

    }

    /**
     * 
     * Deletes the specified HSM client certificate.
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param deleteHsmClientCertificateMessage  (optional)
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> InvalidHsmClientCertificateStateFault </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> HsmClientCertificateNotFoundFault </td><td>  -  </td></tr>
     </table>
     */
    public void pOSTDeleteHsmClientCertificate(String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, DeleteHsmClientCertificateMessage deleteHsmClientCertificateMessage) throws ApiException {
        pOSTDeleteHsmClientCertificateWithHttpInfo(action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, deleteHsmClientCertificateMessage);
    }

    /**
     * 
     * Deletes the specified HSM client certificate.
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param deleteHsmClientCertificateMessage  (optional)
     * @return ApiResponse&lt;Void&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> InvalidHsmClientCertificateStateFault </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> HsmClientCertificateNotFoundFault </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<Void> pOSTDeleteHsmClientCertificateWithHttpInfo(String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, DeleteHsmClientCertificateMessage deleteHsmClientCertificateMessage) throws ApiException {
        okhttp3.Call localVarCall = pOSTDeleteHsmClientCertificateValidateBeforeCall(action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, deleteHsmClientCertificateMessage, null);
        return localVarApiClient.execute(localVarCall);
    }

    /**
     *  (asynchronously)
     * Deletes the specified HSM client certificate.
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param deleteHsmClientCertificateMessage  (optional)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> InvalidHsmClientCertificateStateFault </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> HsmClientCertificateNotFoundFault </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call pOSTDeleteHsmClientCertificateAsync(String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, DeleteHsmClientCertificateMessage deleteHsmClientCertificateMessage, final ApiCallback<Void> _callback) throws ApiException {

        okhttp3.Call localVarCall = pOSTDeleteHsmClientCertificateValidateBeforeCall(action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, deleteHsmClientCertificateMessage, _callback);
        localVarApiClient.executeAsync(localVarCall, _callback);
        return localVarCall;
    }
    /**
     * Build call for pOSTDeleteHsmConfiguration
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param deleteHsmConfigurationMessage  (optional)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> InvalidHsmConfigurationStateFault </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> HsmConfigurationNotFoundFault </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call pOSTDeleteHsmConfigurationCall(String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, DeleteHsmConfigurationMessage deleteHsmConfigurationMessage, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = deleteHsmConfigurationMessage;

        // create path and map variables
        String localVarPath = "/#Action=DeleteHsmConfiguration";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (action != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("Action", action));
        }

        if (version != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("Version", version));
        }

        if (xAmzContentSha256 != null) {
            localVarHeaderParams.put("X-Amz-Content-Sha256", localVarApiClient.parameterToString(xAmzContentSha256));
        }

        if (xAmzDate != null) {
            localVarHeaderParams.put("X-Amz-Date", localVarApiClient.parameterToString(xAmzDate));
        }

        if (xAmzAlgorithm != null) {
            localVarHeaderParams.put("X-Amz-Algorithm", localVarApiClient.parameterToString(xAmzAlgorithm));
        }

        if (xAmzCredential != null) {
            localVarHeaderParams.put("X-Amz-Credential", localVarApiClient.parameterToString(xAmzCredential));
        }

        if (xAmzSecurityToken != null) {
            localVarHeaderParams.put("X-Amz-Security-Token", localVarApiClient.parameterToString(xAmzSecurityToken));
        }

        if (xAmzSignature != null) {
            localVarHeaderParams.put("X-Amz-Signature", localVarApiClient.parameterToString(xAmzSignature));
        }

        if (xAmzSignedHeaders != null) {
            localVarHeaderParams.put("X-Amz-SignedHeaders", localVarApiClient.parameterToString(xAmzSignedHeaders));
        }

        final String[] localVarAccepts = {
            "text/xml"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            "text/xml"
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "hmac" };
        return localVarApiClient.buildCall(basePath, localVarPath, "POST", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call pOSTDeleteHsmConfigurationValidateBeforeCall(String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, DeleteHsmConfigurationMessage deleteHsmConfigurationMessage, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'action' is set
        if (action == null) {
            throw new ApiException("Missing the required parameter 'action' when calling pOSTDeleteHsmConfiguration(Async)");
        }

        // verify the required parameter 'version' is set
        if (version == null) {
            throw new ApiException("Missing the required parameter 'version' when calling pOSTDeleteHsmConfiguration(Async)");
        }

        return pOSTDeleteHsmConfigurationCall(action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, deleteHsmConfigurationMessage, _callback);

    }

    /**
     * 
     * Deletes the specified Amazon Redshift HSM configuration.
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param deleteHsmConfigurationMessage  (optional)
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> InvalidHsmConfigurationStateFault </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> HsmConfigurationNotFoundFault </td><td>  -  </td></tr>
     </table>
     */
    public void pOSTDeleteHsmConfiguration(String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, DeleteHsmConfigurationMessage deleteHsmConfigurationMessage) throws ApiException {
        pOSTDeleteHsmConfigurationWithHttpInfo(action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, deleteHsmConfigurationMessage);
    }

    /**
     * 
     * Deletes the specified Amazon Redshift HSM configuration.
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param deleteHsmConfigurationMessage  (optional)
     * @return ApiResponse&lt;Void&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> InvalidHsmConfigurationStateFault </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> HsmConfigurationNotFoundFault </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<Void> pOSTDeleteHsmConfigurationWithHttpInfo(String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, DeleteHsmConfigurationMessage deleteHsmConfigurationMessage) throws ApiException {
        okhttp3.Call localVarCall = pOSTDeleteHsmConfigurationValidateBeforeCall(action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, deleteHsmConfigurationMessage, null);
        return localVarApiClient.execute(localVarCall);
    }

    /**
     *  (asynchronously)
     * Deletes the specified Amazon Redshift HSM configuration.
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param deleteHsmConfigurationMessage  (optional)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> InvalidHsmConfigurationStateFault </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> HsmConfigurationNotFoundFault </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call pOSTDeleteHsmConfigurationAsync(String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, DeleteHsmConfigurationMessage deleteHsmConfigurationMessage, final ApiCallback<Void> _callback) throws ApiException {

        okhttp3.Call localVarCall = pOSTDeleteHsmConfigurationValidateBeforeCall(action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, deleteHsmConfigurationMessage, _callback);
        localVarApiClient.executeAsync(localVarCall, _callback);
        return localVarCall;
    }
    /**
     * Build call for pOSTDeletePartner
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param partnerIntegrationInputMessage  (optional)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> PartnerNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> ClusterNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 482 </td><td> UnauthorizedPartnerIntegrationFault </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call pOSTDeletePartnerCall(String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, PartnerIntegrationInputMessage partnerIntegrationInputMessage, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = partnerIntegrationInputMessage;

        // create path and map variables
        String localVarPath = "/#Action=DeletePartner";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (action != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("Action", action));
        }

        if (version != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("Version", version));
        }

        if (xAmzContentSha256 != null) {
            localVarHeaderParams.put("X-Amz-Content-Sha256", localVarApiClient.parameterToString(xAmzContentSha256));
        }

        if (xAmzDate != null) {
            localVarHeaderParams.put("X-Amz-Date", localVarApiClient.parameterToString(xAmzDate));
        }

        if (xAmzAlgorithm != null) {
            localVarHeaderParams.put("X-Amz-Algorithm", localVarApiClient.parameterToString(xAmzAlgorithm));
        }

        if (xAmzCredential != null) {
            localVarHeaderParams.put("X-Amz-Credential", localVarApiClient.parameterToString(xAmzCredential));
        }

        if (xAmzSecurityToken != null) {
            localVarHeaderParams.put("X-Amz-Security-Token", localVarApiClient.parameterToString(xAmzSecurityToken));
        }

        if (xAmzSignature != null) {
            localVarHeaderParams.put("X-Amz-Signature", localVarApiClient.parameterToString(xAmzSignature));
        }

        if (xAmzSignedHeaders != null) {
            localVarHeaderParams.put("X-Amz-SignedHeaders", localVarApiClient.parameterToString(xAmzSignedHeaders));
        }

        final String[] localVarAccepts = {
            "text/xml"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            "text/xml"
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "hmac" };
        return localVarApiClient.buildCall(basePath, localVarPath, "POST", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call pOSTDeletePartnerValidateBeforeCall(String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, PartnerIntegrationInputMessage partnerIntegrationInputMessage, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'action' is set
        if (action == null) {
            throw new ApiException("Missing the required parameter 'action' when calling pOSTDeletePartner(Async)");
        }

        // verify the required parameter 'version' is set
        if (version == null) {
            throw new ApiException("Missing the required parameter 'version' when calling pOSTDeletePartner(Async)");
        }

        return pOSTDeletePartnerCall(action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, partnerIntegrationInputMessage, _callback);

    }

    /**
     * 
     * Deletes a partner integration from a cluster. Data can still flow to the cluster until the integration is deleted at the partner&#39;s website.
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param partnerIntegrationInputMessage  (optional)
     * @return PartnerIntegrationOutputMessage
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> PartnerNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> ClusterNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 482 </td><td> UnauthorizedPartnerIntegrationFault </td><td>  -  </td></tr>
     </table>
     */
    public PartnerIntegrationOutputMessage pOSTDeletePartner(String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, PartnerIntegrationInputMessage partnerIntegrationInputMessage) throws ApiException {
        ApiResponse<PartnerIntegrationOutputMessage> localVarResp = pOSTDeletePartnerWithHttpInfo(action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, partnerIntegrationInputMessage);
        return localVarResp.getData();
    }

    /**
     * 
     * Deletes a partner integration from a cluster. Data can still flow to the cluster until the integration is deleted at the partner&#39;s website.
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param partnerIntegrationInputMessage  (optional)
     * @return ApiResponse&lt;PartnerIntegrationOutputMessage&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> PartnerNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> ClusterNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 482 </td><td> UnauthorizedPartnerIntegrationFault </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<PartnerIntegrationOutputMessage> pOSTDeletePartnerWithHttpInfo(String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, PartnerIntegrationInputMessage partnerIntegrationInputMessage) throws ApiException {
        okhttp3.Call localVarCall = pOSTDeletePartnerValidateBeforeCall(action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, partnerIntegrationInputMessage, null);
        Type localVarReturnType = new TypeToken<PartnerIntegrationOutputMessage>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     *  (asynchronously)
     * Deletes a partner integration from a cluster. Data can still flow to the cluster until the integration is deleted at the partner&#39;s website.
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param partnerIntegrationInputMessage  (optional)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> PartnerNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> ClusterNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 482 </td><td> UnauthorizedPartnerIntegrationFault </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call pOSTDeletePartnerAsync(String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, PartnerIntegrationInputMessage partnerIntegrationInputMessage, final ApiCallback<PartnerIntegrationOutputMessage> _callback) throws ApiException {

        okhttp3.Call localVarCall = pOSTDeletePartnerValidateBeforeCall(action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, partnerIntegrationInputMessage, _callback);
        Type localVarReturnType = new TypeToken<PartnerIntegrationOutputMessage>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for pOSTDeleteScheduledAction
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param deleteScheduledActionMessage  (optional)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> ScheduledActionNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> UnauthorizedOperation </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call pOSTDeleteScheduledActionCall(String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, DeleteScheduledActionMessage deleteScheduledActionMessage, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = deleteScheduledActionMessage;

        // create path and map variables
        String localVarPath = "/#Action=DeleteScheduledAction";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (action != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("Action", action));
        }

        if (version != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("Version", version));
        }

        if (xAmzContentSha256 != null) {
            localVarHeaderParams.put("X-Amz-Content-Sha256", localVarApiClient.parameterToString(xAmzContentSha256));
        }

        if (xAmzDate != null) {
            localVarHeaderParams.put("X-Amz-Date", localVarApiClient.parameterToString(xAmzDate));
        }

        if (xAmzAlgorithm != null) {
            localVarHeaderParams.put("X-Amz-Algorithm", localVarApiClient.parameterToString(xAmzAlgorithm));
        }

        if (xAmzCredential != null) {
            localVarHeaderParams.put("X-Amz-Credential", localVarApiClient.parameterToString(xAmzCredential));
        }

        if (xAmzSecurityToken != null) {
            localVarHeaderParams.put("X-Amz-Security-Token", localVarApiClient.parameterToString(xAmzSecurityToken));
        }

        if (xAmzSignature != null) {
            localVarHeaderParams.put("X-Amz-Signature", localVarApiClient.parameterToString(xAmzSignature));
        }

        if (xAmzSignedHeaders != null) {
            localVarHeaderParams.put("X-Amz-SignedHeaders", localVarApiClient.parameterToString(xAmzSignedHeaders));
        }

        final String[] localVarAccepts = {
            "text/xml"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            "text/xml"
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "hmac" };
        return localVarApiClient.buildCall(basePath, localVarPath, "POST", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call pOSTDeleteScheduledActionValidateBeforeCall(String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, DeleteScheduledActionMessage deleteScheduledActionMessage, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'action' is set
        if (action == null) {
            throw new ApiException("Missing the required parameter 'action' when calling pOSTDeleteScheduledAction(Async)");
        }

        // verify the required parameter 'version' is set
        if (version == null) {
            throw new ApiException("Missing the required parameter 'version' when calling pOSTDeleteScheduledAction(Async)");
        }

        return pOSTDeleteScheduledActionCall(action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, deleteScheduledActionMessage, _callback);

    }

    /**
     * 
     * Deletes a scheduled action. 
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param deleteScheduledActionMessage  (optional)
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> ScheduledActionNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> UnauthorizedOperation </td><td>  -  </td></tr>
     </table>
     */
    public void pOSTDeleteScheduledAction(String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, DeleteScheduledActionMessage deleteScheduledActionMessage) throws ApiException {
        pOSTDeleteScheduledActionWithHttpInfo(action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, deleteScheduledActionMessage);
    }

    /**
     * 
     * Deletes a scheduled action. 
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param deleteScheduledActionMessage  (optional)
     * @return ApiResponse&lt;Void&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> ScheduledActionNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> UnauthorizedOperation </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<Void> pOSTDeleteScheduledActionWithHttpInfo(String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, DeleteScheduledActionMessage deleteScheduledActionMessage) throws ApiException {
        okhttp3.Call localVarCall = pOSTDeleteScheduledActionValidateBeforeCall(action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, deleteScheduledActionMessage, null);
        return localVarApiClient.execute(localVarCall);
    }

    /**
     *  (asynchronously)
     * Deletes a scheduled action. 
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param deleteScheduledActionMessage  (optional)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> ScheduledActionNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> UnauthorizedOperation </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call pOSTDeleteScheduledActionAsync(String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, DeleteScheduledActionMessage deleteScheduledActionMessage, final ApiCallback<Void> _callback) throws ApiException {

        okhttp3.Call localVarCall = pOSTDeleteScheduledActionValidateBeforeCall(action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, deleteScheduledActionMessage, _callback);
        localVarApiClient.executeAsync(localVarCall, _callback);
        return localVarCall;
    }
    /**
     * Build call for pOSTDeleteSnapshotCopyGrant
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param deleteSnapshotCopyGrantMessage  (optional)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> InvalidSnapshotCopyGrantStateFault </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> SnapshotCopyGrantNotFoundFault </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call pOSTDeleteSnapshotCopyGrantCall(String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, DeleteSnapshotCopyGrantMessage deleteSnapshotCopyGrantMessage, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = deleteSnapshotCopyGrantMessage;

        // create path and map variables
        String localVarPath = "/#Action=DeleteSnapshotCopyGrant";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (action != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("Action", action));
        }

        if (version != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("Version", version));
        }

        if (xAmzContentSha256 != null) {
            localVarHeaderParams.put("X-Amz-Content-Sha256", localVarApiClient.parameterToString(xAmzContentSha256));
        }

        if (xAmzDate != null) {
            localVarHeaderParams.put("X-Amz-Date", localVarApiClient.parameterToString(xAmzDate));
        }

        if (xAmzAlgorithm != null) {
            localVarHeaderParams.put("X-Amz-Algorithm", localVarApiClient.parameterToString(xAmzAlgorithm));
        }

        if (xAmzCredential != null) {
            localVarHeaderParams.put("X-Amz-Credential", localVarApiClient.parameterToString(xAmzCredential));
        }

        if (xAmzSecurityToken != null) {
            localVarHeaderParams.put("X-Amz-Security-Token", localVarApiClient.parameterToString(xAmzSecurityToken));
        }

        if (xAmzSignature != null) {
            localVarHeaderParams.put("X-Amz-Signature", localVarApiClient.parameterToString(xAmzSignature));
        }

        if (xAmzSignedHeaders != null) {
            localVarHeaderParams.put("X-Amz-SignedHeaders", localVarApiClient.parameterToString(xAmzSignedHeaders));
        }

        final String[] localVarAccepts = {
            "text/xml"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            "text/xml"
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "hmac" };
        return localVarApiClient.buildCall(basePath, localVarPath, "POST", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call pOSTDeleteSnapshotCopyGrantValidateBeforeCall(String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, DeleteSnapshotCopyGrantMessage deleteSnapshotCopyGrantMessage, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'action' is set
        if (action == null) {
            throw new ApiException("Missing the required parameter 'action' when calling pOSTDeleteSnapshotCopyGrant(Async)");
        }

        // verify the required parameter 'version' is set
        if (version == null) {
            throw new ApiException("Missing the required parameter 'version' when calling pOSTDeleteSnapshotCopyGrant(Async)");
        }

        return pOSTDeleteSnapshotCopyGrantCall(action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, deleteSnapshotCopyGrantMessage, _callback);

    }

    /**
     * 
     * Deletes the specified snapshot copy grant.
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param deleteSnapshotCopyGrantMessage  (optional)
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> InvalidSnapshotCopyGrantStateFault </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> SnapshotCopyGrantNotFoundFault </td><td>  -  </td></tr>
     </table>
     */
    public void pOSTDeleteSnapshotCopyGrant(String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, DeleteSnapshotCopyGrantMessage deleteSnapshotCopyGrantMessage) throws ApiException {
        pOSTDeleteSnapshotCopyGrantWithHttpInfo(action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, deleteSnapshotCopyGrantMessage);
    }

    /**
     * 
     * Deletes the specified snapshot copy grant.
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param deleteSnapshotCopyGrantMessage  (optional)
     * @return ApiResponse&lt;Void&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> InvalidSnapshotCopyGrantStateFault </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> SnapshotCopyGrantNotFoundFault </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<Void> pOSTDeleteSnapshotCopyGrantWithHttpInfo(String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, DeleteSnapshotCopyGrantMessage deleteSnapshotCopyGrantMessage) throws ApiException {
        okhttp3.Call localVarCall = pOSTDeleteSnapshotCopyGrantValidateBeforeCall(action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, deleteSnapshotCopyGrantMessage, null);
        return localVarApiClient.execute(localVarCall);
    }

    /**
     *  (asynchronously)
     * Deletes the specified snapshot copy grant.
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param deleteSnapshotCopyGrantMessage  (optional)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> InvalidSnapshotCopyGrantStateFault </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> SnapshotCopyGrantNotFoundFault </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call pOSTDeleteSnapshotCopyGrantAsync(String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, DeleteSnapshotCopyGrantMessage deleteSnapshotCopyGrantMessage, final ApiCallback<Void> _callback) throws ApiException {

        okhttp3.Call localVarCall = pOSTDeleteSnapshotCopyGrantValidateBeforeCall(action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, deleteSnapshotCopyGrantMessage, _callback);
        localVarApiClient.executeAsync(localVarCall, _callback);
        return localVarCall;
    }
    /**
     * Build call for pOSTDeleteSnapshotSchedule
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param deleteSnapshotScheduleMessage  (optional)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> InvalidClusterSnapshotScheduleStateFault </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> SnapshotScheduleNotFoundFault </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call pOSTDeleteSnapshotScheduleCall(String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, DeleteSnapshotScheduleMessage deleteSnapshotScheduleMessage, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = deleteSnapshotScheduleMessage;

        // create path and map variables
        String localVarPath = "/#Action=DeleteSnapshotSchedule";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (action != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("Action", action));
        }

        if (version != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("Version", version));
        }

        if (xAmzContentSha256 != null) {
            localVarHeaderParams.put("X-Amz-Content-Sha256", localVarApiClient.parameterToString(xAmzContentSha256));
        }

        if (xAmzDate != null) {
            localVarHeaderParams.put("X-Amz-Date", localVarApiClient.parameterToString(xAmzDate));
        }

        if (xAmzAlgorithm != null) {
            localVarHeaderParams.put("X-Amz-Algorithm", localVarApiClient.parameterToString(xAmzAlgorithm));
        }

        if (xAmzCredential != null) {
            localVarHeaderParams.put("X-Amz-Credential", localVarApiClient.parameterToString(xAmzCredential));
        }

        if (xAmzSecurityToken != null) {
            localVarHeaderParams.put("X-Amz-Security-Token", localVarApiClient.parameterToString(xAmzSecurityToken));
        }

        if (xAmzSignature != null) {
            localVarHeaderParams.put("X-Amz-Signature", localVarApiClient.parameterToString(xAmzSignature));
        }

        if (xAmzSignedHeaders != null) {
            localVarHeaderParams.put("X-Amz-SignedHeaders", localVarApiClient.parameterToString(xAmzSignedHeaders));
        }

        final String[] localVarAccepts = {
            "text/xml"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            "text/xml"
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "hmac" };
        return localVarApiClient.buildCall(basePath, localVarPath, "POST", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call pOSTDeleteSnapshotScheduleValidateBeforeCall(String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, DeleteSnapshotScheduleMessage deleteSnapshotScheduleMessage, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'action' is set
        if (action == null) {
            throw new ApiException("Missing the required parameter 'action' when calling pOSTDeleteSnapshotSchedule(Async)");
        }

        // verify the required parameter 'version' is set
        if (version == null) {
            throw new ApiException("Missing the required parameter 'version' when calling pOSTDeleteSnapshotSchedule(Async)");
        }

        return pOSTDeleteSnapshotScheduleCall(action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, deleteSnapshotScheduleMessage, _callback);

    }

    /**
     * 
     * Deletes a snapshot schedule.
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param deleteSnapshotScheduleMessage  (optional)
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> InvalidClusterSnapshotScheduleStateFault </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> SnapshotScheduleNotFoundFault </td><td>  -  </td></tr>
     </table>
     */
    public void pOSTDeleteSnapshotSchedule(String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, DeleteSnapshotScheduleMessage deleteSnapshotScheduleMessage) throws ApiException {
        pOSTDeleteSnapshotScheduleWithHttpInfo(action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, deleteSnapshotScheduleMessage);
    }

    /**
     * 
     * Deletes a snapshot schedule.
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param deleteSnapshotScheduleMessage  (optional)
     * @return ApiResponse&lt;Void&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> InvalidClusterSnapshotScheduleStateFault </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> SnapshotScheduleNotFoundFault </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<Void> pOSTDeleteSnapshotScheduleWithHttpInfo(String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, DeleteSnapshotScheduleMessage deleteSnapshotScheduleMessage) throws ApiException {
        okhttp3.Call localVarCall = pOSTDeleteSnapshotScheduleValidateBeforeCall(action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, deleteSnapshotScheduleMessage, null);
        return localVarApiClient.execute(localVarCall);
    }

    /**
     *  (asynchronously)
     * Deletes a snapshot schedule.
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param deleteSnapshotScheduleMessage  (optional)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> InvalidClusterSnapshotScheduleStateFault </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> SnapshotScheduleNotFoundFault </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call pOSTDeleteSnapshotScheduleAsync(String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, DeleteSnapshotScheduleMessage deleteSnapshotScheduleMessage, final ApiCallback<Void> _callback) throws ApiException {

        okhttp3.Call localVarCall = pOSTDeleteSnapshotScheduleValidateBeforeCall(action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, deleteSnapshotScheduleMessage, _callback);
        localVarApiClient.executeAsync(localVarCall, _callback);
        return localVarCall;
    }
    /**
     * Build call for pOSTDeleteTags
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param deleteTagsMessage  (optional)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> ResourceNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> InvalidTagFault </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call pOSTDeleteTagsCall(String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, DeleteTagsMessage deleteTagsMessage, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = deleteTagsMessage;

        // create path and map variables
        String localVarPath = "/#Action=DeleteTags";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (action != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("Action", action));
        }

        if (version != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("Version", version));
        }

        if (xAmzContentSha256 != null) {
            localVarHeaderParams.put("X-Amz-Content-Sha256", localVarApiClient.parameterToString(xAmzContentSha256));
        }

        if (xAmzDate != null) {
            localVarHeaderParams.put("X-Amz-Date", localVarApiClient.parameterToString(xAmzDate));
        }

        if (xAmzAlgorithm != null) {
            localVarHeaderParams.put("X-Amz-Algorithm", localVarApiClient.parameterToString(xAmzAlgorithm));
        }

        if (xAmzCredential != null) {
            localVarHeaderParams.put("X-Amz-Credential", localVarApiClient.parameterToString(xAmzCredential));
        }

        if (xAmzSecurityToken != null) {
            localVarHeaderParams.put("X-Amz-Security-Token", localVarApiClient.parameterToString(xAmzSecurityToken));
        }

        if (xAmzSignature != null) {
            localVarHeaderParams.put("X-Amz-Signature", localVarApiClient.parameterToString(xAmzSignature));
        }

        if (xAmzSignedHeaders != null) {
            localVarHeaderParams.put("X-Amz-SignedHeaders", localVarApiClient.parameterToString(xAmzSignedHeaders));
        }

        final String[] localVarAccepts = {
            "text/xml"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            "text/xml"
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "hmac" };
        return localVarApiClient.buildCall(basePath, localVarPath, "POST", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call pOSTDeleteTagsValidateBeforeCall(String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, DeleteTagsMessage deleteTagsMessage, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'action' is set
        if (action == null) {
            throw new ApiException("Missing the required parameter 'action' when calling pOSTDeleteTags(Async)");
        }

        // verify the required parameter 'version' is set
        if (version == null) {
            throw new ApiException("Missing the required parameter 'version' when calling pOSTDeleteTags(Async)");
        }

        return pOSTDeleteTagsCall(action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, deleteTagsMessage, _callback);

    }

    /**
     * 
     * Deletes tags from a resource. You must provide the ARN of the resource from which you want to delete the tag or tags.
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param deleteTagsMessage  (optional)
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> ResourceNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> InvalidTagFault </td><td>  -  </td></tr>
     </table>
     */
    public void pOSTDeleteTags(String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, DeleteTagsMessage deleteTagsMessage) throws ApiException {
        pOSTDeleteTagsWithHttpInfo(action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, deleteTagsMessage);
    }

    /**
     * 
     * Deletes tags from a resource. You must provide the ARN of the resource from which you want to delete the tag or tags.
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param deleteTagsMessage  (optional)
     * @return ApiResponse&lt;Void&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> ResourceNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> InvalidTagFault </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<Void> pOSTDeleteTagsWithHttpInfo(String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, DeleteTagsMessage deleteTagsMessage) throws ApiException {
        okhttp3.Call localVarCall = pOSTDeleteTagsValidateBeforeCall(action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, deleteTagsMessage, null);
        return localVarApiClient.execute(localVarCall);
    }

    /**
     *  (asynchronously)
     * Deletes tags from a resource. You must provide the ARN of the resource from which you want to delete the tag or tags.
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param deleteTagsMessage  (optional)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> ResourceNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> InvalidTagFault </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call pOSTDeleteTagsAsync(String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, DeleteTagsMessage deleteTagsMessage, final ApiCallback<Void> _callback) throws ApiException {

        okhttp3.Call localVarCall = pOSTDeleteTagsValidateBeforeCall(action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, deleteTagsMessage, _callback);
        localVarApiClient.executeAsync(localVarCall, _callback);
        return localVarCall;
    }
    /**
     * Build call for pOSTDeleteUsageLimit
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param deleteUsageLimitMessage  (optional)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> UsageLimitNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> UnsupportedOperationFault </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call pOSTDeleteUsageLimitCall(String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, DeleteUsageLimitMessage deleteUsageLimitMessage, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = deleteUsageLimitMessage;

        // create path and map variables
        String localVarPath = "/#Action=DeleteUsageLimit";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (action != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("Action", action));
        }

        if (version != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("Version", version));
        }

        if (xAmzContentSha256 != null) {
            localVarHeaderParams.put("X-Amz-Content-Sha256", localVarApiClient.parameterToString(xAmzContentSha256));
        }

        if (xAmzDate != null) {
            localVarHeaderParams.put("X-Amz-Date", localVarApiClient.parameterToString(xAmzDate));
        }

        if (xAmzAlgorithm != null) {
            localVarHeaderParams.put("X-Amz-Algorithm", localVarApiClient.parameterToString(xAmzAlgorithm));
        }

        if (xAmzCredential != null) {
            localVarHeaderParams.put("X-Amz-Credential", localVarApiClient.parameterToString(xAmzCredential));
        }

        if (xAmzSecurityToken != null) {
            localVarHeaderParams.put("X-Amz-Security-Token", localVarApiClient.parameterToString(xAmzSecurityToken));
        }

        if (xAmzSignature != null) {
            localVarHeaderParams.put("X-Amz-Signature", localVarApiClient.parameterToString(xAmzSignature));
        }

        if (xAmzSignedHeaders != null) {
            localVarHeaderParams.put("X-Amz-SignedHeaders", localVarApiClient.parameterToString(xAmzSignedHeaders));
        }

        final String[] localVarAccepts = {
            "text/xml"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            "text/xml"
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "hmac" };
        return localVarApiClient.buildCall(basePath, localVarPath, "POST", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call pOSTDeleteUsageLimitValidateBeforeCall(String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, DeleteUsageLimitMessage deleteUsageLimitMessage, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'action' is set
        if (action == null) {
            throw new ApiException("Missing the required parameter 'action' when calling pOSTDeleteUsageLimit(Async)");
        }

        // verify the required parameter 'version' is set
        if (version == null) {
            throw new ApiException("Missing the required parameter 'version' when calling pOSTDeleteUsageLimit(Async)");
        }

        return pOSTDeleteUsageLimitCall(action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, deleteUsageLimitMessage, _callback);

    }

    /**
     * 
     * Deletes a usage limit from a cluster.
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param deleteUsageLimitMessage  (optional)
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> UsageLimitNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> UnsupportedOperationFault </td><td>  -  </td></tr>
     </table>
     */
    public void pOSTDeleteUsageLimit(String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, DeleteUsageLimitMessage deleteUsageLimitMessage) throws ApiException {
        pOSTDeleteUsageLimitWithHttpInfo(action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, deleteUsageLimitMessage);
    }

    /**
     * 
     * Deletes a usage limit from a cluster.
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param deleteUsageLimitMessage  (optional)
     * @return ApiResponse&lt;Void&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> UsageLimitNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> UnsupportedOperationFault </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<Void> pOSTDeleteUsageLimitWithHttpInfo(String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, DeleteUsageLimitMessage deleteUsageLimitMessage) throws ApiException {
        okhttp3.Call localVarCall = pOSTDeleteUsageLimitValidateBeforeCall(action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, deleteUsageLimitMessage, null);
        return localVarApiClient.execute(localVarCall);
    }

    /**
     *  (asynchronously)
     * Deletes a usage limit from a cluster.
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param deleteUsageLimitMessage  (optional)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> UsageLimitNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> UnsupportedOperationFault </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call pOSTDeleteUsageLimitAsync(String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, DeleteUsageLimitMessage deleteUsageLimitMessage, final ApiCallback<Void> _callback) throws ApiException {

        okhttp3.Call localVarCall = pOSTDeleteUsageLimitValidateBeforeCall(action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, deleteUsageLimitMessage, _callback);
        localVarApiClient.executeAsync(localVarCall, _callback);
        return localVarCall;
    }
    /**
     * Build call for pOSTDescribeAccountAttributes
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param describeAccountAttributesMessage  (optional)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call pOSTDescribeAccountAttributesCall(String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, DescribeAccountAttributesMessage describeAccountAttributesMessage, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = describeAccountAttributesMessage;

        // create path and map variables
        String localVarPath = "/#Action=DescribeAccountAttributes";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (action != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("Action", action));
        }

        if (version != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("Version", version));
        }

        if (xAmzContentSha256 != null) {
            localVarHeaderParams.put("X-Amz-Content-Sha256", localVarApiClient.parameterToString(xAmzContentSha256));
        }

        if (xAmzDate != null) {
            localVarHeaderParams.put("X-Amz-Date", localVarApiClient.parameterToString(xAmzDate));
        }

        if (xAmzAlgorithm != null) {
            localVarHeaderParams.put("X-Amz-Algorithm", localVarApiClient.parameterToString(xAmzAlgorithm));
        }

        if (xAmzCredential != null) {
            localVarHeaderParams.put("X-Amz-Credential", localVarApiClient.parameterToString(xAmzCredential));
        }

        if (xAmzSecurityToken != null) {
            localVarHeaderParams.put("X-Amz-Security-Token", localVarApiClient.parameterToString(xAmzSecurityToken));
        }

        if (xAmzSignature != null) {
            localVarHeaderParams.put("X-Amz-Signature", localVarApiClient.parameterToString(xAmzSignature));
        }

        if (xAmzSignedHeaders != null) {
            localVarHeaderParams.put("X-Amz-SignedHeaders", localVarApiClient.parameterToString(xAmzSignedHeaders));
        }

        final String[] localVarAccepts = {
            "text/xml"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            "text/xml"
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "hmac" };
        return localVarApiClient.buildCall(basePath, localVarPath, "POST", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call pOSTDescribeAccountAttributesValidateBeforeCall(String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, DescribeAccountAttributesMessage describeAccountAttributesMessage, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'action' is set
        if (action == null) {
            throw new ApiException("Missing the required parameter 'action' when calling pOSTDescribeAccountAttributes(Async)");
        }

        // verify the required parameter 'version' is set
        if (version == null) {
            throw new ApiException("Missing the required parameter 'version' when calling pOSTDescribeAccountAttributes(Async)");
        }

        return pOSTDescribeAccountAttributesCall(action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, describeAccountAttributesMessage, _callback);

    }

    /**
     * 
     * Returns a list of attributes attached to an account
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param describeAccountAttributesMessage  (optional)
     * @return AccountAttributeList
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
     </table>
     */
    public AccountAttributeList pOSTDescribeAccountAttributes(String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, DescribeAccountAttributesMessage describeAccountAttributesMessage) throws ApiException {
        ApiResponse<AccountAttributeList> localVarResp = pOSTDescribeAccountAttributesWithHttpInfo(action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, describeAccountAttributesMessage);
        return localVarResp.getData();
    }

    /**
     * 
     * Returns a list of attributes attached to an account
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param describeAccountAttributesMessage  (optional)
     * @return ApiResponse&lt;AccountAttributeList&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<AccountAttributeList> pOSTDescribeAccountAttributesWithHttpInfo(String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, DescribeAccountAttributesMessage describeAccountAttributesMessage) throws ApiException {
        okhttp3.Call localVarCall = pOSTDescribeAccountAttributesValidateBeforeCall(action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, describeAccountAttributesMessage, null);
        Type localVarReturnType = new TypeToken<AccountAttributeList>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     *  (asynchronously)
     * Returns a list of attributes attached to an account
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param describeAccountAttributesMessage  (optional)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call pOSTDescribeAccountAttributesAsync(String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, DescribeAccountAttributesMessage describeAccountAttributesMessage, final ApiCallback<AccountAttributeList> _callback) throws ApiException {

        okhttp3.Call localVarCall = pOSTDescribeAccountAttributesValidateBeforeCall(action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, describeAccountAttributesMessage, _callback);
        Type localVarReturnType = new TypeToken<AccountAttributeList>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for pOSTDescribeAuthenticationProfiles
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param describeAuthenticationProfilesMessage  (optional)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> AuthenticationProfileNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> InvalidAuthenticationProfileRequestFault </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call pOSTDescribeAuthenticationProfilesCall(String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, DescribeAuthenticationProfilesMessage describeAuthenticationProfilesMessage, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = describeAuthenticationProfilesMessage;

        // create path and map variables
        String localVarPath = "/#Action=DescribeAuthenticationProfiles";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (action != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("Action", action));
        }

        if (version != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("Version", version));
        }

        if (xAmzContentSha256 != null) {
            localVarHeaderParams.put("X-Amz-Content-Sha256", localVarApiClient.parameterToString(xAmzContentSha256));
        }

        if (xAmzDate != null) {
            localVarHeaderParams.put("X-Amz-Date", localVarApiClient.parameterToString(xAmzDate));
        }

        if (xAmzAlgorithm != null) {
            localVarHeaderParams.put("X-Amz-Algorithm", localVarApiClient.parameterToString(xAmzAlgorithm));
        }

        if (xAmzCredential != null) {
            localVarHeaderParams.put("X-Amz-Credential", localVarApiClient.parameterToString(xAmzCredential));
        }

        if (xAmzSecurityToken != null) {
            localVarHeaderParams.put("X-Amz-Security-Token", localVarApiClient.parameterToString(xAmzSecurityToken));
        }

        if (xAmzSignature != null) {
            localVarHeaderParams.put("X-Amz-Signature", localVarApiClient.parameterToString(xAmzSignature));
        }

        if (xAmzSignedHeaders != null) {
            localVarHeaderParams.put("X-Amz-SignedHeaders", localVarApiClient.parameterToString(xAmzSignedHeaders));
        }

        final String[] localVarAccepts = {
            "text/xml"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            "text/xml"
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "hmac" };
        return localVarApiClient.buildCall(basePath, localVarPath, "POST", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call pOSTDescribeAuthenticationProfilesValidateBeforeCall(String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, DescribeAuthenticationProfilesMessage describeAuthenticationProfilesMessage, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'action' is set
        if (action == null) {
            throw new ApiException("Missing the required parameter 'action' when calling pOSTDescribeAuthenticationProfiles(Async)");
        }

        // verify the required parameter 'version' is set
        if (version == null) {
            throw new ApiException("Missing the required parameter 'version' when calling pOSTDescribeAuthenticationProfiles(Async)");
        }

        return pOSTDescribeAuthenticationProfilesCall(action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, describeAuthenticationProfilesMessage, _callback);

    }

    /**
     * 
     * Describes an authentication profile.
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param describeAuthenticationProfilesMessage  (optional)
     * @return DescribeAuthenticationProfilesResult
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> AuthenticationProfileNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> InvalidAuthenticationProfileRequestFault </td><td>  -  </td></tr>
     </table>
     */
    public DescribeAuthenticationProfilesResult pOSTDescribeAuthenticationProfiles(String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, DescribeAuthenticationProfilesMessage describeAuthenticationProfilesMessage) throws ApiException {
        ApiResponse<DescribeAuthenticationProfilesResult> localVarResp = pOSTDescribeAuthenticationProfilesWithHttpInfo(action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, describeAuthenticationProfilesMessage);
        return localVarResp.getData();
    }

    /**
     * 
     * Describes an authentication profile.
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param describeAuthenticationProfilesMessage  (optional)
     * @return ApiResponse&lt;DescribeAuthenticationProfilesResult&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> AuthenticationProfileNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> InvalidAuthenticationProfileRequestFault </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<DescribeAuthenticationProfilesResult> pOSTDescribeAuthenticationProfilesWithHttpInfo(String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, DescribeAuthenticationProfilesMessage describeAuthenticationProfilesMessage) throws ApiException {
        okhttp3.Call localVarCall = pOSTDescribeAuthenticationProfilesValidateBeforeCall(action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, describeAuthenticationProfilesMessage, null);
        Type localVarReturnType = new TypeToken<DescribeAuthenticationProfilesResult>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     *  (asynchronously)
     * Describes an authentication profile.
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param describeAuthenticationProfilesMessage  (optional)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> AuthenticationProfileNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> InvalidAuthenticationProfileRequestFault </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call pOSTDescribeAuthenticationProfilesAsync(String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, DescribeAuthenticationProfilesMessage describeAuthenticationProfilesMessage, final ApiCallback<DescribeAuthenticationProfilesResult> _callback) throws ApiException {

        okhttp3.Call localVarCall = pOSTDescribeAuthenticationProfilesValidateBeforeCall(action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, describeAuthenticationProfilesMessage, _callback);
        Type localVarReturnType = new TypeToken<DescribeAuthenticationProfilesResult>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for pOSTDescribeClusterDbRevisions
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param maxRecords Pagination limit (optional)
     * @param marker Pagination token (optional)
     * @param describeClusterDbRevisionsMessage  (optional)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> ClusterNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> InvalidClusterStateFault </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call pOSTDescribeClusterDbRevisionsCall(String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, String maxRecords, String marker, DescribeClusterDbRevisionsMessage describeClusterDbRevisionsMessage, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = describeClusterDbRevisionsMessage;

        // create path and map variables
        String localVarPath = "/#Action=DescribeClusterDbRevisions";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (maxRecords != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("MaxRecords", maxRecords));
        }

        if (marker != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("Marker", marker));
        }

        if (action != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("Action", action));
        }

        if (version != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("Version", version));
        }

        if (xAmzContentSha256 != null) {
            localVarHeaderParams.put("X-Amz-Content-Sha256", localVarApiClient.parameterToString(xAmzContentSha256));
        }

        if (xAmzDate != null) {
            localVarHeaderParams.put("X-Amz-Date", localVarApiClient.parameterToString(xAmzDate));
        }

        if (xAmzAlgorithm != null) {
            localVarHeaderParams.put("X-Amz-Algorithm", localVarApiClient.parameterToString(xAmzAlgorithm));
        }

        if (xAmzCredential != null) {
            localVarHeaderParams.put("X-Amz-Credential", localVarApiClient.parameterToString(xAmzCredential));
        }

        if (xAmzSecurityToken != null) {
            localVarHeaderParams.put("X-Amz-Security-Token", localVarApiClient.parameterToString(xAmzSecurityToken));
        }

        if (xAmzSignature != null) {
            localVarHeaderParams.put("X-Amz-Signature", localVarApiClient.parameterToString(xAmzSignature));
        }

        if (xAmzSignedHeaders != null) {
            localVarHeaderParams.put("X-Amz-SignedHeaders", localVarApiClient.parameterToString(xAmzSignedHeaders));
        }

        final String[] localVarAccepts = {
            "text/xml"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            "text/xml"
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "hmac" };
        return localVarApiClient.buildCall(basePath, localVarPath, "POST", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call pOSTDescribeClusterDbRevisionsValidateBeforeCall(String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, String maxRecords, String marker, DescribeClusterDbRevisionsMessage describeClusterDbRevisionsMessage, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'action' is set
        if (action == null) {
            throw new ApiException("Missing the required parameter 'action' when calling pOSTDescribeClusterDbRevisions(Async)");
        }

        // verify the required parameter 'version' is set
        if (version == null) {
            throw new ApiException("Missing the required parameter 'version' when calling pOSTDescribeClusterDbRevisions(Async)");
        }

        return pOSTDescribeClusterDbRevisionsCall(action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, maxRecords, marker, describeClusterDbRevisionsMessage, _callback);

    }

    /**
     * 
     * Returns an array of &lt;code&gt;ClusterDbRevision&lt;/code&gt; objects.
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param maxRecords Pagination limit (optional)
     * @param marker Pagination token (optional)
     * @param describeClusterDbRevisionsMessage  (optional)
     * @return ClusterDbRevisionsMessage
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> ClusterNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> InvalidClusterStateFault </td><td>  -  </td></tr>
     </table>
     */
    public ClusterDbRevisionsMessage pOSTDescribeClusterDbRevisions(String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, String maxRecords, String marker, DescribeClusterDbRevisionsMessage describeClusterDbRevisionsMessage) throws ApiException {
        ApiResponse<ClusterDbRevisionsMessage> localVarResp = pOSTDescribeClusterDbRevisionsWithHttpInfo(action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, maxRecords, marker, describeClusterDbRevisionsMessage);
        return localVarResp.getData();
    }

    /**
     * 
     * Returns an array of &lt;code&gt;ClusterDbRevision&lt;/code&gt; objects.
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param maxRecords Pagination limit (optional)
     * @param marker Pagination token (optional)
     * @param describeClusterDbRevisionsMessage  (optional)
     * @return ApiResponse&lt;ClusterDbRevisionsMessage&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> ClusterNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> InvalidClusterStateFault </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<ClusterDbRevisionsMessage> pOSTDescribeClusterDbRevisionsWithHttpInfo(String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, String maxRecords, String marker, DescribeClusterDbRevisionsMessage describeClusterDbRevisionsMessage) throws ApiException {
        okhttp3.Call localVarCall = pOSTDescribeClusterDbRevisionsValidateBeforeCall(action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, maxRecords, marker, describeClusterDbRevisionsMessage, null);
        Type localVarReturnType = new TypeToken<ClusterDbRevisionsMessage>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     *  (asynchronously)
     * Returns an array of &lt;code&gt;ClusterDbRevision&lt;/code&gt; objects.
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param maxRecords Pagination limit (optional)
     * @param marker Pagination token (optional)
     * @param describeClusterDbRevisionsMessage  (optional)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> ClusterNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> InvalidClusterStateFault </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call pOSTDescribeClusterDbRevisionsAsync(String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, String maxRecords, String marker, DescribeClusterDbRevisionsMessage describeClusterDbRevisionsMessage, final ApiCallback<ClusterDbRevisionsMessage> _callback) throws ApiException {

        okhttp3.Call localVarCall = pOSTDescribeClusterDbRevisionsValidateBeforeCall(action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, maxRecords, marker, describeClusterDbRevisionsMessage, _callback);
        Type localVarReturnType = new TypeToken<ClusterDbRevisionsMessage>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for pOSTDescribeClusterParameterGroups
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param maxRecords Pagination limit (optional)
     * @param marker Pagination token (optional)
     * @param describeClusterParameterGroupsMessage  (optional)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> ClusterParameterGroupNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> InvalidTagFault </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call pOSTDescribeClusterParameterGroupsCall(String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, String maxRecords, String marker, DescribeClusterParameterGroupsMessage describeClusterParameterGroupsMessage, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = describeClusterParameterGroupsMessage;

        // create path and map variables
        String localVarPath = "/#Action=DescribeClusterParameterGroups";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (maxRecords != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("MaxRecords", maxRecords));
        }

        if (marker != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("Marker", marker));
        }

        if (action != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("Action", action));
        }

        if (version != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("Version", version));
        }

        if (xAmzContentSha256 != null) {
            localVarHeaderParams.put("X-Amz-Content-Sha256", localVarApiClient.parameterToString(xAmzContentSha256));
        }

        if (xAmzDate != null) {
            localVarHeaderParams.put("X-Amz-Date", localVarApiClient.parameterToString(xAmzDate));
        }

        if (xAmzAlgorithm != null) {
            localVarHeaderParams.put("X-Amz-Algorithm", localVarApiClient.parameterToString(xAmzAlgorithm));
        }

        if (xAmzCredential != null) {
            localVarHeaderParams.put("X-Amz-Credential", localVarApiClient.parameterToString(xAmzCredential));
        }

        if (xAmzSecurityToken != null) {
            localVarHeaderParams.put("X-Amz-Security-Token", localVarApiClient.parameterToString(xAmzSecurityToken));
        }

        if (xAmzSignature != null) {
            localVarHeaderParams.put("X-Amz-Signature", localVarApiClient.parameterToString(xAmzSignature));
        }

        if (xAmzSignedHeaders != null) {
            localVarHeaderParams.put("X-Amz-SignedHeaders", localVarApiClient.parameterToString(xAmzSignedHeaders));
        }

        final String[] localVarAccepts = {
            "text/xml"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            "text/xml"
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "hmac" };
        return localVarApiClient.buildCall(basePath, localVarPath, "POST", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call pOSTDescribeClusterParameterGroupsValidateBeforeCall(String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, String maxRecords, String marker, DescribeClusterParameterGroupsMessage describeClusterParameterGroupsMessage, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'action' is set
        if (action == null) {
            throw new ApiException("Missing the required parameter 'action' when calling pOSTDescribeClusterParameterGroups(Async)");
        }

        // verify the required parameter 'version' is set
        if (version == null) {
            throw new ApiException("Missing the required parameter 'version' when calling pOSTDescribeClusterParameterGroups(Async)");
        }

        return pOSTDescribeClusterParameterGroupsCall(action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, maxRecords, marker, describeClusterParameterGroupsMessage, _callback);

    }

    /**
     * 
     * &lt;p&gt;Returns a list of Amazon Redshift parameter groups, including parameter groups you created and the default parameter group. For each parameter group, the response includes the parameter group name, description, and parameter group family name. You can optionally specify a name to retrieve the description of a specific parameter group.&lt;/p&gt; &lt;p&gt; For more information about parameters and parameter groups, go to &lt;a href&#x3D;\&quot;https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-parameter-groups.html\&quot;&gt;Amazon Redshift Parameter Groups&lt;/a&gt; in the &lt;i&gt;Amazon Redshift Cluster Management Guide&lt;/i&gt;.&lt;/p&gt; &lt;p&gt;If you specify both tag keys and tag values in the same request, Amazon Redshift returns all parameter groups that match any combination of the specified keys and values. For example, if you have &lt;code&gt;owner&lt;/code&gt; and &lt;code&gt;environment&lt;/code&gt; for tag keys, and &lt;code&gt;admin&lt;/code&gt; and &lt;code&gt;test&lt;/code&gt; for tag values, all parameter groups that have any combination of those values are returned.&lt;/p&gt; &lt;p&gt;If both tag keys and values are omitted from the request, parameter groups are returned regardless of whether they have tag keys or values associated with them.&lt;/p&gt;
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param maxRecords Pagination limit (optional)
     * @param marker Pagination token (optional)
     * @param describeClusterParameterGroupsMessage  (optional)
     * @return ClusterParameterGroupsMessage
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> ClusterParameterGroupNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> InvalidTagFault </td><td>  -  </td></tr>
     </table>
     */
    public ClusterParameterGroupsMessage pOSTDescribeClusterParameterGroups(String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, String maxRecords, String marker, DescribeClusterParameterGroupsMessage describeClusterParameterGroupsMessage) throws ApiException {
        ApiResponse<ClusterParameterGroupsMessage> localVarResp = pOSTDescribeClusterParameterGroupsWithHttpInfo(action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, maxRecords, marker, describeClusterParameterGroupsMessage);
        return localVarResp.getData();
    }

    /**
     * 
     * &lt;p&gt;Returns a list of Amazon Redshift parameter groups, including parameter groups you created and the default parameter group. For each parameter group, the response includes the parameter group name, description, and parameter group family name. You can optionally specify a name to retrieve the description of a specific parameter group.&lt;/p&gt; &lt;p&gt; For more information about parameters and parameter groups, go to &lt;a href&#x3D;\&quot;https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-parameter-groups.html\&quot;&gt;Amazon Redshift Parameter Groups&lt;/a&gt; in the &lt;i&gt;Amazon Redshift Cluster Management Guide&lt;/i&gt;.&lt;/p&gt; &lt;p&gt;If you specify both tag keys and tag values in the same request, Amazon Redshift returns all parameter groups that match any combination of the specified keys and values. For example, if you have &lt;code&gt;owner&lt;/code&gt; and &lt;code&gt;environment&lt;/code&gt; for tag keys, and &lt;code&gt;admin&lt;/code&gt; and &lt;code&gt;test&lt;/code&gt; for tag values, all parameter groups that have any combination of those values are returned.&lt;/p&gt; &lt;p&gt;If both tag keys and values are omitted from the request, parameter groups are returned regardless of whether they have tag keys or values associated with them.&lt;/p&gt;
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param maxRecords Pagination limit (optional)
     * @param marker Pagination token (optional)
     * @param describeClusterParameterGroupsMessage  (optional)
     * @return ApiResponse&lt;ClusterParameterGroupsMessage&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> ClusterParameterGroupNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> InvalidTagFault </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<ClusterParameterGroupsMessage> pOSTDescribeClusterParameterGroupsWithHttpInfo(String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, String maxRecords, String marker, DescribeClusterParameterGroupsMessage describeClusterParameterGroupsMessage) throws ApiException {
        okhttp3.Call localVarCall = pOSTDescribeClusterParameterGroupsValidateBeforeCall(action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, maxRecords, marker, describeClusterParameterGroupsMessage, null);
        Type localVarReturnType = new TypeToken<ClusterParameterGroupsMessage>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     *  (asynchronously)
     * &lt;p&gt;Returns a list of Amazon Redshift parameter groups, including parameter groups you created and the default parameter group. For each parameter group, the response includes the parameter group name, description, and parameter group family name. You can optionally specify a name to retrieve the description of a specific parameter group.&lt;/p&gt; &lt;p&gt; For more information about parameters and parameter groups, go to &lt;a href&#x3D;\&quot;https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-parameter-groups.html\&quot;&gt;Amazon Redshift Parameter Groups&lt;/a&gt; in the &lt;i&gt;Amazon Redshift Cluster Management Guide&lt;/i&gt;.&lt;/p&gt; &lt;p&gt;If you specify both tag keys and tag values in the same request, Amazon Redshift returns all parameter groups that match any combination of the specified keys and values. For example, if you have &lt;code&gt;owner&lt;/code&gt; and &lt;code&gt;environment&lt;/code&gt; for tag keys, and &lt;code&gt;admin&lt;/code&gt; and &lt;code&gt;test&lt;/code&gt; for tag values, all parameter groups that have any combination of those values are returned.&lt;/p&gt; &lt;p&gt;If both tag keys and values are omitted from the request, parameter groups are returned regardless of whether they have tag keys or values associated with them.&lt;/p&gt;
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param maxRecords Pagination limit (optional)
     * @param marker Pagination token (optional)
     * @param describeClusterParameterGroupsMessage  (optional)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> ClusterParameterGroupNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> InvalidTagFault </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call pOSTDescribeClusterParameterGroupsAsync(String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, String maxRecords, String marker, DescribeClusterParameterGroupsMessage describeClusterParameterGroupsMessage, final ApiCallback<ClusterParameterGroupsMessage> _callback) throws ApiException {

        okhttp3.Call localVarCall = pOSTDescribeClusterParameterGroupsValidateBeforeCall(action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, maxRecords, marker, describeClusterParameterGroupsMessage, _callback);
        Type localVarReturnType = new TypeToken<ClusterParameterGroupsMessage>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for pOSTDescribeClusterParameters
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param maxRecords Pagination limit (optional)
     * @param marker Pagination token (optional)
     * @param describeClusterParametersMessage  (optional)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> ClusterParameterGroupNotFoundFault </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call pOSTDescribeClusterParametersCall(String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, String maxRecords, String marker, DescribeClusterParametersMessage describeClusterParametersMessage, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = describeClusterParametersMessage;

        // create path and map variables
        String localVarPath = "/#Action=DescribeClusterParameters";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (maxRecords != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("MaxRecords", maxRecords));
        }

        if (marker != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("Marker", marker));
        }

        if (action != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("Action", action));
        }

        if (version != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("Version", version));
        }

        if (xAmzContentSha256 != null) {
            localVarHeaderParams.put("X-Amz-Content-Sha256", localVarApiClient.parameterToString(xAmzContentSha256));
        }

        if (xAmzDate != null) {
            localVarHeaderParams.put("X-Amz-Date", localVarApiClient.parameterToString(xAmzDate));
        }

        if (xAmzAlgorithm != null) {
            localVarHeaderParams.put("X-Amz-Algorithm", localVarApiClient.parameterToString(xAmzAlgorithm));
        }

        if (xAmzCredential != null) {
            localVarHeaderParams.put("X-Amz-Credential", localVarApiClient.parameterToString(xAmzCredential));
        }

        if (xAmzSecurityToken != null) {
            localVarHeaderParams.put("X-Amz-Security-Token", localVarApiClient.parameterToString(xAmzSecurityToken));
        }

        if (xAmzSignature != null) {
            localVarHeaderParams.put("X-Amz-Signature", localVarApiClient.parameterToString(xAmzSignature));
        }

        if (xAmzSignedHeaders != null) {
            localVarHeaderParams.put("X-Amz-SignedHeaders", localVarApiClient.parameterToString(xAmzSignedHeaders));
        }

        final String[] localVarAccepts = {
            "text/xml"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            "text/xml"
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "hmac" };
        return localVarApiClient.buildCall(basePath, localVarPath, "POST", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call pOSTDescribeClusterParametersValidateBeforeCall(String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, String maxRecords, String marker, DescribeClusterParametersMessage describeClusterParametersMessage, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'action' is set
        if (action == null) {
            throw new ApiException("Missing the required parameter 'action' when calling pOSTDescribeClusterParameters(Async)");
        }

        // verify the required parameter 'version' is set
        if (version == null) {
            throw new ApiException("Missing the required parameter 'version' when calling pOSTDescribeClusterParameters(Async)");
        }

        return pOSTDescribeClusterParametersCall(action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, maxRecords, marker, describeClusterParametersMessage, _callback);

    }

    /**
     * 
     * &lt;p&gt;Returns a detailed list of parameters contained within the specified Amazon Redshift parameter group. For each parameter the response includes information such as parameter name, description, data type, value, whether the parameter value is modifiable, and so on.&lt;/p&gt; &lt;p&gt;You can specify &lt;i&gt;source&lt;/i&gt; filter to retrieve parameters of only specific type. For example, to retrieve parameters that were modified by a user action such as from &lt;a&gt;ModifyClusterParameterGroup&lt;/a&gt;, you can specify &lt;i&gt;source&lt;/i&gt; equal to &lt;i&gt;user&lt;/i&gt;.&lt;/p&gt; &lt;p&gt; For more information about parameters and parameter groups, go to &lt;a href&#x3D;\&quot;https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-parameter-groups.html\&quot;&gt;Amazon Redshift Parameter Groups&lt;/a&gt; in the &lt;i&gt;Amazon Redshift Cluster Management Guide&lt;/i&gt;.&lt;/p&gt;
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param maxRecords Pagination limit (optional)
     * @param marker Pagination token (optional)
     * @param describeClusterParametersMessage  (optional)
     * @return ClusterParameterGroupDetails
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> ClusterParameterGroupNotFoundFault </td><td>  -  </td></tr>
     </table>
     */
    public ClusterParameterGroupDetails pOSTDescribeClusterParameters(String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, String maxRecords, String marker, DescribeClusterParametersMessage describeClusterParametersMessage) throws ApiException {
        ApiResponse<ClusterParameterGroupDetails> localVarResp = pOSTDescribeClusterParametersWithHttpInfo(action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, maxRecords, marker, describeClusterParametersMessage);
        return localVarResp.getData();
    }

    /**
     * 
     * &lt;p&gt;Returns a detailed list of parameters contained within the specified Amazon Redshift parameter group. For each parameter the response includes information such as parameter name, description, data type, value, whether the parameter value is modifiable, and so on.&lt;/p&gt; &lt;p&gt;You can specify &lt;i&gt;source&lt;/i&gt; filter to retrieve parameters of only specific type. For example, to retrieve parameters that were modified by a user action such as from &lt;a&gt;ModifyClusterParameterGroup&lt;/a&gt;, you can specify &lt;i&gt;source&lt;/i&gt; equal to &lt;i&gt;user&lt;/i&gt;.&lt;/p&gt; &lt;p&gt; For more information about parameters and parameter groups, go to &lt;a href&#x3D;\&quot;https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-parameter-groups.html\&quot;&gt;Amazon Redshift Parameter Groups&lt;/a&gt; in the &lt;i&gt;Amazon Redshift Cluster Management Guide&lt;/i&gt;.&lt;/p&gt;
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param maxRecords Pagination limit (optional)
     * @param marker Pagination token (optional)
     * @param describeClusterParametersMessage  (optional)
     * @return ApiResponse&lt;ClusterParameterGroupDetails&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> ClusterParameterGroupNotFoundFault </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<ClusterParameterGroupDetails> pOSTDescribeClusterParametersWithHttpInfo(String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, String maxRecords, String marker, DescribeClusterParametersMessage describeClusterParametersMessage) throws ApiException {
        okhttp3.Call localVarCall = pOSTDescribeClusterParametersValidateBeforeCall(action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, maxRecords, marker, describeClusterParametersMessage, null);
        Type localVarReturnType = new TypeToken<ClusterParameterGroupDetails>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     *  (asynchronously)
     * &lt;p&gt;Returns a detailed list of parameters contained within the specified Amazon Redshift parameter group. For each parameter the response includes information such as parameter name, description, data type, value, whether the parameter value is modifiable, and so on.&lt;/p&gt; &lt;p&gt;You can specify &lt;i&gt;source&lt;/i&gt; filter to retrieve parameters of only specific type. For example, to retrieve parameters that were modified by a user action such as from &lt;a&gt;ModifyClusterParameterGroup&lt;/a&gt;, you can specify &lt;i&gt;source&lt;/i&gt; equal to &lt;i&gt;user&lt;/i&gt;.&lt;/p&gt; &lt;p&gt; For more information about parameters and parameter groups, go to &lt;a href&#x3D;\&quot;https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-parameter-groups.html\&quot;&gt;Amazon Redshift Parameter Groups&lt;/a&gt; in the &lt;i&gt;Amazon Redshift Cluster Management Guide&lt;/i&gt;.&lt;/p&gt;
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param maxRecords Pagination limit (optional)
     * @param marker Pagination token (optional)
     * @param describeClusterParametersMessage  (optional)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> ClusterParameterGroupNotFoundFault </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call pOSTDescribeClusterParametersAsync(String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, String maxRecords, String marker, DescribeClusterParametersMessage describeClusterParametersMessage, final ApiCallback<ClusterParameterGroupDetails> _callback) throws ApiException {

        okhttp3.Call localVarCall = pOSTDescribeClusterParametersValidateBeforeCall(action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, maxRecords, marker, describeClusterParametersMessage, _callback);
        Type localVarReturnType = new TypeToken<ClusterParameterGroupDetails>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for pOSTDescribeClusterSecurityGroups
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param maxRecords Pagination limit (optional)
     * @param marker Pagination token (optional)
     * @param describeClusterSecurityGroupsMessage  (optional)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> ClusterSecurityGroupNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> InvalidTagFault </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call pOSTDescribeClusterSecurityGroupsCall(String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, String maxRecords, String marker, DescribeClusterSecurityGroupsMessage describeClusterSecurityGroupsMessage, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = describeClusterSecurityGroupsMessage;

        // create path and map variables
        String localVarPath = "/#Action=DescribeClusterSecurityGroups";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (maxRecords != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("MaxRecords", maxRecords));
        }

        if (marker != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("Marker", marker));
        }

        if (action != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("Action", action));
        }

        if (version != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("Version", version));
        }

        if (xAmzContentSha256 != null) {
            localVarHeaderParams.put("X-Amz-Content-Sha256", localVarApiClient.parameterToString(xAmzContentSha256));
        }

        if (xAmzDate != null) {
            localVarHeaderParams.put("X-Amz-Date", localVarApiClient.parameterToString(xAmzDate));
        }

        if (xAmzAlgorithm != null) {
            localVarHeaderParams.put("X-Amz-Algorithm", localVarApiClient.parameterToString(xAmzAlgorithm));
        }

        if (xAmzCredential != null) {
            localVarHeaderParams.put("X-Amz-Credential", localVarApiClient.parameterToString(xAmzCredential));
        }

        if (xAmzSecurityToken != null) {
            localVarHeaderParams.put("X-Amz-Security-Token", localVarApiClient.parameterToString(xAmzSecurityToken));
        }

        if (xAmzSignature != null) {
            localVarHeaderParams.put("X-Amz-Signature", localVarApiClient.parameterToString(xAmzSignature));
        }

        if (xAmzSignedHeaders != null) {
            localVarHeaderParams.put("X-Amz-SignedHeaders", localVarApiClient.parameterToString(xAmzSignedHeaders));
        }

        final String[] localVarAccepts = {
            "text/xml"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            "text/xml"
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "hmac" };
        return localVarApiClient.buildCall(basePath, localVarPath, "POST", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call pOSTDescribeClusterSecurityGroupsValidateBeforeCall(String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, String maxRecords, String marker, DescribeClusterSecurityGroupsMessage describeClusterSecurityGroupsMessage, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'action' is set
        if (action == null) {
            throw new ApiException("Missing the required parameter 'action' when calling pOSTDescribeClusterSecurityGroups(Async)");
        }

        // verify the required parameter 'version' is set
        if (version == null) {
            throw new ApiException("Missing the required parameter 'version' when calling pOSTDescribeClusterSecurityGroups(Async)");
        }

        return pOSTDescribeClusterSecurityGroupsCall(action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, maxRecords, marker, describeClusterSecurityGroupsMessage, _callback);

    }

    /**
     * 
     * &lt;p&gt;Returns information about Amazon Redshift security groups. If the name of a security group is specified, the response will contain only information about only that security group.&lt;/p&gt; &lt;p&gt; For information about managing security groups, go to &lt;a href&#x3D;\&quot;https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-security-groups.html\&quot;&gt;Amazon Redshift Cluster Security Groups&lt;/a&gt; in the &lt;i&gt;Amazon Redshift Cluster Management Guide&lt;/i&gt;.&lt;/p&gt; &lt;p&gt;If you specify both tag keys and tag values in the same request, Amazon Redshift returns all security groups that match any combination of the specified keys and values. For example, if you have &lt;code&gt;owner&lt;/code&gt; and &lt;code&gt;environment&lt;/code&gt; for tag keys, and &lt;code&gt;admin&lt;/code&gt; and &lt;code&gt;test&lt;/code&gt; for tag values, all security groups that have any combination of those values are returned.&lt;/p&gt; &lt;p&gt;If both tag keys and values are omitted from the request, security groups are returned regardless of whether they have tag keys or values associated with them.&lt;/p&gt;
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param maxRecords Pagination limit (optional)
     * @param marker Pagination token (optional)
     * @param describeClusterSecurityGroupsMessage  (optional)
     * @return ClusterSecurityGroupMessage
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> ClusterSecurityGroupNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> InvalidTagFault </td><td>  -  </td></tr>
     </table>
     */
    public ClusterSecurityGroupMessage pOSTDescribeClusterSecurityGroups(String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, String maxRecords, String marker, DescribeClusterSecurityGroupsMessage describeClusterSecurityGroupsMessage) throws ApiException {
        ApiResponse<ClusterSecurityGroupMessage> localVarResp = pOSTDescribeClusterSecurityGroupsWithHttpInfo(action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, maxRecords, marker, describeClusterSecurityGroupsMessage);
        return localVarResp.getData();
    }

    /**
     * 
     * &lt;p&gt;Returns information about Amazon Redshift security groups. If the name of a security group is specified, the response will contain only information about only that security group.&lt;/p&gt; &lt;p&gt; For information about managing security groups, go to &lt;a href&#x3D;\&quot;https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-security-groups.html\&quot;&gt;Amazon Redshift Cluster Security Groups&lt;/a&gt; in the &lt;i&gt;Amazon Redshift Cluster Management Guide&lt;/i&gt;.&lt;/p&gt; &lt;p&gt;If you specify both tag keys and tag values in the same request, Amazon Redshift returns all security groups that match any combination of the specified keys and values. For example, if you have &lt;code&gt;owner&lt;/code&gt; and &lt;code&gt;environment&lt;/code&gt; for tag keys, and &lt;code&gt;admin&lt;/code&gt; and &lt;code&gt;test&lt;/code&gt; for tag values, all security groups that have any combination of those values are returned.&lt;/p&gt; &lt;p&gt;If both tag keys and values are omitted from the request, security groups are returned regardless of whether they have tag keys or values associated with them.&lt;/p&gt;
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param maxRecords Pagination limit (optional)
     * @param marker Pagination token (optional)
     * @param describeClusterSecurityGroupsMessage  (optional)
     * @return ApiResponse&lt;ClusterSecurityGroupMessage&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> ClusterSecurityGroupNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> InvalidTagFault </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<ClusterSecurityGroupMessage> pOSTDescribeClusterSecurityGroupsWithHttpInfo(String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, String maxRecords, String marker, DescribeClusterSecurityGroupsMessage describeClusterSecurityGroupsMessage) throws ApiException {
        okhttp3.Call localVarCall = pOSTDescribeClusterSecurityGroupsValidateBeforeCall(action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, maxRecords, marker, describeClusterSecurityGroupsMessage, null);
        Type localVarReturnType = new TypeToken<ClusterSecurityGroupMessage>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     *  (asynchronously)
     * &lt;p&gt;Returns information about Amazon Redshift security groups. If the name of a security group is specified, the response will contain only information about only that security group.&lt;/p&gt; &lt;p&gt; For information about managing security groups, go to &lt;a href&#x3D;\&quot;https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-security-groups.html\&quot;&gt;Amazon Redshift Cluster Security Groups&lt;/a&gt; in the &lt;i&gt;Amazon Redshift Cluster Management Guide&lt;/i&gt;.&lt;/p&gt; &lt;p&gt;If you specify both tag keys and tag values in the same request, Amazon Redshift returns all security groups that match any combination of the specified keys and values. For example, if you have &lt;code&gt;owner&lt;/code&gt; and &lt;code&gt;environment&lt;/code&gt; for tag keys, and &lt;code&gt;admin&lt;/code&gt; and &lt;code&gt;test&lt;/code&gt; for tag values, all security groups that have any combination of those values are returned.&lt;/p&gt; &lt;p&gt;If both tag keys and values are omitted from the request, security groups are returned regardless of whether they have tag keys or values associated with them.&lt;/p&gt;
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param maxRecords Pagination limit (optional)
     * @param marker Pagination token (optional)
     * @param describeClusterSecurityGroupsMessage  (optional)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> ClusterSecurityGroupNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> InvalidTagFault </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call pOSTDescribeClusterSecurityGroupsAsync(String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, String maxRecords, String marker, DescribeClusterSecurityGroupsMessage describeClusterSecurityGroupsMessage, final ApiCallback<ClusterSecurityGroupMessage> _callback) throws ApiException {

        okhttp3.Call localVarCall = pOSTDescribeClusterSecurityGroupsValidateBeforeCall(action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, maxRecords, marker, describeClusterSecurityGroupsMessage, _callback);
        Type localVarReturnType = new TypeToken<ClusterSecurityGroupMessage>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for pOSTDescribeClusterSnapshots
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param maxRecords Pagination limit (optional)
     * @param marker Pagination token (optional)
     * @param describeClusterSnapshotsMessage  (optional)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> ClusterNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> ClusterSnapshotNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 482 </td><td> InvalidTagFault </td><td>  -  </td></tr>
        <tr><td> 483 </td><td> UnsupportedOperationFault </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call pOSTDescribeClusterSnapshotsCall(String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, String maxRecords, String marker, DescribeClusterSnapshotsMessage describeClusterSnapshotsMessage, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = describeClusterSnapshotsMessage;

        // create path and map variables
        String localVarPath = "/#Action=DescribeClusterSnapshots";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (maxRecords != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("MaxRecords", maxRecords));
        }

        if (marker != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("Marker", marker));
        }

        if (action != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("Action", action));
        }

        if (version != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("Version", version));
        }

        if (xAmzContentSha256 != null) {
            localVarHeaderParams.put("X-Amz-Content-Sha256", localVarApiClient.parameterToString(xAmzContentSha256));
        }

        if (xAmzDate != null) {
            localVarHeaderParams.put("X-Amz-Date", localVarApiClient.parameterToString(xAmzDate));
        }

        if (xAmzAlgorithm != null) {
            localVarHeaderParams.put("X-Amz-Algorithm", localVarApiClient.parameterToString(xAmzAlgorithm));
        }

        if (xAmzCredential != null) {
            localVarHeaderParams.put("X-Amz-Credential", localVarApiClient.parameterToString(xAmzCredential));
        }

        if (xAmzSecurityToken != null) {
            localVarHeaderParams.put("X-Amz-Security-Token", localVarApiClient.parameterToString(xAmzSecurityToken));
        }

        if (xAmzSignature != null) {
            localVarHeaderParams.put("X-Amz-Signature", localVarApiClient.parameterToString(xAmzSignature));
        }

        if (xAmzSignedHeaders != null) {
            localVarHeaderParams.put("X-Amz-SignedHeaders", localVarApiClient.parameterToString(xAmzSignedHeaders));
        }

        final String[] localVarAccepts = {
            "text/xml"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            "text/xml"
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "hmac" };
        return localVarApiClient.buildCall(basePath, localVarPath, "POST", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call pOSTDescribeClusterSnapshotsValidateBeforeCall(String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, String maxRecords, String marker, DescribeClusterSnapshotsMessage describeClusterSnapshotsMessage, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'action' is set
        if (action == null) {
            throw new ApiException("Missing the required parameter 'action' when calling pOSTDescribeClusterSnapshots(Async)");
        }

        // verify the required parameter 'version' is set
        if (version == null) {
            throw new ApiException("Missing the required parameter 'version' when calling pOSTDescribeClusterSnapshots(Async)");
        }

        return pOSTDescribeClusterSnapshotsCall(action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, maxRecords, marker, describeClusterSnapshotsMessage, _callback);

    }

    /**
     * 
     * &lt;p&gt;Returns one or more snapshot objects, which contain metadata about your cluster snapshots. By default, this operation returns information about all snapshots of all clusters that are owned by your Amazon Web Services account. No information is returned for snapshots owned by inactive Amazon Web Services accounts.&lt;/p&gt; &lt;p&gt;If you specify both tag keys and tag values in the same request, Amazon Redshift returns all snapshots that match any combination of the specified keys and values. For example, if you have &lt;code&gt;owner&lt;/code&gt; and &lt;code&gt;environment&lt;/code&gt; for tag keys, and &lt;code&gt;admin&lt;/code&gt; and &lt;code&gt;test&lt;/code&gt; for tag values, all snapshots that have any combination of those values are returned. Only snapshots that you own are returned in the response; shared snapshots are not returned with the tag key and tag value request parameters.&lt;/p&gt; &lt;p&gt;If both tag keys and values are omitted from the request, snapshots are returned regardless of whether they have tag keys or values associated with them.&lt;/p&gt;
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param maxRecords Pagination limit (optional)
     * @param marker Pagination token (optional)
     * @param describeClusterSnapshotsMessage  (optional)
     * @return SnapshotMessage
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> ClusterNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> ClusterSnapshotNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 482 </td><td> InvalidTagFault </td><td>  -  </td></tr>
        <tr><td> 483 </td><td> UnsupportedOperationFault </td><td>  -  </td></tr>
     </table>
     */
    public SnapshotMessage pOSTDescribeClusterSnapshots(String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, String maxRecords, String marker, DescribeClusterSnapshotsMessage describeClusterSnapshotsMessage) throws ApiException {
        ApiResponse<SnapshotMessage> localVarResp = pOSTDescribeClusterSnapshotsWithHttpInfo(action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, maxRecords, marker, describeClusterSnapshotsMessage);
        return localVarResp.getData();
    }

    /**
     * 
     * &lt;p&gt;Returns one or more snapshot objects, which contain metadata about your cluster snapshots. By default, this operation returns information about all snapshots of all clusters that are owned by your Amazon Web Services account. No information is returned for snapshots owned by inactive Amazon Web Services accounts.&lt;/p&gt; &lt;p&gt;If you specify both tag keys and tag values in the same request, Amazon Redshift returns all snapshots that match any combination of the specified keys and values. For example, if you have &lt;code&gt;owner&lt;/code&gt; and &lt;code&gt;environment&lt;/code&gt; for tag keys, and &lt;code&gt;admin&lt;/code&gt; and &lt;code&gt;test&lt;/code&gt; for tag values, all snapshots that have any combination of those values are returned. Only snapshots that you own are returned in the response; shared snapshots are not returned with the tag key and tag value request parameters.&lt;/p&gt; &lt;p&gt;If both tag keys and values are omitted from the request, snapshots are returned regardless of whether they have tag keys or values associated with them.&lt;/p&gt;
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param maxRecords Pagination limit (optional)
     * @param marker Pagination token (optional)
     * @param describeClusterSnapshotsMessage  (optional)
     * @return ApiResponse&lt;SnapshotMessage&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> ClusterNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> ClusterSnapshotNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 482 </td><td> InvalidTagFault </td><td>  -  </td></tr>
        <tr><td> 483 </td><td> UnsupportedOperationFault </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<SnapshotMessage> pOSTDescribeClusterSnapshotsWithHttpInfo(String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, String maxRecords, String marker, DescribeClusterSnapshotsMessage describeClusterSnapshotsMessage) throws ApiException {
        okhttp3.Call localVarCall = pOSTDescribeClusterSnapshotsValidateBeforeCall(action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, maxRecords, marker, describeClusterSnapshotsMessage, null);
        Type localVarReturnType = new TypeToken<SnapshotMessage>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     *  (asynchronously)
     * &lt;p&gt;Returns one or more snapshot objects, which contain metadata about your cluster snapshots. By default, this operation returns information about all snapshots of all clusters that are owned by your Amazon Web Services account. No information is returned for snapshots owned by inactive Amazon Web Services accounts.&lt;/p&gt; &lt;p&gt;If you specify both tag keys and tag values in the same request, Amazon Redshift returns all snapshots that match any combination of the specified keys and values. For example, if you have &lt;code&gt;owner&lt;/code&gt; and &lt;code&gt;environment&lt;/code&gt; for tag keys, and &lt;code&gt;admin&lt;/code&gt; and &lt;code&gt;test&lt;/code&gt; for tag values, all snapshots that have any combination of those values are returned. Only snapshots that you own are returned in the response; shared snapshots are not returned with the tag key and tag value request parameters.&lt;/p&gt; &lt;p&gt;If both tag keys and values are omitted from the request, snapshots are returned regardless of whether they have tag keys or values associated with them.&lt;/p&gt;
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param maxRecords Pagination limit (optional)
     * @param marker Pagination token (optional)
     * @param describeClusterSnapshotsMessage  (optional)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> ClusterNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> ClusterSnapshotNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 482 </td><td> InvalidTagFault </td><td>  -  </td></tr>
        <tr><td> 483 </td><td> UnsupportedOperationFault </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call pOSTDescribeClusterSnapshotsAsync(String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, String maxRecords, String marker, DescribeClusterSnapshotsMessage describeClusterSnapshotsMessage, final ApiCallback<SnapshotMessage> _callback) throws ApiException {

        okhttp3.Call localVarCall = pOSTDescribeClusterSnapshotsValidateBeforeCall(action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, maxRecords, marker, describeClusterSnapshotsMessage, _callback);
        Type localVarReturnType = new TypeToken<SnapshotMessage>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for pOSTDescribeClusterSubnetGroups
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param maxRecords Pagination limit (optional)
     * @param marker Pagination token (optional)
     * @param describeClusterSubnetGroupsMessage  (optional)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> ClusterSubnetGroupNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> InvalidTagFault </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call pOSTDescribeClusterSubnetGroupsCall(String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, String maxRecords, String marker, DescribeClusterSubnetGroupsMessage describeClusterSubnetGroupsMessage, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = describeClusterSubnetGroupsMessage;

        // create path and map variables
        String localVarPath = "/#Action=DescribeClusterSubnetGroups";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (maxRecords != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("MaxRecords", maxRecords));
        }

        if (marker != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("Marker", marker));
        }

        if (action != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("Action", action));
        }

        if (version != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("Version", version));
        }

        if (xAmzContentSha256 != null) {
            localVarHeaderParams.put("X-Amz-Content-Sha256", localVarApiClient.parameterToString(xAmzContentSha256));
        }

        if (xAmzDate != null) {
            localVarHeaderParams.put("X-Amz-Date", localVarApiClient.parameterToString(xAmzDate));
        }

        if (xAmzAlgorithm != null) {
            localVarHeaderParams.put("X-Amz-Algorithm", localVarApiClient.parameterToString(xAmzAlgorithm));
        }

        if (xAmzCredential != null) {
            localVarHeaderParams.put("X-Amz-Credential", localVarApiClient.parameterToString(xAmzCredential));
        }

        if (xAmzSecurityToken != null) {
            localVarHeaderParams.put("X-Amz-Security-Token", localVarApiClient.parameterToString(xAmzSecurityToken));
        }

        if (xAmzSignature != null) {
            localVarHeaderParams.put("X-Amz-Signature", localVarApiClient.parameterToString(xAmzSignature));
        }

        if (xAmzSignedHeaders != null) {
            localVarHeaderParams.put("X-Amz-SignedHeaders", localVarApiClient.parameterToString(xAmzSignedHeaders));
        }

        final String[] localVarAccepts = {
            "text/xml"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            "text/xml"
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "hmac" };
        return localVarApiClient.buildCall(basePath, localVarPath, "POST", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call pOSTDescribeClusterSubnetGroupsValidateBeforeCall(String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, String maxRecords, String marker, DescribeClusterSubnetGroupsMessage describeClusterSubnetGroupsMessage, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'action' is set
        if (action == null) {
            throw new ApiException("Missing the required parameter 'action' when calling pOSTDescribeClusterSubnetGroups(Async)");
        }

        // verify the required parameter 'version' is set
        if (version == null) {
            throw new ApiException("Missing the required parameter 'version' when calling pOSTDescribeClusterSubnetGroups(Async)");
        }

        return pOSTDescribeClusterSubnetGroupsCall(action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, maxRecords, marker, describeClusterSubnetGroupsMessage, _callback);

    }

    /**
     * 
     * &lt;p&gt;Returns one or more cluster subnet group objects, which contain metadata about your cluster subnet groups. By default, this operation returns information about all cluster subnet groups that are defined in your Amazon Web Services account.&lt;/p&gt; &lt;p&gt;If you specify both tag keys and tag values in the same request, Amazon Redshift returns all subnet groups that match any combination of the specified keys and values. For example, if you have &lt;code&gt;owner&lt;/code&gt; and &lt;code&gt;environment&lt;/code&gt; for tag keys, and &lt;code&gt;admin&lt;/code&gt; and &lt;code&gt;test&lt;/code&gt; for tag values, all subnet groups that have any combination of those values are returned.&lt;/p&gt; &lt;p&gt;If both tag keys and values are omitted from the request, subnet groups are returned regardless of whether they have tag keys or values associated with them.&lt;/p&gt;
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param maxRecords Pagination limit (optional)
     * @param marker Pagination token (optional)
     * @param describeClusterSubnetGroupsMessage  (optional)
     * @return ClusterSubnetGroupMessage
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> ClusterSubnetGroupNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> InvalidTagFault </td><td>  -  </td></tr>
     </table>
     */
    public ClusterSubnetGroupMessage pOSTDescribeClusterSubnetGroups(String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, String maxRecords, String marker, DescribeClusterSubnetGroupsMessage describeClusterSubnetGroupsMessage) throws ApiException {
        ApiResponse<ClusterSubnetGroupMessage> localVarResp = pOSTDescribeClusterSubnetGroupsWithHttpInfo(action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, maxRecords, marker, describeClusterSubnetGroupsMessage);
        return localVarResp.getData();
    }

    /**
     * 
     * &lt;p&gt;Returns one or more cluster subnet group objects, which contain metadata about your cluster subnet groups. By default, this operation returns information about all cluster subnet groups that are defined in your Amazon Web Services account.&lt;/p&gt; &lt;p&gt;If you specify both tag keys and tag values in the same request, Amazon Redshift returns all subnet groups that match any combination of the specified keys and values. For example, if you have &lt;code&gt;owner&lt;/code&gt; and &lt;code&gt;environment&lt;/code&gt; for tag keys, and &lt;code&gt;admin&lt;/code&gt; and &lt;code&gt;test&lt;/code&gt; for tag values, all subnet groups that have any combination of those values are returned.&lt;/p&gt; &lt;p&gt;If both tag keys and values are omitted from the request, subnet groups are returned regardless of whether they have tag keys or values associated with them.&lt;/p&gt;
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param maxRecords Pagination limit (optional)
     * @param marker Pagination token (optional)
     * @param describeClusterSubnetGroupsMessage  (optional)
     * @return ApiResponse&lt;ClusterSubnetGroupMessage&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> ClusterSubnetGroupNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> InvalidTagFault </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<ClusterSubnetGroupMessage> pOSTDescribeClusterSubnetGroupsWithHttpInfo(String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, String maxRecords, String marker, DescribeClusterSubnetGroupsMessage describeClusterSubnetGroupsMessage) throws ApiException {
        okhttp3.Call localVarCall = pOSTDescribeClusterSubnetGroupsValidateBeforeCall(action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, maxRecords, marker, describeClusterSubnetGroupsMessage, null);
        Type localVarReturnType = new TypeToken<ClusterSubnetGroupMessage>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     *  (asynchronously)
     * &lt;p&gt;Returns one or more cluster subnet group objects, which contain metadata about your cluster subnet groups. By default, this operation returns information about all cluster subnet groups that are defined in your Amazon Web Services account.&lt;/p&gt; &lt;p&gt;If you specify both tag keys and tag values in the same request, Amazon Redshift returns all subnet groups that match any combination of the specified keys and values. For example, if you have &lt;code&gt;owner&lt;/code&gt; and &lt;code&gt;environment&lt;/code&gt; for tag keys, and &lt;code&gt;admin&lt;/code&gt; and &lt;code&gt;test&lt;/code&gt; for tag values, all subnet groups that have any combination of those values are returned.&lt;/p&gt; &lt;p&gt;If both tag keys and values are omitted from the request, subnet groups are returned regardless of whether they have tag keys or values associated with them.&lt;/p&gt;
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param maxRecords Pagination limit (optional)
     * @param marker Pagination token (optional)
     * @param describeClusterSubnetGroupsMessage  (optional)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> ClusterSubnetGroupNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> InvalidTagFault </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call pOSTDescribeClusterSubnetGroupsAsync(String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, String maxRecords, String marker, DescribeClusterSubnetGroupsMessage describeClusterSubnetGroupsMessage, final ApiCallback<ClusterSubnetGroupMessage> _callback) throws ApiException {

        okhttp3.Call localVarCall = pOSTDescribeClusterSubnetGroupsValidateBeforeCall(action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, maxRecords, marker, describeClusterSubnetGroupsMessage, _callback);
        Type localVarReturnType = new TypeToken<ClusterSubnetGroupMessage>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for pOSTDescribeClusterTracks
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param maxRecords Pagination limit (optional)
     * @param marker Pagination token (optional)
     * @param describeClusterTracksMessage  (optional)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> InvalidClusterTrackFault </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> UnauthorizedOperation </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call pOSTDescribeClusterTracksCall(String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, String maxRecords, String marker, DescribeClusterTracksMessage describeClusterTracksMessage, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = describeClusterTracksMessage;

        // create path and map variables
        String localVarPath = "/#Action=DescribeClusterTracks";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (maxRecords != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("MaxRecords", maxRecords));
        }

        if (marker != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("Marker", marker));
        }

        if (action != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("Action", action));
        }

        if (version != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("Version", version));
        }

        if (xAmzContentSha256 != null) {
            localVarHeaderParams.put("X-Amz-Content-Sha256", localVarApiClient.parameterToString(xAmzContentSha256));
        }

        if (xAmzDate != null) {
            localVarHeaderParams.put("X-Amz-Date", localVarApiClient.parameterToString(xAmzDate));
        }

        if (xAmzAlgorithm != null) {
            localVarHeaderParams.put("X-Amz-Algorithm", localVarApiClient.parameterToString(xAmzAlgorithm));
        }

        if (xAmzCredential != null) {
            localVarHeaderParams.put("X-Amz-Credential", localVarApiClient.parameterToString(xAmzCredential));
        }

        if (xAmzSecurityToken != null) {
            localVarHeaderParams.put("X-Amz-Security-Token", localVarApiClient.parameterToString(xAmzSecurityToken));
        }

        if (xAmzSignature != null) {
            localVarHeaderParams.put("X-Amz-Signature", localVarApiClient.parameterToString(xAmzSignature));
        }

        if (xAmzSignedHeaders != null) {
            localVarHeaderParams.put("X-Amz-SignedHeaders", localVarApiClient.parameterToString(xAmzSignedHeaders));
        }

        final String[] localVarAccepts = {
            "text/xml"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            "text/xml"
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "hmac" };
        return localVarApiClient.buildCall(basePath, localVarPath, "POST", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call pOSTDescribeClusterTracksValidateBeforeCall(String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, String maxRecords, String marker, DescribeClusterTracksMessage describeClusterTracksMessage, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'action' is set
        if (action == null) {
            throw new ApiException("Missing the required parameter 'action' when calling pOSTDescribeClusterTracks(Async)");
        }

        // verify the required parameter 'version' is set
        if (version == null) {
            throw new ApiException("Missing the required parameter 'version' when calling pOSTDescribeClusterTracks(Async)");
        }

        return pOSTDescribeClusterTracksCall(action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, maxRecords, marker, describeClusterTracksMessage, _callback);

    }

    /**
     * 
     * Returns a list of all the available maintenance tracks.
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param maxRecords Pagination limit (optional)
     * @param marker Pagination token (optional)
     * @param describeClusterTracksMessage  (optional)
     * @return TrackListMessage
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> InvalidClusterTrackFault </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> UnauthorizedOperation </td><td>  -  </td></tr>
     </table>
     */
    public TrackListMessage pOSTDescribeClusterTracks(String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, String maxRecords, String marker, DescribeClusterTracksMessage describeClusterTracksMessage) throws ApiException {
        ApiResponse<TrackListMessage> localVarResp = pOSTDescribeClusterTracksWithHttpInfo(action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, maxRecords, marker, describeClusterTracksMessage);
        return localVarResp.getData();
    }

    /**
     * 
     * Returns a list of all the available maintenance tracks.
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param maxRecords Pagination limit (optional)
     * @param marker Pagination token (optional)
     * @param describeClusterTracksMessage  (optional)
     * @return ApiResponse&lt;TrackListMessage&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> InvalidClusterTrackFault </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> UnauthorizedOperation </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<TrackListMessage> pOSTDescribeClusterTracksWithHttpInfo(String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, String maxRecords, String marker, DescribeClusterTracksMessage describeClusterTracksMessage) throws ApiException {
        okhttp3.Call localVarCall = pOSTDescribeClusterTracksValidateBeforeCall(action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, maxRecords, marker, describeClusterTracksMessage, null);
        Type localVarReturnType = new TypeToken<TrackListMessage>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     *  (asynchronously)
     * Returns a list of all the available maintenance tracks.
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param maxRecords Pagination limit (optional)
     * @param marker Pagination token (optional)
     * @param describeClusterTracksMessage  (optional)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> InvalidClusterTrackFault </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> UnauthorizedOperation </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call pOSTDescribeClusterTracksAsync(String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, String maxRecords, String marker, DescribeClusterTracksMessage describeClusterTracksMessage, final ApiCallback<TrackListMessage> _callback) throws ApiException {

        okhttp3.Call localVarCall = pOSTDescribeClusterTracksValidateBeforeCall(action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, maxRecords, marker, describeClusterTracksMessage, _callback);
        Type localVarReturnType = new TypeToken<TrackListMessage>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for pOSTDescribeClusterVersions
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param maxRecords Pagination limit (optional)
     * @param marker Pagination token (optional)
     * @param describeClusterVersionsMessage  (optional)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call pOSTDescribeClusterVersionsCall(String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, String maxRecords, String marker, DescribeClusterVersionsMessage describeClusterVersionsMessage, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = describeClusterVersionsMessage;

        // create path and map variables
        String localVarPath = "/#Action=DescribeClusterVersions";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (maxRecords != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("MaxRecords", maxRecords));
        }

        if (marker != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("Marker", marker));
        }

        if (action != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("Action", action));
        }

        if (version != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("Version", version));
        }

        if (xAmzContentSha256 != null) {
            localVarHeaderParams.put("X-Amz-Content-Sha256", localVarApiClient.parameterToString(xAmzContentSha256));
        }

        if (xAmzDate != null) {
            localVarHeaderParams.put("X-Amz-Date", localVarApiClient.parameterToString(xAmzDate));
        }

        if (xAmzAlgorithm != null) {
            localVarHeaderParams.put("X-Amz-Algorithm", localVarApiClient.parameterToString(xAmzAlgorithm));
        }

        if (xAmzCredential != null) {
            localVarHeaderParams.put("X-Amz-Credential", localVarApiClient.parameterToString(xAmzCredential));
        }

        if (xAmzSecurityToken != null) {
            localVarHeaderParams.put("X-Amz-Security-Token", localVarApiClient.parameterToString(xAmzSecurityToken));
        }

        if (xAmzSignature != null) {
            localVarHeaderParams.put("X-Amz-Signature", localVarApiClient.parameterToString(xAmzSignature));
        }

        if (xAmzSignedHeaders != null) {
            localVarHeaderParams.put("X-Amz-SignedHeaders", localVarApiClient.parameterToString(xAmzSignedHeaders));
        }

        final String[] localVarAccepts = {
            "text/xml"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            "text/xml"
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "hmac" };
        return localVarApiClient.buildCall(basePath, localVarPath, "POST", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call pOSTDescribeClusterVersionsValidateBeforeCall(String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, String maxRecords, String marker, DescribeClusterVersionsMessage describeClusterVersionsMessage, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'action' is set
        if (action == null) {
            throw new ApiException("Missing the required parameter 'action' when calling pOSTDescribeClusterVersions(Async)");
        }

        // verify the required parameter 'version' is set
        if (version == null) {
            throw new ApiException("Missing the required parameter 'version' when calling pOSTDescribeClusterVersions(Async)");
        }

        return pOSTDescribeClusterVersionsCall(action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, maxRecords, marker, describeClusterVersionsMessage, _callback);

    }

    /**
     * 
     * Returns descriptions of the available Amazon Redshift cluster versions. You can call this operation even before creating any clusters to learn more about the Amazon Redshift versions. For more information about managing clusters, go to &lt;a href&#x3D;\&quot;https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html\&quot;&gt;Amazon Redshift Clusters&lt;/a&gt; in the &lt;i&gt;Amazon Redshift Cluster Management Guide&lt;/i&gt;.
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param maxRecords Pagination limit (optional)
     * @param marker Pagination token (optional)
     * @param describeClusterVersionsMessage  (optional)
     * @return ClusterVersionsMessage
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
     </table>
     */
    public ClusterVersionsMessage pOSTDescribeClusterVersions(String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, String maxRecords, String marker, DescribeClusterVersionsMessage describeClusterVersionsMessage) throws ApiException {
        ApiResponse<ClusterVersionsMessage> localVarResp = pOSTDescribeClusterVersionsWithHttpInfo(action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, maxRecords, marker, describeClusterVersionsMessage);
        return localVarResp.getData();
    }

    /**
     * 
     * Returns descriptions of the available Amazon Redshift cluster versions. You can call this operation even before creating any clusters to learn more about the Amazon Redshift versions. For more information about managing clusters, go to &lt;a href&#x3D;\&quot;https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html\&quot;&gt;Amazon Redshift Clusters&lt;/a&gt; in the &lt;i&gt;Amazon Redshift Cluster Management Guide&lt;/i&gt;.
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param maxRecords Pagination limit (optional)
     * @param marker Pagination token (optional)
     * @param describeClusterVersionsMessage  (optional)
     * @return ApiResponse&lt;ClusterVersionsMessage&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<ClusterVersionsMessage> pOSTDescribeClusterVersionsWithHttpInfo(String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, String maxRecords, String marker, DescribeClusterVersionsMessage describeClusterVersionsMessage) throws ApiException {
        okhttp3.Call localVarCall = pOSTDescribeClusterVersionsValidateBeforeCall(action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, maxRecords, marker, describeClusterVersionsMessage, null);
        Type localVarReturnType = new TypeToken<ClusterVersionsMessage>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     *  (asynchronously)
     * Returns descriptions of the available Amazon Redshift cluster versions. You can call this operation even before creating any clusters to learn more about the Amazon Redshift versions. For more information about managing clusters, go to &lt;a href&#x3D;\&quot;https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html\&quot;&gt;Amazon Redshift Clusters&lt;/a&gt; in the &lt;i&gt;Amazon Redshift Cluster Management Guide&lt;/i&gt;.
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param maxRecords Pagination limit (optional)
     * @param marker Pagination token (optional)
     * @param describeClusterVersionsMessage  (optional)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call pOSTDescribeClusterVersionsAsync(String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, String maxRecords, String marker, DescribeClusterVersionsMessage describeClusterVersionsMessage, final ApiCallback<ClusterVersionsMessage> _callback) throws ApiException {

        okhttp3.Call localVarCall = pOSTDescribeClusterVersionsValidateBeforeCall(action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, maxRecords, marker, describeClusterVersionsMessage, _callback);
        Type localVarReturnType = new TypeToken<ClusterVersionsMessage>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for pOSTDescribeClusters
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param maxRecords Pagination limit (optional)
     * @param marker Pagination token (optional)
     * @param describeClustersMessage  (optional)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> ClusterNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> InvalidTagFault </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call pOSTDescribeClustersCall(String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, String maxRecords, String marker, DescribeClustersMessage describeClustersMessage, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = describeClustersMessage;

        // create path and map variables
        String localVarPath = "/#Action=DescribeClusters";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (maxRecords != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("MaxRecords", maxRecords));
        }

        if (marker != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("Marker", marker));
        }

        if (action != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("Action", action));
        }

        if (version != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("Version", version));
        }

        if (xAmzContentSha256 != null) {
            localVarHeaderParams.put("X-Amz-Content-Sha256", localVarApiClient.parameterToString(xAmzContentSha256));
        }

        if (xAmzDate != null) {
            localVarHeaderParams.put("X-Amz-Date", localVarApiClient.parameterToString(xAmzDate));
        }

        if (xAmzAlgorithm != null) {
            localVarHeaderParams.put("X-Amz-Algorithm", localVarApiClient.parameterToString(xAmzAlgorithm));
        }

        if (xAmzCredential != null) {
            localVarHeaderParams.put("X-Amz-Credential", localVarApiClient.parameterToString(xAmzCredential));
        }

        if (xAmzSecurityToken != null) {
            localVarHeaderParams.put("X-Amz-Security-Token", localVarApiClient.parameterToString(xAmzSecurityToken));
        }

        if (xAmzSignature != null) {
            localVarHeaderParams.put("X-Amz-Signature", localVarApiClient.parameterToString(xAmzSignature));
        }

        if (xAmzSignedHeaders != null) {
            localVarHeaderParams.put("X-Amz-SignedHeaders", localVarApiClient.parameterToString(xAmzSignedHeaders));
        }

        final String[] localVarAccepts = {
            "text/xml"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            "text/xml"
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "hmac" };
        return localVarApiClient.buildCall(basePath, localVarPath, "POST", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call pOSTDescribeClustersValidateBeforeCall(String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, String maxRecords, String marker, DescribeClustersMessage describeClustersMessage, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'action' is set
        if (action == null) {
            throw new ApiException("Missing the required parameter 'action' when calling pOSTDescribeClusters(Async)");
        }

        // verify the required parameter 'version' is set
        if (version == null) {
            throw new ApiException("Missing the required parameter 'version' when calling pOSTDescribeClusters(Async)");
        }

        return pOSTDescribeClustersCall(action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, maxRecords, marker, describeClustersMessage, _callback);

    }

    /**
     * 
     * &lt;p&gt;Returns properties of provisioned clusters including general cluster properties, cluster database properties, maintenance and backup properties, and security and access properties. This operation supports pagination. For more information about managing clusters, go to &lt;a href&#x3D;\&quot;https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html\&quot;&gt;Amazon Redshift Clusters&lt;/a&gt; in the &lt;i&gt;Amazon Redshift Cluster Management Guide&lt;/i&gt;.&lt;/p&gt; &lt;p&gt;If you specify both tag keys and tag values in the same request, Amazon Redshift returns all clusters that match any combination of the specified keys and values. For example, if you have &lt;code&gt;owner&lt;/code&gt; and &lt;code&gt;environment&lt;/code&gt; for tag keys, and &lt;code&gt;admin&lt;/code&gt; and &lt;code&gt;test&lt;/code&gt; for tag values, all clusters that have any combination of those values are returned.&lt;/p&gt; &lt;p&gt;If both tag keys and values are omitted from the request, clusters are returned regardless of whether they have tag keys or values associated with them.&lt;/p&gt;
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param maxRecords Pagination limit (optional)
     * @param marker Pagination token (optional)
     * @param describeClustersMessage  (optional)
     * @return ClustersMessage
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> ClusterNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> InvalidTagFault </td><td>  -  </td></tr>
     </table>
     */
    public ClustersMessage pOSTDescribeClusters(String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, String maxRecords, String marker, DescribeClustersMessage describeClustersMessage) throws ApiException {
        ApiResponse<ClustersMessage> localVarResp = pOSTDescribeClustersWithHttpInfo(action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, maxRecords, marker, describeClustersMessage);
        return localVarResp.getData();
    }

    /**
     * 
     * &lt;p&gt;Returns properties of provisioned clusters including general cluster properties, cluster database properties, maintenance and backup properties, and security and access properties. This operation supports pagination. For more information about managing clusters, go to &lt;a href&#x3D;\&quot;https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html\&quot;&gt;Amazon Redshift Clusters&lt;/a&gt; in the &lt;i&gt;Amazon Redshift Cluster Management Guide&lt;/i&gt;.&lt;/p&gt; &lt;p&gt;If you specify both tag keys and tag values in the same request, Amazon Redshift returns all clusters that match any combination of the specified keys and values. For example, if you have &lt;code&gt;owner&lt;/code&gt; and &lt;code&gt;environment&lt;/code&gt; for tag keys, and &lt;code&gt;admin&lt;/code&gt; and &lt;code&gt;test&lt;/code&gt; for tag values, all clusters that have any combination of those values are returned.&lt;/p&gt; &lt;p&gt;If both tag keys and values are omitted from the request, clusters are returned regardless of whether they have tag keys or values associated with them.&lt;/p&gt;
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param maxRecords Pagination limit (optional)
     * @param marker Pagination token (optional)
     * @param describeClustersMessage  (optional)
     * @return ApiResponse&lt;ClustersMessage&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> ClusterNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> InvalidTagFault </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<ClustersMessage> pOSTDescribeClustersWithHttpInfo(String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, String maxRecords, String marker, DescribeClustersMessage describeClustersMessage) throws ApiException {
        okhttp3.Call localVarCall = pOSTDescribeClustersValidateBeforeCall(action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, maxRecords, marker, describeClustersMessage, null);
        Type localVarReturnType = new TypeToken<ClustersMessage>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     *  (asynchronously)
     * &lt;p&gt;Returns properties of provisioned clusters including general cluster properties, cluster database properties, maintenance and backup properties, and security and access properties. This operation supports pagination. For more information about managing clusters, go to &lt;a href&#x3D;\&quot;https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html\&quot;&gt;Amazon Redshift Clusters&lt;/a&gt; in the &lt;i&gt;Amazon Redshift Cluster Management Guide&lt;/i&gt;.&lt;/p&gt; &lt;p&gt;If you specify both tag keys and tag values in the same request, Amazon Redshift returns all clusters that match any combination of the specified keys and values. For example, if you have &lt;code&gt;owner&lt;/code&gt; and &lt;code&gt;environment&lt;/code&gt; for tag keys, and &lt;code&gt;admin&lt;/code&gt; and &lt;code&gt;test&lt;/code&gt; for tag values, all clusters that have any combination of those values are returned.&lt;/p&gt; &lt;p&gt;If both tag keys and values are omitted from the request, clusters are returned regardless of whether they have tag keys or values associated with them.&lt;/p&gt;
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param maxRecords Pagination limit (optional)
     * @param marker Pagination token (optional)
     * @param describeClustersMessage  (optional)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> ClusterNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> InvalidTagFault </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call pOSTDescribeClustersAsync(String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, String maxRecords, String marker, DescribeClustersMessage describeClustersMessage, final ApiCallback<ClustersMessage> _callback) throws ApiException {

        okhttp3.Call localVarCall = pOSTDescribeClustersValidateBeforeCall(action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, maxRecords, marker, describeClustersMessage, _callback);
        Type localVarReturnType = new TypeToken<ClustersMessage>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for pOSTDescribeCustomDomainAssociations
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param maxRecords Pagination limit (optional)
     * @param marker Pagination token (optional)
     * @param describeCustomDomainAssociationsMessage  (optional)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> CustomDomainAssociationNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> UnsupportedOperationFault </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call pOSTDescribeCustomDomainAssociationsCall(String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, String maxRecords, String marker, DescribeCustomDomainAssociationsMessage describeCustomDomainAssociationsMessage, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = describeCustomDomainAssociationsMessage;

        // create path and map variables
        String localVarPath = "/#Action=DescribeCustomDomainAssociations";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (maxRecords != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("MaxRecords", maxRecords));
        }

        if (marker != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("Marker", marker));
        }

        if (action != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("Action", action));
        }

        if (version != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("Version", version));
        }

        if (xAmzContentSha256 != null) {
            localVarHeaderParams.put("X-Amz-Content-Sha256", localVarApiClient.parameterToString(xAmzContentSha256));
        }

        if (xAmzDate != null) {
            localVarHeaderParams.put("X-Amz-Date", localVarApiClient.parameterToString(xAmzDate));
        }

        if (xAmzAlgorithm != null) {
            localVarHeaderParams.put("X-Amz-Algorithm", localVarApiClient.parameterToString(xAmzAlgorithm));
        }

        if (xAmzCredential != null) {
            localVarHeaderParams.put("X-Amz-Credential", localVarApiClient.parameterToString(xAmzCredential));
        }

        if (xAmzSecurityToken != null) {
            localVarHeaderParams.put("X-Amz-Security-Token", localVarApiClient.parameterToString(xAmzSecurityToken));
        }

        if (xAmzSignature != null) {
            localVarHeaderParams.put("X-Amz-Signature", localVarApiClient.parameterToString(xAmzSignature));
        }

        if (xAmzSignedHeaders != null) {
            localVarHeaderParams.put("X-Amz-SignedHeaders", localVarApiClient.parameterToString(xAmzSignedHeaders));
        }

        final String[] localVarAccepts = {
            "text/xml"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            "text/xml"
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "hmac" };
        return localVarApiClient.buildCall(basePath, localVarPath, "POST", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call pOSTDescribeCustomDomainAssociationsValidateBeforeCall(String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, String maxRecords, String marker, DescribeCustomDomainAssociationsMessage describeCustomDomainAssociationsMessage, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'action' is set
        if (action == null) {
            throw new ApiException("Missing the required parameter 'action' when calling pOSTDescribeCustomDomainAssociations(Async)");
        }

        // verify the required parameter 'version' is set
        if (version == null) {
            throw new ApiException("Missing the required parameter 'version' when calling pOSTDescribeCustomDomainAssociations(Async)");
        }

        return pOSTDescribeCustomDomainAssociationsCall(action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, maxRecords, marker, describeCustomDomainAssociationsMessage, _callback);

    }

    /**
     * 
     * Contains information for custom domain associations for a cluster.
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param maxRecords Pagination limit (optional)
     * @param marker Pagination token (optional)
     * @param describeCustomDomainAssociationsMessage  (optional)
     * @return CustomDomainAssociationsMessage
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> CustomDomainAssociationNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> UnsupportedOperationFault </td><td>  -  </td></tr>
     </table>
     */
    public CustomDomainAssociationsMessage pOSTDescribeCustomDomainAssociations(String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, String maxRecords, String marker, DescribeCustomDomainAssociationsMessage describeCustomDomainAssociationsMessage) throws ApiException {
        ApiResponse<CustomDomainAssociationsMessage> localVarResp = pOSTDescribeCustomDomainAssociationsWithHttpInfo(action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, maxRecords, marker, describeCustomDomainAssociationsMessage);
        return localVarResp.getData();
    }

    /**
     * 
     * Contains information for custom domain associations for a cluster.
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param maxRecords Pagination limit (optional)
     * @param marker Pagination token (optional)
     * @param describeCustomDomainAssociationsMessage  (optional)
     * @return ApiResponse&lt;CustomDomainAssociationsMessage&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> CustomDomainAssociationNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> UnsupportedOperationFault </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<CustomDomainAssociationsMessage> pOSTDescribeCustomDomainAssociationsWithHttpInfo(String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, String maxRecords, String marker, DescribeCustomDomainAssociationsMessage describeCustomDomainAssociationsMessage) throws ApiException {
        okhttp3.Call localVarCall = pOSTDescribeCustomDomainAssociationsValidateBeforeCall(action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, maxRecords, marker, describeCustomDomainAssociationsMessage, null);
        Type localVarReturnType = new TypeToken<CustomDomainAssociationsMessage>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     *  (asynchronously)
     * Contains information for custom domain associations for a cluster.
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param maxRecords Pagination limit (optional)
     * @param marker Pagination token (optional)
     * @param describeCustomDomainAssociationsMessage  (optional)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> CustomDomainAssociationNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> UnsupportedOperationFault </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call pOSTDescribeCustomDomainAssociationsAsync(String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, String maxRecords, String marker, DescribeCustomDomainAssociationsMessage describeCustomDomainAssociationsMessage, final ApiCallback<CustomDomainAssociationsMessage> _callback) throws ApiException {

        okhttp3.Call localVarCall = pOSTDescribeCustomDomainAssociationsValidateBeforeCall(action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, maxRecords, marker, describeCustomDomainAssociationsMessage, _callback);
        Type localVarReturnType = new TypeToken<CustomDomainAssociationsMessage>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for pOSTDescribeDataShares
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param maxRecords Pagination limit (optional)
     * @param marker Pagination token (optional)
     * @param describeDataSharesMessage  (optional)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> InvalidDataShareFault </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call pOSTDescribeDataSharesCall(String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, String maxRecords, String marker, DescribeDataSharesMessage describeDataSharesMessage, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = describeDataSharesMessage;

        // create path and map variables
        String localVarPath = "/#Action=DescribeDataShares";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (maxRecords != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("MaxRecords", maxRecords));
        }

        if (marker != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("Marker", marker));
        }

        if (action != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("Action", action));
        }

        if (version != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("Version", version));
        }

        if (xAmzContentSha256 != null) {
            localVarHeaderParams.put("X-Amz-Content-Sha256", localVarApiClient.parameterToString(xAmzContentSha256));
        }

        if (xAmzDate != null) {
            localVarHeaderParams.put("X-Amz-Date", localVarApiClient.parameterToString(xAmzDate));
        }

        if (xAmzAlgorithm != null) {
            localVarHeaderParams.put("X-Amz-Algorithm", localVarApiClient.parameterToString(xAmzAlgorithm));
        }

        if (xAmzCredential != null) {
            localVarHeaderParams.put("X-Amz-Credential", localVarApiClient.parameterToString(xAmzCredential));
        }

        if (xAmzSecurityToken != null) {
            localVarHeaderParams.put("X-Amz-Security-Token", localVarApiClient.parameterToString(xAmzSecurityToken));
        }

        if (xAmzSignature != null) {
            localVarHeaderParams.put("X-Amz-Signature", localVarApiClient.parameterToString(xAmzSignature));
        }

        if (xAmzSignedHeaders != null) {
            localVarHeaderParams.put("X-Amz-SignedHeaders", localVarApiClient.parameterToString(xAmzSignedHeaders));
        }

        final String[] localVarAccepts = {
            "text/xml"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            "text/xml"
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "hmac" };
        return localVarApiClient.buildCall(basePath, localVarPath, "POST", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call pOSTDescribeDataSharesValidateBeforeCall(String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, String maxRecords, String marker, DescribeDataSharesMessage describeDataSharesMessage, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'action' is set
        if (action == null) {
            throw new ApiException("Missing the required parameter 'action' when calling pOSTDescribeDataShares(Async)");
        }

        // verify the required parameter 'version' is set
        if (version == null) {
            throw new ApiException("Missing the required parameter 'version' when calling pOSTDescribeDataShares(Async)");
        }

        return pOSTDescribeDataSharesCall(action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, maxRecords, marker, describeDataSharesMessage, _callback);

    }

    /**
     * 
     * Shows the status of any inbound or outbound datashares available in the specified account.
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param maxRecords Pagination limit (optional)
     * @param marker Pagination token (optional)
     * @param describeDataSharesMessage  (optional)
     * @return DescribeDataSharesResult
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> InvalidDataShareFault </td><td>  -  </td></tr>
     </table>
     */
    public DescribeDataSharesResult pOSTDescribeDataShares(String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, String maxRecords, String marker, DescribeDataSharesMessage describeDataSharesMessage) throws ApiException {
        ApiResponse<DescribeDataSharesResult> localVarResp = pOSTDescribeDataSharesWithHttpInfo(action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, maxRecords, marker, describeDataSharesMessage);
        return localVarResp.getData();
    }

    /**
     * 
     * Shows the status of any inbound or outbound datashares available in the specified account.
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param maxRecords Pagination limit (optional)
     * @param marker Pagination token (optional)
     * @param describeDataSharesMessage  (optional)
     * @return ApiResponse&lt;DescribeDataSharesResult&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> InvalidDataShareFault </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<DescribeDataSharesResult> pOSTDescribeDataSharesWithHttpInfo(String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, String maxRecords, String marker, DescribeDataSharesMessage describeDataSharesMessage) throws ApiException {
        okhttp3.Call localVarCall = pOSTDescribeDataSharesValidateBeforeCall(action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, maxRecords, marker, describeDataSharesMessage, null);
        Type localVarReturnType = new TypeToken<DescribeDataSharesResult>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     *  (asynchronously)
     * Shows the status of any inbound or outbound datashares available in the specified account.
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param maxRecords Pagination limit (optional)
     * @param marker Pagination token (optional)
     * @param describeDataSharesMessage  (optional)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> InvalidDataShareFault </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call pOSTDescribeDataSharesAsync(String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, String maxRecords, String marker, DescribeDataSharesMessage describeDataSharesMessage, final ApiCallback<DescribeDataSharesResult> _callback) throws ApiException {

        okhttp3.Call localVarCall = pOSTDescribeDataSharesValidateBeforeCall(action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, maxRecords, marker, describeDataSharesMessage, _callback);
        Type localVarReturnType = new TypeToken<DescribeDataSharesResult>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for pOSTDescribeDataSharesForConsumer
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param maxRecords Pagination limit (optional)
     * @param marker Pagination token (optional)
     * @param describeDataSharesForConsumerMessage  (optional)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> InvalidNamespaceFault </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call pOSTDescribeDataSharesForConsumerCall(String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, String maxRecords, String marker, DescribeDataSharesForConsumerMessage describeDataSharesForConsumerMessage, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = describeDataSharesForConsumerMessage;

        // create path and map variables
        String localVarPath = "/#Action=DescribeDataSharesForConsumer";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (maxRecords != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("MaxRecords", maxRecords));
        }

        if (marker != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("Marker", marker));
        }

        if (action != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("Action", action));
        }

        if (version != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("Version", version));
        }

        if (xAmzContentSha256 != null) {
            localVarHeaderParams.put("X-Amz-Content-Sha256", localVarApiClient.parameterToString(xAmzContentSha256));
        }

        if (xAmzDate != null) {
            localVarHeaderParams.put("X-Amz-Date", localVarApiClient.parameterToString(xAmzDate));
        }

        if (xAmzAlgorithm != null) {
            localVarHeaderParams.put("X-Amz-Algorithm", localVarApiClient.parameterToString(xAmzAlgorithm));
        }

        if (xAmzCredential != null) {
            localVarHeaderParams.put("X-Amz-Credential", localVarApiClient.parameterToString(xAmzCredential));
        }

        if (xAmzSecurityToken != null) {
            localVarHeaderParams.put("X-Amz-Security-Token", localVarApiClient.parameterToString(xAmzSecurityToken));
        }

        if (xAmzSignature != null) {
            localVarHeaderParams.put("X-Amz-Signature", localVarApiClient.parameterToString(xAmzSignature));
        }

        if (xAmzSignedHeaders != null) {
            localVarHeaderParams.put("X-Amz-SignedHeaders", localVarApiClient.parameterToString(xAmzSignedHeaders));
        }

        final String[] localVarAccepts = {
            "text/xml"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            "text/xml"
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "hmac" };
        return localVarApiClient.buildCall(basePath, localVarPath, "POST", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call pOSTDescribeDataSharesForConsumerValidateBeforeCall(String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, String maxRecords, String marker, DescribeDataSharesForConsumerMessage describeDataSharesForConsumerMessage, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'action' is set
        if (action == null) {
            throw new ApiException("Missing the required parameter 'action' when calling pOSTDescribeDataSharesForConsumer(Async)");
        }

        // verify the required parameter 'version' is set
        if (version == null) {
            throw new ApiException("Missing the required parameter 'version' when calling pOSTDescribeDataSharesForConsumer(Async)");
        }

        return pOSTDescribeDataSharesForConsumerCall(action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, maxRecords, marker, describeDataSharesForConsumerMessage, _callback);

    }

    /**
     * 
     * Returns a list of datashares where the account identifier being called is a consumer account identifier.
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param maxRecords Pagination limit (optional)
     * @param marker Pagination token (optional)
     * @param describeDataSharesForConsumerMessage  (optional)
     * @return DescribeDataSharesForConsumerResult
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> InvalidNamespaceFault </td><td>  -  </td></tr>
     </table>
     */
    public DescribeDataSharesForConsumerResult pOSTDescribeDataSharesForConsumer(String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, String maxRecords, String marker, DescribeDataSharesForConsumerMessage describeDataSharesForConsumerMessage) throws ApiException {
        ApiResponse<DescribeDataSharesForConsumerResult> localVarResp = pOSTDescribeDataSharesForConsumerWithHttpInfo(action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, maxRecords, marker, describeDataSharesForConsumerMessage);
        return localVarResp.getData();
    }

    /**
     * 
     * Returns a list of datashares where the account identifier being called is a consumer account identifier.
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param maxRecords Pagination limit (optional)
     * @param marker Pagination token (optional)
     * @param describeDataSharesForConsumerMessage  (optional)
     * @return ApiResponse&lt;DescribeDataSharesForConsumerResult&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> InvalidNamespaceFault </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<DescribeDataSharesForConsumerResult> pOSTDescribeDataSharesForConsumerWithHttpInfo(String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, String maxRecords, String marker, DescribeDataSharesForConsumerMessage describeDataSharesForConsumerMessage) throws ApiException {
        okhttp3.Call localVarCall = pOSTDescribeDataSharesForConsumerValidateBeforeCall(action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, maxRecords, marker, describeDataSharesForConsumerMessage, null);
        Type localVarReturnType = new TypeToken<DescribeDataSharesForConsumerResult>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     *  (asynchronously)
     * Returns a list of datashares where the account identifier being called is a consumer account identifier.
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param maxRecords Pagination limit (optional)
     * @param marker Pagination token (optional)
     * @param describeDataSharesForConsumerMessage  (optional)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> InvalidNamespaceFault </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call pOSTDescribeDataSharesForConsumerAsync(String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, String maxRecords, String marker, DescribeDataSharesForConsumerMessage describeDataSharesForConsumerMessage, final ApiCallback<DescribeDataSharesForConsumerResult> _callback) throws ApiException {

        okhttp3.Call localVarCall = pOSTDescribeDataSharesForConsumerValidateBeforeCall(action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, maxRecords, marker, describeDataSharesForConsumerMessage, _callback);
        Type localVarReturnType = new TypeToken<DescribeDataSharesForConsumerResult>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for pOSTDescribeDataSharesForProducer
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param maxRecords Pagination limit (optional)
     * @param marker Pagination token (optional)
     * @param describeDataSharesForProducerMessage  (optional)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> InvalidNamespaceFault </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call pOSTDescribeDataSharesForProducerCall(String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, String maxRecords, String marker, DescribeDataSharesForProducerMessage describeDataSharesForProducerMessage, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = describeDataSharesForProducerMessage;

        // create path and map variables
        String localVarPath = "/#Action=DescribeDataSharesForProducer";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (maxRecords != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("MaxRecords", maxRecords));
        }

        if (marker != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("Marker", marker));
        }

        if (action != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("Action", action));
        }

        if (version != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("Version", version));
        }

        if (xAmzContentSha256 != null) {
            localVarHeaderParams.put("X-Amz-Content-Sha256", localVarApiClient.parameterToString(xAmzContentSha256));
        }

        if (xAmzDate != null) {
            localVarHeaderParams.put("X-Amz-Date", localVarApiClient.parameterToString(xAmzDate));
        }

        if (xAmzAlgorithm != null) {
            localVarHeaderParams.put("X-Amz-Algorithm", localVarApiClient.parameterToString(xAmzAlgorithm));
        }

        if (xAmzCredential != null) {
            localVarHeaderParams.put("X-Amz-Credential", localVarApiClient.parameterToString(xAmzCredential));
        }

        if (xAmzSecurityToken != null) {
            localVarHeaderParams.put("X-Amz-Security-Token", localVarApiClient.parameterToString(xAmzSecurityToken));
        }

        if (xAmzSignature != null) {
            localVarHeaderParams.put("X-Amz-Signature", localVarApiClient.parameterToString(xAmzSignature));
        }

        if (xAmzSignedHeaders != null) {
            localVarHeaderParams.put("X-Amz-SignedHeaders", localVarApiClient.parameterToString(xAmzSignedHeaders));
        }

        final String[] localVarAccepts = {
            "text/xml"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            "text/xml"
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "hmac" };
        return localVarApiClient.buildCall(basePath, localVarPath, "POST", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call pOSTDescribeDataSharesForProducerValidateBeforeCall(String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, String maxRecords, String marker, DescribeDataSharesForProducerMessage describeDataSharesForProducerMessage, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'action' is set
        if (action == null) {
            throw new ApiException("Missing the required parameter 'action' when calling pOSTDescribeDataSharesForProducer(Async)");
        }

        // verify the required parameter 'version' is set
        if (version == null) {
            throw new ApiException("Missing the required parameter 'version' when calling pOSTDescribeDataSharesForProducer(Async)");
        }

        return pOSTDescribeDataSharesForProducerCall(action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, maxRecords, marker, describeDataSharesForProducerMessage, _callback);

    }

    /**
     * 
     * Returns a list of datashares when the account identifier being called is a producer account identifier.
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param maxRecords Pagination limit (optional)
     * @param marker Pagination token (optional)
     * @param describeDataSharesForProducerMessage  (optional)
     * @return DescribeDataSharesForProducerResult
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> InvalidNamespaceFault </td><td>  -  </td></tr>
     </table>
     */
    public DescribeDataSharesForProducerResult pOSTDescribeDataSharesForProducer(String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, String maxRecords, String marker, DescribeDataSharesForProducerMessage describeDataSharesForProducerMessage) throws ApiException {
        ApiResponse<DescribeDataSharesForProducerResult> localVarResp = pOSTDescribeDataSharesForProducerWithHttpInfo(action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, maxRecords, marker, describeDataSharesForProducerMessage);
        return localVarResp.getData();
    }

    /**
     * 
     * Returns a list of datashares when the account identifier being called is a producer account identifier.
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param maxRecords Pagination limit (optional)
     * @param marker Pagination token (optional)
     * @param describeDataSharesForProducerMessage  (optional)
     * @return ApiResponse&lt;DescribeDataSharesForProducerResult&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> InvalidNamespaceFault </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<DescribeDataSharesForProducerResult> pOSTDescribeDataSharesForProducerWithHttpInfo(String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, String maxRecords, String marker, DescribeDataSharesForProducerMessage describeDataSharesForProducerMessage) throws ApiException {
        okhttp3.Call localVarCall = pOSTDescribeDataSharesForProducerValidateBeforeCall(action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, maxRecords, marker, describeDataSharesForProducerMessage, null);
        Type localVarReturnType = new TypeToken<DescribeDataSharesForProducerResult>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     *  (asynchronously)
     * Returns a list of datashares when the account identifier being called is a producer account identifier.
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param maxRecords Pagination limit (optional)
     * @param marker Pagination token (optional)
     * @param describeDataSharesForProducerMessage  (optional)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> InvalidNamespaceFault </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call pOSTDescribeDataSharesForProducerAsync(String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, String maxRecords, String marker, DescribeDataSharesForProducerMessage describeDataSharesForProducerMessage, final ApiCallback<DescribeDataSharesForProducerResult> _callback) throws ApiException {

        okhttp3.Call localVarCall = pOSTDescribeDataSharesForProducerValidateBeforeCall(action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, maxRecords, marker, describeDataSharesForProducerMessage, _callback);
        Type localVarReturnType = new TypeToken<DescribeDataSharesForProducerResult>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for pOSTDescribeDefaultClusterParameters
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param maxRecords Pagination limit (optional)
     * @param marker Pagination token (optional)
     * @param describeDefaultClusterParametersMessage  (optional)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call pOSTDescribeDefaultClusterParametersCall(String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, String maxRecords, String marker, DescribeDefaultClusterParametersMessage describeDefaultClusterParametersMessage, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = describeDefaultClusterParametersMessage;

        // create path and map variables
        String localVarPath = "/#Action=DescribeDefaultClusterParameters";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (maxRecords != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("MaxRecords", maxRecords));
        }

        if (marker != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("Marker", marker));
        }

        if (action != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("Action", action));
        }

        if (version != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("Version", version));
        }

        if (xAmzContentSha256 != null) {
            localVarHeaderParams.put("X-Amz-Content-Sha256", localVarApiClient.parameterToString(xAmzContentSha256));
        }

        if (xAmzDate != null) {
            localVarHeaderParams.put("X-Amz-Date", localVarApiClient.parameterToString(xAmzDate));
        }

        if (xAmzAlgorithm != null) {
            localVarHeaderParams.put("X-Amz-Algorithm", localVarApiClient.parameterToString(xAmzAlgorithm));
        }

        if (xAmzCredential != null) {
            localVarHeaderParams.put("X-Amz-Credential", localVarApiClient.parameterToString(xAmzCredential));
        }

        if (xAmzSecurityToken != null) {
            localVarHeaderParams.put("X-Amz-Security-Token", localVarApiClient.parameterToString(xAmzSecurityToken));
        }

        if (xAmzSignature != null) {
            localVarHeaderParams.put("X-Amz-Signature", localVarApiClient.parameterToString(xAmzSignature));
        }

        if (xAmzSignedHeaders != null) {
            localVarHeaderParams.put("X-Amz-SignedHeaders", localVarApiClient.parameterToString(xAmzSignedHeaders));
        }

        final String[] localVarAccepts = {
            "text/xml"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            "text/xml"
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "hmac" };
        return localVarApiClient.buildCall(basePath, localVarPath, "POST", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call pOSTDescribeDefaultClusterParametersValidateBeforeCall(String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, String maxRecords, String marker, DescribeDefaultClusterParametersMessage describeDefaultClusterParametersMessage, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'action' is set
        if (action == null) {
            throw new ApiException("Missing the required parameter 'action' when calling pOSTDescribeDefaultClusterParameters(Async)");
        }

        // verify the required parameter 'version' is set
        if (version == null) {
            throw new ApiException("Missing the required parameter 'version' when calling pOSTDescribeDefaultClusterParameters(Async)");
        }

        return pOSTDescribeDefaultClusterParametersCall(action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, maxRecords, marker, describeDefaultClusterParametersMessage, _callback);

    }

    /**
     * 
     * &lt;p&gt;Returns a list of parameter settings for the specified parameter group family.&lt;/p&gt; &lt;p&gt; For more information about parameters and parameter groups, go to &lt;a href&#x3D;\&quot;https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-parameter-groups.html\&quot;&gt;Amazon Redshift Parameter Groups&lt;/a&gt; in the &lt;i&gt;Amazon Redshift Cluster Management Guide&lt;/i&gt;.&lt;/p&gt;
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param maxRecords Pagination limit (optional)
     * @param marker Pagination token (optional)
     * @param describeDefaultClusterParametersMessage  (optional)
     * @return DescribeDefaultClusterParametersResult
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
     </table>
     */
    public DescribeDefaultClusterParametersResult pOSTDescribeDefaultClusterParameters(String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, String maxRecords, String marker, DescribeDefaultClusterParametersMessage describeDefaultClusterParametersMessage) throws ApiException {
        ApiResponse<DescribeDefaultClusterParametersResult> localVarResp = pOSTDescribeDefaultClusterParametersWithHttpInfo(action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, maxRecords, marker, describeDefaultClusterParametersMessage);
        return localVarResp.getData();
    }

    /**
     * 
     * &lt;p&gt;Returns a list of parameter settings for the specified parameter group family.&lt;/p&gt; &lt;p&gt; For more information about parameters and parameter groups, go to &lt;a href&#x3D;\&quot;https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-parameter-groups.html\&quot;&gt;Amazon Redshift Parameter Groups&lt;/a&gt; in the &lt;i&gt;Amazon Redshift Cluster Management Guide&lt;/i&gt;.&lt;/p&gt;
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param maxRecords Pagination limit (optional)
     * @param marker Pagination token (optional)
     * @param describeDefaultClusterParametersMessage  (optional)
     * @return ApiResponse&lt;DescribeDefaultClusterParametersResult&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<DescribeDefaultClusterParametersResult> pOSTDescribeDefaultClusterParametersWithHttpInfo(String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, String maxRecords, String marker, DescribeDefaultClusterParametersMessage describeDefaultClusterParametersMessage) throws ApiException {
        okhttp3.Call localVarCall = pOSTDescribeDefaultClusterParametersValidateBeforeCall(action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, maxRecords, marker, describeDefaultClusterParametersMessage, null);
        Type localVarReturnType = new TypeToken<DescribeDefaultClusterParametersResult>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     *  (asynchronously)
     * &lt;p&gt;Returns a list of parameter settings for the specified parameter group family.&lt;/p&gt; &lt;p&gt; For more information about parameters and parameter groups, go to &lt;a href&#x3D;\&quot;https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-parameter-groups.html\&quot;&gt;Amazon Redshift Parameter Groups&lt;/a&gt; in the &lt;i&gt;Amazon Redshift Cluster Management Guide&lt;/i&gt;.&lt;/p&gt;
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param maxRecords Pagination limit (optional)
     * @param marker Pagination token (optional)
     * @param describeDefaultClusterParametersMessage  (optional)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call pOSTDescribeDefaultClusterParametersAsync(String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, String maxRecords, String marker, DescribeDefaultClusterParametersMessage describeDefaultClusterParametersMessage, final ApiCallback<DescribeDefaultClusterParametersResult> _callback) throws ApiException {

        okhttp3.Call localVarCall = pOSTDescribeDefaultClusterParametersValidateBeforeCall(action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, maxRecords, marker, describeDefaultClusterParametersMessage, _callback);
        Type localVarReturnType = new TypeToken<DescribeDefaultClusterParametersResult>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for pOSTDescribeEndpointAccess
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param maxRecords Pagination limit (optional)
     * @param marker Pagination token (optional)
     * @param describeEndpointAccessMessage  (optional)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> ClusterNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> InvalidClusterStateFault </td><td>  -  </td></tr>
        <tr><td> 482 </td><td> EndpointNotFoundFault </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call pOSTDescribeEndpointAccessCall(String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, String maxRecords, String marker, DescribeEndpointAccessMessage describeEndpointAccessMessage, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = describeEndpointAccessMessage;

        // create path and map variables
        String localVarPath = "/#Action=DescribeEndpointAccess";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (maxRecords != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("MaxRecords", maxRecords));
        }

        if (marker != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("Marker", marker));
        }

        if (action != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("Action", action));
        }

        if (version != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("Version", version));
        }

        if (xAmzContentSha256 != null) {
            localVarHeaderParams.put("X-Amz-Content-Sha256", localVarApiClient.parameterToString(xAmzContentSha256));
        }

        if (xAmzDate != null) {
            localVarHeaderParams.put("X-Amz-Date", localVarApiClient.parameterToString(xAmzDate));
        }

        if (xAmzAlgorithm != null) {
            localVarHeaderParams.put("X-Amz-Algorithm", localVarApiClient.parameterToString(xAmzAlgorithm));
        }

        if (xAmzCredential != null) {
            localVarHeaderParams.put("X-Amz-Credential", localVarApiClient.parameterToString(xAmzCredential));
        }

        if (xAmzSecurityToken != null) {
            localVarHeaderParams.put("X-Amz-Security-Token", localVarApiClient.parameterToString(xAmzSecurityToken));
        }

        if (xAmzSignature != null) {
            localVarHeaderParams.put("X-Amz-Signature", localVarApiClient.parameterToString(xAmzSignature));
        }

        if (xAmzSignedHeaders != null) {
            localVarHeaderParams.put("X-Amz-SignedHeaders", localVarApiClient.parameterToString(xAmzSignedHeaders));
        }

        final String[] localVarAccepts = {
            "text/xml"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            "text/xml"
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "hmac" };
        return localVarApiClient.buildCall(basePath, localVarPath, "POST", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call pOSTDescribeEndpointAccessValidateBeforeCall(String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, String maxRecords, String marker, DescribeEndpointAccessMessage describeEndpointAccessMessage, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'action' is set
        if (action == null) {
            throw new ApiException("Missing the required parameter 'action' when calling pOSTDescribeEndpointAccess(Async)");
        }

        // verify the required parameter 'version' is set
        if (version == null) {
            throw new ApiException("Missing the required parameter 'version' when calling pOSTDescribeEndpointAccess(Async)");
        }

        return pOSTDescribeEndpointAccessCall(action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, maxRecords, marker, describeEndpointAccessMessage, _callback);

    }

    /**
     * 
     * Describes a Redshift-managed VPC endpoint.
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param maxRecords Pagination limit (optional)
     * @param marker Pagination token (optional)
     * @param describeEndpointAccessMessage  (optional)
     * @return EndpointAccessList
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> ClusterNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> InvalidClusterStateFault </td><td>  -  </td></tr>
        <tr><td> 482 </td><td> EndpointNotFoundFault </td><td>  -  </td></tr>
     </table>
     */
    public EndpointAccessList pOSTDescribeEndpointAccess(String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, String maxRecords, String marker, DescribeEndpointAccessMessage describeEndpointAccessMessage) throws ApiException {
        ApiResponse<EndpointAccessList> localVarResp = pOSTDescribeEndpointAccessWithHttpInfo(action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, maxRecords, marker, describeEndpointAccessMessage);
        return localVarResp.getData();
    }

    /**
     * 
     * Describes a Redshift-managed VPC endpoint.
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param maxRecords Pagination limit (optional)
     * @param marker Pagination token (optional)
     * @param describeEndpointAccessMessage  (optional)
     * @return ApiResponse&lt;EndpointAccessList&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> ClusterNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> InvalidClusterStateFault </td><td>  -  </td></tr>
        <tr><td> 482 </td><td> EndpointNotFoundFault </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<EndpointAccessList> pOSTDescribeEndpointAccessWithHttpInfo(String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, String maxRecords, String marker, DescribeEndpointAccessMessage describeEndpointAccessMessage) throws ApiException {
        okhttp3.Call localVarCall = pOSTDescribeEndpointAccessValidateBeforeCall(action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, maxRecords, marker, describeEndpointAccessMessage, null);
        Type localVarReturnType = new TypeToken<EndpointAccessList>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     *  (asynchronously)
     * Describes a Redshift-managed VPC endpoint.
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param maxRecords Pagination limit (optional)
     * @param marker Pagination token (optional)
     * @param describeEndpointAccessMessage  (optional)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> ClusterNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> InvalidClusterStateFault </td><td>  -  </td></tr>
        <tr><td> 482 </td><td> EndpointNotFoundFault </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call pOSTDescribeEndpointAccessAsync(String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, String maxRecords, String marker, DescribeEndpointAccessMessage describeEndpointAccessMessage, final ApiCallback<EndpointAccessList> _callback) throws ApiException {

        okhttp3.Call localVarCall = pOSTDescribeEndpointAccessValidateBeforeCall(action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, maxRecords, marker, describeEndpointAccessMessage, _callback);
        Type localVarReturnType = new TypeToken<EndpointAccessList>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for pOSTDescribeEndpointAuthorization
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param maxRecords Pagination limit (optional)
     * @param marker Pagination token (optional)
     * @param describeEndpointAuthorizationMessage  (optional)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> ClusterNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> UnsupportedOperationFault </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call pOSTDescribeEndpointAuthorizationCall(String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, String maxRecords, String marker, DescribeEndpointAuthorizationMessage describeEndpointAuthorizationMessage, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = describeEndpointAuthorizationMessage;

        // create path and map variables
        String localVarPath = "/#Action=DescribeEndpointAuthorization";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (maxRecords != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("MaxRecords", maxRecords));
        }

        if (marker != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("Marker", marker));
        }

        if (action != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("Action", action));
        }

        if (version != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("Version", version));
        }

        if (xAmzContentSha256 != null) {
            localVarHeaderParams.put("X-Amz-Content-Sha256", localVarApiClient.parameterToString(xAmzContentSha256));
        }

        if (xAmzDate != null) {
            localVarHeaderParams.put("X-Amz-Date", localVarApiClient.parameterToString(xAmzDate));
        }

        if (xAmzAlgorithm != null) {
            localVarHeaderParams.put("X-Amz-Algorithm", localVarApiClient.parameterToString(xAmzAlgorithm));
        }

        if (xAmzCredential != null) {
            localVarHeaderParams.put("X-Amz-Credential", localVarApiClient.parameterToString(xAmzCredential));
        }

        if (xAmzSecurityToken != null) {
            localVarHeaderParams.put("X-Amz-Security-Token", localVarApiClient.parameterToString(xAmzSecurityToken));
        }

        if (xAmzSignature != null) {
            localVarHeaderParams.put("X-Amz-Signature", localVarApiClient.parameterToString(xAmzSignature));
        }

        if (xAmzSignedHeaders != null) {
            localVarHeaderParams.put("X-Amz-SignedHeaders", localVarApiClient.parameterToString(xAmzSignedHeaders));
        }

        final String[] localVarAccepts = {
            "text/xml"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            "text/xml"
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "hmac" };
        return localVarApiClient.buildCall(basePath, localVarPath, "POST", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call pOSTDescribeEndpointAuthorizationValidateBeforeCall(String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, String maxRecords, String marker, DescribeEndpointAuthorizationMessage describeEndpointAuthorizationMessage, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'action' is set
        if (action == null) {
            throw new ApiException("Missing the required parameter 'action' when calling pOSTDescribeEndpointAuthorization(Async)");
        }

        // verify the required parameter 'version' is set
        if (version == null) {
            throw new ApiException("Missing the required parameter 'version' when calling pOSTDescribeEndpointAuthorization(Async)");
        }

        return pOSTDescribeEndpointAuthorizationCall(action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, maxRecords, marker, describeEndpointAuthorizationMessage, _callback);

    }

    /**
     * 
     * Describes an endpoint authorization.
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param maxRecords Pagination limit (optional)
     * @param marker Pagination token (optional)
     * @param describeEndpointAuthorizationMessage  (optional)
     * @return EndpointAuthorizationList
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> ClusterNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> UnsupportedOperationFault </td><td>  -  </td></tr>
     </table>
     */
    public EndpointAuthorizationList pOSTDescribeEndpointAuthorization(String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, String maxRecords, String marker, DescribeEndpointAuthorizationMessage describeEndpointAuthorizationMessage) throws ApiException {
        ApiResponse<EndpointAuthorizationList> localVarResp = pOSTDescribeEndpointAuthorizationWithHttpInfo(action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, maxRecords, marker, describeEndpointAuthorizationMessage);
        return localVarResp.getData();
    }

    /**
     * 
     * Describes an endpoint authorization.
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param maxRecords Pagination limit (optional)
     * @param marker Pagination token (optional)
     * @param describeEndpointAuthorizationMessage  (optional)
     * @return ApiResponse&lt;EndpointAuthorizationList&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> ClusterNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> UnsupportedOperationFault </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<EndpointAuthorizationList> pOSTDescribeEndpointAuthorizationWithHttpInfo(String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, String maxRecords, String marker, DescribeEndpointAuthorizationMessage describeEndpointAuthorizationMessage) throws ApiException {
        okhttp3.Call localVarCall = pOSTDescribeEndpointAuthorizationValidateBeforeCall(action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, maxRecords, marker, describeEndpointAuthorizationMessage, null);
        Type localVarReturnType = new TypeToken<EndpointAuthorizationList>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     *  (asynchronously)
     * Describes an endpoint authorization.
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param maxRecords Pagination limit (optional)
     * @param marker Pagination token (optional)
     * @param describeEndpointAuthorizationMessage  (optional)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> ClusterNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> UnsupportedOperationFault </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call pOSTDescribeEndpointAuthorizationAsync(String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, String maxRecords, String marker, DescribeEndpointAuthorizationMessage describeEndpointAuthorizationMessage, final ApiCallback<EndpointAuthorizationList> _callback) throws ApiException {

        okhttp3.Call localVarCall = pOSTDescribeEndpointAuthorizationValidateBeforeCall(action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, maxRecords, marker, describeEndpointAuthorizationMessage, _callback);
        Type localVarReturnType = new TypeToken<EndpointAuthorizationList>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for pOSTDescribeEventCategories
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param describeEventCategoriesMessage  (optional)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call pOSTDescribeEventCategoriesCall(String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, DescribeEventCategoriesMessage describeEventCategoriesMessage, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = describeEventCategoriesMessage;

        // create path and map variables
        String localVarPath = "/#Action=DescribeEventCategories";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (action != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("Action", action));
        }

        if (version != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("Version", version));
        }

        if (xAmzContentSha256 != null) {
            localVarHeaderParams.put("X-Amz-Content-Sha256", localVarApiClient.parameterToString(xAmzContentSha256));
        }

        if (xAmzDate != null) {
            localVarHeaderParams.put("X-Amz-Date", localVarApiClient.parameterToString(xAmzDate));
        }

        if (xAmzAlgorithm != null) {
            localVarHeaderParams.put("X-Amz-Algorithm", localVarApiClient.parameterToString(xAmzAlgorithm));
        }

        if (xAmzCredential != null) {
            localVarHeaderParams.put("X-Amz-Credential", localVarApiClient.parameterToString(xAmzCredential));
        }

        if (xAmzSecurityToken != null) {
            localVarHeaderParams.put("X-Amz-Security-Token", localVarApiClient.parameterToString(xAmzSecurityToken));
        }

        if (xAmzSignature != null) {
            localVarHeaderParams.put("X-Amz-Signature", localVarApiClient.parameterToString(xAmzSignature));
        }

        if (xAmzSignedHeaders != null) {
            localVarHeaderParams.put("X-Amz-SignedHeaders", localVarApiClient.parameterToString(xAmzSignedHeaders));
        }

        final String[] localVarAccepts = {
            "text/xml"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            "text/xml"
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "hmac" };
        return localVarApiClient.buildCall(basePath, localVarPath, "POST", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call pOSTDescribeEventCategoriesValidateBeforeCall(String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, DescribeEventCategoriesMessage describeEventCategoriesMessage, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'action' is set
        if (action == null) {
            throw new ApiException("Missing the required parameter 'action' when calling pOSTDescribeEventCategories(Async)");
        }

        // verify the required parameter 'version' is set
        if (version == null) {
            throw new ApiException("Missing the required parameter 'version' when calling pOSTDescribeEventCategories(Async)");
        }

        return pOSTDescribeEventCategoriesCall(action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, describeEventCategoriesMessage, _callback);

    }

    /**
     * 
     * Displays a list of event categories for all event source types, or for a specified source type. For a list of the event categories and source types, go to &lt;a href&#x3D;\&quot;https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-event-notifications.html\&quot;&gt;Amazon Redshift Event Notifications&lt;/a&gt;.
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param describeEventCategoriesMessage  (optional)
     * @return EventCategoriesMessage
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
     </table>
     */
    public EventCategoriesMessage pOSTDescribeEventCategories(String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, DescribeEventCategoriesMessage describeEventCategoriesMessage) throws ApiException {
        ApiResponse<EventCategoriesMessage> localVarResp = pOSTDescribeEventCategoriesWithHttpInfo(action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, describeEventCategoriesMessage);
        return localVarResp.getData();
    }

    /**
     * 
     * Displays a list of event categories for all event source types, or for a specified source type. For a list of the event categories and source types, go to &lt;a href&#x3D;\&quot;https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-event-notifications.html\&quot;&gt;Amazon Redshift Event Notifications&lt;/a&gt;.
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param describeEventCategoriesMessage  (optional)
     * @return ApiResponse&lt;EventCategoriesMessage&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<EventCategoriesMessage> pOSTDescribeEventCategoriesWithHttpInfo(String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, DescribeEventCategoriesMessage describeEventCategoriesMessage) throws ApiException {
        okhttp3.Call localVarCall = pOSTDescribeEventCategoriesValidateBeforeCall(action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, describeEventCategoriesMessage, null);
        Type localVarReturnType = new TypeToken<EventCategoriesMessage>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     *  (asynchronously)
     * Displays a list of event categories for all event source types, or for a specified source type. For a list of the event categories and source types, go to &lt;a href&#x3D;\&quot;https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-event-notifications.html\&quot;&gt;Amazon Redshift Event Notifications&lt;/a&gt;.
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param describeEventCategoriesMessage  (optional)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call pOSTDescribeEventCategoriesAsync(String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, DescribeEventCategoriesMessage describeEventCategoriesMessage, final ApiCallback<EventCategoriesMessage> _callback) throws ApiException {

        okhttp3.Call localVarCall = pOSTDescribeEventCategoriesValidateBeforeCall(action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, describeEventCategoriesMessage, _callback);
        Type localVarReturnType = new TypeToken<EventCategoriesMessage>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for pOSTDescribeEventSubscriptions
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param maxRecords Pagination limit (optional)
     * @param marker Pagination token (optional)
     * @param describeEventSubscriptionsMessage  (optional)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> SubscriptionNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> InvalidTagFault </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call pOSTDescribeEventSubscriptionsCall(String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, String maxRecords, String marker, DescribeEventSubscriptionsMessage describeEventSubscriptionsMessage, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = describeEventSubscriptionsMessage;

        // create path and map variables
        String localVarPath = "/#Action=DescribeEventSubscriptions";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (maxRecords != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("MaxRecords", maxRecords));
        }

        if (marker != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("Marker", marker));
        }

        if (action != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("Action", action));
        }

        if (version != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("Version", version));
        }

        if (xAmzContentSha256 != null) {
            localVarHeaderParams.put("X-Amz-Content-Sha256", localVarApiClient.parameterToString(xAmzContentSha256));
        }

        if (xAmzDate != null) {
            localVarHeaderParams.put("X-Amz-Date", localVarApiClient.parameterToString(xAmzDate));
        }

        if (xAmzAlgorithm != null) {
            localVarHeaderParams.put("X-Amz-Algorithm", localVarApiClient.parameterToString(xAmzAlgorithm));
        }

        if (xAmzCredential != null) {
            localVarHeaderParams.put("X-Amz-Credential", localVarApiClient.parameterToString(xAmzCredential));
        }

        if (xAmzSecurityToken != null) {
            localVarHeaderParams.put("X-Amz-Security-Token", localVarApiClient.parameterToString(xAmzSecurityToken));
        }

        if (xAmzSignature != null) {
            localVarHeaderParams.put("X-Amz-Signature", localVarApiClient.parameterToString(xAmzSignature));
        }

        if (xAmzSignedHeaders != null) {
            localVarHeaderParams.put("X-Amz-SignedHeaders", localVarApiClient.parameterToString(xAmzSignedHeaders));
        }

        final String[] localVarAccepts = {
            "text/xml"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            "text/xml"
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "hmac" };
        return localVarApiClient.buildCall(basePath, localVarPath, "POST", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call pOSTDescribeEventSubscriptionsValidateBeforeCall(String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, String maxRecords, String marker, DescribeEventSubscriptionsMessage describeEventSubscriptionsMessage, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'action' is set
        if (action == null) {
            throw new ApiException("Missing the required parameter 'action' when calling pOSTDescribeEventSubscriptions(Async)");
        }

        // verify the required parameter 'version' is set
        if (version == null) {
            throw new ApiException("Missing the required parameter 'version' when calling pOSTDescribeEventSubscriptions(Async)");
        }

        return pOSTDescribeEventSubscriptionsCall(action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, maxRecords, marker, describeEventSubscriptionsMessage, _callback);

    }

    /**
     * 
     * &lt;p&gt;Lists descriptions of all the Amazon Redshift event notification subscriptions for a customer account. If you specify a subscription name, lists the description for that subscription.&lt;/p&gt; &lt;p&gt;If you specify both tag keys and tag values in the same request, Amazon Redshift returns all event notification subscriptions that match any combination of the specified keys and values. For example, if you have &lt;code&gt;owner&lt;/code&gt; and &lt;code&gt;environment&lt;/code&gt; for tag keys, and &lt;code&gt;admin&lt;/code&gt; and &lt;code&gt;test&lt;/code&gt; for tag values, all subscriptions that have any combination of those values are returned.&lt;/p&gt; &lt;p&gt;If both tag keys and values are omitted from the request, subscriptions are returned regardless of whether they have tag keys or values associated with them.&lt;/p&gt;
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param maxRecords Pagination limit (optional)
     * @param marker Pagination token (optional)
     * @param describeEventSubscriptionsMessage  (optional)
     * @return EventSubscriptionsMessage
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> SubscriptionNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> InvalidTagFault </td><td>  -  </td></tr>
     </table>
     */
    public EventSubscriptionsMessage pOSTDescribeEventSubscriptions(String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, String maxRecords, String marker, DescribeEventSubscriptionsMessage describeEventSubscriptionsMessage) throws ApiException {
        ApiResponse<EventSubscriptionsMessage> localVarResp = pOSTDescribeEventSubscriptionsWithHttpInfo(action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, maxRecords, marker, describeEventSubscriptionsMessage);
        return localVarResp.getData();
    }

    /**
     * 
     * &lt;p&gt;Lists descriptions of all the Amazon Redshift event notification subscriptions for a customer account. If you specify a subscription name, lists the description for that subscription.&lt;/p&gt; &lt;p&gt;If you specify both tag keys and tag values in the same request, Amazon Redshift returns all event notification subscriptions that match any combination of the specified keys and values. For example, if you have &lt;code&gt;owner&lt;/code&gt; and &lt;code&gt;environment&lt;/code&gt; for tag keys, and &lt;code&gt;admin&lt;/code&gt; and &lt;code&gt;test&lt;/code&gt; for tag values, all subscriptions that have any combination of those values are returned.&lt;/p&gt; &lt;p&gt;If both tag keys and values are omitted from the request, subscriptions are returned regardless of whether they have tag keys or values associated with them.&lt;/p&gt;
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param maxRecords Pagination limit (optional)
     * @param marker Pagination token (optional)
     * @param describeEventSubscriptionsMessage  (optional)
     * @return ApiResponse&lt;EventSubscriptionsMessage&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> SubscriptionNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> InvalidTagFault </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<EventSubscriptionsMessage> pOSTDescribeEventSubscriptionsWithHttpInfo(String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, String maxRecords, String marker, DescribeEventSubscriptionsMessage describeEventSubscriptionsMessage) throws ApiException {
        okhttp3.Call localVarCall = pOSTDescribeEventSubscriptionsValidateBeforeCall(action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, maxRecords, marker, describeEventSubscriptionsMessage, null);
        Type localVarReturnType = new TypeToken<EventSubscriptionsMessage>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     *  (asynchronously)
     * &lt;p&gt;Lists descriptions of all the Amazon Redshift event notification subscriptions for a customer account. If you specify a subscription name, lists the description for that subscription.&lt;/p&gt; &lt;p&gt;If you specify both tag keys and tag values in the same request, Amazon Redshift returns all event notification subscriptions that match any combination of the specified keys and values. For example, if you have &lt;code&gt;owner&lt;/code&gt; and &lt;code&gt;environment&lt;/code&gt; for tag keys, and &lt;code&gt;admin&lt;/code&gt; and &lt;code&gt;test&lt;/code&gt; for tag values, all subscriptions that have any combination of those values are returned.&lt;/p&gt; &lt;p&gt;If both tag keys and values are omitted from the request, subscriptions are returned regardless of whether they have tag keys or values associated with them.&lt;/p&gt;
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param maxRecords Pagination limit (optional)
     * @param marker Pagination token (optional)
     * @param describeEventSubscriptionsMessage  (optional)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> SubscriptionNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> InvalidTagFault </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call pOSTDescribeEventSubscriptionsAsync(String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, String maxRecords, String marker, DescribeEventSubscriptionsMessage describeEventSubscriptionsMessage, final ApiCallback<EventSubscriptionsMessage> _callback) throws ApiException {

        okhttp3.Call localVarCall = pOSTDescribeEventSubscriptionsValidateBeforeCall(action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, maxRecords, marker, describeEventSubscriptionsMessage, _callback);
        Type localVarReturnType = new TypeToken<EventSubscriptionsMessage>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for pOSTDescribeEvents
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param maxRecords Pagination limit (optional)
     * @param marker Pagination token (optional)
     * @param describeEventsMessage  (optional)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call pOSTDescribeEventsCall(String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, String maxRecords, String marker, DescribeEventsMessage describeEventsMessage, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = describeEventsMessage;

        // create path and map variables
        String localVarPath = "/#Action=DescribeEvents";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (maxRecords != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("MaxRecords", maxRecords));
        }

        if (marker != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("Marker", marker));
        }

        if (action != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("Action", action));
        }

        if (version != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("Version", version));
        }

        if (xAmzContentSha256 != null) {
            localVarHeaderParams.put("X-Amz-Content-Sha256", localVarApiClient.parameterToString(xAmzContentSha256));
        }

        if (xAmzDate != null) {
            localVarHeaderParams.put("X-Amz-Date", localVarApiClient.parameterToString(xAmzDate));
        }

        if (xAmzAlgorithm != null) {
            localVarHeaderParams.put("X-Amz-Algorithm", localVarApiClient.parameterToString(xAmzAlgorithm));
        }

        if (xAmzCredential != null) {
            localVarHeaderParams.put("X-Amz-Credential", localVarApiClient.parameterToString(xAmzCredential));
        }

        if (xAmzSecurityToken != null) {
            localVarHeaderParams.put("X-Amz-Security-Token", localVarApiClient.parameterToString(xAmzSecurityToken));
        }

        if (xAmzSignature != null) {
            localVarHeaderParams.put("X-Amz-Signature", localVarApiClient.parameterToString(xAmzSignature));
        }

        if (xAmzSignedHeaders != null) {
            localVarHeaderParams.put("X-Amz-SignedHeaders", localVarApiClient.parameterToString(xAmzSignedHeaders));
        }

        final String[] localVarAccepts = {
            "text/xml"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            "text/xml"
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "hmac" };
        return localVarApiClient.buildCall(basePath, localVarPath, "POST", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call pOSTDescribeEventsValidateBeforeCall(String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, String maxRecords, String marker, DescribeEventsMessage describeEventsMessage, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'action' is set
        if (action == null) {
            throw new ApiException("Missing the required parameter 'action' when calling pOSTDescribeEvents(Async)");
        }

        // verify the required parameter 'version' is set
        if (version == null) {
            throw new ApiException("Missing the required parameter 'version' when calling pOSTDescribeEvents(Async)");
        }

        return pOSTDescribeEventsCall(action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, maxRecords, marker, describeEventsMessage, _callback);

    }

    /**
     * 
     * Returns events related to clusters, security groups, snapshots, and parameter groups for the past 14 days. Events specific to a particular cluster, security group, snapshot or parameter group can be obtained by providing the name as a parameter. By default, the past hour of events are returned.
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param maxRecords Pagination limit (optional)
     * @param marker Pagination token (optional)
     * @param describeEventsMessage  (optional)
     * @return EventsMessage
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
     </table>
     */
    public EventsMessage pOSTDescribeEvents(String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, String maxRecords, String marker, DescribeEventsMessage describeEventsMessage) throws ApiException {
        ApiResponse<EventsMessage> localVarResp = pOSTDescribeEventsWithHttpInfo(action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, maxRecords, marker, describeEventsMessage);
        return localVarResp.getData();
    }

    /**
     * 
     * Returns events related to clusters, security groups, snapshots, and parameter groups for the past 14 days. Events specific to a particular cluster, security group, snapshot or parameter group can be obtained by providing the name as a parameter. By default, the past hour of events are returned.
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param maxRecords Pagination limit (optional)
     * @param marker Pagination token (optional)
     * @param describeEventsMessage  (optional)
     * @return ApiResponse&lt;EventsMessage&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<EventsMessage> pOSTDescribeEventsWithHttpInfo(String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, String maxRecords, String marker, DescribeEventsMessage describeEventsMessage) throws ApiException {
        okhttp3.Call localVarCall = pOSTDescribeEventsValidateBeforeCall(action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, maxRecords, marker, describeEventsMessage, null);
        Type localVarReturnType = new TypeToken<EventsMessage>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     *  (asynchronously)
     * Returns events related to clusters, security groups, snapshots, and parameter groups for the past 14 days. Events specific to a particular cluster, security group, snapshot or parameter group can be obtained by providing the name as a parameter. By default, the past hour of events are returned.
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param maxRecords Pagination limit (optional)
     * @param marker Pagination token (optional)
     * @param describeEventsMessage  (optional)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call pOSTDescribeEventsAsync(String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, String maxRecords, String marker, DescribeEventsMessage describeEventsMessage, final ApiCallback<EventsMessage> _callback) throws ApiException {

        okhttp3.Call localVarCall = pOSTDescribeEventsValidateBeforeCall(action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, maxRecords, marker, describeEventsMessage, _callback);
        Type localVarReturnType = new TypeToken<EventsMessage>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for pOSTDescribeHsmClientCertificates
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param maxRecords Pagination limit (optional)
     * @param marker Pagination token (optional)
     * @param describeHsmClientCertificatesMessage  (optional)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> HsmClientCertificateNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> InvalidTagFault </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call pOSTDescribeHsmClientCertificatesCall(String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, String maxRecords, String marker, DescribeHsmClientCertificatesMessage describeHsmClientCertificatesMessage, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = describeHsmClientCertificatesMessage;

        // create path and map variables
        String localVarPath = "/#Action=DescribeHsmClientCertificates";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (maxRecords != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("MaxRecords", maxRecords));
        }

        if (marker != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("Marker", marker));
        }

        if (action != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("Action", action));
        }

        if (version != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("Version", version));
        }

        if (xAmzContentSha256 != null) {
            localVarHeaderParams.put("X-Amz-Content-Sha256", localVarApiClient.parameterToString(xAmzContentSha256));
        }

        if (xAmzDate != null) {
            localVarHeaderParams.put("X-Amz-Date", localVarApiClient.parameterToString(xAmzDate));
        }

        if (xAmzAlgorithm != null) {
            localVarHeaderParams.put("X-Amz-Algorithm", localVarApiClient.parameterToString(xAmzAlgorithm));
        }

        if (xAmzCredential != null) {
            localVarHeaderParams.put("X-Amz-Credential", localVarApiClient.parameterToString(xAmzCredential));
        }

        if (xAmzSecurityToken != null) {
            localVarHeaderParams.put("X-Amz-Security-Token", localVarApiClient.parameterToString(xAmzSecurityToken));
        }

        if (xAmzSignature != null) {
            localVarHeaderParams.put("X-Amz-Signature", localVarApiClient.parameterToString(xAmzSignature));
        }

        if (xAmzSignedHeaders != null) {
            localVarHeaderParams.put("X-Amz-SignedHeaders", localVarApiClient.parameterToString(xAmzSignedHeaders));
        }

        final String[] localVarAccepts = {
            "text/xml"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            "text/xml"
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "hmac" };
        return localVarApiClient.buildCall(basePath, localVarPath, "POST", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call pOSTDescribeHsmClientCertificatesValidateBeforeCall(String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, String maxRecords, String marker, DescribeHsmClientCertificatesMessage describeHsmClientCertificatesMessage, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'action' is set
        if (action == null) {
            throw new ApiException("Missing the required parameter 'action' when calling pOSTDescribeHsmClientCertificates(Async)");
        }

        // verify the required parameter 'version' is set
        if (version == null) {
            throw new ApiException("Missing the required parameter 'version' when calling pOSTDescribeHsmClientCertificates(Async)");
        }

        return pOSTDescribeHsmClientCertificatesCall(action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, maxRecords, marker, describeHsmClientCertificatesMessage, _callback);

    }

    /**
     * 
     * &lt;p&gt;Returns information about the specified HSM client certificate. If no certificate ID is specified, returns information about all the HSM certificates owned by your Amazon Web Services account.&lt;/p&gt; &lt;p&gt;If you specify both tag keys and tag values in the same request, Amazon Redshift returns all HSM client certificates that match any combination of the specified keys and values. For example, if you have &lt;code&gt;owner&lt;/code&gt; and &lt;code&gt;environment&lt;/code&gt; for tag keys, and &lt;code&gt;admin&lt;/code&gt; and &lt;code&gt;test&lt;/code&gt; for tag values, all HSM client certificates that have any combination of those values are returned.&lt;/p&gt; &lt;p&gt;If both tag keys and values are omitted from the request, HSM client certificates are returned regardless of whether they have tag keys or values associated with them.&lt;/p&gt;
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param maxRecords Pagination limit (optional)
     * @param marker Pagination token (optional)
     * @param describeHsmClientCertificatesMessage  (optional)
     * @return HsmClientCertificateMessage
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> HsmClientCertificateNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> InvalidTagFault </td><td>  -  </td></tr>
     </table>
     */
    public HsmClientCertificateMessage pOSTDescribeHsmClientCertificates(String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, String maxRecords, String marker, DescribeHsmClientCertificatesMessage describeHsmClientCertificatesMessage) throws ApiException {
        ApiResponse<HsmClientCertificateMessage> localVarResp = pOSTDescribeHsmClientCertificatesWithHttpInfo(action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, maxRecords, marker, describeHsmClientCertificatesMessage);
        return localVarResp.getData();
    }

    /**
     * 
     * &lt;p&gt;Returns information about the specified HSM client certificate. If no certificate ID is specified, returns information about all the HSM certificates owned by your Amazon Web Services account.&lt;/p&gt; &lt;p&gt;If you specify both tag keys and tag values in the same request, Amazon Redshift returns all HSM client certificates that match any combination of the specified keys and values. For example, if you have &lt;code&gt;owner&lt;/code&gt; and &lt;code&gt;environment&lt;/code&gt; for tag keys, and &lt;code&gt;admin&lt;/code&gt; and &lt;code&gt;test&lt;/code&gt; for tag values, all HSM client certificates that have any combination of those values are returned.&lt;/p&gt; &lt;p&gt;If both tag keys and values are omitted from the request, HSM client certificates are returned regardless of whether they have tag keys or values associated with them.&lt;/p&gt;
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param maxRecords Pagination limit (optional)
     * @param marker Pagination token (optional)
     * @param describeHsmClientCertificatesMessage  (optional)
     * @return ApiResponse&lt;HsmClientCertificateMessage&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> HsmClientCertificateNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> InvalidTagFault </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<HsmClientCertificateMessage> pOSTDescribeHsmClientCertificatesWithHttpInfo(String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, String maxRecords, String marker, DescribeHsmClientCertificatesMessage describeHsmClientCertificatesMessage) throws ApiException {
        okhttp3.Call localVarCall = pOSTDescribeHsmClientCertificatesValidateBeforeCall(action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, maxRecords, marker, describeHsmClientCertificatesMessage, null);
        Type localVarReturnType = new TypeToken<HsmClientCertificateMessage>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     *  (asynchronously)
     * &lt;p&gt;Returns information about the specified HSM client certificate. If no certificate ID is specified, returns information about all the HSM certificates owned by your Amazon Web Services account.&lt;/p&gt; &lt;p&gt;If you specify both tag keys and tag values in the same request, Amazon Redshift returns all HSM client certificates that match any combination of the specified keys and values. For example, if you have &lt;code&gt;owner&lt;/code&gt; and &lt;code&gt;environment&lt;/code&gt; for tag keys, and &lt;code&gt;admin&lt;/code&gt; and &lt;code&gt;test&lt;/code&gt; for tag values, all HSM client certificates that have any combination of those values are returned.&lt;/p&gt; &lt;p&gt;If both tag keys and values are omitted from the request, HSM client certificates are returned regardless of whether they have tag keys or values associated with them.&lt;/p&gt;
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param maxRecords Pagination limit (optional)
     * @param marker Pagination token (optional)
     * @param describeHsmClientCertificatesMessage  (optional)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> HsmClientCertificateNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> InvalidTagFault </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call pOSTDescribeHsmClientCertificatesAsync(String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, String maxRecords, String marker, DescribeHsmClientCertificatesMessage describeHsmClientCertificatesMessage, final ApiCallback<HsmClientCertificateMessage> _callback) throws ApiException {

        okhttp3.Call localVarCall = pOSTDescribeHsmClientCertificatesValidateBeforeCall(action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, maxRecords, marker, describeHsmClientCertificatesMessage, _callback);
        Type localVarReturnType = new TypeToken<HsmClientCertificateMessage>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for pOSTDescribeHsmConfigurations
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param maxRecords Pagination limit (optional)
     * @param marker Pagination token (optional)
     * @param describeHsmConfigurationsMessage  (optional)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> HsmConfigurationNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> InvalidTagFault </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call pOSTDescribeHsmConfigurationsCall(String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, String maxRecords, String marker, DescribeHsmConfigurationsMessage describeHsmConfigurationsMessage, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = describeHsmConfigurationsMessage;

        // create path and map variables
        String localVarPath = "/#Action=DescribeHsmConfigurations";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (maxRecords != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("MaxRecords", maxRecords));
        }

        if (marker != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("Marker", marker));
        }

        if (action != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("Action", action));
        }

        if (version != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("Version", version));
        }

        if (xAmzContentSha256 != null) {
            localVarHeaderParams.put("X-Amz-Content-Sha256", localVarApiClient.parameterToString(xAmzContentSha256));
        }

        if (xAmzDate != null) {
            localVarHeaderParams.put("X-Amz-Date", localVarApiClient.parameterToString(xAmzDate));
        }

        if (xAmzAlgorithm != null) {
            localVarHeaderParams.put("X-Amz-Algorithm", localVarApiClient.parameterToString(xAmzAlgorithm));
        }

        if (xAmzCredential != null) {
            localVarHeaderParams.put("X-Amz-Credential", localVarApiClient.parameterToString(xAmzCredential));
        }

        if (xAmzSecurityToken != null) {
            localVarHeaderParams.put("X-Amz-Security-Token", localVarApiClient.parameterToString(xAmzSecurityToken));
        }

        if (xAmzSignature != null) {
            localVarHeaderParams.put("X-Amz-Signature", localVarApiClient.parameterToString(xAmzSignature));
        }

        if (xAmzSignedHeaders != null) {
            localVarHeaderParams.put("X-Amz-SignedHeaders", localVarApiClient.parameterToString(xAmzSignedHeaders));
        }

        final String[] localVarAccepts = {
            "text/xml"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            "text/xml"
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "hmac" };
        return localVarApiClient.buildCall(basePath, localVarPath, "POST", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call pOSTDescribeHsmConfigurationsValidateBeforeCall(String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, String maxRecords, String marker, DescribeHsmConfigurationsMessage describeHsmConfigurationsMessage, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'action' is set
        if (action == null) {
            throw new ApiException("Missing the required parameter 'action' when calling pOSTDescribeHsmConfigurations(Async)");
        }

        // verify the required parameter 'version' is set
        if (version == null) {
            throw new ApiException("Missing the required parameter 'version' when calling pOSTDescribeHsmConfigurations(Async)");
        }

        return pOSTDescribeHsmConfigurationsCall(action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, maxRecords, marker, describeHsmConfigurationsMessage, _callback);

    }

    /**
     * 
     * &lt;p&gt;Returns information about the specified Amazon Redshift HSM configuration. If no configuration ID is specified, returns information about all the HSM configurations owned by your Amazon Web Services account.&lt;/p&gt; &lt;p&gt;If you specify both tag keys and tag values in the same request, Amazon Redshift returns all HSM connections that match any combination of the specified keys and values. For example, if you have &lt;code&gt;owner&lt;/code&gt; and &lt;code&gt;environment&lt;/code&gt; for tag keys, and &lt;code&gt;admin&lt;/code&gt; and &lt;code&gt;test&lt;/code&gt; for tag values, all HSM connections that have any combination of those values are returned.&lt;/p&gt; &lt;p&gt;If both tag keys and values are omitted from the request, HSM connections are returned regardless of whether they have tag keys or values associated with them.&lt;/p&gt;
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param maxRecords Pagination limit (optional)
     * @param marker Pagination token (optional)
     * @param describeHsmConfigurationsMessage  (optional)
     * @return HsmConfigurationMessage
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> HsmConfigurationNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> InvalidTagFault </td><td>  -  </td></tr>
     </table>
     */
    public HsmConfigurationMessage pOSTDescribeHsmConfigurations(String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, String maxRecords, String marker, DescribeHsmConfigurationsMessage describeHsmConfigurationsMessage) throws ApiException {
        ApiResponse<HsmConfigurationMessage> localVarResp = pOSTDescribeHsmConfigurationsWithHttpInfo(action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, maxRecords, marker, describeHsmConfigurationsMessage);
        return localVarResp.getData();
    }

    /**
     * 
     * &lt;p&gt;Returns information about the specified Amazon Redshift HSM configuration. If no configuration ID is specified, returns information about all the HSM configurations owned by your Amazon Web Services account.&lt;/p&gt; &lt;p&gt;If you specify both tag keys and tag values in the same request, Amazon Redshift returns all HSM connections that match any combination of the specified keys and values. For example, if you have &lt;code&gt;owner&lt;/code&gt; and &lt;code&gt;environment&lt;/code&gt; for tag keys, and &lt;code&gt;admin&lt;/code&gt; and &lt;code&gt;test&lt;/code&gt; for tag values, all HSM connections that have any combination of those values are returned.&lt;/p&gt; &lt;p&gt;If both tag keys and values are omitted from the request, HSM connections are returned regardless of whether they have tag keys or values associated with them.&lt;/p&gt;
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param maxRecords Pagination limit (optional)
     * @param marker Pagination token (optional)
     * @param describeHsmConfigurationsMessage  (optional)
     * @return ApiResponse&lt;HsmConfigurationMessage&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> HsmConfigurationNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> InvalidTagFault </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<HsmConfigurationMessage> pOSTDescribeHsmConfigurationsWithHttpInfo(String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, String maxRecords, String marker, DescribeHsmConfigurationsMessage describeHsmConfigurationsMessage) throws ApiException {
        okhttp3.Call localVarCall = pOSTDescribeHsmConfigurationsValidateBeforeCall(action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, maxRecords, marker, describeHsmConfigurationsMessage, null);
        Type localVarReturnType = new TypeToken<HsmConfigurationMessage>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     *  (asynchronously)
     * &lt;p&gt;Returns information about the specified Amazon Redshift HSM configuration. If no configuration ID is specified, returns information about all the HSM configurations owned by your Amazon Web Services account.&lt;/p&gt; &lt;p&gt;If you specify both tag keys and tag values in the same request, Amazon Redshift returns all HSM connections that match any combination of the specified keys and values. For example, if you have &lt;code&gt;owner&lt;/code&gt; and &lt;code&gt;environment&lt;/code&gt; for tag keys, and &lt;code&gt;admin&lt;/code&gt; and &lt;code&gt;test&lt;/code&gt; for tag values, all HSM connections that have any combination of those values are returned.&lt;/p&gt; &lt;p&gt;If both tag keys and values are omitted from the request, HSM connections are returned regardless of whether they have tag keys or values associated with them.&lt;/p&gt;
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param maxRecords Pagination limit (optional)
     * @param marker Pagination token (optional)
     * @param describeHsmConfigurationsMessage  (optional)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> HsmConfigurationNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> InvalidTagFault </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call pOSTDescribeHsmConfigurationsAsync(String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, String maxRecords, String marker, DescribeHsmConfigurationsMessage describeHsmConfigurationsMessage, final ApiCallback<HsmConfigurationMessage> _callback) throws ApiException {

        okhttp3.Call localVarCall = pOSTDescribeHsmConfigurationsValidateBeforeCall(action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, maxRecords, marker, describeHsmConfigurationsMessage, _callback);
        Type localVarReturnType = new TypeToken<HsmConfigurationMessage>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for pOSTDescribeLoggingStatus
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param describeLoggingStatusMessage  (optional)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> ClusterNotFoundFault </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call pOSTDescribeLoggingStatusCall(String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, DescribeLoggingStatusMessage describeLoggingStatusMessage, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = describeLoggingStatusMessage;

        // create path and map variables
        String localVarPath = "/#Action=DescribeLoggingStatus";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (action != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("Action", action));
        }

        if (version != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("Version", version));
        }

        if (xAmzContentSha256 != null) {
            localVarHeaderParams.put("X-Amz-Content-Sha256", localVarApiClient.parameterToString(xAmzContentSha256));
        }

        if (xAmzDate != null) {
            localVarHeaderParams.put("X-Amz-Date", localVarApiClient.parameterToString(xAmzDate));
        }

        if (xAmzAlgorithm != null) {
            localVarHeaderParams.put("X-Amz-Algorithm", localVarApiClient.parameterToString(xAmzAlgorithm));
        }

        if (xAmzCredential != null) {
            localVarHeaderParams.put("X-Amz-Credential", localVarApiClient.parameterToString(xAmzCredential));
        }

        if (xAmzSecurityToken != null) {
            localVarHeaderParams.put("X-Amz-Security-Token", localVarApiClient.parameterToString(xAmzSecurityToken));
        }

        if (xAmzSignature != null) {
            localVarHeaderParams.put("X-Amz-Signature", localVarApiClient.parameterToString(xAmzSignature));
        }

        if (xAmzSignedHeaders != null) {
            localVarHeaderParams.put("X-Amz-SignedHeaders", localVarApiClient.parameterToString(xAmzSignedHeaders));
        }

        final String[] localVarAccepts = {
            "text/xml"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            "text/xml"
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "hmac" };
        return localVarApiClient.buildCall(basePath, localVarPath, "POST", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call pOSTDescribeLoggingStatusValidateBeforeCall(String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, DescribeLoggingStatusMessage describeLoggingStatusMessage, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'action' is set
        if (action == null) {
            throw new ApiException("Missing the required parameter 'action' when calling pOSTDescribeLoggingStatus(Async)");
        }

        // verify the required parameter 'version' is set
        if (version == null) {
            throw new ApiException("Missing the required parameter 'version' when calling pOSTDescribeLoggingStatus(Async)");
        }

        return pOSTDescribeLoggingStatusCall(action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, describeLoggingStatusMessage, _callback);

    }

    /**
     * 
     * Describes whether information, such as queries and connection attempts, is being logged for the specified Amazon Redshift cluster.
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param describeLoggingStatusMessage  (optional)
     * @return LoggingStatus
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> ClusterNotFoundFault </td><td>  -  </td></tr>
     </table>
     */
    public LoggingStatus pOSTDescribeLoggingStatus(String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, DescribeLoggingStatusMessage describeLoggingStatusMessage) throws ApiException {
        ApiResponse<LoggingStatus> localVarResp = pOSTDescribeLoggingStatusWithHttpInfo(action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, describeLoggingStatusMessage);
        return localVarResp.getData();
    }

    /**
     * 
     * Describes whether information, such as queries and connection attempts, is being logged for the specified Amazon Redshift cluster.
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param describeLoggingStatusMessage  (optional)
     * @return ApiResponse&lt;LoggingStatus&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> ClusterNotFoundFault </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<LoggingStatus> pOSTDescribeLoggingStatusWithHttpInfo(String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, DescribeLoggingStatusMessage describeLoggingStatusMessage) throws ApiException {
        okhttp3.Call localVarCall = pOSTDescribeLoggingStatusValidateBeforeCall(action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, describeLoggingStatusMessage, null);
        Type localVarReturnType = new TypeToken<LoggingStatus>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     *  (asynchronously)
     * Describes whether information, such as queries and connection attempts, is being logged for the specified Amazon Redshift cluster.
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param describeLoggingStatusMessage  (optional)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> ClusterNotFoundFault </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call pOSTDescribeLoggingStatusAsync(String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, DescribeLoggingStatusMessage describeLoggingStatusMessage, final ApiCallback<LoggingStatus> _callback) throws ApiException {

        okhttp3.Call localVarCall = pOSTDescribeLoggingStatusValidateBeforeCall(action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, describeLoggingStatusMessage, _callback);
        Type localVarReturnType = new TypeToken<LoggingStatus>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for pOSTDescribeNodeConfigurationOptions
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param maxRecords Pagination limit (optional)
     * @param marker Pagination token (optional)
     * @param describeNodeConfigurationOptionsMessage  (optional)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> ClusterSnapshotNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> InvalidClusterSnapshotStateFault </td><td>  -  </td></tr>
        <tr><td> 482 </td><td> ClusterNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 483 </td><td> AccessToSnapshotDeniedFault </td><td>  -  </td></tr>
        <tr><td> 484 </td><td> UnsupportedOperationFault </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call pOSTDescribeNodeConfigurationOptionsCall(String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, String maxRecords, String marker, DescribeNodeConfigurationOptionsMessage describeNodeConfigurationOptionsMessage, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = describeNodeConfigurationOptionsMessage;

        // create path and map variables
        String localVarPath = "/#Action=DescribeNodeConfigurationOptions";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (maxRecords != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("MaxRecords", maxRecords));
        }

        if (marker != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("Marker", marker));
        }

        if (action != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("Action", action));
        }

        if (version != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("Version", version));
        }

        if (xAmzContentSha256 != null) {
            localVarHeaderParams.put("X-Amz-Content-Sha256", localVarApiClient.parameterToString(xAmzContentSha256));
        }

        if (xAmzDate != null) {
            localVarHeaderParams.put("X-Amz-Date", localVarApiClient.parameterToString(xAmzDate));
        }

        if (xAmzAlgorithm != null) {
            localVarHeaderParams.put("X-Amz-Algorithm", localVarApiClient.parameterToString(xAmzAlgorithm));
        }

        if (xAmzCredential != null) {
            localVarHeaderParams.put("X-Amz-Credential", localVarApiClient.parameterToString(xAmzCredential));
        }

        if (xAmzSecurityToken != null) {
            localVarHeaderParams.put("X-Amz-Security-Token", localVarApiClient.parameterToString(xAmzSecurityToken));
        }

        if (xAmzSignature != null) {
            localVarHeaderParams.put("X-Amz-Signature", localVarApiClient.parameterToString(xAmzSignature));
        }

        if (xAmzSignedHeaders != null) {
            localVarHeaderParams.put("X-Amz-SignedHeaders", localVarApiClient.parameterToString(xAmzSignedHeaders));
        }

        final String[] localVarAccepts = {
            "text/xml"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            "text/xml"
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "hmac" };
        return localVarApiClient.buildCall(basePath, localVarPath, "POST", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call pOSTDescribeNodeConfigurationOptionsValidateBeforeCall(String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, String maxRecords, String marker, DescribeNodeConfigurationOptionsMessage describeNodeConfigurationOptionsMessage, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'action' is set
        if (action == null) {
            throw new ApiException("Missing the required parameter 'action' when calling pOSTDescribeNodeConfigurationOptions(Async)");
        }

        // verify the required parameter 'version' is set
        if (version == null) {
            throw new ApiException("Missing the required parameter 'version' when calling pOSTDescribeNodeConfigurationOptions(Async)");
        }

        return pOSTDescribeNodeConfigurationOptionsCall(action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, maxRecords, marker, describeNodeConfigurationOptionsMessage, _callback);

    }

    /**
     * 
     * Returns properties of possible node configurations such as node type, number of nodes, and disk usage for the specified action type.
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param maxRecords Pagination limit (optional)
     * @param marker Pagination token (optional)
     * @param describeNodeConfigurationOptionsMessage  (optional)
     * @return NodeConfigurationOptionsMessage
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> ClusterSnapshotNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> InvalidClusterSnapshotStateFault </td><td>  -  </td></tr>
        <tr><td> 482 </td><td> ClusterNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 483 </td><td> AccessToSnapshotDeniedFault </td><td>  -  </td></tr>
        <tr><td> 484 </td><td> UnsupportedOperationFault </td><td>  -  </td></tr>
     </table>
     */
    public NodeConfigurationOptionsMessage pOSTDescribeNodeConfigurationOptions(String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, String maxRecords, String marker, DescribeNodeConfigurationOptionsMessage describeNodeConfigurationOptionsMessage) throws ApiException {
        ApiResponse<NodeConfigurationOptionsMessage> localVarResp = pOSTDescribeNodeConfigurationOptionsWithHttpInfo(action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, maxRecords, marker, describeNodeConfigurationOptionsMessage);
        return localVarResp.getData();
    }

    /**
     * 
     * Returns properties of possible node configurations such as node type, number of nodes, and disk usage for the specified action type.
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param maxRecords Pagination limit (optional)
     * @param marker Pagination token (optional)
     * @param describeNodeConfigurationOptionsMessage  (optional)
     * @return ApiResponse&lt;NodeConfigurationOptionsMessage&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> ClusterSnapshotNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> InvalidClusterSnapshotStateFault </td><td>  -  </td></tr>
        <tr><td> 482 </td><td> ClusterNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 483 </td><td> AccessToSnapshotDeniedFault </td><td>  -  </td></tr>
        <tr><td> 484 </td><td> UnsupportedOperationFault </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<NodeConfigurationOptionsMessage> pOSTDescribeNodeConfigurationOptionsWithHttpInfo(String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, String maxRecords, String marker, DescribeNodeConfigurationOptionsMessage describeNodeConfigurationOptionsMessage) throws ApiException {
        okhttp3.Call localVarCall = pOSTDescribeNodeConfigurationOptionsValidateBeforeCall(action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, maxRecords, marker, describeNodeConfigurationOptionsMessage, null);
        Type localVarReturnType = new TypeToken<NodeConfigurationOptionsMessage>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     *  (asynchronously)
     * Returns properties of possible node configurations such as node type, number of nodes, and disk usage for the specified action type.
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param maxRecords Pagination limit (optional)
     * @param marker Pagination token (optional)
     * @param describeNodeConfigurationOptionsMessage  (optional)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> ClusterSnapshotNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> InvalidClusterSnapshotStateFault </td><td>  -  </td></tr>
        <tr><td> 482 </td><td> ClusterNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 483 </td><td> AccessToSnapshotDeniedFault </td><td>  -  </td></tr>
        <tr><td> 484 </td><td> UnsupportedOperationFault </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call pOSTDescribeNodeConfigurationOptionsAsync(String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, String maxRecords, String marker, DescribeNodeConfigurationOptionsMessage describeNodeConfigurationOptionsMessage, final ApiCallback<NodeConfigurationOptionsMessage> _callback) throws ApiException {

        okhttp3.Call localVarCall = pOSTDescribeNodeConfigurationOptionsValidateBeforeCall(action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, maxRecords, marker, describeNodeConfigurationOptionsMessage, _callback);
        Type localVarReturnType = new TypeToken<NodeConfigurationOptionsMessage>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for pOSTDescribeOrderableClusterOptions
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param maxRecords Pagination limit (optional)
     * @param marker Pagination token (optional)
     * @param describeOrderableClusterOptionsMessage  (optional)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call pOSTDescribeOrderableClusterOptionsCall(String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, String maxRecords, String marker, DescribeOrderableClusterOptionsMessage describeOrderableClusterOptionsMessage, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = describeOrderableClusterOptionsMessage;

        // create path and map variables
        String localVarPath = "/#Action=DescribeOrderableClusterOptions";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (maxRecords != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("MaxRecords", maxRecords));
        }

        if (marker != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("Marker", marker));
        }

        if (action != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("Action", action));
        }

        if (version != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("Version", version));
        }

        if (xAmzContentSha256 != null) {
            localVarHeaderParams.put("X-Amz-Content-Sha256", localVarApiClient.parameterToString(xAmzContentSha256));
        }

        if (xAmzDate != null) {
            localVarHeaderParams.put("X-Amz-Date", localVarApiClient.parameterToString(xAmzDate));
        }

        if (xAmzAlgorithm != null) {
            localVarHeaderParams.put("X-Amz-Algorithm", localVarApiClient.parameterToString(xAmzAlgorithm));
        }

        if (xAmzCredential != null) {
            localVarHeaderParams.put("X-Amz-Credential", localVarApiClient.parameterToString(xAmzCredential));
        }

        if (xAmzSecurityToken != null) {
            localVarHeaderParams.put("X-Amz-Security-Token", localVarApiClient.parameterToString(xAmzSecurityToken));
        }

        if (xAmzSignature != null) {
            localVarHeaderParams.put("X-Amz-Signature", localVarApiClient.parameterToString(xAmzSignature));
        }

        if (xAmzSignedHeaders != null) {
            localVarHeaderParams.put("X-Amz-SignedHeaders", localVarApiClient.parameterToString(xAmzSignedHeaders));
        }

        final String[] localVarAccepts = {
            "text/xml"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            "text/xml"
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "hmac" };
        return localVarApiClient.buildCall(basePath, localVarPath, "POST", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call pOSTDescribeOrderableClusterOptionsValidateBeforeCall(String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, String maxRecords, String marker, DescribeOrderableClusterOptionsMessage describeOrderableClusterOptionsMessage, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'action' is set
        if (action == null) {
            throw new ApiException("Missing the required parameter 'action' when calling pOSTDescribeOrderableClusterOptions(Async)");
        }

        // verify the required parameter 'version' is set
        if (version == null) {
            throw new ApiException("Missing the required parameter 'version' when calling pOSTDescribeOrderableClusterOptions(Async)");
        }

        return pOSTDescribeOrderableClusterOptionsCall(action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, maxRecords, marker, describeOrderableClusterOptionsMessage, _callback);

    }

    /**
     * 
     * Returns a list of orderable cluster options. Before you create a new cluster you can use this operation to find what options are available, such as the EC2 Availability Zones (AZ) in the specific Amazon Web Services Region that you can specify, and the node types you can request. The node types differ by available storage, memory, CPU and price. With the cost involved you might want to obtain a list of cluster options in the specific region and specify values when creating a cluster. For more information about managing clusters, go to &lt;a href&#x3D;\&quot;https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html\&quot;&gt;Amazon Redshift Clusters&lt;/a&gt; in the &lt;i&gt;Amazon Redshift Cluster Management Guide&lt;/i&gt;.
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param maxRecords Pagination limit (optional)
     * @param marker Pagination token (optional)
     * @param describeOrderableClusterOptionsMessage  (optional)
     * @return OrderableClusterOptionsMessage
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
     </table>
     */
    public OrderableClusterOptionsMessage pOSTDescribeOrderableClusterOptions(String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, String maxRecords, String marker, DescribeOrderableClusterOptionsMessage describeOrderableClusterOptionsMessage) throws ApiException {
        ApiResponse<OrderableClusterOptionsMessage> localVarResp = pOSTDescribeOrderableClusterOptionsWithHttpInfo(action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, maxRecords, marker, describeOrderableClusterOptionsMessage);
        return localVarResp.getData();
    }

    /**
     * 
     * Returns a list of orderable cluster options. Before you create a new cluster you can use this operation to find what options are available, such as the EC2 Availability Zones (AZ) in the specific Amazon Web Services Region that you can specify, and the node types you can request. The node types differ by available storage, memory, CPU and price. With the cost involved you might want to obtain a list of cluster options in the specific region and specify values when creating a cluster. For more information about managing clusters, go to &lt;a href&#x3D;\&quot;https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html\&quot;&gt;Amazon Redshift Clusters&lt;/a&gt; in the &lt;i&gt;Amazon Redshift Cluster Management Guide&lt;/i&gt;.
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param maxRecords Pagination limit (optional)
     * @param marker Pagination token (optional)
     * @param describeOrderableClusterOptionsMessage  (optional)
     * @return ApiResponse&lt;OrderableClusterOptionsMessage&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<OrderableClusterOptionsMessage> pOSTDescribeOrderableClusterOptionsWithHttpInfo(String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, String maxRecords, String marker, DescribeOrderableClusterOptionsMessage describeOrderableClusterOptionsMessage) throws ApiException {
        okhttp3.Call localVarCall = pOSTDescribeOrderableClusterOptionsValidateBeforeCall(action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, maxRecords, marker, describeOrderableClusterOptionsMessage, null);
        Type localVarReturnType = new TypeToken<OrderableClusterOptionsMessage>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     *  (asynchronously)
     * Returns a list of orderable cluster options. Before you create a new cluster you can use this operation to find what options are available, such as the EC2 Availability Zones (AZ) in the specific Amazon Web Services Region that you can specify, and the node types you can request. The node types differ by available storage, memory, CPU and price. With the cost involved you might want to obtain a list of cluster options in the specific region and specify values when creating a cluster. For more information about managing clusters, go to &lt;a href&#x3D;\&quot;https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html\&quot;&gt;Amazon Redshift Clusters&lt;/a&gt; in the &lt;i&gt;Amazon Redshift Cluster Management Guide&lt;/i&gt;.
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param maxRecords Pagination limit (optional)
     * @param marker Pagination token (optional)
     * @param describeOrderableClusterOptionsMessage  (optional)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call pOSTDescribeOrderableClusterOptionsAsync(String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, String maxRecords, String marker, DescribeOrderableClusterOptionsMessage describeOrderableClusterOptionsMessage, final ApiCallback<OrderableClusterOptionsMessage> _callback) throws ApiException {

        okhttp3.Call localVarCall = pOSTDescribeOrderableClusterOptionsValidateBeforeCall(action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, maxRecords, marker, describeOrderableClusterOptionsMessage, _callback);
        Type localVarReturnType = new TypeToken<OrderableClusterOptionsMessage>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for pOSTDescribePartners
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param describePartnersInputMessage  (optional)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> ClusterNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> UnauthorizedPartnerIntegrationFault </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call pOSTDescribePartnersCall(String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, DescribePartnersInputMessage describePartnersInputMessage, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = describePartnersInputMessage;

        // create path and map variables
        String localVarPath = "/#Action=DescribePartners";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (action != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("Action", action));
        }

        if (version != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("Version", version));
        }

        if (xAmzContentSha256 != null) {
            localVarHeaderParams.put("X-Amz-Content-Sha256", localVarApiClient.parameterToString(xAmzContentSha256));
        }

        if (xAmzDate != null) {
            localVarHeaderParams.put("X-Amz-Date", localVarApiClient.parameterToString(xAmzDate));
        }

        if (xAmzAlgorithm != null) {
            localVarHeaderParams.put("X-Amz-Algorithm", localVarApiClient.parameterToString(xAmzAlgorithm));
        }

        if (xAmzCredential != null) {
            localVarHeaderParams.put("X-Amz-Credential", localVarApiClient.parameterToString(xAmzCredential));
        }

        if (xAmzSecurityToken != null) {
            localVarHeaderParams.put("X-Amz-Security-Token", localVarApiClient.parameterToString(xAmzSecurityToken));
        }

        if (xAmzSignature != null) {
            localVarHeaderParams.put("X-Amz-Signature", localVarApiClient.parameterToString(xAmzSignature));
        }

        if (xAmzSignedHeaders != null) {
            localVarHeaderParams.put("X-Amz-SignedHeaders", localVarApiClient.parameterToString(xAmzSignedHeaders));
        }

        final String[] localVarAccepts = {
            "text/xml"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            "text/xml"
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "hmac" };
        return localVarApiClient.buildCall(basePath, localVarPath, "POST", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call pOSTDescribePartnersValidateBeforeCall(String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, DescribePartnersInputMessage describePartnersInputMessage, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'action' is set
        if (action == null) {
            throw new ApiException("Missing the required parameter 'action' when calling pOSTDescribePartners(Async)");
        }

        // verify the required parameter 'version' is set
        if (version == null) {
            throw new ApiException("Missing the required parameter 'version' when calling pOSTDescribePartners(Async)");
        }

        return pOSTDescribePartnersCall(action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, describePartnersInputMessage, _callback);

    }

    /**
     * 
     * Returns information about the partner integrations defined for a cluster.
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param describePartnersInputMessage  (optional)
     * @return DescribePartnersOutputMessage
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> ClusterNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> UnauthorizedPartnerIntegrationFault </td><td>  -  </td></tr>
     </table>
     */
    public DescribePartnersOutputMessage pOSTDescribePartners(String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, DescribePartnersInputMessage describePartnersInputMessage) throws ApiException {
        ApiResponse<DescribePartnersOutputMessage> localVarResp = pOSTDescribePartnersWithHttpInfo(action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, describePartnersInputMessage);
        return localVarResp.getData();
    }

    /**
     * 
     * Returns information about the partner integrations defined for a cluster.
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param describePartnersInputMessage  (optional)
     * @return ApiResponse&lt;DescribePartnersOutputMessage&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> ClusterNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> UnauthorizedPartnerIntegrationFault </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<DescribePartnersOutputMessage> pOSTDescribePartnersWithHttpInfo(String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, DescribePartnersInputMessage describePartnersInputMessage) throws ApiException {
        okhttp3.Call localVarCall = pOSTDescribePartnersValidateBeforeCall(action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, describePartnersInputMessage, null);
        Type localVarReturnType = new TypeToken<DescribePartnersOutputMessage>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     *  (asynchronously)
     * Returns information about the partner integrations defined for a cluster.
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param describePartnersInputMessage  (optional)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> ClusterNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> UnauthorizedPartnerIntegrationFault </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call pOSTDescribePartnersAsync(String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, DescribePartnersInputMessage describePartnersInputMessage, final ApiCallback<DescribePartnersOutputMessage> _callback) throws ApiException {

        okhttp3.Call localVarCall = pOSTDescribePartnersValidateBeforeCall(action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, describePartnersInputMessage, _callback);
        Type localVarReturnType = new TypeToken<DescribePartnersOutputMessage>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for pOSTDescribeReservedNodeExchangeStatus
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param maxRecords Pagination limit (optional)
     * @param marker Pagination token (optional)
     * @param describeReservedNodeExchangeStatusInputMessage  (optional)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> ReservedNodeNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> ReservedNodeExchangeNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 482 </td><td> UnsupportedOperationFault </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call pOSTDescribeReservedNodeExchangeStatusCall(String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, String maxRecords, String marker, DescribeReservedNodeExchangeStatusInputMessage describeReservedNodeExchangeStatusInputMessage, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = describeReservedNodeExchangeStatusInputMessage;

        // create path and map variables
        String localVarPath = "/#Action=DescribeReservedNodeExchangeStatus";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (maxRecords != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("MaxRecords", maxRecords));
        }

        if (marker != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("Marker", marker));
        }

        if (action != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("Action", action));
        }

        if (version != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("Version", version));
        }

        if (xAmzContentSha256 != null) {
            localVarHeaderParams.put("X-Amz-Content-Sha256", localVarApiClient.parameterToString(xAmzContentSha256));
        }

        if (xAmzDate != null) {
            localVarHeaderParams.put("X-Amz-Date", localVarApiClient.parameterToString(xAmzDate));
        }

        if (xAmzAlgorithm != null) {
            localVarHeaderParams.put("X-Amz-Algorithm", localVarApiClient.parameterToString(xAmzAlgorithm));
        }

        if (xAmzCredential != null) {
            localVarHeaderParams.put("X-Amz-Credential", localVarApiClient.parameterToString(xAmzCredential));
        }

        if (xAmzSecurityToken != null) {
            localVarHeaderParams.put("X-Amz-Security-Token", localVarApiClient.parameterToString(xAmzSecurityToken));
        }

        if (xAmzSignature != null) {
            localVarHeaderParams.put("X-Amz-Signature", localVarApiClient.parameterToString(xAmzSignature));
        }

        if (xAmzSignedHeaders != null) {
            localVarHeaderParams.put("X-Amz-SignedHeaders", localVarApiClient.parameterToString(xAmzSignedHeaders));
        }

        final String[] localVarAccepts = {
            "text/xml"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            "text/xml"
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "hmac" };
        return localVarApiClient.buildCall(basePath, localVarPath, "POST", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call pOSTDescribeReservedNodeExchangeStatusValidateBeforeCall(String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, String maxRecords, String marker, DescribeReservedNodeExchangeStatusInputMessage describeReservedNodeExchangeStatusInputMessage, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'action' is set
        if (action == null) {
            throw new ApiException("Missing the required parameter 'action' when calling pOSTDescribeReservedNodeExchangeStatus(Async)");
        }

        // verify the required parameter 'version' is set
        if (version == null) {
            throw new ApiException("Missing the required parameter 'version' when calling pOSTDescribeReservedNodeExchangeStatus(Async)");
        }

        return pOSTDescribeReservedNodeExchangeStatusCall(action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, maxRecords, marker, describeReservedNodeExchangeStatusInputMessage, _callback);

    }

    /**
     * 
     * Returns exchange status details and associated metadata for a reserved-node exchange. Statuses include such values as in progress and requested.
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param maxRecords Pagination limit (optional)
     * @param marker Pagination token (optional)
     * @param describeReservedNodeExchangeStatusInputMessage  (optional)
     * @return DescribeReservedNodeExchangeStatusOutputMessage
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> ReservedNodeNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> ReservedNodeExchangeNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 482 </td><td> UnsupportedOperationFault </td><td>  -  </td></tr>
     </table>
     */
    public DescribeReservedNodeExchangeStatusOutputMessage pOSTDescribeReservedNodeExchangeStatus(String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, String maxRecords, String marker, DescribeReservedNodeExchangeStatusInputMessage describeReservedNodeExchangeStatusInputMessage) throws ApiException {
        ApiResponse<DescribeReservedNodeExchangeStatusOutputMessage> localVarResp = pOSTDescribeReservedNodeExchangeStatusWithHttpInfo(action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, maxRecords, marker, describeReservedNodeExchangeStatusInputMessage);
        return localVarResp.getData();
    }

    /**
     * 
     * Returns exchange status details and associated metadata for a reserved-node exchange. Statuses include such values as in progress and requested.
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param maxRecords Pagination limit (optional)
     * @param marker Pagination token (optional)
     * @param describeReservedNodeExchangeStatusInputMessage  (optional)
     * @return ApiResponse&lt;DescribeReservedNodeExchangeStatusOutputMessage&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> ReservedNodeNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> ReservedNodeExchangeNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 482 </td><td> UnsupportedOperationFault </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<DescribeReservedNodeExchangeStatusOutputMessage> pOSTDescribeReservedNodeExchangeStatusWithHttpInfo(String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, String maxRecords, String marker, DescribeReservedNodeExchangeStatusInputMessage describeReservedNodeExchangeStatusInputMessage) throws ApiException {
        okhttp3.Call localVarCall = pOSTDescribeReservedNodeExchangeStatusValidateBeforeCall(action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, maxRecords, marker, describeReservedNodeExchangeStatusInputMessage, null);
        Type localVarReturnType = new TypeToken<DescribeReservedNodeExchangeStatusOutputMessage>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     *  (asynchronously)
     * Returns exchange status details and associated metadata for a reserved-node exchange. Statuses include such values as in progress and requested.
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param maxRecords Pagination limit (optional)
     * @param marker Pagination token (optional)
     * @param describeReservedNodeExchangeStatusInputMessage  (optional)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> ReservedNodeNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> ReservedNodeExchangeNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 482 </td><td> UnsupportedOperationFault </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call pOSTDescribeReservedNodeExchangeStatusAsync(String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, String maxRecords, String marker, DescribeReservedNodeExchangeStatusInputMessage describeReservedNodeExchangeStatusInputMessage, final ApiCallback<DescribeReservedNodeExchangeStatusOutputMessage> _callback) throws ApiException {

        okhttp3.Call localVarCall = pOSTDescribeReservedNodeExchangeStatusValidateBeforeCall(action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, maxRecords, marker, describeReservedNodeExchangeStatusInputMessage, _callback);
        Type localVarReturnType = new TypeToken<DescribeReservedNodeExchangeStatusOutputMessage>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for pOSTDescribeReservedNodeOfferings
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param maxRecords Pagination limit (optional)
     * @param marker Pagination token (optional)
     * @param describeReservedNodeOfferingsMessage  (optional)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> ReservedNodeOfferingNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> UnsupportedOperationFault </td><td>  -  </td></tr>
        <tr><td> 482 </td><td> DependentServiceUnavailableFault </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call pOSTDescribeReservedNodeOfferingsCall(String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, String maxRecords, String marker, DescribeReservedNodeOfferingsMessage describeReservedNodeOfferingsMessage, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = describeReservedNodeOfferingsMessage;

        // create path and map variables
        String localVarPath = "/#Action=DescribeReservedNodeOfferings";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (maxRecords != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("MaxRecords", maxRecords));
        }

        if (marker != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("Marker", marker));
        }

        if (action != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("Action", action));
        }

        if (version != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("Version", version));
        }

        if (xAmzContentSha256 != null) {
            localVarHeaderParams.put("X-Amz-Content-Sha256", localVarApiClient.parameterToString(xAmzContentSha256));
        }

        if (xAmzDate != null) {
            localVarHeaderParams.put("X-Amz-Date", localVarApiClient.parameterToString(xAmzDate));
        }

        if (xAmzAlgorithm != null) {
            localVarHeaderParams.put("X-Amz-Algorithm", localVarApiClient.parameterToString(xAmzAlgorithm));
        }

        if (xAmzCredential != null) {
            localVarHeaderParams.put("X-Amz-Credential", localVarApiClient.parameterToString(xAmzCredential));
        }

        if (xAmzSecurityToken != null) {
            localVarHeaderParams.put("X-Amz-Security-Token", localVarApiClient.parameterToString(xAmzSecurityToken));
        }

        if (xAmzSignature != null) {
            localVarHeaderParams.put("X-Amz-Signature", localVarApiClient.parameterToString(xAmzSignature));
        }

        if (xAmzSignedHeaders != null) {
            localVarHeaderParams.put("X-Amz-SignedHeaders", localVarApiClient.parameterToString(xAmzSignedHeaders));
        }

        final String[] localVarAccepts = {
            "text/xml"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            "text/xml"
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "hmac" };
        return localVarApiClient.buildCall(basePath, localVarPath, "POST", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call pOSTDescribeReservedNodeOfferingsValidateBeforeCall(String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, String maxRecords, String marker, DescribeReservedNodeOfferingsMessage describeReservedNodeOfferingsMessage, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'action' is set
        if (action == null) {
            throw new ApiException("Missing the required parameter 'action' when calling pOSTDescribeReservedNodeOfferings(Async)");
        }

        // verify the required parameter 'version' is set
        if (version == null) {
            throw new ApiException("Missing the required parameter 'version' when calling pOSTDescribeReservedNodeOfferings(Async)");
        }

        return pOSTDescribeReservedNodeOfferingsCall(action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, maxRecords, marker, describeReservedNodeOfferingsMessage, _callback);

    }

    /**
     * 
     * &lt;p&gt;Returns a list of the available reserved node offerings by Amazon Redshift with their descriptions including the node type, the fixed and recurring costs of reserving the node and duration the node will be reserved for you. These descriptions help you determine which reserve node offering you want to purchase. You then use the unique offering ID in you call to &lt;a&gt;PurchaseReservedNodeOffering&lt;/a&gt; to reserve one or more nodes for your Amazon Redshift cluster. &lt;/p&gt; &lt;p&gt; For more information about reserved node offerings, go to &lt;a href&#x3D;\&quot;https://docs.aws.amazon.com/redshift/latest/mgmt/purchase-reserved-node-instance.html\&quot;&gt;Purchasing Reserved Nodes&lt;/a&gt; in the &lt;i&gt;Amazon Redshift Cluster Management Guide&lt;/i&gt;.&lt;/p&gt;
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param maxRecords Pagination limit (optional)
     * @param marker Pagination token (optional)
     * @param describeReservedNodeOfferingsMessage  (optional)
     * @return ReservedNodeOfferingsMessage
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> ReservedNodeOfferingNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> UnsupportedOperationFault </td><td>  -  </td></tr>
        <tr><td> 482 </td><td> DependentServiceUnavailableFault </td><td>  -  </td></tr>
     </table>
     */
    public ReservedNodeOfferingsMessage pOSTDescribeReservedNodeOfferings(String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, String maxRecords, String marker, DescribeReservedNodeOfferingsMessage describeReservedNodeOfferingsMessage) throws ApiException {
        ApiResponse<ReservedNodeOfferingsMessage> localVarResp = pOSTDescribeReservedNodeOfferingsWithHttpInfo(action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, maxRecords, marker, describeReservedNodeOfferingsMessage);
        return localVarResp.getData();
    }

    /**
     * 
     * &lt;p&gt;Returns a list of the available reserved node offerings by Amazon Redshift with their descriptions including the node type, the fixed and recurring costs of reserving the node and duration the node will be reserved for you. These descriptions help you determine which reserve node offering you want to purchase. You then use the unique offering ID in you call to &lt;a&gt;PurchaseReservedNodeOffering&lt;/a&gt; to reserve one or more nodes for your Amazon Redshift cluster. &lt;/p&gt; &lt;p&gt; For more information about reserved node offerings, go to &lt;a href&#x3D;\&quot;https://docs.aws.amazon.com/redshift/latest/mgmt/purchase-reserved-node-instance.html\&quot;&gt;Purchasing Reserved Nodes&lt;/a&gt; in the &lt;i&gt;Amazon Redshift Cluster Management Guide&lt;/i&gt;.&lt;/p&gt;
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param maxRecords Pagination limit (optional)
     * @param marker Pagination token (optional)
     * @param describeReservedNodeOfferingsMessage  (optional)
     * @return ApiResponse&lt;ReservedNodeOfferingsMessage&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> ReservedNodeOfferingNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> UnsupportedOperationFault </td><td>  -  </td></tr>
        <tr><td> 482 </td><td> DependentServiceUnavailableFault </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<ReservedNodeOfferingsMessage> pOSTDescribeReservedNodeOfferingsWithHttpInfo(String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, String maxRecords, String marker, DescribeReservedNodeOfferingsMessage describeReservedNodeOfferingsMessage) throws ApiException {
        okhttp3.Call localVarCall = pOSTDescribeReservedNodeOfferingsValidateBeforeCall(action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, maxRecords, marker, describeReservedNodeOfferingsMessage, null);
        Type localVarReturnType = new TypeToken<ReservedNodeOfferingsMessage>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     *  (asynchronously)
     * &lt;p&gt;Returns a list of the available reserved node offerings by Amazon Redshift with their descriptions including the node type, the fixed and recurring costs of reserving the node and duration the node will be reserved for you. These descriptions help you determine which reserve node offering you want to purchase. You then use the unique offering ID in you call to &lt;a&gt;PurchaseReservedNodeOffering&lt;/a&gt; to reserve one or more nodes for your Amazon Redshift cluster. &lt;/p&gt; &lt;p&gt; For more information about reserved node offerings, go to &lt;a href&#x3D;\&quot;https://docs.aws.amazon.com/redshift/latest/mgmt/purchase-reserved-node-instance.html\&quot;&gt;Purchasing Reserved Nodes&lt;/a&gt; in the &lt;i&gt;Amazon Redshift Cluster Management Guide&lt;/i&gt;.&lt;/p&gt;
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param maxRecords Pagination limit (optional)
     * @param marker Pagination token (optional)
     * @param describeReservedNodeOfferingsMessage  (optional)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> ReservedNodeOfferingNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> UnsupportedOperationFault </td><td>  -  </td></tr>
        <tr><td> 482 </td><td> DependentServiceUnavailableFault </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call pOSTDescribeReservedNodeOfferingsAsync(String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, String maxRecords, String marker, DescribeReservedNodeOfferingsMessage describeReservedNodeOfferingsMessage, final ApiCallback<ReservedNodeOfferingsMessage> _callback) throws ApiException {

        okhttp3.Call localVarCall = pOSTDescribeReservedNodeOfferingsValidateBeforeCall(action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, maxRecords, marker, describeReservedNodeOfferingsMessage, _callback);
        Type localVarReturnType = new TypeToken<ReservedNodeOfferingsMessage>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for pOSTDescribeReservedNodes
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param maxRecords Pagination limit (optional)
     * @param marker Pagination token (optional)
     * @param describeReservedNodesMessage  (optional)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> ReservedNodeNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> DependentServiceUnavailableFault </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call pOSTDescribeReservedNodesCall(String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, String maxRecords, String marker, DescribeReservedNodesMessage describeReservedNodesMessage, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = describeReservedNodesMessage;

        // create path and map variables
        String localVarPath = "/#Action=DescribeReservedNodes";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (maxRecords != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("MaxRecords", maxRecords));
        }

        if (marker != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("Marker", marker));
        }

        if (action != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("Action", action));
        }

        if (version != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("Version", version));
        }

        if (xAmzContentSha256 != null) {
            localVarHeaderParams.put("X-Amz-Content-Sha256", localVarApiClient.parameterToString(xAmzContentSha256));
        }

        if (xAmzDate != null) {
            localVarHeaderParams.put("X-Amz-Date", localVarApiClient.parameterToString(xAmzDate));
        }

        if (xAmzAlgorithm != null) {
            localVarHeaderParams.put("X-Amz-Algorithm", localVarApiClient.parameterToString(xAmzAlgorithm));
        }

        if (xAmzCredential != null) {
            localVarHeaderParams.put("X-Amz-Credential", localVarApiClient.parameterToString(xAmzCredential));
        }

        if (xAmzSecurityToken != null) {
            localVarHeaderParams.put("X-Amz-Security-Token", localVarApiClient.parameterToString(xAmzSecurityToken));
        }

        if (xAmzSignature != null) {
            localVarHeaderParams.put("X-Amz-Signature", localVarApiClient.parameterToString(xAmzSignature));
        }

        if (xAmzSignedHeaders != null) {
            localVarHeaderParams.put("X-Amz-SignedHeaders", localVarApiClient.parameterToString(xAmzSignedHeaders));
        }

        final String[] localVarAccepts = {
            "text/xml"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            "text/xml"
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "hmac" };
        return localVarApiClient.buildCall(basePath, localVarPath, "POST", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call pOSTDescribeReservedNodesValidateBeforeCall(String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, String maxRecords, String marker, DescribeReservedNodesMessage describeReservedNodesMessage, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'action' is set
        if (action == null) {
            throw new ApiException("Missing the required parameter 'action' when calling pOSTDescribeReservedNodes(Async)");
        }

        // verify the required parameter 'version' is set
        if (version == null) {
            throw new ApiException("Missing the required parameter 'version' when calling pOSTDescribeReservedNodes(Async)");
        }

        return pOSTDescribeReservedNodesCall(action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, maxRecords, marker, describeReservedNodesMessage, _callback);

    }

    /**
     * 
     * Returns the descriptions of the reserved nodes.
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param maxRecords Pagination limit (optional)
     * @param marker Pagination token (optional)
     * @param describeReservedNodesMessage  (optional)
     * @return ReservedNodesMessage
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> ReservedNodeNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> DependentServiceUnavailableFault </td><td>  -  </td></tr>
     </table>
     */
    public ReservedNodesMessage pOSTDescribeReservedNodes(String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, String maxRecords, String marker, DescribeReservedNodesMessage describeReservedNodesMessage) throws ApiException {
        ApiResponse<ReservedNodesMessage> localVarResp = pOSTDescribeReservedNodesWithHttpInfo(action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, maxRecords, marker, describeReservedNodesMessage);
        return localVarResp.getData();
    }

    /**
     * 
     * Returns the descriptions of the reserved nodes.
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param maxRecords Pagination limit (optional)
     * @param marker Pagination token (optional)
     * @param describeReservedNodesMessage  (optional)
     * @return ApiResponse&lt;ReservedNodesMessage&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> ReservedNodeNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> DependentServiceUnavailableFault </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<ReservedNodesMessage> pOSTDescribeReservedNodesWithHttpInfo(String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, String maxRecords, String marker, DescribeReservedNodesMessage describeReservedNodesMessage) throws ApiException {
        okhttp3.Call localVarCall = pOSTDescribeReservedNodesValidateBeforeCall(action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, maxRecords, marker, describeReservedNodesMessage, null);
        Type localVarReturnType = new TypeToken<ReservedNodesMessage>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     *  (asynchronously)
     * Returns the descriptions of the reserved nodes.
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param maxRecords Pagination limit (optional)
     * @param marker Pagination token (optional)
     * @param describeReservedNodesMessage  (optional)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> ReservedNodeNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> DependentServiceUnavailableFault </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call pOSTDescribeReservedNodesAsync(String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, String maxRecords, String marker, DescribeReservedNodesMessage describeReservedNodesMessage, final ApiCallback<ReservedNodesMessage> _callback) throws ApiException {

        okhttp3.Call localVarCall = pOSTDescribeReservedNodesValidateBeforeCall(action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, maxRecords, marker, describeReservedNodesMessage, _callback);
        Type localVarReturnType = new TypeToken<ReservedNodesMessage>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for pOSTDescribeResize
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param describeResizeMessage  (optional)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> ClusterNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> ResizeNotFoundFault </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call pOSTDescribeResizeCall(String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, DescribeResizeMessage describeResizeMessage, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = describeResizeMessage;

        // create path and map variables
        String localVarPath = "/#Action=DescribeResize";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (action != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("Action", action));
        }

        if (version != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("Version", version));
        }

        if (xAmzContentSha256 != null) {
            localVarHeaderParams.put("X-Amz-Content-Sha256", localVarApiClient.parameterToString(xAmzContentSha256));
        }

        if (xAmzDate != null) {
            localVarHeaderParams.put("X-Amz-Date", localVarApiClient.parameterToString(xAmzDate));
        }

        if (xAmzAlgorithm != null) {
            localVarHeaderParams.put("X-Amz-Algorithm", localVarApiClient.parameterToString(xAmzAlgorithm));
        }

        if (xAmzCredential != null) {
            localVarHeaderParams.put("X-Amz-Credential", localVarApiClient.parameterToString(xAmzCredential));
        }

        if (xAmzSecurityToken != null) {
            localVarHeaderParams.put("X-Amz-Security-Token", localVarApiClient.parameterToString(xAmzSecurityToken));
        }

        if (xAmzSignature != null) {
            localVarHeaderParams.put("X-Amz-Signature", localVarApiClient.parameterToString(xAmzSignature));
        }

        if (xAmzSignedHeaders != null) {
            localVarHeaderParams.put("X-Amz-SignedHeaders", localVarApiClient.parameterToString(xAmzSignedHeaders));
        }

        final String[] localVarAccepts = {
            "text/xml"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            "text/xml"
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "hmac" };
        return localVarApiClient.buildCall(basePath, localVarPath, "POST", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call pOSTDescribeResizeValidateBeforeCall(String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, DescribeResizeMessage describeResizeMessage, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'action' is set
        if (action == null) {
            throw new ApiException("Missing the required parameter 'action' when calling pOSTDescribeResize(Async)");
        }

        // verify the required parameter 'version' is set
        if (version == null) {
            throw new ApiException("Missing the required parameter 'version' when calling pOSTDescribeResize(Async)");
        }

        return pOSTDescribeResizeCall(action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, describeResizeMessage, _callback);

    }

    /**
     * 
     * &lt;p&gt;Returns information about the last resize operation for the specified cluster. If no resize operation has ever been initiated for the specified cluster, a &lt;code&gt;HTTP 404&lt;/code&gt; error is returned. If a resize operation was initiated and completed, the status of the resize remains as &lt;code&gt;SUCCEEDED&lt;/code&gt; until the next resize. &lt;/p&gt; &lt;p&gt;A resize operation can be requested using &lt;a&gt;ModifyCluster&lt;/a&gt; and specifying a different number or type of nodes for the cluster. &lt;/p&gt;
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param describeResizeMessage  (optional)
     * @return ResizeProgressMessage
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> ClusterNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> ResizeNotFoundFault </td><td>  -  </td></tr>
     </table>
     */
    public ResizeProgressMessage pOSTDescribeResize(String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, DescribeResizeMessage describeResizeMessage) throws ApiException {
        ApiResponse<ResizeProgressMessage> localVarResp = pOSTDescribeResizeWithHttpInfo(action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, describeResizeMessage);
        return localVarResp.getData();
    }

    /**
     * 
     * &lt;p&gt;Returns information about the last resize operation for the specified cluster. If no resize operation has ever been initiated for the specified cluster, a &lt;code&gt;HTTP 404&lt;/code&gt; error is returned. If a resize operation was initiated and completed, the status of the resize remains as &lt;code&gt;SUCCEEDED&lt;/code&gt; until the next resize. &lt;/p&gt; &lt;p&gt;A resize operation can be requested using &lt;a&gt;ModifyCluster&lt;/a&gt; and specifying a different number or type of nodes for the cluster. &lt;/p&gt;
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param describeResizeMessage  (optional)
     * @return ApiResponse&lt;ResizeProgressMessage&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> ClusterNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> ResizeNotFoundFault </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<ResizeProgressMessage> pOSTDescribeResizeWithHttpInfo(String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, DescribeResizeMessage describeResizeMessage) throws ApiException {
        okhttp3.Call localVarCall = pOSTDescribeResizeValidateBeforeCall(action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, describeResizeMessage, null);
        Type localVarReturnType = new TypeToken<ResizeProgressMessage>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     *  (asynchronously)
     * &lt;p&gt;Returns information about the last resize operation for the specified cluster. If no resize operation has ever been initiated for the specified cluster, a &lt;code&gt;HTTP 404&lt;/code&gt; error is returned. If a resize operation was initiated and completed, the status of the resize remains as &lt;code&gt;SUCCEEDED&lt;/code&gt; until the next resize. &lt;/p&gt; &lt;p&gt;A resize operation can be requested using &lt;a&gt;ModifyCluster&lt;/a&gt; and specifying a different number or type of nodes for the cluster. &lt;/p&gt;
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param describeResizeMessage  (optional)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> ClusterNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> ResizeNotFoundFault </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call pOSTDescribeResizeAsync(String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, DescribeResizeMessage describeResizeMessage, final ApiCallback<ResizeProgressMessage> _callback) throws ApiException {

        okhttp3.Call localVarCall = pOSTDescribeResizeValidateBeforeCall(action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, describeResizeMessage, _callback);
        Type localVarReturnType = new TypeToken<ResizeProgressMessage>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for pOSTDescribeScheduledActions
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param maxRecords Pagination limit (optional)
     * @param marker Pagination token (optional)
     * @param describeScheduledActionsMessage  (optional)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> ScheduledActionNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> UnauthorizedOperation </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call pOSTDescribeScheduledActionsCall(String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, String maxRecords, String marker, DescribeScheduledActionsMessage describeScheduledActionsMessage, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = describeScheduledActionsMessage;

        // create path and map variables
        String localVarPath = "/#Action=DescribeScheduledActions";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (maxRecords != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("MaxRecords", maxRecords));
        }

        if (marker != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("Marker", marker));
        }

        if (action != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("Action", action));
        }

        if (version != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("Version", version));
        }

        if (xAmzContentSha256 != null) {
            localVarHeaderParams.put("X-Amz-Content-Sha256", localVarApiClient.parameterToString(xAmzContentSha256));
        }

        if (xAmzDate != null) {
            localVarHeaderParams.put("X-Amz-Date", localVarApiClient.parameterToString(xAmzDate));
        }

        if (xAmzAlgorithm != null) {
            localVarHeaderParams.put("X-Amz-Algorithm", localVarApiClient.parameterToString(xAmzAlgorithm));
        }

        if (xAmzCredential != null) {
            localVarHeaderParams.put("X-Amz-Credential", localVarApiClient.parameterToString(xAmzCredential));
        }

        if (xAmzSecurityToken != null) {
            localVarHeaderParams.put("X-Amz-Security-Token", localVarApiClient.parameterToString(xAmzSecurityToken));
        }

        if (xAmzSignature != null) {
            localVarHeaderParams.put("X-Amz-Signature", localVarApiClient.parameterToString(xAmzSignature));
        }

        if (xAmzSignedHeaders != null) {
            localVarHeaderParams.put("X-Amz-SignedHeaders", localVarApiClient.parameterToString(xAmzSignedHeaders));
        }

        final String[] localVarAccepts = {
            "text/xml"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            "text/xml"
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "hmac" };
        return localVarApiClient.buildCall(basePath, localVarPath, "POST", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call pOSTDescribeScheduledActionsValidateBeforeCall(String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, String maxRecords, String marker, DescribeScheduledActionsMessage describeScheduledActionsMessage, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'action' is set
        if (action == null) {
            throw new ApiException("Missing the required parameter 'action' when calling pOSTDescribeScheduledActions(Async)");
        }

        // verify the required parameter 'version' is set
        if (version == null) {
            throw new ApiException("Missing the required parameter 'version' when calling pOSTDescribeScheduledActions(Async)");
        }

        return pOSTDescribeScheduledActionsCall(action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, maxRecords, marker, describeScheduledActionsMessage, _callback);

    }

    /**
     * 
     * Describes properties of scheduled actions. 
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param maxRecords Pagination limit (optional)
     * @param marker Pagination token (optional)
     * @param describeScheduledActionsMessage  (optional)
     * @return ScheduledActionsMessage
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> ScheduledActionNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> UnauthorizedOperation </td><td>  -  </td></tr>
     </table>
     */
    public ScheduledActionsMessage pOSTDescribeScheduledActions(String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, String maxRecords, String marker, DescribeScheduledActionsMessage describeScheduledActionsMessage) throws ApiException {
        ApiResponse<ScheduledActionsMessage> localVarResp = pOSTDescribeScheduledActionsWithHttpInfo(action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, maxRecords, marker, describeScheduledActionsMessage);
        return localVarResp.getData();
    }

    /**
     * 
     * Describes properties of scheduled actions. 
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param maxRecords Pagination limit (optional)
     * @param marker Pagination token (optional)
     * @param describeScheduledActionsMessage  (optional)
     * @return ApiResponse&lt;ScheduledActionsMessage&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> ScheduledActionNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> UnauthorizedOperation </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<ScheduledActionsMessage> pOSTDescribeScheduledActionsWithHttpInfo(String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, String maxRecords, String marker, DescribeScheduledActionsMessage describeScheduledActionsMessage) throws ApiException {
        okhttp3.Call localVarCall = pOSTDescribeScheduledActionsValidateBeforeCall(action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, maxRecords, marker, describeScheduledActionsMessage, null);
        Type localVarReturnType = new TypeToken<ScheduledActionsMessage>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     *  (asynchronously)
     * Describes properties of scheduled actions. 
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param maxRecords Pagination limit (optional)
     * @param marker Pagination token (optional)
     * @param describeScheduledActionsMessage  (optional)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> ScheduledActionNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> UnauthorizedOperation </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call pOSTDescribeScheduledActionsAsync(String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, String maxRecords, String marker, DescribeScheduledActionsMessage describeScheduledActionsMessage, final ApiCallback<ScheduledActionsMessage> _callback) throws ApiException {

        okhttp3.Call localVarCall = pOSTDescribeScheduledActionsValidateBeforeCall(action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, maxRecords, marker, describeScheduledActionsMessage, _callback);
        Type localVarReturnType = new TypeToken<ScheduledActionsMessage>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for pOSTDescribeSnapshotCopyGrants
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param maxRecords Pagination limit (optional)
     * @param marker Pagination token (optional)
     * @param describeSnapshotCopyGrantsMessage  (optional)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> SnapshotCopyGrantNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> InvalidTagFault </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call pOSTDescribeSnapshotCopyGrantsCall(String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, String maxRecords, String marker, DescribeSnapshotCopyGrantsMessage describeSnapshotCopyGrantsMessage, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = describeSnapshotCopyGrantsMessage;

        // create path and map variables
        String localVarPath = "/#Action=DescribeSnapshotCopyGrants";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (maxRecords != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("MaxRecords", maxRecords));
        }

        if (marker != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("Marker", marker));
        }

        if (action != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("Action", action));
        }

        if (version != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("Version", version));
        }

        if (xAmzContentSha256 != null) {
            localVarHeaderParams.put("X-Amz-Content-Sha256", localVarApiClient.parameterToString(xAmzContentSha256));
        }

        if (xAmzDate != null) {
            localVarHeaderParams.put("X-Amz-Date", localVarApiClient.parameterToString(xAmzDate));
        }

        if (xAmzAlgorithm != null) {
            localVarHeaderParams.put("X-Amz-Algorithm", localVarApiClient.parameterToString(xAmzAlgorithm));
        }

        if (xAmzCredential != null) {
            localVarHeaderParams.put("X-Amz-Credential", localVarApiClient.parameterToString(xAmzCredential));
        }

        if (xAmzSecurityToken != null) {
            localVarHeaderParams.put("X-Amz-Security-Token", localVarApiClient.parameterToString(xAmzSecurityToken));
        }

        if (xAmzSignature != null) {
            localVarHeaderParams.put("X-Amz-Signature", localVarApiClient.parameterToString(xAmzSignature));
        }

        if (xAmzSignedHeaders != null) {
            localVarHeaderParams.put("X-Amz-SignedHeaders", localVarApiClient.parameterToString(xAmzSignedHeaders));
        }

        final String[] localVarAccepts = {
            "text/xml"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            "text/xml"
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "hmac" };
        return localVarApiClient.buildCall(basePath, localVarPath, "POST", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call pOSTDescribeSnapshotCopyGrantsValidateBeforeCall(String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, String maxRecords, String marker, DescribeSnapshotCopyGrantsMessage describeSnapshotCopyGrantsMessage, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'action' is set
        if (action == null) {
            throw new ApiException("Missing the required parameter 'action' when calling pOSTDescribeSnapshotCopyGrants(Async)");
        }

        // verify the required parameter 'version' is set
        if (version == null) {
            throw new ApiException("Missing the required parameter 'version' when calling pOSTDescribeSnapshotCopyGrants(Async)");
        }

        return pOSTDescribeSnapshotCopyGrantsCall(action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, maxRecords, marker, describeSnapshotCopyGrantsMessage, _callback);

    }

    /**
     * 
     * &lt;p&gt;Returns a list of snapshot copy grants owned by the Amazon Web Services account in the destination region.&lt;/p&gt; &lt;p&gt; For more information about managing snapshot copy grants, go to &lt;a href&#x3D;\&quot;https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-db-encryption.html\&quot;&gt;Amazon Redshift Database Encryption&lt;/a&gt; in the &lt;i&gt;Amazon Redshift Cluster Management Guide&lt;/i&gt;. &lt;/p&gt;
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param maxRecords Pagination limit (optional)
     * @param marker Pagination token (optional)
     * @param describeSnapshotCopyGrantsMessage  (optional)
     * @return SnapshotCopyGrantMessage
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> SnapshotCopyGrantNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> InvalidTagFault </td><td>  -  </td></tr>
     </table>
     */
    public SnapshotCopyGrantMessage pOSTDescribeSnapshotCopyGrants(String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, String maxRecords, String marker, DescribeSnapshotCopyGrantsMessage describeSnapshotCopyGrantsMessage) throws ApiException {
        ApiResponse<SnapshotCopyGrantMessage> localVarResp = pOSTDescribeSnapshotCopyGrantsWithHttpInfo(action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, maxRecords, marker, describeSnapshotCopyGrantsMessage);
        return localVarResp.getData();
    }

    /**
     * 
     * &lt;p&gt;Returns a list of snapshot copy grants owned by the Amazon Web Services account in the destination region.&lt;/p&gt; &lt;p&gt; For more information about managing snapshot copy grants, go to &lt;a href&#x3D;\&quot;https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-db-encryption.html\&quot;&gt;Amazon Redshift Database Encryption&lt;/a&gt; in the &lt;i&gt;Amazon Redshift Cluster Management Guide&lt;/i&gt;. &lt;/p&gt;
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param maxRecords Pagination limit (optional)
     * @param marker Pagination token (optional)
     * @param describeSnapshotCopyGrantsMessage  (optional)
     * @return ApiResponse&lt;SnapshotCopyGrantMessage&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> SnapshotCopyGrantNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> InvalidTagFault </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<SnapshotCopyGrantMessage> pOSTDescribeSnapshotCopyGrantsWithHttpInfo(String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, String maxRecords, String marker, DescribeSnapshotCopyGrantsMessage describeSnapshotCopyGrantsMessage) throws ApiException {
        okhttp3.Call localVarCall = pOSTDescribeSnapshotCopyGrantsValidateBeforeCall(action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, maxRecords, marker, describeSnapshotCopyGrantsMessage, null);
        Type localVarReturnType = new TypeToken<SnapshotCopyGrantMessage>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     *  (asynchronously)
     * &lt;p&gt;Returns a list of snapshot copy grants owned by the Amazon Web Services account in the destination region.&lt;/p&gt; &lt;p&gt; For more information about managing snapshot copy grants, go to &lt;a href&#x3D;\&quot;https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-db-encryption.html\&quot;&gt;Amazon Redshift Database Encryption&lt;/a&gt; in the &lt;i&gt;Amazon Redshift Cluster Management Guide&lt;/i&gt;. &lt;/p&gt;
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param maxRecords Pagination limit (optional)
     * @param marker Pagination token (optional)
     * @param describeSnapshotCopyGrantsMessage  (optional)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> SnapshotCopyGrantNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> InvalidTagFault </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call pOSTDescribeSnapshotCopyGrantsAsync(String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, String maxRecords, String marker, DescribeSnapshotCopyGrantsMessage describeSnapshotCopyGrantsMessage, final ApiCallback<SnapshotCopyGrantMessage> _callback) throws ApiException {

        okhttp3.Call localVarCall = pOSTDescribeSnapshotCopyGrantsValidateBeforeCall(action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, maxRecords, marker, describeSnapshotCopyGrantsMessage, _callback);
        Type localVarReturnType = new TypeToken<SnapshotCopyGrantMessage>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for pOSTDescribeSnapshotSchedules
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param maxRecords Pagination limit (optional)
     * @param marker Pagination token (optional)
     * @param describeSnapshotSchedulesMessage  (optional)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call pOSTDescribeSnapshotSchedulesCall(String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, String maxRecords, String marker, DescribeSnapshotSchedulesMessage describeSnapshotSchedulesMessage, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = describeSnapshotSchedulesMessage;

        // create path and map variables
        String localVarPath = "/#Action=DescribeSnapshotSchedules";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (maxRecords != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("MaxRecords", maxRecords));
        }

        if (marker != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("Marker", marker));
        }

        if (action != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("Action", action));
        }

        if (version != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("Version", version));
        }

        if (xAmzContentSha256 != null) {
            localVarHeaderParams.put("X-Amz-Content-Sha256", localVarApiClient.parameterToString(xAmzContentSha256));
        }

        if (xAmzDate != null) {
            localVarHeaderParams.put("X-Amz-Date", localVarApiClient.parameterToString(xAmzDate));
        }

        if (xAmzAlgorithm != null) {
            localVarHeaderParams.put("X-Amz-Algorithm", localVarApiClient.parameterToString(xAmzAlgorithm));
        }

        if (xAmzCredential != null) {
            localVarHeaderParams.put("X-Amz-Credential", localVarApiClient.parameterToString(xAmzCredential));
        }

        if (xAmzSecurityToken != null) {
            localVarHeaderParams.put("X-Amz-Security-Token", localVarApiClient.parameterToString(xAmzSecurityToken));
        }

        if (xAmzSignature != null) {
            localVarHeaderParams.put("X-Amz-Signature", localVarApiClient.parameterToString(xAmzSignature));
        }

        if (xAmzSignedHeaders != null) {
            localVarHeaderParams.put("X-Amz-SignedHeaders", localVarApiClient.parameterToString(xAmzSignedHeaders));
        }

        final String[] localVarAccepts = {
            "text/xml"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            "text/xml"
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "hmac" };
        return localVarApiClient.buildCall(basePath, localVarPath, "POST", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call pOSTDescribeSnapshotSchedulesValidateBeforeCall(String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, String maxRecords, String marker, DescribeSnapshotSchedulesMessage describeSnapshotSchedulesMessage, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'action' is set
        if (action == null) {
            throw new ApiException("Missing the required parameter 'action' when calling pOSTDescribeSnapshotSchedules(Async)");
        }

        // verify the required parameter 'version' is set
        if (version == null) {
            throw new ApiException("Missing the required parameter 'version' when calling pOSTDescribeSnapshotSchedules(Async)");
        }

        return pOSTDescribeSnapshotSchedulesCall(action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, maxRecords, marker, describeSnapshotSchedulesMessage, _callback);

    }

    /**
     * 
     * Returns a list of snapshot schedules. 
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param maxRecords Pagination limit (optional)
     * @param marker Pagination token (optional)
     * @param describeSnapshotSchedulesMessage  (optional)
     * @return DescribeSnapshotSchedulesOutputMessage
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
     </table>
     */
    public DescribeSnapshotSchedulesOutputMessage pOSTDescribeSnapshotSchedules(String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, String maxRecords, String marker, DescribeSnapshotSchedulesMessage describeSnapshotSchedulesMessage) throws ApiException {
        ApiResponse<DescribeSnapshotSchedulesOutputMessage> localVarResp = pOSTDescribeSnapshotSchedulesWithHttpInfo(action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, maxRecords, marker, describeSnapshotSchedulesMessage);
        return localVarResp.getData();
    }

    /**
     * 
     * Returns a list of snapshot schedules. 
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param maxRecords Pagination limit (optional)
     * @param marker Pagination token (optional)
     * @param describeSnapshotSchedulesMessage  (optional)
     * @return ApiResponse&lt;DescribeSnapshotSchedulesOutputMessage&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<DescribeSnapshotSchedulesOutputMessage> pOSTDescribeSnapshotSchedulesWithHttpInfo(String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, String maxRecords, String marker, DescribeSnapshotSchedulesMessage describeSnapshotSchedulesMessage) throws ApiException {
        okhttp3.Call localVarCall = pOSTDescribeSnapshotSchedulesValidateBeforeCall(action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, maxRecords, marker, describeSnapshotSchedulesMessage, null);
        Type localVarReturnType = new TypeToken<DescribeSnapshotSchedulesOutputMessage>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     *  (asynchronously)
     * Returns a list of snapshot schedules. 
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param maxRecords Pagination limit (optional)
     * @param marker Pagination token (optional)
     * @param describeSnapshotSchedulesMessage  (optional)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call pOSTDescribeSnapshotSchedulesAsync(String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, String maxRecords, String marker, DescribeSnapshotSchedulesMessage describeSnapshotSchedulesMessage, final ApiCallback<DescribeSnapshotSchedulesOutputMessage> _callback) throws ApiException {

        okhttp3.Call localVarCall = pOSTDescribeSnapshotSchedulesValidateBeforeCall(action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, maxRecords, marker, describeSnapshotSchedulesMessage, _callback);
        Type localVarReturnType = new TypeToken<DescribeSnapshotSchedulesOutputMessage>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for pOSTDescribeStorage
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call pOSTDescribeStorageCall(String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/#Action=DescribeStorage";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (action != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("Action", action));
        }

        if (version != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("Version", version));
        }

        if (xAmzContentSha256 != null) {
            localVarHeaderParams.put("X-Amz-Content-Sha256", localVarApiClient.parameterToString(xAmzContentSha256));
        }

        if (xAmzDate != null) {
            localVarHeaderParams.put("X-Amz-Date", localVarApiClient.parameterToString(xAmzDate));
        }

        if (xAmzAlgorithm != null) {
            localVarHeaderParams.put("X-Amz-Algorithm", localVarApiClient.parameterToString(xAmzAlgorithm));
        }

        if (xAmzCredential != null) {
            localVarHeaderParams.put("X-Amz-Credential", localVarApiClient.parameterToString(xAmzCredential));
        }

        if (xAmzSecurityToken != null) {
            localVarHeaderParams.put("X-Amz-Security-Token", localVarApiClient.parameterToString(xAmzSecurityToken));
        }

        if (xAmzSignature != null) {
            localVarHeaderParams.put("X-Amz-Signature", localVarApiClient.parameterToString(xAmzSignature));
        }

        if (xAmzSignedHeaders != null) {
            localVarHeaderParams.put("X-Amz-SignedHeaders", localVarApiClient.parameterToString(xAmzSignedHeaders));
        }

        final String[] localVarAccepts = {
            "text/xml"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "hmac" };
        return localVarApiClient.buildCall(basePath, localVarPath, "POST", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call pOSTDescribeStorageValidateBeforeCall(String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'action' is set
        if (action == null) {
            throw new ApiException("Missing the required parameter 'action' when calling pOSTDescribeStorage(Async)");
        }

        // verify the required parameter 'version' is set
        if (version == null) {
            throw new ApiException("Missing the required parameter 'version' when calling pOSTDescribeStorage(Async)");
        }

        return pOSTDescribeStorageCall(action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, _callback);

    }

    /**
     * 
     * Returns account level backups storage size and provisional storage.
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @return CustomerStorageMessage
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
     </table>
     */
    public CustomerStorageMessage pOSTDescribeStorage(String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders) throws ApiException {
        ApiResponse<CustomerStorageMessage> localVarResp = pOSTDescribeStorageWithHttpInfo(action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders);
        return localVarResp.getData();
    }

    /**
     * 
     * Returns account level backups storage size and provisional storage.
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @return ApiResponse&lt;CustomerStorageMessage&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<CustomerStorageMessage> pOSTDescribeStorageWithHttpInfo(String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders) throws ApiException {
        okhttp3.Call localVarCall = pOSTDescribeStorageValidateBeforeCall(action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, null);
        Type localVarReturnType = new TypeToken<CustomerStorageMessage>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     *  (asynchronously)
     * Returns account level backups storage size and provisional storage.
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call pOSTDescribeStorageAsync(String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, final ApiCallback<CustomerStorageMessage> _callback) throws ApiException {

        okhttp3.Call localVarCall = pOSTDescribeStorageValidateBeforeCall(action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, _callback);
        Type localVarReturnType = new TypeToken<CustomerStorageMessage>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for pOSTDescribeTableRestoreStatus
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param maxRecords Pagination limit (optional)
     * @param marker Pagination token (optional)
     * @param describeTableRestoreStatusMessage  (optional)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> TableRestoreNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> ClusterNotFoundFault </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call pOSTDescribeTableRestoreStatusCall(String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, String maxRecords, String marker, DescribeTableRestoreStatusMessage describeTableRestoreStatusMessage, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = describeTableRestoreStatusMessage;

        // create path and map variables
        String localVarPath = "/#Action=DescribeTableRestoreStatus";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (maxRecords != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("MaxRecords", maxRecords));
        }

        if (marker != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("Marker", marker));
        }

        if (action != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("Action", action));
        }

        if (version != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("Version", version));
        }

        if (xAmzContentSha256 != null) {
            localVarHeaderParams.put("X-Amz-Content-Sha256", localVarApiClient.parameterToString(xAmzContentSha256));
        }

        if (xAmzDate != null) {
            localVarHeaderParams.put("X-Amz-Date", localVarApiClient.parameterToString(xAmzDate));
        }

        if (xAmzAlgorithm != null) {
            localVarHeaderParams.put("X-Amz-Algorithm", localVarApiClient.parameterToString(xAmzAlgorithm));
        }

        if (xAmzCredential != null) {
            localVarHeaderParams.put("X-Amz-Credential", localVarApiClient.parameterToString(xAmzCredential));
        }

        if (xAmzSecurityToken != null) {
            localVarHeaderParams.put("X-Amz-Security-Token", localVarApiClient.parameterToString(xAmzSecurityToken));
        }

        if (xAmzSignature != null) {
            localVarHeaderParams.put("X-Amz-Signature", localVarApiClient.parameterToString(xAmzSignature));
        }

        if (xAmzSignedHeaders != null) {
            localVarHeaderParams.put("X-Amz-SignedHeaders", localVarApiClient.parameterToString(xAmzSignedHeaders));
        }

        final String[] localVarAccepts = {
            "text/xml"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            "text/xml"
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "hmac" };
        return localVarApiClient.buildCall(basePath, localVarPath, "POST", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call pOSTDescribeTableRestoreStatusValidateBeforeCall(String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, String maxRecords, String marker, DescribeTableRestoreStatusMessage describeTableRestoreStatusMessage, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'action' is set
        if (action == null) {
            throw new ApiException("Missing the required parameter 'action' when calling pOSTDescribeTableRestoreStatus(Async)");
        }

        // verify the required parameter 'version' is set
        if (version == null) {
            throw new ApiException("Missing the required parameter 'version' when calling pOSTDescribeTableRestoreStatus(Async)");
        }

        return pOSTDescribeTableRestoreStatusCall(action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, maxRecords, marker, describeTableRestoreStatusMessage, _callback);

    }

    /**
     * 
     * Lists the status of one or more table restore requests made using the &lt;a&gt;RestoreTableFromClusterSnapshot&lt;/a&gt; API action. If you don&#39;t specify a value for the &lt;code&gt;TableRestoreRequestId&lt;/code&gt; parameter, then &lt;code&gt;DescribeTableRestoreStatus&lt;/code&gt; returns the status of all table restore requests ordered by the date and time of the request in ascending order. Otherwise &lt;code&gt;DescribeTableRestoreStatus&lt;/code&gt; returns the status of the table specified by &lt;code&gt;TableRestoreRequestId&lt;/code&gt;.
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param maxRecords Pagination limit (optional)
     * @param marker Pagination token (optional)
     * @param describeTableRestoreStatusMessage  (optional)
     * @return TableRestoreStatusMessage
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> TableRestoreNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> ClusterNotFoundFault </td><td>  -  </td></tr>
     </table>
     */
    public TableRestoreStatusMessage pOSTDescribeTableRestoreStatus(String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, String maxRecords, String marker, DescribeTableRestoreStatusMessage describeTableRestoreStatusMessage) throws ApiException {
        ApiResponse<TableRestoreStatusMessage> localVarResp = pOSTDescribeTableRestoreStatusWithHttpInfo(action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, maxRecords, marker, describeTableRestoreStatusMessage);
        return localVarResp.getData();
    }

    /**
     * 
     * Lists the status of one or more table restore requests made using the &lt;a&gt;RestoreTableFromClusterSnapshot&lt;/a&gt; API action. If you don&#39;t specify a value for the &lt;code&gt;TableRestoreRequestId&lt;/code&gt; parameter, then &lt;code&gt;DescribeTableRestoreStatus&lt;/code&gt; returns the status of all table restore requests ordered by the date and time of the request in ascending order. Otherwise &lt;code&gt;DescribeTableRestoreStatus&lt;/code&gt; returns the status of the table specified by &lt;code&gt;TableRestoreRequestId&lt;/code&gt;.
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param maxRecords Pagination limit (optional)
     * @param marker Pagination token (optional)
     * @param describeTableRestoreStatusMessage  (optional)
     * @return ApiResponse&lt;TableRestoreStatusMessage&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> TableRestoreNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> ClusterNotFoundFault </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<TableRestoreStatusMessage> pOSTDescribeTableRestoreStatusWithHttpInfo(String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, String maxRecords, String marker, DescribeTableRestoreStatusMessage describeTableRestoreStatusMessage) throws ApiException {
        okhttp3.Call localVarCall = pOSTDescribeTableRestoreStatusValidateBeforeCall(action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, maxRecords, marker, describeTableRestoreStatusMessage, null);
        Type localVarReturnType = new TypeToken<TableRestoreStatusMessage>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     *  (asynchronously)
     * Lists the status of one or more table restore requests made using the &lt;a&gt;RestoreTableFromClusterSnapshot&lt;/a&gt; API action. If you don&#39;t specify a value for the &lt;code&gt;TableRestoreRequestId&lt;/code&gt; parameter, then &lt;code&gt;DescribeTableRestoreStatus&lt;/code&gt; returns the status of all table restore requests ordered by the date and time of the request in ascending order. Otherwise &lt;code&gt;DescribeTableRestoreStatus&lt;/code&gt; returns the status of the table specified by &lt;code&gt;TableRestoreRequestId&lt;/code&gt;.
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param maxRecords Pagination limit (optional)
     * @param marker Pagination token (optional)
     * @param describeTableRestoreStatusMessage  (optional)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> TableRestoreNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> ClusterNotFoundFault </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call pOSTDescribeTableRestoreStatusAsync(String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, String maxRecords, String marker, DescribeTableRestoreStatusMessage describeTableRestoreStatusMessage, final ApiCallback<TableRestoreStatusMessage> _callback) throws ApiException {

        okhttp3.Call localVarCall = pOSTDescribeTableRestoreStatusValidateBeforeCall(action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, maxRecords, marker, describeTableRestoreStatusMessage, _callback);
        Type localVarReturnType = new TypeToken<TableRestoreStatusMessage>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for pOSTDescribeTags
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param maxRecords Pagination limit (optional)
     * @param marker Pagination token (optional)
     * @param describeTagsMessage  (optional)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> ResourceNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> InvalidTagFault </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call pOSTDescribeTagsCall(String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, String maxRecords, String marker, DescribeTagsMessage describeTagsMessage, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = describeTagsMessage;

        // create path and map variables
        String localVarPath = "/#Action=DescribeTags";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (maxRecords != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("MaxRecords", maxRecords));
        }

        if (marker != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("Marker", marker));
        }

        if (action != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("Action", action));
        }

        if (version != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("Version", version));
        }

        if (xAmzContentSha256 != null) {
            localVarHeaderParams.put("X-Amz-Content-Sha256", localVarApiClient.parameterToString(xAmzContentSha256));
        }

        if (xAmzDate != null) {
            localVarHeaderParams.put("X-Amz-Date", localVarApiClient.parameterToString(xAmzDate));
        }

        if (xAmzAlgorithm != null) {
            localVarHeaderParams.put("X-Amz-Algorithm", localVarApiClient.parameterToString(xAmzAlgorithm));
        }

        if (xAmzCredential != null) {
            localVarHeaderParams.put("X-Amz-Credential", localVarApiClient.parameterToString(xAmzCredential));
        }

        if (xAmzSecurityToken != null) {
            localVarHeaderParams.put("X-Amz-Security-Token", localVarApiClient.parameterToString(xAmzSecurityToken));
        }

        if (xAmzSignature != null) {
            localVarHeaderParams.put("X-Amz-Signature", localVarApiClient.parameterToString(xAmzSignature));
        }

        if (xAmzSignedHeaders != null) {
            localVarHeaderParams.put("X-Amz-SignedHeaders", localVarApiClient.parameterToString(xAmzSignedHeaders));
        }

        final String[] localVarAccepts = {
            "text/xml"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            "text/xml"
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "hmac" };
        return localVarApiClient.buildCall(basePath, localVarPath, "POST", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call pOSTDescribeTagsValidateBeforeCall(String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, String maxRecords, String marker, DescribeTagsMessage describeTagsMessage, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'action' is set
        if (action == null) {
            throw new ApiException("Missing the required parameter 'action' when calling pOSTDescribeTags(Async)");
        }

        // verify the required parameter 'version' is set
        if (version == null) {
            throw new ApiException("Missing the required parameter 'version' when calling pOSTDescribeTags(Async)");
        }

        return pOSTDescribeTagsCall(action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, maxRecords, marker, describeTagsMessage, _callback);

    }

    /**
     * 
     * &lt;p&gt;Returns a list of tags. You can return tags from a specific resource by specifying an ARN, or you can return all tags for a given type of resource, such as clusters, snapshots, and so on.&lt;/p&gt; &lt;p&gt;The following are limitations for &lt;code&gt;DescribeTags&lt;/code&gt;: &lt;/p&gt; &lt;ul&gt; &lt;li&gt; &lt;p&gt;You cannot specify an ARN and a resource-type value together in the same request.&lt;/p&gt; &lt;/li&gt; &lt;li&gt; &lt;p&gt;You cannot use the &lt;code&gt;MaxRecords&lt;/code&gt; and &lt;code&gt;Marker&lt;/code&gt; parameters together with the ARN parameter.&lt;/p&gt; &lt;/li&gt; &lt;li&gt; &lt;p&gt;The &lt;code&gt;MaxRecords&lt;/code&gt; parameter can be a range from 10 to 50 results to return in a request.&lt;/p&gt; &lt;/li&gt; &lt;/ul&gt; &lt;p&gt;If you specify both tag keys and tag values in the same request, Amazon Redshift returns all resources that match any combination of the specified keys and values. For example, if you have &lt;code&gt;owner&lt;/code&gt; and &lt;code&gt;environment&lt;/code&gt; for tag keys, and &lt;code&gt;admin&lt;/code&gt; and &lt;code&gt;test&lt;/code&gt; for tag values, all resources that have any combination of those values are returned.&lt;/p&gt; &lt;p&gt;If both tag keys and values are omitted from the request, resources are returned regardless of whether they have tag keys or values associated with them.&lt;/p&gt;
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param maxRecords Pagination limit (optional)
     * @param marker Pagination token (optional)
     * @param describeTagsMessage  (optional)
     * @return TaggedResourceListMessage
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> ResourceNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> InvalidTagFault </td><td>  -  </td></tr>
     </table>
     */
    public TaggedResourceListMessage pOSTDescribeTags(String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, String maxRecords, String marker, DescribeTagsMessage describeTagsMessage) throws ApiException {
        ApiResponse<TaggedResourceListMessage> localVarResp = pOSTDescribeTagsWithHttpInfo(action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, maxRecords, marker, describeTagsMessage);
        return localVarResp.getData();
    }

    /**
     * 
     * &lt;p&gt;Returns a list of tags. You can return tags from a specific resource by specifying an ARN, or you can return all tags for a given type of resource, such as clusters, snapshots, and so on.&lt;/p&gt; &lt;p&gt;The following are limitations for &lt;code&gt;DescribeTags&lt;/code&gt;: &lt;/p&gt; &lt;ul&gt; &lt;li&gt; &lt;p&gt;You cannot specify an ARN and a resource-type value together in the same request.&lt;/p&gt; &lt;/li&gt; &lt;li&gt; &lt;p&gt;You cannot use the &lt;code&gt;MaxRecords&lt;/code&gt; and &lt;code&gt;Marker&lt;/code&gt; parameters together with the ARN parameter.&lt;/p&gt; &lt;/li&gt; &lt;li&gt; &lt;p&gt;The &lt;code&gt;MaxRecords&lt;/code&gt; parameter can be a range from 10 to 50 results to return in a request.&lt;/p&gt; &lt;/li&gt; &lt;/ul&gt; &lt;p&gt;If you specify both tag keys and tag values in the same request, Amazon Redshift returns all resources that match any combination of the specified keys and values. For example, if you have &lt;code&gt;owner&lt;/code&gt; and &lt;code&gt;environment&lt;/code&gt; for tag keys, and &lt;code&gt;admin&lt;/code&gt; and &lt;code&gt;test&lt;/code&gt; for tag values, all resources that have any combination of those values are returned.&lt;/p&gt; &lt;p&gt;If both tag keys and values are omitted from the request, resources are returned regardless of whether they have tag keys or values associated with them.&lt;/p&gt;
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param maxRecords Pagination limit (optional)
     * @param marker Pagination token (optional)
     * @param describeTagsMessage  (optional)
     * @return ApiResponse&lt;TaggedResourceListMessage&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> ResourceNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> InvalidTagFault </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<TaggedResourceListMessage> pOSTDescribeTagsWithHttpInfo(String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, String maxRecords, String marker, DescribeTagsMessage describeTagsMessage) throws ApiException {
        okhttp3.Call localVarCall = pOSTDescribeTagsValidateBeforeCall(action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, maxRecords, marker, describeTagsMessage, null);
        Type localVarReturnType = new TypeToken<TaggedResourceListMessage>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     *  (asynchronously)
     * &lt;p&gt;Returns a list of tags. You can return tags from a specific resource by specifying an ARN, or you can return all tags for a given type of resource, such as clusters, snapshots, and so on.&lt;/p&gt; &lt;p&gt;The following are limitations for &lt;code&gt;DescribeTags&lt;/code&gt;: &lt;/p&gt; &lt;ul&gt; &lt;li&gt; &lt;p&gt;You cannot specify an ARN and a resource-type value together in the same request.&lt;/p&gt; &lt;/li&gt; &lt;li&gt; &lt;p&gt;You cannot use the &lt;code&gt;MaxRecords&lt;/code&gt; and &lt;code&gt;Marker&lt;/code&gt; parameters together with the ARN parameter.&lt;/p&gt; &lt;/li&gt; &lt;li&gt; &lt;p&gt;The &lt;code&gt;MaxRecords&lt;/code&gt; parameter can be a range from 10 to 50 results to return in a request.&lt;/p&gt; &lt;/li&gt; &lt;/ul&gt; &lt;p&gt;If you specify both tag keys and tag values in the same request, Amazon Redshift returns all resources that match any combination of the specified keys and values. For example, if you have &lt;code&gt;owner&lt;/code&gt; and &lt;code&gt;environment&lt;/code&gt; for tag keys, and &lt;code&gt;admin&lt;/code&gt; and &lt;code&gt;test&lt;/code&gt; for tag values, all resources that have any combination of those values are returned.&lt;/p&gt; &lt;p&gt;If both tag keys and values are omitted from the request, resources are returned regardless of whether they have tag keys or values associated with them.&lt;/p&gt;
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param maxRecords Pagination limit (optional)
     * @param marker Pagination token (optional)
     * @param describeTagsMessage  (optional)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> ResourceNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> InvalidTagFault </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call pOSTDescribeTagsAsync(String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, String maxRecords, String marker, DescribeTagsMessage describeTagsMessage, final ApiCallback<TaggedResourceListMessage> _callback) throws ApiException {

        okhttp3.Call localVarCall = pOSTDescribeTagsValidateBeforeCall(action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, maxRecords, marker, describeTagsMessage, _callback);
        Type localVarReturnType = new TypeToken<TaggedResourceListMessage>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for pOSTDescribeUsageLimits
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param maxRecords Pagination limit (optional)
     * @param marker Pagination token (optional)
     * @param describeUsageLimitsMessage  (optional)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> ClusterNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> UnsupportedOperationFault </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call pOSTDescribeUsageLimitsCall(String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, String maxRecords, String marker, DescribeUsageLimitsMessage describeUsageLimitsMessage, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = describeUsageLimitsMessage;

        // create path and map variables
        String localVarPath = "/#Action=DescribeUsageLimits";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (maxRecords != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("MaxRecords", maxRecords));
        }

        if (marker != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("Marker", marker));
        }

        if (action != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("Action", action));
        }

        if (version != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("Version", version));
        }

        if (xAmzContentSha256 != null) {
            localVarHeaderParams.put("X-Amz-Content-Sha256", localVarApiClient.parameterToString(xAmzContentSha256));
        }

        if (xAmzDate != null) {
            localVarHeaderParams.put("X-Amz-Date", localVarApiClient.parameterToString(xAmzDate));
        }

        if (xAmzAlgorithm != null) {
            localVarHeaderParams.put("X-Amz-Algorithm", localVarApiClient.parameterToString(xAmzAlgorithm));
        }

        if (xAmzCredential != null) {
            localVarHeaderParams.put("X-Amz-Credential", localVarApiClient.parameterToString(xAmzCredential));
        }

        if (xAmzSecurityToken != null) {
            localVarHeaderParams.put("X-Amz-Security-Token", localVarApiClient.parameterToString(xAmzSecurityToken));
        }

        if (xAmzSignature != null) {
            localVarHeaderParams.put("X-Amz-Signature", localVarApiClient.parameterToString(xAmzSignature));
        }

        if (xAmzSignedHeaders != null) {
            localVarHeaderParams.put("X-Amz-SignedHeaders", localVarApiClient.parameterToString(xAmzSignedHeaders));
        }

        final String[] localVarAccepts = {
            "text/xml"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            "text/xml"
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "hmac" };
        return localVarApiClient.buildCall(basePath, localVarPath, "POST", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call pOSTDescribeUsageLimitsValidateBeforeCall(String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, String maxRecords, String marker, DescribeUsageLimitsMessage describeUsageLimitsMessage, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'action' is set
        if (action == null) {
            throw new ApiException("Missing the required parameter 'action' when calling pOSTDescribeUsageLimits(Async)");
        }

        // verify the required parameter 'version' is set
        if (version == null) {
            throw new ApiException("Missing the required parameter 'version' when calling pOSTDescribeUsageLimits(Async)");
        }

        return pOSTDescribeUsageLimitsCall(action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, maxRecords, marker, describeUsageLimitsMessage, _callback);

    }

    /**
     * 
     * &lt;p&gt;Shows usage limits on a cluster. Results are filtered based on the combination of input usage limit identifier, cluster identifier, and feature type parameters:&lt;/p&gt; &lt;ul&gt; &lt;li&gt; &lt;p&gt;If usage limit identifier, cluster identifier, and feature type are not provided, then all usage limit objects for the current account in the current region are returned.&lt;/p&gt; &lt;/li&gt; &lt;li&gt; &lt;p&gt;If usage limit identifier is provided, then the corresponding usage limit object is returned.&lt;/p&gt; &lt;/li&gt; &lt;li&gt; &lt;p&gt;If cluster identifier is provided, then all usage limit objects for the specified cluster are returned.&lt;/p&gt; &lt;/li&gt; &lt;li&gt; &lt;p&gt;If cluster identifier and feature type are provided, then all usage limit objects for the combination of cluster and feature are returned.&lt;/p&gt; &lt;/li&gt; &lt;/ul&gt;
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param maxRecords Pagination limit (optional)
     * @param marker Pagination token (optional)
     * @param describeUsageLimitsMessage  (optional)
     * @return UsageLimitList
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> ClusterNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> UnsupportedOperationFault </td><td>  -  </td></tr>
     </table>
     */
    public UsageLimitList pOSTDescribeUsageLimits(String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, String maxRecords, String marker, DescribeUsageLimitsMessage describeUsageLimitsMessage) throws ApiException {
        ApiResponse<UsageLimitList> localVarResp = pOSTDescribeUsageLimitsWithHttpInfo(action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, maxRecords, marker, describeUsageLimitsMessage);
        return localVarResp.getData();
    }

    /**
     * 
     * &lt;p&gt;Shows usage limits on a cluster. Results are filtered based on the combination of input usage limit identifier, cluster identifier, and feature type parameters:&lt;/p&gt; &lt;ul&gt; &lt;li&gt; &lt;p&gt;If usage limit identifier, cluster identifier, and feature type are not provided, then all usage limit objects for the current account in the current region are returned.&lt;/p&gt; &lt;/li&gt; &lt;li&gt; &lt;p&gt;If usage limit identifier is provided, then the corresponding usage limit object is returned.&lt;/p&gt; &lt;/li&gt; &lt;li&gt; &lt;p&gt;If cluster identifier is provided, then all usage limit objects for the specified cluster are returned.&lt;/p&gt; &lt;/li&gt; &lt;li&gt; &lt;p&gt;If cluster identifier and feature type are provided, then all usage limit objects for the combination of cluster and feature are returned.&lt;/p&gt; &lt;/li&gt; &lt;/ul&gt;
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param maxRecords Pagination limit (optional)
     * @param marker Pagination token (optional)
     * @param describeUsageLimitsMessage  (optional)
     * @return ApiResponse&lt;UsageLimitList&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> ClusterNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> UnsupportedOperationFault </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<UsageLimitList> pOSTDescribeUsageLimitsWithHttpInfo(String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, String maxRecords, String marker, DescribeUsageLimitsMessage describeUsageLimitsMessage) throws ApiException {
        okhttp3.Call localVarCall = pOSTDescribeUsageLimitsValidateBeforeCall(action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, maxRecords, marker, describeUsageLimitsMessage, null);
        Type localVarReturnType = new TypeToken<UsageLimitList>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     *  (asynchronously)
     * &lt;p&gt;Shows usage limits on a cluster. Results are filtered based on the combination of input usage limit identifier, cluster identifier, and feature type parameters:&lt;/p&gt; &lt;ul&gt; &lt;li&gt; &lt;p&gt;If usage limit identifier, cluster identifier, and feature type are not provided, then all usage limit objects for the current account in the current region are returned.&lt;/p&gt; &lt;/li&gt; &lt;li&gt; &lt;p&gt;If usage limit identifier is provided, then the corresponding usage limit object is returned.&lt;/p&gt; &lt;/li&gt; &lt;li&gt; &lt;p&gt;If cluster identifier is provided, then all usage limit objects for the specified cluster are returned.&lt;/p&gt; &lt;/li&gt; &lt;li&gt; &lt;p&gt;If cluster identifier and feature type are provided, then all usage limit objects for the combination of cluster and feature are returned.&lt;/p&gt; &lt;/li&gt; &lt;/ul&gt;
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param maxRecords Pagination limit (optional)
     * @param marker Pagination token (optional)
     * @param describeUsageLimitsMessage  (optional)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> ClusterNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> UnsupportedOperationFault </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call pOSTDescribeUsageLimitsAsync(String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, String maxRecords, String marker, DescribeUsageLimitsMessage describeUsageLimitsMessage, final ApiCallback<UsageLimitList> _callback) throws ApiException {

        okhttp3.Call localVarCall = pOSTDescribeUsageLimitsValidateBeforeCall(action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, maxRecords, marker, describeUsageLimitsMessage, _callback);
        Type localVarReturnType = new TypeToken<UsageLimitList>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for pOSTDisableLogging
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param disableLoggingMessage  (optional)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> ClusterNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> InvalidClusterStateFault </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call pOSTDisableLoggingCall(String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, DisableLoggingMessage disableLoggingMessage, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = disableLoggingMessage;

        // create path and map variables
        String localVarPath = "/#Action=DisableLogging";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (action != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("Action", action));
        }

        if (version != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("Version", version));
        }

        if (xAmzContentSha256 != null) {
            localVarHeaderParams.put("X-Amz-Content-Sha256", localVarApiClient.parameterToString(xAmzContentSha256));
        }

        if (xAmzDate != null) {
            localVarHeaderParams.put("X-Amz-Date", localVarApiClient.parameterToString(xAmzDate));
        }

        if (xAmzAlgorithm != null) {
            localVarHeaderParams.put("X-Amz-Algorithm", localVarApiClient.parameterToString(xAmzAlgorithm));
        }

        if (xAmzCredential != null) {
            localVarHeaderParams.put("X-Amz-Credential", localVarApiClient.parameterToString(xAmzCredential));
        }

        if (xAmzSecurityToken != null) {
            localVarHeaderParams.put("X-Amz-Security-Token", localVarApiClient.parameterToString(xAmzSecurityToken));
        }

        if (xAmzSignature != null) {
            localVarHeaderParams.put("X-Amz-Signature", localVarApiClient.parameterToString(xAmzSignature));
        }

        if (xAmzSignedHeaders != null) {
            localVarHeaderParams.put("X-Amz-SignedHeaders", localVarApiClient.parameterToString(xAmzSignedHeaders));
        }

        final String[] localVarAccepts = {
            "text/xml"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            "text/xml"
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "hmac" };
        return localVarApiClient.buildCall(basePath, localVarPath, "POST", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call pOSTDisableLoggingValidateBeforeCall(String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, DisableLoggingMessage disableLoggingMessage, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'action' is set
        if (action == null) {
            throw new ApiException("Missing the required parameter 'action' when calling pOSTDisableLogging(Async)");
        }

        // verify the required parameter 'version' is set
        if (version == null) {
            throw new ApiException("Missing the required parameter 'version' when calling pOSTDisableLogging(Async)");
        }

        return pOSTDisableLoggingCall(action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, disableLoggingMessage, _callback);

    }

    /**
     * 
     * Stops logging information, such as queries and connection attempts, for the specified Amazon Redshift cluster.
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param disableLoggingMessage  (optional)
     * @return LoggingStatus
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> ClusterNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> InvalidClusterStateFault </td><td>  -  </td></tr>
     </table>
     */
    public LoggingStatus pOSTDisableLogging(String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, DisableLoggingMessage disableLoggingMessage) throws ApiException {
        ApiResponse<LoggingStatus> localVarResp = pOSTDisableLoggingWithHttpInfo(action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, disableLoggingMessage);
        return localVarResp.getData();
    }

    /**
     * 
     * Stops logging information, such as queries and connection attempts, for the specified Amazon Redshift cluster.
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param disableLoggingMessage  (optional)
     * @return ApiResponse&lt;LoggingStatus&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> ClusterNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> InvalidClusterStateFault </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<LoggingStatus> pOSTDisableLoggingWithHttpInfo(String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, DisableLoggingMessage disableLoggingMessage) throws ApiException {
        okhttp3.Call localVarCall = pOSTDisableLoggingValidateBeforeCall(action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, disableLoggingMessage, null);
        Type localVarReturnType = new TypeToken<LoggingStatus>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     *  (asynchronously)
     * Stops logging information, such as queries and connection attempts, for the specified Amazon Redshift cluster.
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param disableLoggingMessage  (optional)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> ClusterNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> InvalidClusterStateFault </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call pOSTDisableLoggingAsync(String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, DisableLoggingMessage disableLoggingMessage, final ApiCallback<LoggingStatus> _callback) throws ApiException {

        okhttp3.Call localVarCall = pOSTDisableLoggingValidateBeforeCall(action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, disableLoggingMessage, _callback);
        Type localVarReturnType = new TypeToken<LoggingStatus>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for pOSTDisableSnapshotCopy
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param disableSnapshotCopyMessage  (optional)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> ClusterNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> SnapshotCopyAlreadyDisabledFault </td><td>  -  </td></tr>
        <tr><td> 482 </td><td> InvalidClusterStateFault </td><td>  -  </td></tr>
        <tr><td> 483 </td><td> UnauthorizedOperation </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call pOSTDisableSnapshotCopyCall(String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, DisableSnapshotCopyMessage disableSnapshotCopyMessage, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = disableSnapshotCopyMessage;

        // create path and map variables
        String localVarPath = "/#Action=DisableSnapshotCopy";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (action != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("Action", action));
        }

        if (version != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("Version", version));
        }

        if (xAmzContentSha256 != null) {
            localVarHeaderParams.put("X-Amz-Content-Sha256", localVarApiClient.parameterToString(xAmzContentSha256));
        }

        if (xAmzDate != null) {
            localVarHeaderParams.put("X-Amz-Date", localVarApiClient.parameterToString(xAmzDate));
        }

        if (xAmzAlgorithm != null) {
            localVarHeaderParams.put("X-Amz-Algorithm", localVarApiClient.parameterToString(xAmzAlgorithm));
        }

        if (xAmzCredential != null) {
            localVarHeaderParams.put("X-Amz-Credential", localVarApiClient.parameterToString(xAmzCredential));
        }

        if (xAmzSecurityToken != null) {
            localVarHeaderParams.put("X-Amz-Security-Token", localVarApiClient.parameterToString(xAmzSecurityToken));
        }

        if (xAmzSignature != null) {
            localVarHeaderParams.put("X-Amz-Signature", localVarApiClient.parameterToString(xAmzSignature));
        }

        if (xAmzSignedHeaders != null) {
            localVarHeaderParams.put("X-Amz-SignedHeaders", localVarApiClient.parameterToString(xAmzSignedHeaders));
        }

        final String[] localVarAccepts = {
            "text/xml"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            "text/xml"
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "hmac" };
        return localVarApiClient.buildCall(basePath, localVarPath, "POST", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call pOSTDisableSnapshotCopyValidateBeforeCall(String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, DisableSnapshotCopyMessage disableSnapshotCopyMessage, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'action' is set
        if (action == null) {
            throw new ApiException("Missing the required parameter 'action' when calling pOSTDisableSnapshotCopy(Async)");
        }

        // verify the required parameter 'version' is set
        if (version == null) {
            throw new ApiException("Missing the required parameter 'version' when calling pOSTDisableSnapshotCopy(Async)");
        }

        return pOSTDisableSnapshotCopyCall(action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, disableSnapshotCopyMessage, _callback);

    }

    /**
     * 
     * &lt;p&gt;Disables the automatic copying of snapshots from one region to another region for a specified cluster.&lt;/p&gt; &lt;p&gt;If your cluster and its snapshots are encrypted using an encrypted symmetric key from Key Management Service, use &lt;a&gt;DeleteSnapshotCopyGrant&lt;/a&gt; to delete the grant that grants Amazon Redshift permission to the key in the destination region. &lt;/p&gt;
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param disableSnapshotCopyMessage  (optional)
     * @return DisableSnapshotCopyResult
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> ClusterNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> SnapshotCopyAlreadyDisabledFault </td><td>  -  </td></tr>
        <tr><td> 482 </td><td> InvalidClusterStateFault </td><td>  -  </td></tr>
        <tr><td> 483 </td><td> UnauthorizedOperation </td><td>  -  </td></tr>
     </table>
     */
    public DisableSnapshotCopyResult pOSTDisableSnapshotCopy(String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, DisableSnapshotCopyMessage disableSnapshotCopyMessage) throws ApiException {
        ApiResponse<DisableSnapshotCopyResult> localVarResp = pOSTDisableSnapshotCopyWithHttpInfo(action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, disableSnapshotCopyMessage);
        return localVarResp.getData();
    }

    /**
     * 
     * &lt;p&gt;Disables the automatic copying of snapshots from one region to another region for a specified cluster.&lt;/p&gt; &lt;p&gt;If your cluster and its snapshots are encrypted using an encrypted symmetric key from Key Management Service, use &lt;a&gt;DeleteSnapshotCopyGrant&lt;/a&gt; to delete the grant that grants Amazon Redshift permission to the key in the destination region. &lt;/p&gt;
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param disableSnapshotCopyMessage  (optional)
     * @return ApiResponse&lt;DisableSnapshotCopyResult&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> ClusterNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> SnapshotCopyAlreadyDisabledFault </td><td>  -  </td></tr>
        <tr><td> 482 </td><td> InvalidClusterStateFault </td><td>  -  </td></tr>
        <tr><td> 483 </td><td> UnauthorizedOperation </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<DisableSnapshotCopyResult> pOSTDisableSnapshotCopyWithHttpInfo(String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, DisableSnapshotCopyMessage disableSnapshotCopyMessage) throws ApiException {
        okhttp3.Call localVarCall = pOSTDisableSnapshotCopyValidateBeforeCall(action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, disableSnapshotCopyMessage, null);
        Type localVarReturnType = new TypeToken<DisableSnapshotCopyResult>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     *  (asynchronously)
     * &lt;p&gt;Disables the automatic copying of snapshots from one region to another region for a specified cluster.&lt;/p&gt; &lt;p&gt;If your cluster and its snapshots are encrypted using an encrypted symmetric key from Key Management Service, use &lt;a&gt;DeleteSnapshotCopyGrant&lt;/a&gt; to delete the grant that grants Amazon Redshift permission to the key in the destination region. &lt;/p&gt;
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param disableSnapshotCopyMessage  (optional)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> ClusterNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> SnapshotCopyAlreadyDisabledFault </td><td>  -  </td></tr>
        <tr><td> 482 </td><td> InvalidClusterStateFault </td><td>  -  </td></tr>
        <tr><td> 483 </td><td> UnauthorizedOperation </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call pOSTDisableSnapshotCopyAsync(String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, DisableSnapshotCopyMessage disableSnapshotCopyMessage, final ApiCallback<DisableSnapshotCopyResult> _callback) throws ApiException {

        okhttp3.Call localVarCall = pOSTDisableSnapshotCopyValidateBeforeCall(action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, disableSnapshotCopyMessage, _callback);
        Type localVarReturnType = new TypeToken<DisableSnapshotCopyResult>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for pOSTDisassociateDataShareConsumer
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param disassociateDataShareConsumerMessage  (optional)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> InvalidDataShareFault </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> InvalidNamespaceFault </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call pOSTDisassociateDataShareConsumerCall(String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, DisassociateDataShareConsumerMessage disassociateDataShareConsumerMessage, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = disassociateDataShareConsumerMessage;

        // create path and map variables
        String localVarPath = "/#Action=DisassociateDataShareConsumer";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (action != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("Action", action));
        }

        if (version != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("Version", version));
        }

        if (xAmzContentSha256 != null) {
            localVarHeaderParams.put("X-Amz-Content-Sha256", localVarApiClient.parameterToString(xAmzContentSha256));
        }

        if (xAmzDate != null) {
            localVarHeaderParams.put("X-Amz-Date", localVarApiClient.parameterToString(xAmzDate));
        }

        if (xAmzAlgorithm != null) {
            localVarHeaderParams.put("X-Amz-Algorithm", localVarApiClient.parameterToString(xAmzAlgorithm));
        }

        if (xAmzCredential != null) {
            localVarHeaderParams.put("X-Amz-Credential", localVarApiClient.parameterToString(xAmzCredential));
        }

        if (xAmzSecurityToken != null) {
            localVarHeaderParams.put("X-Amz-Security-Token", localVarApiClient.parameterToString(xAmzSecurityToken));
        }

        if (xAmzSignature != null) {
            localVarHeaderParams.put("X-Amz-Signature", localVarApiClient.parameterToString(xAmzSignature));
        }

        if (xAmzSignedHeaders != null) {
            localVarHeaderParams.put("X-Amz-SignedHeaders", localVarApiClient.parameterToString(xAmzSignedHeaders));
        }

        final String[] localVarAccepts = {
            "text/xml"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            "text/xml"
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "hmac" };
        return localVarApiClient.buildCall(basePath, localVarPath, "POST", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call pOSTDisassociateDataShareConsumerValidateBeforeCall(String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, DisassociateDataShareConsumerMessage disassociateDataShareConsumerMessage, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'action' is set
        if (action == null) {
            throw new ApiException("Missing the required parameter 'action' when calling pOSTDisassociateDataShareConsumer(Async)");
        }

        // verify the required parameter 'version' is set
        if (version == null) {
            throw new ApiException("Missing the required parameter 'version' when calling pOSTDisassociateDataShareConsumer(Async)");
        }

        return pOSTDisassociateDataShareConsumerCall(action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, disassociateDataShareConsumerMessage, _callback);

    }

    /**
     * 
     * From a datashare consumer account, remove association for the specified datashare. 
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param disassociateDataShareConsumerMessage  (optional)
     * @return DataShare
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> InvalidDataShareFault </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> InvalidNamespaceFault </td><td>  -  </td></tr>
     </table>
     */
    public DataShare pOSTDisassociateDataShareConsumer(String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, DisassociateDataShareConsumerMessage disassociateDataShareConsumerMessage) throws ApiException {
        ApiResponse<DataShare> localVarResp = pOSTDisassociateDataShareConsumerWithHttpInfo(action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, disassociateDataShareConsumerMessage);
        return localVarResp.getData();
    }

    /**
     * 
     * From a datashare consumer account, remove association for the specified datashare. 
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param disassociateDataShareConsumerMessage  (optional)
     * @return ApiResponse&lt;DataShare&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> InvalidDataShareFault </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> InvalidNamespaceFault </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<DataShare> pOSTDisassociateDataShareConsumerWithHttpInfo(String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, DisassociateDataShareConsumerMessage disassociateDataShareConsumerMessage) throws ApiException {
        okhttp3.Call localVarCall = pOSTDisassociateDataShareConsumerValidateBeforeCall(action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, disassociateDataShareConsumerMessage, null);
        Type localVarReturnType = new TypeToken<DataShare>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     *  (asynchronously)
     * From a datashare consumer account, remove association for the specified datashare. 
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param disassociateDataShareConsumerMessage  (optional)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> InvalidDataShareFault </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> InvalidNamespaceFault </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call pOSTDisassociateDataShareConsumerAsync(String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, DisassociateDataShareConsumerMessage disassociateDataShareConsumerMessage, final ApiCallback<DataShare> _callback) throws ApiException {

        okhttp3.Call localVarCall = pOSTDisassociateDataShareConsumerValidateBeforeCall(action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, disassociateDataShareConsumerMessage, _callback);
        Type localVarReturnType = new TypeToken<DataShare>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for pOSTEnableLogging
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param enableLoggingMessage  (optional)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> ClusterNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> BucketNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 482 </td><td> InsufficientS3BucketPolicyFault </td><td>  -  </td></tr>
        <tr><td> 483 </td><td> InvalidS3KeyPrefixFault </td><td>  -  </td></tr>
        <tr><td> 484 </td><td> InvalidS3BucketNameFault </td><td>  -  </td></tr>
        <tr><td> 485 </td><td> InvalidClusterStateFault </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call pOSTEnableLoggingCall(String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, EnableLoggingMessage enableLoggingMessage, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = enableLoggingMessage;

        // create path and map variables
        String localVarPath = "/#Action=EnableLogging";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (action != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("Action", action));
        }

        if (version != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("Version", version));
        }

        if (xAmzContentSha256 != null) {
            localVarHeaderParams.put("X-Amz-Content-Sha256", localVarApiClient.parameterToString(xAmzContentSha256));
        }

        if (xAmzDate != null) {
            localVarHeaderParams.put("X-Amz-Date", localVarApiClient.parameterToString(xAmzDate));
        }

        if (xAmzAlgorithm != null) {
            localVarHeaderParams.put("X-Amz-Algorithm", localVarApiClient.parameterToString(xAmzAlgorithm));
        }

        if (xAmzCredential != null) {
            localVarHeaderParams.put("X-Amz-Credential", localVarApiClient.parameterToString(xAmzCredential));
        }

        if (xAmzSecurityToken != null) {
            localVarHeaderParams.put("X-Amz-Security-Token", localVarApiClient.parameterToString(xAmzSecurityToken));
        }

        if (xAmzSignature != null) {
            localVarHeaderParams.put("X-Amz-Signature", localVarApiClient.parameterToString(xAmzSignature));
        }

        if (xAmzSignedHeaders != null) {
            localVarHeaderParams.put("X-Amz-SignedHeaders", localVarApiClient.parameterToString(xAmzSignedHeaders));
        }

        final String[] localVarAccepts = {
            "text/xml"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            "text/xml"
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "hmac" };
        return localVarApiClient.buildCall(basePath, localVarPath, "POST", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call pOSTEnableLoggingValidateBeforeCall(String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, EnableLoggingMessage enableLoggingMessage, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'action' is set
        if (action == null) {
            throw new ApiException("Missing the required parameter 'action' when calling pOSTEnableLogging(Async)");
        }

        // verify the required parameter 'version' is set
        if (version == null) {
            throw new ApiException("Missing the required parameter 'version' when calling pOSTEnableLogging(Async)");
        }

        return pOSTEnableLoggingCall(action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, enableLoggingMessage, _callback);

    }

    /**
     * 
     * Starts logging information, such as queries and connection attempts, for the specified Amazon Redshift cluster.
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param enableLoggingMessage  (optional)
     * @return LoggingStatus
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> ClusterNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> BucketNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 482 </td><td> InsufficientS3BucketPolicyFault </td><td>  -  </td></tr>
        <tr><td> 483 </td><td> InvalidS3KeyPrefixFault </td><td>  -  </td></tr>
        <tr><td> 484 </td><td> InvalidS3BucketNameFault </td><td>  -  </td></tr>
        <tr><td> 485 </td><td> InvalidClusterStateFault </td><td>  -  </td></tr>
     </table>
     */
    public LoggingStatus pOSTEnableLogging(String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, EnableLoggingMessage enableLoggingMessage) throws ApiException {
        ApiResponse<LoggingStatus> localVarResp = pOSTEnableLoggingWithHttpInfo(action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, enableLoggingMessage);
        return localVarResp.getData();
    }

    /**
     * 
     * Starts logging information, such as queries and connection attempts, for the specified Amazon Redshift cluster.
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param enableLoggingMessage  (optional)
     * @return ApiResponse&lt;LoggingStatus&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> ClusterNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> BucketNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 482 </td><td> InsufficientS3BucketPolicyFault </td><td>  -  </td></tr>
        <tr><td> 483 </td><td> InvalidS3KeyPrefixFault </td><td>  -  </td></tr>
        <tr><td> 484 </td><td> InvalidS3BucketNameFault </td><td>  -  </td></tr>
        <tr><td> 485 </td><td> InvalidClusterStateFault </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<LoggingStatus> pOSTEnableLoggingWithHttpInfo(String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, EnableLoggingMessage enableLoggingMessage) throws ApiException {
        okhttp3.Call localVarCall = pOSTEnableLoggingValidateBeforeCall(action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, enableLoggingMessage, null);
        Type localVarReturnType = new TypeToken<LoggingStatus>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     *  (asynchronously)
     * Starts logging information, such as queries and connection attempts, for the specified Amazon Redshift cluster.
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param enableLoggingMessage  (optional)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> ClusterNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> BucketNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 482 </td><td> InsufficientS3BucketPolicyFault </td><td>  -  </td></tr>
        <tr><td> 483 </td><td> InvalidS3KeyPrefixFault </td><td>  -  </td></tr>
        <tr><td> 484 </td><td> InvalidS3BucketNameFault </td><td>  -  </td></tr>
        <tr><td> 485 </td><td> InvalidClusterStateFault </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call pOSTEnableLoggingAsync(String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, EnableLoggingMessage enableLoggingMessage, final ApiCallback<LoggingStatus> _callback) throws ApiException {

        okhttp3.Call localVarCall = pOSTEnableLoggingValidateBeforeCall(action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, enableLoggingMessage, _callback);
        Type localVarReturnType = new TypeToken<LoggingStatus>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for pOSTEnableSnapshotCopy
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param enableSnapshotCopyMessage  (optional)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> IncompatibleOrderableOptions </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> InvalidClusterStateFault </td><td>  -  </td></tr>
        <tr><td> 482 </td><td> ClusterNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 483 </td><td> CopyToRegionDisabledFault </td><td>  -  </td></tr>
        <tr><td> 484 </td><td> SnapshotCopyAlreadyEnabledFault </td><td>  -  </td></tr>
        <tr><td> 485 </td><td> UnknownSnapshotCopyRegionFault </td><td>  -  </td></tr>
        <tr><td> 486 </td><td> UnauthorizedOperation </td><td>  -  </td></tr>
        <tr><td> 487 </td><td> SnapshotCopyGrantNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 488 </td><td> LimitExceededFault </td><td>  -  </td></tr>
        <tr><td> 489 </td><td> DependentServiceRequestThrottlingFault </td><td>  -  </td></tr>
        <tr><td> 490 </td><td> InvalidRetentionPeriodFault </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call pOSTEnableSnapshotCopyCall(String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, EnableSnapshotCopyMessage enableSnapshotCopyMessage, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = enableSnapshotCopyMessage;

        // create path and map variables
        String localVarPath = "/#Action=EnableSnapshotCopy";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (action != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("Action", action));
        }

        if (version != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("Version", version));
        }

        if (xAmzContentSha256 != null) {
            localVarHeaderParams.put("X-Amz-Content-Sha256", localVarApiClient.parameterToString(xAmzContentSha256));
        }

        if (xAmzDate != null) {
            localVarHeaderParams.put("X-Amz-Date", localVarApiClient.parameterToString(xAmzDate));
        }

        if (xAmzAlgorithm != null) {
            localVarHeaderParams.put("X-Amz-Algorithm", localVarApiClient.parameterToString(xAmzAlgorithm));
        }

        if (xAmzCredential != null) {
            localVarHeaderParams.put("X-Amz-Credential", localVarApiClient.parameterToString(xAmzCredential));
        }

        if (xAmzSecurityToken != null) {
            localVarHeaderParams.put("X-Amz-Security-Token", localVarApiClient.parameterToString(xAmzSecurityToken));
        }

        if (xAmzSignature != null) {
            localVarHeaderParams.put("X-Amz-Signature", localVarApiClient.parameterToString(xAmzSignature));
        }

        if (xAmzSignedHeaders != null) {
            localVarHeaderParams.put("X-Amz-SignedHeaders", localVarApiClient.parameterToString(xAmzSignedHeaders));
        }

        final String[] localVarAccepts = {
            "text/xml"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            "text/xml"
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "hmac" };
        return localVarApiClient.buildCall(basePath, localVarPath, "POST", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call pOSTEnableSnapshotCopyValidateBeforeCall(String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, EnableSnapshotCopyMessage enableSnapshotCopyMessage, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'action' is set
        if (action == null) {
            throw new ApiException("Missing the required parameter 'action' when calling pOSTEnableSnapshotCopy(Async)");
        }

        // verify the required parameter 'version' is set
        if (version == null) {
            throw new ApiException("Missing the required parameter 'version' when calling pOSTEnableSnapshotCopy(Async)");
        }

        return pOSTEnableSnapshotCopyCall(action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, enableSnapshotCopyMessage, _callback);

    }

    /**
     * 
     * Enables the automatic copy of snapshots from one region to another region for a specified cluster.
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param enableSnapshotCopyMessage  (optional)
     * @return EnableSnapshotCopyResult
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> IncompatibleOrderableOptions </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> InvalidClusterStateFault </td><td>  -  </td></tr>
        <tr><td> 482 </td><td> ClusterNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 483 </td><td> CopyToRegionDisabledFault </td><td>  -  </td></tr>
        <tr><td> 484 </td><td> SnapshotCopyAlreadyEnabledFault </td><td>  -  </td></tr>
        <tr><td> 485 </td><td> UnknownSnapshotCopyRegionFault </td><td>  -  </td></tr>
        <tr><td> 486 </td><td> UnauthorizedOperation </td><td>  -  </td></tr>
        <tr><td> 487 </td><td> SnapshotCopyGrantNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 488 </td><td> LimitExceededFault </td><td>  -  </td></tr>
        <tr><td> 489 </td><td> DependentServiceRequestThrottlingFault </td><td>  -  </td></tr>
        <tr><td> 490 </td><td> InvalidRetentionPeriodFault </td><td>  -  </td></tr>
     </table>
     */
    public EnableSnapshotCopyResult pOSTEnableSnapshotCopy(String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, EnableSnapshotCopyMessage enableSnapshotCopyMessage) throws ApiException {
        ApiResponse<EnableSnapshotCopyResult> localVarResp = pOSTEnableSnapshotCopyWithHttpInfo(action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, enableSnapshotCopyMessage);
        return localVarResp.getData();
    }

    /**
     * 
     * Enables the automatic copy of snapshots from one region to another region for a specified cluster.
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param enableSnapshotCopyMessage  (optional)
     * @return ApiResponse&lt;EnableSnapshotCopyResult&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> IncompatibleOrderableOptions </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> InvalidClusterStateFault </td><td>  -  </td></tr>
        <tr><td> 482 </td><td> ClusterNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 483 </td><td> CopyToRegionDisabledFault </td><td>  -  </td></tr>
        <tr><td> 484 </td><td> SnapshotCopyAlreadyEnabledFault </td><td>  -  </td></tr>
        <tr><td> 485 </td><td> UnknownSnapshotCopyRegionFault </td><td>  -  </td></tr>
        <tr><td> 486 </td><td> UnauthorizedOperation </td><td>  -  </td></tr>
        <tr><td> 487 </td><td> SnapshotCopyGrantNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 488 </td><td> LimitExceededFault </td><td>  -  </td></tr>
        <tr><td> 489 </td><td> DependentServiceRequestThrottlingFault </td><td>  -  </td></tr>
        <tr><td> 490 </td><td> InvalidRetentionPeriodFault </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<EnableSnapshotCopyResult> pOSTEnableSnapshotCopyWithHttpInfo(String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, EnableSnapshotCopyMessage enableSnapshotCopyMessage) throws ApiException {
        okhttp3.Call localVarCall = pOSTEnableSnapshotCopyValidateBeforeCall(action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, enableSnapshotCopyMessage, null);
        Type localVarReturnType = new TypeToken<EnableSnapshotCopyResult>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     *  (asynchronously)
     * Enables the automatic copy of snapshots from one region to another region for a specified cluster.
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param enableSnapshotCopyMessage  (optional)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> IncompatibleOrderableOptions </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> InvalidClusterStateFault </td><td>  -  </td></tr>
        <tr><td> 482 </td><td> ClusterNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 483 </td><td> CopyToRegionDisabledFault </td><td>  -  </td></tr>
        <tr><td> 484 </td><td> SnapshotCopyAlreadyEnabledFault </td><td>  -  </td></tr>
        <tr><td> 485 </td><td> UnknownSnapshotCopyRegionFault </td><td>  -  </td></tr>
        <tr><td> 486 </td><td> UnauthorizedOperation </td><td>  -  </td></tr>
        <tr><td> 487 </td><td> SnapshotCopyGrantNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 488 </td><td> LimitExceededFault </td><td>  -  </td></tr>
        <tr><td> 489 </td><td> DependentServiceRequestThrottlingFault </td><td>  -  </td></tr>
        <tr><td> 490 </td><td> InvalidRetentionPeriodFault </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call pOSTEnableSnapshotCopyAsync(String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, EnableSnapshotCopyMessage enableSnapshotCopyMessage, final ApiCallback<EnableSnapshotCopyResult> _callback) throws ApiException {

        okhttp3.Call localVarCall = pOSTEnableSnapshotCopyValidateBeforeCall(action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, enableSnapshotCopyMessage, _callback);
        Type localVarReturnType = new TypeToken<EnableSnapshotCopyResult>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for pOSTGetClusterCredentials
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param getClusterCredentialsMessage  (optional)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> ClusterNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> UnsupportedOperationFault </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call pOSTGetClusterCredentialsCall(String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, GetClusterCredentialsMessage getClusterCredentialsMessage, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = getClusterCredentialsMessage;

        // create path and map variables
        String localVarPath = "/#Action=GetClusterCredentials";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (action != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("Action", action));
        }

        if (version != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("Version", version));
        }

        if (xAmzContentSha256 != null) {
            localVarHeaderParams.put("X-Amz-Content-Sha256", localVarApiClient.parameterToString(xAmzContentSha256));
        }

        if (xAmzDate != null) {
            localVarHeaderParams.put("X-Amz-Date", localVarApiClient.parameterToString(xAmzDate));
        }

        if (xAmzAlgorithm != null) {
            localVarHeaderParams.put("X-Amz-Algorithm", localVarApiClient.parameterToString(xAmzAlgorithm));
        }

        if (xAmzCredential != null) {
            localVarHeaderParams.put("X-Amz-Credential", localVarApiClient.parameterToString(xAmzCredential));
        }

        if (xAmzSecurityToken != null) {
            localVarHeaderParams.put("X-Amz-Security-Token", localVarApiClient.parameterToString(xAmzSecurityToken));
        }

        if (xAmzSignature != null) {
            localVarHeaderParams.put("X-Amz-Signature", localVarApiClient.parameterToString(xAmzSignature));
        }

        if (xAmzSignedHeaders != null) {
            localVarHeaderParams.put("X-Amz-SignedHeaders", localVarApiClient.parameterToString(xAmzSignedHeaders));
        }

        final String[] localVarAccepts = {
            "text/xml"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            "text/xml"
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "hmac" };
        return localVarApiClient.buildCall(basePath, localVarPath, "POST", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call pOSTGetClusterCredentialsValidateBeforeCall(String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, GetClusterCredentialsMessage getClusterCredentialsMessage, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'action' is set
        if (action == null) {
            throw new ApiException("Missing the required parameter 'action' when calling pOSTGetClusterCredentials(Async)");
        }

        // verify the required parameter 'version' is set
        if (version == null) {
            throw new ApiException("Missing the required parameter 'version' when calling pOSTGetClusterCredentials(Async)");
        }

        return pOSTGetClusterCredentialsCall(action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, getClusterCredentialsMessage, _callback);

    }

    /**
     * 
     * &lt;p&gt;Returns a database user name and temporary password with temporary authorization to log on to an Amazon Redshift database. The action returns the database user name prefixed with &lt;code&gt;IAM:&lt;/code&gt; if &lt;code&gt;AutoCreate&lt;/code&gt; is &lt;code&gt;False&lt;/code&gt; or &lt;code&gt;IAMA:&lt;/code&gt; if &lt;code&gt;AutoCreate&lt;/code&gt; is &lt;code&gt;True&lt;/code&gt;. You can optionally specify one or more database user groups that the user will join at log on. By default, the temporary credentials expire in 900 seconds. You can optionally specify a duration between 900 seconds (15 minutes) and 3600 seconds (60 minutes). For more information, see &lt;a href&#x3D;\&quot;https://docs.aws.amazon.com/redshift/latest/mgmt/generating-user-credentials.html\&quot;&gt;Using IAM Authentication to Generate Database User Credentials&lt;/a&gt; in the Amazon Redshift Cluster Management Guide.&lt;/p&gt; &lt;p&gt;The Identity and Access Management (IAM) user or role that runs GetClusterCredentials must have an IAM policy attached that allows access to all necessary actions and resources. For more information about permissions, see &lt;a href&#x3D;\&quot;https://docs.aws.amazon.com/redshift/latest/mgmt/redshift-iam-access-control-identity-based.html#redshift-policy-resources.getclustercredentials-resources\&quot;&gt;Resource Policies for GetClusterCredentials&lt;/a&gt; in the Amazon Redshift Cluster Management Guide.&lt;/p&gt; &lt;p&gt;If the &lt;code&gt;DbGroups&lt;/code&gt; parameter is specified, the IAM policy must allow the &lt;code&gt;redshift:JoinGroup&lt;/code&gt; action with access to the listed &lt;code&gt;dbgroups&lt;/code&gt;. &lt;/p&gt; &lt;p&gt;In addition, if the &lt;code&gt;AutoCreate&lt;/code&gt; parameter is set to &lt;code&gt;True&lt;/code&gt;, then the policy must include the &lt;code&gt;redshift:CreateClusterUser&lt;/code&gt; permission.&lt;/p&gt; &lt;p&gt;If the &lt;code&gt;DbName&lt;/code&gt; parameter is specified, the IAM policy must allow access to the resource &lt;code&gt;dbname&lt;/code&gt; for the specified database name. &lt;/p&gt;
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param getClusterCredentialsMessage  (optional)
     * @return ClusterCredentials
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> ClusterNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> UnsupportedOperationFault </td><td>  -  </td></tr>
     </table>
     */
    public ClusterCredentials pOSTGetClusterCredentials(String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, GetClusterCredentialsMessage getClusterCredentialsMessage) throws ApiException {
        ApiResponse<ClusterCredentials> localVarResp = pOSTGetClusterCredentialsWithHttpInfo(action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, getClusterCredentialsMessage);
        return localVarResp.getData();
    }

    /**
     * 
     * &lt;p&gt;Returns a database user name and temporary password with temporary authorization to log on to an Amazon Redshift database. The action returns the database user name prefixed with &lt;code&gt;IAM:&lt;/code&gt; if &lt;code&gt;AutoCreate&lt;/code&gt; is &lt;code&gt;False&lt;/code&gt; or &lt;code&gt;IAMA:&lt;/code&gt; if &lt;code&gt;AutoCreate&lt;/code&gt; is &lt;code&gt;True&lt;/code&gt;. You can optionally specify one or more database user groups that the user will join at log on. By default, the temporary credentials expire in 900 seconds. You can optionally specify a duration between 900 seconds (15 minutes) and 3600 seconds (60 minutes). For more information, see &lt;a href&#x3D;\&quot;https://docs.aws.amazon.com/redshift/latest/mgmt/generating-user-credentials.html\&quot;&gt;Using IAM Authentication to Generate Database User Credentials&lt;/a&gt; in the Amazon Redshift Cluster Management Guide.&lt;/p&gt; &lt;p&gt;The Identity and Access Management (IAM) user or role that runs GetClusterCredentials must have an IAM policy attached that allows access to all necessary actions and resources. For more information about permissions, see &lt;a href&#x3D;\&quot;https://docs.aws.amazon.com/redshift/latest/mgmt/redshift-iam-access-control-identity-based.html#redshift-policy-resources.getclustercredentials-resources\&quot;&gt;Resource Policies for GetClusterCredentials&lt;/a&gt; in the Amazon Redshift Cluster Management Guide.&lt;/p&gt; &lt;p&gt;If the &lt;code&gt;DbGroups&lt;/code&gt; parameter is specified, the IAM policy must allow the &lt;code&gt;redshift:JoinGroup&lt;/code&gt; action with access to the listed &lt;code&gt;dbgroups&lt;/code&gt;. &lt;/p&gt; &lt;p&gt;In addition, if the &lt;code&gt;AutoCreate&lt;/code&gt; parameter is set to &lt;code&gt;True&lt;/code&gt;, then the policy must include the &lt;code&gt;redshift:CreateClusterUser&lt;/code&gt; permission.&lt;/p&gt; &lt;p&gt;If the &lt;code&gt;DbName&lt;/code&gt; parameter is specified, the IAM policy must allow access to the resource &lt;code&gt;dbname&lt;/code&gt; for the specified database name. &lt;/p&gt;
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param getClusterCredentialsMessage  (optional)
     * @return ApiResponse&lt;ClusterCredentials&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> ClusterNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> UnsupportedOperationFault </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<ClusterCredentials> pOSTGetClusterCredentialsWithHttpInfo(String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, GetClusterCredentialsMessage getClusterCredentialsMessage) throws ApiException {
        okhttp3.Call localVarCall = pOSTGetClusterCredentialsValidateBeforeCall(action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, getClusterCredentialsMessage, null);
        Type localVarReturnType = new TypeToken<ClusterCredentials>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     *  (asynchronously)
     * &lt;p&gt;Returns a database user name and temporary password with temporary authorization to log on to an Amazon Redshift database. The action returns the database user name prefixed with &lt;code&gt;IAM:&lt;/code&gt; if &lt;code&gt;AutoCreate&lt;/code&gt; is &lt;code&gt;False&lt;/code&gt; or &lt;code&gt;IAMA:&lt;/code&gt; if &lt;code&gt;AutoCreate&lt;/code&gt; is &lt;code&gt;True&lt;/code&gt;. You can optionally specify one or more database user groups that the user will join at log on. By default, the temporary credentials expire in 900 seconds. You can optionally specify a duration between 900 seconds (15 minutes) and 3600 seconds (60 minutes). For more information, see &lt;a href&#x3D;\&quot;https://docs.aws.amazon.com/redshift/latest/mgmt/generating-user-credentials.html\&quot;&gt;Using IAM Authentication to Generate Database User Credentials&lt;/a&gt; in the Amazon Redshift Cluster Management Guide.&lt;/p&gt; &lt;p&gt;The Identity and Access Management (IAM) user or role that runs GetClusterCredentials must have an IAM policy attached that allows access to all necessary actions and resources. For more information about permissions, see &lt;a href&#x3D;\&quot;https://docs.aws.amazon.com/redshift/latest/mgmt/redshift-iam-access-control-identity-based.html#redshift-policy-resources.getclustercredentials-resources\&quot;&gt;Resource Policies for GetClusterCredentials&lt;/a&gt; in the Amazon Redshift Cluster Management Guide.&lt;/p&gt; &lt;p&gt;If the &lt;code&gt;DbGroups&lt;/code&gt; parameter is specified, the IAM policy must allow the &lt;code&gt;redshift:JoinGroup&lt;/code&gt; action with access to the listed &lt;code&gt;dbgroups&lt;/code&gt;. &lt;/p&gt; &lt;p&gt;In addition, if the &lt;code&gt;AutoCreate&lt;/code&gt; parameter is set to &lt;code&gt;True&lt;/code&gt;, then the policy must include the &lt;code&gt;redshift:CreateClusterUser&lt;/code&gt; permission.&lt;/p&gt; &lt;p&gt;If the &lt;code&gt;DbName&lt;/code&gt; parameter is specified, the IAM policy must allow access to the resource &lt;code&gt;dbname&lt;/code&gt; for the specified database name. &lt;/p&gt;
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param getClusterCredentialsMessage  (optional)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> ClusterNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> UnsupportedOperationFault </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call pOSTGetClusterCredentialsAsync(String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, GetClusterCredentialsMessage getClusterCredentialsMessage, final ApiCallback<ClusterCredentials> _callback) throws ApiException {

        okhttp3.Call localVarCall = pOSTGetClusterCredentialsValidateBeforeCall(action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, getClusterCredentialsMessage, _callback);
        Type localVarReturnType = new TypeToken<ClusterCredentials>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for pOSTGetClusterCredentialsWithIAM
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param getClusterCredentialsWithIAMMessage  (optional)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> ClusterNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> UnsupportedOperationFault </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call pOSTGetClusterCredentialsWithIAMCall(String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, GetClusterCredentialsWithIAMMessage getClusterCredentialsWithIAMMessage, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = getClusterCredentialsWithIAMMessage;

        // create path and map variables
        String localVarPath = "/#Action=GetClusterCredentialsWithIAM";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (action != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("Action", action));
        }

        if (version != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("Version", version));
        }

        if (xAmzContentSha256 != null) {
            localVarHeaderParams.put("X-Amz-Content-Sha256", localVarApiClient.parameterToString(xAmzContentSha256));
        }

        if (xAmzDate != null) {
            localVarHeaderParams.put("X-Amz-Date", localVarApiClient.parameterToString(xAmzDate));
        }

        if (xAmzAlgorithm != null) {
            localVarHeaderParams.put("X-Amz-Algorithm", localVarApiClient.parameterToString(xAmzAlgorithm));
        }

        if (xAmzCredential != null) {
            localVarHeaderParams.put("X-Amz-Credential", localVarApiClient.parameterToString(xAmzCredential));
        }

        if (xAmzSecurityToken != null) {
            localVarHeaderParams.put("X-Amz-Security-Token", localVarApiClient.parameterToString(xAmzSecurityToken));
        }

        if (xAmzSignature != null) {
            localVarHeaderParams.put("X-Amz-Signature", localVarApiClient.parameterToString(xAmzSignature));
        }

        if (xAmzSignedHeaders != null) {
            localVarHeaderParams.put("X-Amz-SignedHeaders", localVarApiClient.parameterToString(xAmzSignedHeaders));
        }

        final String[] localVarAccepts = {
            "text/xml"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            "text/xml"
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "hmac" };
        return localVarApiClient.buildCall(basePath, localVarPath, "POST", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call pOSTGetClusterCredentialsWithIAMValidateBeforeCall(String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, GetClusterCredentialsWithIAMMessage getClusterCredentialsWithIAMMessage, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'action' is set
        if (action == null) {
            throw new ApiException("Missing the required parameter 'action' when calling pOSTGetClusterCredentialsWithIAM(Async)");
        }

        // verify the required parameter 'version' is set
        if (version == null) {
            throw new ApiException("Missing the required parameter 'version' when calling pOSTGetClusterCredentialsWithIAM(Async)");
        }

        return pOSTGetClusterCredentialsWithIAMCall(action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, getClusterCredentialsWithIAMMessage, _callback);

    }

    /**
     * 
     * &lt;p&gt;Returns a database user name and temporary password with temporary authorization to log in to an Amazon Redshift database. The database user is mapped 1:1 to the source Identity and Access Management (IAM) identity. For more information about IAM identities, see &lt;a href&#x3D;\&quot;https://docs.aws.amazon.com/IAM/latest/UserGuide/id.html\&quot;&gt;IAM Identities (users, user groups, and roles)&lt;/a&gt; in the Amazon Web Services Identity and Access Management User Guide.&lt;/p&gt; &lt;p&gt;The Identity and Access Management (IAM) identity that runs this operation must have an IAM policy attached that allows access to all necessary actions and resources. For more information about permissions, see &lt;a href&#x3D;\&quot;https://docs.aws.amazon.com/redshift/latest/mgmt/redshift-iam-access-control-identity-based.html\&quot;&gt;Using identity-based policies (IAM policies)&lt;/a&gt; in the Amazon Redshift Cluster Management Guide. &lt;/p&gt;
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param getClusterCredentialsWithIAMMessage  (optional)
     * @return ClusterExtendedCredentials
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> ClusterNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> UnsupportedOperationFault </td><td>  -  </td></tr>
     </table>
     */
    public ClusterExtendedCredentials pOSTGetClusterCredentialsWithIAM(String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, GetClusterCredentialsWithIAMMessage getClusterCredentialsWithIAMMessage) throws ApiException {
        ApiResponse<ClusterExtendedCredentials> localVarResp = pOSTGetClusterCredentialsWithIAMWithHttpInfo(action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, getClusterCredentialsWithIAMMessage);
        return localVarResp.getData();
    }

    /**
     * 
     * &lt;p&gt;Returns a database user name and temporary password with temporary authorization to log in to an Amazon Redshift database. The database user is mapped 1:1 to the source Identity and Access Management (IAM) identity. For more information about IAM identities, see &lt;a href&#x3D;\&quot;https://docs.aws.amazon.com/IAM/latest/UserGuide/id.html\&quot;&gt;IAM Identities (users, user groups, and roles)&lt;/a&gt; in the Amazon Web Services Identity and Access Management User Guide.&lt;/p&gt; &lt;p&gt;The Identity and Access Management (IAM) identity that runs this operation must have an IAM policy attached that allows access to all necessary actions and resources. For more information about permissions, see &lt;a href&#x3D;\&quot;https://docs.aws.amazon.com/redshift/latest/mgmt/redshift-iam-access-control-identity-based.html\&quot;&gt;Using identity-based policies (IAM policies)&lt;/a&gt; in the Amazon Redshift Cluster Management Guide. &lt;/p&gt;
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param getClusterCredentialsWithIAMMessage  (optional)
     * @return ApiResponse&lt;ClusterExtendedCredentials&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> ClusterNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> UnsupportedOperationFault </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<ClusterExtendedCredentials> pOSTGetClusterCredentialsWithIAMWithHttpInfo(String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, GetClusterCredentialsWithIAMMessage getClusterCredentialsWithIAMMessage) throws ApiException {
        okhttp3.Call localVarCall = pOSTGetClusterCredentialsWithIAMValidateBeforeCall(action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, getClusterCredentialsWithIAMMessage, null);
        Type localVarReturnType = new TypeToken<ClusterExtendedCredentials>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     *  (asynchronously)
     * &lt;p&gt;Returns a database user name and temporary password with temporary authorization to log in to an Amazon Redshift database. The database user is mapped 1:1 to the source Identity and Access Management (IAM) identity. For more information about IAM identities, see &lt;a href&#x3D;\&quot;https://docs.aws.amazon.com/IAM/latest/UserGuide/id.html\&quot;&gt;IAM Identities (users, user groups, and roles)&lt;/a&gt; in the Amazon Web Services Identity and Access Management User Guide.&lt;/p&gt; &lt;p&gt;The Identity and Access Management (IAM) identity that runs this operation must have an IAM policy attached that allows access to all necessary actions and resources. For more information about permissions, see &lt;a href&#x3D;\&quot;https://docs.aws.amazon.com/redshift/latest/mgmt/redshift-iam-access-control-identity-based.html\&quot;&gt;Using identity-based policies (IAM policies)&lt;/a&gt; in the Amazon Redshift Cluster Management Guide. &lt;/p&gt;
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param getClusterCredentialsWithIAMMessage  (optional)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> ClusterNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> UnsupportedOperationFault </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call pOSTGetClusterCredentialsWithIAMAsync(String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, GetClusterCredentialsWithIAMMessage getClusterCredentialsWithIAMMessage, final ApiCallback<ClusterExtendedCredentials> _callback) throws ApiException {

        okhttp3.Call localVarCall = pOSTGetClusterCredentialsWithIAMValidateBeforeCall(action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, getClusterCredentialsWithIAMMessage, _callback);
        Type localVarReturnType = new TypeToken<ClusterExtendedCredentials>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for pOSTGetReservedNodeExchangeConfigurationOptions
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param maxRecords Pagination limit (optional)
     * @param marker Pagination token (optional)
     * @param getReservedNodeExchangeConfigurationOptionsInputMessage  (optional)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> ReservedNodeNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> InvalidReservedNodeStateFault </td><td>  -  </td></tr>
        <tr><td> 482 </td><td> ReservedNodeAlreadyMigratedFault </td><td>  -  </td></tr>
        <tr><td> 483 </td><td> ReservedNodeOfferingNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 484 </td><td> UnsupportedOperationFault </td><td>  -  </td></tr>
        <tr><td> 485 </td><td> DependentServiceUnavailableFault </td><td>  -  </td></tr>
        <tr><td> 486 </td><td> ClusterNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 487 </td><td> ClusterSnapshotNotFoundFault </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call pOSTGetReservedNodeExchangeConfigurationOptionsCall(String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, String maxRecords, String marker, GetReservedNodeExchangeConfigurationOptionsInputMessage getReservedNodeExchangeConfigurationOptionsInputMessage, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = getReservedNodeExchangeConfigurationOptionsInputMessage;

        // create path and map variables
        String localVarPath = "/#Action=GetReservedNodeExchangeConfigurationOptions";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (maxRecords != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("MaxRecords", maxRecords));
        }

        if (marker != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("Marker", marker));
        }

        if (action != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("Action", action));
        }

        if (version != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("Version", version));
        }

        if (xAmzContentSha256 != null) {
            localVarHeaderParams.put("X-Amz-Content-Sha256", localVarApiClient.parameterToString(xAmzContentSha256));
        }

        if (xAmzDate != null) {
            localVarHeaderParams.put("X-Amz-Date", localVarApiClient.parameterToString(xAmzDate));
        }

        if (xAmzAlgorithm != null) {
            localVarHeaderParams.put("X-Amz-Algorithm", localVarApiClient.parameterToString(xAmzAlgorithm));
        }

        if (xAmzCredential != null) {
            localVarHeaderParams.put("X-Amz-Credential", localVarApiClient.parameterToString(xAmzCredential));
        }

        if (xAmzSecurityToken != null) {
            localVarHeaderParams.put("X-Amz-Security-Token", localVarApiClient.parameterToString(xAmzSecurityToken));
        }

        if (xAmzSignature != null) {
            localVarHeaderParams.put("X-Amz-Signature", localVarApiClient.parameterToString(xAmzSignature));
        }

        if (xAmzSignedHeaders != null) {
            localVarHeaderParams.put("X-Amz-SignedHeaders", localVarApiClient.parameterToString(xAmzSignedHeaders));
        }

        final String[] localVarAccepts = {
            "text/xml"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            "text/xml"
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "hmac" };
        return localVarApiClient.buildCall(basePath, localVarPath, "POST", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call pOSTGetReservedNodeExchangeConfigurationOptionsValidateBeforeCall(String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, String maxRecords, String marker, GetReservedNodeExchangeConfigurationOptionsInputMessage getReservedNodeExchangeConfigurationOptionsInputMessage, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'action' is set
        if (action == null) {
            throw new ApiException("Missing the required parameter 'action' when calling pOSTGetReservedNodeExchangeConfigurationOptions(Async)");
        }

        // verify the required parameter 'version' is set
        if (version == null) {
            throw new ApiException("Missing the required parameter 'version' when calling pOSTGetReservedNodeExchangeConfigurationOptions(Async)");
        }

        return pOSTGetReservedNodeExchangeConfigurationOptionsCall(action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, maxRecords, marker, getReservedNodeExchangeConfigurationOptionsInputMessage, _callback);

    }

    /**
     * 
     * Gets the configuration options for the reserved-node exchange. These options include information about the source reserved node and target reserved node offering. Details include the node type, the price, the node count, and the offering type.
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param maxRecords Pagination limit (optional)
     * @param marker Pagination token (optional)
     * @param getReservedNodeExchangeConfigurationOptionsInputMessage  (optional)
     * @return GetReservedNodeExchangeConfigurationOptionsOutputMessage
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> ReservedNodeNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> InvalidReservedNodeStateFault </td><td>  -  </td></tr>
        <tr><td> 482 </td><td> ReservedNodeAlreadyMigratedFault </td><td>  -  </td></tr>
        <tr><td> 483 </td><td> ReservedNodeOfferingNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 484 </td><td> UnsupportedOperationFault </td><td>  -  </td></tr>
        <tr><td> 485 </td><td> DependentServiceUnavailableFault </td><td>  -  </td></tr>
        <tr><td> 486 </td><td> ClusterNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 487 </td><td> ClusterSnapshotNotFoundFault </td><td>  -  </td></tr>
     </table>
     */
    public GetReservedNodeExchangeConfigurationOptionsOutputMessage pOSTGetReservedNodeExchangeConfigurationOptions(String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, String maxRecords, String marker, GetReservedNodeExchangeConfigurationOptionsInputMessage getReservedNodeExchangeConfigurationOptionsInputMessage) throws ApiException {
        ApiResponse<GetReservedNodeExchangeConfigurationOptionsOutputMessage> localVarResp = pOSTGetReservedNodeExchangeConfigurationOptionsWithHttpInfo(action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, maxRecords, marker, getReservedNodeExchangeConfigurationOptionsInputMessage);
        return localVarResp.getData();
    }

    /**
     * 
     * Gets the configuration options for the reserved-node exchange. These options include information about the source reserved node and target reserved node offering. Details include the node type, the price, the node count, and the offering type.
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param maxRecords Pagination limit (optional)
     * @param marker Pagination token (optional)
     * @param getReservedNodeExchangeConfigurationOptionsInputMessage  (optional)
     * @return ApiResponse&lt;GetReservedNodeExchangeConfigurationOptionsOutputMessage&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> ReservedNodeNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> InvalidReservedNodeStateFault </td><td>  -  </td></tr>
        <tr><td> 482 </td><td> ReservedNodeAlreadyMigratedFault </td><td>  -  </td></tr>
        <tr><td> 483 </td><td> ReservedNodeOfferingNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 484 </td><td> UnsupportedOperationFault </td><td>  -  </td></tr>
        <tr><td> 485 </td><td> DependentServiceUnavailableFault </td><td>  -  </td></tr>
        <tr><td> 486 </td><td> ClusterNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 487 </td><td> ClusterSnapshotNotFoundFault </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<GetReservedNodeExchangeConfigurationOptionsOutputMessage> pOSTGetReservedNodeExchangeConfigurationOptionsWithHttpInfo(String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, String maxRecords, String marker, GetReservedNodeExchangeConfigurationOptionsInputMessage getReservedNodeExchangeConfigurationOptionsInputMessage) throws ApiException {
        okhttp3.Call localVarCall = pOSTGetReservedNodeExchangeConfigurationOptionsValidateBeforeCall(action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, maxRecords, marker, getReservedNodeExchangeConfigurationOptionsInputMessage, null);
        Type localVarReturnType = new TypeToken<GetReservedNodeExchangeConfigurationOptionsOutputMessage>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     *  (asynchronously)
     * Gets the configuration options for the reserved-node exchange. These options include information about the source reserved node and target reserved node offering. Details include the node type, the price, the node count, and the offering type.
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param maxRecords Pagination limit (optional)
     * @param marker Pagination token (optional)
     * @param getReservedNodeExchangeConfigurationOptionsInputMessage  (optional)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> ReservedNodeNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> InvalidReservedNodeStateFault </td><td>  -  </td></tr>
        <tr><td> 482 </td><td> ReservedNodeAlreadyMigratedFault </td><td>  -  </td></tr>
        <tr><td> 483 </td><td> ReservedNodeOfferingNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 484 </td><td> UnsupportedOperationFault </td><td>  -  </td></tr>
        <tr><td> 485 </td><td> DependentServiceUnavailableFault </td><td>  -  </td></tr>
        <tr><td> 486 </td><td> ClusterNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 487 </td><td> ClusterSnapshotNotFoundFault </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call pOSTGetReservedNodeExchangeConfigurationOptionsAsync(String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, String maxRecords, String marker, GetReservedNodeExchangeConfigurationOptionsInputMessage getReservedNodeExchangeConfigurationOptionsInputMessage, final ApiCallback<GetReservedNodeExchangeConfigurationOptionsOutputMessage> _callback) throws ApiException {

        okhttp3.Call localVarCall = pOSTGetReservedNodeExchangeConfigurationOptionsValidateBeforeCall(action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, maxRecords, marker, getReservedNodeExchangeConfigurationOptionsInputMessage, _callback);
        Type localVarReturnType = new TypeToken<GetReservedNodeExchangeConfigurationOptionsOutputMessage>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for pOSTGetReservedNodeExchangeOfferings
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param maxRecords Pagination limit (optional)
     * @param marker Pagination token (optional)
     * @param getReservedNodeExchangeOfferingsInputMessage  (optional)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> ReservedNodeNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> InvalidReservedNodeStateFault </td><td>  -  </td></tr>
        <tr><td> 482 </td><td> ReservedNodeAlreadyMigratedFault </td><td>  -  </td></tr>
        <tr><td> 483 </td><td> ReservedNodeOfferingNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 484 </td><td> UnsupportedOperationFault </td><td>  -  </td></tr>
        <tr><td> 485 </td><td> DependentServiceUnavailableFault </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call pOSTGetReservedNodeExchangeOfferingsCall(String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, String maxRecords, String marker, GetReservedNodeExchangeOfferingsInputMessage getReservedNodeExchangeOfferingsInputMessage, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = getReservedNodeExchangeOfferingsInputMessage;

        // create path and map variables
        String localVarPath = "/#Action=GetReservedNodeExchangeOfferings";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (maxRecords != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("MaxRecords", maxRecords));
        }

        if (marker != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("Marker", marker));
        }

        if (action != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("Action", action));
        }

        if (version != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("Version", version));
        }

        if (xAmzContentSha256 != null) {
            localVarHeaderParams.put("X-Amz-Content-Sha256", localVarApiClient.parameterToString(xAmzContentSha256));
        }

        if (xAmzDate != null) {
            localVarHeaderParams.put("X-Amz-Date", localVarApiClient.parameterToString(xAmzDate));
        }

        if (xAmzAlgorithm != null) {
            localVarHeaderParams.put("X-Amz-Algorithm", localVarApiClient.parameterToString(xAmzAlgorithm));
        }

        if (xAmzCredential != null) {
            localVarHeaderParams.put("X-Amz-Credential", localVarApiClient.parameterToString(xAmzCredential));
        }

        if (xAmzSecurityToken != null) {
            localVarHeaderParams.put("X-Amz-Security-Token", localVarApiClient.parameterToString(xAmzSecurityToken));
        }

        if (xAmzSignature != null) {
            localVarHeaderParams.put("X-Amz-Signature", localVarApiClient.parameterToString(xAmzSignature));
        }

        if (xAmzSignedHeaders != null) {
            localVarHeaderParams.put("X-Amz-SignedHeaders", localVarApiClient.parameterToString(xAmzSignedHeaders));
        }

        final String[] localVarAccepts = {
            "text/xml"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            "text/xml"
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "hmac" };
        return localVarApiClient.buildCall(basePath, localVarPath, "POST", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call pOSTGetReservedNodeExchangeOfferingsValidateBeforeCall(String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, String maxRecords, String marker, GetReservedNodeExchangeOfferingsInputMessage getReservedNodeExchangeOfferingsInputMessage, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'action' is set
        if (action == null) {
            throw new ApiException("Missing the required parameter 'action' when calling pOSTGetReservedNodeExchangeOfferings(Async)");
        }

        // verify the required parameter 'version' is set
        if (version == null) {
            throw new ApiException("Missing the required parameter 'version' when calling pOSTGetReservedNodeExchangeOfferings(Async)");
        }

        return pOSTGetReservedNodeExchangeOfferingsCall(action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, maxRecords, marker, getReservedNodeExchangeOfferingsInputMessage, _callback);

    }

    /**
     * 
     * Returns an array of DC2 ReservedNodeOfferings that matches the payment type, term, and usage price of the given DC1 reserved node.
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param maxRecords Pagination limit (optional)
     * @param marker Pagination token (optional)
     * @param getReservedNodeExchangeOfferingsInputMessage  (optional)
     * @return GetReservedNodeExchangeOfferingsOutputMessage
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> ReservedNodeNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> InvalidReservedNodeStateFault </td><td>  -  </td></tr>
        <tr><td> 482 </td><td> ReservedNodeAlreadyMigratedFault </td><td>  -  </td></tr>
        <tr><td> 483 </td><td> ReservedNodeOfferingNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 484 </td><td> UnsupportedOperationFault </td><td>  -  </td></tr>
        <tr><td> 485 </td><td> DependentServiceUnavailableFault </td><td>  -  </td></tr>
     </table>
     */
    public GetReservedNodeExchangeOfferingsOutputMessage pOSTGetReservedNodeExchangeOfferings(String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, String maxRecords, String marker, GetReservedNodeExchangeOfferingsInputMessage getReservedNodeExchangeOfferingsInputMessage) throws ApiException {
        ApiResponse<GetReservedNodeExchangeOfferingsOutputMessage> localVarResp = pOSTGetReservedNodeExchangeOfferingsWithHttpInfo(action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, maxRecords, marker, getReservedNodeExchangeOfferingsInputMessage);
        return localVarResp.getData();
    }

    /**
     * 
     * Returns an array of DC2 ReservedNodeOfferings that matches the payment type, term, and usage price of the given DC1 reserved node.
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param maxRecords Pagination limit (optional)
     * @param marker Pagination token (optional)
     * @param getReservedNodeExchangeOfferingsInputMessage  (optional)
     * @return ApiResponse&lt;GetReservedNodeExchangeOfferingsOutputMessage&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> ReservedNodeNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> InvalidReservedNodeStateFault </td><td>  -  </td></tr>
        <tr><td> 482 </td><td> ReservedNodeAlreadyMigratedFault </td><td>  -  </td></tr>
        <tr><td> 483 </td><td> ReservedNodeOfferingNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 484 </td><td> UnsupportedOperationFault </td><td>  -  </td></tr>
        <tr><td> 485 </td><td> DependentServiceUnavailableFault </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<GetReservedNodeExchangeOfferingsOutputMessage> pOSTGetReservedNodeExchangeOfferingsWithHttpInfo(String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, String maxRecords, String marker, GetReservedNodeExchangeOfferingsInputMessage getReservedNodeExchangeOfferingsInputMessage) throws ApiException {
        okhttp3.Call localVarCall = pOSTGetReservedNodeExchangeOfferingsValidateBeforeCall(action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, maxRecords, marker, getReservedNodeExchangeOfferingsInputMessage, null);
        Type localVarReturnType = new TypeToken<GetReservedNodeExchangeOfferingsOutputMessage>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     *  (asynchronously)
     * Returns an array of DC2 ReservedNodeOfferings that matches the payment type, term, and usage price of the given DC1 reserved node.
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param maxRecords Pagination limit (optional)
     * @param marker Pagination token (optional)
     * @param getReservedNodeExchangeOfferingsInputMessage  (optional)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> ReservedNodeNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> InvalidReservedNodeStateFault </td><td>  -  </td></tr>
        <tr><td> 482 </td><td> ReservedNodeAlreadyMigratedFault </td><td>  -  </td></tr>
        <tr><td> 483 </td><td> ReservedNodeOfferingNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 484 </td><td> UnsupportedOperationFault </td><td>  -  </td></tr>
        <tr><td> 485 </td><td> DependentServiceUnavailableFault </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call pOSTGetReservedNodeExchangeOfferingsAsync(String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, String maxRecords, String marker, GetReservedNodeExchangeOfferingsInputMessage getReservedNodeExchangeOfferingsInputMessage, final ApiCallback<GetReservedNodeExchangeOfferingsOutputMessage> _callback) throws ApiException {

        okhttp3.Call localVarCall = pOSTGetReservedNodeExchangeOfferingsValidateBeforeCall(action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, maxRecords, marker, getReservedNodeExchangeOfferingsInputMessage, _callback);
        Type localVarReturnType = new TypeToken<GetReservedNodeExchangeOfferingsOutputMessage>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for pOSTModifyAquaConfiguration
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param modifyAquaInputMessage  (optional)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> ClusterNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> InvalidClusterStateFault </td><td>  -  </td></tr>
        <tr><td> 482 </td><td> UnsupportedOperationFault </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call pOSTModifyAquaConfigurationCall(String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, ModifyAquaInputMessage modifyAquaInputMessage, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = modifyAquaInputMessage;

        // create path and map variables
        String localVarPath = "/#Action=ModifyAquaConfiguration";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (action != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("Action", action));
        }

        if (version != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("Version", version));
        }

        if (xAmzContentSha256 != null) {
            localVarHeaderParams.put("X-Amz-Content-Sha256", localVarApiClient.parameterToString(xAmzContentSha256));
        }

        if (xAmzDate != null) {
            localVarHeaderParams.put("X-Amz-Date", localVarApiClient.parameterToString(xAmzDate));
        }

        if (xAmzAlgorithm != null) {
            localVarHeaderParams.put("X-Amz-Algorithm", localVarApiClient.parameterToString(xAmzAlgorithm));
        }

        if (xAmzCredential != null) {
            localVarHeaderParams.put("X-Amz-Credential", localVarApiClient.parameterToString(xAmzCredential));
        }

        if (xAmzSecurityToken != null) {
            localVarHeaderParams.put("X-Amz-Security-Token", localVarApiClient.parameterToString(xAmzSecurityToken));
        }

        if (xAmzSignature != null) {
            localVarHeaderParams.put("X-Amz-Signature", localVarApiClient.parameterToString(xAmzSignature));
        }

        if (xAmzSignedHeaders != null) {
            localVarHeaderParams.put("X-Amz-SignedHeaders", localVarApiClient.parameterToString(xAmzSignedHeaders));
        }

        final String[] localVarAccepts = {
            "text/xml"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            "text/xml"
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "hmac" };
        return localVarApiClient.buildCall(basePath, localVarPath, "POST", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call pOSTModifyAquaConfigurationValidateBeforeCall(String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, ModifyAquaInputMessage modifyAquaInputMessage, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'action' is set
        if (action == null) {
            throw new ApiException("Missing the required parameter 'action' when calling pOSTModifyAquaConfiguration(Async)");
        }

        // verify the required parameter 'version' is set
        if (version == null) {
            throw new ApiException("Missing the required parameter 'version' when calling pOSTModifyAquaConfiguration(Async)");
        }

        return pOSTModifyAquaConfigurationCall(action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, modifyAquaInputMessage, _callback);

    }

    /**
     * 
     * This operation is retired. Calling this operation does not change AQUA configuration. Amazon Redshift automatically determines whether to use AQUA (Advanced Query Accelerator). 
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param modifyAquaInputMessage  (optional)
     * @return ModifyAquaOutputMessage
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> ClusterNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> InvalidClusterStateFault </td><td>  -  </td></tr>
        <tr><td> 482 </td><td> UnsupportedOperationFault </td><td>  -  </td></tr>
     </table>
     */
    public ModifyAquaOutputMessage pOSTModifyAquaConfiguration(String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, ModifyAquaInputMessage modifyAquaInputMessage) throws ApiException {
        ApiResponse<ModifyAquaOutputMessage> localVarResp = pOSTModifyAquaConfigurationWithHttpInfo(action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, modifyAquaInputMessage);
        return localVarResp.getData();
    }

    /**
     * 
     * This operation is retired. Calling this operation does not change AQUA configuration. Amazon Redshift automatically determines whether to use AQUA (Advanced Query Accelerator). 
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param modifyAquaInputMessage  (optional)
     * @return ApiResponse&lt;ModifyAquaOutputMessage&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> ClusterNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> InvalidClusterStateFault </td><td>  -  </td></tr>
        <tr><td> 482 </td><td> UnsupportedOperationFault </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<ModifyAquaOutputMessage> pOSTModifyAquaConfigurationWithHttpInfo(String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, ModifyAquaInputMessage modifyAquaInputMessage) throws ApiException {
        okhttp3.Call localVarCall = pOSTModifyAquaConfigurationValidateBeforeCall(action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, modifyAquaInputMessage, null);
        Type localVarReturnType = new TypeToken<ModifyAquaOutputMessage>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     *  (asynchronously)
     * This operation is retired. Calling this operation does not change AQUA configuration. Amazon Redshift automatically determines whether to use AQUA (Advanced Query Accelerator). 
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param modifyAquaInputMessage  (optional)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> ClusterNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> InvalidClusterStateFault </td><td>  -  </td></tr>
        <tr><td> 482 </td><td> UnsupportedOperationFault </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call pOSTModifyAquaConfigurationAsync(String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, ModifyAquaInputMessage modifyAquaInputMessage, final ApiCallback<ModifyAquaOutputMessage> _callback) throws ApiException {

        okhttp3.Call localVarCall = pOSTModifyAquaConfigurationValidateBeforeCall(action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, modifyAquaInputMessage, _callback);
        Type localVarReturnType = new TypeToken<ModifyAquaOutputMessage>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for pOSTModifyAuthenticationProfile
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param modifyAuthenticationProfileMessage  (optional)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> AuthenticationProfileNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> AuthenticationProfileQuotaExceededFault </td><td>  -  </td></tr>
        <tr><td> 482 </td><td> InvalidAuthenticationProfileRequestFault </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call pOSTModifyAuthenticationProfileCall(String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, ModifyAuthenticationProfileMessage modifyAuthenticationProfileMessage, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = modifyAuthenticationProfileMessage;

        // create path and map variables
        String localVarPath = "/#Action=ModifyAuthenticationProfile";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (action != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("Action", action));
        }

        if (version != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("Version", version));
        }

        if (xAmzContentSha256 != null) {
            localVarHeaderParams.put("X-Amz-Content-Sha256", localVarApiClient.parameterToString(xAmzContentSha256));
        }

        if (xAmzDate != null) {
            localVarHeaderParams.put("X-Amz-Date", localVarApiClient.parameterToString(xAmzDate));
        }

        if (xAmzAlgorithm != null) {
            localVarHeaderParams.put("X-Amz-Algorithm", localVarApiClient.parameterToString(xAmzAlgorithm));
        }

        if (xAmzCredential != null) {
            localVarHeaderParams.put("X-Amz-Credential", localVarApiClient.parameterToString(xAmzCredential));
        }

        if (xAmzSecurityToken != null) {
            localVarHeaderParams.put("X-Amz-Security-Token", localVarApiClient.parameterToString(xAmzSecurityToken));
        }

        if (xAmzSignature != null) {
            localVarHeaderParams.put("X-Amz-Signature", localVarApiClient.parameterToString(xAmzSignature));
        }

        if (xAmzSignedHeaders != null) {
            localVarHeaderParams.put("X-Amz-SignedHeaders", localVarApiClient.parameterToString(xAmzSignedHeaders));
        }

        final String[] localVarAccepts = {
            "text/xml"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            "text/xml"
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "hmac" };
        return localVarApiClient.buildCall(basePath, localVarPath, "POST", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call pOSTModifyAuthenticationProfileValidateBeforeCall(String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, ModifyAuthenticationProfileMessage modifyAuthenticationProfileMessage, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'action' is set
        if (action == null) {
            throw new ApiException("Missing the required parameter 'action' when calling pOSTModifyAuthenticationProfile(Async)");
        }

        // verify the required parameter 'version' is set
        if (version == null) {
            throw new ApiException("Missing the required parameter 'version' when calling pOSTModifyAuthenticationProfile(Async)");
        }

        return pOSTModifyAuthenticationProfileCall(action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, modifyAuthenticationProfileMessage, _callback);

    }

    /**
     * 
     * Modifies an authentication profile.
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param modifyAuthenticationProfileMessage  (optional)
     * @return ModifyAuthenticationProfileResult
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> AuthenticationProfileNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> AuthenticationProfileQuotaExceededFault </td><td>  -  </td></tr>
        <tr><td> 482 </td><td> InvalidAuthenticationProfileRequestFault </td><td>  -  </td></tr>
     </table>
     */
    public ModifyAuthenticationProfileResult pOSTModifyAuthenticationProfile(String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, ModifyAuthenticationProfileMessage modifyAuthenticationProfileMessage) throws ApiException {
        ApiResponse<ModifyAuthenticationProfileResult> localVarResp = pOSTModifyAuthenticationProfileWithHttpInfo(action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, modifyAuthenticationProfileMessage);
        return localVarResp.getData();
    }

    /**
     * 
     * Modifies an authentication profile.
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param modifyAuthenticationProfileMessage  (optional)
     * @return ApiResponse&lt;ModifyAuthenticationProfileResult&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> AuthenticationProfileNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> AuthenticationProfileQuotaExceededFault </td><td>  -  </td></tr>
        <tr><td> 482 </td><td> InvalidAuthenticationProfileRequestFault </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<ModifyAuthenticationProfileResult> pOSTModifyAuthenticationProfileWithHttpInfo(String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, ModifyAuthenticationProfileMessage modifyAuthenticationProfileMessage) throws ApiException {
        okhttp3.Call localVarCall = pOSTModifyAuthenticationProfileValidateBeforeCall(action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, modifyAuthenticationProfileMessage, null);
        Type localVarReturnType = new TypeToken<ModifyAuthenticationProfileResult>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     *  (asynchronously)
     * Modifies an authentication profile.
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param modifyAuthenticationProfileMessage  (optional)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> AuthenticationProfileNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> AuthenticationProfileQuotaExceededFault </td><td>  -  </td></tr>
        <tr><td> 482 </td><td> InvalidAuthenticationProfileRequestFault </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call pOSTModifyAuthenticationProfileAsync(String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, ModifyAuthenticationProfileMessage modifyAuthenticationProfileMessage, final ApiCallback<ModifyAuthenticationProfileResult> _callback) throws ApiException {

        okhttp3.Call localVarCall = pOSTModifyAuthenticationProfileValidateBeforeCall(action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, modifyAuthenticationProfileMessage, _callback);
        Type localVarReturnType = new TypeToken<ModifyAuthenticationProfileResult>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for pOSTModifyCluster
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param modifyClusterMessage  (optional)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> InvalidClusterStateFault </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> InvalidClusterSecurityGroupStateFault </td><td>  -  </td></tr>
        <tr><td> 482 </td><td> ClusterNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 483 </td><td> NumberOfNodesQuotaExceededFault </td><td>  -  </td></tr>
        <tr><td> 484 </td><td> NumberOfNodesPerClusterLimitExceededFault </td><td>  -  </td></tr>
        <tr><td> 485 </td><td> ClusterSecurityGroupNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 486 </td><td> ClusterParameterGroupNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 487 </td><td> InsufficientClusterCapacityFault </td><td>  -  </td></tr>
        <tr><td> 488 </td><td> UnsupportedOptionFault </td><td>  -  </td></tr>
        <tr><td> 489 </td><td> UnauthorizedOperation </td><td>  -  </td></tr>
        <tr><td> 490 </td><td> HsmClientCertificateNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 491 </td><td> HsmConfigurationNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 492 </td><td> ClusterAlreadyExistsFault </td><td>  -  </td></tr>
        <tr><td> 493 </td><td> LimitExceededFault </td><td>  -  </td></tr>
        <tr><td> 494 </td><td> DependentServiceRequestThrottlingFault </td><td>  -  </td></tr>
        <tr><td> 495 </td><td> InvalidElasticIpFault </td><td>  -  </td></tr>
        <tr><td> 496 </td><td> TableLimitExceededFault </td><td>  -  </td></tr>
        <tr><td> 497 </td><td> InvalidClusterTrackFault </td><td>  -  </td></tr>
        <tr><td> 498 </td><td> InvalidRetentionPeriodFault </td><td>  -  </td></tr>
        <tr><td> 499 </td><td> UnsupportedOperationFault </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> CustomCnameAssociationFault </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call pOSTModifyClusterCall(String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, ModifyClusterMessage modifyClusterMessage, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = modifyClusterMessage;

        // create path and map variables
        String localVarPath = "/#Action=ModifyCluster";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (action != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("Action", action));
        }

        if (version != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("Version", version));
        }

        if (xAmzContentSha256 != null) {
            localVarHeaderParams.put("X-Amz-Content-Sha256", localVarApiClient.parameterToString(xAmzContentSha256));
        }

        if (xAmzDate != null) {
            localVarHeaderParams.put("X-Amz-Date", localVarApiClient.parameterToString(xAmzDate));
        }

        if (xAmzAlgorithm != null) {
            localVarHeaderParams.put("X-Amz-Algorithm", localVarApiClient.parameterToString(xAmzAlgorithm));
        }

        if (xAmzCredential != null) {
            localVarHeaderParams.put("X-Amz-Credential", localVarApiClient.parameterToString(xAmzCredential));
        }

        if (xAmzSecurityToken != null) {
            localVarHeaderParams.put("X-Amz-Security-Token", localVarApiClient.parameterToString(xAmzSecurityToken));
        }

        if (xAmzSignature != null) {
            localVarHeaderParams.put("X-Amz-Signature", localVarApiClient.parameterToString(xAmzSignature));
        }

        if (xAmzSignedHeaders != null) {
            localVarHeaderParams.put("X-Amz-SignedHeaders", localVarApiClient.parameterToString(xAmzSignedHeaders));
        }

        final String[] localVarAccepts = {
            "text/xml"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            "text/xml"
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "hmac" };
        return localVarApiClient.buildCall(basePath, localVarPath, "POST", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call pOSTModifyClusterValidateBeforeCall(String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, ModifyClusterMessage modifyClusterMessage, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'action' is set
        if (action == null) {
            throw new ApiException("Missing the required parameter 'action' when calling pOSTModifyCluster(Async)");
        }

        // verify the required parameter 'version' is set
        if (version == null) {
            throw new ApiException("Missing the required parameter 'version' when calling pOSTModifyCluster(Async)");
        }

        return pOSTModifyClusterCall(action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, modifyClusterMessage, _callback);

    }

    /**
     * 
     * &lt;p&gt;Modifies the settings for a cluster.&lt;/p&gt; &lt;p&gt;You can also change node type and the number of nodes to scale up or down the cluster. When resizing a cluster, you must specify both the number of nodes and the node type even if one of the parameters does not change.&lt;/p&gt; &lt;p&gt;You can add another security or parameter group, or change the admin user password. Resetting a cluster password or modifying the security groups associated with a cluster do not need a reboot. However, modifying a parameter group requires a reboot for parameters to take effect. For more information about managing clusters, go to &lt;a href&#x3D;\&quot;https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html\&quot;&gt;Amazon Redshift Clusters&lt;/a&gt; in the &lt;i&gt;Amazon Redshift Cluster Management Guide&lt;/i&gt;.&lt;/p&gt;
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param modifyClusterMessage  (optional)
     * @return ModifyClusterResult
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> InvalidClusterStateFault </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> InvalidClusterSecurityGroupStateFault </td><td>  -  </td></tr>
        <tr><td> 482 </td><td> ClusterNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 483 </td><td> NumberOfNodesQuotaExceededFault </td><td>  -  </td></tr>
        <tr><td> 484 </td><td> NumberOfNodesPerClusterLimitExceededFault </td><td>  -  </td></tr>
        <tr><td> 485 </td><td> ClusterSecurityGroupNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 486 </td><td> ClusterParameterGroupNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 487 </td><td> InsufficientClusterCapacityFault </td><td>  -  </td></tr>
        <tr><td> 488 </td><td> UnsupportedOptionFault </td><td>  -  </td></tr>
        <tr><td> 489 </td><td> UnauthorizedOperation </td><td>  -  </td></tr>
        <tr><td> 490 </td><td> HsmClientCertificateNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 491 </td><td> HsmConfigurationNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 492 </td><td> ClusterAlreadyExistsFault </td><td>  -  </td></tr>
        <tr><td> 493 </td><td> LimitExceededFault </td><td>  -  </td></tr>
        <tr><td> 494 </td><td> DependentServiceRequestThrottlingFault </td><td>  -  </td></tr>
        <tr><td> 495 </td><td> InvalidElasticIpFault </td><td>  -  </td></tr>
        <tr><td> 496 </td><td> TableLimitExceededFault </td><td>  -  </td></tr>
        <tr><td> 497 </td><td> InvalidClusterTrackFault </td><td>  -  </td></tr>
        <tr><td> 498 </td><td> InvalidRetentionPeriodFault </td><td>  -  </td></tr>
        <tr><td> 499 </td><td> UnsupportedOperationFault </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> CustomCnameAssociationFault </td><td>  -  </td></tr>
     </table>
     */
    public ModifyClusterResult pOSTModifyCluster(String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, ModifyClusterMessage modifyClusterMessage) throws ApiException {
        ApiResponse<ModifyClusterResult> localVarResp = pOSTModifyClusterWithHttpInfo(action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, modifyClusterMessage);
        return localVarResp.getData();
    }

    /**
     * 
     * &lt;p&gt;Modifies the settings for a cluster.&lt;/p&gt; &lt;p&gt;You can also change node type and the number of nodes to scale up or down the cluster. When resizing a cluster, you must specify both the number of nodes and the node type even if one of the parameters does not change.&lt;/p&gt; &lt;p&gt;You can add another security or parameter group, or change the admin user password. Resetting a cluster password or modifying the security groups associated with a cluster do not need a reboot. However, modifying a parameter group requires a reboot for parameters to take effect. For more information about managing clusters, go to &lt;a href&#x3D;\&quot;https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html\&quot;&gt;Amazon Redshift Clusters&lt;/a&gt; in the &lt;i&gt;Amazon Redshift Cluster Management Guide&lt;/i&gt;.&lt;/p&gt;
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param modifyClusterMessage  (optional)
     * @return ApiResponse&lt;ModifyClusterResult&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> InvalidClusterStateFault </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> InvalidClusterSecurityGroupStateFault </td><td>  -  </td></tr>
        <tr><td> 482 </td><td> ClusterNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 483 </td><td> NumberOfNodesQuotaExceededFault </td><td>  -  </td></tr>
        <tr><td> 484 </td><td> NumberOfNodesPerClusterLimitExceededFault </td><td>  -  </td></tr>
        <tr><td> 485 </td><td> ClusterSecurityGroupNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 486 </td><td> ClusterParameterGroupNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 487 </td><td> InsufficientClusterCapacityFault </td><td>  -  </td></tr>
        <tr><td> 488 </td><td> UnsupportedOptionFault </td><td>  -  </td></tr>
        <tr><td> 489 </td><td> UnauthorizedOperation </td><td>  -  </td></tr>
        <tr><td> 490 </td><td> HsmClientCertificateNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 491 </td><td> HsmConfigurationNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 492 </td><td> ClusterAlreadyExistsFault </td><td>  -  </td></tr>
        <tr><td> 493 </td><td> LimitExceededFault </td><td>  -  </td></tr>
        <tr><td> 494 </td><td> DependentServiceRequestThrottlingFault </td><td>  -  </td></tr>
        <tr><td> 495 </td><td> InvalidElasticIpFault </td><td>  -  </td></tr>
        <tr><td> 496 </td><td> TableLimitExceededFault </td><td>  -  </td></tr>
        <tr><td> 497 </td><td> InvalidClusterTrackFault </td><td>  -  </td></tr>
        <tr><td> 498 </td><td> InvalidRetentionPeriodFault </td><td>  -  </td></tr>
        <tr><td> 499 </td><td> UnsupportedOperationFault </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> CustomCnameAssociationFault </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<ModifyClusterResult> pOSTModifyClusterWithHttpInfo(String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, ModifyClusterMessage modifyClusterMessage) throws ApiException {
        okhttp3.Call localVarCall = pOSTModifyClusterValidateBeforeCall(action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, modifyClusterMessage, null);
        Type localVarReturnType = new TypeToken<ModifyClusterResult>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     *  (asynchronously)
     * &lt;p&gt;Modifies the settings for a cluster.&lt;/p&gt; &lt;p&gt;You can also change node type and the number of nodes to scale up or down the cluster. When resizing a cluster, you must specify both the number of nodes and the node type even if one of the parameters does not change.&lt;/p&gt; &lt;p&gt;You can add another security or parameter group, or change the admin user password. Resetting a cluster password or modifying the security groups associated with a cluster do not need a reboot. However, modifying a parameter group requires a reboot for parameters to take effect. For more information about managing clusters, go to &lt;a href&#x3D;\&quot;https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html\&quot;&gt;Amazon Redshift Clusters&lt;/a&gt; in the &lt;i&gt;Amazon Redshift Cluster Management Guide&lt;/i&gt;.&lt;/p&gt;
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param modifyClusterMessage  (optional)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> InvalidClusterStateFault </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> InvalidClusterSecurityGroupStateFault </td><td>  -  </td></tr>
        <tr><td> 482 </td><td> ClusterNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 483 </td><td> NumberOfNodesQuotaExceededFault </td><td>  -  </td></tr>
        <tr><td> 484 </td><td> NumberOfNodesPerClusterLimitExceededFault </td><td>  -  </td></tr>
        <tr><td> 485 </td><td> ClusterSecurityGroupNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 486 </td><td> ClusterParameterGroupNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 487 </td><td> InsufficientClusterCapacityFault </td><td>  -  </td></tr>
        <tr><td> 488 </td><td> UnsupportedOptionFault </td><td>  -  </td></tr>
        <tr><td> 489 </td><td> UnauthorizedOperation </td><td>  -  </td></tr>
        <tr><td> 490 </td><td> HsmClientCertificateNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 491 </td><td> HsmConfigurationNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 492 </td><td> ClusterAlreadyExistsFault </td><td>  -  </td></tr>
        <tr><td> 493 </td><td> LimitExceededFault </td><td>  -  </td></tr>
        <tr><td> 494 </td><td> DependentServiceRequestThrottlingFault </td><td>  -  </td></tr>
        <tr><td> 495 </td><td> InvalidElasticIpFault </td><td>  -  </td></tr>
        <tr><td> 496 </td><td> TableLimitExceededFault </td><td>  -  </td></tr>
        <tr><td> 497 </td><td> InvalidClusterTrackFault </td><td>  -  </td></tr>
        <tr><td> 498 </td><td> InvalidRetentionPeriodFault </td><td>  -  </td></tr>
        <tr><td> 499 </td><td> UnsupportedOperationFault </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> CustomCnameAssociationFault </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call pOSTModifyClusterAsync(String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, ModifyClusterMessage modifyClusterMessage, final ApiCallback<ModifyClusterResult> _callback) throws ApiException {

        okhttp3.Call localVarCall = pOSTModifyClusterValidateBeforeCall(action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, modifyClusterMessage, _callback);
        Type localVarReturnType = new TypeToken<ModifyClusterResult>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for pOSTModifyClusterDbRevision
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param modifyClusterDbRevisionMessage  (optional)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> ClusterNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> ClusterOnLatestRevisionFault </td><td>  -  </td></tr>
        <tr><td> 482 </td><td> InvalidClusterStateFault </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call pOSTModifyClusterDbRevisionCall(String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, ModifyClusterDbRevisionMessage modifyClusterDbRevisionMessage, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = modifyClusterDbRevisionMessage;

        // create path and map variables
        String localVarPath = "/#Action=ModifyClusterDbRevision";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (action != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("Action", action));
        }

        if (version != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("Version", version));
        }

        if (xAmzContentSha256 != null) {
            localVarHeaderParams.put("X-Amz-Content-Sha256", localVarApiClient.parameterToString(xAmzContentSha256));
        }

        if (xAmzDate != null) {
            localVarHeaderParams.put("X-Amz-Date", localVarApiClient.parameterToString(xAmzDate));
        }

        if (xAmzAlgorithm != null) {
            localVarHeaderParams.put("X-Amz-Algorithm", localVarApiClient.parameterToString(xAmzAlgorithm));
        }

        if (xAmzCredential != null) {
            localVarHeaderParams.put("X-Amz-Credential", localVarApiClient.parameterToString(xAmzCredential));
        }

        if (xAmzSecurityToken != null) {
            localVarHeaderParams.put("X-Amz-Security-Token", localVarApiClient.parameterToString(xAmzSecurityToken));
        }

        if (xAmzSignature != null) {
            localVarHeaderParams.put("X-Amz-Signature", localVarApiClient.parameterToString(xAmzSignature));
        }

        if (xAmzSignedHeaders != null) {
            localVarHeaderParams.put("X-Amz-SignedHeaders", localVarApiClient.parameterToString(xAmzSignedHeaders));
        }

        final String[] localVarAccepts = {
            "text/xml"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            "text/xml"
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "hmac" };
        return localVarApiClient.buildCall(basePath, localVarPath, "POST", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call pOSTModifyClusterDbRevisionValidateBeforeCall(String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, ModifyClusterDbRevisionMessage modifyClusterDbRevisionMessage, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'action' is set
        if (action == null) {
            throw new ApiException("Missing the required parameter 'action' when calling pOSTModifyClusterDbRevision(Async)");
        }

        // verify the required parameter 'version' is set
        if (version == null) {
            throw new ApiException("Missing the required parameter 'version' when calling pOSTModifyClusterDbRevision(Async)");
        }

        return pOSTModifyClusterDbRevisionCall(action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, modifyClusterDbRevisionMessage, _callback);

    }

    /**
     * 
     * Modifies the database revision of a cluster. The database revision is a unique revision of the database running in a cluster.
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param modifyClusterDbRevisionMessage  (optional)
     * @return ModifyClusterDbRevisionResult
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> ClusterNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> ClusterOnLatestRevisionFault </td><td>  -  </td></tr>
        <tr><td> 482 </td><td> InvalidClusterStateFault </td><td>  -  </td></tr>
     </table>
     */
    public ModifyClusterDbRevisionResult pOSTModifyClusterDbRevision(String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, ModifyClusterDbRevisionMessage modifyClusterDbRevisionMessage) throws ApiException {
        ApiResponse<ModifyClusterDbRevisionResult> localVarResp = pOSTModifyClusterDbRevisionWithHttpInfo(action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, modifyClusterDbRevisionMessage);
        return localVarResp.getData();
    }

    /**
     * 
     * Modifies the database revision of a cluster. The database revision is a unique revision of the database running in a cluster.
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param modifyClusterDbRevisionMessage  (optional)
     * @return ApiResponse&lt;ModifyClusterDbRevisionResult&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> ClusterNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> ClusterOnLatestRevisionFault </td><td>  -  </td></tr>
        <tr><td> 482 </td><td> InvalidClusterStateFault </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<ModifyClusterDbRevisionResult> pOSTModifyClusterDbRevisionWithHttpInfo(String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, ModifyClusterDbRevisionMessage modifyClusterDbRevisionMessage) throws ApiException {
        okhttp3.Call localVarCall = pOSTModifyClusterDbRevisionValidateBeforeCall(action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, modifyClusterDbRevisionMessage, null);
        Type localVarReturnType = new TypeToken<ModifyClusterDbRevisionResult>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     *  (asynchronously)
     * Modifies the database revision of a cluster. The database revision is a unique revision of the database running in a cluster.
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param modifyClusterDbRevisionMessage  (optional)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> ClusterNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> ClusterOnLatestRevisionFault </td><td>  -  </td></tr>
        <tr><td> 482 </td><td> InvalidClusterStateFault </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call pOSTModifyClusterDbRevisionAsync(String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, ModifyClusterDbRevisionMessage modifyClusterDbRevisionMessage, final ApiCallback<ModifyClusterDbRevisionResult> _callback) throws ApiException {

        okhttp3.Call localVarCall = pOSTModifyClusterDbRevisionValidateBeforeCall(action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, modifyClusterDbRevisionMessage, _callback);
        Type localVarReturnType = new TypeToken<ModifyClusterDbRevisionResult>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for pOSTModifyClusterIamRoles
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param modifyClusterIamRolesMessage  (optional)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> InvalidClusterStateFault </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> ClusterNotFoundFault </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call pOSTModifyClusterIamRolesCall(String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, ModifyClusterIamRolesMessage modifyClusterIamRolesMessage, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = modifyClusterIamRolesMessage;

        // create path and map variables
        String localVarPath = "/#Action=ModifyClusterIamRoles";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (action != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("Action", action));
        }

        if (version != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("Version", version));
        }

        if (xAmzContentSha256 != null) {
            localVarHeaderParams.put("X-Amz-Content-Sha256", localVarApiClient.parameterToString(xAmzContentSha256));
        }

        if (xAmzDate != null) {
            localVarHeaderParams.put("X-Amz-Date", localVarApiClient.parameterToString(xAmzDate));
        }

        if (xAmzAlgorithm != null) {
            localVarHeaderParams.put("X-Amz-Algorithm", localVarApiClient.parameterToString(xAmzAlgorithm));
        }

        if (xAmzCredential != null) {
            localVarHeaderParams.put("X-Amz-Credential", localVarApiClient.parameterToString(xAmzCredential));
        }

        if (xAmzSecurityToken != null) {
            localVarHeaderParams.put("X-Amz-Security-Token", localVarApiClient.parameterToString(xAmzSecurityToken));
        }

        if (xAmzSignature != null) {
            localVarHeaderParams.put("X-Amz-Signature", localVarApiClient.parameterToString(xAmzSignature));
        }

        if (xAmzSignedHeaders != null) {
            localVarHeaderParams.put("X-Amz-SignedHeaders", localVarApiClient.parameterToString(xAmzSignedHeaders));
        }

        final String[] localVarAccepts = {
            "text/xml"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            "text/xml"
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "hmac" };
        return localVarApiClient.buildCall(basePath, localVarPath, "POST", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call pOSTModifyClusterIamRolesValidateBeforeCall(String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, ModifyClusterIamRolesMessage modifyClusterIamRolesMessage, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'action' is set
        if (action == null) {
            throw new ApiException("Missing the required parameter 'action' when calling pOSTModifyClusterIamRoles(Async)");
        }

        // verify the required parameter 'version' is set
        if (version == null) {
            throw new ApiException("Missing the required parameter 'version' when calling pOSTModifyClusterIamRoles(Async)");
        }

        return pOSTModifyClusterIamRolesCall(action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, modifyClusterIamRolesMessage, _callback);

    }

    /**
     * 
     * &lt;p&gt;Modifies the list of Identity and Access Management (IAM) roles that can be used by the cluster to access other Amazon Web Services services.&lt;/p&gt; &lt;p&gt;The maximum number of IAM roles that you can associate is subject to a quota. For more information, go to &lt;a href&#x3D;\&quot;https://docs.aws.amazon.com/redshift/latest/mgmt/amazon-redshift-limits.html\&quot;&gt;Quotas and limits&lt;/a&gt; in the &lt;i&gt;Amazon Redshift Cluster Management Guide&lt;/i&gt;.&lt;/p&gt;
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param modifyClusterIamRolesMessage  (optional)
     * @return ModifyClusterIamRolesResult
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> InvalidClusterStateFault </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> ClusterNotFoundFault </td><td>  -  </td></tr>
     </table>
     */
    public ModifyClusterIamRolesResult pOSTModifyClusterIamRoles(String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, ModifyClusterIamRolesMessage modifyClusterIamRolesMessage) throws ApiException {
        ApiResponse<ModifyClusterIamRolesResult> localVarResp = pOSTModifyClusterIamRolesWithHttpInfo(action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, modifyClusterIamRolesMessage);
        return localVarResp.getData();
    }

    /**
     * 
     * &lt;p&gt;Modifies the list of Identity and Access Management (IAM) roles that can be used by the cluster to access other Amazon Web Services services.&lt;/p&gt; &lt;p&gt;The maximum number of IAM roles that you can associate is subject to a quota. For more information, go to &lt;a href&#x3D;\&quot;https://docs.aws.amazon.com/redshift/latest/mgmt/amazon-redshift-limits.html\&quot;&gt;Quotas and limits&lt;/a&gt; in the &lt;i&gt;Amazon Redshift Cluster Management Guide&lt;/i&gt;.&lt;/p&gt;
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param modifyClusterIamRolesMessage  (optional)
     * @return ApiResponse&lt;ModifyClusterIamRolesResult&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> InvalidClusterStateFault </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> ClusterNotFoundFault </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<ModifyClusterIamRolesResult> pOSTModifyClusterIamRolesWithHttpInfo(String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, ModifyClusterIamRolesMessage modifyClusterIamRolesMessage) throws ApiException {
        okhttp3.Call localVarCall = pOSTModifyClusterIamRolesValidateBeforeCall(action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, modifyClusterIamRolesMessage, null);
        Type localVarReturnType = new TypeToken<ModifyClusterIamRolesResult>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     *  (asynchronously)
     * &lt;p&gt;Modifies the list of Identity and Access Management (IAM) roles that can be used by the cluster to access other Amazon Web Services services.&lt;/p&gt; &lt;p&gt;The maximum number of IAM roles that you can associate is subject to a quota. For more information, go to &lt;a href&#x3D;\&quot;https://docs.aws.amazon.com/redshift/latest/mgmt/amazon-redshift-limits.html\&quot;&gt;Quotas and limits&lt;/a&gt; in the &lt;i&gt;Amazon Redshift Cluster Management Guide&lt;/i&gt;.&lt;/p&gt;
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param modifyClusterIamRolesMessage  (optional)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> InvalidClusterStateFault </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> ClusterNotFoundFault </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call pOSTModifyClusterIamRolesAsync(String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, ModifyClusterIamRolesMessage modifyClusterIamRolesMessage, final ApiCallback<ModifyClusterIamRolesResult> _callback) throws ApiException {

        okhttp3.Call localVarCall = pOSTModifyClusterIamRolesValidateBeforeCall(action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, modifyClusterIamRolesMessage, _callback);
        Type localVarReturnType = new TypeToken<ModifyClusterIamRolesResult>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for pOSTModifyClusterMaintenance
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param modifyClusterMaintenanceMessage  (optional)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> ClusterNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> InvalidClusterStateFault </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call pOSTModifyClusterMaintenanceCall(String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, ModifyClusterMaintenanceMessage modifyClusterMaintenanceMessage, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = modifyClusterMaintenanceMessage;

        // create path and map variables
        String localVarPath = "/#Action=ModifyClusterMaintenance";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (action != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("Action", action));
        }

        if (version != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("Version", version));
        }

        if (xAmzContentSha256 != null) {
            localVarHeaderParams.put("X-Amz-Content-Sha256", localVarApiClient.parameterToString(xAmzContentSha256));
        }

        if (xAmzDate != null) {
            localVarHeaderParams.put("X-Amz-Date", localVarApiClient.parameterToString(xAmzDate));
        }

        if (xAmzAlgorithm != null) {
            localVarHeaderParams.put("X-Amz-Algorithm", localVarApiClient.parameterToString(xAmzAlgorithm));
        }

        if (xAmzCredential != null) {
            localVarHeaderParams.put("X-Amz-Credential", localVarApiClient.parameterToString(xAmzCredential));
        }

        if (xAmzSecurityToken != null) {
            localVarHeaderParams.put("X-Amz-Security-Token", localVarApiClient.parameterToString(xAmzSecurityToken));
        }

        if (xAmzSignature != null) {
            localVarHeaderParams.put("X-Amz-Signature", localVarApiClient.parameterToString(xAmzSignature));
        }

        if (xAmzSignedHeaders != null) {
            localVarHeaderParams.put("X-Amz-SignedHeaders", localVarApiClient.parameterToString(xAmzSignedHeaders));
        }

        final String[] localVarAccepts = {
            "text/xml"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            "text/xml"
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "hmac" };
        return localVarApiClient.buildCall(basePath, localVarPath, "POST", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call pOSTModifyClusterMaintenanceValidateBeforeCall(String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, ModifyClusterMaintenanceMessage modifyClusterMaintenanceMessage, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'action' is set
        if (action == null) {
            throw new ApiException("Missing the required parameter 'action' when calling pOSTModifyClusterMaintenance(Async)");
        }

        // verify the required parameter 'version' is set
        if (version == null) {
            throw new ApiException("Missing the required parameter 'version' when calling pOSTModifyClusterMaintenance(Async)");
        }

        return pOSTModifyClusterMaintenanceCall(action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, modifyClusterMaintenanceMessage, _callback);

    }

    /**
     * 
     * Modifies the maintenance settings of a cluster.
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param modifyClusterMaintenanceMessage  (optional)
     * @return ModifyClusterMaintenanceResult
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> ClusterNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> InvalidClusterStateFault </td><td>  -  </td></tr>
     </table>
     */
    public ModifyClusterMaintenanceResult pOSTModifyClusterMaintenance(String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, ModifyClusterMaintenanceMessage modifyClusterMaintenanceMessage) throws ApiException {
        ApiResponse<ModifyClusterMaintenanceResult> localVarResp = pOSTModifyClusterMaintenanceWithHttpInfo(action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, modifyClusterMaintenanceMessage);
        return localVarResp.getData();
    }

    /**
     * 
     * Modifies the maintenance settings of a cluster.
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param modifyClusterMaintenanceMessage  (optional)
     * @return ApiResponse&lt;ModifyClusterMaintenanceResult&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> ClusterNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> InvalidClusterStateFault </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<ModifyClusterMaintenanceResult> pOSTModifyClusterMaintenanceWithHttpInfo(String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, ModifyClusterMaintenanceMessage modifyClusterMaintenanceMessage) throws ApiException {
        okhttp3.Call localVarCall = pOSTModifyClusterMaintenanceValidateBeforeCall(action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, modifyClusterMaintenanceMessage, null);
        Type localVarReturnType = new TypeToken<ModifyClusterMaintenanceResult>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     *  (asynchronously)
     * Modifies the maintenance settings of a cluster.
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param modifyClusterMaintenanceMessage  (optional)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> ClusterNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> InvalidClusterStateFault </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call pOSTModifyClusterMaintenanceAsync(String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, ModifyClusterMaintenanceMessage modifyClusterMaintenanceMessage, final ApiCallback<ModifyClusterMaintenanceResult> _callback) throws ApiException {

        okhttp3.Call localVarCall = pOSTModifyClusterMaintenanceValidateBeforeCall(action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, modifyClusterMaintenanceMessage, _callback);
        Type localVarReturnType = new TypeToken<ModifyClusterMaintenanceResult>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for pOSTModifyClusterParameterGroup
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param modifyClusterParameterGroupMessage  (optional)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> ClusterParameterGroupNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> InvalidClusterParameterGroupStateFault </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call pOSTModifyClusterParameterGroupCall(String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, ModifyClusterParameterGroupMessage modifyClusterParameterGroupMessage, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = modifyClusterParameterGroupMessage;

        // create path and map variables
        String localVarPath = "/#Action=ModifyClusterParameterGroup";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (action != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("Action", action));
        }

        if (version != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("Version", version));
        }

        if (xAmzContentSha256 != null) {
            localVarHeaderParams.put("X-Amz-Content-Sha256", localVarApiClient.parameterToString(xAmzContentSha256));
        }

        if (xAmzDate != null) {
            localVarHeaderParams.put("X-Amz-Date", localVarApiClient.parameterToString(xAmzDate));
        }

        if (xAmzAlgorithm != null) {
            localVarHeaderParams.put("X-Amz-Algorithm", localVarApiClient.parameterToString(xAmzAlgorithm));
        }

        if (xAmzCredential != null) {
            localVarHeaderParams.put("X-Amz-Credential", localVarApiClient.parameterToString(xAmzCredential));
        }

        if (xAmzSecurityToken != null) {
            localVarHeaderParams.put("X-Amz-Security-Token", localVarApiClient.parameterToString(xAmzSecurityToken));
        }

        if (xAmzSignature != null) {
            localVarHeaderParams.put("X-Amz-Signature", localVarApiClient.parameterToString(xAmzSignature));
        }

        if (xAmzSignedHeaders != null) {
            localVarHeaderParams.put("X-Amz-SignedHeaders", localVarApiClient.parameterToString(xAmzSignedHeaders));
        }

        final String[] localVarAccepts = {
            "text/xml"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            "text/xml"
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "hmac" };
        return localVarApiClient.buildCall(basePath, localVarPath, "POST", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call pOSTModifyClusterParameterGroupValidateBeforeCall(String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, ModifyClusterParameterGroupMessage modifyClusterParameterGroupMessage, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'action' is set
        if (action == null) {
            throw new ApiException("Missing the required parameter 'action' when calling pOSTModifyClusterParameterGroup(Async)");
        }

        // verify the required parameter 'version' is set
        if (version == null) {
            throw new ApiException("Missing the required parameter 'version' when calling pOSTModifyClusterParameterGroup(Async)");
        }

        return pOSTModifyClusterParameterGroupCall(action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, modifyClusterParameterGroupMessage, _callback);

    }

    /**
     * 
     * &lt;p&gt;Modifies the parameters of a parameter group. For the parameters parameter, it can&#39;t contain ASCII characters.&lt;/p&gt; &lt;p&gt; For more information about parameters and parameter groups, go to &lt;a href&#x3D;\&quot;https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-parameter-groups.html\&quot;&gt;Amazon Redshift Parameter Groups&lt;/a&gt; in the &lt;i&gt;Amazon Redshift Cluster Management Guide&lt;/i&gt;.&lt;/p&gt;
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param modifyClusterParameterGroupMessage  (optional)
     * @return ClusterParameterGroupNameMessage
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> ClusterParameterGroupNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> InvalidClusterParameterGroupStateFault </td><td>  -  </td></tr>
     </table>
     */
    public ClusterParameterGroupNameMessage pOSTModifyClusterParameterGroup(String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, ModifyClusterParameterGroupMessage modifyClusterParameterGroupMessage) throws ApiException {
        ApiResponse<ClusterParameterGroupNameMessage> localVarResp = pOSTModifyClusterParameterGroupWithHttpInfo(action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, modifyClusterParameterGroupMessage);
        return localVarResp.getData();
    }

    /**
     * 
     * &lt;p&gt;Modifies the parameters of a parameter group. For the parameters parameter, it can&#39;t contain ASCII characters.&lt;/p&gt; &lt;p&gt; For more information about parameters and parameter groups, go to &lt;a href&#x3D;\&quot;https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-parameter-groups.html\&quot;&gt;Amazon Redshift Parameter Groups&lt;/a&gt; in the &lt;i&gt;Amazon Redshift Cluster Management Guide&lt;/i&gt;.&lt;/p&gt;
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param modifyClusterParameterGroupMessage  (optional)
     * @return ApiResponse&lt;ClusterParameterGroupNameMessage&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> ClusterParameterGroupNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> InvalidClusterParameterGroupStateFault </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<ClusterParameterGroupNameMessage> pOSTModifyClusterParameterGroupWithHttpInfo(String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, ModifyClusterParameterGroupMessage modifyClusterParameterGroupMessage) throws ApiException {
        okhttp3.Call localVarCall = pOSTModifyClusterParameterGroupValidateBeforeCall(action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, modifyClusterParameterGroupMessage, null);
        Type localVarReturnType = new TypeToken<ClusterParameterGroupNameMessage>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     *  (asynchronously)
     * &lt;p&gt;Modifies the parameters of a parameter group. For the parameters parameter, it can&#39;t contain ASCII characters.&lt;/p&gt; &lt;p&gt; For more information about parameters and parameter groups, go to &lt;a href&#x3D;\&quot;https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-parameter-groups.html\&quot;&gt;Amazon Redshift Parameter Groups&lt;/a&gt; in the &lt;i&gt;Amazon Redshift Cluster Management Guide&lt;/i&gt;.&lt;/p&gt;
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param modifyClusterParameterGroupMessage  (optional)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> ClusterParameterGroupNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> InvalidClusterParameterGroupStateFault </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call pOSTModifyClusterParameterGroupAsync(String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, ModifyClusterParameterGroupMessage modifyClusterParameterGroupMessage, final ApiCallback<ClusterParameterGroupNameMessage> _callback) throws ApiException {

        okhttp3.Call localVarCall = pOSTModifyClusterParameterGroupValidateBeforeCall(action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, modifyClusterParameterGroupMessage, _callback);
        Type localVarReturnType = new TypeToken<ClusterParameterGroupNameMessage>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for pOSTModifyClusterSnapshot
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param modifyClusterSnapshotMessage  (optional)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> InvalidClusterSnapshotStateFault </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> ClusterSnapshotNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 482 </td><td> InvalidRetentionPeriodFault </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call pOSTModifyClusterSnapshotCall(String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, ModifyClusterSnapshotMessage modifyClusterSnapshotMessage, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = modifyClusterSnapshotMessage;

        // create path and map variables
        String localVarPath = "/#Action=ModifyClusterSnapshot";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (action != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("Action", action));
        }

        if (version != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("Version", version));
        }

        if (xAmzContentSha256 != null) {
            localVarHeaderParams.put("X-Amz-Content-Sha256", localVarApiClient.parameterToString(xAmzContentSha256));
        }

        if (xAmzDate != null) {
            localVarHeaderParams.put("X-Amz-Date", localVarApiClient.parameterToString(xAmzDate));
        }

        if (xAmzAlgorithm != null) {
            localVarHeaderParams.put("X-Amz-Algorithm", localVarApiClient.parameterToString(xAmzAlgorithm));
        }

        if (xAmzCredential != null) {
            localVarHeaderParams.put("X-Amz-Credential", localVarApiClient.parameterToString(xAmzCredential));
        }

        if (xAmzSecurityToken != null) {
            localVarHeaderParams.put("X-Amz-Security-Token", localVarApiClient.parameterToString(xAmzSecurityToken));
        }

        if (xAmzSignature != null) {
            localVarHeaderParams.put("X-Amz-Signature", localVarApiClient.parameterToString(xAmzSignature));
        }

        if (xAmzSignedHeaders != null) {
            localVarHeaderParams.put("X-Amz-SignedHeaders", localVarApiClient.parameterToString(xAmzSignedHeaders));
        }

        final String[] localVarAccepts = {
            "text/xml"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            "text/xml"
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "hmac" };
        return localVarApiClient.buildCall(basePath, localVarPath, "POST", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call pOSTModifyClusterSnapshotValidateBeforeCall(String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, ModifyClusterSnapshotMessage modifyClusterSnapshotMessage, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'action' is set
        if (action == null) {
            throw new ApiException("Missing the required parameter 'action' when calling pOSTModifyClusterSnapshot(Async)");
        }

        // verify the required parameter 'version' is set
        if (version == null) {
            throw new ApiException("Missing the required parameter 'version' when calling pOSTModifyClusterSnapshot(Async)");
        }

        return pOSTModifyClusterSnapshotCall(action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, modifyClusterSnapshotMessage, _callback);

    }

    /**
     * 
     * &lt;p&gt;Modifies the settings for a snapshot.&lt;/p&gt; &lt;p&gt;This exanmple modifies the manual retention period setting for a cluster snapshot.&lt;/p&gt;
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param modifyClusterSnapshotMessage  (optional)
     * @return ModifyClusterSnapshotResult
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> InvalidClusterSnapshotStateFault </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> ClusterSnapshotNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 482 </td><td> InvalidRetentionPeriodFault </td><td>  -  </td></tr>
     </table>
     */
    public ModifyClusterSnapshotResult pOSTModifyClusterSnapshot(String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, ModifyClusterSnapshotMessage modifyClusterSnapshotMessage) throws ApiException {
        ApiResponse<ModifyClusterSnapshotResult> localVarResp = pOSTModifyClusterSnapshotWithHttpInfo(action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, modifyClusterSnapshotMessage);
        return localVarResp.getData();
    }

    /**
     * 
     * &lt;p&gt;Modifies the settings for a snapshot.&lt;/p&gt; &lt;p&gt;This exanmple modifies the manual retention period setting for a cluster snapshot.&lt;/p&gt;
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param modifyClusterSnapshotMessage  (optional)
     * @return ApiResponse&lt;ModifyClusterSnapshotResult&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> InvalidClusterSnapshotStateFault </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> ClusterSnapshotNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 482 </td><td> InvalidRetentionPeriodFault </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<ModifyClusterSnapshotResult> pOSTModifyClusterSnapshotWithHttpInfo(String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, ModifyClusterSnapshotMessage modifyClusterSnapshotMessage) throws ApiException {
        okhttp3.Call localVarCall = pOSTModifyClusterSnapshotValidateBeforeCall(action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, modifyClusterSnapshotMessage, null);
        Type localVarReturnType = new TypeToken<ModifyClusterSnapshotResult>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     *  (asynchronously)
     * &lt;p&gt;Modifies the settings for a snapshot.&lt;/p&gt; &lt;p&gt;This exanmple modifies the manual retention period setting for a cluster snapshot.&lt;/p&gt;
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param modifyClusterSnapshotMessage  (optional)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> InvalidClusterSnapshotStateFault </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> ClusterSnapshotNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 482 </td><td> InvalidRetentionPeriodFault </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call pOSTModifyClusterSnapshotAsync(String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, ModifyClusterSnapshotMessage modifyClusterSnapshotMessage, final ApiCallback<ModifyClusterSnapshotResult> _callback) throws ApiException {

        okhttp3.Call localVarCall = pOSTModifyClusterSnapshotValidateBeforeCall(action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, modifyClusterSnapshotMessage, _callback);
        Type localVarReturnType = new TypeToken<ModifyClusterSnapshotResult>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for pOSTModifyClusterSnapshotSchedule
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param modifyClusterSnapshotScheduleMessage  (optional)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> ClusterNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> SnapshotScheduleNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 482 </td><td> InvalidClusterSnapshotScheduleStateFault </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call pOSTModifyClusterSnapshotScheduleCall(String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, ModifyClusterSnapshotScheduleMessage modifyClusterSnapshotScheduleMessage, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = modifyClusterSnapshotScheduleMessage;

        // create path and map variables
        String localVarPath = "/#Action=ModifyClusterSnapshotSchedule";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (action != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("Action", action));
        }

        if (version != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("Version", version));
        }

        if (xAmzContentSha256 != null) {
            localVarHeaderParams.put("X-Amz-Content-Sha256", localVarApiClient.parameterToString(xAmzContentSha256));
        }

        if (xAmzDate != null) {
            localVarHeaderParams.put("X-Amz-Date", localVarApiClient.parameterToString(xAmzDate));
        }

        if (xAmzAlgorithm != null) {
            localVarHeaderParams.put("X-Amz-Algorithm", localVarApiClient.parameterToString(xAmzAlgorithm));
        }

        if (xAmzCredential != null) {
            localVarHeaderParams.put("X-Amz-Credential", localVarApiClient.parameterToString(xAmzCredential));
        }

        if (xAmzSecurityToken != null) {
            localVarHeaderParams.put("X-Amz-Security-Token", localVarApiClient.parameterToString(xAmzSecurityToken));
        }

        if (xAmzSignature != null) {
            localVarHeaderParams.put("X-Amz-Signature", localVarApiClient.parameterToString(xAmzSignature));
        }

        if (xAmzSignedHeaders != null) {
            localVarHeaderParams.put("X-Amz-SignedHeaders", localVarApiClient.parameterToString(xAmzSignedHeaders));
        }

        final String[] localVarAccepts = {
            "text/xml"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            "text/xml"
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "hmac" };
        return localVarApiClient.buildCall(basePath, localVarPath, "POST", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call pOSTModifyClusterSnapshotScheduleValidateBeforeCall(String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, ModifyClusterSnapshotScheduleMessage modifyClusterSnapshotScheduleMessage, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'action' is set
        if (action == null) {
            throw new ApiException("Missing the required parameter 'action' when calling pOSTModifyClusterSnapshotSchedule(Async)");
        }

        // verify the required parameter 'version' is set
        if (version == null) {
            throw new ApiException("Missing the required parameter 'version' when calling pOSTModifyClusterSnapshotSchedule(Async)");
        }

        return pOSTModifyClusterSnapshotScheduleCall(action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, modifyClusterSnapshotScheduleMessage, _callback);

    }

    /**
     * 
     * Modifies a snapshot schedule for a cluster.
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param modifyClusterSnapshotScheduleMessage  (optional)
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> ClusterNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> SnapshotScheduleNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 482 </td><td> InvalidClusterSnapshotScheduleStateFault </td><td>  -  </td></tr>
     </table>
     */
    public void pOSTModifyClusterSnapshotSchedule(String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, ModifyClusterSnapshotScheduleMessage modifyClusterSnapshotScheduleMessage) throws ApiException {
        pOSTModifyClusterSnapshotScheduleWithHttpInfo(action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, modifyClusterSnapshotScheduleMessage);
    }

    /**
     * 
     * Modifies a snapshot schedule for a cluster.
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param modifyClusterSnapshotScheduleMessage  (optional)
     * @return ApiResponse&lt;Void&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> ClusterNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> SnapshotScheduleNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 482 </td><td> InvalidClusterSnapshotScheduleStateFault </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<Void> pOSTModifyClusterSnapshotScheduleWithHttpInfo(String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, ModifyClusterSnapshotScheduleMessage modifyClusterSnapshotScheduleMessage) throws ApiException {
        okhttp3.Call localVarCall = pOSTModifyClusterSnapshotScheduleValidateBeforeCall(action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, modifyClusterSnapshotScheduleMessage, null);
        return localVarApiClient.execute(localVarCall);
    }

    /**
     *  (asynchronously)
     * Modifies a snapshot schedule for a cluster.
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param modifyClusterSnapshotScheduleMessage  (optional)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> ClusterNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> SnapshotScheduleNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 482 </td><td> InvalidClusterSnapshotScheduleStateFault </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call pOSTModifyClusterSnapshotScheduleAsync(String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, ModifyClusterSnapshotScheduleMessage modifyClusterSnapshotScheduleMessage, final ApiCallback<Void> _callback) throws ApiException {

        okhttp3.Call localVarCall = pOSTModifyClusterSnapshotScheduleValidateBeforeCall(action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, modifyClusterSnapshotScheduleMessage, _callback);
        localVarApiClient.executeAsync(localVarCall, _callback);
        return localVarCall;
    }
    /**
     * Build call for pOSTModifyClusterSubnetGroup
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param modifyClusterSubnetGroupMessage  (optional)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> ClusterSubnetGroupNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> ClusterSubnetQuotaExceededFault </td><td>  -  </td></tr>
        <tr><td> 482 </td><td> SubnetAlreadyInUse </td><td>  -  </td></tr>
        <tr><td> 483 </td><td> InvalidSubnet </td><td>  -  </td></tr>
        <tr><td> 484 </td><td> UnauthorizedOperation </td><td>  -  </td></tr>
        <tr><td> 485 </td><td> DependentServiceRequestThrottlingFault </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call pOSTModifyClusterSubnetGroupCall(String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, ModifyClusterSubnetGroupMessage modifyClusterSubnetGroupMessage, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = modifyClusterSubnetGroupMessage;

        // create path and map variables
        String localVarPath = "/#Action=ModifyClusterSubnetGroup";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (action != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("Action", action));
        }

        if (version != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("Version", version));
        }

        if (xAmzContentSha256 != null) {
            localVarHeaderParams.put("X-Amz-Content-Sha256", localVarApiClient.parameterToString(xAmzContentSha256));
        }

        if (xAmzDate != null) {
            localVarHeaderParams.put("X-Amz-Date", localVarApiClient.parameterToString(xAmzDate));
        }

        if (xAmzAlgorithm != null) {
            localVarHeaderParams.put("X-Amz-Algorithm", localVarApiClient.parameterToString(xAmzAlgorithm));
        }

        if (xAmzCredential != null) {
            localVarHeaderParams.put("X-Amz-Credential", localVarApiClient.parameterToString(xAmzCredential));
        }

        if (xAmzSecurityToken != null) {
            localVarHeaderParams.put("X-Amz-Security-Token", localVarApiClient.parameterToString(xAmzSecurityToken));
        }

        if (xAmzSignature != null) {
            localVarHeaderParams.put("X-Amz-Signature", localVarApiClient.parameterToString(xAmzSignature));
        }

        if (xAmzSignedHeaders != null) {
            localVarHeaderParams.put("X-Amz-SignedHeaders", localVarApiClient.parameterToString(xAmzSignedHeaders));
        }

        final String[] localVarAccepts = {
            "text/xml"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            "text/xml"
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "hmac" };
        return localVarApiClient.buildCall(basePath, localVarPath, "POST", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call pOSTModifyClusterSubnetGroupValidateBeforeCall(String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, ModifyClusterSubnetGroupMessage modifyClusterSubnetGroupMessage, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'action' is set
        if (action == null) {
            throw new ApiException("Missing the required parameter 'action' when calling pOSTModifyClusterSubnetGroup(Async)");
        }

        // verify the required parameter 'version' is set
        if (version == null) {
            throw new ApiException("Missing the required parameter 'version' when calling pOSTModifyClusterSubnetGroup(Async)");
        }

        return pOSTModifyClusterSubnetGroupCall(action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, modifyClusterSubnetGroupMessage, _callback);

    }

    /**
     * 
     * Modifies a cluster subnet group to include the specified list of VPC subnets. The operation replaces the existing list of subnets with the new list of subnets.
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param modifyClusterSubnetGroupMessage  (optional)
     * @return ModifyClusterSubnetGroupResult
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> ClusterSubnetGroupNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> ClusterSubnetQuotaExceededFault </td><td>  -  </td></tr>
        <tr><td> 482 </td><td> SubnetAlreadyInUse </td><td>  -  </td></tr>
        <tr><td> 483 </td><td> InvalidSubnet </td><td>  -  </td></tr>
        <tr><td> 484 </td><td> UnauthorizedOperation </td><td>  -  </td></tr>
        <tr><td> 485 </td><td> DependentServiceRequestThrottlingFault </td><td>  -  </td></tr>
     </table>
     */
    public ModifyClusterSubnetGroupResult pOSTModifyClusterSubnetGroup(String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, ModifyClusterSubnetGroupMessage modifyClusterSubnetGroupMessage) throws ApiException {
        ApiResponse<ModifyClusterSubnetGroupResult> localVarResp = pOSTModifyClusterSubnetGroupWithHttpInfo(action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, modifyClusterSubnetGroupMessage);
        return localVarResp.getData();
    }

    /**
     * 
     * Modifies a cluster subnet group to include the specified list of VPC subnets. The operation replaces the existing list of subnets with the new list of subnets.
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param modifyClusterSubnetGroupMessage  (optional)
     * @return ApiResponse&lt;ModifyClusterSubnetGroupResult&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> ClusterSubnetGroupNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> ClusterSubnetQuotaExceededFault </td><td>  -  </td></tr>
        <tr><td> 482 </td><td> SubnetAlreadyInUse </td><td>  -  </td></tr>
        <tr><td> 483 </td><td> InvalidSubnet </td><td>  -  </td></tr>
        <tr><td> 484 </td><td> UnauthorizedOperation </td><td>  -  </td></tr>
        <tr><td> 485 </td><td> DependentServiceRequestThrottlingFault </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<ModifyClusterSubnetGroupResult> pOSTModifyClusterSubnetGroupWithHttpInfo(String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, ModifyClusterSubnetGroupMessage modifyClusterSubnetGroupMessage) throws ApiException {
        okhttp3.Call localVarCall = pOSTModifyClusterSubnetGroupValidateBeforeCall(action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, modifyClusterSubnetGroupMessage, null);
        Type localVarReturnType = new TypeToken<ModifyClusterSubnetGroupResult>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     *  (asynchronously)
     * Modifies a cluster subnet group to include the specified list of VPC subnets. The operation replaces the existing list of subnets with the new list of subnets.
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param modifyClusterSubnetGroupMessage  (optional)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> ClusterSubnetGroupNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> ClusterSubnetQuotaExceededFault </td><td>  -  </td></tr>
        <tr><td> 482 </td><td> SubnetAlreadyInUse </td><td>  -  </td></tr>
        <tr><td> 483 </td><td> InvalidSubnet </td><td>  -  </td></tr>
        <tr><td> 484 </td><td> UnauthorizedOperation </td><td>  -  </td></tr>
        <tr><td> 485 </td><td> DependentServiceRequestThrottlingFault </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call pOSTModifyClusterSubnetGroupAsync(String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, ModifyClusterSubnetGroupMessage modifyClusterSubnetGroupMessage, final ApiCallback<ModifyClusterSubnetGroupResult> _callback) throws ApiException {

        okhttp3.Call localVarCall = pOSTModifyClusterSubnetGroupValidateBeforeCall(action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, modifyClusterSubnetGroupMessage, _callback);
        Type localVarReturnType = new TypeToken<ModifyClusterSubnetGroupResult>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for pOSTModifyCustomDomainAssociation
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param modifyCustomDomainAssociationMessage  (optional)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> UnsupportedOperationFault </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> ClusterNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 482 </td><td> CustomCnameAssociationFault </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call pOSTModifyCustomDomainAssociationCall(String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, ModifyCustomDomainAssociationMessage modifyCustomDomainAssociationMessage, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = modifyCustomDomainAssociationMessage;

        // create path and map variables
        String localVarPath = "/#Action=ModifyCustomDomainAssociation";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (action != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("Action", action));
        }

        if (version != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("Version", version));
        }

        if (xAmzContentSha256 != null) {
            localVarHeaderParams.put("X-Amz-Content-Sha256", localVarApiClient.parameterToString(xAmzContentSha256));
        }

        if (xAmzDate != null) {
            localVarHeaderParams.put("X-Amz-Date", localVarApiClient.parameterToString(xAmzDate));
        }

        if (xAmzAlgorithm != null) {
            localVarHeaderParams.put("X-Amz-Algorithm", localVarApiClient.parameterToString(xAmzAlgorithm));
        }

        if (xAmzCredential != null) {
            localVarHeaderParams.put("X-Amz-Credential", localVarApiClient.parameterToString(xAmzCredential));
        }

        if (xAmzSecurityToken != null) {
            localVarHeaderParams.put("X-Amz-Security-Token", localVarApiClient.parameterToString(xAmzSecurityToken));
        }

        if (xAmzSignature != null) {
            localVarHeaderParams.put("X-Amz-Signature", localVarApiClient.parameterToString(xAmzSignature));
        }

        if (xAmzSignedHeaders != null) {
            localVarHeaderParams.put("X-Amz-SignedHeaders", localVarApiClient.parameterToString(xAmzSignedHeaders));
        }

        final String[] localVarAccepts = {
            "text/xml"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            "text/xml"
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "hmac" };
        return localVarApiClient.buildCall(basePath, localVarPath, "POST", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call pOSTModifyCustomDomainAssociationValidateBeforeCall(String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, ModifyCustomDomainAssociationMessage modifyCustomDomainAssociationMessage, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'action' is set
        if (action == null) {
            throw new ApiException("Missing the required parameter 'action' when calling pOSTModifyCustomDomainAssociation(Async)");
        }

        // verify the required parameter 'version' is set
        if (version == null) {
            throw new ApiException("Missing the required parameter 'version' when calling pOSTModifyCustomDomainAssociation(Async)");
        }

        return pOSTModifyCustomDomainAssociationCall(action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, modifyCustomDomainAssociationMessage, _callback);

    }

    /**
     * 
     * Contains information for changing a custom domain association.
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param modifyCustomDomainAssociationMessage  (optional)
     * @return ModifyCustomDomainAssociationResult
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> UnsupportedOperationFault </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> ClusterNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 482 </td><td> CustomCnameAssociationFault </td><td>  -  </td></tr>
     </table>
     */
    public ModifyCustomDomainAssociationResult pOSTModifyCustomDomainAssociation(String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, ModifyCustomDomainAssociationMessage modifyCustomDomainAssociationMessage) throws ApiException {
        ApiResponse<ModifyCustomDomainAssociationResult> localVarResp = pOSTModifyCustomDomainAssociationWithHttpInfo(action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, modifyCustomDomainAssociationMessage);
        return localVarResp.getData();
    }

    /**
     * 
     * Contains information for changing a custom domain association.
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param modifyCustomDomainAssociationMessage  (optional)
     * @return ApiResponse&lt;ModifyCustomDomainAssociationResult&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> UnsupportedOperationFault </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> ClusterNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 482 </td><td> CustomCnameAssociationFault </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<ModifyCustomDomainAssociationResult> pOSTModifyCustomDomainAssociationWithHttpInfo(String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, ModifyCustomDomainAssociationMessage modifyCustomDomainAssociationMessage) throws ApiException {
        okhttp3.Call localVarCall = pOSTModifyCustomDomainAssociationValidateBeforeCall(action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, modifyCustomDomainAssociationMessage, null);
        Type localVarReturnType = new TypeToken<ModifyCustomDomainAssociationResult>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     *  (asynchronously)
     * Contains information for changing a custom domain association.
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param modifyCustomDomainAssociationMessage  (optional)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> UnsupportedOperationFault </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> ClusterNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 482 </td><td> CustomCnameAssociationFault </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call pOSTModifyCustomDomainAssociationAsync(String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, ModifyCustomDomainAssociationMessage modifyCustomDomainAssociationMessage, final ApiCallback<ModifyCustomDomainAssociationResult> _callback) throws ApiException {

        okhttp3.Call localVarCall = pOSTModifyCustomDomainAssociationValidateBeforeCall(action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, modifyCustomDomainAssociationMessage, _callback);
        Type localVarReturnType = new TypeToken<ModifyCustomDomainAssociationResult>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for pOSTModifyEndpointAccess
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param modifyEndpointAccessMessage  (optional)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> InvalidClusterSecurityGroupStateFault </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> ClusterNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 482 </td><td> InvalidEndpointStateFault </td><td>  -  </td></tr>
        <tr><td> 483 </td><td> EndpointNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 484 </td><td> InvalidClusterStateFault </td><td>  -  </td></tr>
        <tr><td> 485 </td><td> UnauthorizedOperation </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call pOSTModifyEndpointAccessCall(String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, ModifyEndpointAccessMessage modifyEndpointAccessMessage, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = modifyEndpointAccessMessage;

        // create path and map variables
        String localVarPath = "/#Action=ModifyEndpointAccess";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (action != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("Action", action));
        }

        if (version != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("Version", version));
        }

        if (xAmzContentSha256 != null) {
            localVarHeaderParams.put("X-Amz-Content-Sha256", localVarApiClient.parameterToString(xAmzContentSha256));
        }

        if (xAmzDate != null) {
            localVarHeaderParams.put("X-Amz-Date", localVarApiClient.parameterToString(xAmzDate));
        }

        if (xAmzAlgorithm != null) {
            localVarHeaderParams.put("X-Amz-Algorithm", localVarApiClient.parameterToString(xAmzAlgorithm));
        }

        if (xAmzCredential != null) {
            localVarHeaderParams.put("X-Amz-Credential", localVarApiClient.parameterToString(xAmzCredential));
        }

        if (xAmzSecurityToken != null) {
            localVarHeaderParams.put("X-Amz-Security-Token", localVarApiClient.parameterToString(xAmzSecurityToken));
        }

        if (xAmzSignature != null) {
            localVarHeaderParams.put("X-Amz-Signature", localVarApiClient.parameterToString(xAmzSignature));
        }

        if (xAmzSignedHeaders != null) {
            localVarHeaderParams.put("X-Amz-SignedHeaders", localVarApiClient.parameterToString(xAmzSignedHeaders));
        }

        final String[] localVarAccepts = {
            "text/xml"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            "text/xml"
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "hmac" };
        return localVarApiClient.buildCall(basePath, localVarPath, "POST", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call pOSTModifyEndpointAccessValidateBeforeCall(String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, ModifyEndpointAccessMessage modifyEndpointAccessMessage, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'action' is set
        if (action == null) {
            throw new ApiException("Missing the required parameter 'action' when calling pOSTModifyEndpointAccess(Async)");
        }

        // verify the required parameter 'version' is set
        if (version == null) {
            throw new ApiException("Missing the required parameter 'version' when calling pOSTModifyEndpointAccess(Async)");
        }

        return pOSTModifyEndpointAccessCall(action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, modifyEndpointAccessMessage, _callback);

    }

    /**
     * 
     * Modifies a Redshift-managed VPC endpoint.
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param modifyEndpointAccessMessage  (optional)
     * @return EndpointAccess
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> InvalidClusterSecurityGroupStateFault </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> ClusterNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 482 </td><td> InvalidEndpointStateFault </td><td>  -  </td></tr>
        <tr><td> 483 </td><td> EndpointNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 484 </td><td> InvalidClusterStateFault </td><td>  -  </td></tr>
        <tr><td> 485 </td><td> UnauthorizedOperation </td><td>  -  </td></tr>
     </table>
     */
    public EndpointAccess pOSTModifyEndpointAccess(String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, ModifyEndpointAccessMessage modifyEndpointAccessMessage) throws ApiException {
        ApiResponse<EndpointAccess> localVarResp = pOSTModifyEndpointAccessWithHttpInfo(action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, modifyEndpointAccessMessage);
        return localVarResp.getData();
    }

    /**
     * 
     * Modifies a Redshift-managed VPC endpoint.
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param modifyEndpointAccessMessage  (optional)
     * @return ApiResponse&lt;EndpointAccess&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> InvalidClusterSecurityGroupStateFault </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> ClusterNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 482 </td><td> InvalidEndpointStateFault </td><td>  -  </td></tr>
        <tr><td> 483 </td><td> EndpointNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 484 </td><td> InvalidClusterStateFault </td><td>  -  </td></tr>
        <tr><td> 485 </td><td> UnauthorizedOperation </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<EndpointAccess> pOSTModifyEndpointAccessWithHttpInfo(String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, ModifyEndpointAccessMessage modifyEndpointAccessMessage) throws ApiException {
        okhttp3.Call localVarCall = pOSTModifyEndpointAccessValidateBeforeCall(action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, modifyEndpointAccessMessage, null);
        Type localVarReturnType = new TypeToken<EndpointAccess>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     *  (asynchronously)
     * Modifies a Redshift-managed VPC endpoint.
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param modifyEndpointAccessMessage  (optional)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> InvalidClusterSecurityGroupStateFault </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> ClusterNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 482 </td><td> InvalidEndpointStateFault </td><td>  -  </td></tr>
        <tr><td> 483 </td><td> EndpointNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 484 </td><td> InvalidClusterStateFault </td><td>  -  </td></tr>
        <tr><td> 485 </td><td> UnauthorizedOperation </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call pOSTModifyEndpointAccessAsync(String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, ModifyEndpointAccessMessage modifyEndpointAccessMessage, final ApiCallback<EndpointAccess> _callback) throws ApiException {

        okhttp3.Call localVarCall = pOSTModifyEndpointAccessValidateBeforeCall(action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, modifyEndpointAccessMessage, _callback);
        Type localVarReturnType = new TypeToken<EndpointAccess>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for pOSTModifyEventSubscription
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param modifyEventSubscriptionMessage  (optional)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> SubscriptionNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> SNSInvalidTopicFault </td><td>  -  </td></tr>
        <tr><td> 482 </td><td> SNSNoAuthorizationFault </td><td>  -  </td></tr>
        <tr><td> 483 </td><td> SNSTopicArnNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 484 </td><td> SubscriptionEventIdNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 485 </td><td> SubscriptionCategoryNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 486 </td><td> SubscriptionSeverityNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 487 </td><td> SourceNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 488 </td><td> InvalidSubscriptionStateFault </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call pOSTModifyEventSubscriptionCall(String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, ModifyEventSubscriptionMessage modifyEventSubscriptionMessage, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = modifyEventSubscriptionMessage;

        // create path and map variables
        String localVarPath = "/#Action=ModifyEventSubscription";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (action != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("Action", action));
        }

        if (version != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("Version", version));
        }

        if (xAmzContentSha256 != null) {
            localVarHeaderParams.put("X-Amz-Content-Sha256", localVarApiClient.parameterToString(xAmzContentSha256));
        }

        if (xAmzDate != null) {
            localVarHeaderParams.put("X-Amz-Date", localVarApiClient.parameterToString(xAmzDate));
        }

        if (xAmzAlgorithm != null) {
            localVarHeaderParams.put("X-Amz-Algorithm", localVarApiClient.parameterToString(xAmzAlgorithm));
        }

        if (xAmzCredential != null) {
            localVarHeaderParams.put("X-Amz-Credential", localVarApiClient.parameterToString(xAmzCredential));
        }

        if (xAmzSecurityToken != null) {
            localVarHeaderParams.put("X-Amz-Security-Token", localVarApiClient.parameterToString(xAmzSecurityToken));
        }

        if (xAmzSignature != null) {
            localVarHeaderParams.put("X-Amz-Signature", localVarApiClient.parameterToString(xAmzSignature));
        }

        if (xAmzSignedHeaders != null) {
            localVarHeaderParams.put("X-Amz-SignedHeaders", localVarApiClient.parameterToString(xAmzSignedHeaders));
        }

        final String[] localVarAccepts = {
            "text/xml"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            "text/xml"
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "hmac" };
        return localVarApiClient.buildCall(basePath, localVarPath, "POST", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call pOSTModifyEventSubscriptionValidateBeforeCall(String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, ModifyEventSubscriptionMessage modifyEventSubscriptionMessage, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'action' is set
        if (action == null) {
            throw new ApiException("Missing the required parameter 'action' when calling pOSTModifyEventSubscription(Async)");
        }

        // verify the required parameter 'version' is set
        if (version == null) {
            throw new ApiException("Missing the required parameter 'version' when calling pOSTModifyEventSubscription(Async)");
        }

        return pOSTModifyEventSubscriptionCall(action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, modifyEventSubscriptionMessage, _callback);

    }

    /**
     * 
     * Modifies an existing Amazon Redshift event notification subscription.
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param modifyEventSubscriptionMessage  (optional)
     * @return ModifyEventSubscriptionResult
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> SubscriptionNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> SNSInvalidTopicFault </td><td>  -  </td></tr>
        <tr><td> 482 </td><td> SNSNoAuthorizationFault </td><td>  -  </td></tr>
        <tr><td> 483 </td><td> SNSTopicArnNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 484 </td><td> SubscriptionEventIdNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 485 </td><td> SubscriptionCategoryNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 486 </td><td> SubscriptionSeverityNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 487 </td><td> SourceNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 488 </td><td> InvalidSubscriptionStateFault </td><td>  -  </td></tr>
     </table>
     */
    public ModifyEventSubscriptionResult pOSTModifyEventSubscription(String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, ModifyEventSubscriptionMessage modifyEventSubscriptionMessage) throws ApiException {
        ApiResponse<ModifyEventSubscriptionResult> localVarResp = pOSTModifyEventSubscriptionWithHttpInfo(action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, modifyEventSubscriptionMessage);
        return localVarResp.getData();
    }

    /**
     * 
     * Modifies an existing Amazon Redshift event notification subscription.
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param modifyEventSubscriptionMessage  (optional)
     * @return ApiResponse&lt;ModifyEventSubscriptionResult&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> SubscriptionNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> SNSInvalidTopicFault </td><td>  -  </td></tr>
        <tr><td> 482 </td><td> SNSNoAuthorizationFault </td><td>  -  </td></tr>
        <tr><td> 483 </td><td> SNSTopicArnNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 484 </td><td> SubscriptionEventIdNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 485 </td><td> SubscriptionCategoryNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 486 </td><td> SubscriptionSeverityNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 487 </td><td> SourceNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 488 </td><td> InvalidSubscriptionStateFault </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<ModifyEventSubscriptionResult> pOSTModifyEventSubscriptionWithHttpInfo(String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, ModifyEventSubscriptionMessage modifyEventSubscriptionMessage) throws ApiException {
        okhttp3.Call localVarCall = pOSTModifyEventSubscriptionValidateBeforeCall(action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, modifyEventSubscriptionMessage, null);
        Type localVarReturnType = new TypeToken<ModifyEventSubscriptionResult>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     *  (asynchronously)
     * Modifies an existing Amazon Redshift event notification subscription.
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param modifyEventSubscriptionMessage  (optional)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> SubscriptionNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> SNSInvalidTopicFault </td><td>  -  </td></tr>
        <tr><td> 482 </td><td> SNSNoAuthorizationFault </td><td>  -  </td></tr>
        <tr><td> 483 </td><td> SNSTopicArnNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 484 </td><td> SubscriptionEventIdNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 485 </td><td> SubscriptionCategoryNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 486 </td><td> SubscriptionSeverityNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 487 </td><td> SourceNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 488 </td><td> InvalidSubscriptionStateFault </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call pOSTModifyEventSubscriptionAsync(String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, ModifyEventSubscriptionMessage modifyEventSubscriptionMessage, final ApiCallback<ModifyEventSubscriptionResult> _callback) throws ApiException {

        okhttp3.Call localVarCall = pOSTModifyEventSubscriptionValidateBeforeCall(action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, modifyEventSubscriptionMessage, _callback);
        Type localVarReturnType = new TypeToken<ModifyEventSubscriptionResult>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for pOSTModifyScheduledAction
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param modifyScheduledActionMessage  (optional)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> ScheduledActionNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> ScheduledActionTypeUnsupportedFault </td><td>  -  </td></tr>
        <tr><td> 482 </td><td> InvalidScheduleFault </td><td>  -  </td></tr>
        <tr><td> 483 </td><td> InvalidScheduledActionFault </td><td>  -  </td></tr>
        <tr><td> 484 </td><td> UnauthorizedOperation </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call pOSTModifyScheduledActionCall(String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, ModifyScheduledActionMessage modifyScheduledActionMessage, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = modifyScheduledActionMessage;

        // create path and map variables
        String localVarPath = "/#Action=ModifyScheduledAction";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (action != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("Action", action));
        }

        if (version != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("Version", version));
        }

        if (xAmzContentSha256 != null) {
            localVarHeaderParams.put("X-Amz-Content-Sha256", localVarApiClient.parameterToString(xAmzContentSha256));
        }

        if (xAmzDate != null) {
            localVarHeaderParams.put("X-Amz-Date", localVarApiClient.parameterToString(xAmzDate));
        }

        if (xAmzAlgorithm != null) {
            localVarHeaderParams.put("X-Amz-Algorithm", localVarApiClient.parameterToString(xAmzAlgorithm));
        }

        if (xAmzCredential != null) {
            localVarHeaderParams.put("X-Amz-Credential", localVarApiClient.parameterToString(xAmzCredential));
        }

        if (xAmzSecurityToken != null) {
            localVarHeaderParams.put("X-Amz-Security-Token", localVarApiClient.parameterToString(xAmzSecurityToken));
        }

        if (xAmzSignature != null) {
            localVarHeaderParams.put("X-Amz-Signature", localVarApiClient.parameterToString(xAmzSignature));
        }

        if (xAmzSignedHeaders != null) {
            localVarHeaderParams.put("X-Amz-SignedHeaders", localVarApiClient.parameterToString(xAmzSignedHeaders));
        }

        final String[] localVarAccepts = {
            "text/xml"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            "text/xml"
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "hmac" };
        return localVarApiClient.buildCall(basePath, localVarPath, "POST", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call pOSTModifyScheduledActionValidateBeforeCall(String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, ModifyScheduledActionMessage modifyScheduledActionMessage, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'action' is set
        if (action == null) {
            throw new ApiException("Missing the required parameter 'action' when calling pOSTModifyScheduledAction(Async)");
        }

        // verify the required parameter 'version' is set
        if (version == null) {
            throw new ApiException("Missing the required parameter 'version' when calling pOSTModifyScheduledAction(Async)");
        }

        return pOSTModifyScheduledActionCall(action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, modifyScheduledActionMessage, _callback);

    }

    /**
     * 
     * Modifies a scheduled action. 
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param modifyScheduledActionMessage  (optional)
     * @return ScheduledAction
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> ScheduledActionNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> ScheduledActionTypeUnsupportedFault </td><td>  -  </td></tr>
        <tr><td> 482 </td><td> InvalidScheduleFault </td><td>  -  </td></tr>
        <tr><td> 483 </td><td> InvalidScheduledActionFault </td><td>  -  </td></tr>
        <tr><td> 484 </td><td> UnauthorizedOperation </td><td>  -  </td></tr>
     </table>
     */
    public ScheduledAction pOSTModifyScheduledAction(String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, ModifyScheduledActionMessage modifyScheduledActionMessage) throws ApiException {
        ApiResponse<ScheduledAction> localVarResp = pOSTModifyScheduledActionWithHttpInfo(action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, modifyScheduledActionMessage);
        return localVarResp.getData();
    }

    /**
     * 
     * Modifies a scheduled action. 
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param modifyScheduledActionMessage  (optional)
     * @return ApiResponse&lt;ScheduledAction&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> ScheduledActionNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> ScheduledActionTypeUnsupportedFault </td><td>  -  </td></tr>
        <tr><td> 482 </td><td> InvalidScheduleFault </td><td>  -  </td></tr>
        <tr><td> 483 </td><td> InvalidScheduledActionFault </td><td>  -  </td></tr>
        <tr><td> 484 </td><td> UnauthorizedOperation </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<ScheduledAction> pOSTModifyScheduledActionWithHttpInfo(String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, ModifyScheduledActionMessage modifyScheduledActionMessage) throws ApiException {
        okhttp3.Call localVarCall = pOSTModifyScheduledActionValidateBeforeCall(action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, modifyScheduledActionMessage, null);
        Type localVarReturnType = new TypeToken<ScheduledAction>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     *  (asynchronously)
     * Modifies a scheduled action. 
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param modifyScheduledActionMessage  (optional)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> ScheduledActionNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> ScheduledActionTypeUnsupportedFault </td><td>  -  </td></tr>
        <tr><td> 482 </td><td> InvalidScheduleFault </td><td>  -  </td></tr>
        <tr><td> 483 </td><td> InvalidScheduledActionFault </td><td>  -  </td></tr>
        <tr><td> 484 </td><td> UnauthorizedOperation </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call pOSTModifyScheduledActionAsync(String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, ModifyScheduledActionMessage modifyScheduledActionMessage, final ApiCallback<ScheduledAction> _callback) throws ApiException {

        okhttp3.Call localVarCall = pOSTModifyScheduledActionValidateBeforeCall(action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, modifyScheduledActionMessage, _callback);
        Type localVarReturnType = new TypeToken<ScheduledAction>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for pOSTModifySnapshotCopyRetentionPeriod
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param modifySnapshotCopyRetentionPeriodMessage  (optional)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> ClusterNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> SnapshotCopyDisabledFault </td><td>  -  </td></tr>
        <tr><td> 482 </td><td> UnauthorizedOperation </td><td>  -  </td></tr>
        <tr><td> 483 </td><td> InvalidClusterStateFault </td><td>  -  </td></tr>
        <tr><td> 484 </td><td> InvalidRetentionPeriodFault </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call pOSTModifySnapshotCopyRetentionPeriodCall(String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, ModifySnapshotCopyRetentionPeriodMessage modifySnapshotCopyRetentionPeriodMessage, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = modifySnapshotCopyRetentionPeriodMessage;

        // create path and map variables
        String localVarPath = "/#Action=ModifySnapshotCopyRetentionPeriod";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (action != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("Action", action));
        }

        if (version != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("Version", version));
        }

        if (xAmzContentSha256 != null) {
            localVarHeaderParams.put("X-Amz-Content-Sha256", localVarApiClient.parameterToString(xAmzContentSha256));
        }

        if (xAmzDate != null) {
            localVarHeaderParams.put("X-Amz-Date", localVarApiClient.parameterToString(xAmzDate));
        }

        if (xAmzAlgorithm != null) {
            localVarHeaderParams.put("X-Amz-Algorithm", localVarApiClient.parameterToString(xAmzAlgorithm));
        }

        if (xAmzCredential != null) {
            localVarHeaderParams.put("X-Amz-Credential", localVarApiClient.parameterToString(xAmzCredential));
        }

        if (xAmzSecurityToken != null) {
            localVarHeaderParams.put("X-Amz-Security-Token", localVarApiClient.parameterToString(xAmzSecurityToken));
        }

        if (xAmzSignature != null) {
            localVarHeaderParams.put("X-Amz-Signature", localVarApiClient.parameterToString(xAmzSignature));
        }

        if (xAmzSignedHeaders != null) {
            localVarHeaderParams.put("X-Amz-SignedHeaders", localVarApiClient.parameterToString(xAmzSignedHeaders));
        }

        final String[] localVarAccepts = {
            "text/xml"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            "text/xml"
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "hmac" };
        return localVarApiClient.buildCall(basePath, localVarPath, "POST", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call pOSTModifySnapshotCopyRetentionPeriodValidateBeforeCall(String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, ModifySnapshotCopyRetentionPeriodMessage modifySnapshotCopyRetentionPeriodMessage, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'action' is set
        if (action == null) {
            throw new ApiException("Missing the required parameter 'action' when calling pOSTModifySnapshotCopyRetentionPeriod(Async)");
        }

        // verify the required parameter 'version' is set
        if (version == null) {
            throw new ApiException("Missing the required parameter 'version' when calling pOSTModifySnapshotCopyRetentionPeriod(Async)");
        }

        return pOSTModifySnapshotCopyRetentionPeriodCall(action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, modifySnapshotCopyRetentionPeriodMessage, _callback);

    }

    /**
     * 
     * Modifies the number of days to retain snapshots in the destination Amazon Web Services Region after they are copied from the source Amazon Web Services Region. By default, this operation only changes the retention period of copied automated snapshots. The retention periods for both new and existing copied automated snapshots are updated with the new retention period. You can set the manual option to change only the retention periods of copied manual snapshots. If you set this option, only newly copied manual snapshots have the new retention period. 
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param modifySnapshotCopyRetentionPeriodMessage  (optional)
     * @return ModifySnapshotCopyRetentionPeriodResult
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> ClusterNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> SnapshotCopyDisabledFault </td><td>  -  </td></tr>
        <tr><td> 482 </td><td> UnauthorizedOperation </td><td>  -  </td></tr>
        <tr><td> 483 </td><td> InvalidClusterStateFault </td><td>  -  </td></tr>
        <tr><td> 484 </td><td> InvalidRetentionPeriodFault </td><td>  -  </td></tr>
     </table>
     */
    public ModifySnapshotCopyRetentionPeriodResult pOSTModifySnapshotCopyRetentionPeriod(String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, ModifySnapshotCopyRetentionPeriodMessage modifySnapshotCopyRetentionPeriodMessage) throws ApiException {
        ApiResponse<ModifySnapshotCopyRetentionPeriodResult> localVarResp = pOSTModifySnapshotCopyRetentionPeriodWithHttpInfo(action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, modifySnapshotCopyRetentionPeriodMessage);
        return localVarResp.getData();
    }

    /**
     * 
     * Modifies the number of days to retain snapshots in the destination Amazon Web Services Region after they are copied from the source Amazon Web Services Region. By default, this operation only changes the retention period of copied automated snapshots. The retention periods for both new and existing copied automated snapshots are updated with the new retention period. You can set the manual option to change only the retention periods of copied manual snapshots. If you set this option, only newly copied manual snapshots have the new retention period. 
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param modifySnapshotCopyRetentionPeriodMessage  (optional)
     * @return ApiResponse&lt;ModifySnapshotCopyRetentionPeriodResult&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> ClusterNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> SnapshotCopyDisabledFault </td><td>  -  </td></tr>
        <tr><td> 482 </td><td> UnauthorizedOperation </td><td>  -  </td></tr>
        <tr><td> 483 </td><td> InvalidClusterStateFault </td><td>  -  </td></tr>
        <tr><td> 484 </td><td> InvalidRetentionPeriodFault </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<ModifySnapshotCopyRetentionPeriodResult> pOSTModifySnapshotCopyRetentionPeriodWithHttpInfo(String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, ModifySnapshotCopyRetentionPeriodMessage modifySnapshotCopyRetentionPeriodMessage) throws ApiException {
        okhttp3.Call localVarCall = pOSTModifySnapshotCopyRetentionPeriodValidateBeforeCall(action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, modifySnapshotCopyRetentionPeriodMessage, null);
        Type localVarReturnType = new TypeToken<ModifySnapshotCopyRetentionPeriodResult>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     *  (asynchronously)
     * Modifies the number of days to retain snapshots in the destination Amazon Web Services Region after they are copied from the source Amazon Web Services Region. By default, this operation only changes the retention period of copied automated snapshots. The retention periods for both new and existing copied automated snapshots are updated with the new retention period. You can set the manual option to change only the retention periods of copied manual snapshots. If you set this option, only newly copied manual snapshots have the new retention period. 
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param modifySnapshotCopyRetentionPeriodMessage  (optional)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> ClusterNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> SnapshotCopyDisabledFault </td><td>  -  </td></tr>
        <tr><td> 482 </td><td> UnauthorizedOperation </td><td>  -  </td></tr>
        <tr><td> 483 </td><td> InvalidClusterStateFault </td><td>  -  </td></tr>
        <tr><td> 484 </td><td> InvalidRetentionPeriodFault </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call pOSTModifySnapshotCopyRetentionPeriodAsync(String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, ModifySnapshotCopyRetentionPeriodMessage modifySnapshotCopyRetentionPeriodMessage, final ApiCallback<ModifySnapshotCopyRetentionPeriodResult> _callback) throws ApiException {

        okhttp3.Call localVarCall = pOSTModifySnapshotCopyRetentionPeriodValidateBeforeCall(action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, modifySnapshotCopyRetentionPeriodMessage, _callback);
        Type localVarReturnType = new TypeToken<ModifySnapshotCopyRetentionPeriodResult>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for pOSTModifySnapshotSchedule
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param modifySnapshotScheduleMessage  (optional)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> InvalidScheduleFault </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> SnapshotScheduleNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 482 </td><td> SnapshotScheduleUpdateInProgressFault </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call pOSTModifySnapshotScheduleCall(String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, ModifySnapshotScheduleMessage modifySnapshotScheduleMessage, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = modifySnapshotScheduleMessage;

        // create path and map variables
        String localVarPath = "/#Action=ModifySnapshotSchedule";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (action != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("Action", action));
        }

        if (version != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("Version", version));
        }

        if (xAmzContentSha256 != null) {
            localVarHeaderParams.put("X-Amz-Content-Sha256", localVarApiClient.parameterToString(xAmzContentSha256));
        }

        if (xAmzDate != null) {
            localVarHeaderParams.put("X-Amz-Date", localVarApiClient.parameterToString(xAmzDate));
        }

        if (xAmzAlgorithm != null) {
            localVarHeaderParams.put("X-Amz-Algorithm", localVarApiClient.parameterToString(xAmzAlgorithm));
        }

        if (xAmzCredential != null) {
            localVarHeaderParams.put("X-Amz-Credential", localVarApiClient.parameterToString(xAmzCredential));
        }

        if (xAmzSecurityToken != null) {
            localVarHeaderParams.put("X-Amz-Security-Token", localVarApiClient.parameterToString(xAmzSecurityToken));
        }

        if (xAmzSignature != null) {
            localVarHeaderParams.put("X-Amz-Signature", localVarApiClient.parameterToString(xAmzSignature));
        }

        if (xAmzSignedHeaders != null) {
            localVarHeaderParams.put("X-Amz-SignedHeaders", localVarApiClient.parameterToString(xAmzSignedHeaders));
        }

        final String[] localVarAccepts = {
            "text/xml"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            "text/xml"
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "hmac" };
        return localVarApiClient.buildCall(basePath, localVarPath, "POST", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call pOSTModifySnapshotScheduleValidateBeforeCall(String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, ModifySnapshotScheduleMessage modifySnapshotScheduleMessage, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'action' is set
        if (action == null) {
            throw new ApiException("Missing the required parameter 'action' when calling pOSTModifySnapshotSchedule(Async)");
        }

        // verify the required parameter 'version' is set
        if (version == null) {
            throw new ApiException("Missing the required parameter 'version' when calling pOSTModifySnapshotSchedule(Async)");
        }

        return pOSTModifySnapshotScheduleCall(action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, modifySnapshotScheduleMessage, _callback);

    }

    /**
     * 
     * Modifies a snapshot schedule. Any schedule associated with a cluster is modified asynchronously.
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param modifySnapshotScheduleMessage  (optional)
     * @return SnapshotSchedule
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> InvalidScheduleFault </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> SnapshotScheduleNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 482 </td><td> SnapshotScheduleUpdateInProgressFault </td><td>  -  </td></tr>
     </table>
     */
    public SnapshotSchedule pOSTModifySnapshotSchedule(String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, ModifySnapshotScheduleMessage modifySnapshotScheduleMessage) throws ApiException {
        ApiResponse<SnapshotSchedule> localVarResp = pOSTModifySnapshotScheduleWithHttpInfo(action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, modifySnapshotScheduleMessage);
        return localVarResp.getData();
    }

    /**
     * 
     * Modifies a snapshot schedule. Any schedule associated with a cluster is modified asynchronously.
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param modifySnapshotScheduleMessage  (optional)
     * @return ApiResponse&lt;SnapshotSchedule&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> InvalidScheduleFault </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> SnapshotScheduleNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 482 </td><td> SnapshotScheduleUpdateInProgressFault </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<SnapshotSchedule> pOSTModifySnapshotScheduleWithHttpInfo(String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, ModifySnapshotScheduleMessage modifySnapshotScheduleMessage) throws ApiException {
        okhttp3.Call localVarCall = pOSTModifySnapshotScheduleValidateBeforeCall(action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, modifySnapshotScheduleMessage, null);
        Type localVarReturnType = new TypeToken<SnapshotSchedule>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     *  (asynchronously)
     * Modifies a snapshot schedule. Any schedule associated with a cluster is modified asynchronously.
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param modifySnapshotScheduleMessage  (optional)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> InvalidScheduleFault </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> SnapshotScheduleNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 482 </td><td> SnapshotScheduleUpdateInProgressFault </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call pOSTModifySnapshotScheduleAsync(String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, ModifySnapshotScheduleMessage modifySnapshotScheduleMessage, final ApiCallback<SnapshotSchedule> _callback) throws ApiException {

        okhttp3.Call localVarCall = pOSTModifySnapshotScheduleValidateBeforeCall(action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, modifySnapshotScheduleMessage, _callback);
        Type localVarReturnType = new TypeToken<SnapshotSchedule>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for pOSTModifyUsageLimit
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param modifyUsageLimitMessage  (optional)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> InvalidUsageLimitFault </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> UsageLimitNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 482 </td><td> UnsupportedOperationFault </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call pOSTModifyUsageLimitCall(String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, ModifyUsageLimitMessage modifyUsageLimitMessage, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = modifyUsageLimitMessage;

        // create path and map variables
        String localVarPath = "/#Action=ModifyUsageLimit";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (action != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("Action", action));
        }

        if (version != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("Version", version));
        }

        if (xAmzContentSha256 != null) {
            localVarHeaderParams.put("X-Amz-Content-Sha256", localVarApiClient.parameterToString(xAmzContentSha256));
        }

        if (xAmzDate != null) {
            localVarHeaderParams.put("X-Amz-Date", localVarApiClient.parameterToString(xAmzDate));
        }

        if (xAmzAlgorithm != null) {
            localVarHeaderParams.put("X-Amz-Algorithm", localVarApiClient.parameterToString(xAmzAlgorithm));
        }

        if (xAmzCredential != null) {
            localVarHeaderParams.put("X-Amz-Credential", localVarApiClient.parameterToString(xAmzCredential));
        }

        if (xAmzSecurityToken != null) {
            localVarHeaderParams.put("X-Amz-Security-Token", localVarApiClient.parameterToString(xAmzSecurityToken));
        }

        if (xAmzSignature != null) {
            localVarHeaderParams.put("X-Amz-Signature", localVarApiClient.parameterToString(xAmzSignature));
        }

        if (xAmzSignedHeaders != null) {
            localVarHeaderParams.put("X-Amz-SignedHeaders", localVarApiClient.parameterToString(xAmzSignedHeaders));
        }

        final String[] localVarAccepts = {
            "text/xml"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            "text/xml"
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "hmac" };
        return localVarApiClient.buildCall(basePath, localVarPath, "POST", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call pOSTModifyUsageLimitValidateBeforeCall(String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, ModifyUsageLimitMessage modifyUsageLimitMessage, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'action' is set
        if (action == null) {
            throw new ApiException("Missing the required parameter 'action' when calling pOSTModifyUsageLimit(Async)");
        }

        // verify the required parameter 'version' is set
        if (version == null) {
            throw new ApiException("Missing the required parameter 'version' when calling pOSTModifyUsageLimit(Async)");
        }

        return pOSTModifyUsageLimitCall(action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, modifyUsageLimitMessage, _callback);

    }

    /**
     * 
     * Modifies a usage limit in a cluster. You can&#39;t modify the feature type or period of a usage limit.
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param modifyUsageLimitMessage  (optional)
     * @return UsageLimit
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> InvalidUsageLimitFault </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> UsageLimitNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 482 </td><td> UnsupportedOperationFault </td><td>  -  </td></tr>
     </table>
     */
    public UsageLimit pOSTModifyUsageLimit(String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, ModifyUsageLimitMessage modifyUsageLimitMessage) throws ApiException {
        ApiResponse<UsageLimit> localVarResp = pOSTModifyUsageLimitWithHttpInfo(action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, modifyUsageLimitMessage);
        return localVarResp.getData();
    }

    /**
     * 
     * Modifies a usage limit in a cluster. You can&#39;t modify the feature type or period of a usage limit.
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param modifyUsageLimitMessage  (optional)
     * @return ApiResponse&lt;UsageLimit&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> InvalidUsageLimitFault </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> UsageLimitNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 482 </td><td> UnsupportedOperationFault </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<UsageLimit> pOSTModifyUsageLimitWithHttpInfo(String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, ModifyUsageLimitMessage modifyUsageLimitMessage) throws ApiException {
        okhttp3.Call localVarCall = pOSTModifyUsageLimitValidateBeforeCall(action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, modifyUsageLimitMessage, null);
        Type localVarReturnType = new TypeToken<UsageLimit>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     *  (asynchronously)
     * Modifies a usage limit in a cluster. You can&#39;t modify the feature type or period of a usage limit.
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param modifyUsageLimitMessage  (optional)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> InvalidUsageLimitFault </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> UsageLimitNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 482 </td><td> UnsupportedOperationFault </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call pOSTModifyUsageLimitAsync(String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, ModifyUsageLimitMessage modifyUsageLimitMessage, final ApiCallback<UsageLimit> _callback) throws ApiException {

        okhttp3.Call localVarCall = pOSTModifyUsageLimitValidateBeforeCall(action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, modifyUsageLimitMessage, _callback);
        Type localVarReturnType = new TypeToken<UsageLimit>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for pOSTPauseCluster
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param pauseClusterMessage  (optional)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> ClusterNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> InvalidClusterStateFault </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call pOSTPauseClusterCall(String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, PauseClusterMessage pauseClusterMessage, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = pauseClusterMessage;

        // create path and map variables
        String localVarPath = "/#Action=PauseCluster";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (action != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("Action", action));
        }

        if (version != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("Version", version));
        }

        if (xAmzContentSha256 != null) {
            localVarHeaderParams.put("X-Amz-Content-Sha256", localVarApiClient.parameterToString(xAmzContentSha256));
        }

        if (xAmzDate != null) {
            localVarHeaderParams.put("X-Amz-Date", localVarApiClient.parameterToString(xAmzDate));
        }

        if (xAmzAlgorithm != null) {
            localVarHeaderParams.put("X-Amz-Algorithm", localVarApiClient.parameterToString(xAmzAlgorithm));
        }

        if (xAmzCredential != null) {
            localVarHeaderParams.put("X-Amz-Credential", localVarApiClient.parameterToString(xAmzCredential));
        }

        if (xAmzSecurityToken != null) {
            localVarHeaderParams.put("X-Amz-Security-Token", localVarApiClient.parameterToString(xAmzSecurityToken));
        }

        if (xAmzSignature != null) {
            localVarHeaderParams.put("X-Amz-Signature", localVarApiClient.parameterToString(xAmzSignature));
        }

        if (xAmzSignedHeaders != null) {
            localVarHeaderParams.put("X-Amz-SignedHeaders", localVarApiClient.parameterToString(xAmzSignedHeaders));
        }

        final String[] localVarAccepts = {
            "text/xml"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            "text/xml"
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "hmac" };
        return localVarApiClient.buildCall(basePath, localVarPath, "POST", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call pOSTPauseClusterValidateBeforeCall(String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, PauseClusterMessage pauseClusterMessage, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'action' is set
        if (action == null) {
            throw new ApiException("Missing the required parameter 'action' when calling pOSTPauseCluster(Async)");
        }

        // verify the required parameter 'version' is set
        if (version == null) {
            throw new ApiException("Missing the required parameter 'version' when calling pOSTPauseCluster(Async)");
        }

        return pOSTPauseClusterCall(action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, pauseClusterMessage, _callback);

    }

    /**
     * 
     * Pauses a cluster.
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param pauseClusterMessage  (optional)
     * @return PauseClusterResult
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> ClusterNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> InvalidClusterStateFault </td><td>  -  </td></tr>
     </table>
     */
    public PauseClusterResult pOSTPauseCluster(String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, PauseClusterMessage pauseClusterMessage) throws ApiException {
        ApiResponse<PauseClusterResult> localVarResp = pOSTPauseClusterWithHttpInfo(action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, pauseClusterMessage);
        return localVarResp.getData();
    }

    /**
     * 
     * Pauses a cluster.
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param pauseClusterMessage  (optional)
     * @return ApiResponse&lt;PauseClusterResult&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> ClusterNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> InvalidClusterStateFault </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<PauseClusterResult> pOSTPauseClusterWithHttpInfo(String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, PauseClusterMessage pauseClusterMessage) throws ApiException {
        okhttp3.Call localVarCall = pOSTPauseClusterValidateBeforeCall(action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, pauseClusterMessage, null);
        Type localVarReturnType = new TypeToken<PauseClusterResult>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     *  (asynchronously)
     * Pauses a cluster.
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param pauseClusterMessage  (optional)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> ClusterNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> InvalidClusterStateFault </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call pOSTPauseClusterAsync(String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, PauseClusterMessage pauseClusterMessage, final ApiCallback<PauseClusterResult> _callback) throws ApiException {

        okhttp3.Call localVarCall = pOSTPauseClusterValidateBeforeCall(action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, pauseClusterMessage, _callback);
        Type localVarReturnType = new TypeToken<PauseClusterResult>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for pOSTPurchaseReservedNodeOffering
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param purchaseReservedNodeOfferingMessage  (optional)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> ReservedNodeOfferingNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> ReservedNodeAlreadyExistsFault </td><td>  -  </td></tr>
        <tr><td> 482 </td><td> ReservedNodeQuotaExceededFault </td><td>  -  </td></tr>
        <tr><td> 483 </td><td> UnsupportedOperationFault </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call pOSTPurchaseReservedNodeOfferingCall(String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, PurchaseReservedNodeOfferingMessage purchaseReservedNodeOfferingMessage, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = purchaseReservedNodeOfferingMessage;

        // create path and map variables
        String localVarPath = "/#Action=PurchaseReservedNodeOffering";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (action != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("Action", action));
        }

        if (version != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("Version", version));
        }

        if (xAmzContentSha256 != null) {
            localVarHeaderParams.put("X-Amz-Content-Sha256", localVarApiClient.parameterToString(xAmzContentSha256));
        }

        if (xAmzDate != null) {
            localVarHeaderParams.put("X-Amz-Date", localVarApiClient.parameterToString(xAmzDate));
        }

        if (xAmzAlgorithm != null) {
            localVarHeaderParams.put("X-Amz-Algorithm", localVarApiClient.parameterToString(xAmzAlgorithm));
        }

        if (xAmzCredential != null) {
            localVarHeaderParams.put("X-Amz-Credential", localVarApiClient.parameterToString(xAmzCredential));
        }

        if (xAmzSecurityToken != null) {
            localVarHeaderParams.put("X-Amz-Security-Token", localVarApiClient.parameterToString(xAmzSecurityToken));
        }

        if (xAmzSignature != null) {
            localVarHeaderParams.put("X-Amz-Signature", localVarApiClient.parameterToString(xAmzSignature));
        }

        if (xAmzSignedHeaders != null) {
            localVarHeaderParams.put("X-Amz-SignedHeaders", localVarApiClient.parameterToString(xAmzSignedHeaders));
        }

        final String[] localVarAccepts = {
            "text/xml"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            "text/xml"
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "hmac" };
        return localVarApiClient.buildCall(basePath, localVarPath, "POST", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call pOSTPurchaseReservedNodeOfferingValidateBeforeCall(String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, PurchaseReservedNodeOfferingMessage purchaseReservedNodeOfferingMessage, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'action' is set
        if (action == null) {
            throw new ApiException("Missing the required parameter 'action' when calling pOSTPurchaseReservedNodeOffering(Async)");
        }

        // verify the required parameter 'version' is set
        if (version == null) {
            throw new ApiException("Missing the required parameter 'version' when calling pOSTPurchaseReservedNodeOffering(Async)");
        }

        return pOSTPurchaseReservedNodeOfferingCall(action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, purchaseReservedNodeOfferingMessage, _callback);

    }

    /**
     * 
     * &lt;p&gt;Allows you to purchase reserved nodes. Amazon Redshift offers a predefined set of reserved node offerings. You can purchase one or more of the offerings. You can call the &lt;a&gt;DescribeReservedNodeOfferings&lt;/a&gt; API to obtain the available reserved node offerings. You can call this API by providing a specific reserved node offering and the number of nodes you want to reserve. &lt;/p&gt; &lt;p&gt; For more information about reserved node offerings, go to &lt;a href&#x3D;\&quot;https://docs.aws.amazon.com/redshift/latest/mgmt/purchase-reserved-node-instance.html\&quot;&gt;Purchasing Reserved Nodes&lt;/a&gt; in the &lt;i&gt;Amazon Redshift Cluster Management Guide&lt;/i&gt;.&lt;/p&gt;
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param purchaseReservedNodeOfferingMessage  (optional)
     * @return PurchaseReservedNodeOfferingResult
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> ReservedNodeOfferingNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> ReservedNodeAlreadyExistsFault </td><td>  -  </td></tr>
        <tr><td> 482 </td><td> ReservedNodeQuotaExceededFault </td><td>  -  </td></tr>
        <tr><td> 483 </td><td> UnsupportedOperationFault </td><td>  -  </td></tr>
     </table>
     */
    public PurchaseReservedNodeOfferingResult pOSTPurchaseReservedNodeOffering(String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, PurchaseReservedNodeOfferingMessage purchaseReservedNodeOfferingMessage) throws ApiException {
        ApiResponse<PurchaseReservedNodeOfferingResult> localVarResp = pOSTPurchaseReservedNodeOfferingWithHttpInfo(action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, purchaseReservedNodeOfferingMessage);
        return localVarResp.getData();
    }

    /**
     * 
     * &lt;p&gt;Allows you to purchase reserved nodes. Amazon Redshift offers a predefined set of reserved node offerings. You can purchase one or more of the offerings. You can call the &lt;a&gt;DescribeReservedNodeOfferings&lt;/a&gt; API to obtain the available reserved node offerings. You can call this API by providing a specific reserved node offering and the number of nodes you want to reserve. &lt;/p&gt; &lt;p&gt; For more information about reserved node offerings, go to &lt;a href&#x3D;\&quot;https://docs.aws.amazon.com/redshift/latest/mgmt/purchase-reserved-node-instance.html\&quot;&gt;Purchasing Reserved Nodes&lt;/a&gt; in the &lt;i&gt;Amazon Redshift Cluster Management Guide&lt;/i&gt;.&lt;/p&gt;
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param purchaseReservedNodeOfferingMessage  (optional)
     * @return ApiResponse&lt;PurchaseReservedNodeOfferingResult&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> ReservedNodeOfferingNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> ReservedNodeAlreadyExistsFault </td><td>  -  </td></tr>
        <tr><td> 482 </td><td> ReservedNodeQuotaExceededFault </td><td>  -  </td></tr>
        <tr><td> 483 </td><td> UnsupportedOperationFault </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<PurchaseReservedNodeOfferingResult> pOSTPurchaseReservedNodeOfferingWithHttpInfo(String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, PurchaseReservedNodeOfferingMessage purchaseReservedNodeOfferingMessage) throws ApiException {
        okhttp3.Call localVarCall = pOSTPurchaseReservedNodeOfferingValidateBeforeCall(action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, purchaseReservedNodeOfferingMessage, null);
        Type localVarReturnType = new TypeToken<PurchaseReservedNodeOfferingResult>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     *  (asynchronously)
     * &lt;p&gt;Allows you to purchase reserved nodes. Amazon Redshift offers a predefined set of reserved node offerings. You can purchase one or more of the offerings. You can call the &lt;a&gt;DescribeReservedNodeOfferings&lt;/a&gt; API to obtain the available reserved node offerings. You can call this API by providing a specific reserved node offering and the number of nodes you want to reserve. &lt;/p&gt; &lt;p&gt; For more information about reserved node offerings, go to &lt;a href&#x3D;\&quot;https://docs.aws.amazon.com/redshift/latest/mgmt/purchase-reserved-node-instance.html\&quot;&gt;Purchasing Reserved Nodes&lt;/a&gt; in the &lt;i&gt;Amazon Redshift Cluster Management Guide&lt;/i&gt;.&lt;/p&gt;
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param purchaseReservedNodeOfferingMessage  (optional)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> ReservedNodeOfferingNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> ReservedNodeAlreadyExistsFault </td><td>  -  </td></tr>
        <tr><td> 482 </td><td> ReservedNodeQuotaExceededFault </td><td>  -  </td></tr>
        <tr><td> 483 </td><td> UnsupportedOperationFault </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call pOSTPurchaseReservedNodeOfferingAsync(String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, PurchaseReservedNodeOfferingMessage purchaseReservedNodeOfferingMessage, final ApiCallback<PurchaseReservedNodeOfferingResult> _callback) throws ApiException {

        okhttp3.Call localVarCall = pOSTPurchaseReservedNodeOfferingValidateBeforeCall(action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, purchaseReservedNodeOfferingMessage, _callback);
        Type localVarReturnType = new TypeToken<PurchaseReservedNodeOfferingResult>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for pOSTRebootCluster
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param rebootClusterMessage  (optional)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> InvalidClusterStateFault </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> ClusterNotFoundFault </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call pOSTRebootClusterCall(String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, RebootClusterMessage rebootClusterMessage, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = rebootClusterMessage;

        // create path and map variables
        String localVarPath = "/#Action=RebootCluster";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (action != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("Action", action));
        }

        if (version != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("Version", version));
        }

        if (xAmzContentSha256 != null) {
            localVarHeaderParams.put("X-Amz-Content-Sha256", localVarApiClient.parameterToString(xAmzContentSha256));
        }

        if (xAmzDate != null) {
            localVarHeaderParams.put("X-Amz-Date", localVarApiClient.parameterToString(xAmzDate));
        }

        if (xAmzAlgorithm != null) {
            localVarHeaderParams.put("X-Amz-Algorithm", localVarApiClient.parameterToString(xAmzAlgorithm));
        }

        if (xAmzCredential != null) {
            localVarHeaderParams.put("X-Amz-Credential", localVarApiClient.parameterToString(xAmzCredential));
        }

        if (xAmzSecurityToken != null) {
            localVarHeaderParams.put("X-Amz-Security-Token", localVarApiClient.parameterToString(xAmzSecurityToken));
        }

        if (xAmzSignature != null) {
            localVarHeaderParams.put("X-Amz-Signature", localVarApiClient.parameterToString(xAmzSignature));
        }

        if (xAmzSignedHeaders != null) {
            localVarHeaderParams.put("X-Amz-SignedHeaders", localVarApiClient.parameterToString(xAmzSignedHeaders));
        }

        final String[] localVarAccepts = {
            "text/xml"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            "text/xml"
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "hmac" };
        return localVarApiClient.buildCall(basePath, localVarPath, "POST", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call pOSTRebootClusterValidateBeforeCall(String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, RebootClusterMessage rebootClusterMessage, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'action' is set
        if (action == null) {
            throw new ApiException("Missing the required parameter 'action' when calling pOSTRebootCluster(Async)");
        }

        // verify the required parameter 'version' is set
        if (version == null) {
            throw new ApiException("Missing the required parameter 'version' when calling pOSTRebootCluster(Async)");
        }

        return pOSTRebootClusterCall(action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, rebootClusterMessage, _callback);

    }

    /**
     * 
     * Reboots a cluster. This action is taken as soon as possible. It results in a momentary outage to the cluster, during which the cluster status is set to &lt;code&gt;rebooting&lt;/code&gt;. A cluster event is created when the reboot is completed. Any pending cluster modifications (see &lt;a&gt;ModifyCluster&lt;/a&gt;) are applied at this reboot. For more information about managing clusters, go to &lt;a href&#x3D;\&quot;https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html\&quot;&gt;Amazon Redshift Clusters&lt;/a&gt; in the &lt;i&gt;Amazon Redshift Cluster Management Guide&lt;/i&gt;. 
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param rebootClusterMessage  (optional)
     * @return RebootClusterResult
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> InvalidClusterStateFault </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> ClusterNotFoundFault </td><td>  -  </td></tr>
     </table>
     */
    public RebootClusterResult pOSTRebootCluster(String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, RebootClusterMessage rebootClusterMessage) throws ApiException {
        ApiResponse<RebootClusterResult> localVarResp = pOSTRebootClusterWithHttpInfo(action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, rebootClusterMessage);
        return localVarResp.getData();
    }

    /**
     * 
     * Reboots a cluster. This action is taken as soon as possible. It results in a momentary outage to the cluster, during which the cluster status is set to &lt;code&gt;rebooting&lt;/code&gt;. A cluster event is created when the reboot is completed. Any pending cluster modifications (see &lt;a&gt;ModifyCluster&lt;/a&gt;) are applied at this reboot. For more information about managing clusters, go to &lt;a href&#x3D;\&quot;https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html\&quot;&gt;Amazon Redshift Clusters&lt;/a&gt; in the &lt;i&gt;Amazon Redshift Cluster Management Guide&lt;/i&gt;. 
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param rebootClusterMessage  (optional)
     * @return ApiResponse&lt;RebootClusterResult&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> InvalidClusterStateFault </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> ClusterNotFoundFault </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<RebootClusterResult> pOSTRebootClusterWithHttpInfo(String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, RebootClusterMessage rebootClusterMessage) throws ApiException {
        okhttp3.Call localVarCall = pOSTRebootClusterValidateBeforeCall(action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, rebootClusterMessage, null);
        Type localVarReturnType = new TypeToken<RebootClusterResult>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     *  (asynchronously)
     * Reboots a cluster. This action is taken as soon as possible. It results in a momentary outage to the cluster, during which the cluster status is set to &lt;code&gt;rebooting&lt;/code&gt;. A cluster event is created when the reboot is completed. Any pending cluster modifications (see &lt;a&gt;ModifyCluster&lt;/a&gt;) are applied at this reboot. For more information about managing clusters, go to &lt;a href&#x3D;\&quot;https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html\&quot;&gt;Amazon Redshift Clusters&lt;/a&gt; in the &lt;i&gt;Amazon Redshift Cluster Management Guide&lt;/i&gt;. 
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param rebootClusterMessage  (optional)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> InvalidClusterStateFault </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> ClusterNotFoundFault </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call pOSTRebootClusterAsync(String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, RebootClusterMessage rebootClusterMessage, final ApiCallback<RebootClusterResult> _callback) throws ApiException {

        okhttp3.Call localVarCall = pOSTRebootClusterValidateBeforeCall(action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, rebootClusterMessage, _callback);
        Type localVarReturnType = new TypeToken<RebootClusterResult>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for pOSTRejectDataShare
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param rejectDataShareMessage  (optional)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> InvalidDataShareFault </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call pOSTRejectDataShareCall(String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, RejectDataShareMessage rejectDataShareMessage, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = rejectDataShareMessage;

        // create path and map variables
        String localVarPath = "/#Action=RejectDataShare";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (action != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("Action", action));
        }

        if (version != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("Version", version));
        }

        if (xAmzContentSha256 != null) {
            localVarHeaderParams.put("X-Amz-Content-Sha256", localVarApiClient.parameterToString(xAmzContentSha256));
        }

        if (xAmzDate != null) {
            localVarHeaderParams.put("X-Amz-Date", localVarApiClient.parameterToString(xAmzDate));
        }

        if (xAmzAlgorithm != null) {
            localVarHeaderParams.put("X-Amz-Algorithm", localVarApiClient.parameterToString(xAmzAlgorithm));
        }

        if (xAmzCredential != null) {
            localVarHeaderParams.put("X-Amz-Credential", localVarApiClient.parameterToString(xAmzCredential));
        }

        if (xAmzSecurityToken != null) {
            localVarHeaderParams.put("X-Amz-Security-Token", localVarApiClient.parameterToString(xAmzSecurityToken));
        }

        if (xAmzSignature != null) {
            localVarHeaderParams.put("X-Amz-Signature", localVarApiClient.parameterToString(xAmzSignature));
        }

        if (xAmzSignedHeaders != null) {
            localVarHeaderParams.put("X-Amz-SignedHeaders", localVarApiClient.parameterToString(xAmzSignedHeaders));
        }

        final String[] localVarAccepts = {
            "text/xml"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            "text/xml"
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "hmac" };
        return localVarApiClient.buildCall(basePath, localVarPath, "POST", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call pOSTRejectDataShareValidateBeforeCall(String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, RejectDataShareMessage rejectDataShareMessage, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'action' is set
        if (action == null) {
            throw new ApiException("Missing the required parameter 'action' when calling pOSTRejectDataShare(Async)");
        }

        // verify the required parameter 'version' is set
        if (version == null) {
            throw new ApiException("Missing the required parameter 'version' when calling pOSTRejectDataShare(Async)");
        }

        return pOSTRejectDataShareCall(action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, rejectDataShareMessage, _callback);

    }

    /**
     * 
     * From a datashare consumer account, rejects the specified datashare.
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param rejectDataShareMessage  (optional)
     * @return DataShare
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> InvalidDataShareFault </td><td>  -  </td></tr>
     </table>
     */
    public DataShare pOSTRejectDataShare(String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, RejectDataShareMessage rejectDataShareMessage) throws ApiException {
        ApiResponse<DataShare> localVarResp = pOSTRejectDataShareWithHttpInfo(action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, rejectDataShareMessage);
        return localVarResp.getData();
    }

    /**
     * 
     * From a datashare consumer account, rejects the specified datashare.
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param rejectDataShareMessage  (optional)
     * @return ApiResponse&lt;DataShare&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> InvalidDataShareFault </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<DataShare> pOSTRejectDataShareWithHttpInfo(String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, RejectDataShareMessage rejectDataShareMessage) throws ApiException {
        okhttp3.Call localVarCall = pOSTRejectDataShareValidateBeforeCall(action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, rejectDataShareMessage, null);
        Type localVarReturnType = new TypeToken<DataShare>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     *  (asynchronously)
     * From a datashare consumer account, rejects the specified datashare.
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param rejectDataShareMessage  (optional)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> InvalidDataShareFault </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call pOSTRejectDataShareAsync(String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, RejectDataShareMessage rejectDataShareMessage, final ApiCallback<DataShare> _callback) throws ApiException {

        okhttp3.Call localVarCall = pOSTRejectDataShareValidateBeforeCall(action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, rejectDataShareMessage, _callback);
        Type localVarReturnType = new TypeToken<DataShare>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for pOSTResetClusterParameterGroup
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param resetClusterParameterGroupMessage  (optional)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> InvalidClusterParameterGroupStateFault </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> ClusterParameterGroupNotFoundFault </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call pOSTResetClusterParameterGroupCall(String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, ResetClusterParameterGroupMessage resetClusterParameterGroupMessage, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = resetClusterParameterGroupMessage;

        // create path and map variables
        String localVarPath = "/#Action=ResetClusterParameterGroup";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (action != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("Action", action));
        }

        if (version != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("Version", version));
        }

        if (xAmzContentSha256 != null) {
            localVarHeaderParams.put("X-Amz-Content-Sha256", localVarApiClient.parameterToString(xAmzContentSha256));
        }

        if (xAmzDate != null) {
            localVarHeaderParams.put("X-Amz-Date", localVarApiClient.parameterToString(xAmzDate));
        }

        if (xAmzAlgorithm != null) {
            localVarHeaderParams.put("X-Amz-Algorithm", localVarApiClient.parameterToString(xAmzAlgorithm));
        }

        if (xAmzCredential != null) {
            localVarHeaderParams.put("X-Amz-Credential", localVarApiClient.parameterToString(xAmzCredential));
        }

        if (xAmzSecurityToken != null) {
            localVarHeaderParams.put("X-Amz-Security-Token", localVarApiClient.parameterToString(xAmzSecurityToken));
        }

        if (xAmzSignature != null) {
            localVarHeaderParams.put("X-Amz-Signature", localVarApiClient.parameterToString(xAmzSignature));
        }

        if (xAmzSignedHeaders != null) {
            localVarHeaderParams.put("X-Amz-SignedHeaders", localVarApiClient.parameterToString(xAmzSignedHeaders));
        }

        final String[] localVarAccepts = {
            "text/xml"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            "text/xml"
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "hmac" };
        return localVarApiClient.buildCall(basePath, localVarPath, "POST", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call pOSTResetClusterParameterGroupValidateBeforeCall(String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, ResetClusterParameterGroupMessage resetClusterParameterGroupMessage, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'action' is set
        if (action == null) {
            throw new ApiException("Missing the required parameter 'action' when calling pOSTResetClusterParameterGroup(Async)");
        }

        // verify the required parameter 'version' is set
        if (version == null) {
            throw new ApiException("Missing the required parameter 'version' when calling pOSTResetClusterParameterGroup(Async)");
        }

        return pOSTResetClusterParameterGroupCall(action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, resetClusterParameterGroupMessage, _callback);

    }

    /**
     * 
     * Sets one or more parameters of the specified parameter group to their default values and sets the source values of the parameters to \&quot;engine-default\&quot;. To reset the entire parameter group specify the &lt;i&gt;ResetAllParameters&lt;/i&gt; parameter. For parameter changes to take effect you must reboot any associated clusters. 
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param resetClusterParameterGroupMessage  (optional)
     * @return ClusterParameterGroupNameMessage
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> InvalidClusterParameterGroupStateFault </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> ClusterParameterGroupNotFoundFault </td><td>  -  </td></tr>
     </table>
     */
    public ClusterParameterGroupNameMessage pOSTResetClusterParameterGroup(String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, ResetClusterParameterGroupMessage resetClusterParameterGroupMessage) throws ApiException {
        ApiResponse<ClusterParameterGroupNameMessage> localVarResp = pOSTResetClusterParameterGroupWithHttpInfo(action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, resetClusterParameterGroupMessage);
        return localVarResp.getData();
    }

    /**
     * 
     * Sets one or more parameters of the specified parameter group to their default values and sets the source values of the parameters to \&quot;engine-default\&quot;. To reset the entire parameter group specify the &lt;i&gt;ResetAllParameters&lt;/i&gt; parameter. For parameter changes to take effect you must reboot any associated clusters. 
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param resetClusterParameterGroupMessage  (optional)
     * @return ApiResponse&lt;ClusterParameterGroupNameMessage&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> InvalidClusterParameterGroupStateFault </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> ClusterParameterGroupNotFoundFault </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<ClusterParameterGroupNameMessage> pOSTResetClusterParameterGroupWithHttpInfo(String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, ResetClusterParameterGroupMessage resetClusterParameterGroupMessage) throws ApiException {
        okhttp3.Call localVarCall = pOSTResetClusterParameterGroupValidateBeforeCall(action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, resetClusterParameterGroupMessage, null);
        Type localVarReturnType = new TypeToken<ClusterParameterGroupNameMessage>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     *  (asynchronously)
     * Sets one or more parameters of the specified parameter group to their default values and sets the source values of the parameters to \&quot;engine-default\&quot;. To reset the entire parameter group specify the &lt;i&gt;ResetAllParameters&lt;/i&gt; parameter. For parameter changes to take effect you must reboot any associated clusters. 
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param resetClusterParameterGroupMessage  (optional)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> InvalidClusterParameterGroupStateFault </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> ClusterParameterGroupNotFoundFault </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call pOSTResetClusterParameterGroupAsync(String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, ResetClusterParameterGroupMessage resetClusterParameterGroupMessage, final ApiCallback<ClusterParameterGroupNameMessage> _callback) throws ApiException {

        okhttp3.Call localVarCall = pOSTResetClusterParameterGroupValidateBeforeCall(action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, resetClusterParameterGroupMessage, _callback);
        Type localVarReturnType = new TypeToken<ClusterParameterGroupNameMessage>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for pOSTResizeCluster
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param resizeClusterMessage  (optional)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> InvalidClusterStateFault </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> ClusterNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 482 </td><td> NumberOfNodesQuotaExceededFault </td><td>  -  </td></tr>
        <tr><td> 483 </td><td> NumberOfNodesPerClusterLimitExceededFault </td><td>  -  </td></tr>
        <tr><td> 484 </td><td> InsufficientClusterCapacityFault </td><td>  -  </td></tr>
        <tr><td> 485 </td><td> UnsupportedOptionFault </td><td>  -  </td></tr>
        <tr><td> 486 </td><td> UnsupportedOperationFault </td><td>  -  </td></tr>
        <tr><td> 487 </td><td> UnauthorizedOperation </td><td>  -  </td></tr>
        <tr><td> 488 </td><td> LimitExceededFault </td><td>  -  </td></tr>
        <tr><td> 489 </td><td> ReservedNodeNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 490 </td><td> InvalidReservedNodeStateFault </td><td>  -  </td></tr>
        <tr><td> 491 </td><td> ReservedNodeAlreadyMigratedFault </td><td>  -  </td></tr>
        <tr><td> 492 </td><td> ReservedNodeOfferingNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 493 </td><td> DependentServiceUnavailableFault </td><td>  -  </td></tr>
        <tr><td> 494 </td><td> ReservedNodeAlreadyExistsFault </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call pOSTResizeClusterCall(String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, ResizeClusterMessage resizeClusterMessage, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = resizeClusterMessage;

        // create path and map variables
        String localVarPath = "/#Action=ResizeCluster";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (action != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("Action", action));
        }

        if (version != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("Version", version));
        }

        if (xAmzContentSha256 != null) {
            localVarHeaderParams.put("X-Amz-Content-Sha256", localVarApiClient.parameterToString(xAmzContentSha256));
        }

        if (xAmzDate != null) {
            localVarHeaderParams.put("X-Amz-Date", localVarApiClient.parameterToString(xAmzDate));
        }

        if (xAmzAlgorithm != null) {
            localVarHeaderParams.put("X-Amz-Algorithm", localVarApiClient.parameterToString(xAmzAlgorithm));
        }

        if (xAmzCredential != null) {
            localVarHeaderParams.put("X-Amz-Credential", localVarApiClient.parameterToString(xAmzCredential));
        }

        if (xAmzSecurityToken != null) {
            localVarHeaderParams.put("X-Amz-Security-Token", localVarApiClient.parameterToString(xAmzSecurityToken));
        }

        if (xAmzSignature != null) {
            localVarHeaderParams.put("X-Amz-Signature", localVarApiClient.parameterToString(xAmzSignature));
        }

        if (xAmzSignedHeaders != null) {
            localVarHeaderParams.put("X-Amz-SignedHeaders", localVarApiClient.parameterToString(xAmzSignedHeaders));
        }

        final String[] localVarAccepts = {
            "text/xml"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            "text/xml"
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "hmac" };
        return localVarApiClient.buildCall(basePath, localVarPath, "POST", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call pOSTResizeClusterValidateBeforeCall(String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, ResizeClusterMessage resizeClusterMessage, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'action' is set
        if (action == null) {
            throw new ApiException("Missing the required parameter 'action' when calling pOSTResizeCluster(Async)");
        }

        // verify the required parameter 'version' is set
        if (version == null) {
            throw new ApiException("Missing the required parameter 'version' when calling pOSTResizeCluster(Async)");
        }

        return pOSTResizeClusterCall(action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, resizeClusterMessage, _callback);

    }

    /**
     * 
     * &lt;p&gt;Changes the size of the cluster. You can change the cluster&#39;s type, or change the number or type of nodes. The default behavior is to use the elastic resize method. With an elastic resize, your cluster is available for read and write operations more quickly than with the classic resize method. &lt;/p&gt; &lt;p&gt;Elastic resize operations have the following restrictions:&lt;/p&gt; &lt;ul&gt; &lt;li&gt; &lt;p&gt;You can only resize clusters of the following types:&lt;/p&gt; &lt;ul&gt; &lt;li&gt; &lt;p&gt;dc1.large (if your cluster is in a VPC)&lt;/p&gt; &lt;/li&gt; &lt;li&gt; &lt;p&gt;dc1.8xlarge (if your cluster is in a VPC)&lt;/p&gt; &lt;/li&gt; &lt;li&gt; &lt;p&gt;dc2.large&lt;/p&gt; &lt;/li&gt; &lt;li&gt; &lt;p&gt;dc2.8xlarge&lt;/p&gt; &lt;/li&gt; &lt;li&gt; &lt;p&gt;ds2.xlarge&lt;/p&gt; &lt;/li&gt; &lt;li&gt; &lt;p&gt;ds2.8xlarge&lt;/p&gt; &lt;/li&gt; &lt;li&gt; &lt;p&gt;ra3.xlplus&lt;/p&gt; &lt;/li&gt; &lt;li&gt; &lt;p&gt;ra3.4xlarge&lt;/p&gt; &lt;/li&gt; &lt;li&gt; &lt;p&gt;ra3.16xlarge&lt;/p&gt; &lt;/li&gt; &lt;/ul&gt; &lt;/li&gt; &lt;li&gt; &lt;p&gt;The type of nodes that you add must match the node type for the cluster.&lt;/p&gt; &lt;/li&gt; &lt;/ul&gt;
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param resizeClusterMessage  (optional)
     * @return ResizeClusterResult
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> InvalidClusterStateFault </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> ClusterNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 482 </td><td> NumberOfNodesQuotaExceededFault </td><td>  -  </td></tr>
        <tr><td> 483 </td><td> NumberOfNodesPerClusterLimitExceededFault </td><td>  -  </td></tr>
        <tr><td> 484 </td><td> InsufficientClusterCapacityFault </td><td>  -  </td></tr>
        <tr><td> 485 </td><td> UnsupportedOptionFault </td><td>  -  </td></tr>
        <tr><td> 486 </td><td> UnsupportedOperationFault </td><td>  -  </td></tr>
        <tr><td> 487 </td><td> UnauthorizedOperation </td><td>  -  </td></tr>
        <tr><td> 488 </td><td> LimitExceededFault </td><td>  -  </td></tr>
        <tr><td> 489 </td><td> ReservedNodeNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 490 </td><td> InvalidReservedNodeStateFault </td><td>  -  </td></tr>
        <tr><td> 491 </td><td> ReservedNodeAlreadyMigratedFault </td><td>  -  </td></tr>
        <tr><td> 492 </td><td> ReservedNodeOfferingNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 493 </td><td> DependentServiceUnavailableFault </td><td>  -  </td></tr>
        <tr><td> 494 </td><td> ReservedNodeAlreadyExistsFault </td><td>  -  </td></tr>
     </table>
     */
    public ResizeClusterResult pOSTResizeCluster(String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, ResizeClusterMessage resizeClusterMessage) throws ApiException {
        ApiResponse<ResizeClusterResult> localVarResp = pOSTResizeClusterWithHttpInfo(action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, resizeClusterMessage);
        return localVarResp.getData();
    }

    /**
     * 
     * &lt;p&gt;Changes the size of the cluster. You can change the cluster&#39;s type, or change the number or type of nodes. The default behavior is to use the elastic resize method. With an elastic resize, your cluster is available for read and write operations more quickly than with the classic resize method. &lt;/p&gt; &lt;p&gt;Elastic resize operations have the following restrictions:&lt;/p&gt; &lt;ul&gt; &lt;li&gt; &lt;p&gt;You can only resize clusters of the following types:&lt;/p&gt; &lt;ul&gt; &lt;li&gt; &lt;p&gt;dc1.large (if your cluster is in a VPC)&lt;/p&gt; &lt;/li&gt; &lt;li&gt; &lt;p&gt;dc1.8xlarge (if your cluster is in a VPC)&lt;/p&gt; &lt;/li&gt; &lt;li&gt; &lt;p&gt;dc2.large&lt;/p&gt; &lt;/li&gt; &lt;li&gt; &lt;p&gt;dc2.8xlarge&lt;/p&gt; &lt;/li&gt; &lt;li&gt; &lt;p&gt;ds2.xlarge&lt;/p&gt; &lt;/li&gt; &lt;li&gt; &lt;p&gt;ds2.8xlarge&lt;/p&gt; &lt;/li&gt; &lt;li&gt; &lt;p&gt;ra3.xlplus&lt;/p&gt; &lt;/li&gt; &lt;li&gt; &lt;p&gt;ra3.4xlarge&lt;/p&gt; &lt;/li&gt; &lt;li&gt; &lt;p&gt;ra3.16xlarge&lt;/p&gt; &lt;/li&gt; &lt;/ul&gt; &lt;/li&gt; &lt;li&gt; &lt;p&gt;The type of nodes that you add must match the node type for the cluster.&lt;/p&gt; &lt;/li&gt; &lt;/ul&gt;
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param resizeClusterMessage  (optional)
     * @return ApiResponse&lt;ResizeClusterResult&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> InvalidClusterStateFault </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> ClusterNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 482 </td><td> NumberOfNodesQuotaExceededFault </td><td>  -  </td></tr>
        <tr><td> 483 </td><td> NumberOfNodesPerClusterLimitExceededFault </td><td>  -  </td></tr>
        <tr><td> 484 </td><td> InsufficientClusterCapacityFault </td><td>  -  </td></tr>
        <tr><td> 485 </td><td> UnsupportedOptionFault </td><td>  -  </td></tr>
        <tr><td> 486 </td><td> UnsupportedOperationFault </td><td>  -  </td></tr>
        <tr><td> 487 </td><td> UnauthorizedOperation </td><td>  -  </td></tr>
        <tr><td> 488 </td><td> LimitExceededFault </td><td>  -  </td></tr>
        <tr><td> 489 </td><td> ReservedNodeNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 490 </td><td> InvalidReservedNodeStateFault </td><td>  -  </td></tr>
        <tr><td> 491 </td><td> ReservedNodeAlreadyMigratedFault </td><td>  -  </td></tr>
        <tr><td> 492 </td><td> ReservedNodeOfferingNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 493 </td><td> DependentServiceUnavailableFault </td><td>  -  </td></tr>
        <tr><td> 494 </td><td> ReservedNodeAlreadyExistsFault </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<ResizeClusterResult> pOSTResizeClusterWithHttpInfo(String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, ResizeClusterMessage resizeClusterMessage) throws ApiException {
        okhttp3.Call localVarCall = pOSTResizeClusterValidateBeforeCall(action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, resizeClusterMessage, null);
        Type localVarReturnType = new TypeToken<ResizeClusterResult>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     *  (asynchronously)
     * &lt;p&gt;Changes the size of the cluster. You can change the cluster&#39;s type, or change the number or type of nodes. The default behavior is to use the elastic resize method. With an elastic resize, your cluster is available for read and write operations more quickly than with the classic resize method. &lt;/p&gt; &lt;p&gt;Elastic resize operations have the following restrictions:&lt;/p&gt; &lt;ul&gt; &lt;li&gt; &lt;p&gt;You can only resize clusters of the following types:&lt;/p&gt; &lt;ul&gt; &lt;li&gt; &lt;p&gt;dc1.large (if your cluster is in a VPC)&lt;/p&gt; &lt;/li&gt; &lt;li&gt; &lt;p&gt;dc1.8xlarge (if your cluster is in a VPC)&lt;/p&gt; &lt;/li&gt; &lt;li&gt; &lt;p&gt;dc2.large&lt;/p&gt; &lt;/li&gt; &lt;li&gt; &lt;p&gt;dc2.8xlarge&lt;/p&gt; &lt;/li&gt; &lt;li&gt; &lt;p&gt;ds2.xlarge&lt;/p&gt; &lt;/li&gt; &lt;li&gt; &lt;p&gt;ds2.8xlarge&lt;/p&gt; &lt;/li&gt; &lt;li&gt; &lt;p&gt;ra3.xlplus&lt;/p&gt; &lt;/li&gt; &lt;li&gt; &lt;p&gt;ra3.4xlarge&lt;/p&gt; &lt;/li&gt; &lt;li&gt; &lt;p&gt;ra3.16xlarge&lt;/p&gt; &lt;/li&gt; &lt;/ul&gt; &lt;/li&gt; &lt;li&gt; &lt;p&gt;The type of nodes that you add must match the node type for the cluster.&lt;/p&gt; &lt;/li&gt; &lt;/ul&gt;
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param resizeClusterMessage  (optional)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> InvalidClusterStateFault </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> ClusterNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 482 </td><td> NumberOfNodesQuotaExceededFault </td><td>  -  </td></tr>
        <tr><td> 483 </td><td> NumberOfNodesPerClusterLimitExceededFault </td><td>  -  </td></tr>
        <tr><td> 484 </td><td> InsufficientClusterCapacityFault </td><td>  -  </td></tr>
        <tr><td> 485 </td><td> UnsupportedOptionFault </td><td>  -  </td></tr>
        <tr><td> 486 </td><td> UnsupportedOperationFault </td><td>  -  </td></tr>
        <tr><td> 487 </td><td> UnauthorizedOperation </td><td>  -  </td></tr>
        <tr><td> 488 </td><td> LimitExceededFault </td><td>  -  </td></tr>
        <tr><td> 489 </td><td> ReservedNodeNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 490 </td><td> InvalidReservedNodeStateFault </td><td>  -  </td></tr>
        <tr><td> 491 </td><td> ReservedNodeAlreadyMigratedFault </td><td>  -  </td></tr>
        <tr><td> 492 </td><td> ReservedNodeOfferingNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 493 </td><td> DependentServiceUnavailableFault </td><td>  -  </td></tr>
        <tr><td> 494 </td><td> ReservedNodeAlreadyExistsFault </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call pOSTResizeClusterAsync(String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, ResizeClusterMessage resizeClusterMessage, final ApiCallback<ResizeClusterResult> _callback) throws ApiException {

        okhttp3.Call localVarCall = pOSTResizeClusterValidateBeforeCall(action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, resizeClusterMessage, _callback);
        Type localVarReturnType = new TypeToken<ResizeClusterResult>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for pOSTRestoreFromClusterSnapshot
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param restoreFromClusterSnapshotMessage  (optional)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> AccessToSnapshotDeniedFault </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> ClusterAlreadyExistsFault </td><td>  -  </td></tr>
        <tr><td> 482 </td><td> ClusterSnapshotNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 483 </td><td> ClusterQuotaExceededFault </td><td>  -  </td></tr>
        <tr><td> 484 </td><td> InsufficientClusterCapacityFault </td><td>  -  </td></tr>
        <tr><td> 485 </td><td> InvalidClusterSnapshotStateFault </td><td>  -  </td></tr>
        <tr><td> 486 </td><td> InvalidRestoreFault </td><td>  -  </td></tr>
        <tr><td> 487 </td><td> NumberOfNodesQuotaExceededFault </td><td>  -  </td></tr>
        <tr><td> 488 </td><td> NumberOfNodesPerClusterLimitExceededFault </td><td>  -  </td></tr>
        <tr><td> 489 </td><td> InvalidVPCNetworkStateFault </td><td>  -  </td></tr>
        <tr><td> 490 </td><td> InvalidClusterSubnetGroupStateFault </td><td>  -  </td></tr>
        <tr><td> 491 </td><td> InvalidSubnet </td><td>  -  </td></tr>
        <tr><td> 492 </td><td> ClusterSubnetGroupNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 493 </td><td> UnauthorizedOperation </td><td>  -  </td></tr>
        <tr><td> 494 </td><td> HsmClientCertificateNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 495 </td><td> HsmConfigurationNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 496 </td><td> InvalidElasticIpFault </td><td>  -  </td></tr>
        <tr><td> 497 </td><td> ClusterParameterGroupNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 498 </td><td> ClusterSecurityGroupNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 499 </td><td> LimitExceededFault </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> DependentServiceRequestThrottlingFault </td><td>  -  </td></tr>
        <tr><td> 501 </td><td> InvalidClusterTrackFault </td><td>  -  </td></tr>
        <tr><td> 502 </td><td> SnapshotScheduleNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 503 </td><td> TagLimitExceededFault </td><td>  -  </td></tr>
        <tr><td> 504 </td><td> InvalidTagFault </td><td>  -  </td></tr>
        <tr><td> 505 </td><td> ReservedNodeNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 506 </td><td> InvalidReservedNodeStateFault </td><td>  -  </td></tr>
        <tr><td> 507 </td><td> ReservedNodeAlreadyMigratedFault </td><td>  -  </td></tr>
        <tr><td> 508 </td><td> ReservedNodeOfferingNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 509 </td><td> DependentServiceUnavailableFault </td><td>  -  </td></tr>
        <tr><td> 510 </td><td> ReservedNodeAlreadyExistsFault </td><td>  -  </td></tr>
        <tr><td> 511 </td><td> UnsupportedOperationFault </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call pOSTRestoreFromClusterSnapshotCall(String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, RestoreFromClusterSnapshotMessage restoreFromClusterSnapshotMessage, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = restoreFromClusterSnapshotMessage;

        // create path and map variables
        String localVarPath = "/#Action=RestoreFromClusterSnapshot";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (action != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("Action", action));
        }

        if (version != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("Version", version));
        }

        if (xAmzContentSha256 != null) {
            localVarHeaderParams.put("X-Amz-Content-Sha256", localVarApiClient.parameterToString(xAmzContentSha256));
        }

        if (xAmzDate != null) {
            localVarHeaderParams.put("X-Amz-Date", localVarApiClient.parameterToString(xAmzDate));
        }

        if (xAmzAlgorithm != null) {
            localVarHeaderParams.put("X-Amz-Algorithm", localVarApiClient.parameterToString(xAmzAlgorithm));
        }

        if (xAmzCredential != null) {
            localVarHeaderParams.put("X-Amz-Credential", localVarApiClient.parameterToString(xAmzCredential));
        }

        if (xAmzSecurityToken != null) {
            localVarHeaderParams.put("X-Amz-Security-Token", localVarApiClient.parameterToString(xAmzSecurityToken));
        }

        if (xAmzSignature != null) {
            localVarHeaderParams.put("X-Amz-Signature", localVarApiClient.parameterToString(xAmzSignature));
        }

        if (xAmzSignedHeaders != null) {
            localVarHeaderParams.put("X-Amz-SignedHeaders", localVarApiClient.parameterToString(xAmzSignedHeaders));
        }

        final String[] localVarAccepts = {
            "text/xml"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            "text/xml"
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "hmac" };
        return localVarApiClient.buildCall(basePath, localVarPath, "POST", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call pOSTRestoreFromClusterSnapshotValidateBeforeCall(String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, RestoreFromClusterSnapshotMessage restoreFromClusterSnapshotMessage, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'action' is set
        if (action == null) {
            throw new ApiException("Missing the required parameter 'action' when calling pOSTRestoreFromClusterSnapshot(Async)");
        }

        // verify the required parameter 'version' is set
        if (version == null) {
            throw new ApiException("Missing the required parameter 'version' when calling pOSTRestoreFromClusterSnapshot(Async)");
        }

        return pOSTRestoreFromClusterSnapshotCall(action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, restoreFromClusterSnapshotMessage, _callback);

    }

    /**
     * 
     * &lt;p&gt;Creates a new cluster from a snapshot. By default, Amazon Redshift creates the resulting cluster with the same configuration as the original cluster from which the snapshot was created, except that the new cluster is created with the default cluster security and parameter groups. After Amazon Redshift creates the cluster, you can use the &lt;a&gt;ModifyCluster&lt;/a&gt; API to associate a different security group and different parameter group with the restored cluster. If you are using a DS node type, you can also choose to change to another DS node type of the same size during restore.&lt;/p&gt; &lt;p&gt;If you restore a cluster into a VPC, you must provide a cluster subnet group where you want the cluster restored.&lt;/p&gt; &lt;p&gt; For more information about working with snapshots, go to &lt;a href&#x3D;\&quot;https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-snapshots.html\&quot;&gt;Amazon Redshift Snapshots&lt;/a&gt; in the &lt;i&gt;Amazon Redshift Cluster Management Guide&lt;/i&gt;.&lt;/p&gt;
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param restoreFromClusterSnapshotMessage  (optional)
     * @return RestoreFromClusterSnapshotResult
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> AccessToSnapshotDeniedFault </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> ClusterAlreadyExistsFault </td><td>  -  </td></tr>
        <tr><td> 482 </td><td> ClusterSnapshotNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 483 </td><td> ClusterQuotaExceededFault </td><td>  -  </td></tr>
        <tr><td> 484 </td><td> InsufficientClusterCapacityFault </td><td>  -  </td></tr>
        <tr><td> 485 </td><td> InvalidClusterSnapshotStateFault </td><td>  -  </td></tr>
        <tr><td> 486 </td><td> InvalidRestoreFault </td><td>  -  </td></tr>
        <tr><td> 487 </td><td> NumberOfNodesQuotaExceededFault </td><td>  -  </td></tr>
        <tr><td> 488 </td><td> NumberOfNodesPerClusterLimitExceededFault </td><td>  -  </td></tr>
        <tr><td> 489 </td><td> InvalidVPCNetworkStateFault </td><td>  -  </td></tr>
        <tr><td> 490 </td><td> InvalidClusterSubnetGroupStateFault </td><td>  -  </td></tr>
        <tr><td> 491 </td><td> InvalidSubnet </td><td>  -  </td></tr>
        <tr><td> 492 </td><td> ClusterSubnetGroupNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 493 </td><td> UnauthorizedOperation </td><td>  -  </td></tr>
        <tr><td> 494 </td><td> HsmClientCertificateNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 495 </td><td> HsmConfigurationNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 496 </td><td> InvalidElasticIpFault </td><td>  -  </td></tr>
        <tr><td> 497 </td><td> ClusterParameterGroupNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 498 </td><td> ClusterSecurityGroupNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 499 </td><td> LimitExceededFault </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> DependentServiceRequestThrottlingFault </td><td>  -  </td></tr>
        <tr><td> 501 </td><td> InvalidClusterTrackFault </td><td>  -  </td></tr>
        <tr><td> 502 </td><td> SnapshotScheduleNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 503 </td><td> TagLimitExceededFault </td><td>  -  </td></tr>
        <tr><td> 504 </td><td> InvalidTagFault </td><td>  -  </td></tr>
        <tr><td> 505 </td><td> ReservedNodeNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 506 </td><td> InvalidReservedNodeStateFault </td><td>  -  </td></tr>
        <tr><td> 507 </td><td> ReservedNodeAlreadyMigratedFault </td><td>  -  </td></tr>
        <tr><td> 508 </td><td> ReservedNodeOfferingNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 509 </td><td> DependentServiceUnavailableFault </td><td>  -  </td></tr>
        <tr><td> 510 </td><td> ReservedNodeAlreadyExistsFault </td><td>  -  </td></tr>
        <tr><td> 511 </td><td> UnsupportedOperationFault </td><td>  -  </td></tr>
     </table>
     */
    public RestoreFromClusterSnapshotResult pOSTRestoreFromClusterSnapshot(String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, RestoreFromClusterSnapshotMessage restoreFromClusterSnapshotMessage) throws ApiException {
        ApiResponse<RestoreFromClusterSnapshotResult> localVarResp = pOSTRestoreFromClusterSnapshotWithHttpInfo(action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, restoreFromClusterSnapshotMessage);
        return localVarResp.getData();
    }

    /**
     * 
     * &lt;p&gt;Creates a new cluster from a snapshot. By default, Amazon Redshift creates the resulting cluster with the same configuration as the original cluster from which the snapshot was created, except that the new cluster is created with the default cluster security and parameter groups. After Amazon Redshift creates the cluster, you can use the &lt;a&gt;ModifyCluster&lt;/a&gt; API to associate a different security group and different parameter group with the restored cluster. If you are using a DS node type, you can also choose to change to another DS node type of the same size during restore.&lt;/p&gt; &lt;p&gt;If you restore a cluster into a VPC, you must provide a cluster subnet group where you want the cluster restored.&lt;/p&gt; &lt;p&gt; For more information about working with snapshots, go to &lt;a href&#x3D;\&quot;https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-snapshots.html\&quot;&gt;Amazon Redshift Snapshots&lt;/a&gt; in the &lt;i&gt;Amazon Redshift Cluster Management Guide&lt;/i&gt;.&lt;/p&gt;
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param restoreFromClusterSnapshotMessage  (optional)
     * @return ApiResponse&lt;RestoreFromClusterSnapshotResult&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> AccessToSnapshotDeniedFault </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> ClusterAlreadyExistsFault </td><td>  -  </td></tr>
        <tr><td> 482 </td><td> ClusterSnapshotNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 483 </td><td> ClusterQuotaExceededFault </td><td>  -  </td></tr>
        <tr><td> 484 </td><td> InsufficientClusterCapacityFault </td><td>  -  </td></tr>
        <tr><td> 485 </td><td> InvalidClusterSnapshotStateFault </td><td>  -  </td></tr>
        <tr><td> 486 </td><td> InvalidRestoreFault </td><td>  -  </td></tr>
        <tr><td> 487 </td><td> NumberOfNodesQuotaExceededFault </td><td>  -  </td></tr>
        <tr><td> 488 </td><td> NumberOfNodesPerClusterLimitExceededFault </td><td>  -  </td></tr>
        <tr><td> 489 </td><td> InvalidVPCNetworkStateFault </td><td>  -  </td></tr>
        <tr><td> 490 </td><td> InvalidClusterSubnetGroupStateFault </td><td>  -  </td></tr>
        <tr><td> 491 </td><td> InvalidSubnet </td><td>  -  </td></tr>
        <tr><td> 492 </td><td> ClusterSubnetGroupNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 493 </td><td> UnauthorizedOperation </td><td>  -  </td></tr>
        <tr><td> 494 </td><td> HsmClientCertificateNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 495 </td><td> HsmConfigurationNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 496 </td><td> InvalidElasticIpFault </td><td>  -  </td></tr>
        <tr><td> 497 </td><td> ClusterParameterGroupNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 498 </td><td> ClusterSecurityGroupNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 499 </td><td> LimitExceededFault </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> DependentServiceRequestThrottlingFault </td><td>  -  </td></tr>
        <tr><td> 501 </td><td> InvalidClusterTrackFault </td><td>  -  </td></tr>
        <tr><td> 502 </td><td> SnapshotScheduleNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 503 </td><td> TagLimitExceededFault </td><td>  -  </td></tr>
        <tr><td> 504 </td><td> InvalidTagFault </td><td>  -  </td></tr>
        <tr><td> 505 </td><td> ReservedNodeNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 506 </td><td> InvalidReservedNodeStateFault </td><td>  -  </td></tr>
        <tr><td> 507 </td><td> ReservedNodeAlreadyMigratedFault </td><td>  -  </td></tr>
        <tr><td> 508 </td><td> ReservedNodeOfferingNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 509 </td><td> DependentServiceUnavailableFault </td><td>  -  </td></tr>
        <tr><td> 510 </td><td> ReservedNodeAlreadyExistsFault </td><td>  -  </td></tr>
        <tr><td> 511 </td><td> UnsupportedOperationFault </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<RestoreFromClusterSnapshotResult> pOSTRestoreFromClusterSnapshotWithHttpInfo(String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, RestoreFromClusterSnapshotMessage restoreFromClusterSnapshotMessage) throws ApiException {
        okhttp3.Call localVarCall = pOSTRestoreFromClusterSnapshotValidateBeforeCall(action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, restoreFromClusterSnapshotMessage, null);
        Type localVarReturnType = new TypeToken<RestoreFromClusterSnapshotResult>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     *  (asynchronously)
     * &lt;p&gt;Creates a new cluster from a snapshot. By default, Amazon Redshift creates the resulting cluster with the same configuration as the original cluster from which the snapshot was created, except that the new cluster is created with the default cluster security and parameter groups. After Amazon Redshift creates the cluster, you can use the &lt;a&gt;ModifyCluster&lt;/a&gt; API to associate a different security group and different parameter group with the restored cluster. If you are using a DS node type, you can also choose to change to another DS node type of the same size during restore.&lt;/p&gt; &lt;p&gt;If you restore a cluster into a VPC, you must provide a cluster subnet group where you want the cluster restored.&lt;/p&gt; &lt;p&gt; For more information about working with snapshots, go to &lt;a href&#x3D;\&quot;https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-snapshots.html\&quot;&gt;Amazon Redshift Snapshots&lt;/a&gt; in the &lt;i&gt;Amazon Redshift Cluster Management Guide&lt;/i&gt;.&lt;/p&gt;
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param restoreFromClusterSnapshotMessage  (optional)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> AccessToSnapshotDeniedFault </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> ClusterAlreadyExistsFault </td><td>  -  </td></tr>
        <tr><td> 482 </td><td> ClusterSnapshotNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 483 </td><td> ClusterQuotaExceededFault </td><td>  -  </td></tr>
        <tr><td> 484 </td><td> InsufficientClusterCapacityFault </td><td>  -  </td></tr>
        <tr><td> 485 </td><td> InvalidClusterSnapshotStateFault </td><td>  -  </td></tr>
        <tr><td> 486 </td><td> InvalidRestoreFault </td><td>  -  </td></tr>
        <tr><td> 487 </td><td> NumberOfNodesQuotaExceededFault </td><td>  -  </td></tr>
        <tr><td> 488 </td><td> NumberOfNodesPerClusterLimitExceededFault </td><td>  -  </td></tr>
        <tr><td> 489 </td><td> InvalidVPCNetworkStateFault </td><td>  -  </td></tr>
        <tr><td> 490 </td><td> InvalidClusterSubnetGroupStateFault </td><td>  -  </td></tr>
        <tr><td> 491 </td><td> InvalidSubnet </td><td>  -  </td></tr>
        <tr><td> 492 </td><td> ClusterSubnetGroupNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 493 </td><td> UnauthorizedOperation </td><td>  -  </td></tr>
        <tr><td> 494 </td><td> HsmClientCertificateNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 495 </td><td> HsmConfigurationNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 496 </td><td> InvalidElasticIpFault </td><td>  -  </td></tr>
        <tr><td> 497 </td><td> ClusterParameterGroupNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 498 </td><td> ClusterSecurityGroupNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 499 </td><td> LimitExceededFault </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> DependentServiceRequestThrottlingFault </td><td>  -  </td></tr>
        <tr><td> 501 </td><td> InvalidClusterTrackFault </td><td>  -  </td></tr>
        <tr><td> 502 </td><td> SnapshotScheduleNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 503 </td><td> TagLimitExceededFault </td><td>  -  </td></tr>
        <tr><td> 504 </td><td> InvalidTagFault </td><td>  -  </td></tr>
        <tr><td> 505 </td><td> ReservedNodeNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 506 </td><td> InvalidReservedNodeStateFault </td><td>  -  </td></tr>
        <tr><td> 507 </td><td> ReservedNodeAlreadyMigratedFault </td><td>  -  </td></tr>
        <tr><td> 508 </td><td> ReservedNodeOfferingNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 509 </td><td> DependentServiceUnavailableFault </td><td>  -  </td></tr>
        <tr><td> 510 </td><td> ReservedNodeAlreadyExistsFault </td><td>  -  </td></tr>
        <tr><td> 511 </td><td> UnsupportedOperationFault </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call pOSTRestoreFromClusterSnapshotAsync(String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, RestoreFromClusterSnapshotMessage restoreFromClusterSnapshotMessage, final ApiCallback<RestoreFromClusterSnapshotResult> _callback) throws ApiException {

        okhttp3.Call localVarCall = pOSTRestoreFromClusterSnapshotValidateBeforeCall(action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, restoreFromClusterSnapshotMessage, _callback);
        Type localVarReturnType = new TypeToken<RestoreFromClusterSnapshotResult>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for pOSTRestoreTableFromClusterSnapshot
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param restoreTableFromClusterSnapshotMessage  (optional)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> ClusterSnapshotNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> InProgressTableRestoreQuotaExceededFault </td><td>  -  </td></tr>
        <tr><td> 482 </td><td> InvalidClusterSnapshotStateFault </td><td>  -  </td></tr>
        <tr><td> 483 </td><td> InvalidTableRestoreArgumentFault </td><td>  -  </td></tr>
        <tr><td> 484 </td><td> ClusterNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 485 </td><td> InvalidClusterStateFault </td><td>  -  </td></tr>
        <tr><td> 486 </td><td> UnsupportedOperationFault </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call pOSTRestoreTableFromClusterSnapshotCall(String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, RestoreTableFromClusterSnapshotMessage restoreTableFromClusterSnapshotMessage, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = restoreTableFromClusterSnapshotMessage;

        // create path and map variables
        String localVarPath = "/#Action=RestoreTableFromClusterSnapshot";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (action != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("Action", action));
        }

        if (version != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("Version", version));
        }

        if (xAmzContentSha256 != null) {
            localVarHeaderParams.put("X-Amz-Content-Sha256", localVarApiClient.parameterToString(xAmzContentSha256));
        }

        if (xAmzDate != null) {
            localVarHeaderParams.put("X-Amz-Date", localVarApiClient.parameterToString(xAmzDate));
        }

        if (xAmzAlgorithm != null) {
            localVarHeaderParams.put("X-Amz-Algorithm", localVarApiClient.parameterToString(xAmzAlgorithm));
        }

        if (xAmzCredential != null) {
            localVarHeaderParams.put("X-Amz-Credential", localVarApiClient.parameterToString(xAmzCredential));
        }

        if (xAmzSecurityToken != null) {
            localVarHeaderParams.put("X-Amz-Security-Token", localVarApiClient.parameterToString(xAmzSecurityToken));
        }

        if (xAmzSignature != null) {
            localVarHeaderParams.put("X-Amz-Signature", localVarApiClient.parameterToString(xAmzSignature));
        }

        if (xAmzSignedHeaders != null) {
            localVarHeaderParams.put("X-Amz-SignedHeaders", localVarApiClient.parameterToString(xAmzSignedHeaders));
        }

        final String[] localVarAccepts = {
            "text/xml"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            "text/xml"
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "hmac" };
        return localVarApiClient.buildCall(basePath, localVarPath, "POST", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call pOSTRestoreTableFromClusterSnapshotValidateBeforeCall(String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, RestoreTableFromClusterSnapshotMessage restoreTableFromClusterSnapshotMessage, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'action' is set
        if (action == null) {
            throw new ApiException("Missing the required parameter 'action' when calling pOSTRestoreTableFromClusterSnapshot(Async)");
        }

        // verify the required parameter 'version' is set
        if (version == null) {
            throw new ApiException("Missing the required parameter 'version' when calling pOSTRestoreTableFromClusterSnapshot(Async)");
        }

        return pOSTRestoreTableFromClusterSnapshotCall(action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, restoreTableFromClusterSnapshotMessage, _callback);

    }

    /**
     * 
     * &lt;p&gt;Creates a new table from a table in an Amazon Redshift cluster snapshot. You must create the new table within the Amazon Redshift cluster that the snapshot was taken from.&lt;/p&gt; &lt;p&gt;You cannot use &lt;code&gt;RestoreTableFromClusterSnapshot&lt;/code&gt; to restore a table with the same name as an existing table in an Amazon Redshift cluster. That is, you cannot overwrite an existing table in a cluster with a restored table. If you want to replace your original table with a new, restored table, then rename or drop your original table before you call &lt;code&gt;RestoreTableFromClusterSnapshot&lt;/code&gt;. When you have renamed your original table, then you can pass the original name of the table as the &lt;code&gt;NewTableName&lt;/code&gt; parameter value in the call to &lt;code&gt;RestoreTableFromClusterSnapshot&lt;/code&gt;. This way, you can replace the original table with the table created from the snapshot.&lt;/p&gt; &lt;p&gt;You can&#39;t use this operation to restore tables with &lt;a href&#x3D;\&quot;https://docs.aws.amazon.com/redshift/latest/dg/t_Sorting_data.html#t_Sorting_data-interleaved\&quot;&gt;interleaved sort keys&lt;/a&gt;.&lt;/p&gt;
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param restoreTableFromClusterSnapshotMessage  (optional)
     * @return RestoreTableFromClusterSnapshotResult
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> ClusterSnapshotNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> InProgressTableRestoreQuotaExceededFault </td><td>  -  </td></tr>
        <tr><td> 482 </td><td> InvalidClusterSnapshotStateFault </td><td>  -  </td></tr>
        <tr><td> 483 </td><td> InvalidTableRestoreArgumentFault </td><td>  -  </td></tr>
        <tr><td> 484 </td><td> ClusterNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 485 </td><td> InvalidClusterStateFault </td><td>  -  </td></tr>
        <tr><td> 486 </td><td> UnsupportedOperationFault </td><td>  -  </td></tr>
     </table>
     */
    public RestoreTableFromClusterSnapshotResult pOSTRestoreTableFromClusterSnapshot(String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, RestoreTableFromClusterSnapshotMessage restoreTableFromClusterSnapshotMessage) throws ApiException {
        ApiResponse<RestoreTableFromClusterSnapshotResult> localVarResp = pOSTRestoreTableFromClusterSnapshotWithHttpInfo(action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, restoreTableFromClusterSnapshotMessage);
        return localVarResp.getData();
    }

    /**
     * 
     * &lt;p&gt;Creates a new table from a table in an Amazon Redshift cluster snapshot. You must create the new table within the Amazon Redshift cluster that the snapshot was taken from.&lt;/p&gt; &lt;p&gt;You cannot use &lt;code&gt;RestoreTableFromClusterSnapshot&lt;/code&gt; to restore a table with the same name as an existing table in an Amazon Redshift cluster. That is, you cannot overwrite an existing table in a cluster with a restored table. If you want to replace your original table with a new, restored table, then rename or drop your original table before you call &lt;code&gt;RestoreTableFromClusterSnapshot&lt;/code&gt;. When you have renamed your original table, then you can pass the original name of the table as the &lt;code&gt;NewTableName&lt;/code&gt; parameter value in the call to &lt;code&gt;RestoreTableFromClusterSnapshot&lt;/code&gt;. This way, you can replace the original table with the table created from the snapshot.&lt;/p&gt; &lt;p&gt;You can&#39;t use this operation to restore tables with &lt;a href&#x3D;\&quot;https://docs.aws.amazon.com/redshift/latest/dg/t_Sorting_data.html#t_Sorting_data-interleaved\&quot;&gt;interleaved sort keys&lt;/a&gt;.&lt;/p&gt;
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param restoreTableFromClusterSnapshotMessage  (optional)
     * @return ApiResponse&lt;RestoreTableFromClusterSnapshotResult&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> ClusterSnapshotNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> InProgressTableRestoreQuotaExceededFault </td><td>  -  </td></tr>
        <tr><td> 482 </td><td> InvalidClusterSnapshotStateFault </td><td>  -  </td></tr>
        <tr><td> 483 </td><td> InvalidTableRestoreArgumentFault </td><td>  -  </td></tr>
        <tr><td> 484 </td><td> ClusterNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 485 </td><td> InvalidClusterStateFault </td><td>  -  </td></tr>
        <tr><td> 486 </td><td> UnsupportedOperationFault </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<RestoreTableFromClusterSnapshotResult> pOSTRestoreTableFromClusterSnapshotWithHttpInfo(String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, RestoreTableFromClusterSnapshotMessage restoreTableFromClusterSnapshotMessage) throws ApiException {
        okhttp3.Call localVarCall = pOSTRestoreTableFromClusterSnapshotValidateBeforeCall(action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, restoreTableFromClusterSnapshotMessage, null);
        Type localVarReturnType = new TypeToken<RestoreTableFromClusterSnapshotResult>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     *  (asynchronously)
     * &lt;p&gt;Creates a new table from a table in an Amazon Redshift cluster snapshot. You must create the new table within the Amazon Redshift cluster that the snapshot was taken from.&lt;/p&gt; &lt;p&gt;You cannot use &lt;code&gt;RestoreTableFromClusterSnapshot&lt;/code&gt; to restore a table with the same name as an existing table in an Amazon Redshift cluster. That is, you cannot overwrite an existing table in a cluster with a restored table. If you want to replace your original table with a new, restored table, then rename or drop your original table before you call &lt;code&gt;RestoreTableFromClusterSnapshot&lt;/code&gt;. When you have renamed your original table, then you can pass the original name of the table as the &lt;code&gt;NewTableName&lt;/code&gt; parameter value in the call to &lt;code&gt;RestoreTableFromClusterSnapshot&lt;/code&gt;. This way, you can replace the original table with the table created from the snapshot.&lt;/p&gt; &lt;p&gt;You can&#39;t use this operation to restore tables with &lt;a href&#x3D;\&quot;https://docs.aws.amazon.com/redshift/latest/dg/t_Sorting_data.html#t_Sorting_data-interleaved\&quot;&gt;interleaved sort keys&lt;/a&gt;.&lt;/p&gt;
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param restoreTableFromClusterSnapshotMessage  (optional)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> ClusterSnapshotNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> InProgressTableRestoreQuotaExceededFault </td><td>  -  </td></tr>
        <tr><td> 482 </td><td> InvalidClusterSnapshotStateFault </td><td>  -  </td></tr>
        <tr><td> 483 </td><td> InvalidTableRestoreArgumentFault </td><td>  -  </td></tr>
        <tr><td> 484 </td><td> ClusterNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 485 </td><td> InvalidClusterStateFault </td><td>  -  </td></tr>
        <tr><td> 486 </td><td> UnsupportedOperationFault </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call pOSTRestoreTableFromClusterSnapshotAsync(String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, RestoreTableFromClusterSnapshotMessage restoreTableFromClusterSnapshotMessage, final ApiCallback<RestoreTableFromClusterSnapshotResult> _callback) throws ApiException {

        okhttp3.Call localVarCall = pOSTRestoreTableFromClusterSnapshotValidateBeforeCall(action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, restoreTableFromClusterSnapshotMessage, _callback);
        Type localVarReturnType = new TypeToken<RestoreTableFromClusterSnapshotResult>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for pOSTResumeCluster
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param resumeClusterMessage  (optional)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> ClusterNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> InvalidClusterStateFault </td><td>  -  </td></tr>
        <tr><td> 482 </td><td> InsufficientClusterCapacityFault </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call pOSTResumeClusterCall(String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, ResumeClusterMessage resumeClusterMessage, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = resumeClusterMessage;

        // create path and map variables
        String localVarPath = "/#Action=ResumeCluster";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (action != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("Action", action));
        }

        if (version != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("Version", version));
        }

        if (xAmzContentSha256 != null) {
            localVarHeaderParams.put("X-Amz-Content-Sha256", localVarApiClient.parameterToString(xAmzContentSha256));
        }

        if (xAmzDate != null) {
            localVarHeaderParams.put("X-Amz-Date", localVarApiClient.parameterToString(xAmzDate));
        }

        if (xAmzAlgorithm != null) {
            localVarHeaderParams.put("X-Amz-Algorithm", localVarApiClient.parameterToString(xAmzAlgorithm));
        }

        if (xAmzCredential != null) {
            localVarHeaderParams.put("X-Amz-Credential", localVarApiClient.parameterToString(xAmzCredential));
        }

        if (xAmzSecurityToken != null) {
            localVarHeaderParams.put("X-Amz-Security-Token", localVarApiClient.parameterToString(xAmzSecurityToken));
        }

        if (xAmzSignature != null) {
            localVarHeaderParams.put("X-Amz-Signature", localVarApiClient.parameterToString(xAmzSignature));
        }

        if (xAmzSignedHeaders != null) {
            localVarHeaderParams.put("X-Amz-SignedHeaders", localVarApiClient.parameterToString(xAmzSignedHeaders));
        }

        final String[] localVarAccepts = {
            "text/xml"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            "text/xml"
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "hmac" };
        return localVarApiClient.buildCall(basePath, localVarPath, "POST", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call pOSTResumeClusterValidateBeforeCall(String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, ResumeClusterMessage resumeClusterMessage, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'action' is set
        if (action == null) {
            throw new ApiException("Missing the required parameter 'action' when calling pOSTResumeCluster(Async)");
        }

        // verify the required parameter 'version' is set
        if (version == null) {
            throw new ApiException("Missing the required parameter 'version' when calling pOSTResumeCluster(Async)");
        }

        return pOSTResumeClusterCall(action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, resumeClusterMessage, _callback);

    }

    /**
     * 
     * Resumes a paused cluster.
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param resumeClusterMessage  (optional)
     * @return ResumeClusterResult
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> ClusterNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> InvalidClusterStateFault </td><td>  -  </td></tr>
        <tr><td> 482 </td><td> InsufficientClusterCapacityFault </td><td>  -  </td></tr>
     </table>
     */
    public ResumeClusterResult pOSTResumeCluster(String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, ResumeClusterMessage resumeClusterMessage) throws ApiException {
        ApiResponse<ResumeClusterResult> localVarResp = pOSTResumeClusterWithHttpInfo(action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, resumeClusterMessage);
        return localVarResp.getData();
    }

    /**
     * 
     * Resumes a paused cluster.
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param resumeClusterMessage  (optional)
     * @return ApiResponse&lt;ResumeClusterResult&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> ClusterNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> InvalidClusterStateFault </td><td>  -  </td></tr>
        <tr><td> 482 </td><td> InsufficientClusterCapacityFault </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<ResumeClusterResult> pOSTResumeClusterWithHttpInfo(String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, ResumeClusterMessage resumeClusterMessage) throws ApiException {
        okhttp3.Call localVarCall = pOSTResumeClusterValidateBeforeCall(action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, resumeClusterMessage, null);
        Type localVarReturnType = new TypeToken<ResumeClusterResult>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     *  (asynchronously)
     * Resumes a paused cluster.
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param resumeClusterMessage  (optional)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> ClusterNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> InvalidClusterStateFault </td><td>  -  </td></tr>
        <tr><td> 482 </td><td> InsufficientClusterCapacityFault </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call pOSTResumeClusterAsync(String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, ResumeClusterMessage resumeClusterMessage, final ApiCallback<ResumeClusterResult> _callback) throws ApiException {

        okhttp3.Call localVarCall = pOSTResumeClusterValidateBeforeCall(action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, resumeClusterMessage, _callback);
        Type localVarReturnType = new TypeToken<ResumeClusterResult>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for pOSTRevokeClusterSecurityGroupIngress
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param revokeClusterSecurityGroupIngressMessage  (optional)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> ClusterSecurityGroupNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> AuthorizationNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 482 </td><td> InvalidClusterSecurityGroupStateFault </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call pOSTRevokeClusterSecurityGroupIngressCall(String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, RevokeClusterSecurityGroupIngressMessage revokeClusterSecurityGroupIngressMessage, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = revokeClusterSecurityGroupIngressMessage;

        // create path and map variables
        String localVarPath = "/#Action=RevokeClusterSecurityGroupIngress";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (action != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("Action", action));
        }

        if (version != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("Version", version));
        }

        if (xAmzContentSha256 != null) {
            localVarHeaderParams.put("X-Amz-Content-Sha256", localVarApiClient.parameterToString(xAmzContentSha256));
        }

        if (xAmzDate != null) {
            localVarHeaderParams.put("X-Amz-Date", localVarApiClient.parameterToString(xAmzDate));
        }

        if (xAmzAlgorithm != null) {
            localVarHeaderParams.put("X-Amz-Algorithm", localVarApiClient.parameterToString(xAmzAlgorithm));
        }

        if (xAmzCredential != null) {
            localVarHeaderParams.put("X-Amz-Credential", localVarApiClient.parameterToString(xAmzCredential));
        }

        if (xAmzSecurityToken != null) {
            localVarHeaderParams.put("X-Amz-Security-Token", localVarApiClient.parameterToString(xAmzSecurityToken));
        }

        if (xAmzSignature != null) {
            localVarHeaderParams.put("X-Amz-Signature", localVarApiClient.parameterToString(xAmzSignature));
        }

        if (xAmzSignedHeaders != null) {
            localVarHeaderParams.put("X-Amz-SignedHeaders", localVarApiClient.parameterToString(xAmzSignedHeaders));
        }

        final String[] localVarAccepts = {
            "text/xml"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            "text/xml"
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "hmac" };
        return localVarApiClient.buildCall(basePath, localVarPath, "POST", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call pOSTRevokeClusterSecurityGroupIngressValidateBeforeCall(String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, RevokeClusterSecurityGroupIngressMessage revokeClusterSecurityGroupIngressMessage, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'action' is set
        if (action == null) {
            throw new ApiException("Missing the required parameter 'action' when calling pOSTRevokeClusterSecurityGroupIngress(Async)");
        }

        // verify the required parameter 'version' is set
        if (version == null) {
            throw new ApiException("Missing the required parameter 'version' when calling pOSTRevokeClusterSecurityGroupIngress(Async)");
        }

        return pOSTRevokeClusterSecurityGroupIngressCall(action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, revokeClusterSecurityGroupIngressMessage, _callback);

    }

    /**
     * 
     * Revokes an ingress rule in an Amazon Redshift security group for a previously authorized IP range or Amazon EC2 security group. To add an ingress rule, see &lt;a&gt;AuthorizeClusterSecurityGroupIngress&lt;/a&gt;. For information about managing security groups, go to &lt;a href&#x3D;\&quot;https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-security-groups.html\&quot;&gt;Amazon Redshift Cluster Security Groups&lt;/a&gt; in the &lt;i&gt;Amazon Redshift Cluster Management Guide&lt;/i&gt;. 
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param revokeClusterSecurityGroupIngressMessage  (optional)
     * @return RevokeClusterSecurityGroupIngressResult
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> ClusterSecurityGroupNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> AuthorizationNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 482 </td><td> InvalidClusterSecurityGroupStateFault </td><td>  -  </td></tr>
     </table>
     */
    public RevokeClusterSecurityGroupIngressResult pOSTRevokeClusterSecurityGroupIngress(String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, RevokeClusterSecurityGroupIngressMessage revokeClusterSecurityGroupIngressMessage) throws ApiException {
        ApiResponse<RevokeClusterSecurityGroupIngressResult> localVarResp = pOSTRevokeClusterSecurityGroupIngressWithHttpInfo(action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, revokeClusterSecurityGroupIngressMessage);
        return localVarResp.getData();
    }

    /**
     * 
     * Revokes an ingress rule in an Amazon Redshift security group for a previously authorized IP range or Amazon EC2 security group. To add an ingress rule, see &lt;a&gt;AuthorizeClusterSecurityGroupIngress&lt;/a&gt;. For information about managing security groups, go to &lt;a href&#x3D;\&quot;https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-security-groups.html\&quot;&gt;Amazon Redshift Cluster Security Groups&lt;/a&gt; in the &lt;i&gt;Amazon Redshift Cluster Management Guide&lt;/i&gt;. 
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param revokeClusterSecurityGroupIngressMessage  (optional)
     * @return ApiResponse&lt;RevokeClusterSecurityGroupIngressResult&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> ClusterSecurityGroupNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> AuthorizationNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 482 </td><td> InvalidClusterSecurityGroupStateFault </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<RevokeClusterSecurityGroupIngressResult> pOSTRevokeClusterSecurityGroupIngressWithHttpInfo(String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, RevokeClusterSecurityGroupIngressMessage revokeClusterSecurityGroupIngressMessage) throws ApiException {
        okhttp3.Call localVarCall = pOSTRevokeClusterSecurityGroupIngressValidateBeforeCall(action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, revokeClusterSecurityGroupIngressMessage, null);
        Type localVarReturnType = new TypeToken<RevokeClusterSecurityGroupIngressResult>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     *  (asynchronously)
     * Revokes an ingress rule in an Amazon Redshift security group for a previously authorized IP range or Amazon EC2 security group. To add an ingress rule, see &lt;a&gt;AuthorizeClusterSecurityGroupIngress&lt;/a&gt;. For information about managing security groups, go to &lt;a href&#x3D;\&quot;https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-security-groups.html\&quot;&gt;Amazon Redshift Cluster Security Groups&lt;/a&gt; in the &lt;i&gt;Amazon Redshift Cluster Management Guide&lt;/i&gt;. 
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param revokeClusterSecurityGroupIngressMessage  (optional)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> ClusterSecurityGroupNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> AuthorizationNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 482 </td><td> InvalidClusterSecurityGroupStateFault </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call pOSTRevokeClusterSecurityGroupIngressAsync(String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, RevokeClusterSecurityGroupIngressMessage revokeClusterSecurityGroupIngressMessage, final ApiCallback<RevokeClusterSecurityGroupIngressResult> _callback) throws ApiException {

        okhttp3.Call localVarCall = pOSTRevokeClusterSecurityGroupIngressValidateBeforeCall(action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, revokeClusterSecurityGroupIngressMessage, _callback);
        Type localVarReturnType = new TypeToken<RevokeClusterSecurityGroupIngressResult>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for pOSTRevokeEndpointAccess
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param revokeEndpointAccessMessage  (optional)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> ClusterNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> InvalidEndpointStateFault </td><td>  -  </td></tr>
        <tr><td> 482 </td><td> InvalidClusterSecurityGroupStateFault </td><td>  -  </td></tr>
        <tr><td> 483 </td><td> EndpointNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 484 </td><td> EndpointAuthorizationNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 485 </td><td> InvalidAuthorizationStateFault </td><td>  -  </td></tr>
        <tr><td> 486 </td><td> InvalidClusterStateFault </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call pOSTRevokeEndpointAccessCall(String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, RevokeEndpointAccessMessage revokeEndpointAccessMessage, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = revokeEndpointAccessMessage;

        // create path and map variables
        String localVarPath = "/#Action=RevokeEndpointAccess";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (action != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("Action", action));
        }

        if (version != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("Version", version));
        }

        if (xAmzContentSha256 != null) {
            localVarHeaderParams.put("X-Amz-Content-Sha256", localVarApiClient.parameterToString(xAmzContentSha256));
        }

        if (xAmzDate != null) {
            localVarHeaderParams.put("X-Amz-Date", localVarApiClient.parameterToString(xAmzDate));
        }

        if (xAmzAlgorithm != null) {
            localVarHeaderParams.put("X-Amz-Algorithm", localVarApiClient.parameterToString(xAmzAlgorithm));
        }

        if (xAmzCredential != null) {
            localVarHeaderParams.put("X-Amz-Credential", localVarApiClient.parameterToString(xAmzCredential));
        }

        if (xAmzSecurityToken != null) {
            localVarHeaderParams.put("X-Amz-Security-Token", localVarApiClient.parameterToString(xAmzSecurityToken));
        }

        if (xAmzSignature != null) {
            localVarHeaderParams.put("X-Amz-Signature", localVarApiClient.parameterToString(xAmzSignature));
        }

        if (xAmzSignedHeaders != null) {
            localVarHeaderParams.put("X-Amz-SignedHeaders", localVarApiClient.parameterToString(xAmzSignedHeaders));
        }

        final String[] localVarAccepts = {
            "text/xml"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            "text/xml"
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "hmac" };
        return localVarApiClient.buildCall(basePath, localVarPath, "POST", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call pOSTRevokeEndpointAccessValidateBeforeCall(String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, RevokeEndpointAccessMessage revokeEndpointAccessMessage, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'action' is set
        if (action == null) {
            throw new ApiException("Missing the required parameter 'action' when calling pOSTRevokeEndpointAccess(Async)");
        }

        // verify the required parameter 'version' is set
        if (version == null) {
            throw new ApiException("Missing the required parameter 'version' when calling pOSTRevokeEndpointAccess(Async)");
        }

        return pOSTRevokeEndpointAccessCall(action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, revokeEndpointAccessMessage, _callback);

    }

    /**
     * 
     * Revokes access to a cluster.
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param revokeEndpointAccessMessage  (optional)
     * @return EndpointAuthorization
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> ClusterNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> InvalidEndpointStateFault </td><td>  -  </td></tr>
        <tr><td> 482 </td><td> InvalidClusterSecurityGroupStateFault </td><td>  -  </td></tr>
        <tr><td> 483 </td><td> EndpointNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 484 </td><td> EndpointAuthorizationNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 485 </td><td> InvalidAuthorizationStateFault </td><td>  -  </td></tr>
        <tr><td> 486 </td><td> InvalidClusterStateFault </td><td>  -  </td></tr>
     </table>
     */
    public EndpointAuthorization pOSTRevokeEndpointAccess(String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, RevokeEndpointAccessMessage revokeEndpointAccessMessage) throws ApiException {
        ApiResponse<EndpointAuthorization> localVarResp = pOSTRevokeEndpointAccessWithHttpInfo(action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, revokeEndpointAccessMessage);
        return localVarResp.getData();
    }

    /**
     * 
     * Revokes access to a cluster.
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param revokeEndpointAccessMessage  (optional)
     * @return ApiResponse&lt;EndpointAuthorization&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> ClusterNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> InvalidEndpointStateFault </td><td>  -  </td></tr>
        <tr><td> 482 </td><td> InvalidClusterSecurityGroupStateFault </td><td>  -  </td></tr>
        <tr><td> 483 </td><td> EndpointNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 484 </td><td> EndpointAuthorizationNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 485 </td><td> InvalidAuthorizationStateFault </td><td>  -  </td></tr>
        <tr><td> 486 </td><td> InvalidClusterStateFault </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<EndpointAuthorization> pOSTRevokeEndpointAccessWithHttpInfo(String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, RevokeEndpointAccessMessage revokeEndpointAccessMessage) throws ApiException {
        okhttp3.Call localVarCall = pOSTRevokeEndpointAccessValidateBeforeCall(action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, revokeEndpointAccessMessage, null);
        Type localVarReturnType = new TypeToken<EndpointAuthorization>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     *  (asynchronously)
     * Revokes access to a cluster.
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param revokeEndpointAccessMessage  (optional)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> ClusterNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> InvalidEndpointStateFault </td><td>  -  </td></tr>
        <tr><td> 482 </td><td> InvalidClusterSecurityGroupStateFault </td><td>  -  </td></tr>
        <tr><td> 483 </td><td> EndpointNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 484 </td><td> EndpointAuthorizationNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 485 </td><td> InvalidAuthorizationStateFault </td><td>  -  </td></tr>
        <tr><td> 486 </td><td> InvalidClusterStateFault </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call pOSTRevokeEndpointAccessAsync(String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, RevokeEndpointAccessMessage revokeEndpointAccessMessage, final ApiCallback<EndpointAuthorization> _callback) throws ApiException {

        okhttp3.Call localVarCall = pOSTRevokeEndpointAccessValidateBeforeCall(action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, revokeEndpointAccessMessage, _callback);
        Type localVarReturnType = new TypeToken<EndpointAuthorization>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for pOSTRevokeSnapshotAccess
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param revokeSnapshotAccessMessage  (optional)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> AccessToSnapshotDeniedFault </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> AuthorizationNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 482 </td><td> ClusterSnapshotNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 483 </td><td> UnsupportedOperationFault </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call pOSTRevokeSnapshotAccessCall(String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, RevokeSnapshotAccessMessage revokeSnapshotAccessMessage, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = revokeSnapshotAccessMessage;

        // create path and map variables
        String localVarPath = "/#Action=RevokeSnapshotAccess";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (action != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("Action", action));
        }

        if (version != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("Version", version));
        }

        if (xAmzContentSha256 != null) {
            localVarHeaderParams.put("X-Amz-Content-Sha256", localVarApiClient.parameterToString(xAmzContentSha256));
        }

        if (xAmzDate != null) {
            localVarHeaderParams.put("X-Amz-Date", localVarApiClient.parameterToString(xAmzDate));
        }

        if (xAmzAlgorithm != null) {
            localVarHeaderParams.put("X-Amz-Algorithm", localVarApiClient.parameterToString(xAmzAlgorithm));
        }

        if (xAmzCredential != null) {
            localVarHeaderParams.put("X-Amz-Credential", localVarApiClient.parameterToString(xAmzCredential));
        }

        if (xAmzSecurityToken != null) {
            localVarHeaderParams.put("X-Amz-Security-Token", localVarApiClient.parameterToString(xAmzSecurityToken));
        }

        if (xAmzSignature != null) {
            localVarHeaderParams.put("X-Amz-Signature", localVarApiClient.parameterToString(xAmzSignature));
        }

        if (xAmzSignedHeaders != null) {
            localVarHeaderParams.put("X-Amz-SignedHeaders", localVarApiClient.parameterToString(xAmzSignedHeaders));
        }

        final String[] localVarAccepts = {
            "text/xml"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            "text/xml"
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "hmac" };
        return localVarApiClient.buildCall(basePath, localVarPath, "POST", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call pOSTRevokeSnapshotAccessValidateBeforeCall(String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, RevokeSnapshotAccessMessage revokeSnapshotAccessMessage, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'action' is set
        if (action == null) {
            throw new ApiException("Missing the required parameter 'action' when calling pOSTRevokeSnapshotAccess(Async)");
        }

        // verify the required parameter 'version' is set
        if (version == null) {
            throw new ApiException("Missing the required parameter 'version' when calling pOSTRevokeSnapshotAccess(Async)");
        }

        return pOSTRevokeSnapshotAccessCall(action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, revokeSnapshotAccessMessage, _callback);

    }

    /**
     * 
     * &lt;p&gt;Removes the ability of the specified Amazon Web Services account to restore the specified snapshot. If the account is currently restoring the snapshot, the restore will run to completion.&lt;/p&gt; &lt;p&gt; For more information about working with snapshots, go to &lt;a href&#x3D;\&quot;https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-snapshots.html\&quot;&gt;Amazon Redshift Snapshots&lt;/a&gt; in the &lt;i&gt;Amazon Redshift Cluster Management Guide&lt;/i&gt;.&lt;/p&gt;
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param revokeSnapshotAccessMessage  (optional)
     * @return RevokeSnapshotAccessResult
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> AccessToSnapshotDeniedFault </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> AuthorizationNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 482 </td><td> ClusterSnapshotNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 483 </td><td> UnsupportedOperationFault </td><td>  -  </td></tr>
     </table>
     */
    public RevokeSnapshotAccessResult pOSTRevokeSnapshotAccess(String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, RevokeSnapshotAccessMessage revokeSnapshotAccessMessage) throws ApiException {
        ApiResponse<RevokeSnapshotAccessResult> localVarResp = pOSTRevokeSnapshotAccessWithHttpInfo(action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, revokeSnapshotAccessMessage);
        return localVarResp.getData();
    }

    /**
     * 
     * &lt;p&gt;Removes the ability of the specified Amazon Web Services account to restore the specified snapshot. If the account is currently restoring the snapshot, the restore will run to completion.&lt;/p&gt; &lt;p&gt; For more information about working with snapshots, go to &lt;a href&#x3D;\&quot;https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-snapshots.html\&quot;&gt;Amazon Redshift Snapshots&lt;/a&gt; in the &lt;i&gt;Amazon Redshift Cluster Management Guide&lt;/i&gt;.&lt;/p&gt;
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param revokeSnapshotAccessMessage  (optional)
     * @return ApiResponse&lt;RevokeSnapshotAccessResult&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> AccessToSnapshotDeniedFault </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> AuthorizationNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 482 </td><td> ClusterSnapshotNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 483 </td><td> UnsupportedOperationFault </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<RevokeSnapshotAccessResult> pOSTRevokeSnapshotAccessWithHttpInfo(String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, RevokeSnapshotAccessMessage revokeSnapshotAccessMessage) throws ApiException {
        okhttp3.Call localVarCall = pOSTRevokeSnapshotAccessValidateBeforeCall(action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, revokeSnapshotAccessMessage, null);
        Type localVarReturnType = new TypeToken<RevokeSnapshotAccessResult>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     *  (asynchronously)
     * &lt;p&gt;Removes the ability of the specified Amazon Web Services account to restore the specified snapshot. If the account is currently restoring the snapshot, the restore will run to completion.&lt;/p&gt; &lt;p&gt; For more information about working with snapshots, go to &lt;a href&#x3D;\&quot;https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-snapshots.html\&quot;&gt;Amazon Redshift Snapshots&lt;/a&gt; in the &lt;i&gt;Amazon Redshift Cluster Management Guide&lt;/i&gt;.&lt;/p&gt;
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param revokeSnapshotAccessMessage  (optional)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> AccessToSnapshotDeniedFault </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> AuthorizationNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 482 </td><td> ClusterSnapshotNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 483 </td><td> UnsupportedOperationFault </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call pOSTRevokeSnapshotAccessAsync(String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, RevokeSnapshotAccessMessage revokeSnapshotAccessMessage, final ApiCallback<RevokeSnapshotAccessResult> _callback) throws ApiException {

        okhttp3.Call localVarCall = pOSTRevokeSnapshotAccessValidateBeforeCall(action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, revokeSnapshotAccessMessage, _callback);
        Type localVarReturnType = new TypeToken<RevokeSnapshotAccessResult>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for pOSTRotateEncryptionKey
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param rotateEncryptionKeyMessage  (optional)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> ClusterNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> InvalidClusterStateFault </td><td>  -  </td></tr>
        <tr><td> 482 </td><td> DependentServiceRequestThrottlingFault </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call pOSTRotateEncryptionKeyCall(String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, RotateEncryptionKeyMessage rotateEncryptionKeyMessage, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = rotateEncryptionKeyMessage;

        // create path and map variables
        String localVarPath = "/#Action=RotateEncryptionKey";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (action != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("Action", action));
        }

        if (version != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("Version", version));
        }

        if (xAmzContentSha256 != null) {
            localVarHeaderParams.put("X-Amz-Content-Sha256", localVarApiClient.parameterToString(xAmzContentSha256));
        }

        if (xAmzDate != null) {
            localVarHeaderParams.put("X-Amz-Date", localVarApiClient.parameterToString(xAmzDate));
        }

        if (xAmzAlgorithm != null) {
            localVarHeaderParams.put("X-Amz-Algorithm", localVarApiClient.parameterToString(xAmzAlgorithm));
        }

        if (xAmzCredential != null) {
            localVarHeaderParams.put("X-Amz-Credential", localVarApiClient.parameterToString(xAmzCredential));
        }

        if (xAmzSecurityToken != null) {
            localVarHeaderParams.put("X-Amz-Security-Token", localVarApiClient.parameterToString(xAmzSecurityToken));
        }

        if (xAmzSignature != null) {
            localVarHeaderParams.put("X-Amz-Signature", localVarApiClient.parameterToString(xAmzSignature));
        }

        if (xAmzSignedHeaders != null) {
            localVarHeaderParams.put("X-Amz-SignedHeaders", localVarApiClient.parameterToString(xAmzSignedHeaders));
        }

        final String[] localVarAccepts = {
            "text/xml"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            "text/xml"
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "hmac" };
        return localVarApiClient.buildCall(basePath, localVarPath, "POST", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call pOSTRotateEncryptionKeyValidateBeforeCall(String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, RotateEncryptionKeyMessage rotateEncryptionKeyMessage, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'action' is set
        if (action == null) {
            throw new ApiException("Missing the required parameter 'action' when calling pOSTRotateEncryptionKey(Async)");
        }

        // verify the required parameter 'version' is set
        if (version == null) {
            throw new ApiException("Missing the required parameter 'version' when calling pOSTRotateEncryptionKey(Async)");
        }

        return pOSTRotateEncryptionKeyCall(action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, rotateEncryptionKeyMessage, _callback);

    }

    /**
     * 
     * Rotates the encryption keys for a cluster.
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param rotateEncryptionKeyMessage  (optional)
     * @return RotateEncryptionKeyResult
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> ClusterNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> InvalidClusterStateFault </td><td>  -  </td></tr>
        <tr><td> 482 </td><td> DependentServiceRequestThrottlingFault </td><td>  -  </td></tr>
     </table>
     */
    public RotateEncryptionKeyResult pOSTRotateEncryptionKey(String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, RotateEncryptionKeyMessage rotateEncryptionKeyMessage) throws ApiException {
        ApiResponse<RotateEncryptionKeyResult> localVarResp = pOSTRotateEncryptionKeyWithHttpInfo(action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, rotateEncryptionKeyMessage);
        return localVarResp.getData();
    }

    /**
     * 
     * Rotates the encryption keys for a cluster.
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param rotateEncryptionKeyMessage  (optional)
     * @return ApiResponse&lt;RotateEncryptionKeyResult&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> ClusterNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> InvalidClusterStateFault </td><td>  -  </td></tr>
        <tr><td> 482 </td><td> DependentServiceRequestThrottlingFault </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<RotateEncryptionKeyResult> pOSTRotateEncryptionKeyWithHttpInfo(String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, RotateEncryptionKeyMessage rotateEncryptionKeyMessage) throws ApiException {
        okhttp3.Call localVarCall = pOSTRotateEncryptionKeyValidateBeforeCall(action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, rotateEncryptionKeyMessage, null);
        Type localVarReturnType = new TypeToken<RotateEncryptionKeyResult>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     *  (asynchronously)
     * Rotates the encryption keys for a cluster.
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param rotateEncryptionKeyMessage  (optional)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> ClusterNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> InvalidClusterStateFault </td><td>  -  </td></tr>
        <tr><td> 482 </td><td> DependentServiceRequestThrottlingFault </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call pOSTRotateEncryptionKeyAsync(String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, RotateEncryptionKeyMessage rotateEncryptionKeyMessage, final ApiCallback<RotateEncryptionKeyResult> _callback) throws ApiException {

        okhttp3.Call localVarCall = pOSTRotateEncryptionKeyValidateBeforeCall(action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, rotateEncryptionKeyMessage, _callback);
        Type localVarReturnType = new TypeToken<RotateEncryptionKeyResult>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for pOSTUpdatePartnerStatus
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param updatePartnerStatusInputMessage  (optional)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> PartnerNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> ClusterNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 482 </td><td> UnauthorizedPartnerIntegrationFault </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call pOSTUpdatePartnerStatusCall(String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, UpdatePartnerStatusInputMessage updatePartnerStatusInputMessage, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = updatePartnerStatusInputMessage;

        // create path and map variables
        String localVarPath = "/#Action=UpdatePartnerStatus";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (action != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("Action", action));
        }

        if (version != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("Version", version));
        }

        if (xAmzContentSha256 != null) {
            localVarHeaderParams.put("X-Amz-Content-Sha256", localVarApiClient.parameterToString(xAmzContentSha256));
        }

        if (xAmzDate != null) {
            localVarHeaderParams.put("X-Amz-Date", localVarApiClient.parameterToString(xAmzDate));
        }

        if (xAmzAlgorithm != null) {
            localVarHeaderParams.put("X-Amz-Algorithm", localVarApiClient.parameterToString(xAmzAlgorithm));
        }

        if (xAmzCredential != null) {
            localVarHeaderParams.put("X-Amz-Credential", localVarApiClient.parameterToString(xAmzCredential));
        }

        if (xAmzSecurityToken != null) {
            localVarHeaderParams.put("X-Amz-Security-Token", localVarApiClient.parameterToString(xAmzSecurityToken));
        }

        if (xAmzSignature != null) {
            localVarHeaderParams.put("X-Amz-Signature", localVarApiClient.parameterToString(xAmzSignature));
        }

        if (xAmzSignedHeaders != null) {
            localVarHeaderParams.put("X-Amz-SignedHeaders", localVarApiClient.parameterToString(xAmzSignedHeaders));
        }

        final String[] localVarAccepts = {
            "text/xml"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            "text/xml"
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "hmac" };
        return localVarApiClient.buildCall(basePath, localVarPath, "POST", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call pOSTUpdatePartnerStatusValidateBeforeCall(String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, UpdatePartnerStatusInputMessage updatePartnerStatusInputMessage, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'action' is set
        if (action == null) {
            throw new ApiException("Missing the required parameter 'action' when calling pOSTUpdatePartnerStatus(Async)");
        }

        // verify the required parameter 'version' is set
        if (version == null) {
            throw new ApiException("Missing the required parameter 'version' when calling pOSTUpdatePartnerStatus(Async)");
        }

        return pOSTUpdatePartnerStatusCall(action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, updatePartnerStatusInputMessage, _callback);

    }

    /**
     * 
     * Updates the status of a partner integration.
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param updatePartnerStatusInputMessage  (optional)
     * @return PartnerIntegrationOutputMessage
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> PartnerNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> ClusterNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 482 </td><td> UnauthorizedPartnerIntegrationFault </td><td>  -  </td></tr>
     </table>
     */
    public PartnerIntegrationOutputMessage pOSTUpdatePartnerStatus(String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, UpdatePartnerStatusInputMessage updatePartnerStatusInputMessage) throws ApiException {
        ApiResponse<PartnerIntegrationOutputMessage> localVarResp = pOSTUpdatePartnerStatusWithHttpInfo(action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, updatePartnerStatusInputMessage);
        return localVarResp.getData();
    }

    /**
     * 
     * Updates the status of a partner integration.
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param updatePartnerStatusInputMessage  (optional)
     * @return ApiResponse&lt;PartnerIntegrationOutputMessage&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> PartnerNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> ClusterNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 482 </td><td> UnauthorizedPartnerIntegrationFault </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<PartnerIntegrationOutputMessage> pOSTUpdatePartnerStatusWithHttpInfo(String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, UpdatePartnerStatusInputMessage updatePartnerStatusInputMessage) throws ApiException {
        okhttp3.Call localVarCall = pOSTUpdatePartnerStatusValidateBeforeCall(action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, updatePartnerStatusInputMessage, null);
        Type localVarReturnType = new TypeToken<PartnerIntegrationOutputMessage>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     *  (asynchronously)
     * Updates the status of a partner integration.
     * @param action  (required)
     * @param version  (required)
     * @param xAmzContentSha256  (optional)
     * @param xAmzDate  (optional)
     * @param xAmzAlgorithm  (optional)
     * @param xAmzCredential  (optional)
     * @param xAmzSecurityToken  (optional)
     * @param xAmzSignature  (optional)
     * @param xAmzSignedHeaders  (optional)
     * @param updatePartnerStatusInputMessage  (optional)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 480 </td><td> PartnerNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 481 </td><td> ClusterNotFoundFault </td><td>  -  </td></tr>
        <tr><td> 482 </td><td> UnauthorizedPartnerIntegrationFault </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call pOSTUpdatePartnerStatusAsync(String action, String version, String xAmzContentSha256, String xAmzDate, String xAmzAlgorithm, String xAmzCredential, String xAmzSecurityToken, String xAmzSignature, String xAmzSignedHeaders, UpdatePartnerStatusInputMessage updatePartnerStatusInputMessage, final ApiCallback<PartnerIntegrationOutputMessage> _callback) throws ApiException {

        okhttp3.Call localVarCall = pOSTUpdatePartnerStatusValidateBeforeCall(action, version, xAmzContentSha256, xAmzDate, xAmzAlgorithm, xAmzCredential, xAmzSecurityToken, xAmzSignature, xAmzSignedHeaders, updatePartnerStatusInputMessage, _callback);
        Type localVarReturnType = new TypeToken<PartnerIntegrationOutputMessage>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
}
