/*
 * Amazon Glacier
 * <p> Amazon S3 Glacier (Glacier) is a storage solution for \"cold data.\"</p> <p>Glacier is an extremely low-cost storage service that provides secure, durable, and easy-to-use storage for data backup and archival. With Glacier, customers can store their data cost effectively for months, years, or decades. Glacier also enables customers to offload the administrative burdens of operating and scaling storage to AWS, so they don't have to worry about capacity planning, hardware provisioning, data replication, hardware failure and recovery, or time-consuming hardware migrations.</p> <p>Glacier is a great storage choice when low storage cost is paramount and your data is rarely retrieved. If your application requires fast or frequent access to your data, consider using Amazon S3. For more information, see <a href=\"http://aws.amazon.com/s3/\">Amazon Simple Storage Service (Amazon S3)</a>.</p> <p>You can store any kind of data in any format. There is no maximum limit on the total amount of data you can store in Glacier.</p> <p>If you are a first-time user of Glacier, we recommend that you begin by reading the following sections in the <i>Amazon S3 Glacier Developer Guide</i>:</p> <ul> <li> <p> <a href=\"https://docs.aws.amazon.com/amazonglacier/latest/dev/introduction.html\">What is Amazon S3 Glacier</a> - This section of the Developer Guide describes the underlying data model, the operations it supports, and the AWS SDKs that you can use to interact with the service.</p> </li> <li> <p> <a href=\"https://docs.aws.amazon.com/amazonglacier/latest/dev/amazon-glacier-getting-started.html\">Getting Started with Amazon S3 Glacier</a> - The Getting Started section walks you through the process of creating a vault, uploading archives, creating jobs to download archives, retrieving the job output, and deleting archives.</p> </li> </ul>
 *
 * The version of the OpenAPI document: 2012-06-01
 * Contact: mike.ralphson@gmail.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package org.openapitools.client.model;

import java.util.Objects;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;
import java.util.Arrays;
import java.util.List;
import java.util.Map;
import org.openapitools.client.model.CannedACL;
import org.openapitools.client.model.S3LocationEncryption;
import org.openapitools.client.model.StorageClass;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonArray;
import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;
import com.google.gson.TypeAdapterFactory;
import com.google.gson.reflect.TypeToken;
import com.google.gson.TypeAdapter;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;

import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import org.openapitools.client.JSON;

/**
 * Contains information about the location in Amazon S3 where the select job results are stored.
 */
@javax.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen", date = "2024-10-12T12:12:14.721106-04:00[America/New_York]", comments = "Generator version: 7.9.0")
public class S3Location {
  public static final String SERIALIZED_NAME_BUCKET_NAME = "BucketName";
  @SerializedName(SERIALIZED_NAME_BUCKET_NAME)
  private String bucketName;

  public static final String SERIALIZED_NAME_PREFIX = "Prefix";
  @SerializedName(SERIALIZED_NAME_PREFIX)
  private String prefix;

  public static final String SERIALIZED_NAME_ENCRYPTION = "Encryption";
  @SerializedName(SERIALIZED_NAME_ENCRYPTION)
  private S3LocationEncryption encryption;

  public static final String SERIALIZED_NAME_CANNED_A_C_L = "CannedACL";
  @SerializedName(SERIALIZED_NAME_CANNED_A_C_L)
  private CannedACL cannedACL;

  public static final String SERIALIZED_NAME_ACCESS_CONTROL_LIST = "AccessControlList";
  @SerializedName(SERIALIZED_NAME_ACCESS_CONTROL_LIST)
  private List accessControlList;

  public static final String SERIALIZED_NAME_TAGGING = "Tagging";
  @SerializedName(SERIALIZED_NAME_TAGGING)
  private Map tagging;

  public static final String SERIALIZED_NAME_USER_METADATA = "UserMetadata";
  @SerializedName(SERIALIZED_NAME_USER_METADATA)
  private Map userMetadata;

  public static final String SERIALIZED_NAME_STORAGE_CLASS = "StorageClass";
  @SerializedName(SERIALIZED_NAME_STORAGE_CLASS)
  private StorageClass storageClass;

  public S3Location() {
  }

  public S3Location bucketName(String bucketName) {
    this.bucketName = bucketName;
    return this;
  }

  /**
   * Get bucketName
   * @return bucketName
   */
  @javax.annotation.Nullable
  public String getBucketName() {
    return bucketName;
  }

  public void setBucketName(String bucketName) {
    this.bucketName = bucketName;
  }


  public S3Location prefix(String prefix) {
    this.prefix = prefix;
    return this;
  }

  /**
   * Get prefix
   * @return prefix
   */
  @javax.annotation.Nullable
  public String getPrefix() {
    return prefix;
  }

  public void setPrefix(String prefix) {
    this.prefix = prefix;
  }


  public S3Location encryption(S3LocationEncryption encryption) {
    this.encryption = encryption;
    return this;
  }

  /**
   * Get encryption
   * @return encryption
   */
  @javax.annotation.Nullable
  public S3LocationEncryption getEncryption() {
    return encryption;
  }

  public void setEncryption(S3LocationEncryption encryption) {
    this.encryption = encryption;
  }


  public S3Location cannedACL(CannedACL cannedACL) {
    this.cannedACL = cannedACL;
    return this;
  }

  /**
   * Get cannedACL
   * @return cannedACL
   */
  @javax.annotation.Nullable
  public CannedACL getCannedACL() {
    return cannedACL;
  }

  public void setCannedACL(CannedACL cannedACL) {
    this.cannedACL = cannedACL;
  }


  public S3Location accessControlList(List accessControlList) {
    this.accessControlList = accessControlList;
    return this;
  }

  /**
   * Get accessControlList
   * @return accessControlList
   */
  @javax.annotation.Nullable
  public List getAccessControlList() {
    return accessControlList;
  }

  public void setAccessControlList(List accessControlList) {
    this.accessControlList = accessControlList;
  }


  public S3Location tagging(Map tagging) {
    this.tagging = tagging;
    return this;
  }

  /**
   * Get tagging
   * @return tagging
   */
  @javax.annotation.Nullable
  public Map getTagging() {
    return tagging;
  }

  public void setTagging(Map tagging) {
    this.tagging = tagging;
  }


  public S3Location userMetadata(Map userMetadata) {
    this.userMetadata = userMetadata;
    return this;
  }

  /**
   * Get userMetadata
   * @return userMetadata
   */
  @javax.annotation.Nullable
  public Map getUserMetadata() {
    return userMetadata;
  }

  public void setUserMetadata(Map userMetadata) {
    this.userMetadata = userMetadata;
  }


  public S3Location storageClass(StorageClass storageClass) {
    this.storageClass = storageClass;
    return this;
  }

  /**
   * Get storageClass
   * @return storageClass
   */
  @javax.annotation.Nullable
  public StorageClass getStorageClass() {
    return storageClass;
  }

  public void setStorageClass(StorageClass storageClass) {
    this.storageClass = storageClass;
  }



  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    S3Location s3Location = (S3Location) o;
    return Objects.equals(this.bucketName, s3Location.bucketName) &&
        Objects.equals(this.prefix, s3Location.prefix) &&
        Objects.equals(this.encryption, s3Location.encryption) &&
        Objects.equals(this.cannedACL, s3Location.cannedACL) &&
        Objects.equals(this.accessControlList, s3Location.accessControlList) &&
        Objects.equals(this.tagging, s3Location.tagging) &&
        Objects.equals(this.userMetadata, s3Location.userMetadata) &&
        Objects.equals(this.storageClass, s3Location.storageClass);
  }

  @Override
  public int hashCode() {
    return Objects.hash(bucketName, prefix, encryption, cannedACL, accessControlList, tagging, userMetadata, storageClass);
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class S3Location {\n");
    sb.append("    bucketName: ").append(toIndentedString(bucketName)).append("\n");
    sb.append("    prefix: ").append(toIndentedString(prefix)).append("\n");
    sb.append("    encryption: ").append(toIndentedString(encryption)).append("\n");
    sb.append("    cannedACL: ").append(toIndentedString(cannedACL)).append("\n");
    sb.append("    accessControlList: ").append(toIndentedString(accessControlList)).append("\n");
    sb.append("    tagging: ").append(toIndentedString(tagging)).append("\n");
    sb.append("    userMetadata: ").append(toIndentedString(userMetadata)).append("\n");
    sb.append("    storageClass: ").append(toIndentedString(storageClass)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }


  public static HashSet<String> openapiFields;
  public static HashSet<String> openapiRequiredFields;

  static {
    // a set of all properties/fields (JSON key names)
    openapiFields = new HashSet<String>();
    openapiFields.add("BucketName");
    openapiFields.add("Prefix");
    openapiFields.add("Encryption");
    openapiFields.add("CannedACL");
    openapiFields.add("AccessControlList");
    openapiFields.add("Tagging");
    openapiFields.add("UserMetadata");
    openapiFields.add("StorageClass");

    // a set of required properties/fields (JSON key names)
    openapiRequiredFields = new HashSet<String>();
  }

  /**
   * Validates the JSON Element and throws an exception if issues found
   *
   * @param jsonElement JSON Element
   * @throws IOException if the JSON Element is invalid with respect to S3Location
   */
  public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      if (jsonElement == null) {
        if (!S3Location.openapiRequiredFields.isEmpty()) { // has required fields but JSON element is null
          throw new IllegalArgumentException(String.format("The required field(s) %s in S3Location is not found in the empty JSON string", S3Location.openapiRequiredFields.toString()));
        }
      }

      Set<Map.Entry<String, JsonElement>> entries = jsonElement.getAsJsonObject().entrySet();
      // check to see if the JSON string contains additional fields
      for (Map.Entry<String, JsonElement> entry : entries) {
        if (!S3Location.openapiFields.contains(entry.getKey())) {
          throw new IllegalArgumentException(String.format("The field `%s` in the JSON string is not defined in the `S3Location` properties. JSON: %s", entry.getKey(), jsonElement.toString()));
        }
      }
        JsonObject jsonObj = jsonElement.getAsJsonObject();
      // validate the optional field `BucketName`
      if (jsonObj.get("BucketName") != null && !jsonObj.get("BucketName").isJsonNull()) {
        String.validateJsonElement(jsonObj.get("BucketName"));
      }
      // validate the optional field `Prefix`
      if (jsonObj.get("Prefix") != null && !jsonObj.get("Prefix").isJsonNull()) {
        String.validateJsonElement(jsonObj.get("Prefix"));
      }
      // validate the optional field `Encryption`
      if (jsonObj.get("Encryption") != null && !jsonObj.get("Encryption").isJsonNull()) {
        S3LocationEncryption.validateJsonElement(jsonObj.get("Encryption"));
      }
      // validate the optional field `CannedACL`
      if (jsonObj.get("CannedACL") != null && !jsonObj.get("CannedACL").isJsonNull()) {
        CannedACL.validateJsonElement(jsonObj.get("CannedACL"));
      }
      // validate the optional field `AccessControlList`
      if (jsonObj.get("AccessControlList") != null && !jsonObj.get("AccessControlList").isJsonNull()) {
        List.validateJsonElement(jsonObj.get("AccessControlList"));
      }
      // validate the optional field `Tagging`
      if (jsonObj.get("Tagging") != null && !jsonObj.get("Tagging").isJsonNull()) {
        Map.validateJsonElement(jsonObj.get("Tagging"));
      }
      // validate the optional field `UserMetadata`
      if (jsonObj.get("UserMetadata") != null && !jsonObj.get("UserMetadata").isJsonNull()) {
        Map.validateJsonElement(jsonObj.get("UserMetadata"));
      }
      // validate the optional field `StorageClass`
      if (jsonObj.get("StorageClass") != null && !jsonObj.get("StorageClass").isJsonNull()) {
        StorageClass.validateJsonElement(jsonObj.get("StorageClass"));
      }
  }

  public static class CustomTypeAdapterFactory implements TypeAdapterFactory {
    @SuppressWarnings("unchecked")
    @Override
    public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
       if (!S3Location.class.isAssignableFrom(type.getRawType())) {
         return null; // this class only serializes 'S3Location' and its subtypes
       }
       final TypeAdapter<JsonElement> elementAdapter = gson.getAdapter(JsonElement.class);
       final TypeAdapter<S3Location> thisAdapter
                        = gson.getDelegateAdapter(this, TypeToken.get(S3Location.class));

       return (TypeAdapter<T>) new TypeAdapter<S3Location>() {
           @Override
           public void write(JsonWriter out, S3Location value) throws IOException {
             JsonObject obj = thisAdapter.toJsonTree(value).getAsJsonObject();
             elementAdapter.write(out, obj);
           }

           @Override
           public S3Location read(JsonReader in) throws IOException {
             JsonElement jsonElement = elementAdapter.read(in);
             validateJsonElement(jsonElement);
             return thisAdapter.fromJsonTree(jsonElement);
           }

       }.nullSafe();
    }
  }

  /**
   * Create an instance of S3Location given an JSON string
   *
   * @param jsonString JSON string
   * @return An instance of S3Location
   * @throws IOException if the JSON string is invalid with respect to S3Location
   */
  public static S3Location fromJson(String jsonString) throws IOException {
    return JSON.getGson().fromJson(jsonString, S3Location.class);
  }

  /**
   * Convert an instance of S3Location to an JSON string
   *
   * @return JSON string
   */
  public String toJson() {
    return JSON.getGson().toJson(this);
  }
}

