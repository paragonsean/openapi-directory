/*
 * Amazon Macie 2
 * Amazon Macie
 *
 * The version of the OpenAPI document: 2020-01-01
 * Contact: mike.ralphson@gmail.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package org.openapitools.client.model;

import java.util.Objects;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import org.openapitools.client.model.SeverityLevel;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonArray;
import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;
import com.google.gson.TypeAdapterFactory;
import com.google.gson.reflect.TypeToken;
import com.google.gson.TypeAdapter;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;

import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import org.openapitools.client.JSON;

/**
 * CreateCustomDataIdentifierRequest
 */
@javax.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen", date = "2024-10-12T12:11:49.935146-04:00[America/New_York]", comments = "Generator version: 7.9.0")
public class CreateCustomDataIdentifierRequest {
  public static final String SERIALIZED_NAME_CLIENT_TOKEN = "clientToken";
  @SerializedName(SERIALIZED_NAME_CLIENT_TOKEN)
  private String clientToken;

  public static final String SERIALIZED_NAME_DESCRIPTION = "description";
  @SerializedName(SERIALIZED_NAME_DESCRIPTION)
  private String description;

  public static final String SERIALIZED_NAME_IGNORE_WORDS = "ignoreWords";
  @SerializedName(SERIALIZED_NAME_IGNORE_WORDS)
  private List<String> ignoreWords = new ArrayList<>();

  public static final String SERIALIZED_NAME_KEYWORDS = "keywords";
  @SerializedName(SERIALIZED_NAME_KEYWORDS)
  private List<String> keywords = new ArrayList<>();

  public static final String SERIALIZED_NAME_MAXIMUM_MATCH_DISTANCE = "maximumMatchDistance";
  @SerializedName(SERIALIZED_NAME_MAXIMUM_MATCH_DISTANCE)
  private Integer maximumMatchDistance;

  public static final String SERIALIZED_NAME_NAME = "name";
  @SerializedName(SERIALIZED_NAME_NAME)
  private String name;

  public static final String SERIALIZED_NAME_REGEX = "regex";
  @SerializedName(SERIALIZED_NAME_REGEX)
  private String regex;

  public static final String SERIALIZED_NAME_SEVERITY_LEVELS = "severityLevels";
  @SerializedName(SERIALIZED_NAME_SEVERITY_LEVELS)
  private List<SeverityLevel> severityLevels = new ArrayList<>();

  public static final String SERIALIZED_NAME_TAGS = "tags";
  @SerializedName(SERIALIZED_NAME_TAGS)
  private Map<String, String> tags = new HashMap<>();

  public CreateCustomDataIdentifierRequest() {
  }

  public CreateCustomDataIdentifierRequest clientToken(String clientToken) {
    this.clientToken = clientToken;
    return this;
  }

  /**
   * A unique, case-sensitive token that you provide to ensure the idempotency of the request.
   * @return clientToken
   */
  @javax.annotation.Nullable
  public String getClientToken() {
    return clientToken;
  }

  public void setClientToken(String clientToken) {
    this.clientToken = clientToken;
  }


  public CreateCustomDataIdentifierRequest description(String description) {
    this.description = description;
    return this;
  }

  /**
   * &lt;p&gt;A custom description of the custom data identifier. The description can contain as many as 512 characters.&lt;/p&gt; &lt;p&gt;We strongly recommend that you avoid including any sensitive data in the description of a custom data identifier. Other users of your account might be able to see this description, depending on the actions that they&#39;re allowed to perform in Amazon Macie.&lt;/p&gt;
   * @return description
   */
  @javax.annotation.Nullable
  public String getDescription() {
    return description;
  }

  public void setDescription(String description) {
    this.description = description;
  }


  public CreateCustomDataIdentifierRequest ignoreWords(List<String> ignoreWords) {
    this.ignoreWords = ignoreWords;
    return this;
  }

  public CreateCustomDataIdentifierRequest addIgnoreWordsItem(String ignoreWordsItem) {
    if (this.ignoreWords == null) {
      this.ignoreWords = new ArrayList<>();
    }
    this.ignoreWords.add(ignoreWordsItem);
    return this;
  }

  /**
   * An array that lists specific character sequences (&lt;i&gt;ignore words&lt;/i&gt;) to exclude from the results. If the text matched by the regular expression contains any string in this array, Amazon Macie ignores it. The array can contain as many as 10 ignore words. Each ignore word can contain 4-90 UTF-8 characters. Ignore words are case sensitive.
   * @return ignoreWords
   */
  @javax.annotation.Nullable
  public List<String> getIgnoreWords() {
    return ignoreWords;
  }

  public void setIgnoreWords(List<String> ignoreWords) {
    this.ignoreWords = ignoreWords;
  }


  public CreateCustomDataIdentifierRequest keywords(List<String> keywords) {
    this.keywords = keywords;
    return this;
  }

  public CreateCustomDataIdentifierRequest addKeywordsItem(String keywordsItem) {
    if (this.keywords == null) {
      this.keywords = new ArrayList<>();
    }
    this.keywords.add(keywordsItem);
    return this;
  }

  /**
   * An array that lists specific character sequences (&lt;i&gt;keywords&lt;/i&gt;), one of which must precede and be within proximity (maximumMatchDistance) of the regular expression to match. The array can contain as many as 50 keywords. Each keyword can contain 3-90 UTF-8 characters. Keywords aren&#39;t case sensitive.
   * @return keywords
   */
  @javax.annotation.Nullable
  public List<String> getKeywords() {
    return keywords;
  }

  public void setKeywords(List<String> keywords) {
    this.keywords = keywords;
  }


  public CreateCustomDataIdentifierRequest maximumMatchDistance(Integer maximumMatchDistance) {
    this.maximumMatchDistance = maximumMatchDistance;
    return this;
  }

  /**
   * The maximum number of characters that can exist between the end of at least one complete character sequence specified by the keywords array and the end of the text that matches the regex pattern. If a complete keyword precedes all the text that matches the pattern and the keyword is within the specified distance, Amazon Macie includes the result. The distance can be 1-300 characters. The default value is 50.
   * @return maximumMatchDistance
   */
  @javax.annotation.Nullable
  public Integer getMaximumMatchDistance() {
    return maximumMatchDistance;
  }

  public void setMaximumMatchDistance(Integer maximumMatchDistance) {
    this.maximumMatchDistance = maximumMatchDistance;
  }


  public CreateCustomDataIdentifierRequest name(String name) {
    this.name = name;
    return this;
  }

  /**
   * &lt;p&gt;A custom name for the custom data identifier. The name can contain as many as 128 characters.&lt;/p&gt; &lt;p&gt;We strongly recommend that you avoid including any sensitive data in the name of a custom data identifier. Other users of your account might be able to see this name, depending on the actions that they&#39;re allowed to perform in Amazon Macie.&lt;/p&gt;
   * @return name
   */
  @javax.annotation.Nonnull
  public String getName() {
    return name;
  }

  public void setName(String name) {
    this.name = name;
  }


  public CreateCustomDataIdentifierRequest regex(String regex) {
    this.regex = regex;
    return this;
  }

  /**
   * The regular expression (&lt;i&gt;regex&lt;/i&gt;) that defines the pattern to match. The expression can contain as many as 512 characters.
   * @return regex
   */
  @javax.annotation.Nonnull
  public String getRegex() {
    return regex;
  }

  public void setRegex(String regex) {
    this.regex = regex;
  }


  public CreateCustomDataIdentifierRequest severityLevels(List<SeverityLevel> severityLevels) {
    this.severityLevels = severityLevels;
    return this;
  }

  public CreateCustomDataIdentifierRequest addSeverityLevelsItem(SeverityLevel severityLevelsItem) {
    if (this.severityLevels == null) {
      this.severityLevels = new ArrayList<>();
    }
    this.severityLevels.add(severityLevelsItem);
    return this;
  }

  /**
   * &lt;p&gt;The severity to assign to findings that the custom data identifier produces, based on the number of occurrences of text that matches the custom data identifier&#39;s detection criteria. You can specify as many as three SeverityLevel objects in this array, one for each severity: LOW, MEDIUM, or HIGH. If you specify more than one, the occurrences thresholds must be in ascending order by severity, moving from LOW to HIGH. For example, 1 for LOW, 50 for MEDIUM, and 100 for HIGH. If an S3 object contains fewer occurrences than the lowest specified threshold, Amazon Macie doesn&#39;t create a finding.&lt;/p&gt; &lt;p&gt;If you don&#39;t specify any values for this array, Macie creates findings for S3 objects that contain at least one occurrence of text that matches the detection criteria, and Macie automatically assigns the MEDIUM severity to those findings.&lt;/p&gt;
   * @return severityLevels
   */
  @javax.annotation.Nullable
  public List<SeverityLevel> getSeverityLevels() {
    return severityLevels;
  }

  public void setSeverityLevels(List<SeverityLevel> severityLevels) {
    this.severityLevels = severityLevels;
  }


  public CreateCustomDataIdentifierRequest tags(Map<String, String> tags) {
    this.tags = tags;
    return this;
  }

  public CreateCustomDataIdentifierRequest putTagsItem(String key, String tagsItem) {
    if (this.tags == null) {
      this.tags = new HashMap<>();
    }
    this.tags.put(key, tagsItem);
    return this;
  }

  /**
   * A string-to-string map of key-value pairs that specifies the tags (keys and values) for an Amazon Macie resource.
   * @return tags
   */
  @javax.annotation.Nullable
  public Map<String, String> getTags() {
    return tags;
  }

  public void setTags(Map<String, String> tags) {
    this.tags = tags;
  }



  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    CreateCustomDataIdentifierRequest createCustomDataIdentifierRequest = (CreateCustomDataIdentifierRequest) o;
    return Objects.equals(this.clientToken, createCustomDataIdentifierRequest.clientToken) &&
        Objects.equals(this.description, createCustomDataIdentifierRequest.description) &&
        Objects.equals(this.ignoreWords, createCustomDataIdentifierRequest.ignoreWords) &&
        Objects.equals(this.keywords, createCustomDataIdentifierRequest.keywords) &&
        Objects.equals(this.maximumMatchDistance, createCustomDataIdentifierRequest.maximumMatchDistance) &&
        Objects.equals(this.name, createCustomDataIdentifierRequest.name) &&
        Objects.equals(this.regex, createCustomDataIdentifierRequest.regex) &&
        Objects.equals(this.severityLevels, createCustomDataIdentifierRequest.severityLevels) &&
        Objects.equals(this.tags, createCustomDataIdentifierRequest.tags);
  }

  @Override
  public int hashCode() {
    return Objects.hash(clientToken, description, ignoreWords, keywords, maximumMatchDistance, name, regex, severityLevels, tags);
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class CreateCustomDataIdentifierRequest {\n");
    sb.append("    clientToken: ").append(toIndentedString(clientToken)).append("\n");
    sb.append("    description: ").append(toIndentedString(description)).append("\n");
    sb.append("    ignoreWords: ").append(toIndentedString(ignoreWords)).append("\n");
    sb.append("    keywords: ").append(toIndentedString(keywords)).append("\n");
    sb.append("    maximumMatchDistance: ").append(toIndentedString(maximumMatchDistance)).append("\n");
    sb.append("    name: ").append(toIndentedString(name)).append("\n");
    sb.append("    regex: ").append(toIndentedString(regex)).append("\n");
    sb.append("    severityLevels: ").append(toIndentedString(severityLevels)).append("\n");
    sb.append("    tags: ").append(toIndentedString(tags)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }


  public static HashSet<String> openapiFields;
  public static HashSet<String> openapiRequiredFields;

  static {
    // a set of all properties/fields (JSON key names)
    openapiFields = new HashSet<String>();
    openapiFields.add("clientToken");
    openapiFields.add("description");
    openapiFields.add("ignoreWords");
    openapiFields.add("keywords");
    openapiFields.add("maximumMatchDistance");
    openapiFields.add("name");
    openapiFields.add("regex");
    openapiFields.add("severityLevels");
    openapiFields.add("tags");

    // a set of required properties/fields (JSON key names)
    openapiRequiredFields = new HashSet<String>();
    openapiRequiredFields.add("name");
    openapiRequiredFields.add("regex");
  }

  /**
   * Validates the JSON Element and throws an exception if issues found
   *
   * @param jsonElement JSON Element
   * @throws IOException if the JSON Element is invalid with respect to CreateCustomDataIdentifierRequest
   */
  public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      if (jsonElement == null) {
        if (!CreateCustomDataIdentifierRequest.openapiRequiredFields.isEmpty()) { // has required fields but JSON element is null
          throw new IllegalArgumentException(String.format("The required field(s) %s in CreateCustomDataIdentifierRequest is not found in the empty JSON string", CreateCustomDataIdentifierRequest.openapiRequiredFields.toString()));
        }
      }

      Set<Map.Entry<String, JsonElement>> entries = jsonElement.getAsJsonObject().entrySet();
      // check to see if the JSON string contains additional fields
      for (Map.Entry<String, JsonElement> entry : entries) {
        if (!CreateCustomDataIdentifierRequest.openapiFields.contains(entry.getKey())) {
          throw new IllegalArgumentException(String.format("The field `%s` in the JSON string is not defined in the `CreateCustomDataIdentifierRequest` properties. JSON: %s", entry.getKey(), jsonElement.toString()));
        }
      }

      // check to make sure all required properties/fields are present in the JSON string
      for (String requiredField : CreateCustomDataIdentifierRequest.openapiRequiredFields) {
        if (jsonElement.getAsJsonObject().get(requiredField) == null) {
          throw new IllegalArgumentException(String.format("The required field `%s` is not found in the JSON string: %s", requiredField, jsonElement.toString()));
        }
      }
        JsonObject jsonObj = jsonElement.getAsJsonObject();
      if ((jsonObj.get("clientToken") != null && !jsonObj.get("clientToken").isJsonNull()) && !jsonObj.get("clientToken").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `clientToken` to be a primitive type in the JSON string but got `%s`", jsonObj.get("clientToken").toString()));
      }
      if ((jsonObj.get("description") != null && !jsonObj.get("description").isJsonNull()) && !jsonObj.get("description").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `description` to be a primitive type in the JSON string but got `%s`", jsonObj.get("description").toString()));
      }
      // ensure the optional json data is an array if present
      if (jsonObj.get("ignoreWords") != null && !jsonObj.get("ignoreWords").isJsonNull() && !jsonObj.get("ignoreWords").isJsonArray()) {
        throw new IllegalArgumentException(String.format("Expected the field `ignoreWords` to be an array in the JSON string but got `%s`", jsonObj.get("ignoreWords").toString()));
      }
      // ensure the optional json data is an array if present
      if (jsonObj.get("keywords") != null && !jsonObj.get("keywords").isJsonNull() && !jsonObj.get("keywords").isJsonArray()) {
        throw new IllegalArgumentException(String.format("Expected the field `keywords` to be an array in the JSON string but got `%s`", jsonObj.get("keywords").toString()));
      }
      if (!jsonObj.get("name").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `name` to be a primitive type in the JSON string but got `%s`", jsonObj.get("name").toString()));
      }
      if (!jsonObj.get("regex").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `regex` to be a primitive type in the JSON string but got `%s`", jsonObj.get("regex").toString()));
      }
      if (jsonObj.get("severityLevels") != null && !jsonObj.get("severityLevels").isJsonNull()) {
        JsonArray jsonArrayseverityLevels = jsonObj.getAsJsonArray("severityLevels");
        if (jsonArrayseverityLevels != null) {
          // ensure the json data is an array
          if (!jsonObj.get("severityLevels").isJsonArray()) {
            throw new IllegalArgumentException(String.format("Expected the field `severityLevels` to be an array in the JSON string but got `%s`", jsonObj.get("severityLevels").toString()));
          }

          // validate the optional field `severityLevels` (array)
          for (int i = 0; i < jsonArrayseverityLevels.size(); i++) {
            SeverityLevel.validateJsonElement(jsonArrayseverityLevels.get(i));
          };
        }
      }
  }

  public static class CustomTypeAdapterFactory implements TypeAdapterFactory {
    @SuppressWarnings("unchecked")
    @Override
    public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
       if (!CreateCustomDataIdentifierRequest.class.isAssignableFrom(type.getRawType())) {
         return null; // this class only serializes 'CreateCustomDataIdentifierRequest' and its subtypes
       }
       final TypeAdapter<JsonElement> elementAdapter = gson.getAdapter(JsonElement.class);
       final TypeAdapter<CreateCustomDataIdentifierRequest> thisAdapter
                        = gson.getDelegateAdapter(this, TypeToken.get(CreateCustomDataIdentifierRequest.class));

       return (TypeAdapter<T>) new TypeAdapter<CreateCustomDataIdentifierRequest>() {
           @Override
           public void write(JsonWriter out, CreateCustomDataIdentifierRequest value) throws IOException {
             JsonObject obj = thisAdapter.toJsonTree(value).getAsJsonObject();
             elementAdapter.write(out, obj);
           }

           @Override
           public CreateCustomDataIdentifierRequest read(JsonReader in) throws IOException {
             JsonElement jsonElement = elementAdapter.read(in);
             validateJsonElement(jsonElement);
             return thisAdapter.fromJsonTree(jsonElement);
           }

       }.nullSafe();
    }
  }

  /**
   * Create an instance of CreateCustomDataIdentifierRequest given an JSON string
   *
   * @param jsonString JSON string
   * @return An instance of CreateCustomDataIdentifierRequest
   * @throws IOException if the JSON string is invalid with respect to CreateCustomDataIdentifierRequest
   */
  public static CreateCustomDataIdentifierRequest fromJson(String jsonString) throws IOException {
    return JSON.getGson().fromJson(jsonString, CreateCustomDataIdentifierRequest.class);
  }

  /**
   * Convert an instance of CreateCustomDataIdentifierRequest to an JSON string
   *
   * @return JSON string
   */
  public String toJson() {
    return JSON.getGson().toJson(this);
  }
}

