/*
 * Amazon Macie 2
 * Amazon Macie
 *
 * The version of the OpenAPI document: 2020-01-01
 * Contact: mike.ralphson@gmail.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package org.openapitools.client.model;

import java.util.Objects;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;
import java.time.OffsetDateTime;
import java.util.Arrays;
import org.openapitools.client.model.BucketMetadataErrorCode;
import org.openapitools.client.model.BucketMetadataObjectCountByEncryptionType;
import org.openapitools.client.model.BucketMetadataUnclassifiableObjectCount;
import org.openapitools.client.model.BucketMetadataUnclassifiableObjectSizeInBytes;
import org.openapitools.client.model.MatchingBucketJobDetails;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonArray;
import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;
import com.google.gson.TypeAdapterFactory;
import com.google.gson.reflect.TypeToken;
import com.google.gson.TypeAdapter;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;

import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import org.openapitools.client.JSON;

/**
 * &lt;p&gt;Provides statistical data and other information about an S3 bucket that Amazon Macie monitors and analyzes for your account. By default, object count and storage size values include data for object parts that are the result of incomplete multipart uploads. For more information, see &lt;a href&#x3D;\&quot;https://docs.aws.amazon.com/macie/latest/user/monitoring-s3-how-it-works.html\&quot;&gt;How Macie monitors Amazon S3 data security&lt;/a&gt; in the &lt;i&gt;Amazon Macie User Guide&lt;/i&gt;.&lt;/p&gt; &lt;p&gt;If an error occurs when Macie attempts to retrieve and process information about the bucket or the bucket&#39;s objects, the value for most of these properties is null. Key exceptions are accountId and bucketName. To identify the cause of the error, refer to the errorCode and errorMessage values.&lt;/p&gt;
 */
@javax.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen", date = "2024-10-12T12:11:49.935146-04:00[America/New_York]", comments = "Generator version: 7.9.0")
public class MatchingBucket {
  public static final String SERIALIZED_NAME_ACCOUNT_ID = "accountId";
  @SerializedName(SERIALIZED_NAME_ACCOUNT_ID)
  private String accountId;

  public static final String SERIALIZED_NAME_BUCKET_NAME = "bucketName";
  @SerializedName(SERIALIZED_NAME_BUCKET_NAME)
  private String bucketName;

  public static final String SERIALIZED_NAME_CLASSIFIABLE_OBJECT_COUNT = "classifiableObjectCount";
  @SerializedName(SERIALIZED_NAME_CLASSIFIABLE_OBJECT_COUNT)
  private Integer classifiableObjectCount;

  public static final String SERIALIZED_NAME_CLASSIFIABLE_SIZE_IN_BYTES = "classifiableSizeInBytes";
  @SerializedName(SERIALIZED_NAME_CLASSIFIABLE_SIZE_IN_BYTES)
  private Integer classifiableSizeInBytes;

  public static final String SERIALIZED_NAME_ERROR_CODE = "errorCode";
  @SerializedName(SERIALIZED_NAME_ERROR_CODE)
  private BucketMetadataErrorCode errorCode;

  public static final String SERIALIZED_NAME_ERROR_MESSAGE = "errorMessage";
  @SerializedName(SERIALIZED_NAME_ERROR_MESSAGE)
  private String errorMessage;

  public static final String SERIALIZED_NAME_JOB_DETAILS = "jobDetails";
  @SerializedName(SERIALIZED_NAME_JOB_DETAILS)
  private MatchingBucketJobDetails jobDetails;

  public static final String SERIALIZED_NAME_LAST_AUTOMATED_DISCOVERY_TIME = "lastAutomatedDiscoveryTime";
  @SerializedName(SERIALIZED_NAME_LAST_AUTOMATED_DISCOVERY_TIME)
  private OffsetDateTime lastAutomatedDiscoveryTime;

  public static final String SERIALIZED_NAME_OBJECT_COUNT = "objectCount";
  @SerializedName(SERIALIZED_NAME_OBJECT_COUNT)
  private Integer objectCount;

  public static final String SERIALIZED_NAME_OBJECT_COUNT_BY_ENCRYPTION_TYPE = "objectCountByEncryptionType";
  @SerializedName(SERIALIZED_NAME_OBJECT_COUNT_BY_ENCRYPTION_TYPE)
  private BucketMetadataObjectCountByEncryptionType objectCountByEncryptionType;

  public static final String SERIALIZED_NAME_SENSITIVITY_SCORE = "sensitivityScore";
  @SerializedName(SERIALIZED_NAME_SENSITIVITY_SCORE)
  private Integer sensitivityScore;

  public static final String SERIALIZED_NAME_SIZE_IN_BYTES = "sizeInBytes";
  @SerializedName(SERIALIZED_NAME_SIZE_IN_BYTES)
  private Integer sizeInBytes;

  public static final String SERIALIZED_NAME_SIZE_IN_BYTES_COMPRESSED = "sizeInBytesCompressed";
  @SerializedName(SERIALIZED_NAME_SIZE_IN_BYTES_COMPRESSED)
  private Integer sizeInBytesCompressed;

  public static final String SERIALIZED_NAME_UNCLASSIFIABLE_OBJECT_COUNT = "unclassifiableObjectCount";
  @SerializedName(SERIALIZED_NAME_UNCLASSIFIABLE_OBJECT_COUNT)
  private BucketMetadataUnclassifiableObjectCount unclassifiableObjectCount;

  public static final String SERIALIZED_NAME_UNCLASSIFIABLE_OBJECT_SIZE_IN_BYTES = "unclassifiableObjectSizeInBytes";
  @SerializedName(SERIALIZED_NAME_UNCLASSIFIABLE_OBJECT_SIZE_IN_BYTES)
  private BucketMetadataUnclassifiableObjectSizeInBytes unclassifiableObjectSizeInBytes;

  public MatchingBucket() {
  }

  public MatchingBucket accountId(String accountId) {
    this.accountId = accountId;
    return this;
  }

  /**
   * Get accountId
   * @return accountId
   */
  @javax.annotation.Nullable
  public String getAccountId() {
    return accountId;
  }

  public void setAccountId(String accountId) {
    this.accountId = accountId;
  }


  public MatchingBucket bucketName(String bucketName) {
    this.bucketName = bucketName;
    return this;
  }

  /**
   * Get bucketName
   * @return bucketName
   */
  @javax.annotation.Nullable
  public String getBucketName() {
    return bucketName;
  }

  public void setBucketName(String bucketName) {
    this.bucketName = bucketName;
  }


  public MatchingBucket classifiableObjectCount(Integer classifiableObjectCount) {
    this.classifiableObjectCount = classifiableObjectCount;
    return this;
  }

  /**
   * Get classifiableObjectCount
   * @return classifiableObjectCount
   */
  @javax.annotation.Nullable
  public Integer getClassifiableObjectCount() {
    return classifiableObjectCount;
  }

  public void setClassifiableObjectCount(Integer classifiableObjectCount) {
    this.classifiableObjectCount = classifiableObjectCount;
  }


  public MatchingBucket classifiableSizeInBytes(Integer classifiableSizeInBytes) {
    this.classifiableSizeInBytes = classifiableSizeInBytes;
    return this;
  }

  /**
   * Get classifiableSizeInBytes
   * @return classifiableSizeInBytes
   */
  @javax.annotation.Nullable
  public Integer getClassifiableSizeInBytes() {
    return classifiableSizeInBytes;
  }

  public void setClassifiableSizeInBytes(Integer classifiableSizeInBytes) {
    this.classifiableSizeInBytes = classifiableSizeInBytes;
  }


  public MatchingBucket errorCode(BucketMetadataErrorCode errorCode) {
    this.errorCode = errorCode;
    return this;
  }

  /**
   * Get errorCode
   * @return errorCode
   */
  @javax.annotation.Nullable
  public BucketMetadataErrorCode getErrorCode() {
    return errorCode;
  }

  public void setErrorCode(BucketMetadataErrorCode errorCode) {
    this.errorCode = errorCode;
  }


  public MatchingBucket errorMessage(String errorMessage) {
    this.errorMessage = errorMessage;
    return this;
  }

  /**
   * Get errorMessage
   * @return errorMessage
   */
  @javax.annotation.Nullable
  public String getErrorMessage() {
    return errorMessage;
  }

  public void setErrorMessage(String errorMessage) {
    this.errorMessage = errorMessage;
  }


  public MatchingBucket jobDetails(MatchingBucketJobDetails jobDetails) {
    this.jobDetails = jobDetails;
    return this;
  }

  /**
   * Get jobDetails
   * @return jobDetails
   */
  @javax.annotation.Nullable
  public MatchingBucketJobDetails getJobDetails() {
    return jobDetails;
  }

  public void setJobDetails(MatchingBucketJobDetails jobDetails) {
    this.jobDetails = jobDetails;
  }


  public MatchingBucket lastAutomatedDiscoveryTime(OffsetDateTime lastAutomatedDiscoveryTime) {
    this.lastAutomatedDiscoveryTime = lastAutomatedDiscoveryTime;
    return this;
  }

  /**
   * Get lastAutomatedDiscoveryTime
   * @return lastAutomatedDiscoveryTime
   */
  @javax.annotation.Nullable
  public OffsetDateTime getLastAutomatedDiscoveryTime() {
    return lastAutomatedDiscoveryTime;
  }

  public void setLastAutomatedDiscoveryTime(OffsetDateTime lastAutomatedDiscoveryTime) {
    this.lastAutomatedDiscoveryTime = lastAutomatedDiscoveryTime;
  }


  public MatchingBucket objectCount(Integer objectCount) {
    this.objectCount = objectCount;
    return this;
  }

  /**
   * Get objectCount
   * @return objectCount
   */
  @javax.annotation.Nullable
  public Integer getObjectCount() {
    return objectCount;
  }

  public void setObjectCount(Integer objectCount) {
    this.objectCount = objectCount;
  }


  public MatchingBucket objectCountByEncryptionType(BucketMetadataObjectCountByEncryptionType objectCountByEncryptionType) {
    this.objectCountByEncryptionType = objectCountByEncryptionType;
    return this;
  }

  /**
   * Get objectCountByEncryptionType
   * @return objectCountByEncryptionType
   */
  @javax.annotation.Nullable
  public BucketMetadataObjectCountByEncryptionType getObjectCountByEncryptionType() {
    return objectCountByEncryptionType;
  }

  public void setObjectCountByEncryptionType(BucketMetadataObjectCountByEncryptionType objectCountByEncryptionType) {
    this.objectCountByEncryptionType = objectCountByEncryptionType;
  }


  public MatchingBucket sensitivityScore(Integer sensitivityScore) {
    this.sensitivityScore = sensitivityScore;
    return this;
  }

  /**
   * Get sensitivityScore
   * @return sensitivityScore
   */
  @javax.annotation.Nullable
  public Integer getSensitivityScore() {
    return sensitivityScore;
  }

  public void setSensitivityScore(Integer sensitivityScore) {
    this.sensitivityScore = sensitivityScore;
  }


  public MatchingBucket sizeInBytes(Integer sizeInBytes) {
    this.sizeInBytes = sizeInBytes;
    return this;
  }

  /**
   * Get sizeInBytes
   * @return sizeInBytes
   */
  @javax.annotation.Nullable
  public Integer getSizeInBytes() {
    return sizeInBytes;
  }

  public void setSizeInBytes(Integer sizeInBytes) {
    this.sizeInBytes = sizeInBytes;
  }


  public MatchingBucket sizeInBytesCompressed(Integer sizeInBytesCompressed) {
    this.sizeInBytesCompressed = sizeInBytesCompressed;
    return this;
  }

  /**
   * Get sizeInBytesCompressed
   * @return sizeInBytesCompressed
   */
  @javax.annotation.Nullable
  public Integer getSizeInBytesCompressed() {
    return sizeInBytesCompressed;
  }

  public void setSizeInBytesCompressed(Integer sizeInBytesCompressed) {
    this.sizeInBytesCompressed = sizeInBytesCompressed;
  }


  public MatchingBucket unclassifiableObjectCount(BucketMetadataUnclassifiableObjectCount unclassifiableObjectCount) {
    this.unclassifiableObjectCount = unclassifiableObjectCount;
    return this;
  }

  /**
   * Get unclassifiableObjectCount
   * @return unclassifiableObjectCount
   */
  @javax.annotation.Nullable
  public BucketMetadataUnclassifiableObjectCount getUnclassifiableObjectCount() {
    return unclassifiableObjectCount;
  }

  public void setUnclassifiableObjectCount(BucketMetadataUnclassifiableObjectCount unclassifiableObjectCount) {
    this.unclassifiableObjectCount = unclassifiableObjectCount;
  }


  public MatchingBucket unclassifiableObjectSizeInBytes(BucketMetadataUnclassifiableObjectSizeInBytes unclassifiableObjectSizeInBytes) {
    this.unclassifiableObjectSizeInBytes = unclassifiableObjectSizeInBytes;
    return this;
  }

  /**
   * Get unclassifiableObjectSizeInBytes
   * @return unclassifiableObjectSizeInBytes
   */
  @javax.annotation.Nullable
  public BucketMetadataUnclassifiableObjectSizeInBytes getUnclassifiableObjectSizeInBytes() {
    return unclassifiableObjectSizeInBytes;
  }

  public void setUnclassifiableObjectSizeInBytes(BucketMetadataUnclassifiableObjectSizeInBytes unclassifiableObjectSizeInBytes) {
    this.unclassifiableObjectSizeInBytes = unclassifiableObjectSizeInBytes;
  }



  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    MatchingBucket matchingBucket = (MatchingBucket) o;
    return Objects.equals(this.accountId, matchingBucket.accountId) &&
        Objects.equals(this.bucketName, matchingBucket.bucketName) &&
        Objects.equals(this.classifiableObjectCount, matchingBucket.classifiableObjectCount) &&
        Objects.equals(this.classifiableSizeInBytes, matchingBucket.classifiableSizeInBytes) &&
        Objects.equals(this.errorCode, matchingBucket.errorCode) &&
        Objects.equals(this.errorMessage, matchingBucket.errorMessage) &&
        Objects.equals(this.jobDetails, matchingBucket.jobDetails) &&
        Objects.equals(this.lastAutomatedDiscoveryTime, matchingBucket.lastAutomatedDiscoveryTime) &&
        Objects.equals(this.objectCount, matchingBucket.objectCount) &&
        Objects.equals(this.objectCountByEncryptionType, matchingBucket.objectCountByEncryptionType) &&
        Objects.equals(this.sensitivityScore, matchingBucket.sensitivityScore) &&
        Objects.equals(this.sizeInBytes, matchingBucket.sizeInBytes) &&
        Objects.equals(this.sizeInBytesCompressed, matchingBucket.sizeInBytesCompressed) &&
        Objects.equals(this.unclassifiableObjectCount, matchingBucket.unclassifiableObjectCount) &&
        Objects.equals(this.unclassifiableObjectSizeInBytes, matchingBucket.unclassifiableObjectSizeInBytes);
  }

  @Override
  public int hashCode() {
    return Objects.hash(accountId, bucketName, classifiableObjectCount, classifiableSizeInBytes, errorCode, errorMessage, jobDetails, lastAutomatedDiscoveryTime, objectCount, objectCountByEncryptionType, sensitivityScore, sizeInBytes, sizeInBytesCompressed, unclassifiableObjectCount, unclassifiableObjectSizeInBytes);
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class MatchingBucket {\n");
    sb.append("    accountId: ").append(toIndentedString(accountId)).append("\n");
    sb.append("    bucketName: ").append(toIndentedString(bucketName)).append("\n");
    sb.append("    classifiableObjectCount: ").append(toIndentedString(classifiableObjectCount)).append("\n");
    sb.append("    classifiableSizeInBytes: ").append(toIndentedString(classifiableSizeInBytes)).append("\n");
    sb.append("    errorCode: ").append(toIndentedString(errorCode)).append("\n");
    sb.append("    errorMessage: ").append(toIndentedString(errorMessage)).append("\n");
    sb.append("    jobDetails: ").append(toIndentedString(jobDetails)).append("\n");
    sb.append("    lastAutomatedDiscoveryTime: ").append(toIndentedString(lastAutomatedDiscoveryTime)).append("\n");
    sb.append("    objectCount: ").append(toIndentedString(objectCount)).append("\n");
    sb.append("    objectCountByEncryptionType: ").append(toIndentedString(objectCountByEncryptionType)).append("\n");
    sb.append("    sensitivityScore: ").append(toIndentedString(sensitivityScore)).append("\n");
    sb.append("    sizeInBytes: ").append(toIndentedString(sizeInBytes)).append("\n");
    sb.append("    sizeInBytesCompressed: ").append(toIndentedString(sizeInBytesCompressed)).append("\n");
    sb.append("    unclassifiableObjectCount: ").append(toIndentedString(unclassifiableObjectCount)).append("\n");
    sb.append("    unclassifiableObjectSizeInBytes: ").append(toIndentedString(unclassifiableObjectSizeInBytes)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }


  public static HashSet<String> openapiFields;
  public static HashSet<String> openapiRequiredFields;

  static {
    // a set of all properties/fields (JSON key names)
    openapiFields = new HashSet<String>();
    openapiFields.add("accountId");
    openapiFields.add("bucketName");
    openapiFields.add("classifiableObjectCount");
    openapiFields.add("classifiableSizeInBytes");
    openapiFields.add("errorCode");
    openapiFields.add("errorMessage");
    openapiFields.add("jobDetails");
    openapiFields.add("lastAutomatedDiscoveryTime");
    openapiFields.add("objectCount");
    openapiFields.add("objectCountByEncryptionType");
    openapiFields.add("sensitivityScore");
    openapiFields.add("sizeInBytes");
    openapiFields.add("sizeInBytesCompressed");
    openapiFields.add("unclassifiableObjectCount");
    openapiFields.add("unclassifiableObjectSizeInBytes");

    // a set of required properties/fields (JSON key names)
    openapiRequiredFields = new HashSet<String>();
  }

  /**
   * Validates the JSON Element and throws an exception if issues found
   *
   * @param jsonElement JSON Element
   * @throws IOException if the JSON Element is invalid with respect to MatchingBucket
   */
  public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      if (jsonElement == null) {
        if (!MatchingBucket.openapiRequiredFields.isEmpty()) { // has required fields but JSON element is null
          throw new IllegalArgumentException(String.format("The required field(s) %s in MatchingBucket is not found in the empty JSON string", MatchingBucket.openapiRequiredFields.toString()));
        }
      }

      Set<Map.Entry<String, JsonElement>> entries = jsonElement.getAsJsonObject().entrySet();
      // check to see if the JSON string contains additional fields
      for (Map.Entry<String, JsonElement> entry : entries) {
        if (!MatchingBucket.openapiFields.contains(entry.getKey())) {
          throw new IllegalArgumentException(String.format("The field `%s` in the JSON string is not defined in the `MatchingBucket` properties. JSON: %s", entry.getKey(), jsonElement.toString()));
        }
      }
        JsonObject jsonObj = jsonElement.getAsJsonObject();
      // validate the optional field `accountId`
      if (jsonObj.get("accountId") != null && !jsonObj.get("accountId").isJsonNull()) {
        String.validateJsonElement(jsonObj.get("accountId"));
      }
      // validate the optional field `bucketName`
      if (jsonObj.get("bucketName") != null && !jsonObj.get("bucketName").isJsonNull()) {
        String.validateJsonElement(jsonObj.get("bucketName"));
      }
      // validate the optional field `classifiableObjectCount`
      if (jsonObj.get("classifiableObjectCount") != null && !jsonObj.get("classifiableObjectCount").isJsonNull()) {
        Integer.validateJsonElement(jsonObj.get("classifiableObjectCount"));
      }
      // validate the optional field `classifiableSizeInBytes`
      if (jsonObj.get("classifiableSizeInBytes") != null && !jsonObj.get("classifiableSizeInBytes").isJsonNull()) {
        Integer.validateJsonElement(jsonObj.get("classifiableSizeInBytes"));
      }
      // validate the optional field `errorCode`
      if (jsonObj.get("errorCode") != null && !jsonObj.get("errorCode").isJsonNull()) {
        BucketMetadataErrorCode.validateJsonElement(jsonObj.get("errorCode"));
      }
      // validate the optional field `errorMessage`
      if (jsonObj.get("errorMessage") != null && !jsonObj.get("errorMessage").isJsonNull()) {
        String.validateJsonElement(jsonObj.get("errorMessage"));
      }
      // validate the optional field `jobDetails`
      if (jsonObj.get("jobDetails") != null && !jsonObj.get("jobDetails").isJsonNull()) {
        MatchingBucketJobDetails.validateJsonElement(jsonObj.get("jobDetails"));
      }
      // validate the optional field `lastAutomatedDiscoveryTime`
      if (jsonObj.get("lastAutomatedDiscoveryTime") != null && !jsonObj.get("lastAutomatedDiscoveryTime").isJsonNull()) {
        OffsetDateTime.validateJsonElement(jsonObj.get("lastAutomatedDiscoveryTime"));
      }
      // validate the optional field `objectCount`
      if (jsonObj.get("objectCount") != null && !jsonObj.get("objectCount").isJsonNull()) {
        Integer.validateJsonElement(jsonObj.get("objectCount"));
      }
      // validate the optional field `objectCountByEncryptionType`
      if (jsonObj.get("objectCountByEncryptionType") != null && !jsonObj.get("objectCountByEncryptionType").isJsonNull()) {
        BucketMetadataObjectCountByEncryptionType.validateJsonElement(jsonObj.get("objectCountByEncryptionType"));
      }
      // validate the optional field `sensitivityScore`
      if (jsonObj.get("sensitivityScore") != null && !jsonObj.get("sensitivityScore").isJsonNull()) {
        Integer.validateJsonElement(jsonObj.get("sensitivityScore"));
      }
      // validate the optional field `sizeInBytes`
      if (jsonObj.get("sizeInBytes") != null && !jsonObj.get("sizeInBytes").isJsonNull()) {
        Integer.validateJsonElement(jsonObj.get("sizeInBytes"));
      }
      // validate the optional field `sizeInBytesCompressed`
      if (jsonObj.get("sizeInBytesCompressed") != null && !jsonObj.get("sizeInBytesCompressed").isJsonNull()) {
        Integer.validateJsonElement(jsonObj.get("sizeInBytesCompressed"));
      }
      // validate the optional field `unclassifiableObjectCount`
      if (jsonObj.get("unclassifiableObjectCount") != null && !jsonObj.get("unclassifiableObjectCount").isJsonNull()) {
        BucketMetadataUnclassifiableObjectCount.validateJsonElement(jsonObj.get("unclassifiableObjectCount"));
      }
      // validate the optional field `unclassifiableObjectSizeInBytes`
      if (jsonObj.get("unclassifiableObjectSizeInBytes") != null && !jsonObj.get("unclassifiableObjectSizeInBytes").isJsonNull()) {
        BucketMetadataUnclassifiableObjectSizeInBytes.validateJsonElement(jsonObj.get("unclassifiableObjectSizeInBytes"));
      }
  }

  public static class CustomTypeAdapterFactory implements TypeAdapterFactory {
    @SuppressWarnings("unchecked")
    @Override
    public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
       if (!MatchingBucket.class.isAssignableFrom(type.getRawType())) {
         return null; // this class only serializes 'MatchingBucket' and its subtypes
       }
       final TypeAdapter<JsonElement> elementAdapter = gson.getAdapter(JsonElement.class);
       final TypeAdapter<MatchingBucket> thisAdapter
                        = gson.getDelegateAdapter(this, TypeToken.get(MatchingBucket.class));

       return (TypeAdapter<T>) new TypeAdapter<MatchingBucket>() {
           @Override
           public void write(JsonWriter out, MatchingBucket value) throws IOException {
             JsonObject obj = thisAdapter.toJsonTree(value).getAsJsonObject();
             elementAdapter.write(out, obj);
           }

           @Override
           public MatchingBucket read(JsonReader in) throws IOException {
             JsonElement jsonElement = elementAdapter.read(in);
             validateJsonElement(jsonElement);
             return thisAdapter.fromJsonTree(jsonElement);
           }

       }.nullSafe();
    }
  }

  /**
   * Create an instance of MatchingBucket given an JSON string
   *
   * @param jsonString JSON string
   * @return An instance of MatchingBucket
   * @throws IOException if the JSON string is invalid with respect to MatchingBucket
   */
  public static MatchingBucket fromJson(String jsonString) throws IOException {
    return JSON.getGson().fromJson(jsonString, MatchingBucket.class);
  }

  /**
   * Convert an instance of MatchingBucket to an JSON string
   *
   * @return JSON string
   */
  public String toJson() {
    return JSON.getGson().toJson(this);
  }
}

