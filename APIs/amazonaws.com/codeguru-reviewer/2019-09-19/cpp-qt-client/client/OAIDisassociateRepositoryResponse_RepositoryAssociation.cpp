/**
 * Amazon CodeGuru Reviewer
 * <p>This section provides documentation for the Amazon CodeGuru Reviewer API operations. CodeGuru Reviewer is a service that uses program analysis and machine learning to detect potential defects that are difficult for developers to find and recommends fixes in your Java and Python code.</p> <p>By proactively detecting and providing recommendations for addressing code defects and implementing best practices, CodeGuru Reviewer improves the overall quality and maintainability of your code base during the code review stage. For more information about CodeGuru Reviewer, see the <i> <a href=\"https://docs.aws.amazon.com/codeguru/latest/reviewer-ug/welcome.html\">Amazon CodeGuru Reviewer User Guide</a>.</i> </p> <p>To improve the security of your CodeGuru Reviewer API calls, you can establish a private connection between your VPC and CodeGuru Reviewer by creating an <i>interface VPC endpoint</i>. For more information, see <a href=\"https://docs.aws.amazon.com/codeguru/latest/reviewer-ug/vpc-interface-endpoints.html\">CodeGuru Reviewer and interface VPC endpoints (Amazon Web Services PrivateLink)</a> in the <i>Amazon CodeGuru Reviewer User Guide</i>.</p>
 *
 * The version of the OpenAPI document: 2019-09-19
 * Contact: mike.ralphson@gmail.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

#include "OAIDisassociateRepositoryResponse_RepositoryAssociation.h"

#include <QDebug>
#include <QJsonArray>
#include <QJsonDocument>
#include <QObject>

#include "OAIHelpers.h"

namespace OpenAPI {

OAIDisassociateRepositoryResponse_RepositoryAssociation::OAIDisassociateRepositoryResponse_RepositoryAssociation(QString json) {
    this->initializeModel();
    this->fromJson(json);
}

OAIDisassociateRepositoryResponse_RepositoryAssociation::OAIDisassociateRepositoryResponse_RepositoryAssociation() {
    this->initializeModel();
}

OAIDisassociateRepositoryResponse_RepositoryAssociation::~OAIDisassociateRepositoryResponse_RepositoryAssociation() {}

void OAIDisassociateRepositoryResponse_RepositoryAssociation::initializeModel() {

    m_association_id_isSet = false;
    m_association_id_isValid = false;

    m_association_arn_isSet = false;
    m_association_arn_isValid = false;

    m_connection_arn_isSet = false;
    m_connection_arn_isValid = false;

    m_name_isSet = false;
    m_name_isValid = false;

    m_owner_isSet = false;
    m_owner_isValid = false;

    m_provider_type_isSet = false;
    m_provider_type_isValid = false;

    m_state_isSet = false;
    m_state_isValid = false;

    m_state_reason_isSet = false;
    m_state_reason_isValid = false;

    m_last_updated_time_stamp_isSet = false;
    m_last_updated_time_stamp_isValid = false;

    m_created_time_stamp_isSet = false;
    m_created_time_stamp_isValid = false;

    m_kms_key_details_isSet = false;
    m_kms_key_details_isValid = false;

    m_s3_repository_details_isSet = false;
    m_s3_repository_details_isValid = false;
}

void OAIDisassociateRepositoryResponse_RepositoryAssociation::fromJson(QString jsonString) {
    QByteArray array(jsonString.toStdString().c_str());
    QJsonDocument doc = QJsonDocument::fromJson(array);
    QJsonObject jsonObject = doc.object();
    this->fromJsonObject(jsonObject);
}

void OAIDisassociateRepositoryResponse_RepositoryAssociation::fromJsonObject(QJsonObject json) {

    m_association_id_isValid = ::OpenAPI::fromJsonValue(m_association_id, json[QString("AssociationId")]);
    m_association_id_isSet = !json[QString("AssociationId")].isNull() && m_association_id_isValid;

    m_association_arn_isValid = ::OpenAPI::fromJsonValue(m_association_arn, json[QString("AssociationArn")]);
    m_association_arn_isSet = !json[QString("AssociationArn")].isNull() && m_association_arn_isValid;

    m_connection_arn_isValid = ::OpenAPI::fromJsonValue(m_connection_arn, json[QString("ConnectionArn")]);
    m_connection_arn_isSet = !json[QString("ConnectionArn")].isNull() && m_connection_arn_isValid;

    m_name_isValid = ::OpenAPI::fromJsonValue(m_name, json[QString("Name")]);
    m_name_isSet = !json[QString("Name")].isNull() && m_name_isValid;

    m_owner_isValid = ::OpenAPI::fromJsonValue(m_owner, json[QString("Owner")]);
    m_owner_isSet = !json[QString("Owner")].isNull() && m_owner_isValid;

    m_provider_type_isValid = ::OpenAPI::fromJsonValue(m_provider_type, json[QString("ProviderType")]);
    m_provider_type_isSet = !json[QString("ProviderType")].isNull() && m_provider_type_isValid;

    m_state_isValid = ::OpenAPI::fromJsonValue(m_state, json[QString("State")]);
    m_state_isSet = !json[QString("State")].isNull() && m_state_isValid;

    m_state_reason_isValid = ::OpenAPI::fromJsonValue(m_state_reason, json[QString("StateReason")]);
    m_state_reason_isSet = !json[QString("StateReason")].isNull() && m_state_reason_isValid;

    m_last_updated_time_stamp_isValid = ::OpenAPI::fromJsonValue(m_last_updated_time_stamp, json[QString("LastUpdatedTimeStamp")]);
    m_last_updated_time_stamp_isSet = !json[QString("LastUpdatedTimeStamp")].isNull() && m_last_updated_time_stamp_isValid;

    m_created_time_stamp_isValid = ::OpenAPI::fromJsonValue(m_created_time_stamp, json[QString("CreatedTimeStamp")]);
    m_created_time_stamp_isSet = !json[QString("CreatedTimeStamp")].isNull() && m_created_time_stamp_isValid;

    m_kms_key_details_isValid = ::OpenAPI::fromJsonValue(m_kms_key_details, json[QString("KMSKeyDetails")]);
    m_kms_key_details_isSet = !json[QString("KMSKeyDetails")].isNull() && m_kms_key_details_isValid;

    m_s3_repository_details_isValid = ::OpenAPI::fromJsonValue(m_s3_repository_details, json[QString("S3RepositoryDetails")]);
    m_s3_repository_details_isSet = !json[QString("S3RepositoryDetails")].isNull() && m_s3_repository_details_isValid;
}

QString OAIDisassociateRepositoryResponse_RepositoryAssociation::asJson() const {
    QJsonObject obj = this->asJsonObject();
    QJsonDocument doc(obj);
    QByteArray bytes = doc.toJson();
    return QString(bytes);
}

QJsonObject OAIDisassociateRepositoryResponse_RepositoryAssociation::asJsonObject() const {
    QJsonObject obj;
    if (m_association_id_isSet) {
        obj.insert(QString("AssociationId"), ::OpenAPI::toJsonValue(m_association_id));
    }
    if (m_association_arn_isSet) {
        obj.insert(QString("AssociationArn"), ::OpenAPI::toJsonValue(m_association_arn));
    }
    if (m_connection_arn_isSet) {
        obj.insert(QString("ConnectionArn"), ::OpenAPI::toJsonValue(m_connection_arn));
    }
    if (m_name_isSet) {
        obj.insert(QString("Name"), ::OpenAPI::toJsonValue(m_name));
    }
    if (m_owner_isSet) {
        obj.insert(QString("Owner"), ::OpenAPI::toJsonValue(m_owner));
    }
    if (m_provider_type.isSet()) {
        obj.insert(QString("ProviderType"), ::OpenAPI::toJsonValue(m_provider_type));
    }
    if (m_state.isSet()) {
        obj.insert(QString("State"), ::OpenAPI::toJsonValue(m_state));
    }
    if (m_state_reason_isSet) {
        obj.insert(QString("StateReason"), ::OpenAPI::toJsonValue(m_state_reason));
    }
    if (m_last_updated_time_stamp_isSet) {
        obj.insert(QString("LastUpdatedTimeStamp"), ::OpenAPI::toJsonValue(m_last_updated_time_stamp));
    }
    if (m_created_time_stamp_isSet) {
        obj.insert(QString("CreatedTimeStamp"), ::OpenAPI::toJsonValue(m_created_time_stamp));
    }
    if (m_kms_key_details.isSet()) {
        obj.insert(QString("KMSKeyDetails"), ::OpenAPI::toJsonValue(m_kms_key_details));
    }
    if (m_s3_repository_details.isSet()) {
        obj.insert(QString("S3RepositoryDetails"), ::OpenAPI::toJsonValue(m_s3_repository_details));
    }
    return obj;
}

QString OAIDisassociateRepositoryResponse_RepositoryAssociation::getAssociationId() const {
    return m_association_id;
}
void OAIDisassociateRepositoryResponse_RepositoryAssociation::setAssociationId(const QString &association_id) {
    m_association_id = association_id;
    m_association_id_isSet = true;
}

bool OAIDisassociateRepositoryResponse_RepositoryAssociation::is_association_id_Set() const{
    return m_association_id_isSet;
}

bool OAIDisassociateRepositoryResponse_RepositoryAssociation::is_association_id_Valid() const{
    return m_association_id_isValid;
}

QString OAIDisassociateRepositoryResponse_RepositoryAssociation::getAssociationArn() const {
    return m_association_arn;
}
void OAIDisassociateRepositoryResponse_RepositoryAssociation::setAssociationArn(const QString &association_arn) {
    m_association_arn = association_arn;
    m_association_arn_isSet = true;
}

bool OAIDisassociateRepositoryResponse_RepositoryAssociation::is_association_arn_Set() const{
    return m_association_arn_isSet;
}

bool OAIDisassociateRepositoryResponse_RepositoryAssociation::is_association_arn_Valid() const{
    return m_association_arn_isValid;
}

QString OAIDisassociateRepositoryResponse_RepositoryAssociation::getConnectionArn() const {
    return m_connection_arn;
}
void OAIDisassociateRepositoryResponse_RepositoryAssociation::setConnectionArn(const QString &connection_arn) {
    m_connection_arn = connection_arn;
    m_connection_arn_isSet = true;
}

bool OAIDisassociateRepositoryResponse_RepositoryAssociation::is_connection_arn_Set() const{
    return m_connection_arn_isSet;
}

bool OAIDisassociateRepositoryResponse_RepositoryAssociation::is_connection_arn_Valid() const{
    return m_connection_arn_isValid;
}

QString OAIDisassociateRepositoryResponse_RepositoryAssociation::getName() const {
    return m_name;
}
void OAIDisassociateRepositoryResponse_RepositoryAssociation::setName(const QString &name) {
    m_name = name;
    m_name_isSet = true;
}

bool OAIDisassociateRepositoryResponse_RepositoryAssociation::is_name_Set() const{
    return m_name_isSet;
}

bool OAIDisassociateRepositoryResponse_RepositoryAssociation::is_name_Valid() const{
    return m_name_isValid;
}

QString OAIDisassociateRepositoryResponse_RepositoryAssociation::getOwner() const {
    return m_owner;
}
void OAIDisassociateRepositoryResponse_RepositoryAssociation::setOwner(const QString &owner) {
    m_owner = owner;
    m_owner_isSet = true;
}

bool OAIDisassociateRepositoryResponse_RepositoryAssociation::is_owner_Set() const{
    return m_owner_isSet;
}

bool OAIDisassociateRepositoryResponse_RepositoryAssociation::is_owner_Valid() const{
    return m_owner_isValid;
}

OAIProviderType OAIDisassociateRepositoryResponse_RepositoryAssociation::getProviderType() const {
    return m_provider_type;
}
void OAIDisassociateRepositoryResponse_RepositoryAssociation::setProviderType(const OAIProviderType &provider_type) {
    m_provider_type = provider_type;
    m_provider_type_isSet = true;
}

bool OAIDisassociateRepositoryResponse_RepositoryAssociation::is_provider_type_Set() const{
    return m_provider_type_isSet;
}

bool OAIDisassociateRepositoryResponse_RepositoryAssociation::is_provider_type_Valid() const{
    return m_provider_type_isValid;
}

OAIRepositoryAssociationState OAIDisassociateRepositoryResponse_RepositoryAssociation::getState() const {
    return m_state;
}
void OAIDisassociateRepositoryResponse_RepositoryAssociation::setState(const OAIRepositoryAssociationState &state) {
    m_state = state;
    m_state_isSet = true;
}

bool OAIDisassociateRepositoryResponse_RepositoryAssociation::is_state_Set() const{
    return m_state_isSet;
}

bool OAIDisassociateRepositoryResponse_RepositoryAssociation::is_state_Valid() const{
    return m_state_isValid;
}

QString OAIDisassociateRepositoryResponse_RepositoryAssociation::getStateReason() const {
    return m_state_reason;
}
void OAIDisassociateRepositoryResponse_RepositoryAssociation::setStateReason(const QString &state_reason) {
    m_state_reason = state_reason;
    m_state_reason_isSet = true;
}

bool OAIDisassociateRepositoryResponse_RepositoryAssociation::is_state_reason_Set() const{
    return m_state_reason_isSet;
}

bool OAIDisassociateRepositoryResponse_RepositoryAssociation::is_state_reason_Valid() const{
    return m_state_reason_isValid;
}

QDateTime OAIDisassociateRepositoryResponse_RepositoryAssociation::getLastUpdatedTimeStamp() const {
    return m_last_updated_time_stamp;
}
void OAIDisassociateRepositoryResponse_RepositoryAssociation::setLastUpdatedTimeStamp(const QDateTime &last_updated_time_stamp) {
    m_last_updated_time_stamp = last_updated_time_stamp;
    m_last_updated_time_stamp_isSet = true;
}

bool OAIDisassociateRepositoryResponse_RepositoryAssociation::is_last_updated_time_stamp_Set() const{
    return m_last_updated_time_stamp_isSet;
}

bool OAIDisassociateRepositoryResponse_RepositoryAssociation::is_last_updated_time_stamp_Valid() const{
    return m_last_updated_time_stamp_isValid;
}

QDateTime OAIDisassociateRepositoryResponse_RepositoryAssociation::getCreatedTimeStamp() const {
    return m_created_time_stamp;
}
void OAIDisassociateRepositoryResponse_RepositoryAssociation::setCreatedTimeStamp(const QDateTime &created_time_stamp) {
    m_created_time_stamp = created_time_stamp;
    m_created_time_stamp_isSet = true;
}

bool OAIDisassociateRepositoryResponse_RepositoryAssociation::is_created_time_stamp_Set() const{
    return m_created_time_stamp_isSet;
}

bool OAIDisassociateRepositoryResponse_RepositoryAssociation::is_created_time_stamp_Valid() const{
    return m_created_time_stamp_isValid;
}

OAIAssociateRepositoryRequest_KMSKeyDetails OAIDisassociateRepositoryResponse_RepositoryAssociation::getKmsKeyDetails() const {
    return m_kms_key_details;
}
void OAIDisassociateRepositoryResponse_RepositoryAssociation::setKmsKeyDetails(const OAIAssociateRepositoryRequest_KMSKeyDetails &kms_key_details) {
    m_kms_key_details = kms_key_details;
    m_kms_key_details_isSet = true;
}

bool OAIDisassociateRepositoryResponse_RepositoryAssociation::is_kms_key_details_Set() const{
    return m_kms_key_details_isSet;
}

bool OAIDisassociateRepositoryResponse_RepositoryAssociation::is_kms_key_details_Valid() const{
    return m_kms_key_details_isValid;
}

OAIS3RepositoryDetails OAIDisassociateRepositoryResponse_RepositoryAssociation::getS3RepositoryDetails() const {
    return m_s3_repository_details;
}
void OAIDisassociateRepositoryResponse_RepositoryAssociation::setS3RepositoryDetails(const OAIS3RepositoryDetails &s3_repository_details) {
    m_s3_repository_details = s3_repository_details;
    m_s3_repository_details_isSet = true;
}

bool OAIDisassociateRepositoryResponse_RepositoryAssociation::is_s3_repository_details_Set() const{
    return m_s3_repository_details_isSet;
}

bool OAIDisassociateRepositoryResponse_RepositoryAssociation::is_s3_repository_details_Valid() const{
    return m_s3_repository_details_isValid;
}

bool OAIDisassociateRepositoryResponse_RepositoryAssociation::isSet() const {
    bool isObjectUpdated = false;
    do {
        if (m_association_id_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_association_arn_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_connection_arn_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_name_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_owner_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_provider_type.isSet()) {
            isObjectUpdated = true;
            break;
        }

        if (m_state.isSet()) {
            isObjectUpdated = true;
            break;
        }

        if (m_state_reason_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_last_updated_time_stamp_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_created_time_stamp_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_kms_key_details.isSet()) {
            isObjectUpdated = true;
            break;
        }

        if (m_s3_repository_details.isSet()) {
            isObjectUpdated = true;
            break;
        }
    } while (false);
    return isObjectUpdated;
}

bool OAIDisassociateRepositoryResponse_RepositoryAssociation::isValid() const {
    // only required properties are required for the object to be considered valid
    return true;
}

} // namespace OpenAPI
