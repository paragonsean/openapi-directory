/*
 * AWS Backup
 * <fullname>Backup</fullname> <p>Backup is a unified backup service designed to protect Amazon Web Services services and their associated data. Backup simplifies the creation, migration, restoration, and deletion of backups, while also providing reporting and auditing.</p>
 *
 * The version of the OpenAPI document: 2018-11-15
 * Contact: mike.ralphson@gmail.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package org.openapitools.client.model;

import java.util.Objects;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;
import java.time.OffsetDateTime;
import java.util.Arrays;
import org.openapitools.client.model.LegalHoldStatus;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonArray;
import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;
import com.google.gson.TypeAdapterFactory;
import com.google.gson.reflect.TypeToken;
import com.google.gson.TypeAdapter;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;

import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import org.openapitools.client.JSON;

/**
 * A legal hold is an administrative tool that helps prevent backups from being deleted while under a hold. While the hold is in place, backups under a hold cannot be deleted and lifecycle policies that would alter the backup status (such as transition to cold storage) are delayed until the legal hold is removed. A backup can have more than one legal hold. Legal holds are applied to one or more backups (also known as recovery points). These backups can be filtered by resource types and by resource IDs.
 */
@javax.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen", date = "2024-10-12T12:06:47.732009-04:00[America/New_York]", comments = "Generator version: 7.9.0")
public class LegalHold {
  public static final String SERIALIZED_NAME_TITLE = "Title";
  @SerializedName(SERIALIZED_NAME_TITLE)
  private String title;

  public static final String SERIALIZED_NAME_STATUS = "Status";
  @SerializedName(SERIALIZED_NAME_STATUS)
  private LegalHoldStatus status;

  public static final String SERIALIZED_NAME_DESCRIPTION = "Description";
  @SerializedName(SERIALIZED_NAME_DESCRIPTION)
  private String description;

  public static final String SERIALIZED_NAME_LEGAL_HOLD_ID = "LegalHoldId";
  @SerializedName(SERIALIZED_NAME_LEGAL_HOLD_ID)
  private String legalHoldId;

  public static final String SERIALIZED_NAME_LEGAL_HOLD_ARN = "LegalHoldArn";
  @SerializedName(SERIALIZED_NAME_LEGAL_HOLD_ARN)
  private String legalHoldArn;

  public static final String SERIALIZED_NAME_CREATION_DATE = "CreationDate";
  @SerializedName(SERIALIZED_NAME_CREATION_DATE)
  private OffsetDateTime creationDate;

  public static final String SERIALIZED_NAME_CANCELLATION_DATE = "CancellationDate";
  @SerializedName(SERIALIZED_NAME_CANCELLATION_DATE)
  private OffsetDateTime cancellationDate;

  public LegalHold() {
  }

  public LegalHold title(String title) {
    this.title = title;
    return this;
  }

  /**
   * Get title
   * @return title
   */
  @javax.annotation.Nullable
  public String getTitle() {
    return title;
  }

  public void setTitle(String title) {
    this.title = title;
  }


  public LegalHold status(LegalHoldStatus status) {
    this.status = status;
    return this;
  }

  /**
   * Get status
   * @return status
   */
  @javax.annotation.Nullable
  public LegalHoldStatus getStatus() {
    return status;
  }

  public void setStatus(LegalHoldStatus status) {
    this.status = status;
  }


  public LegalHold description(String description) {
    this.description = description;
    return this;
  }

  /**
   * Get description
   * @return description
   */
  @javax.annotation.Nullable
  public String getDescription() {
    return description;
  }

  public void setDescription(String description) {
    this.description = description;
  }


  public LegalHold legalHoldId(String legalHoldId) {
    this.legalHoldId = legalHoldId;
    return this;
  }

  /**
   * Get legalHoldId
   * @return legalHoldId
   */
  @javax.annotation.Nullable
  public String getLegalHoldId() {
    return legalHoldId;
  }

  public void setLegalHoldId(String legalHoldId) {
    this.legalHoldId = legalHoldId;
  }


  public LegalHold legalHoldArn(String legalHoldArn) {
    this.legalHoldArn = legalHoldArn;
    return this;
  }

  /**
   * Get legalHoldArn
   * @return legalHoldArn
   */
  @javax.annotation.Nullable
  public String getLegalHoldArn() {
    return legalHoldArn;
  }

  public void setLegalHoldArn(String legalHoldArn) {
    this.legalHoldArn = legalHoldArn;
  }


  public LegalHold creationDate(OffsetDateTime creationDate) {
    this.creationDate = creationDate;
    return this;
  }

  /**
   * Get creationDate
   * @return creationDate
   */
  @javax.annotation.Nullable
  public OffsetDateTime getCreationDate() {
    return creationDate;
  }

  public void setCreationDate(OffsetDateTime creationDate) {
    this.creationDate = creationDate;
  }


  public LegalHold cancellationDate(OffsetDateTime cancellationDate) {
    this.cancellationDate = cancellationDate;
    return this;
  }

  /**
   * Get cancellationDate
   * @return cancellationDate
   */
  @javax.annotation.Nullable
  public OffsetDateTime getCancellationDate() {
    return cancellationDate;
  }

  public void setCancellationDate(OffsetDateTime cancellationDate) {
    this.cancellationDate = cancellationDate;
  }



  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    LegalHold legalHold = (LegalHold) o;
    return Objects.equals(this.title, legalHold.title) &&
        Objects.equals(this.status, legalHold.status) &&
        Objects.equals(this.description, legalHold.description) &&
        Objects.equals(this.legalHoldId, legalHold.legalHoldId) &&
        Objects.equals(this.legalHoldArn, legalHold.legalHoldArn) &&
        Objects.equals(this.creationDate, legalHold.creationDate) &&
        Objects.equals(this.cancellationDate, legalHold.cancellationDate);
  }

  @Override
  public int hashCode() {
    return Objects.hash(title, status, description, legalHoldId, legalHoldArn, creationDate, cancellationDate);
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class LegalHold {\n");
    sb.append("    title: ").append(toIndentedString(title)).append("\n");
    sb.append("    status: ").append(toIndentedString(status)).append("\n");
    sb.append("    description: ").append(toIndentedString(description)).append("\n");
    sb.append("    legalHoldId: ").append(toIndentedString(legalHoldId)).append("\n");
    sb.append("    legalHoldArn: ").append(toIndentedString(legalHoldArn)).append("\n");
    sb.append("    creationDate: ").append(toIndentedString(creationDate)).append("\n");
    sb.append("    cancellationDate: ").append(toIndentedString(cancellationDate)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }


  public static HashSet<String> openapiFields;
  public static HashSet<String> openapiRequiredFields;

  static {
    // a set of all properties/fields (JSON key names)
    openapiFields = new HashSet<String>();
    openapiFields.add("Title");
    openapiFields.add("Status");
    openapiFields.add("Description");
    openapiFields.add("LegalHoldId");
    openapiFields.add("LegalHoldArn");
    openapiFields.add("CreationDate");
    openapiFields.add("CancellationDate");

    // a set of required properties/fields (JSON key names)
    openapiRequiredFields = new HashSet<String>();
  }

  /**
   * Validates the JSON Element and throws an exception if issues found
   *
   * @param jsonElement JSON Element
   * @throws IOException if the JSON Element is invalid with respect to LegalHold
   */
  public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      if (jsonElement == null) {
        if (!LegalHold.openapiRequiredFields.isEmpty()) { // has required fields but JSON element is null
          throw new IllegalArgumentException(String.format("The required field(s) %s in LegalHold is not found in the empty JSON string", LegalHold.openapiRequiredFields.toString()));
        }
      }

      Set<Map.Entry<String, JsonElement>> entries = jsonElement.getAsJsonObject().entrySet();
      // check to see if the JSON string contains additional fields
      for (Map.Entry<String, JsonElement> entry : entries) {
        if (!LegalHold.openapiFields.contains(entry.getKey())) {
          throw new IllegalArgumentException(String.format("The field `%s` in the JSON string is not defined in the `LegalHold` properties. JSON: %s", entry.getKey(), jsonElement.toString()));
        }
      }
        JsonObject jsonObj = jsonElement.getAsJsonObject();
      // validate the optional field `Title`
      if (jsonObj.get("Title") != null && !jsonObj.get("Title").isJsonNull()) {
        String.validateJsonElement(jsonObj.get("Title"));
      }
      // validate the optional field `Status`
      if (jsonObj.get("Status") != null && !jsonObj.get("Status").isJsonNull()) {
        LegalHoldStatus.validateJsonElement(jsonObj.get("Status"));
      }
      // validate the optional field `Description`
      if (jsonObj.get("Description") != null && !jsonObj.get("Description").isJsonNull()) {
        String.validateJsonElement(jsonObj.get("Description"));
      }
      // validate the optional field `LegalHoldId`
      if (jsonObj.get("LegalHoldId") != null && !jsonObj.get("LegalHoldId").isJsonNull()) {
        String.validateJsonElement(jsonObj.get("LegalHoldId"));
      }
      // validate the optional field `LegalHoldArn`
      if (jsonObj.get("LegalHoldArn") != null && !jsonObj.get("LegalHoldArn").isJsonNull()) {
        String.validateJsonElement(jsonObj.get("LegalHoldArn"));
      }
      // validate the optional field `CreationDate`
      if (jsonObj.get("CreationDate") != null && !jsonObj.get("CreationDate").isJsonNull()) {
        OffsetDateTime.validateJsonElement(jsonObj.get("CreationDate"));
      }
      // validate the optional field `CancellationDate`
      if (jsonObj.get("CancellationDate") != null && !jsonObj.get("CancellationDate").isJsonNull()) {
        OffsetDateTime.validateJsonElement(jsonObj.get("CancellationDate"));
      }
  }

  public static class CustomTypeAdapterFactory implements TypeAdapterFactory {
    @SuppressWarnings("unchecked")
    @Override
    public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
       if (!LegalHold.class.isAssignableFrom(type.getRawType())) {
         return null; // this class only serializes 'LegalHold' and its subtypes
       }
       final TypeAdapter<JsonElement> elementAdapter = gson.getAdapter(JsonElement.class);
       final TypeAdapter<LegalHold> thisAdapter
                        = gson.getDelegateAdapter(this, TypeToken.get(LegalHold.class));

       return (TypeAdapter<T>) new TypeAdapter<LegalHold>() {
           @Override
           public void write(JsonWriter out, LegalHold value) throws IOException {
             JsonObject obj = thisAdapter.toJsonTree(value).getAsJsonObject();
             elementAdapter.write(out, obj);
           }

           @Override
           public LegalHold read(JsonReader in) throws IOException {
             JsonElement jsonElement = elementAdapter.read(in);
             validateJsonElement(jsonElement);
             return thisAdapter.fromJsonTree(jsonElement);
           }

       }.nullSafe();
    }
  }

  /**
   * Create an instance of LegalHold given an JSON string
   *
   * @param jsonString JSON string
   * @return An instance of LegalHold
   * @throws IOException if the JSON string is invalid with respect to LegalHold
   */
  public static LegalHold fromJson(String jsonString) throws IOException {
    return JSON.getGson().fromJson(jsonString, LegalHold.class);
  }

  /**
   * Convert an instance of LegalHold to an JSON string
   *
   * @return JSON string
   */
  public String toJson() {
    return JSON.getGson().toJson(this);
  }
}

