/**
 * Amazon Connect Customer Profiles
 * <fullname>Amazon Connect Customer Profiles</fullname> <p>Amazon Connect Customer Profiles is a unified customer profile for your contact center that has pre-built connectors powered by AppFlow that make it easy to combine customer information from third party applications, such as Salesforce (CRM), ServiceNow (ITSM), and your enterprise resource planning (ERP), with contact history from your Amazon Connect contact center. If you're new to Amazon Connect, you might find it helpful to review the <a href=\"https://docs.aws.amazon.com/connect/latest/adminguide/\">Amazon Connect Administrator Guide</a>.</p>
 *
 * The version of the OpenAPI document: 2020-08-15
 * Contact: mike.ralphson@gmail.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

#include "OAICreateDomainResponse_RuleBasedMatching.h"

#include <QDebug>
#include <QJsonArray>
#include <QJsonDocument>
#include <QObject>

#include "OAIHelpers.h"

namespace OpenAPI {

OAICreateDomainResponse_RuleBasedMatching::OAICreateDomainResponse_RuleBasedMatching(QString json) {
    this->initializeModel();
    this->fromJson(json);
}

OAICreateDomainResponse_RuleBasedMatching::OAICreateDomainResponse_RuleBasedMatching() {
    this->initializeModel();
}

OAICreateDomainResponse_RuleBasedMatching::~OAICreateDomainResponse_RuleBasedMatching() {}

void OAICreateDomainResponse_RuleBasedMatching::initializeModel() {

    m_enabled_isSet = false;
    m_enabled_isValid = false;

    m_matching_rules_isSet = false;
    m_matching_rules_isValid = false;

    m_status_isSet = false;
    m_status_isValid = false;

    m_max_allowed_rule_level_for_merging_isSet = false;
    m_max_allowed_rule_level_for_merging_isValid = false;

    m_max_allowed_rule_level_for_matching_isSet = false;
    m_max_allowed_rule_level_for_matching_isValid = false;

    m_attribute_types_selector_isSet = false;
    m_attribute_types_selector_isValid = false;

    m_conflict_resolution_isSet = false;
    m_conflict_resolution_isValid = false;

    m_exporting_config_isSet = false;
    m_exporting_config_isValid = false;
}

void OAICreateDomainResponse_RuleBasedMatching::fromJson(QString jsonString) {
    QByteArray array(jsonString.toStdString().c_str());
    QJsonDocument doc = QJsonDocument::fromJson(array);
    QJsonObject jsonObject = doc.object();
    this->fromJsonObject(jsonObject);
}

void OAICreateDomainResponse_RuleBasedMatching::fromJsonObject(QJsonObject json) {

    m_enabled_isValid = ::OpenAPI::fromJsonValue(m_enabled, json[QString("Enabled")]);
    m_enabled_isSet = !json[QString("Enabled")].isNull() && m_enabled_isValid;

    m_matching_rules_isValid = ::OpenAPI::fromJsonValue(m_matching_rules, json[QString("MatchingRules")]);
    m_matching_rules_isSet = !json[QString("MatchingRules")].isNull() && m_matching_rules_isValid;

    m_status_isValid = ::OpenAPI::fromJsonValue(m_status, json[QString("Status")]);
    m_status_isSet = !json[QString("Status")].isNull() && m_status_isValid;

    m_max_allowed_rule_level_for_merging_isValid = ::OpenAPI::fromJsonValue(m_max_allowed_rule_level_for_merging, json[QString("MaxAllowedRuleLevelForMerging")]);
    m_max_allowed_rule_level_for_merging_isSet = !json[QString("MaxAllowedRuleLevelForMerging")].isNull() && m_max_allowed_rule_level_for_merging_isValid;

    m_max_allowed_rule_level_for_matching_isValid = ::OpenAPI::fromJsonValue(m_max_allowed_rule_level_for_matching, json[QString("MaxAllowedRuleLevelForMatching")]);
    m_max_allowed_rule_level_for_matching_isSet = !json[QString("MaxAllowedRuleLevelForMatching")].isNull() && m_max_allowed_rule_level_for_matching_isValid;

    m_attribute_types_selector_isValid = ::OpenAPI::fromJsonValue(m_attribute_types_selector, json[QString("AttributeTypesSelector")]);
    m_attribute_types_selector_isSet = !json[QString("AttributeTypesSelector")].isNull() && m_attribute_types_selector_isValid;

    m_conflict_resolution_isValid = ::OpenAPI::fromJsonValue(m_conflict_resolution, json[QString("ConflictResolution")]);
    m_conflict_resolution_isSet = !json[QString("ConflictResolution")].isNull() && m_conflict_resolution_isValid;

    m_exporting_config_isValid = ::OpenAPI::fromJsonValue(m_exporting_config, json[QString("ExportingConfig")]);
    m_exporting_config_isSet = !json[QString("ExportingConfig")].isNull() && m_exporting_config_isValid;
}

QString OAICreateDomainResponse_RuleBasedMatching::asJson() const {
    QJsonObject obj = this->asJsonObject();
    QJsonDocument doc(obj);
    QByteArray bytes = doc.toJson();
    return QString(bytes);
}

QJsonObject OAICreateDomainResponse_RuleBasedMatching::asJsonObject() const {
    QJsonObject obj;
    if (m_enabled_isSet) {
        obj.insert(QString("Enabled"), ::OpenAPI::toJsonValue(m_enabled));
    }
    if (m_matching_rules.isSet()) {
        obj.insert(QString("MatchingRules"), ::OpenAPI::toJsonValue(m_matching_rules));
    }
    if (m_status.isSet()) {
        obj.insert(QString("Status"), ::OpenAPI::toJsonValue(m_status));
    }
    if (m_max_allowed_rule_level_for_merging_isSet) {
        obj.insert(QString("MaxAllowedRuleLevelForMerging"), ::OpenAPI::toJsonValue(m_max_allowed_rule_level_for_merging));
    }
    if (m_max_allowed_rule_level_for_matching_isSet) {
        obj.insert(QString("MaxAllowedRuleLevelForMatching"), ::OpenAPI::toJsonValue(m_max_allowed_rule_level_for_matching));
    }
    if (m_attribute_types_selector.isSet()) {
        obj.insert(QString("AttributeTypesSelector"), ::OpenAPI::toJsonValue(m_attribute_types_selector));
    }
    if (m_conflict_resolution.isSet()) {
        obj.insert(QString("ConflictResolution"), ::OpenAPI::toJsonValue(m_conflict_resolution));
    }
    if (m_exporting_config.isSet()) {
        obj.insert(QString("ExportingConfig"), ::OpenAPI::toJsonValue(m_exporting_config));
    }
    return obj;
}

bool OAICreateDomainResponse_RuleBasedMatching::getEnabled() const {
    return m_enabled;
}
void OAICreateDomainResponse_RuleBasedMatching::setEnabled(const bool &enabled) {
    m_enabled = enabled;
    m_enabled_isSet = true;
}

bool OAICreateDomainResponse_RuleBasedMatching::is_enabled_Set() const{
    return m_enabled_isSet;
}

bool OAICreateDomainResponse_RuleBasedMatching::is_enabled_Valid() const{
    return m_enabled_isValid;
}

QList OAICreateDomainResponse_RuleBasedMatching::getMatchingRules() const {
    return m_matching_rules;
}
void OAICreateDomainResponse_RuleBasedMatching::setMatchingRules(const QList &matching_rules) {
    m_matching_rules = matching_rules;
    m_matching_rules_isSet = true;
}

bool OAICreateDomainResponse_RuleBasedMatching::is_matching_rules_Set() const{
    return m_matching_rules_isSet;
}

bool OAICreateDomainResponse_RuleBasedMatching::is_matching_rules_Valid() const{
    return m_matching_rules_isValid;
}

OAIRuleBasedMatchingStatus OAICreateDomainResponse_RuleBasedMatching::getStatus() const {
    return m_status;
}
void OAICreateDomainResponse_RuleBasedMatching::setStatus(const OAIRuleBasedMatchingStatus &status) {
    m_status = status;
    m_status_isSet = true;
}

bool OAICreateDomainResponse_RuleBasedMatching::is_status_Set() const{
    return m_status_isSet;
}

bool OAICreateDomainResponse_RuleBasedMatching::is_status_Valid() const{
    return m_status_isValid;
}

qint32 OAICreateDomainResponse_RuleBasedMatching::getMaxAllowedRuleLevelForMerging() const {
    return m_max_allowed_rule_level_for_merging;
}
void OAICreateDomainResponse_RuleBasedMatching::setMaxAllowedRuleLevelForMerging(const qint32 &max_allowed_rule_level_for_merging) {
    m_max_allowed_rule_level_for_merging = max_allowed_rule_level_for_merging;
    m_max_allowed_rule_level_for_merging_isSet = true;
}

bool OAICreateDomainResponse_RuleBasedMatching::is_max_allowed_rule_level_for_merging_Set() const{
    return m_max_allowed_rule_level_for_merging_isSet;
}

bool OAICreateDomainResponse_RuleBasedMatching::is_max_allowed_rule_level_for_merging_Valid() const{
    return m_max_allowed_rule_level_for_merging_isValid;
}

qint32 OAICreateDomainResponse_RuleBasedMatching::getMaxAllowedRuleLevelForMatching() const {
    return m_max_allowed_rule_level_for_matching;
}
void OAICreateDomainResponse_RuleBasedMatching::setMaxAllowedRuleLevelForMatching(const qint32 &max_allowed_rule_level_for_matching) {
    m_max_allowed_rule_level_for_matching = max_allowed_rule_level_for_matching;
    m_max_allowed_rule_level_for_matching_isSet = true;
}

bool OAICreateDomainResponse_RuleBasedMatching::is_max_allowed_rule_level_for_matching_Set() const{
    return m_max_allowed_rule_level_for_matching_isSet;
}

bool OAICreateDomainResponse_RuleBasedMatching::is_max_allowed_rule_level_for_matching_Valid() const{
    return m_max_allowed_rule_level_for_matching_isValid;
}

OAIUpdateDomain_request_RuleBasedMatching_AttributeTypesSelector OAICreateDomainResponse_RuleBasedMatching::getAttributeTypesSelector() const {
    return m_attribute_types_selector;
}
void OAICreateDomainResponse_RuleBasedMatching::setAttributeTypesSelector(const OAIUpdateDomain_request_RuleBasedMatching_AttributeTypesSelector &attribute_types_selector) {
    m_attribute_types_selector = attribute_types_selector;
    m_attribute_types_selector_isSet = true;
}

bool OAICreateDomainResponse_RuleBasedMatching::is_attribute_types_selector_Set() const{
    return m_attribute_types_selector_isSet;
}

bool OAICreateDomainResponse_RuleBasedMatching::is_attribute_types_selector_Valid() const{
    return m_attribute_types_selector_isValid;
}

OAIConflictResolution OAICreateDomainResponse_RuleBasedMatching::getConflictResolution() const {
    return m_conflict_resolution;
}
void OAICreateDomainResponse_RuleBasedMatching::setConflictResolution(const OAIConflictResolution &conflict_resolution) {
    m_conflict_resolution = conflict_resolution;
    m_conflict_resolution_isSet = true;
}

bool OAICreateDomainResponse_RuleBasedMatching::is_conflict_resolution_Set() const{
    return m_conflict_resolution_isSet;
}

bool OAICreateDomainResponse_RuleBasedMatching::is_conflict_resolution_Valid() const{
    return m_conflict_resolution_isValid;
}

OAIExportingConfig OAICreateDomainResponse_RuleBasedMatching::getExportingConfig() const {
    return m_exporting_config;
}
void OAICreateDomainResponse_RuleBasedMatching::setExportingConfig(const OAIExportingConfig &exporting_config) {
    m_exporting_config = exporting_config;
    m_exporting_config_isSet = true;
}

bool OAICreateDomainResponse_RuleBasedMatching::is_exporting_config_Set() const{
    return m_exporting_config_isSet;
}

bool OAICreateDomainResponse_RuleBasedMatching::is_exporting_config_Valid() const{
    return m_exporting_config_isValid;
}

bool OAICreateDomainResponse_RuleBasedMatching::isSet() const {
    bool isObjectUpdated = false;
    do {
        if (m_enabled_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_matching_rules.isSet()) {
            isObjectUpdated = true;
            break;
        }

        if (m_status.isSet()) {
            isObjectUpdated = true;
            break;
        }

        if (m_max_allowed_rule_level_for_merging_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_max_allowed_rule_level_for_matching_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_attribute_types_selector.isSet()) {
            isObjectUpdated = true;
            break;
        }

        if (m_conflict_resolution.isSet()) {
            isObjectUpdated = true;
            break;
        }

        if (m_exporting_config.isSet()) {
            isObjectUpdated = true;
            break;
        }
    } while (false);
    return isObjectUpdated;
}

bool OAICreateDomainResponse_RuleBasedMatching::isValid() const {
    // only required properties are required for the object to be considered valid
    return true;
}

} // namespace OpenAPI
