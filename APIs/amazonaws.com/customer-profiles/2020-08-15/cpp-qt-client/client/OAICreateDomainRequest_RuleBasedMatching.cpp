/**
 * Amazon Connect Customer Profiles
 * <fullname>Amazon Connect Customer Profiles</fullname> <p>Amazon Connect Customer Profiles is a unified customer profile for your contact center that has pre-built connectors powered by AppFlow that make it easy to combine customer information from third party applications, such as Salesforce (CRM), ServiceNow (ITSM), and your enterprise resource planning (ERP), with contact history from your Amazon Connect contact center. If you're new to Amazon Connect, you might find it helpful to review the <a href=\"https://docs.aws.amazon.com/connect/latest/adminguide/\">Amazon Connect Administrator Guide</a>.</p>
 *
 * The version of the OpenAPI document: 2020-08-15
 * Contact: mike.ralphson@gmail.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

#include "OAICreateDomainRequest_RuleBasedMatching.h"

#include <QDebug>
#include <QJsonArray>
#include <QJsonDocument>
#include <QObject>

#include "OAIHelpers.h"

namespace OpenAPI {

OAICreateDomainRequest_RuleBasedMatching::OAICreateDomainRequest_RuleBasedMatching(QString json) {
    this->initializeModel();
    this->fromJson(json);
}

OAICreateDomainRequest_RuleBasedMatching::OAICreateDomainRequest_RuleBasedMatching() {
    this->initializeModel();
}

OAICreateDomainRequest_RuleBasedMatching::~OAICreateDomainRequest_RuleBasedMatching() {}

void OAICreateDomainRequest_RuleBasedMatching::initializeModel() {

    m_enabled_isSet = false;
    m_enabled_isValid = false;

    m_matching_rules_isSet = false;
    m_matching_rules_isValid = false;

    m_max_allowed_rule_level_for_merging_isSet = false;
    m_max_allowed_rule_level_for_merging_isValid = false;

    m_max_allowed_rule_level_for_matching_isSet = false;
    m_max_allowed_rule_level_for_matching_isValid = false;

    m_attribute_types_selector_isSet = false;
    m_attribute_types_selector_isValid = false;

    m_conflict_resolution_isSet = false;
    m_conflict_resolution_isValid = false;

    m_exporting_config_isSet = false;
    m_exporting_config_isValid = false;
}

void OAICreateDomainRequest_RuleBasedMatching::fromJson(QString jsonString) {
    QByteArray array(jsonString.toStdString().c_str());
    QJsonDocument doc = QJsonDocument::fromJson(array);
    QJsonObject jsonObject = doc.object();
    this->fromJsonObject(jsonObject);
}

void OAICreateDomainRequest_RuleBasedMatching::fromJsonObject(QJsonObject json) {

    m_enabled_isValid = ::OpenAPI::fromJsonValue(m_enabled, json[QString("Enabled")]);
    m_enabled_isSet = !json[QString("Enabled")].isNull() && m_enabled_isValid;

    m_matching_rules_isValid = ::OpenAPI::fromJsonValue(m_matching_rules, json[QString("MatchingRules")]);
    m_matching_rules_isSet = !json[QString("MatchingRules")].isNull() && m_matching_rules_isValid;

    m_max_allowed_rule_level_for_merging_isValid = ::OpenAPI::fromJsonValue(m_max_allowed_rule_level_for_merging, json[QString("MaxAllowedRuleLevelForMerging")]);
    m_max_allowed_rule_level_for_merging_isSet = !json[QString("MaxAllowedRuleLevelForMerging")].isNull() && m_max_allowed_rule_level_for_merging_isValid;

    m_max_allowed_rule_level_for_matching_isValid = ::OpenAPI::fromJsonValue(m_max_allowed_rule_level_for_matching, json[QString("MaxAllowedRuleLevelForMatching")]);
    m_max_allowed_rule_level_for_matching_isSet = !json[QString("MaxAllowedRuleLevelForMatching")].isNull() && m_max_allowed_rule_level_for_matching_isValid;

    m_attribute_types_selector_isValid = ::OpenAPI::fromJsonValue(m_attribute_types_selector, json[QString("AttributeTypesSelector")]);
    m_attribute_types_selector_isSet = !json[QString("AttributeTypesSelector")].isNull() && m_attribute_types_selector_isValid;

    m_conflict_resolution_isValid = ::OpenAPI::fromJsonValue(m_conflict_resolution, json[QString("ConflictResolution")]);
    m_conflict_resolution_isSet = !json[QString("ConflictResolution")].isNull() && m_conflict_resolution_isValid;

    m_exporting_config_isValid = ::OpenAPI::fromJsonValue(m_exporting_config, json[QString("ExportingConfig")]);
    m_exporting_config_isSet = !json[QString("ExportingConfig")].isNull() && m_exporting_config_isValid;
}

QString OAICreateDomainRequest_RuleBasedMatching::asJson() const {
    QJsonObject obj = this->asJsonObject();
    QJsonDocument doc(obj);
    QByteArray bytes = doc.toJson();
    return QString(bytes);
}

QJsonObject OAICreateDomainRequest_RuleBasedMatching::asJsonObject() const {
    QJsonObject obj;
    if (m_enabled_isSet) {
        obj.insert(QString("Enabled"), ::OpenAPI::toJsonValue(m_enabled));
    }
    if (m_matching_rules.isSet()) {
        obj.insert(QString("MatchingRules"), ::OpenAPI::toJsonValue(m_matching_rules));
    }
    if (m_max_allowed_rule_level_for_merging_isSet) {
        obj.insert(QString("MaxAllowedRuleLevelForMerging"), ::OpenAPI::toJsonValue(m_max_allowed_rule_level_for_merging));
    }
    if (m_max_allowed_rule_level_for_matching_isSet) {
        obj.insert(QString("MaxAllowedRuleLevelForMatching"), ::OpenAPI::toJsonValue(m_max_allowed_rule_level_for_matching));
    }
    if (m_attribute_types_selector.isSet()) {
        obj.insert(QString("AttributeTypesSelector"), ::OpenAPI::toJsonValue(m_attribute_types_selector));
    }
    if (m_conflict_resolution.isSet()) {
        obj.insert(QString("ConflictResolution"), ::OpenAPI::toJsonValue(m_conflict_resolution));
    }
    if (m_exporting_config.isSet()) {
        obj.insert(QString("ExportingConfig"), ::OpenAPI::toJsonValue(m_exporting_config));
    }
    return obj;
}

bool OAICreateDomainRequest_RuleBasedMatching::getEnabled() const {
    return m_enabled;
}
void OAICreateDomainRequest_RuleBasedMatching::setEnabled(const bool &enabled) {
    m_enabled = enabled;
    m_enabled_isSet = true;
}

bool OAICreateDomainRequest_RuleBasedMatching::is_enabled_Set() const{
    return m_enabled_isSet;
}

bool OAICreateDomainRequest_RuleBasedMatching::is_enabled_Valid() const{
    return m_enabled_isValid;
}

QList OAICreateDomainRequest_RuleBasedMatching::getMatchingRules() const {
    return m_matching_rules;
}
void OAICreateDomainRequest_RuleBasedMatching::setMatchingRules(const QList &matching_rules) {
    m_matching_rules = matching_rules;
    m_matching_rules_isSet = true;
}

bool OAICreateDomainRequest_RuleBasedMatching::is_matching_rules_Set() const{
    return m_matching_rules_isSet;
}

bool OAICreateDomainRequest_RuleBasedMatching::is_matching_rules_Valid() const{
    return m_matching_rules_isValid;
}

qint32 OAICreateDomainRequest_RuleBasedMatching::getMaxAllowedRuleLevelForMerging() const {
    return m_max_allowed_rule_level_for_merging;
}
void OAICreateDomainRequest_RuleBasedMatching::setMaxAllowedRuleLevelForMerging(const qint32 &max_allowed_rule_level_for_merging) {
    m_max_allowed_rule_level_for_merging = max_allowed_rule_level_for_merging;
    m_max_allowed_rule_level_for_merging_isSet = true;
}

bool OAICreateDomainRequest_RuleBasedMatching::is_max_allowed_rule_level_for_merging_Set() const{
    return m_max_allowed_rule_level_for_merging_isSet;
}

bool OAICreateDomainRequest_RuleBasedMatching::is_max_allowed_rule_level_for_merging_Valid() const{
    return m_max_allowed_rule_level_for_merging_isValid;
}

qint32 OAICreateDomainRequest_RuleBasedMatching::getMaxAllowedRuleLevelForMatching() const {
    return m_max_allowed_rule_level_for_matching;
}
void OAICreateDomainRequest_RuleBasedMatching::setMaxAllowedRuleLevelForMatching(const qint32 &max_allowed_rule_level_for_matching) {
    m_max_allowed_rule_level_for_matching = max_allowed_rule_level_for_matching;
    m_max_allowed_rule_level_for_matching_isSet = true;
}

bool OAICreateDomainRequest_RuleBasedMatching::is_max_allowed_rule_level_for_matching_Set() const{
    return m_max_allowed_rule_level_for_matching_isSet;
}

bool OAICreateDomainRequest_RuleBasedMatching::is_max_allowed_rule_level_for_matching_Valid() const{
    return m_max_allowed_rule_level_for_matching_isValid;
}

OAIUpdateDomain_request_RuleBasedMatching_AttributeTypesSelector OAICreateDomainRequest_RuleBasedMatching::getAttributeTypesSelector() const {
    return m_attribute_types_selector;
}
void OAICreateDomainRequest_RuleBasedMatching::setAttributeTypesSelector(const OAIUpdateDomain_request_RuleBasedMatching_AttributeTypesSelector &attribute_types_selector) {
    m_attribute_types_selector = attribute_types_selector;
    m_attribute_types_selector_isSet = true;
}

bool OAICreateDomainRequest_RuleBasedMatching::is_attribute_types_selector_Set() const{
    return m_attribute_types_selector_isSet;
}

bool OAICreateDomainRequest_RuleBasedMatching::is_attribute_types_selector_Valid() const{
    return m_attribute_types_selector_isValid;
}

OAIConflictResolution OAICreateDomainRequest_RuleBasedMatching::getConflictResolution() const {
    return m_conflict_resolution;
}
void OAICreateDomainRequest_RuleBasedMatching::setConflictResolution(const OAIConflictResolution &conflict_resolution) {
    m_conflict_resolution = conflict_resolution;
    m_conflict_resolution_isSet = true;
}

bool OAICreateDomainRequest_RuleBasedMatching::is_conflict_resolution_Set() const{
    return m_conflict_resolution_isSet;
}

bool OAICreateDomainRequest_RuleBasedMatching::is_conflict_resolution_Valid() const{
    return m_conflict_resolution_isValid;
}

OAIExportingConfig OAICreateDomainRequest_RuleBasedMatching::getExportingConfig() const {
    return m_exporting_config;
}
void OAICreateDomainRequest_RuleBasedMatching::setExportingConfig(const OAIExportingConfig &exporting_config) {
    m_exporting_config = exporting_config;
    m_exporting_config_isSet = true;
}

bool OAICreateDomainRequest_RuleBasedMatching::is_exporting_config_Set() const{
    return m_exporting_config_isSet;
}

bool OAICreateDomainRequest_RuleBasedMatching::is_exporting_config_Valid() const{
    return m_exporting_config_isValid;
}

bool OAICreateDomainRequest_RuleBasedMatching::isSet() const {
    bool isObjectUpdated = false;
    do {
        if (m_enabled_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_matching_rules.isSet()) {
            isObjectUpdated = true;
            break;
        }

        if (m_max_allowed_rule_level_for_merging_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_max_allowed_rule_level_for_matching_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_attribute_types_selector.isSet()) {
            isObjectUpdated = true;
            break;
        }

        if (m_conflict_resolution.isSet()) {
            isObjectUpdated = true;
            break;
        }

        if (m_exporting_config.isSet()) {
            isObjectUpdated = true;
            break;
        }
    } while (false);
    return isObjectUpdated;
}

bool OAICreateDomainRequest_RuleBasedMatching::isValid() const {
    // only required properties are required for the object to be considered valid
    return m_enabled_isValid && true;
}

} // namespace OpenAPI
