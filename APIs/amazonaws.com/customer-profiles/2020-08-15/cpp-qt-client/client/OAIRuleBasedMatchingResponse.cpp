/**
 * Amazon Connect Customer Profiles
 * <fullname>Amazon Connect Customer Profiles</fullname> <p>Amazon Connect Customer Profiles is a unified customer profile for your contact center that has pre-built connectors powered by AppFlow that make it easy to combine customer information from third party applications, such as Salesforce (CRM), ServiceNow (ITSM), and your enterprise resource planning (ERP), with contact history from your Amazon Connect contact center. If you're new to Amazon Connect, you might find it helpful to review the <a href=\"https://docs.aws.amazon.com/connect/latest/adminguide/\">Amazon Connect Administrator Guide</a>.</p>
 *
 * The version of the OpenAPI document: 2020-08-15
 * Contact: mike.ralphson@gmail.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

#include "OAIRuleBasedMatchingResponse.h"

#include <QDebug>
#include <QJsonArray>
#include <QJsonDocument>
#include <QObject>

#include "OAIHelpers.h"

namespace OpenAPI {

OAIRuleBasedMatchingResponse::OAIRuleBasedMatchingResponse(QString json) {
    this->initializeModel();
    this->fromJson(json);
}

OAIRuleBasedMatchingResponse::OAIRuleBasedMatchingResponse() {
    this->initializeModel();
}

OAIRuleBasedMatchingResponse::~OAIRuleBasedMatchingResponse() {}

void OAIRuleBasedMatchingResponse::initializeModel() {

    m_enabled_isSet = false;
    m_enabled_isValid = false;

    m_matching_rules_isSet = false;
    m_matching_rules_isValid = false;

    m_status_isSet = false;
    m_status_isValid = false;

    m_max_allowed_rule_level_for_merging_isSet = false;
    m_max_allowed_rule_level_for_merging_isValid = false;

    m_max_allowed_rule_level_for_matching_isSet = false;
    m_max_allowed_rule_level_for_matching_isValid = false;

    m_attribute_types_selector_isSet = false;
    m_attribute_types_selector_isValid = false;

    m_conflict_resolution_isSet = false;
    m_conflict_resolution_isValid = false;

    m_exporting_config_isSet = false;
    m_exporting_config_isValid = false;
}

void OAIRuleBasedMatchingResponse::fromJson(QString jsonString) {
    QByteArray array(jsonString.toStdString().c_str());
    QJsonDocument doc = QJsonDocument::fromJson(array);
    QJsonObject jsonObject = doc.object();
    this->fromJsonObject(jsonObject);
}

void OAIRuleBasedMatchingResponse::fromJsonObject(QJsonObject json) {

    m_enabled_isValid = ::OpenAPI::fromJsonValue(m_enabled, json[QString("Enabled")]);
    m_enabled_isSet = !json[QString("Enabled")].isNull() && m_enabled_isValid;

    m_matching_rules_isValid = ::OpenAPI::fromJsonValue(m_matching_rules, json[QString("MatchingRules")]);
    m_matching_rules_isSet = !json[QString("MatchingRules")].isNull() && m_matching_rules_isValid;

    m_status_isValid = ::OpenAPI::fromJsonValue(m_status, json[QString("Status")]);
    m_status_isSet = !json[QString("Status")].isNull() && m_status_isValid;

    m_max_allowed_rule_level_for_merging_isValid = ::OpenAPI::fromJsonValue(m_max_allowed_rule_level_for_merging, json[QString("MaxAllowedRuleLevelForMerging")]);
    m_max_allowed_rule_level_for_merging_isSet = !json[QString("MaxAllowedRuleLevelForMerging")].isNull() && m_max_allowed_rule_level_for_merging_isValid;

    m_max_allowed_rule_level_for_matching_isValid = ::OpenAPI::fromJsonValue(m_max_allowed_rule_level_for_matching, json[QString("MaxAllowedRuleLevelForMatching")]);
    m_max_allowed_rule_level_for_matching_isSet = !json[QString("MaxAllowedRuleLevelForMatching")].isNull() && m_max_allowed_rule_level_for_matching_isValid;

    m_attribute_types_selector_isValid = ::OpenAPI::fromJsonValue(m_attribute_types_selector, json[QString("AttributeTypesSelector")]);
    m_attribute_types_selector_isSet = !json[QString("AttributeTypesSelector")].isNull() && m_attribute_types_selector_isValid;

    m_conflict_resolution_isValid = ::OpenAPI::fromJsonValue(m_conflict_resolution, json[QString("ConflictResolution")]);
    m_conflict_resolution_isSet = !json[QString("ConflictResolution")].isNull() && m_conflict_resolution_isValid;

    m_exporting_config_isValid = ::OpenAPI::fromJsonValue(m_exporting_config, json[QString("ExportingConfig")]);
    m_exporting_config_isSet = !json[QString("ExportingConfig")].isNull() && m_exporting_config_isValid;
}

QString OAIRuleBasedMatchingResponse::asJson() const {
    QJsonObject obj = this->asJsonObject();
    QJsonDocument doc(obj);
    QByteArray bytes = doc.toJson();
    return QString(bytes);
}

QJsonObject OAIRuleBasedMatchingResponse::asJsonObject() const {
    QJsonObject obj;
    if (m_enabled_isSet) {
        obj.insert(QString("Enabled"), ::OpenAPI::toJsonValue(m_enabled));
    }
    if (m_matching_rules.isSet()) {
        obj.insert(QString("MatchingRules"), ::OpenAPI::toJsonValue(m_matching_rules));
    }
    if (m_status.isSet()) {
        obj.insert(QString("Status"), ::OpenAPI::toJsonValue(m_status));
    }
    if (m_max_allowed_rule_level_for_merging_isSet) {
        obj.insert(QString("MaxAllowedRuleLevelForMerging"), ::OpenAPI::toJsonValue(m_max_allowed_rule_level_for_merging));
    }
    if (m_max_allowed_rule_level_for_matching_isSet) {
        obj.insert(QString("MaxAllowedRuleLevelForMatching"), ::OpenAPI::toJsonValue(m_max_allowed_rule_level_for_matching));
    }
    if (m_attribute_types_selector.isSet()) {
        obj.insert(QString("AttributeTypesSelector"), ::OpenAPI::toJsonValue(m_attribute_types_selector));
    }
    if (m_conflict_resolution.isSet()) {
        obj.insert(QString("ConflictResolution"), ::OpenAPI::toJsonValue(m_conflict_resolution));
    }
    if (m_exporting_config.isSet()) {
        obj.insert(QString("ExportingConfig"), ::OpenAPI::toJsonValue(m_exporting_config));
    }
    return obj;
}

bool OAIRuleBasedMatchingResponse::getEnabled() const {
    return m_enabled;
}
void OAIRuleBasedMatchingResponse::setEnabled(const bool &enabled) {
    m_enabled = enabled;
    m_enabled_isSet = true;
}

bool OAIRuleBasedMatchingResponse::is_enabled_Set() const{
    return m_enabled_isSet;
}

bool OAIRuleBasedMatchingResponse::is_enabled_Valid() const{
    return m_enabled_isValid;
}

QList OAIRuleBasedMatchingResponse::getMatchingRules() const {
    return m_matching_rules;
}
void OAIRuleBasedMatchingResponse::setMatchingRules(const QList &matching_rules) {
    m_matching_rules = matching_rules;
    m_matching_rules_isSet = true;
}

bool OAIRuleBasedMatchingResponse::is_matching_rules_Set() const{
    return m_matching_rules_isSet;
}

bool OAIRuleBasedMatchingResponse::is_matching_rules_Valid() const{
    return m_matching_rules_isValid;
}

OAIRuleBasedMatchingStatus OAIRuleBasedMatchingResponse::getStatus() const {
    return m_status;
}
void OAIRuleBasedMatchingResponse::setStatus(const OAIRuleBasedMatchingStatus &status) {
    m_status = status;
    m_status_isSet = true;
}

bool OAIRuleBasedMatchingResponse::is_status_Set() const{
    return m_status_isSet;
}

bool OAIRuleBasedMatchingResponse::is_status_Valid() const{
    return m_status_isValid;
}

qint32 OAIRuleBasedMatchingResponse::getMaxAllowedRuleLevelForMerging() const {
    return m_max_allowed_rule_level_for_merging;
}
void OAIRuleBasedMatchingResponse::setMaxAllowedRuleLevelForMerging(const qint32 &max_allowed_rule_level_for_merging) {
    m_max_allowed_rule_level_for_merging = max_allowed_rule_level_for_merging;
    m_max_allowed_rule_level_for_merging_isSet = true;
}

bool OAIRuleBasedMatchingResponse::is_max_allowed_rule_level_for_merging_Set() const{
    return m_max_allowed_rule_level_for_merging_isSet;
}

bool OAIRuleBasedMatchingResponse::is_max_allowed_rule_level_for_merging_Valid() const{
    return m_max_allowed_rule_level_for_merging_isValid;
}

qint32 OAIRuleBasedMatchingResponse::getMaxAllowedRuleLevelForMatching() const {
    return m_max_allowed_rule_level_for_matching;
}
void OAIRuleBasedMatchingResponse::setMaxAllowedRuleLevelForMatching(const qint32 &max_allowed_rule_level_for_matching) {
    m_max_allowed_rule_level_for_matching = max_allowed_rule_level_for_matching;
    m_max_allowed_rule_level_for_matching_isSet = true;
}

bool OAIRuleBasedMatchingResponse::is_max_allowed_rule_level_for_matching_Set() const{
    return m_max_allowed_rule_level_for_matching_isSet;
}

bool OAIRuleBasedMatchingResponse::is_max_allowed_rule_level_for_matching_Valid() const{
    return m_max_allowed_rule_level_for_matching_isValid;
}

OAIUpdateDomain_request_RuleBasedMatching_AttributeTypesSelector OAIRuleBasedMatchingResponse::getAttributeTypesSelector() const {
    return m_attribute_types_selector;
}
void OAIRuleBasedMatchingResponse::setAttributeTypesSelector(const OAIUpdateDomain_request_RuleBasedMatching_AttributeTypesSelector &attribute_types_selector) {
    m_attribute_types_selector = attribute_types_selector;
    m_attribute_types_selector_isSet = true;
}

bool OAIRuleBasedMatchingResponse::is_attribute_types_selector_Set() const{
    return m_attribute_types_selector_isSet;
}

bool OAIRuleBasedMatchingResponse::is_attribute_types_selector_Valid() const{
    return m_attribute_types_selector_isValid;
}

OAIConflictResolution OAIRuleBasedMatchingResponse::getConflictResolution() const {
    return m_conflict_resolution;
}
void OAIRuleBasedMatchingResponse::setConflictResolution(const OAIConflictResolution &conflict_resolution) {
    m_conflict_resolution = conflict_resolution;
    m_conflict_resolution_isSet = true;
}

bool OAIRuleBasedMatchingResponse::is_conflict_resolution_Set() const{
    return m_conflict_resolution_isSet;
}

bool OAIRuleBasedMatchingResponse::is_conflict_resolution_Valid() const{
    return m_conflict_resolution_isValid;
}

OAIExportingConfig OAIRuleBasedMatchingResponse::getExportingConfig() const {
    return m_exporting_config;
}
void OAIRuleBasedMatchingResponse::setExportingConfig(const OAIExportingConfig &exporting_config) {
    m_exporting_config = exporting_config;
    m_exporting_config_isSet = true;
}

bool OAIRuleBasedMatchingResponse::is_exporting_config_Set() const{
    return m_exporting_config_isSet;
}

bool OAIRuleBasedMatchingResponse::is_exporting_config_Valid() const{
    return m_exporting_config_isValid;
}

bool OAIRuleBasedMatchingResponse::isSet() const {
    bool isObjectUpdated = false;
    do {
        if (m_enabled_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_matching_rules.isSet()) {
            isObjectUpdated = true;
            break;
        }

        if (m_status.isSet()) {
            isObjectUpdated = true;
            break;
        }

        if (m_max_allowed_rule_level_for_merging_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_max_allowed_rule_level_for_matching_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_attribute_types_selector.isSet()) {
            isObjectUpdated = true;
            break;
        }

        if (m_conflict_resolution.isSet()) {
            isObjectUpdated = true;
            break;
        }

        if (m_exporting_config.isSet()) {
            isObjectUpdated = true;
            break;
        }
    } while (false);
    return isObjectUpdated;
}

bool OAIRuleBasedMatchingResponse::isValid() const {
    // only required properties are required for the object to be considered valid
    return true;
}

} // namespace OpenAPI
