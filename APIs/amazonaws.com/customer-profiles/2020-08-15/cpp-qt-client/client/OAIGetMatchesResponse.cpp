/**
 * Amazon Connect Customer Profiles
 * <fullname>Amazon Connect Customer Profiles</fullname> <p>Amazon Connect Customer Profiles is a unified customer profile for your contact center that has pre-built connectors powered by AppFlow that make it easy to combine customer information from third party applications, such as Salesforce (CRM), ServiceNow (ITSM), and your enterprise resource planning (ERP), with contact history from your Amazon Connect contact center. If you're new to Amazon Connect, you might find it helpful to review the <a href=\"https://docs.aws.amazon.com/connect/latest/adminguide/\">Amazon Connect Administrator Guide</a>.</p>
 *
 * The version of the OpenAPI document: 2020-08-15
 * Contact: mike.ralphson@gmail.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

#include "OAIGetMatchesResponse.h"

#include <QDebug>
#include <QJsonArray>
#include <QJsonDocument>
#include <QObject>

#include "OAIHelpers.h"

namespace OpenAPI {

OAIGetMatchesResponse::OAIGetMatchesResponse(QString json) {
    this->initializeModel();
    this->fromJson(json);
}

OAIGetMatchesResponse::OAIGetMatchesResponse() {
    this->initializeModel();
}

OAIGetMatchesResponse::~OAIGetMatchesResponse() {}

void OAIGetMatchesResponse::initializeModel() {

    m_next_token_isSet = false;
    m_next_token_isValid = false;

    m_match_generation_date_isSet = false;
    m_match_generation_date_isValid = false;

    m_potential_matches_isSet = false;
    m_potential_matches_isValid = false;

    m_matches_isSet = false;
    m_matches_isValid = false;
}

void OAIGetMatchesResponse::fromJson(QString jsonString) {
    QByteArray array(jsonString.toStdString().c_str());
    QJsonDocument doc = QJsonDocument::fromJson(array);
    QJsonObject jsonObject = doc.object();
    this->fromJsonObject(jsonObject);
}

void OAIGetMatchesResponse::fromJsonObject(QJsonObject json) {

    m_next_token_isValid = ::OpenAPI::fromJsonValue(m_next_token, json[QString("NextToken")]);
    m_next_token_isSet = !json[QString("NextToken")].isNull() && m_next_token_isValid;

    m_match_generation_date_isValid = ::OpenAPI::fromJsonValue(m_match_generation_date, json[QString("MatchGenerationDate")]);
    m_match_generation_date_isSet = !json[QString("MatchGenerationDate")].isNull() && m_match_generation_date_isValid;

    m_potential_matches_isValid = ::OpenAPI::fromJsonValue(m_potential_matches, json[QString("PotentialMatches")]);
    m_potential_matches_isSet = !json[QString("PotentialMatches")].isNull() && m_potential_matches_isValid;

    m_matches_isValid = ::OpenAPI::fromJsonValue(m_matches, json[QString("Matches")]);
    m_matches_isSet = !json[QString("Matches")].isNull() && m_matches_isValid;
}

QString OAIGetMatchesResponse::asJson() const {
    QJsonObject obj = this->asJsonObject();
    QJsonDocument doc(obj);
    QByteArray bytes = doc.toJson();
    return QString(bytes);
}

QJsonObject OAIGetMatchesResponse::asJsonObject() const {
    QJsonObject obj;
    if (m_next_token_isSet) {
        obj.insert(QString("NextToken"), ::OpenAPI::toJsonValue(m_next_token));
    }
    if (m_match_generation_date_isSet) {
        obj.insert(QString("MatchGenerationDate"), ::OpenAPI::toJsonValue(m_match_generation_date));
    }
    if (m_potential_matches_isSet) {
        obj.insert(QString("PotentialMatches"), ::OpenAPI::toJsonValue(m_potential_matches));
    }
    if (m_matches.isSet()) {
        obj.insert(QString("Matches"), ::OpenAPI::toJsonValue(m_matches));
    }
    return obj;
}

QString OAIGetMatchesResponse::getNextToken() const {
    return m_next_token;
}
void OAIGetMatchesResponse::setNextToken(const QString &next_token) {
    m_next_token = next_token;
    m_next_token_isSet = true;
}

bool OAIGetMatchesResponse::is_next_token_Set() const{
    return m_next_token_isSet;
}

bool OAIGetMatchesResponse::is_next_token_Valid() const{
    return m_next_token_isValid;
}

QDateTime OAIGetMatchesResponse::getMatchGenerationDate() const {
    return m_match_generation_date;
}
void OAIGetMatchesResponse::setMatchGenerationDate(const QDateTime &match_generation_date) {
    m_match_generation_date = match_generation_date;
    m_match_generation_date_isSet = true;
}

bool OAIGetMatchesResponse::is_match_generation_date_Set() const{
    return m_match_generation_date_isSet;
}

bool OAIGetMatchesResponse::is_match_generation_date_Valid() const{
    return m_match_generation_date_isValid;
}

qint32 OAIGetMatchesResponse::getPotentialMatches() const {
    return m_potential_matches;
}
void OAIGetMatchesResponse::setPotentialMatches(const qint32 &potential_matches) {
    m_potential_matches = potential_matches;
    m_potential_matches_isSet = true;
}

bool OAIGetMatchesResponse::is_potential_matches_Set() const{
    return m_potential_matches_isSet;
}

bool OAIGetMatchesResponse::is_potential_matches_Valid() const{
    return m_potential_matches_isValid;
}

QList OAIGetMatchesResponse::getMatches() const {
    return m_matches;
}
void OAIGetMatchesResponse::setMatches(const QList &matches) {
    m_matches = matches;
    m_matches_isSet = true;
}

bool OAIGetMatchesResponse::is_matches_Set() const{
    return m_matches_isSet;
}

bool OAIGetMatchesResponse::is_matches_Valid() const{
    return m_matches_isValid;
}

bool OAIGetMatchesResponse::isSet() const {
    bool isObjectUpdated = false;
    do {
        if (m_next_token_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_match_generation_date_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_potential_matches_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_matches.isSet()) {
            isObjectUpdated = true;
            break;
        }
    } while (false);
    return isObjectUpdated;
}

bool OAIGetMatchesResponse::isValid() const {
    // only required properties are required for the object to be considered valid
    return true;
}

} // namespace OpenAPI
