/**
 * Amazon Connect Customer Profiles
 * <fullname>Amazon Connect Customer Profiles</fullname> <p>Amazon Connect Customer Profiles is a unified customer profile for your contact center that has pre-built connectors powered by AppFlow that make it easy to combine customer information from third party applications, such as Salesforce (CRM), ServiceNow (ITSM), and your enterprise resource planning (ERP), with contact history from your Amazon Connect contact center. If you're new to Amazon Connect, you might find it helpful to review the <a href=\"https://docs.aws.amazon.com/connect/latest/adminguide/\">Amazon Connect Administrator Guide</a>.</p>
 *
 * The version of the OpenAPI document: 2020-08-15
 * Contact: mike.ralphson@gmail.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

#include "OAIUpdateDomainRequest_RuleBasedMatching.h"

#include <QDebug>
#include <QJsonArray>
#include <QJsonDocument>
#include <QObject>

#include "OAIHelpers.h"

namespace OpenAPI {

OAIUpdateDomainRequest_RuleBasedMatching::OAIUpdateDomainRequest_RuleBasedMatching(QString json) {
    this->initializeModel();
    this->fromJson(json);
}

OAIUpdateDomainRequest_RuleBasedMatching::OAIUpdateDomainRequest_RuleBasedMatching() {
    this->initializeModel();
}

OAIUpdateDomainRequest_RuleBasedMatching::~OAIUpdateDomainRequest_RuleBasedMatching() {}

void OAIUpdateDomainRequest_RuleBasedMatching::initializeModel() {

    m_enabled_isSet = false;
    m_enabled_isValid = false;

    m_matching_rules_isSet = false;
    m_matching_rules_isValid = false;

    m_max_allowed_rule_level_for_merging_isSet = false;
    m_max_allowed_rule_level_for_merging_isValid = false;

    m_max_allowed_rule_level_for_matching_isSet = false;
    m_max_allowed_rule_level_for_matching_isValid = false;

    m_attribute_types_selector_isSet = false;
    m_attribute_types_selector_isValid = false;

    m_conflict_resolution_isSet = false;
    m_conflict_resolution_isValid = false;

    m_exporting_config_isSet = false;
    m_exporting_config_isValid = false;
}

void OAIUpdateDomainRequest_RuleBasedMatching::fromJson(QString jsonString) {
    QByteArray array(jsonString.toStdString().c_str());
    QJsonDocument doc = QJsonDocument::fromJson(array);
    QJsonObject jsonObject = doc.object();
    this->fromJsonObject(jsonObject);
}

void OAIUpdateDomainRequest_RuleBasedMatching::fromJsonObject(QJsonObject json) {

    m_enabled_isValid = ::OpenAPI::fromJsonValue(m_enabled, json[QString("Enabled")]);
    m_enabled_isSet = !json[QString("Enabled")].isNull() && m_enabled_isValid;

    m_matching_rules_isValid = ::OpenAPI::fromJsonValue(m_matching_rules, json[QString("MatchingRules")]);
    m_matching_rules_isSet = !json[QString("MatchingRules")].isNull() && m_matching_rules_isValid;

    m_max_allowed_rule_level_for_merging_isValid = ::OpenAPI::fromJsonValue(m_max_allowed_rule_level_for_merging, json[QString("MaxAllowedRuleLevelForMerging")]);
    m_max_allowed_rule_level_for_merging_isSet = !json[QString("MaxAllowedRuleLevelForMerging")].isNull() && m_max_allowed_rule_level_for_merging_isValid;

    m_max_allowed_rule_level_for_matching_isValid = ::OpenAPI::fromJsonValue(m_max_allowed_rule_level_for_matching, json[QString("MaxAllowedRuleLevelForMatching")]);
    m_max_allowed_rule_level_for_matching_isSet = !json[QString("MaxAllowedRuleLevelForMatching")].isNull() && m_max_allowed_rule_level_for_matching_isValid;

    m_attribute_types_selector_isValid = ::OpenAPI::fromJsonValue(m_attribute_types_selector, json[QString("AttributeTypesSelector")]);
    m_attribute_types_selector_isSet = !json[QString("AttributeTypesSelector")].isNull() && m_attribute_types_selector_isValid;

    m_conflict_resolution_isValid = ::OpenAPI::fromJsonValue(m_conflict_resolution, json[QString("ConflictResolution")]);
    m_conflict_resolution_isSet = !json[QString("ConflictResolution")].isNull() && m_conflict_resolution_isValid;

    m_exporting_config_isValid = ::OpenAPI::fromJsonValue(m_exporting_config, json[QString("ExportingConfig")]);
    m_exporting_config_isSet = !json[QString("ExportingConfig")].isNull() && m_exporting_config_isValid;
}

QString OAIUpdateDomainRequest_RuleBasedMatching::asJson() const {
    QJsonObject obj = this->asJsonObject();
    QJsonDocument doc(obj);
    QByteArray bytes = doc.toJson();
    return QString(bytes);
}

QJsonObject OAIUpdateDomainRequest_RuleBasedMatching::asJsonObject() const {
    QJsonObject obj;
    if (m_enabled_isSet) {
        obj.insert(QString("Enabled"), ::OpenAPI::toJsonValue(m_enabled));
    }
    if (m_matching_rules.isSet()) {
        obj.insert(QString("MatchingRules"), ::OpenAPI::toJsonValue(m_matching_rules));
    }
    if (m_max_allowed_rule_level_for_merging_isSet) {
        obj.insert(QString("MaxAllowedRuleLevelForMerging"), ::OpenAPI::toJsonValue(m_max_allowed_rule_level_for_merging));
    }
    if (m_max_allowed_rule_level_for_matching_isSet) {
        obj.insert(QString("MaxAllowedRuleLevelForMatching"), ::OpenAPI::toJsonValue(m_max_allowed_rule_level_for_matching));
    }
    if (m_attribute_types_selector.isSet()) {
        obj.insert(QString("AttributeTypesSelector"), ::OpenAPI::toJsonValue(m_attribute_types_selector));
    }
    if (m_conflict_resolution.isSet()) {
        obj.insert(QString("ConflictResolution"), ::OpenAPI::toJsonValue(m_conflict_resolution));
    }
    if (m_exporting_config.isSet()) {
        obj.insert(QString("ExportingConfig"), ::OpenAPI::toJsonValue(m_exporting_config));
    }
    return obj;
}

bool OAIUpdateDomainRequest_RuleBasedMatching::getEnabled() const {
    return m_enabled;
}
void OAIUpdateDomainRequest_RuleBasedMatching::setEnabled(const bool &enabled) {
    m_enabled = enabled;
    m_enabled_isSet = true;
}

bool OAIUpdateDomainRequest_RuleBasedMatching::is_enabled_Set() const{
    return m_enabled_isSet;
}

bool OAIUpdateDomainRequest_RuleBasedMatching::is_enabled_Valid() const{
    return m_enabled_isValid;
}

QList OAIUpdateDomainRequest_RuleBasedMatching::getMatchingRules() const {
    return m_matching_rules;
}
void OAIUpdateDomainRequest_RuleBasedMatching::setMatchingRules(const QList &matching_rules) {
    m_matching_rules = matching_rules;
    m_matching_rules_isSet = true;
}

bool OAIUpdateDomainRequest_RuleBasedMatching::is_matching_rules_Set() const{
    return m_matching_rules_isSet;
}

bool OAIUpdateDomainRequest_RuleBasedMatching::is_matching_rules_Valid() const{
    return m_matching_rules_isValid;
}

qint32 OAIUpdateDomainRequest_RuleBasedMatching::getMaxAllowedRuleLevelForMerging() const {
    return m_max_allowed_rule_level_for_merging;
}
void OAIUpdateDomainRequest_RuleBasedMatching::setMaxAllowedRuleLevelForMerging(const qint32 &max_allowed_rule_level_for_merging) {
    m_max_allowed_rule_level_for_merging = max_allowed_rule_level_for_merging;
    m_max_allowed_rule_level_for_merging_isSet = true;
}

bool OAIUpdateDomainRequest_RuleBasedMatching::is_max_allowed_rule_level_for_merging_Set() const{
    return m_max_allowed_rule_level_for_merging_isSet;
}

bool OAIUpdateDomainRequest_RuleBasedMatching::is_max_allowed_rule_level_for_merging_Valid() const{
    return m_max_allowed_rule_level_for_merging_isValid;
}

qint32 OAIUpdateDomainRequest_RuleBasedMatching::getMaxAllowedRuleLevelForMatching() const {
    return m_max_allowed_rule_level_for_matching;
}
void OAIUpdateDomainRequest_RuleBasedMatching::setMaxAllowedRuleLevelForMatching(const qint32 &max_allowed_rule_level_for_matching) {
    m_max_allowed_rule_level_for_matching = max_allowed_rule_level_for_matching;
    m_max_allowed_rule_level_for_matching_isSet = true;
}

bool OAIUpdateDomainRequest_RuleBasedMatching::is_max_allowed_rule_level_for_matching_Set() const{
    return m_max_allowed_rule_level_for_matching_isSet;
}

bool OAIUpdateDomainRequest_RuleBasedMatching::is_max_allowed_rule_level_for_matching_Valid() const{
    return m_max_allowed_rule_level_for_matching_isValid;
}

OAIUpdateDomain_request_RuleBasedMatching_AttributeTypesSelector OAIUpdateDomainRequest_RuleBasedMatching::getAttributeTypesSelector() const {
    return m_attribute_types_selector;
}
void OAIUpdateDomainRequest_RuleBasedMatching::setAttributeTypesSelector(const OAIUpdateDomain_request_RuleBasedMatching_AttributeTypesSelector &attribute_types_selector) {
    m_attribute_types_selector = attribute_types_selector;
    m_attribute_types_selector_isSet = true;
}

bool OAIUpdateDomainRequest_RuleBasedMatching::is_attribute_types_selector_Set() const{
    return m_attribute_types_selector_isSet;
}

bool OAIUpdateDomainRequest_RuleBasedMatching::is_attribute_types_selector_Valid() const{
    return m_attribute_types_selector_isValid;
}

OAIConflictResolution OAIUpdateDomainRequest_RuleBasedMatching::getConflictResolution() const {
    return m_conflict_resolution;
}
void OAIUpdateDomainRequest_RuleBasedMatching::setConflictResolution(const OAIConflictResolution &conflict_resolution) {
    m_conflict_resolution = conflict_resolution;
    m_conflict_resolution_isSet = true;
}

bool OAIUpdateDomainRequest_RuleBasedMatching::is_conflict_resolution_Set() const{
    return m_conflict_resolution_isSet;
}

bool OAIUpdateDomainRequest_RuleBasedMatching::is_conflict_resolution_Valid() const{
    return m_conflict_resolution_isValid;
}

OAIExportingConfig OAIUpdateDomainRequest_RuleBasedMatching::getExportingConfig() const {
    return m_exporting_config;
}
void OAIUpdateDomainRequest_RuleBasedMatching::setExportingConfig(const OAIExportingConfig &exporting_config) {
    m_exporting_config = exporting_config;
    m_exporting_config_isSet = true;
}

bool OAIUpdateDomainRequest_RuleBasedMatching::is_exporting_config_Set() const{
    return m_exporting_config_isSet;
}

bool OAIUpdateDomainRequest_RuleBasedMatching::is_exporting_config_Valid() const{
    return m_exporting_config_isValid;
}

bool OAIUpdateDomainRequest_RuleBasedMatching::isSet() const {
    bool isObjectUpdated = false;
    do {
        if (m_enabled_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_matching_rules.isSet()) {
            isObjectUpdated = true;
            break;
        }

        if (m_max_allowed_rule_level_for_merging_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_max_allowed_rule_level_for_matching_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_attribute_types_selector.isSet()) {
            isObjectUpdated = true;
            break;
        }

        if (m_conflict_resolution.isSet()) {
            isObjectUpdated = true;
            break;
        }

        if (m_exporting_config.isSet()) {
            isObjectUpdated = true;
            break;
        }
    } while (false);
    return isObjectUpdated;
}

bool OAIUpdateDomainRequest_RuleBasedMatching::isValid() const {
    // only required properties are required for the object to be considered valid
    return m_enabled_isValid && true;
}

} // namespace OpenAPI
