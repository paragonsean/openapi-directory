/**
 * AWS Clean Rooms Service
 * <p>Welcome to the <i>Clean Rooms API Reference</i>.</p> <p>Clean Rooms is an Amazon Web Services service that helps multiple parties to join their data together in a secure collaboration workspace. In the collaboration, members who can query and receive results can get insights into the collective datasets without either party getting access to the other party's raw data.</p> <p>To learn more about Clean Rooms concepts, procedures, and best practices, see the <a href=\"https://docs.aws.amazon.com/clean-rooms/latest/userguide/what-is.html\">Clean Rooms User Guide</a>.</p>
 *
 * The version of the OpenAPI document: 2022-02-17
 * Contact: mike.ralphson@gmail.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

#include "OAICollaboration_dataEncryptionMetadata.h"

#include <QDebug>
#include <QJsonArray>
#include <QJsonDocument>
#include <QObject>

#include "OAIHelpers.h"

namespace OpenAPI {

OAICollaboration_dataEncryptionMetadata::OAICollaboration_dataEncryptionMetadata(QString json) {
    this->initializeModel();
    this->fromJson(json);
}

OAICollaboration_dataEncryptionMetadata::OAICollaboration_dataEncryptionMetadata() {
    this->initializeModel();
}

OAICollaboration_dataEncryptionMetadata::~OAICollaboration_dataEncryptionMetadata() {}

void OAICollaboration_dataEncryptionMetadata::initializeModel() {

    m_allow_cleartext_isSet = false;
    m_allow_cleartext_isValid = false;

    m_allow_duplicates_isSet = false;
    m_allow_duplicates_isValid = false;

    m_allow_joins_on_columns_with_different_names_isSet = false;
    m_allow_joins_on_columns_with_different_names_isValid = false;

    m_preserve_nulls_isSet = false;
    m_preserve_nulls_isValid = false;
}

void OAICollaboration_dataEncryptionMetadata::fromJson(QString jsonString) {
    QByteArray array(jsonString.toStdString().c_str());
    QJsonDocument doc = QJsonDocument::fromJson(array);
    QJsonObject jsonObject = doc.object();
    this->fromJsonObject(jsonObject);
}

void OAICollaboration_dataEncryptionMetadata::fromJsonObject(QJsonObject json) {

    m_allow_cleartext_isValid = ::OpenAPI::fromJsonValue(m_allow_cleartext, json[QString("allowCleartext")]);
    m_allow_cleartext_isSet = !json[QString("allowCleartext")].isNull() && m_allow_cleartext_isValid;

    m_allow_duplicates_isValid = ::OpenAPI::fromJsonValue(m_allow_duplicates, json[QString("allowDuplicates")]);
    m_allow_duplicates_isSet = !json[QString("allowDuplicates")].isNull() && m_allow_duplicates_isValid;

    m_allow_joins_on_columns_with_different_names_isValid = ::OpenAPI::fromJsonValue(m_allow_joins_on_columns_with_different_names, json[QString("allowJoinsOnColumnsWithDifferentNames")]);
    m_allow_joins_on_columns_with_different_names_isSet = !json[QString("allowJoinsOnColumnsWithDifferentNames")].isNull() && m_allow_joins_on_columns_with_different_names_isValid;

    m_preserve_nulls_isValid = ::OpenAPI::fromJsonValue(m_preserve_nulls, json[QString("preserveNulls")]);
    m_preserve_nulls_isSet = !json[QString("preserveNulls")].isNull() && m_preserve_nulls_isValid;
}

QString OAICollaboration_dataEncryptionMetadata::asJson() const {
    QJsonObject obj = this->asJsonObject();
    QJsonDocument doc(obj);
    QByteArray bytes = doc.toJson();
    return QString(bytes);
}

QJsonObject OAICollaboration_dataEncryptionMetadata::asJsonObject() const {
    QJsonObject obj;
    if (m_allow_cleartext_isSet) {
        obj.insert(QString("allowCleartext"), ::OpenAPI::toJsonValue(m_allow_cleartext));
    }
    if (m_allow_duplicates_isSet) {
        obj.insert(QString("allowDuplicates"), ::OpenAPI::toJsonValue(m_allow_duplicates));
    }
    if (m_allow_joins_on_columns_with_different_names_isSet) {
        obj.insert(QString("allowJoinsOnColumnsWithDifferentNames"), ::OpenAPI::toJsonValue(m_allow_joins_on_columns_with_different_names));
    }
    if (m_preserve_nulls_isSet) {
        obj.insert(QString("preserveNulls"), ::OpenAPI::toJsonValue(m_preserve_nulls));
    }
    return obj;
}

bool OAICollaboration_dataEncryptionMetadata::getAllowCleartext() const {
    return m_allow_cleartext;
}
void OAICollaboration_dataEncryptionMetadata::setAllowCleartext(const bool &allow_cleartext) {
    m_allow_cleartext = allow_cleartext;
    m_allow_cleartext_isSet = true;
}

bool OAICollaboration_dataEncryptionMetadata::is_allow_cleartext_Set() const{
    return m_allow_cleartext_isSet;
}

bool OAICollaboration_dataEncryptionMetadata::is_allow_cleartext_Valid() const{
    return m_allow_cleartext_isValid;
}

bool OAICollaboration_dataEncryptionMetadata::getAllowDuplicates() const {
    return m_allow_duplicates;
}
void OAICollaboration_dataEncryptionMetadata::setAllowDuplicates(const bool &allow_duplicates) {
    m_allow_duplicates = allow_duplicates;
    m_allow_duplicates_isSet = true;
}

bool OAICollaboration_dataEncryptionMetadata::is_allow_duplicates_Set() const{
    return m_allow_duplicates_isSet;
}

bool OAICollaboration_dataEncryptionMetadata::is_allow_duplicates_Valid() const{
    return m_allow_duplicates_isValid;
}

bool OAICollaboration_dataEncryptionMetadata::getAllowJoinsOnColumnsWithDifferentNames() const {
    return m_allow_joins_on_columns_with_different_names;
}
void OAICollaboration_dataEncryptionMetadata::setAllowJoinsOnColumnsWithDifferentNames(const bool &allow_joins_on_columns_with_different_names) {
    m_allow_joins_on_columns_with_different_names = allow_joins_on_columns_with_different_names;
    m_allow_joins_on_columns_with_different_names_isSet = true;
}

bool OAICollaboration_dataEncryptionMetadata::is_allow_joins_on_columns_with_different_names_Set() const{
    return m_allow_joins_on_columns_with_different_names_isSet;
}

bool OAICollaboration_dataEncryptionMetadata::is_allow_joins_on_columns_with_different_names_Valid() const{
    return m_allow_joins_on_columns_with_different_names_isValid;
}

bool OAICollaboration_dataEncryptionMetadata::getPreserveNulls() const {
    return m_preserve_nulls;
}
void OAICollaboration_dataEncryptionMetadata::setPreserveNulls(const bool &preserve_nulls) {
    m_preserve_nulls = preserve_nulls;
    m_preserve_nulls_isSet = true;
}

bool OAICollaboration_dataEncryptionMetadata::is_preserve_nulls_Set() const{
    return m_preserve_nulls_isSet;
}

bool OAICollaboration_dataEncryptionMetadata::is_preserve_nulls_Valid() const{
    return m_preserve_nulls_isValid;
}

bool OAICollaboration_dataEncryptionMetadata::isSet() const {
    bool isObjectUpdated = false;
    do {
        if (m_allow_cleartext_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_allow_duplicates_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_allow_joins_on_columns_with_different_names_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_preserve_nulls_isSet) {
            isObjectUpdated = true;
            break;
        }
    } while (false);
    return isObjectUpdated;
}

bool OAICollaboration_dataEncryptionMetadata::isValid() const {
    // only required properties are required for the object to be considered valid
    return m_allow_cleartext_isValid && m_allow_duplicates_isValid && m_allow_joins_on_columns_with_different_names_isValid && m_preserve_nulls_isValid && true;
}

} // namespace OpenAPI
