/**
 * AWS Clean Rooms Service
 * <p>Welcome to the <i>Clean Rooms API Reference</i>.</p> <p>Clean Rooms is an Amazon Web Services service that helps multiple parties to join their data together in a secure collaboration workspace. In the collaboration, members who can query and receive results can get insights into the collective datasets without either party getting access to the other party's raw data.</p> <p>To learn more about Clean Rooms concepts, procedures, and best practices, see the <a href=\"https://docs.aws.amazon.com/clean-rooms/latest/userguide/what-is.html\">Clean Rooms User Guide</a>.</p>
 *
 * The version of the OpenAPI document: 2022-02-17
 * Contact: mike.ralphson@gmail.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

#include "OAICreateConfiguredTable_request.h"

#include <QDebug>
#include <QJsonArray>
#include <QJsonDocument>
#include <QObject>

#include "OAIHelpers.h"

namespace OpenAPI {

OAICreateConfiguredTable_request::OAICreateConfiguredTable_request(QString json) {
    this->initializeModel();
    this->fromJson(json);
}

OAICreateConfiguredTable_request::OAICreateConfiguredTable_request() {
    this->initializeModel();
}

OAICreateConfiguredTable_request::~OAICreateConfiguredTable_request() {}

void OAICreateConfiguredTable_request::initializeModel() {

    m_name_isSet = false;
    m_name_isValid = false;

    m_description_isSet = false;
    m_description_isValid = false;

    m_table_reference_isSet = false;
    m_table_reference_isValid = false;

    m_allowed_columns_isSet = false;
    m_allowed_columns_isValid = false;

    m_analysis_method_isSet = false;
    m_analysis_method_isValid = false;

    m_tags_isSet = false;
    m_tags_isValid = false;
}

void OAICreateConfiguredTable_request::fromJson(QString jsonString) {
    QByteArray array(jsonString.toStdString().c_str());
    QJsonDocument doc = QJsonDocument::fromJson(array);
    QJsonObject jsonObject = doc.object();
    this->fromJsonObject(jsonObject);
}

void OAICreateConfiguredTable_request::fromJsonObject(QJsonObject json) {

    m_name_isValid = ::OpenAPI::fromJsonValue(m_name, json[QString("name")]);
    m_name_isSet = !json[QString("name")].isNull() && m_name_isValid;

    m_description_isValid = ::OpenAPI::fromJsonValue(m_description, json[QString("description")]);
    m_description_isSet = !json[QString("description")].isNull() && m_description_isValid;

    m_table_reference_isValid = ::OpenAPI::fromJsonValue(m_table_reference, json[QString("tableReference")]);
    m_table_reference_isSet = !json[QString("tableReference")].isNull() && m_table_reference_isValid;

    m_allowed_columns_isValid = ::OpenAPI::fromJsonValue(m_allowed_columns, json[QString("allowedColumns")]);
    m_allowed_columns_isSet = !json[QString("allowedColumns")].isNull() && m_allowed_columns_isValid;

    m_analysis_method_isValid = ::OpenAPI::fromJsonValue(m_analysis_method, json[QString("analysisMethod")]);
    m_analysis_method_isSet = !json[QString("analysisMethod")].isNull() && m_analysis_method_isValid;

    m_tags_isValid = ::OpenAPI::fromJsonValue(m_tags, json[QString("tags")]);
    m_tags_isSet = !json[QString("tags")].isNull() && m_tags_isValid;
}

QString OAICreateConfiguredTable_request::asJson() const {
    QJsonObject obj = this->asJsonObject();
    QJsonDocument doc(obj);
    QByteArray bytes = doc.toJson();
    return QString(bytes);
}

QJsonObject OAICreateConfiguredTable_request::asJsonObject() const {
    QJsonObject obj;
    if (m_name_isSet) {
        obj.insert(QString("name"), ::OpenAPI::toJsonValue(m_name));
    }
    if (m_description_isSet) {
        obj.insert(QString("description"), ::OpenAPI::toJsonValue(m_description));
    }
    if (m_table_reference.isSet()) {
        obj.insert(QString("tableReference"), ::OpenAPI::toJsonValue(m_table_reference));
    }
    if (m_allowed_columns.size() > 0) {
        obj.insert(QString("allowedColumns"), ::OpenAPI::toJsonValue(m_allowed_columns));
    }
    if (m_analysis_method_isSet) {
        obj.insert(QString("analysisMethod"), ::OpenAPI::toJsonValue(m_analysis_method));
    }
    if (m_tags.size() > 0) {
        obj.insert(QString("tags"), ::OpenAPI::toJsonValue(m_tags));
    }
    return obj;
}

QString OAICreateConfiguredTable_request::getName() const {
    return m_name;
}
void OAICreateConfiguredTable_request::setName(const QString &name) {
    m_name = name;
    m_name_isSet = true;
}

bool OAICreateConfiguredTable_request::is_name_Set() const{
    return m_name_isSet;
}

bool OAICreateConfiguredTable_request::is_name_Valid() const{
    return m_name_isValid;
}

QString OAICreateConfiguredTable_request::getDescription() const {
    return m_description;
}
void OAICreateConfiguredTable_request::setDescription(const QString &description) {
    m_description = description;
    m_description_isSet = true;
}

bool OAICreateConfiguredTable_request::is_description_Set() const{
    return m_description_isSet;
}

bool OAICreateConfiguredTable_request::is_description_Valid() const{
    return m_description_isValid;
}

OAICreateConfiguredTable_request_tableReference OAICreateConfiguredTable_request::getTableReference() const {
    return m_table_reference;
}
void OAICreateConfiguredTable_request::setTableReference(const OAICreateConfiguredTable_request_tableReference &table_reference) {
    m_table_reference = table_reference;
    m_table_reference_isSet = true;
}

bool OAICreateConfiguredTable_request::is_table_reference_Set() const{
    return m_table_reference_isSet;
}

bool OAICreateConfiguredTable_request::is_table_reference_Valid() const{
    return m_table_reference_isValid;
}

QList<QString> OAICreateConfiguredTable_request::getAllowedColumns() const {
    return m_allowed_columns;
}
void OAICreateConfiguredTable_request::setAllowedColumns(const QList<QString> &allowed_columns) {
    m_allowed_columns = allowed_columns;
    m_allowed_columns_isSet = true;
}

bool OAICreateConfiguredTable_request::is_allowed_columns_Set() const{
    return m_allowed_columns_isSet;
}

bool OAICreateConfiguredTable_request::is_allowed_columns_Valid() const{
    return m_allowed_columns_isValid;
}

QString OAICreateConfiguredTable_request::getAnalysisMethod() const {
    return m_analysis_method;
}
void OAICreateConfiguredTable_request::setAnalysisMethod(const QString &analysis_method) {
    m_analysis_method = analysis_method;
    m_analysis_method_isSet = true;
}

bool OAICreateConfiguredTable_request::is_analysis_method_Set() const{
    return m_analysis_method_isSet;
}

bool OAICreateConfiguredTable_request::is_analysis_method_Valid() const{
    return m_analysis_method_isValid;
}

QMap<QString, QString> OAICreateConfiguredTable_request::getTags() const {
    return m_tags;
}
void OAICreateConfiguredTable_request::setTags(const QMap<QString, QString> &tags) {
    m_tags = tags;
    m_tags_isSet = true;
}

bool OAICreateConfiguredTable_request::is_tags_Set() const{
    return m_tags_isSet;
}

bool OAICreateConfiguredTable_request::is_tags_Valid() const{
    return m_tags_isValid;
}

bool OAICreateConfiguredTable_request::isSet() const {
    bool isObjectUpdated = false;
    do {
        if (m_name_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_description_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_table_reference.isSet()) {
            isObjectUpdated = true;
            break;
        }

        if (m_allowed_columns.size() > 0) {
            isObjectUpdated = true;
            break;
        }

        if (m_analysis_method_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_tags.size() > 0) {
            isObjectUpdated = true;
            break;
        }
    } while (false);
    return isObjectUpdated;
}

bool OAICreateConfiguredTable_request::isValid() const {
    // only required properties are required for the object to be considered valid
    return m_name_isValid && m_table_reference_isValid && m_allowed_columns_isValid && m_analysis_method_isValid && true;
}

} // namespace OpenAPI
