/**
 * AWS Glue
 * <fullname>Glue</fullname> <p>Defines the public endpoint for the Glue service.</p>
 *
 * The version of the OpenAPI document: 2017-03-31
 * Contact: mike.ralphson@gmail.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

#include "OAICatalogKafkaSource_StreamingOptions.h"

#include <QDebug>
#include <QJsonArray>
#include <QJsonDocument>
#include <QObject>

#include "OAIHelpers.h"

namespace OpenAPI {

OAICatalogKafkaSource_StreamingOptions::OAICatalogKafkaSource_StreamingOptions(QString json) {
    this->initializeModel();
    this->fromJson(json);
}

OAICatalogKafkaSource_StreamingOptions::OAICatalogKafkaSource_StreamingOptions() {
    this->initializeModel();
}

OAICatalogKafkaSource_StreamingOptions::~OAICatalogKafkaSource_StreamingOptions() {}

void OAICatalogKafkaSource_StreamingOptions::initializeModel() {

    m_bootstrap_servers_isSet = false;
    m_bootstrap_servers_isValid = false;

    m_security_protocol_isSet = false;
    m_security_protocol_isValid = false;

    m_connection_name_isSet = false;
    m_connection_name_isValid = false;

    m_topic_name_isSet = false;
    m_topic_name_isValid = false;

    m_assign_isSet = false;
    m_assign_isValid = false;

    m_subscribe_pattern_isSet = false;
    m_subscribe_pattern_isValid = false;

    m_classification_isSet = false;
    m_classification_isValid = false;

    m_delimiter_isSet = false;
    m_delimiter_isValid = false;

    m_starting_offsets_isSet = false;
    m_starting_offsets_isValid = false;

    m_ending_offsets_isSet = false;
    m_ending_offsets_isValid = false;

    m_poll_timeout_ms_isSet = false;
    m_poll_timeout_ms_isValid = false;

    m_num_retries_isSet = false;
    m_num_retries_isValid = false;

    m_retry_interval_ms_isSet = false;
    m_retry_interval_ms_isValid = false;

    m_max_offsets_per_trigger_isSet = false;
    m_max_offsets_per_trigger_isValid = false;

    m_min_partitions_isSet = false;
    m_min_partitions_isValid = false;

    m_include_headers_isSet = false;
    m_include_headers_isValid = false;

    m_add_record_timestamp_isSet = false;
    m_add_record_timestamp_isValid = false;

    m_emit_consumer_lag_metrics_isSet = false;
    m_emit_consumer_lag_metrics_isValid = false;

    m_starting_timestamp_isSet = false;
    m_starting_timestamp_isValid = false;
}

void OAICatalogKafkaSource_StreamingOptions::fromJson(QString jsonString) {
    QByteArray array(jsonString.toStdString().c_str());
    QJsonDocument doc = QJsonDocument::fromJson(array);
    QJsonObject jsonObject = doc.object();
    this->fromJsonObject(jsonObject);
}

void OAICatalogKafkaSource_StreamingOptions::fromJsonObject(QJsonObject json) {

    m_bootstrap_servers_isValid = ::OpenAPI::fromJsonValue(m_bootstrap_servers, json[QString("BootstrapServers")]);
    m_bootstrap_servers_isSet = !json[QString("BootstrapServers")].isNull() && m_bootstrap_servers_isValid;

    m_security_protocol_isValid = ::OpenAPI::fromJsonValue(m_security_protocol, json[QString("SecurityProtocol")]);
    m_security_protocol_isSet = !json[QString("SecurityProtocol")].isNull() && m_security_protocol_isValid;

    m_connection_name_isValid = ::OpenAPI::fromJsonValue(m_connection_name, json[QString("ConnectionName")]);
    m_connection_name_isSet = !json[QString("ConnectionName")].isNull() && m_connection_name_isValid;

    m_topic_name_isValid = ::OpenAPI::fromJsonValue(m_topic_name, json[QString("TopicName")]);
    m_topic_name_isSet = !json[QString("TopicName")].isNull() && m_topic_name_isValid;

    m_assign_isValid = ::OpenAPI::fromJsonValue(m_assign, json[QString("Assign")]);
    m_assign_isSet = !json[QString("Assign")].isNull() && m_assign_isValid;

    m_subscribe_pattern_isValid = ::OpenAPI::fromJsonValue(m_subscribe_pattern, json[QString("SubscribePattern")]);
    m_subscribe_pattern_isSet = !json[QString("SubscribePattern")].isNull() && m_subscribe_pattern_isValid;

    m_classification_isValid = ::OpenAPI::fromJsonValue(m_classification, json[QString("Classification")]);
    m_classification_isSet = !json[QString("Classification")].isNull() && m_classification_isValid;

    m_delimiter_isValid = ::OpenAPI::fromJsonValue(m_delimiter, json[QString("Delimiter")]);
    m_delimiter_isSet = !json[QString("Delimiter")].isNull() && m_delimiter_isValid;

    m_starting_offsets_isValid = ::OpenAPI::fromJsonValue(m_starting_offsets, json[QString("StartingOffsets")]);
    m_starting_offsets_isSet = !json[QString("StartingOffsets")].isNull() && m_starting_offsets_isValid;

    m_ending_offsets_isValid = ::OpenAPI::fromJsonValue(m_ending_offsets, json[QString("EndingOffsets")]);
    m_ending_offsets_isSet = !json[QString("EndingOffsets")].isNull() && m_ending_offsets_isValid;

    m_poll_timeout_ms_isValid = ::OpenAPI::fromJsonValue(m_poll_timeout_ms, json[QString("PollTimeoutMs")]);
    m_poll_timeout_ms_isSet = !json[QString("PollTimeoutMs")].isNull() && m_poll_timeout_ms_isValid;

    m_num_retries_isValid = ::OpenAPI::fromJsonValue(m_num_retries, json[QString("NumRetries")]);
    m_num_retries_isSet = !json[QString("NumRetries")].isNull() && m_num_retries_isValid;

    m_retry_interval_ms_isValid = ::OpenAPI::fromJsonValue(m_retry_interval_ms, json[QString("RetryIntervalMs")]);
    m_retry_interval_ms_isSet = !json[QString("RetryIntervalMs")].isNull() && m_retry_interval_ms_isValid;

    m_max_offsets_per_trigger_isValid = ::OpenAPI::fromJsonValue(m_max_offsets_per_trigger, json[QString("MaxOffsetsPerTrigger")]);
    m_max_offsets_per_trigger_isSet = !json[QString("MaxOffsetsPerTrigger")].isNull() && m_max_offsets_per_trigger_isValid;

    m_min_partitions_isValid = ::OpenAPI::fromJsonValue(m_min_partitions, json[QString("MinPartitions")]);
    m_min_partitions_isSet = !json[QString("MinPartitions")].isNull() && m_min_partitions_isValid;

    m_include_headers_isValid = ::OpenAPI::fromJsonValue(m_include_headers, json[QString("IncludeHeaders")]);
    m_include_headers_isSet = !json[QString("IncludeHeaders")].isNull() && m_include_headers_isValid;

    m_add_record_timestamp_isValid = ::OpenAPI::fromJsonValue(m_add_record_timestamp, json[QString("AddRecordTimestamp")]);
    m_add_record_timestamp_isSet = !json[QString("AddRecordTimestamp")].isNull() && m_add_record_timestamp_isValid;

    m_emit_consumer_lag_metrics_isValid = ::OpenAPI::fromJsonValue(m_emit_consumer_lag_metrics, json[QString("EmitConsumerLagMetrics")]);
    m_emit_consumer_lag_metrics_isSet = !json[QString("EmitConsumerLagMetrics")].isNull() && m_emit_consumer_lag_metrics_isValid;

    m_starting_timestamp_isValid = ::OpenAPI::fromJsonValue(m_starting_timestamp, json[QString("StartingTimestamp")]);
    m_starting_timestamp_isSet = !json[QString("StartingTimestamp")].isNull() && m_starting_timestamp_isValid;
}

QString OAICatalogKafkaSource_StreamingOptions::asJson() const {
    QJsonObject obj = this->asJsonObject();
    QJsonDocument doc(obj);
    QByteArray bytes = doc.toJson();
    return QString(bytes);
}

QJsonObject OAICatalogKafkaSource_StreamingOptions::asJsonObject() const {
    QJsonObject obj;
    if (m_bootstrap_servers_isSet) {
        obj.insert(QString("BootstrapServers"), ::OpenAPI::toJsonValue(m_bootstrap_servers));
    }
    if (m_security_protocol_isSet) {
        obj.insert(QString("SecurityProtocol"), ::OpenAPI::toJsonValue(m_security_protocol));
    }
    if (m_connection_name_isSet) {
        obj.insert(QString("ConnectionName"), ::OpenAPI::toJsonValue(m_connection_name));
    }
    if (m_topic_name_isSet) {
        obj.insert(QString("TopicName"), ::OpenAPI::toJsonValue(m_topic_name));
    }
    if (m_assign_isSet) {
        obj.insert(QString("Assign"), ::OpenAPI::toJsonValue(m_assign));
    }
    if (m_subscribe_pattern_isSet) {
        obj.insert(QString("SubscribePattern"), ::OpenAPI::toJsonValue(m_subscribe_pattern));
    }
    if (m_classification_isSet) {
        obj.insert(QString("Classification"), ::OpenAPI::toJsonValue(m_classification));
    }
    if (m_delimiter_isSet) {
        obj.insert(QString("Delimiter"), ::OpenAPI::toJsonValue(m_delimiter));
    }
    if (m_starting_offsets_isSet) {
        obj.insert(QString("StartingOffsets"), ::OpenAPI::toJsonValue(m_starting_offsets));
    }
    if (m_ending_offsets_isSet) {
        obj.insert(QString("EndingOffsets"), ::OpenAPI::toJsonValue(m_ending_offsets));
    }
    if (m_poll_timeout_ms_isSet) {
        obj.insert(QString("PollTimeoutMs"), ::OpenAPI::toJsonValue(m_poll_timeout_ms));
    }
    if (m_num_retries_isSet) {
        obj.insert(QString("NumRetries"), ::OpenAPI::toJsonValue(m_num_retries));
    }
    if (m_retry_interval_ms_isSet) {
        obj.insert(QString("RetryIntervalMs"), ::OpenAPI::toJsonValue(m_retry_interval_ms));
    }
    if (m_max_offsets_per_trigger_isSet) {
        obj.insert(QString("MaxOffsetsPerTrigger"), ::OpenAPI::toJsonValue(m_max_offsets_per_trigger));
    }
    if (m_min_partitions_isSet) {
        obj.insert(QString("MinPartitions"), ::OpenAPI::toJsonValue(m_min_partitions));
    }
    if (m_include_headers_isSet) {
        obj.insert(QString("IncludeHeaders"), ::OpenAPI::toJsonValue(m_include_headers));
    }
    if (m_add_record_timestamp_isSet) {
        obj.insert(QString("AddRecordTimestamp"), ::OpenAPI::toJsonValue(m_add_record_timestamp));
    }
    if (m_emit_consumer_lag_metrics_isSet) {
        obj.insert(QString("EmitConsumerLagMetrics"), ::OpenAPI::toJsonValue(m_emit_consumer_lag_metrics));
    }
    if (m_starting_timestamp_isSet) {
        obj.insert(QString("StartingTimestamp"), ::OpenAPI::toJsonValue(m_starting_timestamp));
    }
    return obj;
}

QString OAICatalogKafkaSource_StreamingOptions::getBootstrapServers() const {
    return m_bootstrap_servers;
}
void OAICatalogKafkaSource_StreamingOptions::setBootstrapServers(const QString &bootstrap_servers) {
    m_bootstrap_servers = bootstrap_servers;
    m_bootstrap_servers_isSet = true;
}

bool OAICatalogKafkaSource_StreamingOptions::is_bootstrap_servers_Set() const{
    return m_bootstrap_servers_isSet;
}

bool OAICatalogKafkaSource_StreamingOptions::is_bootstrap_servers_Valid() const{
    return m_bootstrap_servers_isValid;
}

QString OAICatalogKafkaSource_StreamingOptions::getSecurityProtocol() const {
    return m_security_protocol;
}
void OAICatalogKafkaSource_StreamingOptions::setSecurityProtocol(const QString &security_protocol) {
    m_security_protocol = security_protocol;
    m_security_protocol_isSet = true;
}

bool OAICatalogKafkaSource_StreamingOptions::is_security_protocol_Set() const{
    return m_security_protocol_isSet;
}

bool OAICatalogKafkaSource_StreamingOptions::is_security_protocol_Valid() const{
    return m_security_protocol_isValid;
}

QString OAICatalogKafkaSource_StreamingOptions::getConnectionName() const {
    return m_connection_name;
}
void OAICatalogKafkaSource_StreamingOptions::setConnectionName(const QString &connection_name) {
    m_connection_name = connection_name;
    m_connection_name_isSet = true;
}

bool OAICatalogKafkaSource_StreamingOptions::is_connection_name_Set() const{
    return m_connection_name_isSet;
}

bool OAICatalogKafkaSource_StreamingOptions::is_connection_name_Valid() const{
    return m_connection_name_isValid;
}

QString OAICatalogKafkaSource_StreamingOptions::getTopicName() const {
    return m_topic_name;
}
void OAICatalogKafkaSource_StreamingOptions::setTopicName(const QString &topic_name) {
    m_topic_name = topic_name;
    m_topic_name_isSet = true;
}

bool OAICatalogKafkaSource_StreamingOptions::is_topic_name_Set() const{
    return m_topic_name_isSet;
}

bool OAICatalogKafkaSource_StreamingOptions::is_topic_name_Valid() const{
    return m_topic_name_isValid;
}

QString OAICatalogKafkaSource_StreamingOptions::getAssign() const {
    return m_assign;
}
void OAICatalogKafkaSource_StreamingOptions::setAssign(const QString &assign) {
    m_assign = assign;
    m_assign_isSet = true;
}

bool OAICatalogKafkaSource_StreamingOptions::is_assign_Set() const{
    return m_assign_isSet;
}

bool OAICatalogKafkaSource_StreamingOptions::is_assign_Valid() const{
    return m_assign_isValid;
}

QString OAICatalogKafkaSource_StreamingOptions::getSubscribePattern() const {
    return m_subscribe_pattern;
}
void OAICatalogKafkaSource_StreamingOptions::setSubscribePattern(const QString &subscribe_pattern) {
    m_subscribe_pattern = subscribe_pattern;
    m_subscribe_pattern_isSet = true;
}

bool OAICatalogKafkaSource_StreamingOptions::is_subscribe_pattern_Set() const{
    return m_subscribe_pattern_isSet;
}

bool OAICatalogKafkaSource_StreamingOptions::is_subscribe_pattern_Valid() const{
    return m_subscribe_pattern_isValid;
}

QString OAICatalogKafkaSource_StreamingOptions::getClassification() const {
    return m_classification;
}
void OAICatalogKafkaSource_StreamingOptions::setClassification(const QString &classification) {
    m_classification = classification;
    m_classification_isSet = true;
}

bool OAICatalogKafkaSource_StreamingOptions::is_classification_Set() const{
    return m_classification_isSet;
}

bool OAICatalogKafkaSource_StreamingOptions::is_classification_Valid() const{
    return m_classification_isValid;
}

QString OAICatalogKafkaSource_StreamingOptions::getDelimiter() const {
    return m_delimiter;
}
void OAICatalogKafkaSource_StreamingOptions::setDelimiter(const QString &delimiter) {
    m_delimiter = delimiter;
    m_delimiter_isSet = true;
}

bool OAICatalogKafkaSource_StreamingOptions::is_delimiter_Set() const{
    return m_delimiter_isSet;
}

bool OAICatalogKafkaSource_StreamingOptions::is_delimiter_Valid() const{
    return m_delimiter_isValid;
}

QString OAICatalogKafkaSource_StreamingOptions::getStartingOffsets() const {
    return m_starting_offsets;
}
void OAICatalogKafkaSource_StreamingOptions::setStartingOffsets(const QString &starting_offsets) {
    m_starting_offsets = starting_offsets;
    m_starting_offsets_isSet = true;
}

bool OAICatalogKafkaSource_StreamingOptions::is_starting_offsets_Set() const{
    return m_starting_offsets_isSet;
}

bool OAICatalogKafkaSource_StreamingOptions::is_starting_offsets_Valid() const{
    return m_starting_offsets_isValid;
}

QString OAICatalogKafkaSource_StreamingOptions::getEndingOffsets() const {
    return m_ending_offsets;
}
void OAICatalogKafkaSource_StreamingOptions::setEndingOffsets(const QString &ending_offsets) {
    m_ending_offsets = ending_offsets;
    m_ending_offsets_isSet = true;
}

bool OAICatalogKafkaSource_StreamingOptions::is_ending_offsets_Set() const{
    return m_ending_offsets_isSet;
}

bool OAICatalogKafkaSource_StreamingOptions::is_ending_offsets_Valid() const{
    return m_ending_offsets_isValid;
}

qint32 OAICatalogKafkaSource_StreamingOptions::getPollTimeoutMs() const {
    return m_poll_timeout_ms;
}
void OAICatalogKafkaSource_StreamingOptions::setPollTimeoutMs(const qint32 &poll_timeout_ms) {
    m_poll_timeout_ms = poll_timeout_ms;
    m_poll_timeout_ms_isSet = true;
}

bool OAICatalogKafkaSource_StreamingOptions::is_poll_timeout_ms_Set() const{
    return m_poll_timeout_ms_isSet;
}

bool OAICatalogKafkaSource_StreamingOptions::is_poll_timeout_ms_Valid() const{
    return m_poll_timeout_ms_isValid;
}

qint32 OAICatalogKafkaSource_StreamingOptions::getNumRetries() const {
    return m_num_retries;
}
void OAICatalogKafkaSource_StreamingOptions::setNumRetries(const qint32 &num_retries) {
    m_num_retries = num_retries;
    m_num_retries_isSet = true;
}

bool OAICatalogKafkaSource_StreamingOptions::is_num_retries_Set() const{
    return m_num_retries_isSet;
}

bool OAICatalogKafkaSource_StreamingOptions::is_num_retries_Valid() const{
    return m_num_retries_isValid;
}

qint32 OAICatalogKafkaSource_StreamingOptions::getRetryIntervalMs() const {
    return m_retry_interval_ms;
}
void OAICatalogKafkaSource_StreamingOptions::setRetryIntervalMs(const qint32 &retry_interval_ms) {
    m_retry_interval_ms = retry_interval_ms;
    m_retry_interval_ms_isSet = true;
}

bool OAICatalogKafkaSource_StreamingOptions::is_retry_interval_ms_Set() const{
    return m_retry_interval_ms_isSet;
}

bool OAICatalogKafkaSource_StreamingOptions::is_retry_interval_ms_Valid() const{
    return m_retry_interval_ms_isValid;
}

qint32 OAICatalogKafkaSource_StreamingOptions::getMaxOffsetsPerTrigger() const {
    return m_max_offsets_per_trigger;
}
void OAICatalogKafkaSource_StreamingOptions::setMaxOffsetsPerTrigger(const qint32 &max_offsets_per_trigger) {
    m_max_offsets_per_trigger = max_offsets_per_trigger;
    m_max_offsets_per_trigger_isSet = true;
}

bool OAICatalogKafkaSource_StreamingOptions::is_max_offsets_per_trigger_Set() const{
    return m_max_offsets_per_trigger_isSet;
}

bool OAICatalogKafkaSource_StreamingOptions::is_max_offsets_per_trigger_Valid() const{
    return m_max_offsets_per_trigger_isValid;
}

qint32 OAICatalogKafkaSource_StreamingOptions::getMinPartitions() const {
    return m_min_partitions;
}
void OAICatalogKafkaSource_StreamingOptions::setMinPartitions(const qint32 &min_partitions) {
    m_min_partitions = min_partitions;
    m_min_partitions_isSet = true;
}

bool OAICatalogKafkaSource_StreamingOptions::is_min_partitions_Set() const{
    return m_min_partitions_isSet;
}

bool OAICatalogKafkaSource_StreamingOptions::is_min_partitions_Valid() const{
    return m_min_partitions_isValid;
}

bool OAICatalogKafkaSource_StreamingOptions::getIncludeHeaders() const {
    return m_include_headers;
}
void OAICatalogKafkaSource_StreamingOptions::setIncludeHeaders(const bool &include_headers) {
    m_include_headers = include_headers;
    m_include_headers_isSet = true;
}

bool OAICatalogKafkaSource_StreamingOptions::is_include_headers_Set() const{
    return m_include_headers_isSet;
}

bool OAICatalogKafkaSource_StreamingOptions::is_include_headers_Valid() const{
    return m_include_headers_isValid;
}

QString OAICatalogKafkaSource_StreamingOptions::getAddRecordTimestamp() const {
    return m_add_record_timestamp;
}
void OAICatalogKafkaSource_StreamingOptions::setAddRecordTimestamp(const QString &add_record_timestamp) {
    m_add_record_timestamp = add_record_timestamp;
    m_add_record_timestamp_isSet = true;
}

bool OAICatalogKafkaSource_StreamingOptions::is_add_record_timestamp_Set() const{
    return m_add_record_timestamp_isSet;
}

bool OAICatalogKafkaSource_StreamingOptions::is_add_record_timestamp_Valid() const{
    return m_add_record_timestamp_isValid;
}

QString OAICatalogKafkaSource_StreamingOptions::getEmitConsumerLagMetrics() const {
    return m_emit_consumer_lag_metrics;
}
void OAICatalogKafkaSource_StreamingOptions::setEmitConsumerLagMetrics(const QString &emit_consumer_lag_metrics) {
    m_emit_consumer_lag_metrics = emit_consumer_lag_metrics;
    m_emit_consumer_lag_metrics_isSet = true;
}

bool OAICatalogKafkaSource_StreamingOptions::is_emit_consumer_lag_metrics_Set() const{
    return m_emit_consumer_lag_metrics_isSet;
}

bool OAICatalogKafkaSource_StreamingOptions::is_emit_consumer_lag_metrics_Valid() const{
    return m_emit_consumer_lag_metrics_isValid;
}

QDateTime OAICatalogKafkaSource_StreamingOptions::getStartingTimestamp() const {
    return m_starting_timestamp;
}
void OAICatalogKafkaSource_StreamingOptions::setStartingTimestamp(const QDateTime &starting_timestamp) {
    m_starting_timestamp = starting_timestamp;
    m_starting_timestamp_isSet = true;
}

bool OAICatalogKafkaSource_StreamingOptions::is_starting_timestamp_Set() const{
    return m_starting_timestamp_isSet;
}

bool OAICatalogKafkaSource_StreamingOptions::is_starting_timestamp_Valid() const{
    return m_starting_timestamp_isValid;
}

bool OAICatalogKafkaSource_StreamingOptions::isSet() const {
    bool isObjectUpdated = false;
    do {
        if (m_bootstrap_servers_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_security_protocol_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_connection_name_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_topic_name_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_assign_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_subscribe_pattern_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_classification_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_delimiter_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_starting_offsets_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_ending_offsets_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_poll_timeout_ms_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_num_retries_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_retry_interval_ms_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_max_offsets_per_trigger_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_min_partitions_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_include_headers_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_add_record_timestamp_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_emit_consumer_lag_metrics_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_starting_timestamp_isSet) {
            isObjectUpdated = true;
            break;
        }
    } while (false);
    return isObjectUpdated;
}

bool OAICatalogKafkaSource_StreamingOptions::isValid() const {
    // only required properties are required for the object to be considered valid
    return true;
}

} // namespace OpenAPI
