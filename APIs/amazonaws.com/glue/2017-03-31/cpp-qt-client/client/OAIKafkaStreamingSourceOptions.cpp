/**
 * AWS Glue
 * <fullname>Glue</fullname> <p>Defines the public endpoint for the Glue service.</p>
 *
 * The version of the OpenAPI document: 2017-03-31
 * Contact: mike.ralphson@gmail.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

#include "OAIKafkaStreamingSourceOptions.h"

#include <QDebug>
#include <QJsonArray>
#include <QJsonDocument>
#include <QObject>

#include "OAIHelpers.h"

namespace OpenAPI {

OAIKafkaStreamingSourceOptions::OAIKafkaStreamingSourceOptions(QString json) {
    this->initializeModel();
    this->fromJson(json);
}

OAIKafkaStreamingSourceOptions::OAIKafkaStreamingSourceOptions() {
    this->initializeModel();
}

OAIKafkaStreamingSourceOptions::~OAIKafkaStreamingSourceOptions() {}

void OAIKafkaStreamingSourceOptions::initializeModel() {

    m_bootstrap_servers_isSet = false;
    m_bootstrap_servers_isValid = false;

    m_security_protocol_isSet = false;
    m_security_protocol_isValid = false;

    m_connection_name_isSet = false;
    m_connection_name_isValid = false;

    m_topic_name_isSet = false;
    m_topic_name_isValid = false;

    m_assign_isSet = false;
    m_assign_isValid = false;

    m_subscribe_pattern_isSet = false;
    m_subscribe_pattern_isValid = false;

    m_classification_isSet = false;
    m_classification_isValid = false;

    m_delimiter_isSet = false;
    m_delimiter_isValid = false;

    m_starting_offsets_isSet = false;
    m_starting_offsets_isValid = false;

    m_ending_offsets_isSet = false;
    m_ending_offsets_isValid = false;

    m_poll_timeout_ms_isSet = false;
    m_poll_timeout_ms_isValid = false;

    m_num_retries_isSet = false;
    m_num_retries_isValid = false;

    m_retry_interval_ms_isSet = false;
    m_retry_interval_ms_isValid = false;

    m_max_offsets_per_trigger_isSet = false;
    m_max_offsets_per_trigger_isValid = false;

    m_min_partitions_isSet = false;
    m_min_partitions_isValid = false;

    m_include_headers_isSet = false;
    m_include_headers_isValid = false;

    m_add_record_timestamp_isSet = false;
    m_add_record_timestamp_isValid = false;

    m_emit_consumer_lag_metrics_isSet = false;
    m_emit_consumer_lag_metrics_isValid = false;

    m_starting_timestamp_isSet = false;
    m_starting_timestamp_isValid = false;
}

void OAIKafkaStreamingSourceOptions::fromJson(QString jsonString) {
    QByteArray array(jsonString.toStdString().c_str());
    QJsonDocument doc = QJsonDocument::fromJson(array);
    QJsonObject jsonObject = doc.object();
    this->fromJsonObject(jsonObject);
}

void OAIKafkaStreamingSourceOptions::fromJsonObject(QJsonObject json) {

    m_bootstrap_servers_isValid = ::OpenAPI::fromJsonValue(m_bootstrap_servers, json[QString("BootstrapServers")]);
    m_bootstrap_servers_isSet = !json[QString("BootstrapServers")].isNull() && m_bootstrap_servers_isValid;

    m_security_protocol_isValid = ::OpenAPI::fromJsonValue(m_security_protocol, json[QString("SecurityProtocol")]);
    m_security_protocol_isSet = !json[QString("SecurityProtocol")].isNull() && m_security_protocol_isValid;

    m_connection_name_isValid = ::OpenAPI::fromJsonValue(m_connection_name, json[QString("ConnectionName")]);
    m_connection_name_isSet = !json[QString("ConnectionName")].isNull() && m_connection_name_isValid;

    m_topic_name_isValid = ::OpenAPI::fromJsonValue(m_topic_name, json[QString("TopicName")]);
    m_topic_name_isSet = !json[QString("TopicName")].isNull() && m_topic_name_isValid;

    m_assign_isValid = ::OpenAPI::fromJsonValue(m_assign, json[QString("Assign")]);
    m_assign_isSet = !json[QString("Assign")].isNull() && m_assign_isValid;

    m_subscribe_pattern_isValid = ::OpenAPI::fromJsonValue(m_subscribe_pattern, json[QString("SubscribePattern")]);
    m_subscribe_pattern_isSet = !json[QString("SubscribePattern")].isNull() && m_subscribe_pattern_isValid;

    m_classification_isValid = ::OpenAPI::fromJsonValue(m_classification, json[QString("Classification")]);
    m_classification_isSet = !json[QString("Classification")].isNull() && m_classification_isValid;

    m_delimiter_isValid = ::OpenAPI::fromJsonValue(m_delimiter, json[QString("Delimiter")]);
    m_delimiter_isSet = !json[QString("Delimiter")].isNull() && m_delimiter_isValid;

    m_starting_offsets_isValid = ::OpenAPI::fromJsonValue(m_starting_offsets, json[QString("StartingOffsets")]);
    m_starting_offsets_isSet = !json[QString("StartingOffsets")].isNull() && m_starting_offsets_isValid;

    m_ending_offsets_isValid = ::OpenAPI::fromJsonValue(m_ending_offsets, json[QString("EndingOffsets")]);
    m_ending_offsets_isSet = !json[QString("EndingOffsets")].isNull() && m_ending_offsets_isValid;

    m_poll_timeout_ms_isValid = ::OpenAPI::fromJsonValue(m_poll_timeout_ms, json[QString("PollTimeoutMs")]);
    m_poll_timeout_ms_isSet = !json[QString("PollTimeoutMs")].isNull() && m_poll_timeout_ms_isValid;

    m_num_retries_isValid = ::OpenAPI::fromJsonValue(m_num_retries, json[QString("NumRetries")]);
    m_num_retries_isSet = !json[QString("NumRetries")].isNull() && m_num_retries_isValid;

    m_retry_interval_ms_isValid = ::OpenAPI::fromJsonValue(m_retry_interval_ms, json[QString("RetryIntervalMs")]);
    m_retry_interval_ms_isSet = !json[QString("RetryIntervalMs")].isNull() && m_retry_interval_ms_isValid;

    m_max_offsets_per_trigger_isValid = ::OpenAPI::fromJsonValue(m_max_offsets_per_trigger, json[QString("MaxOffsetsPerTrigger")]);
    m_max_offsets_per_trigger_isSet = !json[QString("MaxOffsetsPerTrigger")].isNull() && m_max_offsets_per_trigger_isValid;

    m_min_partitions_isValid = ::OpenAPI::fromJsonValue(m_min_partitions, json[QString("MinPartitions")]);
    m_min_partitions_isSet = !json[QString("MinPartitions")].isNull() && m_min_partitions_isValid;

    m_include_headers_isValid = ::OpenAPI::fromJsonValue(m_include_headers, json[QString("IncludeHeaders")]);
    m_include_headers_isSet = !json[QString("IncludeHeaders")].isNull() && m_include_headers_isValid;

    m_add_record_timestamp_isValid = ::OpenAPI::fromJsonValue(m_add_record_timestamp, json[QString("AddRecordTimestamp")]);
    m_add_record_timestamp_isSet = !json[QString("AddRecordTimestamp")].isNull() && m_add_record_timestamp_isValid;

    m_emit_consumer_lag_metrics_isValid = ::OpenAPI::fromJsonValue(m_emit_consumer_lag_metrics, json[QString("EmitConsumerLagMetrics")]);
    m_emit_consumer_lag_metrics_isSet = !json[QString("EmitConsumerLagMetrics")].isNull() && m_emit_consumer_lag_metrics_isValid;

    m_starting_timestamp_isValid = ::OpenAPI::fromJsonValue(m_starting_timestamp, json[QString("StartingTimestamp")]);
    m_starting_timestamp_isSet = !json[QString("StartingTimestamp")].isNull() && m_starting_timestamp_isValid;
}

QString OAIKafkaStreamingSourceOptions::asJson() const {
    QJsonObject obj = this->asJsonObject();
    QJsonDocument doc(obj);
    QByteArray bytes = doc.toJson();
    return QString(bytes);
}

QJsonObject OAIKafkaStreamingSourceOptions::asJsonObject() const {
    QJsonObject obj;
    if (m_bootstrap_servers_isSet) {
        obj.insert(QString("BootstrapServers"), ::OpenAPI::toJsonValue(m_bootstrap_servers));
    }
    if (m_security_protocol_isSet) {
        obj.insert(QString("SecurityProtocol"), ::OpenAPI::toJsonValue(m_security_protocol));
    }
    if (m_connection_name_isSet) {
        obj.insert(QString("ConnectionName"), ::OpenAPI::toJsonValue(m_connection_name));
    }
    if (m_topic_name_isSet) {
        obj.insert(QString("TopicName"), ::OpenAPI::toJsonValue(m_topic_name));
    }
    if (m_assign_isSet) {
        obj.insert(QString("Assign"), ::OpenAPI::toJsonValue(m_assign));
    }
    if (m_subscribe_pattern_isSet) {
        obj.insert(QString("SubscribePattern"), ::OpenAPI::toJsonValue(m_subscribe_pattern));
    }
    if (m_classification_isSet) {
        obj.insert(QString("Classification"), ::OpenAPI::toJsonValue(m_classification));
    }
    if (m_delimiter_isSet) {
        obj.insert(QString("Delimiter"), ::OpenAPI::toJsonValue(m_delimiter));
    }
    if (m_starting_offsets_isSet) {
        obj.insert(QString("StartingOffsets"), ::OpenAPI::toJsonValue(m_starting_offsets));
    }
    if (m_ending_offsets_isSet) {
        obj.insert(QString("EndingOffsets"), ::OpenAPI::toJsonValue(m_ending_offsets));
    }
    if (m_poll_timeout_ms_isSet) {
        obj.insert(QString("PollTimeoutMs"), ::OpenAPI::toJsonValue(m_poll_timeout_ms));
    }
    if (m_num_retries_isSet) {
        obj.insert(QString("NumRetries"), ::OpenAPI::toJsonValue(m_num_retries));
    }
    if (m_retry_interval_ms_isSet) {
        obj.insert(QString("RetryIntervalMs"), ::OpenAPI::toJsonValue(m_retry_interval_ms));
    }
    if (m_max_offsets_per_trigger_isSet) {
        obj.insert(QString("MaxOffsetsPerTrigger"), ::OpenAPI::toJsonValue(m_max_offsets_per_trigger));
    }
    if (m_min_partitions_isSet) {
        obj.insert(QString("MinPartitions"), ::OpenAPI::toJsonValue(m_min_partitions));
    }
    if (m_include_headers_isSet) {
        obj.insert(QString("IncludeHeaders"), ::OpenAPI::toJsonValue(m_include_headers));
    }
    if (m_add_record_timestamp_isSet) {
        obj.insert(QString("AddRecordTimestamp"), ::OpenAPI::toJsonValue(m_add_record_timestamp));
    }
    if (m_emit_consumer_lag_metrics_isSet) {
        obj.insert(QString("EmitConsumerLagMetrics"), ::OpenAPI::toJsonValue(m_emit_consumer_lag_metrics));
    }
    if (m_starting_timestamp_isSet) {
        obj.insert(QString("StartingTimestamp"), ::OpenAPI::toJsonValue(m_starting_timestamp));
    }
    return obj;
}

QString OAIKafkaStreamingSourceOptions::getBootstrapServers() const {
    return m_bootstrap_servers;
}
void OAIKafkaStreamingSourceOptions::setBootstrapServers(const QString &bootstrap_servers) {
    m_bootstrap_servers = bootstrap_servers;
    m_bootstrap_servers_isSet = true;
}

bool OAIKafkaStreamingSourceOptions::is_bootstrap_servers_Set() const{
    return m_bootstrap_servers_isSet;
}

bool OAIKafkaStreamingSourceOptions::is_bootstrap_servers_Valid() const{
    return m_bootstrap_servers_isValid;
}

QString OAIKafkaStreamingSourceOptions::getSecurityProtocol() const {
    return m_security_protocol;
}
void OAIKafkaStreamingSourceOptions::setSecurityProtocol(const QString &security_protocol) {
    m_security_protocol = security_protocol;
    m_security_protocol_isSet = true;
}

bool OAIKafkaStreamingSourceOptions::is_security_protocol_Set() const{
    return m_security_protocol_isSet;
}

bool OAIKafkaStreamingSourceOptions::is_security_protocol_Valid() const{
    return m_security_protocol_isValid;
}

QString OAIKafkaStreamingSourceOptions::getConnectionName() const {
    return m_connection_name;
}
void OAIKafkaStreamingSourceOptions::setConnectionName(const QString &connection_name) {
    m_connection_name = connection_name;
    m_connection_name_isSet = true;
}

bool OAIKafkaStreamingSourceOptions::is_connection_name_Set() const{
    return m_connection_name_isSet;
}

bool OAIKafkaStreamingSourceOptions::is_connection_name_Valid() const{
    return m_connection_name_isValid;
}

QString OAIKafkaStreamingSourceOptions::getTopicName() const {
    return m_topic_name;
}
void OAIKafkaStreamingSourceOptions::setTopicName(const QString &topic_name) {
    m_topic_name = topic_name;
    m_topic_name_isSet = true;
}

bool OAIKafkaStreamingSourceOptions::is_topic_name_Set() const{
    return m_topic_name_isSet;
}

bool OAIKafkaStreamingSourceOptions::is_topic_name_Valid() const{
    return m_topic_name_isValid;
}

QString OAIKafkaStreamingSourceOptions::getAssign() const {
    return m_assign;
}
void OAIKafkaStreamingSourceOptions::setAssign(const QString &assign) {
    m_assign = assign;
    m_assign_isSet = true;
}

bool OAIKafkaStreamingSourceOptions::is_assign_Set() const{
    return m_assign_isSet;
}

bool OAIKafkaStreamingSourceOptions::is_assign_Valid() const{
    return m_assign_isValid;
}

QString OAIKafkaStreamingSourceOptions::getSubscribePattern() const {
    return m_subscribe_pattern;
}
void OAIKafkaStreamingSourceOptions::setSubscribePattern(const QString &subscribe_pattern) {
    m_subscribe_pattern = subscribe_pattern;
    m_subscribe_pattern_isSet = true;
}

bool OAIKafkaStreamingSourceOptions::is_subscribe_pattern_Set() const{
    return m_subscribe_pattern_isSet;
}

bool OAIKafkaStreamingSourceOptions::is_subscribe_pattern_Valid() const{
    return m_subscribe_pattern_isValid;
}

QString OAIKafkaStreamingSourceOptions::getClassification() const {
    return m_classification;
}
void OAIKafkaStreamingSourceOptions::setClassification(const QString &classification) {
    m_classification = classification;
    m_classification_isSet = true;
}

bool OAIKafkaStreamingSourceOptions::is_classification_Set() const{
    return m_classification_isSet;
}

bool OAIKafkaStreamingSourceOptions::is_classification_Valid() const{
    return m_classification_isValid;
}

QString OAIKafkaStreamingSourceOptions::getDelimiter() const {
    return m_delimiter;
}
void OAIKafkaStreamingSourceOptions::setDelimiter(const QString &delimiter) {
    m_delimiter = delimiter;
    m_delimiter_isSet = true;
}

bool OAIKafkaStreamingSourceOptions::is_delimiter_Set() const{
    return m_delimiter_isSet;
}

bool OAIKafkaStreamingSourceOptions::is_delimiter_Valid() const{
    return m_delimiter_isValid;
}

QString OAIKafkaStreamingSourceOptions::getStartingOffsets() const {
    return m_starting_offsets;
}
void OAIKafkaStreamingSourceOptions::setStartingOffsets(const QString &starting_offsets) {
    m_starting_offsets = starting_offsets;
    m_starting_offsets_isSet = true;
}

bool OAIKafkaStreamingSourceOptions::is_starting_offsets_Set() const{
    return m_starting_offsets_isSet;
}

bool OAIKafkaStreamingSourceOptions::is_starting_offsets_Valid() const{
    return m_starting_offsets_isValid;
}

QString OAIKafkaStreamingSourceOptions::getEndingOffsets() const {
    return m_ending_offsets;
}
void OAIKafkaStreamingSourceOptions::setEndingOffsets(const QString &ending_offsets) {
    m_ending_offsets = ending_offsets;
    m_ending_offsets_isSet = true;
}

bool OAIKafkaStreamingSourceOptions::is_ending_offsets_Set() const{
    return m_ending_offsets_isSet;
}

bool OAIKafkaStreamingSourceOptions::is_ending_offsets_Valid() const{
    return m_ending_offsets_isValid;
}

qint32 OAIKafkaStreamingSourceOptions::getPollTimeoutMs() const {
    return m_poll_timeout_ms;
}
void OAIKafkaStreamingSourceOptions::setPollTimeoutMs(const qint32 &poll_timeout_ms) {
    m_poll_timeout_ms = poll_timeout_ms;
    m_poll_timeout_ms_isSet = true;
}

bool OAIKafkaStreamingSourceOptions::is_poll_timeout_ms_Set() const{
    return m_poll_timeout_ms_isSet;
}

bool OAIKafkaStreamingSourceOptions::is_poll_timeout_ms_Valid() const{
    return m_poll_timeout_ms_isValid;
}

qint32 OAIKafkaStreamingSourceOptions::getNumRetries() const {
    return m_num_retries;
}
void OAIKafkaStreamingSourceOptions::setNumRetries(const qint32 &num_retries) {
    m_num_retries = num_retries;
    m_num_retries_isSet = true;
}

bool OAIKafkaStreamingSourceOptions::is_num_retries_Set() const{
    return m_num_retries_isSet;
}

bool OAIKafkaStreamingSourceOptions::is_num_retries_Valid() const{
    return m_num_retries_isValid;
}

qint32 OAIKafkaStreamingSourceOptions::getRetryIntervalMs() const {
    return m_retry_interval_ms;
}
void OAIKafkaStreamingSourceOptions::setRetryIntervalMs(const qint32 &retry_interval_ms) {
    m_retry_interval_ms = retry_interval_ms;
    m_retry_interval_ms_isSet = true;
}

bool OAIKafkaStreamingSourceOptions::is_retry_interval_ms_Set() const{
    return m_retry_interval_ms_isSet;
}

bool OAIKafkaStreamingSourceOptions::is_retry_interval_ms_Valid() const{
    return m_retry_interval_ms_isValid;
}

qint32 OAIKafkaStreamingSourceOptions::getMaxOffsetsPerTrigger() const {
    return m_max_offsets_per_trigger;
}
void OAIKafkaStreamingSourceOptions::setMaxOffsetsPerTrigger(const qint32 &max_offsets_per_trigger) {
    m_max_offsets_per_trigger = max_offsets_per_trigger;
    m_max_offsets_per_trigger_isSet = true;
}

bool OAIKafkaStreamingSourceOptions::is_max_offsets_per_trigger_Set() const{
    return m_max_offsets_per_trigger_isSet;
}

bool OAIKafkaStreamingSourceOptions::is_max_offsets_per_trigger_Valid() const{
    return m_max_offsets_per_trigger_isValid;
}

qint32 OAIKafkaStreamingSourceOptions::getMinPartitions() const {
    return m_min_partitions;
}
void OAIKafkaStreamingSourceOptions::setMinPartitions(const qint32 &min_partitions) {
    m_min_partitions = min_partitions;
    m_min_partitions_isSet = true;
}

bool OAIKafkaStreamingSourceOptions::is_min_partitions_Set() const{
    return m_min_partitions_isSet;
}

bool OAIKafkaStreamingSourceOptions::is_min_partitions_Valid() const{
    return m_min_partitions_isValid;
}

bool OAIKafkaStreamingSourceOptions::getIncludeHeaders() const {
    return m_include_headers;
}
void OAIKafkaStreamingSourceOptions::setIncludeHeaders(const bool &include_headers) {
    m_include_headers = include_headers;
    m_include_headers_isSet = true;
}

bool OAIKafkaStreamingSourceOptions::is_include_headers_Set() const{
    return m_include_headers_isSet;
}

bool OAIKafkaStreamingSourceOptions::is_include_headers_Valid() const{
    return m_include_headers_isValid;
}

QString OAIKafkaStreamingSourceOptions::getAddRecordTimestamp() const {
    return m_add_record_timestamp;
}
void OAIKafkaStreamingSourceOptions::setAddRecordTimestamp(const QString &add_record_timestamp) {
    m_add_record_timestamp = add_record_timestamp;
    m_add_record_timestamp_isSet = true;
}

bool OAIKafkaStreamingSourceOptions::is_add_record_timestamp_Set() const{
    return m_add_record_timestamp_isSet;
}

bool OAIKafkaStreamingSourceOptions::is_add_record_timestamp_Valid() const{
    return m_add_record_timestamp_isValid;
}

QString OAIKafkaStreamingSourceOptions::getEmitConsumerLagMetrics() const {
    return m_emit_consumer_lag_metrics;
}
void OAIKafkaStreamingSourceOptions::setEmitConsumerLagMetrics(const QString &emit_consumer_lag_metrics) {
    m_emit_consumer_lag_metrics = emit_consumer_lag_metrics;
    m_emit_consumer_lag_metrics_isSet = true;
}

bool OAIKafkaStreamingSourceOptions::is_emit_consumer_lag_metrics_Set() const{
    return m_emit_consumer_lag_metrics_isSet;
}

bool OAIKafkaStreamingSourceOptions::is_emit_consumer_lag_metrics_Valid() const{
    return m_emit_consumer_lag_metrics_isValid;
}

QDateTime OAIKafkaStreamingSourceOptions::getStartingTimestamp() const {
    return m_starting_timestamp;
}
void OAIKafkaStreamingSourceOptions::setStartingTimestamp(const QDateTime &starting_timestamp) {
    m_starting_timestamp = starting_timestamp;
    m_starting_timestamp_isSet = true;
}

bool OAIKafkaStreamingSourceOptions::is_starting_timestamp_Set() const{
    return m_starting_timestamp_isSet;
}

bool OAIKafkaStreamingSourceOptions::is_starting_timestamp_Valid() const{
    return m_starting_timestamp_isValid;
}

bool OAIKafkaStreamingSourceOptions::isSet() const {
    bool isObjectUpdated = false;
    do {
        if (m_bootstrap_servers_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_security_protocol_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_connection_name_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_topic_name_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_assign_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_subscribe_pattern_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_classification_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_delimiter_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_starting_offsets_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_ending_offsets_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_poll_timeout_ms_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_num_retries_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_retry_interval_ms_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_max_offsets_per_trigger_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_min_partitions_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_include_headers_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_add_record_timestamp_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_emit_consumer_lag_metrics_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_starting_timestamp_isSet) {
            isObjectUpdated = true;
            break;
        }
    } while (false);
    return isObjectUpdated;
}

bool OAIKafkaStreamingSourceOptions::isValid() const {
    // only required properties are required for the object to be considered valid
    return true;
}

} // namespace OpenAPI
