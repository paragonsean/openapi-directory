/**
 * AWSMainframeModernization
 * Amazon Web Services Mainframe Modernization provides tools and resources to help you plan and implement migration and modernization from mainframes to Amazon Web Services managed runtime environments. It provides tools for analyzing existing mainframe applications, developing or updating mainframe applications using COBOL or PL/I, and implementing an automated pipeline for continuous integration and continuous delivery (CI/CD) of the applications.
 *
 * The version of the OpenAPI document: 2021-04-28
 * Contact: mike.ralphson@gmail.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

#include "OAIAlternateKey.h"

#include <QDebug>
#include <QJsonArray>
#include <QJsonDocument>
#include <QObject>

#include "OAIHelpers.h"

namespace OpenAPI {

OAIAlternateKey::OAIAlternateKey(QString json) {
    this->initializeModel();
    this->fromJson(json);
}

OAIAlternateKey::OAIAlternateKey() {
    this->initializeModel();
}

OAIAlternateKey::~OAIAlternateKey() {}

void OAIAlternateKey::initializeModel() {

    m_allow_duplicates_isSet = false;
    m_allow_duplicates_isValid = false;

    m_length_isSet = false;
    m_length_isValid = false;

    m_name_isSet = false;
    m_name_isValid = false;

    m_offset_isSet = false;
    m_offset_isValid = false;
}

void OAIAlternateKey::fromJson(QString jsonString) {
    QByteArray array(jsonString.toStdString().c_str());
    QJsonDocument doc = QJsonDocument::fromJson(array);
    QJsonObject jsonObject = doc.object();
    this->fromJsonObject(jsonObject);
}

void OAIAlternateKey::fromJsonObject(QJsonObject json) {

    m_allow_duplicates_isValid = ::OpenAPI::fromJsonValue(m_allow_duplicates, json[QString("allowDuplicates")]);
    m_allow_duplicates_isSet = !json[QString("allowDuplicates")].isNull() && m_allow_duplicates_isValid;

    m_length_isValid = ::OpenAPI::fromJsonValue(m_length, json[QString("length")]);
    m_length_isSet = !json[QString("length")].isNull() && m_length_isValid;

    m_name_isValid = ::OpenAPI::fromJsonValue(m_name, json[QString("name")]);
    m_name_isSet = !json[QString("name")].isNull() && m_name_isValid;

    m_offset_isValid = ::OpenAPI::fromJsonValue(m_offset, json[QString("offset")]);
    m_offset_isSet = !json[QString("offset")].isNull() && m_offset_isValid;
}

QString OAIAlternateKey::asJson() const {
    QJsonObject obj = this->asJsonObject();
    QJsonDocument doc(obj);
    QByteArray bytes = doc.toJson();
    return QString(bytes);
}

QJsonObject OAIAlternateKey::asJsonObject() const {
    QJsonObject obj;
    if (m_allow_duplicates_isSet) {
        obj.insert(QString("allowDuplicates"), ::OpenAPI::toJsonValue(m_allow_duplicates));
    }
    if (m_length_isSet) {
        obj.insert(QString("length"), ::OpenAPI::toJsonValue(m_length));
    }
    if (m_name_isSet) {
        obj.insert(QString("name"), ::OpenAPI::toJsonValue(m_name));
    }
    if (m_offset_isSet) {
        obj.insert(QString("offset"), ::OpenAPI::toJsonValue(m_offset));
    }
    return obj;
}

bool OAIAlternateKey::getAllowDuplicates() const {
    return m_allow_duplicates;
}
void OAIAlternateKey::setAllowDuplicates(const bool &allow_duplicates) {
    m_allow_duplicates = allow_duplicates;
    m_allow_duplicates_isSet = true;
}

bool OAIAlternateKey::is_allow_duplicates_Set() const{
    return m_allow_duplicates_isSet;
}

bool OAIAlternateKey::is_allow_duplicates_Valid() const{
    return m_allow_duplicates_isValid;
}

qint32 OAIAlternateKey::getLength() const {
    return m_length;
}
void OAIAlternateKey::setLength(const qint32 &length) {
    m_length = length;
    m_length_isSet = true;
}

bool OAIAlternateKey::is_length_Set() const{
    return m_length_isSet;
}

bool OAIAlternateKey::is_length_Valid() const{
    return m_length_isValid;
}

QString OAIAlternateKey::getName() const {
    return m_name;
}
void OAIAlternateKey::setName(const QString &name) {
    m_name = name;
    m_name_isSet = true;
}

bool OAIAlternateKey::is_name_Set() const{
    return m_name_isSet;
}

bool OAIAlternateKey::is_name_Valid() const{
    return m_name_isValid;
}

qint32 OAIAlternateKey::getOffset() const {
    return m_offset;
}
void OAIAlternateKey::setOffset(const qint32 &offset) {
    m_offset = offset;
    m_offset_isSet = true;
}

bool OAIAlternateKey::is_offset_Set() const{
    return m_offset_isSet;
}

bool OAIAlternateKey::is_offset_Valid() const{
    return m_offset_isValid;
}

bool OAIAlternateKey::isSet() const {
    bool isObjectUpdated = false;
    do {
        if (m_allow_duplicates_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_length_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_name_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_offset_isSet) {
            isObjectUpdated = true;
            break;
        }
    } while (false);
    return isObjectUpdated;
}

bool OAIAlternateKey::isValid() const {
    // only required properties are required for the object to be considered valid
    return m_length_isValid && m_offset_isValid && true;
}

} // namespace OpenAPI
