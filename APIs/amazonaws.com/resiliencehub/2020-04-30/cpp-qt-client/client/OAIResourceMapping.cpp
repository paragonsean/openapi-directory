/**
 * AWS Resilience Hub
 * Resilience Hub helps you proactively prepare and protect your Amazon Web Services applications from disruptions. It offers continual resiliency assessment and validation that integrates into your software development lifecycle. This enables you to uncover resiliency weaknesses, ensure recovery time objective (RTO) and recovery point objective (RPO) targets for your applications are met, and resolve issues before they are released into production. 
 *
 * The version of the OpenAPI document: 2020-04-30
 * Contact: mike.ralphson@gmail.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

#include "OAIResourceMapping.h"

#include <QDebug>
#include <QJsonArray>
#include <QJsonDocument>
#include <QObject>

#include "OAIHelpers.h"

namespace OpenAPI {

OAIResourceMapping::OAIResourceMapping(QString json) {
    this->initializeModel();
    this->fromJson(json);
}

OAIResourceMapping::OAIResourceMapping() {
    this->initializeModel();
}

OAIResourceMapping::~OAIResourceMapping() {}

void OAIResourceMapping::initializeModel() {

    m_app_registry_app_name_isSet = false;
    m_app_registry_app_name_isValid = false;

    m_eks_source_name_isSet = false;
    m_eks_source_name_isValid = false;

    m_logical_stack_name_isSet = false;
    m_logical_stack_name_isValid = false;

    m_mapping_type_isSet = false;
    m_mapping_type_isValid = false;

    m_physical_resource_id_isSet = false;
    m_physical_resource_id_isValid = false;

    m_resource_group_name_isSet = false;
    m_resource_group_name_isValid = false;

    m_resource_name_isSet = false;
    m_resource_name_isValid = false;

    m_terraform_source_name_isSet = false;
    m_terraform_source_name_isValid = false;
}

void OAIResourceMapping::fromJson(QString jsonString) {
    QByteArray array(jsonString.toStdString().c_str());
    QJsonDocument doc = QJsonDocument::fromJson(array);
    QJsonObject jsonObject = doc.object();
    this->fromJsonObject(jsonObject);
}

void OAIResourceMapping::fromJsonObject(QJsonObject json) {

    m_app_registry_app_name_isValid = ::OpenAPI::fromJsonValue(m_app_registry_app_name, json[QString("appRegistryAppName")]);
    m_app_registry_app_name_isSet = !json[QString("appRegistryAppName")].isNull() && m_app_registry_app_name_isValid;

    m_eks_source_name_isValid = ::OpenAPI::fromJsonValue(m_eks_source_name, json[QString("eksSourceName")]);
    m_eks_source_name_isSet = !json[QString("eksSourceName")].isNull() && m_eks_source_name_isValid;

    m_logical_stack_name_isValid = ::OpenAPI::fromJsonValue(m_logical_stack_name, json[QString("logicalStackName")]);
    m_logical_stack_name_isSet = !json[QString("logicalStackName")].isNull() && m_logical_stack_name_isValid;

    m_mapping_type_isValid = ::OpenAPI::fromJsonValue(m_mapping_type, json[QString("mappingType")]);
    m_mapping_type_isSet = !json[QString("mappingType")].isNull() && m_mapping_type_isValid;

    m_physical_resource_id_isValid = ::OpenAPI::fromJsonValue(m_physical_resource_id, json[QString("physicalResourceId")]);
    m_physical_resource_id_isSet = !json[QString("physicalResourceId")].isNull() && m_physical_resource_id_isValid;

    m_resource_group_name_isValid = ::OpenAPI::fromJsonValue(m_resource_group_name, json[QString("resourceGroupName")]);
    m_resource_group_name_isSet = !json[QString("resourceGroupName")].isNull() && m_resource_group_name_isValid;

    m_resource_name_isValid = ::OpenAPI::fromJsonValue(m_resource_name, json[QString("resourceName")]);
    m_resource_name_isSet = !json[QString("resourceName")].isNull() && m_resource_name_isValid;

    m_terraform_source_name_isValid = ::OpenAPI::fromJsonValue(m_terraform_source_name, json[QString("terraformSourceName")]);
    m_terraform_source_name_isSet = !json[QString("terraformSourceName")].isNull() && m_terraform_source_name_isValid;
}

QString OAIResourceMapping::asJson() const {
    QJsonObject obj = this->asJsonObject();
    QJsonDocument doc(obj);
    QByteArray bytes = doc.toJson();
    return QString(bytes);
}

QJsonObject OAIResourceMapping::asJsonObject() const {
    QJsonObject obj;
    if (m_app_registry_app_name_isSet) {
        obj.insert(QString("appRegistryAppName"), ::OpenAPI::toJsonValue(m_app_registry_app_name));
    }
    if (m_eks_source_name_isSet) {
        obj.insert(QString("eksSourceName"), ::OpenAPI::toJsonValue(m_eks_source_name));
    }
    if (m_logical_stack_name_isSet) {
        obj.insert(QString("logicalStackName"), ::OpenAPI::toJsonValue(m_logical_stack_name));
    }
    if (m_mapping_type.isSet()) {
        obj.insert(QString("mappingType"), ::OpenAPI::toJsonValue(m_mapping_type));
    }
    if (m_physical_resource_id.isSet()) {
        obj.insert(QString("physicalResourceId"), ::OpenAPI::toJsonValue(m_physical_resource_id));
    }
    if (m_resource_group_name_isSet) {
        obj.insert(QString("resourceGroupName"), ::OpenAPI::toJsonValue(m_resource_group_name));
    }
    if (m_resource_name_isSet) {
        obj.insert(QString("resourceName"), ::OpenAPI::toJsonValue(m_resource_name));
    }
    if (m_terraform_source_name_isSet) {
        obj.insert(QString("terraformSourceName"), ::OpenAPI::toJsonValue(m_terraform_source_name));
    }
    return obj;
}

QString OAIResourceMapping::getAppRegistryAppName() const {
    return m_app_registry_app_name;
}
void OAIResourceMapping::setAppRegistryAppName(const QString &app_registry_app_name) {
    m_app_registry_app_name = app_registry_app_name;
    m_app_registry_app_name_isSet = true;
}

bool OAIResourceMapping::is_app_registry_app_name_Set() const{
    return m_app_registry_app_name_isSet;
}

bool OAIResourceMapping::is_app_registry_app_name_Valid() const{
    return m_app_registry_app_name_isValid;
}

QString OAIResourceMapping::getEksSourceName() const {
    return m_eks_source_name;
}
void OAIResourceMapping::setEksSourceName(const QString &eks_source_name) {
    m_eks_source_name = eks_source_name;
    m_eks_source_name_isSet = true;
}

bool OAIResourceMapping::is_eks_source_name_Set() const{
    return m_eks_source_name_isSet;
}

bool OAIResourceMapping::is_eks_source_name_Valid() const{
    return m_eks_source_name_isValid;
}

QString OAIResourceMapping::getLogicalStackName() const {
    return m_logical_stack_name;
}
void OAIResourceMapping::setLogicalStackName(const QString &logical_stack_name) {
    m_logical_stack_name = logical_stack_name;
    m_logical_stack_name_isSet = true;
}

bool OAIResourceMapping::is_logical_stack_name_Set() const{
    return m_logical_stack_name_isSet;
}

bool OAIResourceMapping::is_logical_stack_name_Valid() const{
    return m_logical_stack_name_isValid;
}

OAIResourceMappingType OAIResourceMapping::getMappingType() const {
    return m_mapping_type;
}
void OAIResourceMapping::setMappingType(const OAIResourceMappingType &mapping_type) {
    m_mapping_type = mapping_type;
    m_mapping_type_isSet = true;
}

bool OAIResourceMapping::is_mapping_type_Set() const{
    return m_mapping_type_isSet;
}

bool OAIResourceMapping::is_mapping_type_Valid() const{
    return m_mapping_type_isValid;
}

OAIResourceMapping_physicalResourceId OAIResourceMapping::getPhysicalResourceId() const {
    return m_physical_resource_id;
}
void OAIResourceMapping::setPhysicalResourceId(const OAIResourceMapping_physicalResourceId &physical_resource_id) {
    m_physical_resource_id = physical_resource_id;
    m_physical_resource_id_isSet = true;
}

bool OAIResourceMapping::is_physical_resource_id_Set() const{
    return m_physical_resource_id_isSet;
}

bool OAIResourceMapping::is_physical_resource_id_Valid() const{
    return m_physical_resource_id_isValid;
}

QString OAIResourceMapping::getResourceGroupName() const {
    return m_resource_group_name;
}
void OAIResourceMapping::setResourceGroupName(const QString &resource_group_name) {
    m_resource_group_name = resource_group_name;
    m_resource_group_name_isSet = true;
}

bool OAIResourceMapping::is_resource_group_name_Set() const{
    return m_resource_group_name_isSet;
}

bool OAIResourceMapping::is_resource_group_name_Valid() const{
    return m_resource_group_name_isValid;
}

QString OAIResourceMapping::getResourceName() const {
    return m_resource_name;
}
void OAIResourceMapping::setResourceName(const QString &resource_name) {
    m_resource_name = resource_name;
    m_resource_name_isSet = true;
}

bool OAIResourceMapping::is_resource_name_Set() const{
    return m_resource_name_isSet;
}

bool OAIResourceMapping::is_resource_name_Valid() const{
    return m_resource_name_isValid;
}

QString OAIResourceMapping::getTerraformSourceName() const {
    return m_terraform_source_name;
}
void OAIResourceMapping::setTerraformSourceName(const QString &terraform_source_name) {
    m_terraform_source_name = terraform_source_name;
    m_terraform_source_name_isSet = true;
}

bool OAIResourceMapping::is_terraform_source_name_Set() const{
    return m_terraform_source_name_isSet;
}

bool OAIResourceMapping::is_terraform_source_name_Valid() const{
    return m_terraform_source_name_isValid;
}

bool OAIResourceMapping::isSet() const {
    bool isObjectUpdated = false;
    do {
        if (m_app_registry_app_name_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_eks_source_name_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_logical_stack_name_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_mapping_type.isSet()) {
            isObjectUpdated = true;
            break;
        }

        if (m_physical_resource_id.isSet()) {
            isObjectUpdated = true;
            break;
        }

        if (m_resource_group_name_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_resource_name_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_terraform_source_name_isSet) {
            isObjectUpdated = true;
            break;
        }
    } while (false);
    return isObjectUpdated;
}

bool OAIResourceMapping::isValid() const {
    // only required properties are required for the object to be considered valid
    return m_mapping_type_isValid && m_physical_resource_id_isValid && true;
}

} // namespace OpenAPI
