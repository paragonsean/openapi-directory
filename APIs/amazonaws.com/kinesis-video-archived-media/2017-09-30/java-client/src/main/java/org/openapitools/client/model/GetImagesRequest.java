/*
 * Amazon Kinesis Video Streams Archived Media
 * <p/>
 *
 * The version of the OpenAPI document: 2017-09-30
 * Contact: mike.ralphson@gmail.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package org.openapitools.client.model;

import java.util.Objects;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;
import java.time.OffsetDateTime;
import java.util.Arrays;
import java.util.HashMap;
import java.util.Map;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonArray;
import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;
import com.google.gson.TypeAdapterFactory;
import com.google.gson.reflect.TypeToken;
import com.google.gson.TypeAdapter;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;

import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import org.openapitools.client.JSON;

/**
 * GetImagesRequest
 */
@javax.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen", date = "2024-10-12T12:12:53.497265-04:00[America/New_York]", comments = "Generator version: 7.9.0")
public class GetImagesRequest {
  public static final String SERIALIZED_NAME_STREAM_NAME = "StreamName";
  @SerializedName(SERIALIZED_NAME_STREAM_NAME)
  private String streamName;

  public static final String SERIALIZED_NAME_STREAM_A_R_N = "StreamARN";
  @SerializedName(SERIALIZED_NAME_STREAM_A_R_N)
  private String streamARN;

  /**
   * The origin of the Server or Producer timestamps to use to generate the images.
   */
  @JsonAdapter(ImageSelectorTypeEnum.Adapter.class)
  public enum ImageSelectorTypeEnum {
    PRODUCER_TIMESTAMP("PRODUCER_TIMESTAMP"),
    
    SERVER_TIMESTAMP("SERVER_TIMESTAMP");

    private String value;

    ImageSelectorTypeEnum(String value) {
      this.value = value;
    }

    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }

    public static ImageSelectorTypeEnum fromValue(String value) {
      for (ImageSelectorTypeEnum b : ImageSelectorTypeEnum.values()) {
        if (b.value.equals(value)) {
          return b;
        }
      }
      throw new IllegalArgumentException("Unexpected value '" + value + "'");
    }

    public static class Adapter extends TypeAdapter<ImageSelectorTypeEnum> {
      @Override
      public void write(final JsonWriter jsonWriter, final ImageSelectorTypeEnum enumeration) throws IOException {
        jsonWriter.value(enumeration.getValue());
      }

      @Override
      public ImageSelectorTypeEnum read(final JsonReader jsonReader) throws IOException {
        String value =  jsonReader.nextString();
        return ImageSelectorTypeEnum.fromValue(value);
      }
    }

    public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      String value = jsonElement.getAsString();
      ImageSelectorTypeEnum.fromValue(value);
    }
  }

  public static final String SERIALIZED_NAME_IMAGE_SELECTOR_TYPE = "ImageSelectorType";
  @SerializedName(SERIALIZED_NAME_IMAGE_SELECTOR_TYPE)
  private ImageSelectorTypeEnum imageSelectorType;

  public static final String SERIALIZED_NAME_START_TIMESTAMP = "StartTimestamp";
  @SerializedName(SERIALIZED_NAME_START_TIMESTAMP)
  private OffsetDateTime startTimestamp;

  public static final String SERIALIZED_NAME_END_TIMESTAMP = "EndTimestamp";
  @SerializedName(SERIALIZED_NAME_END_TIMESTAMP)
  private OffsetDateTime endTimestamp;

  public static final String SERIALIZED_NAME_SAMPLING_INTERVAL = "SamplingInterval";
  @SerializedName(SERIALIZED_NAME_SAMPLING_INTERVAL)
  private Integer samplingInterval;

  /**
   * The format that will be used to encode the image.
   */
  @JsonAdapter(FormatEnum.Adapter.class)
  public enum FormatEnum {
    JPEG("JPEG"),
    
    PNG("PNG");

    private String value;

    FormatEnum(String value) {
      this.value = value;
    }

    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }

    public static FormatEnum fromValue(String value) {
      for (FormatEnum b : FormatEnum.values()) {
        if (b.value.equals(value)) {
          return b;
        }
      }
      throw new IllegalArgumentException("Unexpected value '" + value + "'");
    }

    public static class Adapter extends TypeAdapter<FormatEnum> {
      @Override
      public void write(final JsonWriter jsonWriter, final FormatEnum enumeration) throws IOException {
        jsonWriter.value(enumeration.getValue());
      }

      @Override
      public FormatEnum read(final JsonReader jsonReader) throws IOException {
        String value =  jsonReader.nextString();
        return FormatEnum.fromValue(value);
      }
    }

    public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      String value = jsonElement.getAsString();
      FormatEnum.fromValue(value);
    }
  }

  public static final String SERIALIZED_NAME_FORMAT = "Format";
  @SerializedName(SERIALIZED_NAME_FORMAT)
  private FormatEnum format;

  public static final String SERIALIZED_NAME_FORMAT_CONFIG = "FormatConfig";
  @SerializedName(SERIALIZED_NAME_FORMAT_CONFIG)
  private Map<String, String> formatConfig = new HashMap<>();

  public static final String SERIALIZED_NAME_WIDTH_PIXELS = "WidthPixels";
  @SerializedName(SERIALIZED_NAME_WIDTH_PIXELS)
  private Integer widthPixels;

  public static final String SERIALIZED_NAME_HEIGHT_PIXELS = "HeightPixels";
  @SerializedName(SERIALIZED_NAME_HEIGHT_PIXELS)
  private Integer heightPixels;

  public static final String SERIALIZED_NAME_MAX_RESULTS = "MaxResults";
  @SerializedName(SERIALIZED_NAME_MAX_RESULTS)
  private Integer maxResults;

  public static final String SERIALIZED_NAME_NEXT_TOKEN = "NextToken";
  @SerializedName(SERIALIZED_NAME_NEXT_TOKEN)
  private String nextToken;

  public GetImagesRequest() {
  }

  public GetImagesRequest streamName(String streamName) {
    this.streamName = streamName;
    return this;
  }

  /**
   * The name of the stream from which to retrieve the images. You must specify either the &lt;code&gt;StreamName&lt;/code&gt; or the &lt;code&gt;StreamARN&lt;/code&gt;.
   * @return streamName
   */
  @javax.annotation.Nullable
  public String getStreamName() {
    return streamName;
  }

  public void setStreamName(String streamName) {
    this.streamName = streamName;
  }


  public GetImagesRequest streamARN(String streamARN) {
    this.streamARN = streamARN;
    return this;
  }

  /**
   * The Amazon Resource Name (ARN) of the stream from which to retrieve the images. You must specify either the &lt;code&gt;StreamName&lt;/code&gt; or the &lt;code&gt;StreamARN&lt;/code&gt;.
   * @return streamARN
   */
  @javax.annotation.Nullable
  public String getStreamARN() {
    return streamARN;
  }

  public void setStreamARN(String streamARN) {
    this.streamARN = streamARN;
  }


  public GetImagesRequest imageSelectorType(ImageSelectorTypeEnum imageSelectorType) {
    this.imageSelectorType = imageSelectorType;
    return this;
  }

  /**
   * The origin of the Server or Producer timestamps to use to generate the images.
   * @return imageSelectorType
   */
  @javax.annotation.Nonnull
  public ImageSelectorTypeEnum getImageSelectorType() {
    return imageSelectorType;
  }

  public void setImageSelectorType(ImageSelectorTypeEnum imageSelectorType) {
    this.imageSelectorType = imageSelectorType;
  }


  public GetImagesRequest startTimestamp(OffsetDateTime startTimestamp) {
    this.startTimestamp = startTimestamp;
    return this;
  }

  /**
   * The starting point from which the images should be generated. This &lt;code&gt;StartTimestamp&lt;/code&gt; must be within an inclusive range of timestamps for an image to be returned.
   * @return startTimestamp
   */
  @javax.annotation.Nonnull
  public OffsetDateTime getStartTimestamp() {
    return startTimestamp;
  }

  public void setStartTimestamp(OffsetDateTime startTimestamp) {
    this.startTimestamp = startTimestamp;
  }


  public GetImagesRequest endTimestamp(OffsetDateTime endTimestamp) {
    this.endTimestamp = endTimestamp;
    return this;
  }

  /**
   * The end timestamp for the range of images to be generated. If the time range between &lt;code&gt;StartTimestamp&lt;/code&gt; and &lt;code&gt;EndTimestamp&lt;/code&gt; is more than 300 seconds above &lt;code&gt;StartTimestamp&lt;/code&gt;, you will receive an &lt;code&gt;IllegalArgumentException&lt;/code&gt;.
   * @return endTimestamp
   */
  @javax.annotation.Nonnull
  public OffsetDateTime getEndTimestamp() {
    return endTimestamp;
  }

  public void setEndTimestamp(OffsetDateTime endTimestamp) {
    this.endTimestamp = endTimestamp;
  }


  public GetImagesRequest samplingInterval(Integer samplingInterval) {
    this.samplingInterval = samplingInterval;
    return this;
  }

  /**
   * &lt;p&gt;The time interval in milliseconds (ms) at which the images need to be generated from the stream, with a default of 3000 ms. The minimum value that can be provided is 200 ms. If the timestamp range is less than the sampling interval, the Image from the &lt;code&gt;startTimestamp&lt;/code&gt; will be returned if available. &lt;/p&gt; &lt;note&gt; &lt;p&gt;The minimum value of 200 ms is a hard limit.&lt;/p&gt; &lt;/note&gt;
   * @return samplingInterval
   */
  @javax.annotation.Nullable
  public Integer getSamplingInterval() {
    return samplingInterval;
  }

  public void setSamplingInterval(Integer samplingInterval) {
    this.samplingInterval = samplingInterval;
  }


  public GetImagesRequest format(FormatEnum format) {
    this.format = format;
    return this;
  }

  /**
   * The format that will be used to encode the image.
   * @return format
   */
  @javax.annotation.Nonnull
  public FormatEnum getFormat() {
    return format;
  }

  public void setFormat(FormatEnum format) {
    this.format = format;
  }


  public GetImagesRequest formatConfig(Map<String, String> formatConfig) {
    this.formatConfig = formatConfig;
    return this;
  }

  public GetImagesRequest putFormatConfigItem(String key, String formatConfigItem) {
    if (this.formatConfig == null) {
      this.formatConfig = new HashMap<>();
    }
    this.formatConfig.put(key, formatConfigItem);
    return this;
  }

  /**
   * The list of a key-value pair structure that contains extra parameters that can be applied when the image is generated. The &lt;code&gt;FormatConfig&lt;/code&gt; key is the &lt;code&gt;JPEGQuality&lt;/code&gt;, which indicates the JPEG quality key to be used to generate the image. The &lt;code&gt;FormatConfig&lt;/code&gt; value accepts ints from 1 to 100. If the value is 1, the image will be generated with less quality and the best compression. If the value is 100, the image will be generated with the best quality and less compression. If no value is provided, the default value of the &lt;code&gt;JPEGQuality&lt;/code&gt; key will be set to 80.
   * @return formatConfig
   */
  @javax.annotation.Nullable
  public Map<String, String> getFormatConfig() {
    return formatConfig;
  }

  public void setFormatConfig(Map<String, String> formatConfig) {
    this.formatConfig = formatConfig;
  }


  public GetImagesRequest widthPixels(Integer widthPixels) {
    this.widthPixels = widthPixels;
    return this;
  }

  /**
   * The width of the output image that is used in conjunction with the &lt;code&gt;HeightPixels&lt;/code&gt; parameter. When both &lt;code&gt;WidthPixels&lt;/code&gt; and &lt;code&gt;HeightPixels&lt;/code&gt; parameters are provided, the image will be stretched to fit the specified aspect ratio. If only the &lt;code&gt;WidthPixels&lt;/code&gt; parameter is provided or if only the &lt;code&gt;HeightPixels&lt;/code&gt; is provided, a &lt;code&gt;ValidationException&lt;/code&gt; will be thrown. If neither parameter is provided, the original image size from the stream will be returned.
   * minimum: 1
   * maximum: 3840
   * @return widthPixels
   */
  @javax.annotation.Nullable
  public Integer getWidthPixels() {
    return widthPixels;
  }

  public void setWidthPixels(Integer widthPixels) {
    this.widthPixels = widthPixels;
  }


  public GetImagesRequest heightPixels(Integer heightPixels) {
    this.heightPixels = heightPixels;
    return this;
  }

  /**
   * The height of the output image that is used in conjunction with the &lt;code&gt;WidthPixels&lt;/code&gt; parameter. When both &lt;code&gt;HeightPixels&lt;/code&gt; and &lt;code&gt;WidthPixels&lt;/code&gt; parameters are provided, the image will be stretched to fit the specified aspect ratio. If only the &lt;code&gt;HeightPixels&lt;/code&gt; parameter is provided, its original aspect ratio will be used to calculate the &lt;code&gt;WidthPixels&lt;/code&gt; ratio. If neither parameter is provided, the original image size will be returned.
   * minimum: 1
   * maximum: 2160
   * @return heightPixels
   */
  @javax.annotation.Nullable
  public Integer getHeightPixels() {
    return heightPixels;
  }

  public void setHeightPixels(Integer heightPixels) {
    this.heightPixels = heightPixels;
  }


  public GetImagesRequest maxResults(Integer maxResults) {
    this.maxResults = maxResults;
    return this;
  }

  /**
   * &lt;p&gt;The maximum number of images to be returned by the API. &lt;/p&gt; &lt;note&gt; &lt;p&gt;The default limit is 25 images per API response. Providing a &lt;code&gt;MaxResults&lt;/code&gt; greater than this value will result in a page size of 25. Any additional results will be paginated. &lt;/p&gt; &lt;/note&gt;
   * minimum: 1
   * maximum: 100
   * @return maxResults
   */
  @javax.annotation.Nullable
  public Integer getMaxResults() {
    return maxResults;
  }

  public void setMaxResults(Integer maxResults) {
    this.maxResults = maxResults;
  }


  public GetImagesRequest nextToken(String nextToken) {
    this.nextToken = nextToken;
    return this;
  }

  /**
   * A token that specifies where to start paginating the next set of Images. This is the &lt;code&gt;GetImages:NextToken&lt;/code&gt; from a previously truncated response.
   * @return nextToken
   */
  @javax.annotation.Nullable
  public String getNextToken() {
    return nextToken;
  }

  public void setNextToken(String nextToken) {
    this.nextToken = nextToken;
  }



  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    GetImagesRequest getImagesRequest = (GetImagesRequest) o;
    return Objects.equals(this.streamName, getImagesRequest.streamName) &&
        Objects.equals(this.streamARN, getImagesRequest.streamARN) &&
        Objects.equals(this.imageSelectorType, getImagesRequest.imageSelectorType) &&
        Objects.equals(this.startTimestamp, getImagesRequest.startTimestamp) &&
        Objects.equals(this.endTimestamp, getImagesRequest.endTimestamp) &&
        Objects.equals(this.samplingInterval, getImagesRequest.samplingInterval) &&
        Objects.equals(this.format, getImagesRequest.format) &&
        Objects.equals(this.formatConfig, getImagesRequest.formatConfig) &&
        Objects.equals(this.widthPixels, getImagesRequest.widthPixels) &&
        Objects.equals(this.heightPixels, getImagesRequest.heightPixels) &&
        Objects.equals(this.maxResults, getImagesRequest.maxResults) &&
        Objects.equals(this.nextToken, getImagesRequest.nextToken);
  }

  @Override
  public int hashCode() {
    return Objects.hash(streamName, streamARN, imageSelectorType, startTimestamp, endTimestamp, samplingInterval, format, formatConfig, widthPixels, heightPixels, maxResults, nextToken);
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class GetImagesRequest {\n");
    sb.append("    streamName: ").append(toIndentedString(streamName)).append("\n");
    sb.append("    streamARN: ").append(toIndentedString(streamARN)).append("\n");
    sb.append("    imageSelectorType: ").append(toIndentedString(imageSelectorType)).append("\n");
    sb.append("    startTimestamp: ").append(toIndentedString(startTimestamp)).append("\n");
    sb.append("    endTimestamp: ").append(toIndentedString(endTimestamp)).append("\n");
    sb.append("    samplingInterval: ").append(toIndentedString(samplingInterval)).append("\n");
    sb.append("    format: ").append(toIndentedString(format)).append("\n");
    sb.append("    formatConfig: ").append(toIndentedString(formatConfig)).append("\n");
    sb.append("    widthPixels: ").append(toIndentedString(widthPixels)).append("\n");
    sb.append("    heightPixels: ").append(toIndentedString(heightPixels)).append("\n");
    sb.append("    maxResults: ").append(toIndentedString(maxResults)).append("\n");
    sb.append("    nextToken: ").append(toIndentedString(nextToken)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }


  public static HashSet<String> openapiFields;
  public static HashSet<String> openapiRequiredFields;

  static {
    // a set of all properties/fields (JSON key names)
    openapiFields = new HashSet<String>();
    openapiFields.add("StreamName");
    openapiFields.add("StreamARN");
    openapiFields.add("ImageSelectorType");
    openapiFields.add("StartTimestamp");
    openapiFields.add("EndTimestamp");
    openapiFields.add("SamplingInterval");
    openapiFields.add("Format");
    openapiFields.add("FormatConfig");
    openapiFields.add("WidthPixels");
    openapiFields.add("HeightPixels");
    openapiFields.add("MaxResults");
    openapiFields.add("NextToken");

    // a set of required properties/fields (JSON key names)
    openapiRequiredFields = new HashSet<String>();
    openapiRequiredFields.add("ImageSelectorType");
    openapiRequiredFields.add("StartTimestamp");
    openapiRequiredFields.add("EndTimestamp");
    openapiRequiredFields.add("Format");
  }

  /**
   * Validates the JSON Element and throws an exception if issues found
   *
   * @param jsonElement JSON Element
   * @throws IOException if the JSON Element is invalid with respect to GetImagesRequest
   */
  public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      if (jsonElement == null) {
        if (!GetImagesRequest.openapiRequiredFields.isEmpty()) { // has required fields but JSON element is null
          throw new IllegalArgumentException(String.format("The required field(s) %s in GetImagesRequest is not found in the empty JSON string", GetImagesRequest.openapiRequiredFields.toString()));
        }
      }

      Set<Map.Entry<String, JsonElement>> entries = jsonElement.getAsJsonObject().entrySet();
      // check to see if the JSON string contains additional fields
      for (Map.Entry<String, JsonElement> entry : entries) {
        if (!GetImagesRequest.openapiFields.contains(entry.getKey())) {
          throw new IllegalArgumentException(String.format("The field `%s` in the JSON string is not defined in the `GetImagesRequest` properties. JSON: %s", entry.getKey(), jsonElement.toString()));
        }
      }

      // check to make sure all required properties/fields are present in the JSON string
      for (String requiredField : GetImagesRequest.openapiRequiredFields) {
        if (jsonElement.getAsJsonObject().get(requiredField) == null) {
          throw new IllegalArgumentException(String.format("The required field `%s` is not found in the JSON string: %s", requiredField, jsonElement.toString()));
        }
      }
        JsonObject jsonObj = jsonElement.getAsJsonObject();
      if ((jsonObj.get("StreamName") != null && !jsonObj.get("StreamName").isJsonNull()) && !jsonObj.get("StreamName").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `StreamName` to be a primitive type in the JSON string but got `%s`", jsonObj.get("StreamName").toString()));
      }
      if ((jsonObj.get("StreamARN") != null && !jsonObj.get("StreamARN").isJsonNull()) && !jsonObj.get("StreamARN").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `StreamARN` to be a primitive type in the JSON string but got `%s`", jsonObj.get("StreamARN").toString()));
      }
      if (!jsonObj.get("ImageSelectorType").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `ImageSelectorType` to be a primitive type in the JSON string but got `%s`", jsonObj.get("ImageSelectorType").toString()));
      }
      // validate the required field `ImageSelectorType`
      ImageSelectorTypeEnum.validateJsonElement(jsonObj.get("ImageSelectorType"));
      if (!jsonObj.get("Format").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `Format` to be a primitive type in the JSON string but got `%s`", jsonObj.get("Format").toString()));
      }
      // validate the required field `Format`
      FormatEnum.validateJsonElement(jsonObj.get("Format"));
      if ((jsonObj.get("NextToken") != null && !jsonObj.get("NextToken").isJsonNull()) && !jsonObj.get("NextToken").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `NextToken` to be a primitive type in the JSON string but got `%s`", jsonObj.get("NextToken").toString()));
      }
  }

  public static class CustomTypeAdapterFactory implements TypeAdapterFactory {
    @SuppressWarnings("unchecked")
    @Override
    public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
       if (!GetImagesRequest.class.isAssignableFrom(type.getRawType())) {
         return null; // this class only serializes 'GetImagesRequest' and its subtypes
       }
       final TypeAdapter<JsonElement> elementAdapter = gson.getAdapter(JsonElement.class);
       final TypeAdapter<GetImagesRequest> thisAdapter
                        = gson.getDelegateAdapter(this, TypeToken.get(GetImagesRequest.class));

       return (TypeAdapter<T>) new TypeAdapter<GetImagesRequest>() {
           @Override
           public void write(JsonWriter out, GetImagesRequest value) throws IOException {
             JsonObject obj = thisAdapter.toJsonTree(value).getAsJsonObject();
             elementAdapter.write(out, obj);
           }

           @Override
           public GetImagesRequest read(JsonReader in) throws IOException {
             JsonElement jsonElement = elementAdapter.read(in);
             validateJsonElement(jsonElement);
             return thisAdapter.fromJsonTree(jsonElement);
           }

       }.nullSafe();
    }
  }

  /**
   * Create an instance of GetImagesRequest given an JSON string
   *
   * @param jsonString JSON string
   * @return An instance of GetImagesRequest
   * @throws IOException if the JSON string is invalid with respect to GetImagesRequest
   */
  public static GetImagesRequest fromJson(String jsonString) throws IOException {
    return JSON.getGson().fromJson(jsonString, GetImagesRequest.class);
  }

  /**
   * Convert an instance of GetImagesRequest to an JSON string
   *
   * @return JSON string
   */
  public String toJson() {
    return JSON.getGson().toJson(this);
  }
}

