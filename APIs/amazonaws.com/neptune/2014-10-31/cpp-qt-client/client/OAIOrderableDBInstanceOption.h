/**
 * Amazon Neptune
 * <fullname>Amazon Neptune</fullname> <p>Amazon Neptune is a fast, reliable, fully-managed graph database service that makes it easy to build and run applications that work with highly connected datasets. The core of Amazon Neptune is a purpose-built, high-performance graph database engine optimized for storing billions of relationships and querying the graph with milliseconds latency. Amazon Neptune supports popular graph models Property Graph and W3C's RDF, and their respective query languages Apache TinkerPop Gremlin and SPARQL, allowing you to easily build queries that efficiently navigate highly connected datasets. Neptune powers graph use cases such as recommendation engines, fraud detection, knowledge graphs, drug discovery, and network security.</p> <p>This interface reference for Amazon Neptune contains documentation for a programming or command line interface you can use to manage Amazon Neptune. Note that Amazon Neptune is asynchronous, which means that some interfaces might require techniques such as polling or callback functions to determine when a command has been applied. In this reference, the parameter descriptions indicate whether a command is applied immediately, on the next instance reboot, or during the maintenance window. The reference structure is as follows, and we list following some related topics from the user guide.</p>
 *
 * The version of the OpenAPI document: 2014-10-31
 * Contact: mike.ralphson@gmail.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

/*
 * OAIOrderableDBInstanceOption.h
 *
 * &lt;p&gt;Contains a list of available options for a DB instance.&lt;/p&gt; &lt;p&gt; This data type is used as a response element in the &lt;a&gt;DescribeOrderableDBInstanceOptions&lt;/a&gt; action.&lt;/p&gt;
 */

#ifndef OAIOrderableDBInstanceOption_H
#define OAIOrderableDBInstanceOption_H

#include <QJsonObject>

#include <QList>
#include <QString>

#include "OAIEnum.h"
#include "OAIObject.h"

namespace OpenAPI {

class OAIOrderableDBInstanceOption : public OAIObject {
public:
    OAIOrderableDBInstanceOption();
    OAIOrderableDBInstanceOption(QString json);
    ~OAIOrderableDBInstanceOption() override;

    QString asJson() const override;
    QJsonObject asJsonObject() const override;
    void fromJsonObject(QJsonObject json) override;
    void fromJson(QString jsonString) override;

    QString getEngine() const;
    void setEngine(const QString &engine);
    bool is_engine_Set() const;
    bool is_engine_Valid() const;

    QString getEngineVersion() const;
    void setEngineVersion(const QString &engine_version);
    bool is_engine_version_Set() const;
    bool is_engine_version_Valid() const;

    QString getDbInstanceClass() const;
    void setDbInstanceClass(const QString &db_instance_class);
    bool is_db_instance_class_Set() const;
    bool is_db_instance_class_Valid() const;

    QString getLicenseModel() const;
    void setLicenseModel(const QString &license_model);
    bool is_license_model_Set() const;
    bool is_license_model_Valid() const;

    QList getAvailabilityZones() const;
    void setAvailabilityZones(const QList &availability_zones);
    bool is_availability_zones_Set() const;
    bool is_availability_zones_Valid() const;

    bool getMultiAzCapable() const;
    void setMultiAzCapable(const bool &multi_az_capable);
    bool is_multi_az_capable_Set() const;
    bool is_multi_az_capable_Valid() const;

    bool getReadReplicaCapable() const;
    void setReadReplicaCapable(const bool &read_replica_capable);
    bool is_read_replica_capable_Set() const;
    bool is_read_replica_capable_Valid() const;

    bool getVpc() const;
    void setVpc(const bool &vpc);
    bool is_vpc_Set() const;
    bool is_vpc_Valid() const;

    bool getSupportsStorageEncryption() const;
    void setSupportsStorageEncryption(const bool &supports_storage_encryption);
    bool is_supports_storage_encryption_Set() const;
    bool is_supports_storage_encryption_Valid() const;

    QString getStorageType() const;
    void setStorageType(const QString &storage_type);
    bool is_storage_type_Set() const;
    bool is_storage_type_Valid() const;

    bool getSupportsIops() const;
    void setSupportsIops(const bool &supports_iops);
    bool is_supports_iops_Set() const;
    bool is_supports_iops_Valid() const;

    bool getSupportsEnhancedMonitoring() const;
    void setSupportsEnhancedMonitoring(const bool &supports_enhanced_monitoring);
    bool is_supports_enhanced_monitoring_Set() const;
    bool is_supports_enhanced_monitoring_Valid() const;

    bool getSupportsIamDatabaseAuthentication() const;
    void setSupportsIamDatabaseAuthentication(const bool &supports_iam_database_authentication);
    bool is_supports_iam_database_authentication_Set() const;
    bool is_supports_iam_database_authentication_Valid() const;

    bool getSupportsPerformanceInsights() const;
    void setSupportsPerformanceInsights(const bool &supports_performance_insights);
    bool is_supports_performance_insights_Set() const;
    bool is_supports_performance_insights_Valid() const;

    qint32 getMinStorageSize() const;
    void setMinStorageSize(const qint32 &min_storage_size);
    bool is_min_storage_size_Set() const;
    bool is_min_storage_size_Valid() const;

    qint32 getMaxStorageSize() const;
    void setMaxStorageSize(const qint32 &max_storage_size);
    bool is_max_storage_size_Set() const;
    bool is_max_storage_size_Valid() const;

    qint32 getMinIopsPerDbInstance() const;
    void setMinIopsPerDbInstance(const qint32 &min_iops_per_db_instance);
    bool is_min_iops_per_db_instance_Set() const;
    bool is_min_iops_per_db_instance_Valid() const;

    qint32 getMaxIopsPerDbInstance() const;
    void setMaxIopsPerDbInstance(const qint32 &max_iops_per_db_instance);
    bool is_max_iops_per_db_instance_Set() const;
    bool is_max_iops_per_db_instance_Valid() const;

    double getMinIopsPerGib() const;
    void setMinIopsPerGib(const double &min_iops_per_gib);
    bool is_min_iops_per_gib_Set() const;
    bool is_min_iops_per_gib_Valid() const;

    double getMaxIopsPerGib() const;
    void setMaxIopsPerGib(const double &max_iops_per_gib);
    bool is_max_iops_per_gib_Set() const;
    bool is_max_iops_per_gib_Valid() const;

    bool getSupportsGlobalDatabases() const;
    void setSupportsGlobalDatabases(const bool &supports_global_databases);
    bool is_supports_global_databases_Set() const;
    bool is_supports_global_databases_Valid() const;

    virtual bool isSet() const override;
    virtual bool isValid() const override;

private:
    void initializeModel();

    QString m_engine;
    bool m_engine_isSet;
    bool m_engine_isValid;

    QString m_engine_version;
    bool m_engine_version_isSet;
    bool m_engine_version_isValid;

    QString m_db_instance_class;
    bool m_db_instance_class_isSet;
    bool m_db_instance_class_isValid;

    QString m_license_model;
    bool m_license_model_isSet;
    bool m_license_model_isValid;

    QList m_availability_zones;
    bool m_availability_zones_isSet;
    bool m_availability_zones_isValid;

    bool m_multi_az_capable;
    bool m_multi_az_capable_isSet;
    bool m_multi_az_capable_isValid;

    bool m_read_replica_capable;
    bool m_read_replica_capable_isSet;
    bool m_read_replica_capable_isValid;

    bool m_vpc;
    bool m_vpc_isSet;
    bool m_vpc_isValid;

    bool m_supports_storage_encryption;
    bool m_supports_storage_encryption_isSet;
    bool m_supports_storage_encryption_isValid;

    QString m_storage_type;
    bool m_storage_type_isSet;
    bool m_storage_type_isValid;

    bool m_supports_iops;
    bool m_supports_iops_isSet;
    bool m_supports_iops_isValid;

    bool m_supports_enhanced_monitoring;
    bool m_supports_enhanced_monitoring_isSet;
    bool m_supports_enhanced_monitoring_isValid;

    bool m_supports_iam_database_authentication;
    bool m_supports_iam_database_authentication_isSet;
    bool m_supports_iam_database_authentication_isValid;

    bool m_supports_performance_insights;
    bool m_supports_performance_insights_isSet;
    bool m_supports_performance_insights_isValid;

    qint32 m_min_storage_size;
    bool m_min_storage_size_isSet;
    bool m_min_storage_size_isValid;

    qint32 m_max_storage_size;
    bool m_max_storage_size_isSet;
    bool m_max_storage_size_isValid;

    qint32 m_min_iops_per_db_instance;
    bool m_min_iops_per_db_instance_isSet;
    bool m_min_iops_per_db_instance_isValid;

    qint32 m_max_iops_per_db_instance;
    bool m_max_iops_per_db_instance_isSet;
    bool m_max_iops_per_db_instance_isValid;

    double m_min_iops_per_gib;
    bool m_min_iops_per_gib_isSet;
    bool m_min_iops_per_gib_isValid;

    double m_max_iops_per_gib;
    bool m_max_iops_per_gib_isSet;
    bool m_max_iops_per_gib_isValid;

    bool m_supports_global_databases;
    bool m_supports_global_databases_isSet;
    bool m_supports_global_databases_isValid;
};

} // namespace OpenAPI

Q_DECLARE_METATYPE(OpenAPI::OAIOrderableDBInstanceOption)

#endif // OAIOrderableDBInstanceOption_H
