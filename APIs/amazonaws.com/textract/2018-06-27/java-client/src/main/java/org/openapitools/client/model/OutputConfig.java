/*
 * Amazon Textract
 * Amazon Textract detects and analyzes text in documents and converts it into machine-readable text. This is the API reference documentation for Amazon Textract.
 *
 * The version of the OpenAPI document: 2018-06-27
 * Contact: mike.ralphson@gmail.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package org.openapitools.client.model;

import java.util.Objects;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;
import java.util.Arrays;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonArray;
import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;
import com.google.gson.TypeAdapterFactory;
import com.google.gson.reflect.TypeToken;
import com.google.gson.TypeAdapter;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;

import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import org.openapitools.client.JSON;

/**
 * &lt;p&gt;Sets whether or not your output will go to a user created bucket. Used to set the name of the bucket, and the prefix on the output file.&lt;/p&gt; &lt;p&gt; &lt;code&gt;OutputConfig&lt;/code&gt; is an optional parameter which lets you adjust where your output will be placed. By default, Amazon Textract will store the results internally and can only be accessed by the Get API operations. With &lt;code&gt;OutputConfig&lt;/code&gt; enabled, you can set the name of the bucket the output will be sent to the file prefix of the results where you can download your results. Additionally, you can set the &lt;code&gt;KMSKeyID&lt;/code&gt; parameter to a customer master key (CMK) to encrypt your output. Without this parameter set Amazon Textract will encrypt server-side using the AWS managed CMK for Amazon S3.&lt;/p&gt; &lt;p&gt;Decryption of Customer Content is necessary for processing of the documents by Amazon Textract. If your account is opted out under an AI services opt out policy then all unencrypted Customer Content is immediately and permanently deleted after the Customer Content has been processed by the service. No copy of of the output is retained by Amazon Textract. For information about how to opt out, see &lt;a href&#x3D;\&quot;https://docs.aws.amazon.com/organizations/latest/userguide/orgs_manage_policies_ai-opt-out.html\&quot;&gt; Managing AI services opt-out policy. &lt;/a&gt; &lt;/p&gt; &lt;p&gt;For more information on data privacy, see the &lt;a href&#x3D;\&quot;https://aws.amazon.com/compliance/data-privacy-faq/\&quot;&gt;Data Privacy FAQ&lt;/a&gt;.&lt;/p&gt;
 */
@javax.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen", date = "2024-10-12T12:09:42.141552-04:00[America/New_York]", comments = "Generator version: 7.9.0")
public class OutputConfig {
  public static final String SERIALIZED_NAME_S3_BUCKET = "S3Bucket";
  @SerializedName(SERIALIZED_NAME_S3_BUCKET)
  private String s3Bucket;

  public static final String SERIALIZED_NAME_S3_PREFIX = "S3Prefix";
  @SerializedName(SERIALIZED_NAME_S3_PREFIX)
  private String s3Prefix;

  public OutputConfig() {
  }

  public OutputConfig s3Bucket(String s3Bucket) {
    this.s3Bucket = s3Bucket;
    return this;
  }

  /**
   * Get s3Bucket
   * @return s3Bucket
   */
  @javax.annotation.Nonnull
  public String getS3Bucket() {
    return s3Bucket;
  }

  public void setS3Bucket(String s3Bucket) {
    this.s3Bucket = s3Bucket;
  }


  public OutputConfig s3Prefix(String s3Prefix) {
    this.s3Prefix = s3Prefix;
    return this;
  }

  /**
   * Get s3Prefix
   * @return s3Prefix
   */
  @javax.annotation.Nullable
  public String getS3Prefix() {
    return s3Prefix;
  }

  public void setS3Prefix(String s3Prefix) {
    this.s3Prefix = s3Prefix;
  }



  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    OutputConfig outputConfig = (OutputConfig) o;
    return Objects.equals(this.s3Bucket, outputConfig.s3Bucket) &&
        Objects.equals(this.s3Prefix, outputConfig.s3Prefix);
  }

  @Override
  public int hashCode() {
    return Objects.hash(s3Bucket, s3Prefix);
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class OutputConfig {\n");
    sb.append("    s3Bucket: ").append(toIndentedString(s3Bucket)).append("\n");
    sb.append("    s3Prefix: ").append(toIndentedString(s3Prefix)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }


  public static HashSet<String> openapiFields;
  public static HashSet<String> openapiRequiredFields;

  static {
    // a set of all properties/fields (JSON key names)
    openapiFields = new HashSet<String>();
    openapiFields.add("S3Bucket");
    openapiFields.add("S3Prefix");

    // a set of required properties/fields (JSON key names)
    openapiRequiredFields = new HashSet<String>();
    openapiRequiredFields.add("S3Bucket");
  }

  /**
   * Validates the JSON Element and throws an exception if issues found
   *
   * @param jsonElement JSON Element
   * @throws IOException if the JSON Element is invalid with respect to OutputConfig
   */
  public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      if (jsonElement == null) {
        if (!OutputConfig.openapiRequiredFields.isEmpty()) { // has required fields but JSON element is null
          throw new IllegalArgumentException(String.format("The required field(s) %s in OutputConfig is not found in the empty JSON string", OutputConfig.openapiRequiredFields.toString()));
        }
      }

      Set<Map.Entry<String, JsonElement>> entries = jsonElement.getAsJsonObject().entrySet();
      // check to see if the JSON string contains additional fields
      for (Map.Entry<String, JsonElement> entry : entries) {
        if (!OutputConfig.openapiFields.contains(entry.getKey())) {
          throw new IllegalArgumentException(String.format("The field `%s` in the JSON string is not defined in the `OutputConfig` properties. JSON: %s", entry.getKey(), jsonElement.toString()));
        }
      }

      // check to make sure all required properties/fields are present in the JSON string
      for (String requiredField : OutputConfig.openapiRequiredFields) {
        if (jsonElement.getAsJsonObject().get(requiredField) == null) {
          throw new IllegalArgumentException(String.format("The required field `%s` is not found in the JSON string: %s", requiredField, jsonElement.toString()));
        }
      }
        JsonObject jsonObj = jsonElement.getAsJsonObject();
      // validate the required field `S3Bucket`
      String.validateJsonElement(jsonObj.get("S3Bucket"));
      // validate the optional field `S3Prefix`
      if (jsonObj.get("S3Prefix") != null && !jsonObj.get("S3Prefix").isJsonNull()) {
        String.validateJsonElement(jsonObj.get("S3Prefix"));
      }
  }

  public static class CustomTypeAdapterFactory implements TypeAdapterFactory {
    @SuppressWarnings("unchecked")
    @Override
    public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
       if (!OutputConfig.class.isAssignableFrom(type.getRawType())) {
         return null; // this class only serializes 'OutputConfig' and its subtypes
       }
       final TypeAdapter<JsonElement> elementAdapter = gson.getAdapter(JsonElement.class);
       final TypeAdapter<OutputConfig> thisAdapter
                        = gson.getDelegateAdapter(this, TypeToken.get(OutputConfig.class));

       return (TypeAdapter<T>) new TypeAdapter<OutputConfig>() {
           @Override
           public void write(JsonWriter out, OutputConfig value) throws IOException {
             JsonObject obj = thisAdapter.toJsonTree(value).getAsJsonObject();
             elementAdapter.write(out, obj);
           }

           @Override
           public OutputConfig read(JsonReader in) throws IOException {
             JsonElement jsonElement = elementAdapter.read(in);
             validateJsonElement(jsonElement);
             return thisAdapter.fromJsonTree(jsonElement);
           }

       }.nullSafe();
    }
  }

  /**
   * Create an instance of OutputConfig given an JSON string
   *
   * @param jsonString JSON string
   * @return An instance of OutputConfig
   * @throws IOException if the JSON string is invalid with respect to OutputConfig
   */
  public static OutputConfig fromJson(String jsonString) throws IOException {
    return JSON.getGson().fromJson(jsonString, OutputConfig.class);
  }

  /**
   * Convert an instance of OutputConfig to an JSON string
   *
   * @return JSON string
   */
  public String toJson() {
    return JSON.getGson().toJson(this);
  }
}

