/*
 * Amazon Textract
 * Amazon Textract detects and analyzes text in documents and converts it into machine-readable text. This is the API reference documentation for Amazon Textract.
 *
 * The version of the OpenAPI document: 2018-06-27
 * Contact: mike.ralphson@gmail.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package org.openapitools.client.model;

import java.util.Objects;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;
import java.util.Arrays;
import java.util.List;
import org.openapitools.client.model.BlockGeometry;
import org.openapitools.client.model.BlockQuery;
import org.openapitools.client.model.BlockType;
import org.openapitools.client.model.SelectionStatus;
import org.openapitools.client.model.TextType;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonArray;
import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;
import com.google.gson.TypeAdapterFactory;
import com.google.gson.reflect.TypeToken;
import com.google.gson.TypeAdapter;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;

import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import org.openapitools.client.JSON;

/**
 * &lt;p&gt;A &lt;code&gt;Block&lt;/code&gt; represents items that are recognized in a document within a group of pixels close to each other. The information returned in a &lt;code&gt;Block&lt;/code&gt; object depends on the type of operation. In text detection for documents (for example &lt;a&gt;DetectDocumentText&lt;/a&gt;), you get information about the detected words and lines of text. In text analysis (for example &lt;a&gt;AnalyzeDocument&lt;/a&gt;), you can also get information about the fields, tables, and selection elements that are detected in the document.&lt;/p&gt; &lt;p&gt;An array of &lt;code&gt;Block&lt;/code&gt; objects is returned by both synchronous and asynchronous operations. In synchronous operations, such as &lt;a&gt;DetectDocumentText&lt;/a&gt;, the array of &lt;code&gt;Block&lt;/code&gt; objects is the entire set of results. In asynchronous operations, such as &lt;a&gt;GetDocumentAnalysis&lt;/a&gt;, the array is returned over one or more responses.&lt;/p&gt; &lt;p&gt;For more information, see &lt;a href&#x3D;\&quot;https://docs.aws.amazon.com/textract/latest/dg/how-it-works.html\&quot;&gt;How Amazon Textract Works&lt;/a&gt;.&lt;/p&gt;
 */
@javax.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen", date = "2024-10-12T12:09:42.141552-04:00[America/New_York]", comments = "Generator version: 7.9.0")
public class Block {
  public static final String SERIALIZED_NAME_BLOCK_TYPE = "BlockType";
  @SerializedName(SERIALIZED_NAME_BLOCK_TYPE)
  private BlockType blockType;

  public static final String SERIALIZED_NAME_CONFIDENCE = "Confidence";
  @SerializedName(SERIALIZED_NAME_CONFIDENCE)
  private Float confidence;

  public static final String SERIALIZED_NAME_TEXT = "Text";
  @SerializedName(SERIALIZED_NAME_TEXT)
  private String text;

  public static final String SERIALIZED_NAME_TEXT_TYPE = "TextType";
  @SerializedName(SERIALIZED_NAME_TEXT_TYPE)
  private TextType textType;

  public static final String SERIALIZED_NAME_ROW_INDEX = "RowIndex";
  @SerializedName(SERIALIZED_NAME_ROW_INDEX)
  private Integer rowIndex;

  public static final String SERIALIZED_NAME_COLUMN_INDEX = "ColumnIndex";
  @SerializedName(SERIALIZED_NAME_COLUMN_INDEX)
  private Integer columnIndex;

  public static final String SERIALIZED_NAME_ROW_SPAN = "RowSpan";
  @SerializedName(SERIALIZED_NAME_ROW_SPAN)
  private Integer rowSpan;

  public static final String SERIALIZED_NAME_COLUMN_SPAN = "ColumnSpan";
  @SerializedName(SERIALIZED_NAME_COLUMN_SPAN)
  private Integer columnSpan;

  public static final String SERIALIZED_NAME_GEOMETRY = "Geometry";
  @SerializedName(SERIALIZED_NAME_GEOMETRY)
  private BlockGeometry geometry;

  public static final String SERIALIZED_NAME_ID = "Id";
  @SerializedName(SERIALIZED_NAME_ID)
  private String id;

  public static final String SERIALIZED_NAME_RELATIONSHIPS = "Relationships";
  @SerializedName(SERIALIZED_NAME_RELATIONSHIPS)
  private List relationships;

  public static final String SERIALIZED_NAME_ENTITY_TYPES = "EntityTypes";
  @SerializedName(SERIALIZED_NAME_ENTITY_TYPES)
  private List entityTypes;

  public static final String SERIALIZED_NAME_SELECTION_STATUS = "SelectionStatus";
  @SerializedName(SERIALIZED_NAME_SELECTION_STATUS)
  private SelectionStatus selectionStatus;

  public static final String SERIALIZED_NAME_PAGE = "Page";
  @SerializedName(SERIALIZED_NAME_PAGE)
  private Integer page;

  public static final String SERIALIZED_NAME_QUERY = "Query";
  @SerializedName(SERIALIZED_NAME_QUERY)
  private BlockQuery query;

  public Block() {
  }

  public Block blockType(BlockType blockType) {
    this.blockType = blockType;
    return this;
  }

  /**
   * Get blockType
   * @return blockType
   */
  @javax.annotation.Nullable
  public BlockType getBlockType() {
    return blockType;
  }

  public void setBlockType(BlockType blockType) {
    this.blockType = blockType;
  }


  public Block confidence(Float confidence) {
    this.confidence = confidence;
    return this;
  }

  /**
   * Get confidence
   * @return confidence
   */
  @javax.annotation.Nullable
  public Float getConfidence() {
    return confidence;
  }

  public void setConfidence(Float confidence) {
    this.confidence = confidence;
  }


  public Block text(String text) {
    this.text = text;
    return this;
  }

  /**
   * Get text
   * @return text
   */
  @javax.annotation.Nullable
  public String getText() {
    return text;
  }

  public void setText(String text) {
    this.text = text;
  }


  public Block textType(TextType textType) {
    this.textType = textType;
    return this;
  }

  /**
   * Get textType
   * @return textType
   */
  @javax.annotation.Nullable
  public TextType getTextType() {
    return textType;
  }

  public void setTextType(TextType textType) {
    this.textType = textType;
  }


  public Block rowIndex(Integer rowIndex) {
    this.rowIndex = rowIndex;
    return this;
  }

  /**
   * Get rowIndex
   * @return rowIndex
   */
  @javax.annotation.Nullable
  public Integer getRowIndex() {
    return rowIndex;
  }

  public void setRowIndex(Integer rowIndex) {
    this.rowIndex = rowIndex;
  }


  public Block columnIndex(Integer columnIndex) {
    this.columnIndex = columnIndex;
    return this;
  }

  /**
   * Get columnIndex
   * @return columnIndex
   */
  @javax.annotation.Nullable
  public Integer getColumnIndex() {
    return columnIndex;
  }

  public void setColumnIndex(Integer columnIndex) {
    this.columnIndex = columnIndex;
  }


  public Block rowSpan(Integer rowSpan) {
    this.rowSpan = rowSpan;
    return this;
  }

  /**
   * Get rowSpan
   * @return rowSpan
   */
  @javax.annotation.Nullable
  public Integer getRowSpan() {
    return rowSpan;
  }

  public void setRowSpan(Integer rowSpan) {
    this.rowSpan = rowSpan;
  }


  public Block columnSpan(Integer columnSpan) {
    this.columnSpan = columnSpan;
    return this;
  }

  /**
   * Get columnSpan
   * @return columnSpan
   */
  @javax.annotation.Nullable
  public Integer getColumnSpan() {
    return columnSpan;
  }

  public void setColumnSpan(Integer columnSpan) {
    this.columnSpan = columnSpan;
  }


  public Block geometry(BlockGeometry geometry) {
    this.geometry = geometry;
    return this;
  }

  /**
   * Get geometry
   * @return geometry
   */
  @javax.annotation.Nullable
  public BlockGeometry getGeometry() {
    return geometry;
  }

  public void setGeometry(BlockGeometry geometry) {
    this.geometry = geometry;
  }


  public Block id(String id) {
    this.id = id;
    return this;
  }

  /**
   * Get id
   * @return id
   */
  @javax.annotation.Nullable
  public String getId() {
    return id;
  }

  public void setId(String id) {
    this.id = id;
  }


  public Block relationships(List relationships) {
    this.relationships = relationships;
    return this;
  }

  /**
   * Get relationships
   * @return relationships
   */
  @javax.annotation.Nullable
  public List getRelationships() {
    return relationships;
  }

  public void setRelationships(List relationships) {
    this.relationships = relationships;
  }


  public Block entityTypes(List entityTypes) {
    this.entityTypes = entityTypes;
    return this;
  }

  /**
   * Get entityTypes
   * @return entityTypes
   */
  @javax.annotation.Nullable
  public List getEntityTypes() {
    return entityTypes;
  }

  public void setEntityTypes(List entityTypes) {
    this.entityTypes = entityTypes;
  }


  public Block selectionStatus(SelectionStatus selectionStatus) {
    this.selectionStatus = selectionStatus;
    return this;
  }

  /**
   * Get selectionStatus
   * @return selectionStatus
   */
  @javax.annotation.Nullable
  public SelectionStatus getSelectionStatus() {
    return selectionStatus;
  }

  public void setSelectionStatus(SelectionStatus selectionStatus) {
    this.selectionStatus = selectionStatus;
  }


  public Block page(Integer page) {
    this.page = page;
    return this;
  }

  /**
   * Get page
   * @return page
   */
  @javax.annotation.Nullable
  public Integer getPage() {
    return page;
  }

  public void setPage(Integer page) {
    this.page = page;
  }


  public Block query(BlockQuery query) {
    this.query = query;
    return this;
  }

  /**
   * Get query
   * @return query
   */
  @javax.annotation.Nullable
  public BlockQuery getQuery() {
    return query;
  }

  public void setQuery(BlockQuery query) {
    this.query = query;
  }



  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    Block block = (Block) o;
    return Objects.equals(this.blockType, block.blockType) &&
        Objects.equals(this.confidence, block.confidence) &&
        Objects.equals(this.text, block.text) &&
        Objects.equals(this.textType, block.textType) &&
        Objects.equals(this.rowIndex, block.rowIndex) &&
        Objects.equals(this.columnIndex, block.columnIndex) &&
        Objects.equals(this.rowSpan, block.rowSpan) &&
        Objects.equals(this.columnSpan, block.columnSpan) &&
        Objects.equals(this.geometry, block.geometry) &&
        Objects.equals(this.id, block.id) &&
        Objects.equals(this.relationships, block.relationships) &&
        Objects.equals(this.entityTypes, block.entityTypes) &&
        Objects.equals(this.selectionStatus, block.selectionStatus) &&
        Objects.equals(this.page, block.page) &&
        Objects.equals(this.query, block.query);
  }

  @Override
  public int hashCode() {
    return Objects.hash(blockType, confidence, text, textType, rowIndex, columnIndex, rowSpan, columnSpan, geometry, id, relationships, entityTypes, selectionStatus, page, query);
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class Block {\n");
    sb.append("    blockType: ").append(toIndentedString(blockType)).append("\n");
    sb.append("    confidence: ").append(toIndentedString(confidence)).append("\n");
    sb.append("    text: ").append(toIndentedString(text)).append("\n");
    sb.append("    textType: ").append(toIndentedString(textType)).append("\n");
    sb.append("    rowIndex: ").append(toIndentedString(rowIndex)).append("\n");
    sb.append("    columnIndex: ").append(toIndentedString(columnIndex)).append("\n");
    sb.append("    rowSpan: ").append(toIndentedString(rowSpan)).append("\n");
    sb.append("    columnSpan: ").append(toIndentedString(columnSpan)).append("\n");
    sb.append("    geometry: ").append(toIndentedString(geometry)).append("\n");
    sb.append("    id: ").append(toIndentedString(id)).append("\n");
    sb.append("    relationships: ").append(toIndentedString(relationships)).append("\n");
    sb.append("    entityTypes: ").append(toIndentedString(entityTypes)).append("\n");
    sb.append("    selectionStatus: ").append(toIndentedString(selectionStatus)).append("\n");
    sb.append("    page: ").append(toIndentedString(page)).append("\n");
    sb.append("    query: ").append(toIndentedString(query)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }


  public static HashSet<String> openapiFields;
  public static HashSet<String> openapiRequiredFields;

  static {
    // a set of all properties/fields (JSON key names)
    openapiFields = new HashSet<String>();
    openapiFields.add("BlockType");
    openapiFields.add("Confidence");
    openapiFields.add("Text");
    openapiFields.add("TextType");
    openapiFields.add("RowIndex");
    openapiFields.add("ColumnIndex");
    openapiFields.add("RowSpan");
    openapiFields.add("ColumnSpan");
    openapiFields.add("Geometry");
    openapiFields.add("Id");
    openapiFields.add("Relationships");
    openapiFields.add("EntityTypes");
    openapiFields.add("SelectionStatus");
    openapiFields.add("Page");
    openapiFields.add("Query");

    // a set of required properties/fields (JSON key names)
    openapiRequiredFields = new HashSet<String>();
  }

  /**
   * Validates the JSON Element and throws an exception if issues found
   *
   * @param jsonElement JSON Element
   * @throws IOException if the JSON Element is invalid with respect to Block
   */
  public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      if (jsonElement == null) {
        if (!Block.openapiRequiredFields.isEmpty()) { // has required fields but JSON element is null
          throw new IllegalArgumentException(String.format("The required field(s) %s in Block is not found in the empty JSON string", Block.openapiRequiredFields.toString()));
        }
      }

      Set<Map.Entry<String, JsonElement>> entries = jsonElement.getAsJsonObject().entrySet();
      // check to see if the JSON string contains additional fields
      for (Map.Entry<String, JsonElement> entry : entries) {
        if (!Block.openapiFields.contains(entry.getKey())) {
          throw new IllegalArgumentException(String.format("The field `%s` in the JSON string is not defined in the `Block` properties. JSON: %s", entry.getKey(), jsonElement.toString()));
        }
      }
        JsonObject jsonObj = jsonElement.getAsJsonObject();
      // validate the optional field `BlockType`
      if (jsonObj.get("BlockType") != null && !jsonObj.get("BlockType").isJsonNull()) {
        BlockType.validateJsonElement(jsonObj.get("BlockType"));
      }
      // validate the optional field `Confidence`
      if (jsonObj.get("Confidence") != null && !jsonObj.get("Confidence").isJsonNull()) {
        Float.validateJsonElement(jsonObj.get("Confidence"));
      }
      // validate the optional field `Text`
      if (jsonObj.get("Text") != null && !jsonObj.get("Text").isJsonNull()) {
        String.validateJsonElement(jsonObj.get("Text"));
      }
      // validate the optional field `TextType`
      if (jsonObj.get("TextType") != null && !jsonObj.get("TextType").isJsonNull()) {
        TextType.validateJsonElement(jsonObj.get("TextType"));
      }
      // validate the optional field `RowIndex`
      if (jsonObj.get("RowIndex") != null && !jsonObj.get("RowIndex").isJsonNull()) {
        Integer.validateJsonElement(jsonObj.get("RowIndex"));
      }
      // validate the optional field `ColumnIndex`
      if (jsonObj.get("ColumnIndex") != null && !jsonObj.get("ColumnIndex").isJsonNull()) {
        Integer.validateJsonElement(jsonObj.get("ColumnIndex"));
      }
      // validate the optional field `RowSpan`
      if (jsonObj.get("RowSpan") != null && !jsonObj.get("RowSpan").isJsonNull()) {
        Integer.validateJsonElement(jsonObj.get("RowSpan"));
      }
      // validate the optional field `ColumnSpan`
      if (jsonObj.get("ColumnSpan") != null && !jsonObj.get("ColumnSpan").isJsonNull()) {
        Integer.validateJsonElement(jsonObj.get("ColumnSpan"));
      }
      // validate the optional field `Geometry`
      if (jsonObj.get("Geometry") != null && !jsonObj.get("Geometry").isJsonNull()) {
        BlockGeometry.validateJsonElement(jsonObj.get("Geometry"));
      }
      // validate the optional field `Id`
      if (jsonObj.get("Id") != null && !jsonObj.get("Id").isJsonNull()) {
        String.validateJsonElement(jsonObj.get("Id"));
      }
      // validate the optional field `Relationships`
      if (jsonObj.get("Relationships") != null && !jsonObj.get("Relationships").isJsonNull()) {
        List.validateJsonElement(jsonObj.get("Relationships"));
      }
      // validate the optional field `EntityTypes`
      if (jsonObj.get("EntityTypes") != null && !jsonObj.get("EntityTypes").isJsonNull()) {
        List.validateJsonElement(jsonObj.get("EntityTypes"));
      }
      // validate the optional field `SelectionStatus`
      if (jsonObj.get("SelectionStatus") != null && !jsonObj.get("SelectionStatus").isJsonNull()) {
        SelectionStatus.validateJsonElement(jsonObj.get("SelectionStatus"));
      }
      // validate the optional field `Page`
      if (jsonObj.get("Page") != null && !jsonObj.get("Page").isJsonNull()) {
        Integer.validateJsonElement(jsonObj.get("Page"));
      }
      // validate the optional field `Query`
      if (jsonObj.get("Query") != null && !jsonObj.get("Query").isJsonNull()) {
        BlockQuery.validateJsonElement(jsonObj.get("Query"));
      }
  }

  public static class CustomTypeAdapterFactory implements TypeAdapterFactory {
    @SuppressWarnings("unchecked")
    @Override
    public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
       if (!Block.class.isAssignableFrom(type.getRawType())) {
         return null; // this class only serializes 'Block' and its subtypes
       }
       final TypeAdapter<JsonElement> elementAdapter = gson.getAdapter(JsonElement.class);
       final TypeAdapter<Block> thisAdapter
                        = gson.getDelegateAdapter(this, TypeToken.get(Block.class));

       return (TypeAdapter<T>) new TypeAdapter<Block>() {
           @Override
           public void write(JsonWriter out, Block value) throws IOException {
             JsonObject obj = thisAdapter.toJsonTree(value).getAsJsonObject();
             elementAdapter.write(out, obj);
           }

           @Override
           public Block read(JsonReader in) throws IOException {
             JsonElement jsonElement = elementAdapter.read(in);
             validateJsonElement(jsonElement);
             return thisAdapter.fromJsonTree(jsonElement);
           }

       }.nullSafe();
    }
  }

  /**
   * Create an instance of Block given an JSON string
   *
   * @param jsonString JSON string
   * @return An instance of Block
   * @throws IOException if the JSON string is invalid with respect to Block
   */
  public static Block fromJson(String jsonString) throws IOException {
    return JSON.getGson().fromJson(jsonString, Block.class);
  }

  /**
   * Convert an instance of Block to an JSON string
   *
   * @return JSON string
   */
  public String toJson() {
    return JSON.getGson().toJson(this);
  }
}

