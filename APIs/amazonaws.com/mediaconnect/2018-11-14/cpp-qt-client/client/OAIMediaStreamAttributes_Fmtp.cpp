/**
 * AWS MediaConnect
 * API for AWS Elemental MediaConnect
 *
 * The version of the OpenAPI document: 2018-11-14
 * Contact: mike.ralphson@gmail.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

#include "OAIMediaStreamAttributes_Fmtp.h"

#include <QDebug>
#include <QJsonArray>
#include <QJsonDocument>
#include <QObject>

#include "OAIHelpers.h"

namespace OpenAPI {

OAIMediaStreamAttributes_Fmtp::OAIMediaStreamAttributes_Fmtp(QString json) {
    this->initializeModel();
    this->fromJson(json);
}

OAIMediaStreamAttributes_Fmtp::OAIMediaStreamAttributes_Fmtp() {
    this->initializeModel();
}

OAIMediaStreamAttributes_Fmtp::~OAIMediaStreamAttributes_Fmtp() {}

void OAIMediaStreamAttributes_Fmtp::initializeModel() {

    m_channel_order_isSet = false;
    m_channel_order_isValid = false;

    m_colorimetry_isSet = false;
    m_colorimetry_isValid = false;

    m_exact_framerate_isSet = false;
    m_exact_framerate_isValid = false;

    m_par_isSet = false;
    m_par_isValid = false;

    m_range_isSet = false;
    m_range_isValid = false;

    m_scan_mode_isSet = false;
    m_scan_mode_isValid = false;

    m_tcs_isSet = false;
    m_tcs_isValid = false;
}

void OAIMediaStreamAttributes_Fmtp::fromJson(QString jsonString) {
    QByteArray array(jsonString.toStdString().c_str());
    QJsonDocument doc = QJsonDocument::fromJson(array);
    QJsonObject jsonObject = doc.object();
    this->fromJsonObject(jsonObject);
}

void OAIMediaStreamAttributes_Fmtp::fromJsonObject(QJsonObject json) {

    m_channel_order_isValid = ::OpenAPI::fromJsonValue(m_channel_order, json[QString("ChannelOrder")]);
    m_channel_order_isSet = !json[QString("ChannelOrder")].isNull() && m_channel_order_isValid;

    m_colorimetry_isValid = ::OpenAPI::fromJsonValue(m_colorimetry, json[QString("Colorimetry")]);
    m_colorimetry_isSet = !json[QString("Colorimetry")].isNull() && m_colorimetry_isValid;

    m_exact_framerate_isValid = ::OpenAPI::fromJsonValue(m_exact_framerate, json[QString("ExactFramerate")]);
    m_exact_framerate_isSet = !json[QString("ExactFramerate")].isNull() && m_exact_framerate_isValid;

    m_par_isValid = ::OpenAPI::fromJsonValue(m_par, json[QString("Par")]);
    m_par_isSet = !json[QString("Par")].isNull() && m_par_isValid;

    m_range_isValid = ::OpenAPI::fromJsonValue(m_range, json[QString("Range")]);
    m_range_isSet = !json[QString("Range")].isNull() && m_range_isValid;

    m_scan_mode_isValid = ::OpenAPI::fromJsonValue(m_scan_mode, json[QString("ScanMode")]);
    m_scan_mode_isSet = !json[QString("ScanMode")].isNull() && m_scan_mode_isValid;

    m_tcs_isValid = ::OpenAPI::fromJsonValue(m_tcs, json[QString("Tcs")]);
    m_tcs_isSet = !json[QString("Tcs")].isNull() && m_tcs_isValid;
}

QString OAIMediaStreamAttributes_Fmtp::asJson() const {
    QJsonObject obj = this->asJsonObject();
    QJsonDocument doc(obj);
    QByteArray bytes = doc.toJson();
    return QString(bytes);
}

QJsonObject OAIMediaStreamAttributes_Fmtp::asJsonObject() const {
    QJsonObject obj;
    if (m_channel_order_isSet) {
        obj.insert(QString("ChannelOrder"), ::OpenAPI::toJsonValue(m_channel_order));
    }
    if (m_colorimetry.isSet()) {
        obj.insert(QString("Colorimetry"), ::OpenAPI::toJsonValue(m_colorimetry));
    }
    if (m_exact_framerate_isSet) {
        obj.insert(QString("ExactFramerate"), ::OpenAPI::toJsonValue(m_exact_framerate));
    }
    if (m_par_isSet) {
        obj.insert(QString("Par"), ::OpenAPI::toJsonValue(m_par));
    }
    if (m_range.isSet()) {
        obj.insert(QString("Range"), ::OpenAPI::toJsonValue(m_range));
    }
    if (m_scan_mode.isSet()) {
        obj.insert(QString("ScanMode"), ::OpenAPI::toJsonValue(m_scan_mode));
    }
    if (m_tcs.isSet()) {
        obj.insert(QString("Tcs"), ::OpenAPI::toJsonValue(m_tcs));
    }
    return obj;
}

QString OAIMediaStreamAttributes_Fmtp::getChannelOrder() const {
    return m_channel_order;
}
void OAIMediaStreamAttributes_Fmtp::setChannelOrder(const QString &channel_order) {
    m_channel_order = channel_order;
    m_channel_order_isSet = true;
}

bool OAIMediaStreamAttributes_Fmtp::is_channel_order_Set() const{
    return m_channel_order_isSet;
}

bool OAIMediaStreamAttributes_Fmtp::is_channel_order_Valid() const{
    return m_channel_order_isValid;
}

OAIColorimetry OAIMediaStreamAttributes_Fmtp::getColorimetry() const {
    return m_colorimetry;
}
void OAIMediaStreamAttributes_Fmtp::setColorimetry(const OAIColorimetry &colorimetry) {
    m_colorimetry = colorimetry;
    m_colorimetry_isSet = true;
}

bool OAIMediaStreamAttributes_Fmtp::is_colorimetry_Set() const{
    return m_colorimetry_isSet;
}

bool OAIMediaStreamAttributes_Fmtp::is_colorimetry_Valid() const{
    return m_colorimetry_isValid;
}

QString OAIMediaStreamAttributes_Fmtp::getExactFramerate() const {
    return m_exact_framerate;
}
void OAIMediaStreamAttributes_Fmtp::setExactFramerate(const QString &exact_framerate) {
    m_exact_framerate = exact_framerate;
    m_exact_framerate_isSet = true;
}

bool OAIMediaStreamAttributes_Fmtp::is_exact_framerate_Set() const{
    return m_exact_framerate_isSet;
}

bool OAIMediaStreamAttributes_Fmtp::is_exact_framerate_Valid() const{
    return m_exact_framerate_isValid;
}

QString OAIMediaStreamAttributes_Fmtp::getPar() const {
    return m_par;
}
void OAIMediaStreamAttributes_Fmtp::setPar(const QString &par) {
    m_par = par;
    m_par_isSet = true;
}

bool OAIMediaStreamAttributes_Fmtp::is_par_Set() const{
    return m_par_isSet;
}

bool OAIMediaStreamAttributes_Fmtp::is_par_Valid() const{
    return m_par_isValid;
}

OAIRange OAIMediaStreamAttributes_Fmtp::getRange() const {
    return m_range;
}
void OAIMediaStreamAttributes_Fmtp::setRange(const OAIRange &range) {
    m_range = range;
    m_range_isSet = true;
}

bool OAIMediaStreamAttributes_Fmtp::is_range_Set() const{
    return m_range_isSet;
}

bool OAIMediaStreamAttributes_Fmtp::is_range_Valid() const{
    return m_range_isValid;
}

OAIScanMode OAIMediaStreamAttributes_Fmtp::getScanMode() const {
    return m_scan_mode;
}
void OAIMediaStreamAttributes_Fmtp::setScanMode(const OAIScanMode &scan_mode) {
    m_scan_mode = scan_mode;
    m_scan_mode_isSet = true;
}

bool OAIMediaStreamAttributes_Fmtp::is_scan_mode_Set() const{
    return m_scan_mode_isSet;
}

bool OAIMediaStreamAttributes_Fmtp::is_scan_mode_Valid() const{
    return m_scan_mode_isValid;
}

OAITcs OAIMediaStreamAttributes_Fmtp::getTcs() const {
    return m_tcs;
}
void OAIMediaStreamAttributes_Fmtp::setTcs(const OAITcs &tcs) {
    m_tcs = tcs;
    m_tcs_isSet = true;
}

bool OAIMediaStreamAttributes_Fmtp::is_tcs_Set() const{
    return m_tcs_isSet;
}

bool OAIMediaStreamAttributes_Fmtp::is_tcs_Valid() const{
    return m_tcs_isValid;
}

bool OAIMediaStreamAttributes_Fmtp::isSet() const {
    bool isObjectUpdated = false;
    do {
        if (m_channel_order_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_colorimetry.isSet()) {
            isObjectUpdated = true;
            break;
        }

        if (m_exact_framerate_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_par_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_range.isSet()) {
            isObjectUpdated = true;
            break;
        }

        if (m_scan_mode.isSet()) {
            isObjectUpdated = true;
            break;
        }

        if (m_tcs.isSet()) {
            isObjectUpdated = true;
            break;
        }
    } while (false);
    return isObjectUpdated;
}

bool OAIMediaStreamAttributes_Fmtp::isValid() const {
    // only required properties are required for the object to be considered valid
    return true;
}

} // namespace OpenAPI
