/*
 * AWS MediaConnect
 * API for AWS Elemental MediaConnect
 *
 * The version of the OpenAPI document: 2018-11-14
 * Contact: mike.ralphson@gmail.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package org.openapitools.client.model;

import java.util.Objects;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import org.openapitools.client.model.MediaStreamSourceConfigurationRequest;
import org.openapitools.client.model.UpdateFlowOutputRequestEncryption;
import org.openapitools.client.model.UpdateFlowSourceRequestGatewayBridgeSource;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonArray;
import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;
import com.google.gson.TypeAdapterFactory;
import com.google.gson.reflect.TypeToken;
import com.google.gson.TypeAdapter;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;

import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import org.openapitools.client.JSON;

/**
 * UpdateFlowSourceRequest
 */
@javax.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen", date = "2024-10-12T12:01:07.515051-04:00[America/New_York]", comments = "Generator version: 7.9.0")
public class UpdateFlowSourceRequest {
  public static final String SERIALIZED_NAME_DECRYPTION = "decryption";
  @SerializedName(SERIALIZED_NAME_DECRYPTION)
  private UpdateFlowOutputRequestEncryption decryption;

  public static final String SERIALIZED_NAME_DESCRIPTION = "description";
  @SerializedName(SERIALIZED_NAME_DESCRIPTION)
  private String description;

  public static final String SERIALIZED_NAME_ENTITLEMENT_ARN = "entitlementArn";
  @SerializedName(SERIALIZED_NAME_ENTITLEMENT_ARN)
  private String entitlementArn;

  public static final String SERIALIZED_NAME_INGEST_PORT = "ingestPort";
  @SerializedName(SERIALIZED_NAME_INGEST_PORT)
  private Integer ingestPort;

  public static final String SERIALIZED_NAME_MAX_BITRATE = "maxBitrate";
  @SerializedName(SERIALIZED_NAME_MAX_BITRATE)
  private Integer maxBitrate;

  public static final String SERIALIZED_NAME_MAX_LATENCY = "maxLatency";
  @SerializedName(SERIALIZED_NAME_MAX_LATENCY)
  private Integer maxLatency;

  public static final String SERIALIZED_NAME_MAX_SYNC_BUFFER = "maxSyncBuffer";
  @SerializedName(SERIALIZED_NAME_MAX_SYNC_BUFFER)
  private Integer maxSyncBuffer;

  public static final String SERIALIZED_NAME_MEDIA_STREAM_SOURCE_CONFIGURATIONS = "mediaStreamSourceConfigurations";
  @SerializedName(SERIALIZED_NAME_MEDIA_STREAM_SOURCE_CONFIGURATIONS)
  private List<MediaStreamSourceConfigurationRequest> mediaStreamSourceConfigurations = new ArrayList<>();

  public static final String SERIALIZED_NAME_MIN_LATENCY = "minLatency";
  @SerializedName(SERIALIZED_NAME_MIN_LATENCY)
  private Integer minLatency;

  /**
   * The protocol that is used by the source.
   */
  @JsonAdapter(ProtocolEnum.Adapter.class)
  public enum ProtocolEnum {
    ZIXI_PUSH("zixi-push"),
    
    RTP_FEC("rtp-fec"),
    
    RTP("rtp"),
    
    ZIXI_PULL("zixi-pull"),
    
    RIST("rist"),
    
    ST2110_JPEGXS("st2110-jpegxs"),
    
    CDI("cdi"),
    
    SRT_LISTENER("srt-listener"),
    
    SRT_CALLER("srt-caller"),
    
    FUJITSU_QOS("fujitsu-qos"),
    
    UDP("udp");

    private String value;

    ProtocolEnum(String value) {
      this.value = value;
    }

    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }

    public static ProtocolEnum fromValue(String value) {
      for (ProtocolEnum b : ProtocolEnum.values()) {
        if (b.value.equals(value)) {
          return b;
        }
      }
      throw new IllegalArgumentException("Unexpected value '" + value + "'");
    }

    public static class Adapter extends TypeAdapter<ProtocolEnum> {
      @Override
      public void write(final JsonWriter jsonWriter, final ProtocolEnum enumeration) throws IOException {
        jsonWriter.value(enumeration.getValue());
      }

      @Override
      public ProtocolEnum read(final JsonReader jsonReader) throws IOException {
        String value =  jsonReader.nextString();
        return ProtocolEnum.fromValue(value);
      }
    }

    public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      String value = jsonElement.getAsString();
      ProtocolEnum.fromValue(value);
    }
  }

  public static final String SERIALIZED_NAME_PROTOCOL = "protocol";
  @SerializedName(SERIALIZED_NAME_PROTOCOL)
  private ProtocolEnum protocol;

  public static final String SERIALIZED_NAME_SENDER_CONTROL_PORT = "senderControlPort";
  @SerializedName(SERIALIZED_NAME_SENDER_CONTROL_PORT)
  private Integer senderControlPort;

  public static final String SERIALIZED_NAME_SENDER_IP_ADDRESS = "senderIpAddress";
  @SerializedName(SERIALIZED_NAME_SENDER_IP_ADDRESS)
  private String senderIpAddress;

  public static final String SERIALIZED_NAME_SOURCE_LISTENER_ADDRESS = "sourceListenerAddress";
  @SerializedName(SERIALIZED_NAME_SOURCE_LISTENER_ADDRESS)
  private String sourceListenerAddress;

  public static final String SERIALIZED_NAME_SOURCE_LISTENER_PORT = "sourceListenerPort";
  @SerializedName(SERIALIZED_NAME_SOURCE_LISTENER_PORT)
  private Integer sourceListenerPort;

  public static final String SERIALIZED_NAME_STREAM_ID = "streamId";
  @SerializedName(SERIALIZED_NAME_STREAM_ID)
  private String streamId;

  public static final String SERIALIZED_NAME_VPC_INTERFACE_NAME = "vpcInterfaceName";
  @SerializedName(SERIALIZED_NAME_VPC_INTERFACE_NAME)
  private String vpcInterfaceName;

  public static final String SERIALIZED_NAME_WHITELIST_CIDR = "whitelistCidr";
  @SerializedName(SERIALIZED_NAME_WHITELIST_CIDR)
  private String whitelistCidr;

  public static final String SERIALIZED_NAME_GATEWAY_BRIDGE_SOURCE = "gatewayBridgeSource";
  @SerializedName(SERIALIZED_NAME_GATEWAY_BRIDGE_SOURCE)
  private UpdateFlowSourceRequestGatewayBridgeSource gatewayBridgeSource;

  public UpdateFlowSourceRequest() {
  }

  public UpdateFlowSourceRequest decryption(UpdateFlowOutputRequestEncryption decryption) {
    this.decryption = decryption;
    return this;
  }

  /**
   * Get decryption
   * @return decryption
   */
  @javax.annotation.Nullable
  public UpdateFlowOutputRequestEncryption getDecryption() {
    return decryption;
  }

  public void setDecryption(UpdateFlowOutputRequestEncryption decryption) {
    this.decryption = decryption;
  }


  public UpdateFlowSourceRequest description(String description) {
    this.description = description;
    return this;
  }

  /**
   * A description for the source. This value is not used or seen outside of the current AWS Elemental MediaConnect account.
   * @return description
   */
  @javax.annotation.Nullable
  public String getDescription() {
    return description;
  }

  public void setDescription(String description) {
    this.description = description;
  }


  public UpdateFlowSourceRequest entitlementArn(String entitlementArn) {
    this.entitlementArn = entitlementArn;
    return this;
  }

  /**
   * The ARN of the entitlement that allows you to subscribe to this flow. The entitlement is set by the flow originator, and the ARN is generated as part of the originator&#39;s flow.
   * @return entitlementArn
   */
  @javax.annotation.Nullable
  public String getEntitlementArn() {
    return entitlementArn;
  }

  public void setEntitlementArn(String entitlementArn) {
    this.entitlementArn = entitlementArn;
  }


  public UpdateFlowSourceRequest ingestPort(Integer ingestPort) {
    this.ingestPort = ingestPort;
    return this;
  }

  /**
   * The port that the flow will be listening on for incoming content.
   * @return ingestPort
   */
  @javax.annotation.Nullable
  public Integer getIngestPort() {
    return ingestPort;
  }

  public void setIngestPort(Integer ingestPort) {
    this.ingestPort = ingestPort;
  }


  public UpdateFlowSourceRequest maxBitrate(Integer maxBitrate) {
    this.maxBitrate = maxBitrate;
    return this;
  }

  /**
   * The smoothing max bitrate (in bps) for RIST, RTP, and RTP-FEC streams.
   * @return maxBitrate
   */
  @javax.annotation.Nullable
  public Integer getMaxBitrate() {
    return maxBitrate;
  }

  public void setMaxBitrate(Integer maxBitrate) {
    this.maxBitrate = maxBitrate;
  }


  public UpdateFlowSourceRequest maxLatency(Integer maxLatency) {
    this.maxLatency = maxLatency;
    return this;
  }

  /**
   * The maximum latency in milliseconds. This parameter applies only to RIST-based, Zixi-based, and Fujitsu-based streams.
   * @return maxLatency
   */
  @javax.annotation.Nullable
  public Integer getMaxLatency() {
    return maxLatency;
  }

  public void setMaxLatency(Integer maxLatency) {
    this.maxLatency = maxLatency;
  }


  public UpdateFlowSourceRequest maxSyncBuffer(Integer maxSyncBuffer) {
    this.maxSyncBuffer = maxSyncBuffer;
    return this;
  }

  /**
   * The size of the buffer (in milliseconds) to use to sync incoming source data.
   * @return maxSyncBuffer
   */
  @javax.annotation.Nullable
  public Integer getMaxSyncBuffer() {
    return maxSyncBuffer;
  }

  public void setMaxSyncBuffer(Integer maxSyncBuffer) {
    this.maxSyncBuffer = maxSyncBuffer;
  }


  public UpdateFlowSourceRequest mediaStreamSourceConfigurations(List<MediaStreamSourceConfigurationRequest> mediaStreamSourceConfigurations) {
    this.mediaStreamSourceConfigurations = mediaStreamSourceConfigurations;
    return this;
  }

  public UpdateFlowSourceRequest addMediaStreamSourceConfigurationsItem(MediaStreamSourceConfigurationRequest mediaStreamSourceConfigurationsItem) {
    if (this.mediaStreamSourceConfigurations == null) {
      this.mediaStreamSourceConfigurations = new ArrayList<>();
    }
    this.mediaStreamSourceConfigurations.add(mediaStreamSourceConfigurationsItem);
    return this;
  }

  /**
   * The media streams that are associated with the source, and the parameters for those associations.
   * @return mediaStreamSourceConfigurations
   */
  @javax.annotation.Nullable
  public List<MediaStreamSourceConfigurationRequest> getMediaStreamSourceConfigurations() {
    return mediaStreamSourceConfigurations;
  }

  public void setMediaStreamSourceConfigurations(List<MediaStreamSourceConfigurationRequest> mediaStreamSourceConfigurations) {
    this.mediaStreamSourceConfigurations = mediaStreamSourceConfigurations;
  }


  public UpdateFlowSourceRequest minLatency(Integer minLatency) {
    this.minLatency = minLatency;
    return this;
  }

  /**
   * The minimum latency in milliseconds for SRT-based streams. In streams that use the SRT protocol, this value that you set on your MediaConnect source or output represents the minimal potential latency of that connection. The latency of the stream is set to the highest number between the sender’s minimum latency and the receiver’s minimum latency.
   * @return minLatency
   */
  @javax.annotation.Nullable
  public Integer getMinLatency() {
    return minLatency;
  }

  public void setMinLatency(Integer minLatency) {
    this.minLatency = minLatency;
  }


  public UpdateFlowSourceRequest protocol(ProtocolEnum protocol) {
    this.protocol = protocol;
    return this;
  }

  /**
   * The protocol that is used by the source.
   * @return protocol
   */
  @javax.annotation.Nullable
  public ProtocolEnum getProtocol() {
    return protocol;
  }

  public void setProtocol(ProtocolEnum protocol) {
    this.protocol = protocol;
  }


  public UpdateFlowSourceRequest senderControlPort(Integer senderControlPort) {
    this.senderControlPort = senderControlPort;
    return this;
  }

  /**
   * The port that the flow uses to send outbound requests to initiate connection with the sender.
   * @return senderControlPort
   */
  @javax.annotation.Nullable
  public Integer getSenderControlPort() {
    return senderControlPort;
  }

  public void setSenderControlPort(Integer senderControlPort) {
    this.senderControlPort = senderControlPort;
  }


  public UpdateFlowSourceRequest senderIpAddress(String senderIpAddress) {
    this.senderIpAddress = senderIpAddress;
    return this;
  }

  /**
   * The IP address that the flow communicates with to initiate connection with the sender.
   * @return senderIpAddress
   */
  @javax.annotation.Nullable
  public String getSenderIpAddress() {
    return senderIpAddress;
  }

  public void setSenderIpAddress(String senderIpAddress) {
    this.senderIpAddress = senderIpAddress;
  }


  public UpdateFlowSourceRequest sourceListenerAddress(String sourceListenerAddress) {
    this.sourceListenerAddress = sourceListenerAddress;
    return this;
  }

  /**
   * Source IP or domain name for SRT-caller protocol.
   * @return sourceListenerAddress
   */
  @javax.annotation.Nullable
  public String getSourceListenerAddress() {
    return sourceListenerAddress;
  }

  public void setSourceListenerAddress(String sourceListenerAddress) {
    this.sourceListenerAddress = sourceListenerAddress;
  }


  public UpdateFlowSourceRequest sourceListenerPort(Integer sourceListenerPort) {
    this.sourceListenerPort = sourceListenerPort;
    return this;
  }

  /**
   * Source port for SRT-caller protocol.
   * @return sourceListenerPort
   */
  @javax.annotation.Nullable
  public Integer getSourceListenerPort() {
    return sourceListenerPort;
  }

  public void setSourceListenerPort(Integer sourceListenerPort) {
    this.sourceListenerPort = sourceListenerPort;
  }


  public UpdateFlowSourceRequest streamId(String streamId) {
    this.streamId = streamId;
    return this;
  }

  /**
   * The stream ID that you want to use for this transport. This parameter applies only to Zixi and SRT caller-based streams.
   * @return streamId
   */
  @javax.annotation.Nullable
  public String getStreamId() {
    return streamId;
  }

  public void setStreamId(String streamId) {
    this.streamId = streamId;
  }


  public UpdateFlowSourceRequest vpcInterfaceName(String vpcInterfaceName) {
    this.vpcInterfaceName = vpcInterfaceName;
    return this;
  }

  /**
   * The name of the VPC interface to use for this source.
   * @return vpcInterfaceName
   */
  @javax.annotation.Nullable
  public String getVpcInterfaceName() {
    return vpcInterfaceName;
  }

  public void setVpcInterfaceName(String vpcInterfaceName) {
    this.vpcInterfaceName = vpcInterfaceName;
  }


  public UpdateFlowSourceRequest whitelistCidr(String whitelistCidr) {
    this.whitelistCidr = whitelistCidr;
    return this;
  }

  /**
   * The range of IP addresses that should be allowed to contribute content to your source. These IP addresses should be in the form of a Classless Inter-Domain Routing (CIDR) block; for example, 10.0.0.0/16.
   * @return whitelistCidr
   */
  @javax.annotation.Nullable
  public String getWhitelistCidr() {
    return whitelistCidr;
  }

  public void setWhitelistCidr(String whitelistCidr) {
    this.whitelistCidr = whitelistCidr;
  }


  public UpdateFlowSourceRequest gatewayBridgeSource(UpdateFlowSourceRequestGatewayBridgeSource gatewayBridgeSource) {
    this.gatewayBridgeSource = gatewayBridgeSource;
    return this;
  }

  /**
   * Get gatewayBridgeSource
   * @return gatewayBridgeSource
   */
  @javax.annotation.Nullable
  public UpdateFlowSourceRequestGatewayBridgeSource getGatewayBridgeSource() {
    return gatewayBridgeSource;
  }

  public void setGatewayBridgeSource(UpdateFlowSourceRequestGatewayBridgeSource gatewayBridgeSource) {
    this.gatewayBridgeSource = gatewayBridgeSource;
  }



  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    UpdateFlowSourceRequest updateFlowSourceRequest = (UpdateFlowSourceRequest) o;
    return Objects.equals(this.decryption, updateFlowSourceRequest.decryption) &&
        Objects.equals(this.description, updateFlowSourceRequest.description) &&
        Objects.equals(this.entitlementArn, updateFlowSourceRequest.entitlementArn) &&
        Objects.equals(this.ingestPort, updateFlowSourceRequest.ingestPort) &&
        Objects.equals(this.maxBitrate, updateFlowSourceRequest.maxBitrate) &&
        Objects.equals(this.maxLatency, updateFlowSourceRequest.maxLatency) &&
        Objects.equals(this.maxSyncBuffer, updateFlowSourceRequest.maxSyncBuffer) &&
        Objects.equals(this.mediaStreamSourceConfigurations, updateFlowSourceRequest.mediaStreamSourceConfigurations) &&
        Objects.equals(this.minLatency, updateFlowSourceRequest.minLatency) &&
        Objects.equals(this.protocol, updateFlowSourceRequest.protocol) &&
        Objects.equals(this.senderControlPort, updateFlowSourceRequest.senderControlPort) &&
        Objects.equals(this.senderIpAddress, updateFlowSourceRequest.senderIpAddress) &&
        Objects.equals(this.sourceListenerAddress, updateFlowSourceRequest.sourceListenerAddress) &&
        Objects.equals(this.sourceListenerPort, updateFlowSourceRequest.sourceListenerPort) &&
        Objects.equals(this.streamId, updateFlowSourceRequest.streamId) &&
        Objects.equals(this.vpcInterfaceName, updateFlowSourceRequest.vpcInterfaceName) &&
        Objects.equals(this.whitelistCidr, updateFlowSourceRequest.whitelistCidr) &&
        Objects.equals(this.gatewayBridgeSource, updateFlowSourceRequest.gatewayBridgeSource);
  }

  @Override
  public int hashCode() {
    return Objects.hash(decryption, description, entitlementArn, ingestPort, maxBitrate, maxLatency, maxSyncBuffer, mediaStreamSourceConfigurations, minLatency, protocol, senderControlPort, senderIpAddress, sourceListenerAddress, sourceListenerPort, streamId, vpcInterfaceName, whitelistCidr, gatewayBridgeSource);
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class UpdateFlowSourceRequest {\n");
    sb.append("    decryption: ").append(toIndentedString(decryption)).append("\n");
    sb.append("    description: ").append(toIndentedString(description)).append("\n");
    sb.append("    entitlementArn: ").append(toIndentedString(entitlementArn)).append("\n");
    sb.append("    ingestPort: ").append(toIndentedString(ingestPort)).append("\n");
    sb.append("    maxBitrate: ").append(toIndentedString(maxBitrate)).append("\n");
    sb.append("    maxLatency: ").append(toIndentedString(maxLatency)).append("\n");
    sb.append("    maxSyncBuffer: ").append(toIndentedString(maxSyncBuffer)).append("\n");
    sb.append("    mediaStreamSourceConfigurations: ").append(toIndentedString(mediaStreamSourceConfigurations)).append("\n");
    sb.append("    minLatency: ").append(toIndentedString(minLatency)).append("\n");
    sb.append("    protocol: ").append(toIndentedString(protocol)).append("\n");
    sb.append("    senderControlPort: ").append(toIndentedString(senderControlPort)).append("\n");
    sb.append("    senderIpAddress: ").append(toIndentedString(senderIpAddress)).append("\n");
    sb.append("    sourceListenerAddress: ").append(toIndentedString(sourceListenerAddress)).append("\n");
    sb.append("    sourceListenerPort: ").append(toIndentedString(sourceListenerPort)).append("\n");
    sb.append("    streamId: ").append(toIndentedString(streamId)).append("\n");
    sb.append("    vpcInterfaceName: ").append(toIndentedString(vpcInterfaceName)).append("\n");
    sb.append("    whitelistCidr: ").append(toIndentedString(whitelistCidr)).append("\n");
    sb.append("    gatewayBridgeSource: ").append(toIndentedString(gatewayBridgeSource)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }


  public static HashSet<String> openapiFields;
  public static HashSet<String> openapiRequiredFields;

  static {
    // a set of all properties/fields (JSON key names)
    openapiFields = new HashSet<String>();
    openapiFields.add("decryption");
    openapiFields.add("description");
    openapiFields.add("entitlementArn");
    openapiFields.add("ingestPort");
    openapiFields.add("maxBitrate");
    openapiFields.add("maxLatency");
    openapiFields.add("maxSyncBuffer");
    openapiFields.add("mediaStreamSourceConfigurations");
    openapiFields.add("minLatency");
    openapiFields.add("protocol");
    openapiFields.add("senderControlPort");
    openapiFields.add("senderIpAddress");
    openapiFields.add("sourceListenerAddress");
    openapiFields.add("sourceListenerPort");
    openapiFields.add("streamId");
    openapiFields.add("vpcInterfaceName");
    openapiFields.add("whitelistCidr");
    openapiFields.add("gatewayBridgeSource");

    // a set of required properties/fields (JSON key names)
    openapiRequiredFields = new HashSet<String>();
  }

  /**
   * Validates the JSON Element and throws an exception if issues found
   *
   * @param jsonElement JSON Element
   * @throws IOException if the JSON Element is invalid with respect to UpdateFlowSourceRequest
   */
  public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      if (jsonElement == null) {
        if (!UpdateFlowSourceRequest.openapiRequiredFields.isEmpty()) { // has required fields but JSON element is null
          throw new IllegalArgumentException(String.format("The required field(s) %s in UpdateFlowSourceRequest is not found in the empty JSON string", UpdateFlowSourceRequest.openapiRequiredFields.toString()));
        }
      }

      Set<Map.Entry<String, JsonElement>> entries = jsonElement.getAsJsonObject().entrySet();
      // check to see if the JSON string contains additional fields
      for (Map.Entry<String, JsonElement> entry : entries) {
        if (!UpdateFlowSourceRequest.openapiFields.contains(entry.getKey())) {
          throw new IllegalArgumentException(String.format("The field `%s` in the JSON string is not defined in the `UpdateFlowSourceRequest` properties. JSON: %s", entry.getKey(), jsonElement.toString()));
        }
      }
        JsonObject jsonObj = jsonElement.getAsJsonObject();
      // validate the optional field `decryption`
      if (jsonObj.get("decryption") != null && !jsonObj.get("decryption").isJsonNull()) {
        UpdateFlowOutputRequestEncryption.validateJsonElement(jsonObj.get("decryption"));
      }
      if ((jsonObj.get("description") != null && !jsonObj.get("description").isJsonNull()) && !jsonObj.get("description").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `description` to be a primitive type in the JSON string but got `%s`", jsonObj.get("description").toString()));
      }
      if ((jsonObj.get("entitlementArn") != null && !jsonObj.get("entitlementArn").isJsonNull()) && !jsonObj.get("entitlementArn").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `entitlementArn` to be a primitive type in the JSON string but got `%s`", jsonObj.get("entitlementArn").toString()));
      }
      if (jsonObj.get("mediaStreamSourceConfigurations") != null && !jsonObj.get("mediaStreamSourceConfigurations").isJsonNull()) {
        JsonArray jsonArraymediaStreamSourceConfigurations = jsonObj.getAsJsonArray("mediaStreamSourceConfigurations");
        if (jsonArraymediaStreamSourceConfigurations != null) {
          // ensure the json data is an array
          if (!jsonObj.get("mediaStreamSourceConfigurations").isJsonArray()) {
            throw new IllegalArgumentException(String.format("Expected the field `mediaStreamSourceConfigurations` to be an array in the JSON string but got `%s`", jsonObj.get("mediaStreamSourceConfigurations").toString()));
          }

          // validate the optional field `mediaStreamSourceConfigurations` (array)
          for (int i = 0; i < jsonArraymediaStreamSourceConfigurations.size(); i++) {
            MediaStreamSourceConfigurationRequest.validateJsonElement(jsonArraymediaStreamSourceConfigurations.get(i));
          };
        }
      }
      if ((jsonObj.get("protocol") != null && !jsonObj.get("protocol").isJsonNull()) && !jsonObj.get("protocol").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `protocol` to be a primitive type in the JSON string but got `%s`", jsonObj.get("protocol").toString()));
      }
      // validate the optional field `protocol`
      if (jsonObj.get("protocol") != null && !jsonObj.get("protocol").isJsonNull()) {
        ProtocolEnum.validateJsonElement(jsonObj.get("protocol"));
      }
      if ((jsonObj.get("senderIpAddress") != null && !jsonObj.get("senderIpAddress").isJsonNull()) && !jsonObj.get("senderIpAddress").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `senderIpAddress` to be a primitive type in the JSON string but got `%s`", jsonObj.get("senderIpAddress").toString()));
      }
      if ((jsonObj.get("sourceListenerAddress") != null && !jsonObj.get("sourceListenerAddress").isJsonNull()) && !jsonObj.get("sourceListenerAddress").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `sourceListenerAddress` to be a primitive type in the JSON string but got `%s`", jsonObj.get("sourceListenerAddress").toString()));
      }
      if ((jsonObj.get("streamId") != null && !jsonObj.get("streamId").isJsonNull()) && !jsonObj.get("streamId").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `streamId` to be a primitive type in the JSON string but got `%s`", jsonObj.get("streamId").toString()));
      }
      if ((jsonObj.get("vpcInterfaceName") != null && !jsonObj.get("vpcInterfaceName").isJsonNull()) && !jsonObj.get("vpcInterfaceName").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `vpcInterfaceName` to be a primitive type in the JSON string but got `%s`", jsonObj.get("vpcInterfaceName").toString()));
      }
      if ((jsonObj.get("whitelistCidr") != null && !jsonObj.get("whitelistCidr").isJsonNull()) && !jsonObj.get("whitelistCidr").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `whitelistCidr` to be a primitive type in the JSON string but got `%s`", jsonObj.get("whitelistCidr").toString()));
      }
      // validate the optional field `gatewayBridgeSource`
      if (jsonObj.get("gatewayBridgeSource") != null && !jsonObj.get("gatewayBridgeSource").isJsonNull()) {
        UpdateFlowSourceRequestGatewayBridgeSource.validateJsonElement(jsonObj.get("gatewayBridgeSource"));
      }
  }

  public static class CustomTypeAdapterFactory implements TypeAdapterFactory {
    @SuppressWarnings("unchecked")
    @Override
    public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
       if (!UpdateFlowSourceRequest.class.isAssignableFrom(type.getRawType())) {
         return null; // this class only serializes 'UpdateFlowSourceRequest' and its subtypes
       }
       final TypeAdapter<JsonElement> elementAdapter = gson.getAdapter(JsonElement.class);
       final TypeAdapter<UpdateFlowSourceRequest> thisAdapter
                        = gson.getDelegateAdapter(this, TypeToken.get(UpdateFlowSourceRequest.class));

       return (TypeAdapter<T>) new TypeAdapter<UpdateFlowSourceRequest>() {
           @Override
           public void write(JsonWriter out, UpdateFlowSourceRequest value) throws IOException {
             JsonObject obj = thisAdapter.toJsonTree(value).getAsJsonObject();
             elementAdapter.write(out, obj);
           }

           @Override
           public UpdateFlowSourceRequest read(JsonReader in) throws IOException {
             JsonElement jsonElement = elementAdapter.read(in);
             validateJsonElement(jsonElement);
             return thisAdapter.fromJsonTree(jsonElement);
           }

       }.nullSafe();
    }
  }

  /**
   * Create an instance of UpdateFlowSourceRequest given an JSON string
   *
   * @param jsonString JSON string
   * @return An instance of UpdateFlowSourceRequest
   * @throws IOException if the JSON string is invalid with respect to UpdateFlowSourceRequest
   */
  public static UpdateFlowSourceRequest fromJson(String jsonString) throws IOException {
    return JSON.getGson().fromJson(jsonString, UpdateFlowSourceRequest.class);
  }

  /**
   * Convert an instance of UpdateFlowSourceRequest to an JSON string
   *
   * @return JSON string
   */
  public String toJson() {
    return JSON.getGson().toJson(this);
  }
}

