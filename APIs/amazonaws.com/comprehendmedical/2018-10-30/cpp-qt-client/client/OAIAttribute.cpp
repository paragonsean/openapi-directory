/**
 * AWS Comprehend Medical
 * Amazon Comprehend Medical extracts structured information from unstructured clinical text. Use these actions to gain insight in your documents. Amazon Comprehend Medical only detects entities in English language texts. Amazon Comprehend Medical places limits on the sizes of files allowed for different API operations. To learn more, see <a href=\"https://docs.aws.amazon.com/comprehend-medical/latest/dev/comprehendmedical-quotas.html\">Guidelines and quotas</a> in the <i>Amazon Comprehend Medical Developer Guide</i>.
 *
 * The version of the OpenAPI document: 2018-10-30
 * Contact: mike.ralphson@gmail.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

#include "OAIAttribute.h"

#include <QDebug>
#include <QJsonArray>
#include <QJsonDocument>
#include <QObject>

#include "OAIHelpers.h"

namespace OpenAPI {

OAIAttribute::OAIAttribute(QString json) {
    this->initializeModel();
    this->fromJson(json);
}

OAIAttribute::OAIAttribute() {
    this->initializeModel();
}

OAIAttribute::~OAIAttribute() {}

void OAIAttribute::initializeModel() {

    m_type_isSet = false;
    m_type_isValid = false;

    m_score_isSet = false;
    m_score_isValid = false;

    m_relationship_score_isSet = false;
    m_relationship_score_isValid = false;

    m_relationship_type_isSet = false;
    m_relationship_type_isValid = false;

    m_id_isSet = false;
    m_id_isValid = false;

    m_begin_offset_isSet = false;
    m_begin_offset_isValid = false;

    m_end_offset_isSet = false;
    m_end_offset_isValid = false;

    m_text_isSet = false;
    m_text_isValid = false;

    m_category_isSet = false;
    m_category_isValid = false;

    m_traits_isSet = false;
    m_traits_isValid = false;
}

void OAIAttribute::fromJson(QString jsonString) {
    QByteArray array(jsonString.toStdString().c_str());
    QJsonDocument doc = QJsonDocument::fromJson(array);
    QJsonObject jsonObject = doc.object();
    this->fromJsonObject(jsonObject);
}

void OAIAttribute::fromJsonObject(QJsonObject json) {

    m_type_isValid = ::OpenAPI::fromJsonValue(m_type, json[QString("Type")]);
    m_type_isSet = !json[QString("Type")].isNull() && m_type_isValid;

    m_score_isValid = ::OpenAPI::fromJsonValue(m_score, json[QString("Score")]);
    m_score_isSet = !json[QString("Score")].isNull() && m_score_isValid;

    m_relationship_score_isValid = ::OpenAPI::fromJsonValue(m_relationship_score, json[QString("RelationshipScore")]);
    m_relationship_score_isSet = !json[QString("RelationshipScore")].isNull() && m_relationship_score_isValid;

    m_relationship_type_isValid = ::OpenAPI::fromJsonValue(m_relationship_type, json[QString("RelationshipType")]);
    m_relationship_type_isSet = !json[QString("RelationshipType")].isNull() && m_relationship_type_isValid;

    m_id_isValid = ::OpenAPI::fromJsonValue(m_id, json[QString("Id")]);
    m_id_isSet = !json[QString("Id")].isNull() && m_id_isValid;

    m_begin_offset_isValid = ::OpenAPI::fromJsonValue(m_begin_offset, json[QString("BeginOffset")]);
    m_begin_offset_isSet = !json[QString("BeginOffset")].isNull() && m_begin_offset_isValid;

    m_end_offset_isValid = ::OpenAPI::fromJsonValue(m_end_offset, json[QString("EndOffset")]);
    m_end_offset_isSet = !json[QString("EndOffset")].isNull() && m_end_offset_isValid;

    m_text_isValid = ::OpenAPI::fromJsonValue(m_text, json[QString("Text")]);
    m_text_isSet = !json[QString("Text")].isNull() && m_text_isValid;

    m_category_isValid = ::OpenAPI::fromJsonValue(m_category, json[QString("Category")]);
    m_category_isSet = !json[QString("Category")].isNull() && m_category_isValid;

    m_traits_isValid = ::OpenAPI::fromJsonValue(m_traits, json[QString("Traits")]);
    m_traits_isSet = !json[QString("Traits")].isNull() && m_traits_isValid;
}

QString OAIAttribute::asJson() const {
    QJsonObject obj = this->asJsonObject();
    QJsonDocument doc(obj);
    QByteArray bytes = doc.toJson();
    return QString(bytes);
}

QJsonObject OAIAttribute::asJsonObject() const {
    QJsonObject obj;
    if (m_type.isSet()) {
        obj.insert(QString("Type"), ::OpenAPI::toJsonValue(m_type));
    }
    if (m_score_isSet) {
        obj.insert(QString("Score"), ::OpenAPI::toJsonValue(m_score));
    }
    if (m_relationship_score_isSet) {
        obj.insert(QString("RelationshipScore"), ::OpenAPI::toJsonValue(m_relationship_score));
    }
    if (m_relationship_type.isSet()) {
        obj.insert(QString("RelationshipType"), ::OpenAPI::toJsonValue(m_relationship_type));
    }
    if (m_id_isSet) {
        obj.insert(QString("Id"), ::OpenAPI::toJsonValue(m_id));
    }
    if (m_begin_offset_isSet) {
        obj.insert(QString("BeginOffset"), ::OpenAPI::toJsonValue(m_begin_offset));
    }
    if (m_end_offset_isSet) {
        obj.insert(QString("EndOffset"), ::OpenAPI::toJsonValue(m_end_offset));
    }
    if (m_text_isSet) {
        obj.insert(QString("Text"), ::OpenAPI::toJsonValue(m_text));
    }
    if (m_category.isSet()) {
        obj.insert(QString("Category"), ::OpenAPI::toJsonValue(m_category));
    }
    if (m_traits.isSet()) {
        obj.insert(QString("Traits"), ::OpenAPI::toJsonValue(m_traits));
    }
    return obj;
}

OAIEntitySubType OAIAttribute::getType() const {
    return m_type;
}
void OAIAttribute::setType(const OAIEntitySubType &type) {
    m_type = type;
    m_type_isSet = true;
}

bool OAIAttribute::is_type_Set() const{
    return m_type_isSet;
}

bool OAIAttribute::is_type_Valid() const{
    return m_type_isValid;
}

float OAIAttribute::getScore() const {
    return m_score;
}
void OAIAttribute::setScore(const float &score) {
    m_score = score;
    m_score_isSet = true;
}

bool OAIAttribute::is_score_Set() const{
    return m_score_isSet;
}

bool OAIAttribute::is_score_Valid() const{
    return m_score_isValid;
}

float OAIAttribute::getRelationshipScore() const {
    return m_relationship_score;
}
void OAIAttribute::setRelationshipScore(const float &relationship_score) {
    m_relationship_score = relationship_score;
    m_relationship_score_isSet = true;
}

bool OAIAttribute::is_relationship_score_Set() const{
    return m_relationship_score_isSet;
}

bool OAIAttribute::is_relationship_score_Valid() const{
    return m_relationship_score_isValid;
}

OAIRelationshipType OAIAttribute::getRelationshipType() const {
    return m_relationship_type;
}
void OAIAttribute::setRelationshipType(const OAIRelationshipType &relationship_type) {
    m_relationship_type = relationship_type;
    m_relationship_type_isSet = true;
}

bool OAIAttribute::is_relationship_type_Set() const{
    return m_relationship_type_isSet;
}

bool OAIAttribute::is_relationship_type_Valid() const{
    return m_relationship_type_isValid;
}

qint32 OAIAttribute::getId() const {
    return m_id;
}
void OAIAttribute::setId(const qint32 &id) {
    m_id = id;
    m_id_isSet = true;
}

bool OAIAttribute::is_id_Set() const{
    return m_id_isSet;
}

bool OAIAttribute::is_id_Valid() const{
    return m_id_isValid;
}

qint32 OAIAttribute::getBeginOffset() const {
    return m_begin_offset;
}
void OAIAttribute::setBeginOffset(const qint32 &begin_offset) {
    m_begin_offset = begin_offset;
    m_begin_offset_isSet = true;
}

bool OAIAttribute::is_begin_offset_Set() const{
    return m_begin_offset_isSet;
}

bool OAIAttribute::is_begin_offset_Valid() const{
    return m_begin_offset_isValid;
}

qint32 OAIAttribute::getEndOffset() const {
    return m_end_offset;
}
void OAIAttribute::setEndOffset(const qint32 &end_offset) {
    m_end_offset = end_offset;
    m_end_offset_isSet = true;
}

bool OAIAttribute::is_end_offset_Set() const{
    return m_end_offset_isSet;
}

bool OAIAttribute::is_end_offset_Valid() const{
    return m_end_offset_isValid;
}

QString OAIAttribute::getText() const {
    return m_text;
}
void OAIAttribute::setText(const QString &text) {
    m_text = text;
    m_text_isSet = true;
}

bool OAIAttribute::is_text_Set() const{
    return m_text_isSet;
}

bool OAIAttribute::is_text_Valid() const{
    return m_text_isValid;
}

OAIEntityType OAIAttribute::getCategory() const {
    return m_category;
}
void OAIAttribute::setCategory(const OAIEntityType &category) {
    m_category = category;
    m_category_isSet = true;
}

bool OAIAttribute::is_category_Set() const{
    return m_category_isSet;
}

bool OAIAttribute::is_category_Valid() const{
    return m_category_isValid;
}

QList OAIAttribute::getTraits() const {
    return m_traits;
}
void OAIAttribute::setTraits(const QList &traits) {
    m_traits = traits;
    m_traits_isSet = true;
}

bool OAIAttribute::is_traits_Set() const{
    return m_traits_isSet;
}

bool OAIAttribute::is_traits_Valid() const{
    return m_traits_isValid;
}

bool OAIAttribute::isSet() const {
    bool isObjectUpdated = false;
    do {
        if (m_type.isSet()) {
            isObjectUpdated = true;
            break;
        }

        if (m_score_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_relationship_score_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_relationship_type.isSet()) {
            isObjectUpdated = true;
            break;
        }

        if (m_id_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_begin_offset_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_end_offset_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_text_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_category.isSet()) {
            isObjectUpdated = true;
            break;
        }

        if (m_traits.isSet()) {
            isObjectUpdated = true;
            break;
        }
    } while (false);
    return isObjectUpdated;
}

bool OAIAttribute::isValid() const {
    // only required properties are required for the object to be considered valid
    return true;
}

} // namespace OpenAPI
