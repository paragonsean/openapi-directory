/**
 * Amazon CloudFront
 * <fullname>Amazon CloudFront</fullname> <p>This is the <i>Amazon CloudFront API Reference</i>. This guide is for developers who need detailed information about CloudFront API actions, data types, and errors. For detailed information about CloudFront features, see the <i>Amazon CloudFront Developer Guide</i>.</p>
 *
 * The version of the OpenAPI document: 2018-06-18
 * Contact: mike.ralphson@gmail.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

#include "OAICacheBehavior.h"

#include <QDebug>
#include <QJsonArray>
#include <QJsonDocument>
#include <QObject>

#include "OAIHelpers.h"

namespace OpenAPI {

OAICacheBehavior::OAICacheBehavior(QString json) {
    this->initializeModel();
    this->fromJson(json);
}

OAICacheBehavior::OAICacheBehavior() {
    this->initializeModel();
}

OAICacheBehavior::~OAICacheBehavior() {}

void OAICacheBehavior::initializeModel() {

    m_path_pattern_isSet = false;
    m_path_pattern_isValid = false;

    m_target_origin_id_isSet = false;
    m_target_origin_id_isValid = false;

    m_forwarded_values_isSet = false;
    m_forwarded_values_isValid = false;

    m_trusted_signers_isSet = false;
    m_trusted_signers_isValid = false;

    m_viewer_protocol_policy_isSet = false;
    m_viewer_protocol_policy_isValid = false;

    m_min_ttl_isSet = false;
    m_min_ttl_isValid = false;

    m_allowed_methods_isSet = false;
    m_allowed_methods_isValid = false;

    m_smooth_streaming_isSet = false;
    m_smooth_streaming_isValid = false;

    m_default_ttl_isSet = false;
    m_default_ttl_isValid = false;

    m_max_ttl_isSet = false;
    m_max_ttl_isValid = false;

    m_compress_isSet = false;
    m_compress_isValid = false;

    m_lambda_function_associations_isSet = false;
    m_lambda_function_associations_isValid = false;

    m_field_level_encryption_id_isSet = false;
    m_field_level_encryption_id_isValid = false;
}

void OAICacheBehavior::fromJson(QString jsonString) {
    QByteArray array(jsonString.toStdString().c_str());
    QJsonDocument doc = QJsonDocument::fromJson(array);
    QJsonObject jsonObject = doc.object();
    this->fromJsonObject(jsonObject);
}

void OAICacheBehavior::fromJsonObject(QJsonObject json) {

    m_path_pattern_isValid = ::OpenAPI::fromJsonValue(m_path_pattern, json[QString("PathPattern")]);
    m_path_pattern_isSet = !json[QString("PathPattern")].isNull() && m_path_pattern_isValid;

    m_target_origin_id_isValid = ::OpenAPI::fromJsonValue(m_target_origin_id, json[QString("TargetOriginId")]);
    m_target_origin_id_isSet = !json[QString("TargetOriginId")].isNull() && m_target_origin_id_isValid;

    m_forwarded_values_isValid = ::OpenAPI::fromJsonValue(m_forwarded_values, json[QString("ForwardedValues")]);
    m_forwarded_values_isSet = !json[QString("ForwardedValues")].isNull() && m_forwarded_values_isValid;

    m_trusted_signers_isValid = ::OpenAPI::fromJsonValue(m_trusted_signers, json[QString("TrustedSigners")]);
    m_trusted_signers_isSet = !json[QString("TrustedSigners")].isNull() && m_trusted_signers_isValid;

    m_viewer_protocol_policy_isValid = ::OpenAPI::fromJsonValue(m_viewer_protocol_policy, json[QString("ViewerProtocolPolicy")]);
    m_viewer_protocol_policy_isSet = !json[QString("ViewerProtocolPolicy")].isNull() && m_viewer_protocol_policy_isValid;

    m_min_ttl_isValid = ::OpenAPI::fromJsonValue(m_min_ttl, json[QString("MinTTL")]);
    m_min_ttl_isSet = !json[QString("MinTTL")].isNull() && m_min_ttl_isValid;

    m_allowed_methods_isValid = ::OpenAPI::fromJsonValue(m_allowed_methods, json[QString("AllowedMethods")]);
    m_allowed_methods_isSet = !json[QString("AllowedMethods")].isNull() && m_allowed_methods_isValid;

    m_smooth_streaming_isValid = ::OpenAPI::fromJsonValue(m_smooth_streaming, json[QString("SmoothStreaming")]);
    m_smooth_streaming_isSet = !json[QString("SmoothStreaming")].isNull() && m_smooth_streaming_isValid;

    m_default_ttl_isValid = ::OpenAPI::fromJsonValue(m_default_ttl, json[QString("DefaultTTL")]);
    m_default_ttl_isSet = !json[QString("DefaultTTL")].isNull() && m_default_ttl_isValid;

    m_max_ttl_isValid = ::OpenAPI::fromJsonValue(m_max_ttl, json[QString("MaxTTL")]);
    m_max_ttl_isSet = !json[QString("MaxTTL")].isNull() && m_max_ttl_isValid;

    m_compress_isValid = ::OpenAPI::fromJsonValue(m_compress, json[QString("Compress")]);
    m_compress_isSet = !json[QString("Compress")].isNull() && m_compress_isValid;

    m_lambda_function_associations_isValid = ::OpenAPI::fromJsonValue(m_lambda_function_associations, json[QString("LambdaFunctionAssociations")]);
    m_lambda_function_associations_isSet = !json[QString("LambdaFunctionAssociations")].isNull() && m_lambda_function_associations_isValid;

    m_field_level_encryption_id_isValid = ::OpenAPI::fromJsonValue(m_field_level_encryption_id, json[QString("FieldLevelEncryptionId")]);
    m_field_level_encryption_id_isSet = !json[QString("FieldLevelEncryptionId")].isNull() && m_field_level_encryption_id_isValid;
}

QString OAICacheBehavior::asJson() const {
    QJsonObject obj = this->asJsonObject();
    QJsonDocument doc(obj);
    QByteArray bytes = doc.toJson();
    return QString(bytes);
}

QJsonObject OAICacheBehavior::asJsonObject() const {
    QJsonObject obj;
    if (m_path_pattern_isSet) {
        obj.insert(QString("PathPattern"), ::OpenAPI::toJsonValue(m_path_pattern));
    }
    if (m_target_origin_id_isSet) {
        obj.insert(QString("TargetOriginId"), ::OpenAPI::toJsonValue(m_target_origin_id));
    }
    if (m_forwarded_values.isSet()) {
        obj.insert(QString("ForwardedValues"), ::OpenAPI::toJsonValue(m_forwarded_values));
    }
    if (m_trusted_signers.isSet()) {
        obj.insert(QString("TrustedSigners"), ::OpenAPI::toJsonValue(m_trusted_signers));
    }
    if (m_viewer_protocol_policy.isSet()) {
        obj.insert(QString("ViewerProtocolPolicy"), ::OpenAPI::toJsonValue(m_viewer_protocol_policy));
    }
    if (m_min_ttl_isSet) {
        obj.insert(QString("MinTTL"), ::OpenAPI::toJsonValue(m_min_ttl));
    }
    if (m_allowed_methods.isSet()) {
        obj.insert(QString("AllowedMethods"), ::OpenAPI::toJsonValue(m_allowed_methods));
    }
    if (m_smooth_streaming_isSet) {
        obj.insert(QString("SmoothStreaming"), ::OpenAPI::toJsonValue(m_smooth_streaming));
    }
    if (m_default_ttl_isSet) {
        obj.insert(QString("DefaultTTL"), ::OpenAPI::toJsonValue(m_default_ttl));
    }
    if (m_max_ttl_isSet) {
        obj.insert(QString("MaxTTL"), ::OpenAPI::toJsonValue(m_max_ttl));
    }
    if (m_compress_isSet) {
        obj.insert(QString("Compress"), ::OpenAPI::toJsonValue(m_compress));
    }
    if (m_lambda_function_associations.isSet()) {
        obj.insert(QString("LambdaFunctionAssociations"), ::OpenAPI::toJsonValue(m_lambda_function_associations));
    }
    if (m_field_level_encryption_id_isSet) {
        obj.insert(QString("FieldLevelEncryptionId"), ::OpenAPI::toJsonValue(m_field_level_encryption_id));
    }
    return obj;
}

QString OAICacheBehavior::getPathPattern() const {
    return m_path_pattern;
}
void OAICacheBehavior::setPathPattern(const QString &path_pattern) {
    m_path_pattern = path_pattern;
    m_path_pattern_isSet = true;
}

bool OAICacheBehavior::is_path_pattern_Set() const{
    return m_path_pattern_isSet;
}

bool OAICacheBehavior::is_path_pattern_Valid() const{
    return m_path_pattern_isValid;
}

QString OAICacheBehavior::getTargetOriginId() const {
    return m_target_origin_id;
}
void OAICacheBehavior::setTargetOriginId(const QString &target_origin_id) {
    m_target_origin_id = target_origin_id;
    m_target_origin_id_isSet = true;
}

bool OAICacheBehavior::is_target_origin_id_Set() const{
    return m_target_origin_id_isSet;
}

bool OAICacheBehavior::is_target_origin_id_Valid() const{
    return m_target_origin_id_isValid;
}

OAIDefaultCacheBehavior_ForwardedValues OAICacheBehavior::getForwardedValues() const {
    return m_forwarded_values;
}
void OAICacheBehavior::setForwardedValues(const OAIDefaultCacheBehavior_ForwardedValues &forwarded_values) {
    m_forwarded_values = forwarded_values;
    m_forwarded_values_isSet = true;
}

bool OAICacheBehavior::is_forwarded_values_Set() const{
    return m_forwarded_values_isSet;
}

bool OAICacheBehavior::is_forwarded_values_Valid() const{
    return m_forwarded_values_isValid;
}

OAIDefaultCacheBehavior_TrustedSigners OAICacheBehavior::getTrustedSigners() const {
    return m_trusted_signers;
}
void OAICacheBehavior::setTrustedSigners(const OAIDefaultCacheBehavior_TrustedSigners &trusted_signers) {
    m_trusted_signers = trusted_signers;
    m_trusted_signers_isSet = true;
}

bool OAICacheBehavior::is_trusted_signers_Set() const{
    return m_trusted_signers_isSet;
}

bool OAICacheBehavior::is_trusted_signers_Valid() const{
    return m_trusted_signers_isValid;
}

OAIViewerProtocolPolicy OAICacheBehavior::getViewerProtocolPolicy() const {
    return m_viewer_protocol_policy;
}
void OAICacheBehavior::setViewerProtocolPolicy(const OAIViewerProtocolPolicy &viewer_protocol_policy) {
    m_viewer_protocol_policy = viewer_protocol_policy;
    m_viewer_protocol_policy_isSet = true;
}

bool OAICacheBehavior::is_viewer_protocol_policy_Set() const{
    return m_viewer_protocol_policy_isSet;
}

bool OAICacheBehavior::is_viewer_protocol_policy_Valid() const{
    return m_viewer_protocol_policy_isValid;
}

qint32 OAICacheBehavior::getMinTtl() const {
    return m_min_ttl;
}
void OAICacheBehavior::setMinTtl(const qint32 &min_ttl) {
    m_min_ttl = min_ttl;
    m_min_ttl_isSet = true;
}

bool OAICacheBehavior::is_min_ttl_Set() const{
    return m_min_ttl_isSet;
}

bool OAICacheBehavior::is_min_ttl_Valid() const{
    return m_min_ttl_isValid;
}

OAIAllowedMethods OAICacheBehavior::getAllowedMethods() const {
    return m_allowed_methods;
}
void OAICacheBehavior::setAllowedMethods(const OAIAllowedMethods &allowed_methods) {
    m_allowed_methods = allowed_methods;
    m_allowed_methods_isSet = true;
}

bool OAICacheBehavior::is_allowed_methods_Set() const{
    return m_allowed_methods_isSet;
}

bool OAICacheBehavior::is_allowed_methods_Valid() const{
    return m_allowed_methods_isValid;
}

bool OAICacheBehavior::getSmoothStreaming() const {
    return m_smooth_streaming;
}
void OAICacheBehavior::setSmoothStreaming(const bool &smooth_streaming) {
    m_smooth_streaming = smooth_streaming;
    m_smooth_streaming_isSet = true;
}

bool OAICacheBehavior::is_smooth_streaming_Set() const{
    return m_smooth_streaming_isSet;
}

bool OAICacheBehavior::is_smooth_streaming_Valid() const{
    return m_smooth_streaming_isValid;
}

qint32 OAICacheBehavior::getDefaultTtl() const {
    return m_default_ttl;
}
void OAICacheBehavior::setDefaultTtl(const qint32 &default_ttl) {
    m_default_ttl = default_ttl;
    m_default_ttl_isSet = true;
}

bool OAICacheBehavior::is_default_ttl_Set() const{
    return m_default_ttl_isSet;
}

bool OAICacheBehavior::is_default_ttl_Valid() const{
    return m_default_ttl_isValid;
}

qint32 OAICacheBehavior::getMaxTtl() const {
    return m_max_ttl;
}
void OAICacheBehavior::setMaxTtl(const qint32 &max_ttl) {
    m_max_ttl = max_ttl;
    m_max_ttl_isSet = true;
}

bool OAICacheBehavior::is_max_ttl_Set() const{
    return m_max_ttl_isSet;
}

bool OAICacheBehavior::is_max_ttl_Valid() const{
    return m_max_ttl_isValid;
}

bool OAICacheBehavior::getCompress() const {
    return m_compress;
}
void OAICacheBehavior::setCompress(const bool &compress) {
    m_compress = compress;
    m_compress_isSet = true;
}

bool OAICacheBehavior::is_compress_Set() const{
    return m_compress_isSet;
}

bool OAICacheBehavior::is_compress_Valid() const{
    return m_compress_isValid;
}

OAIDefaultCacheBehavior_LambdaFunctionAssociations OAICacheBehavior::getLambdaFunctionAssociations() const {
    return m_lambda_function_associations;
}
void OAICacheBehavior::setLambdaFunctionAssociations(const OAIDefaultCacheBehavior_LambdaFunctionAssociations &lambda_function_associations) {
    m_lambda_function_associations = lambda_function_associations;
    m_lambda_function_associations_isSet = true;
}

bool OAICacheBehavior::is_lambda_function_associations_Set() const{
    return m_lambda_function_associations_isSet;
}

bool OAICacheBehavior::is_lambda_function_associations_Valid() const{
    return m_lambda_function_associations_isValid;
}

QString OAICacheBehavior::getFieldLevelEncryptionId() const {
    return m_field_level_encryption_id;
}
void OAICacheBehavior::setFieldLevelEncryptionId(const QString &field_level_encryption_id) {
    m_field_level_encryption_id = field_level_encryption_id;
    m_field_level_encryption_id_isSet = true;
}

bool OAICacheBehavior::is_field_level_encryption_id_Set() const{
    return m_field_level_encryption_id_isSet;
}

bool OAICacheBehavior::is_field_level_encryption_id_Valid() const{
    return m_field_level_encryption_id_isValid;
}

bool OAICacheBehavior::isSet() const {
    bool isObjectUpdated = false;
    do {
        if (m_path_pattern_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_target_origin_id_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_forwarded_values.isSet()) {
            isObjectUpdated = true;
            break;
        }

        if (m_trusted_signers.isSet()) {
            isObjectUpdated = true;
            break;
        }

        if (m_viewer_protocol_policy.isSet()) {
            isObjectUpdated = true;
            break;
        }

        if (m_min_ttl_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_allowed_methods.isSet()) {
            isObjectUpdated = true;
            break;
        }

        if (m_smooth_streaming_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_default_ttl_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_max_ttl_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_compress_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_lambda_function_associations.isSet()) {
            isObjectUpdated = true;
            break;
        }

        if (m_field_level_encryption_id_isSet) {
            isObjectUpdated = true;
            break;
        }
    } while (false);
    return isObjectUpdated;
}

bool OAICacheBehavior::isValid() const {
    // only required properties are required for the object to be considered valid
    return m_path_pattern_isValid && m_target_origin_id_isValid && m_forwarded_values_isValid && m_trusted_signers_isValid && m_viewer_protocol_policy_isValid && m_min_ttl_isValid && true;
}

} // namespace OpenAPI
