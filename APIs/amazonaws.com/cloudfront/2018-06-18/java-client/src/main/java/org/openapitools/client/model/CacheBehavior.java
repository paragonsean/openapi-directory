/*
 * Amazon CloudFront
 * <fullname>Amazon CloudFront</fullname> <p>This is the <i>Amazon CloudFront API Reference</i>. This guide is for developers who need detailed information about CloudFront API actions, data types, and errors. For detailed information about CloudFront features, see the <i>Amazon CloudFront Developer Guide</i>.</p>
 *
 * The version of the OpenAPI document: 2018-06-18
 * Contact: mike.ralphson@gmail.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package org.openapitools.client.model;

import java.util.Objects;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;
import java.util.Arrays;
import org.openapitools.client.model.AllowedMethods;
import org.openapitools.client.model.DefaultCacheBehaviorForwardedValues;
import org.openapitools.client.model.DefaultCacheBehaviorLambdaFunctionAssociations;
import org.openapitools.client.model.DefaultCacheBehaviorTrustedSigners;
import org.openapitools.client.model.ViewerProtocolPolicy;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonArray;
import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;
import com.google.gson.TypeAdapterFactory;
import com.google.gson.reflect.TypeToken;
import com.google.gson.TypeAdapter;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;

import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import org.openapitools.client.JSON;

/**
 * &lt;p&gt;A complex type that describes how CloudFront processes requests.&lt;/p&gt; &lt;p&gt;You must create at least as many cache behaviors (including the default cache behavior) as you have origins if you want CloudFront to distribute objects from all of the origins. Each cache behavior specifies the one origin from which you want CloudFront to get objects. If you have two origins and only the default cache behavior, the default cache behavior will cause CloudFront to get objects from one of the origins, but the other origin is never used.&lt;/p&gt; &lt;p&gt;For the current limit on the number of cache behaviors that you can add to a distribution, see &lt;a href&#x3D;\&quot;http://docs.aws.amazon.com/general/latest/gr/aws_service_limits.html#limits_cloudfront\&quot;&gt;Amazon CloudFront Limits&lt;/a&gt; in the &lt;i&gt;AWS General Reference&lt;/i&gt;.&lt;/p&gt; &lt;p&gt;If you don&#39;t want to specify any cache behaviors, include only an empty &lt;code&gt;CacheBehaviors&lt;/code&gt; element. Don&#39;t include an empty &lt;code&gt;CacheBehavior&lt;/code&gt; element, or CloudFront returns a &lt;code&gt;MalformedXML&lt;/code&gt; error.&lt;/p&gt; &lt;p&gt;To delete all cache behaviors in an existing distribution, update the distribution configuration and include only an empty &lt;code&gt;CacheBehaviors&lt;/code&gt; element.&lt;/p&gt; &lt;p&gt;To add, change, or remove one or more cache behaviors, update the distribution configuration and specify all of the cache behaviors that you want to include in the updated distribution.&lt;/p&gt; &lt;p&gt;For more information about cache behaviors, see &lt;a href&#x3D;\&quot;http://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/distribution-web-values-specify.html#DownloadDistValuesCacheBehavior\&quot;&gt;Cache Behaviors&lt;/a&gt; in the &lt;i&gt;Amazon CloudFront Developer Guide&lt;/i&gt;.&lt;/p&gt;
 */
@javax.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen", date = "2024-10-12T12:04:40.036732-04:00[America/New_York]", comments = "Generator version: 7.9.0")
public class CacheBehavior {
  public static final String SERIALIZED_NAME_PATH_PATTERN = "PathPattern";
  @SerializedName(SERIALIZED_NAME_PATH_PATTERN)
  private String pathPattern;

  public static final String SERIALIZED_NAME_TARGET_ORIGIN_ID = "TargetOriginId";
  @SerializedName(SERIALIZED_NAME_TARGET_ORIGIN_ID)
  private String targetOriginId;

  public static final String SERIALIZED_NAME_FORWARDED_VALUES = "ForwardedValues";
  @SerializedName(SERIALIZED_NAME_FORWARDED_VALUES)
  private DefaultCacheBehaviorForwardedValues forwardedValues;

  public static final String SERIALIZED_NAME_TRUSTED_SIGNERS = "TrustedSigners";
  @SerializedName(SERIALIZED_NAME_TRUSTED_SIGNERS)
  private DefaultCacheBehaviorTrustedSigners trustedSigners;

  public static final String SERIALIZED_NAME_VIEWER_PROTOCOL_POLICY = "ViewerProtocolPolicy";
  @SerializedName(SERIALIZED_NAME_VIEWER_PROTOCOL_POLICY)
  private ViewerProtocolPolicy viewerProtocolPolicy;

  public static final String SERIALIZED_NAME_MIN_T_T_L = "MinTTL";
  @SerializedName(SERIALIZED_NAME_MIN_T_T_L)
  private Integer minTTL;

  public static final String SERIALIZED_NAME_ALLOWED_METHODS = "AllowedMethods";
  @SerializedName(SERIALIZED_NAME_ALLOWED_METHODS)
  private AllowedMethods allowedMethods;

  public static final String SERIALIZED_NAME_SMOOTH_STREAMING = "SmoothStreaming";
  @SerializedName(SERIALIZED_NAME_SMOOTH_STREAMING)
  private Boolean smoothStreaming;

  public static final String SERIALIZED_NAME_DEFAULT_T_T_L = "DefaultTTL";
  @SerializedName(SERIALIZED_NAME_DEFAULT_T_T_L)
  private Integer defaultTTL;

  public static final String SERIALIZED_NAME_MAX_T_T_L = "MaxTTL";
  @SerializedName(SERIALIZED_NAME_MAX_T_T_L)
  private Integer maxTTL;

  public static final String SERIALIZED_NAME_COMPRESS = "Compress";
  @SerializedName(SERIALIZED_NAME_COMPRESS)
  private Boolean compress;

  public static final String SERIALIZED_NAME_LAMBDA_FUNCTION_ASSOCIATIONS = "LambdaFunctionAssociations";
  @SerializedName(SERIALIZED_NAME_LAMBDA_FUNCTION_ASSOCIATIONS)
  private DefaultCacheBehaviorLambdaFunctionAssociations lambdaFunctionAssociations;

  public static final String SERIALIZED_NAME_FIELD_LEVEL_ENCRYPTION_ID = "FieldLevelEncryptionId";
  @SerializedName(SERIALIZED_NAME_FIELD_LEVEL_ENCRYPTION_ID)
  private String fieldLevelEncryptionId;

  public CacheBehavior() {
  }

  public CacheBehavior pathPattern(String pathPattern) {
    this.pathPattern = pathPattern;
    return this;
  }

  /**
   * Get pathPattern
   * @return pathPattern
   */
  @javax.annotation.Nonnull
  public String getPathPattern() {
    return pathPattern;
  }

  public void setPathPattern(String pathPattern) {
    this.pathPattern = pathPattern;
  }


  public CacheBehavior targetOriginId(String targetOriginId) {
    this.targetOriginId = targetOriginId;
    return this;
  }

  /**
   * Get targetOriginId
   * @return targetOriginId
   */
  @javax.annotation.Nonnull
  public String getTargetOriginId() {
    return targetOriginId;
  }

  public void setTargetOriginId(String targetOriginId) {
    this.targetOriginId = targetOriginId;
  }


  public CacheBehavior forwardedValues(DefaultCacheBehaviorForwardedValues forwardedValues) {
    this.forwardedValues = forwardedValues;
    return this;
  }

  /**
   * Get forwardedValues
   * @return forwardedValues
   */
  @javax.annotation.Nonnull
  public DefaultCacheBehaviorForwardedValues getForwardedValues() {
    return forwardedValues;
  }

  public void setForwardedValues(DefaultCacheBehaviorForwardedValues forwardedValues) {
    this.forwardedValues = forwardedValues;
  }


  public CacheBehavior trustedSigners(DefaultCacheBehaviorTrustedSigners trustedSigners) {
    this.trustedSigners = trustedSigners;
    return this;
  }

  /**
   * Get trustedSigners
   * @return trustedSigners
   */
  @javax.annotation.Nonnull
  public DefaultCacheBehaviorTrustedSigners getTrustedSigners() {
    return trustedSigners;
  }

  public void setTrustedSigners(DefaultCacheBehaviorTrustedSigners trustedSigners) {
    this.trustedSigners = trustedSigners;
  }


  public CacheBehavior viewerProtocolPolicy(ViewerProtocolPolicy viewerProtocolPolicy) {
    this.viewerProtocolPolicy = viewerProtocolPolicy;
    return this;
  }

  /**
   * Get viewerProtocolPolicy
   * @return viewerProtocolPolicy
   */
  @javax.annotation.Nonnull
  public ViewerProtocolPolicy getViewerProtocolPolicy() {
    return viewerProtocolPolicy;
  }

  public void setViewerProtocolPolicy(ViewerProtocolPolicy viewerProtocolPolicy) {
    this.viewerProtocolPolicy = viewerProtocolPolicy;
  }


  public CacheBehavior minTTL(Integer minTTL) {
    this.minTTL = minTTL;
    return this;
  }

  /**
   * Get minTTL
   * @return minTTL
   */
  @javax.annotation.Nonnull
  public Integer getMinTTL() {
    return minTTL;
  }

  public void setMinTTL(Integer minTTL) {
    this.minTTL = minTTL;
  }


  public CacheBehavior allowedMethods(AllowedMethods allowedMethods) {
    this.allowedMethods = allowedMethods;
    return this;
  }

  /**
   * Get allowedMethods
   * @return allowedMethods
   */
  @javax.annotation.Nullable
  public AllowedMethods getAllowedMethods() {
    return allowedMethods;
  }

  public void setAllowedMethods(AllowedMethods allowedMethods) {
    this.allowedMethods = allowedMethods;
  }


  public CacheBehavior smoothStreaming(Boolean smoothStreaming) {
    this.smoothStreaming = smoothStreaming;
    return this;
  }

  /**
   * Get smoothStreaming
   * @return smoothStreaming
   */
  @javax.annotation.Nullable
  public Boolean getSmoothStreaming() {
    return smoothStreaming;
  }

  public void setSmoothStreaming(Boolean smoothStreaming) {
    this.smoothStreaming = smoothStreaming;
  }


  public CacheBehavior defaultTTL(Integer defaultTTL) {
    this.defaultTTL = defaultTTL;
    return this;
  }

  /**
   * Get defaultTTL
   * @return defaultTTL
   */
  @javax.annotation.Nullable
  public Integer getDefaultTTL() {
    return defaultTTL;
  }

  public void setDefaultTTL(Integer defaultTTL) {
    this.defaultTTL = defaultTTL;
  }


  public CacheBehavior maxTTL(Integer maxTTL) {
    this.maxTTL = maxTTL;
    return this;
  }

  /**
   * Get maxTTL
   * @return maxTTL
   */
  @javax.annotation.Nullable
  public Integer getMaxTTL() {
    return maxTTL;
  }

  public void setMaxTTL(Integer maxTTL) {
    this.maxTTL = maxTTL;
  }


  public CacheBehavior compress(Boolean compress) {
    this.compress = compress;
    return this;
  }

  /**
   * Get compress
   * @return compress
   */
  @javax.annotation.Nullable
  public Boolean getCompress() {
    return compress;
  }

  public void setCompress(Boolean compress) {
    this.compress = compress;
  }


  public CacheBehavior lambdaFunctionAssociations(DefaultCacheBehaviorLambdaFunctionAssociations lambdaFunctionAssociations) {
    this.lambdaFunctionAssociations = lambdaFunctionAssociations;
    return this;
  }

  /**
   * Get lambdaFunctionAssociations
   * @return lambdaFunctionAssociations
   */
  @javax.annotation.Nullable
  public DefaultCacheBehaviorLambdaFunctionAssociations getLambdaFunctionAssociations() {
    return lambdaFunctionAssociations;
  }

  public void setLambdaFunctionAssociations(DefaultCacheBehaviorLambdaFunctionAssociations lambdaFunctionAssociations) {
    this.lambdaFunctionAssociations = lambdaFunctionAssociations;
  }


  public CacheBehavior fieldLevelEncryptionId(String fieldLevelEncryptionId) {
    this.fieldLevelEncryptionId = fieldLevelEncryptionId;
    return this;
  }

  /**
   * Get fieldLevelEncryptionId
   * @return fieldLevelEncryptionId
   */
  @javax.annotation.Nullable
  public String getFieldLevelEncryptionId() {
    return fieldLevelEncryptionId;
  }

  public void setFieldLevelEncryptionId(String fieldLevelEncryptionId) {
    this.fieldLevelEncryptionId = fieldLevelEncryptionId;
  }



  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    CacheBehavior cacheBehavior = (CacheBehavior) o;
    return Objects.equals(this.pathPattern, cacheBehavior.pathPattern) &&
        Objects.equals(this.targetOriginId, cacheBehavior.targetOriginId) &&
        Objects.equals(this.forwardedValues, cacheBehavior.forwardedValues) &&
        Objects.equals(this.trustedSigners, cacheBehavior.trustedSigners) &&
        Objects.equals(this.viewerProtocolPolicy, cacheBehavior.viewerProtocolPolicy) &&
        Objects.equals(this.minTTL, cacheBehavior.minTTL) &&
        Objects.equals(this.allowedMethods, cacheBehavior.allowedMethods) &&
        Objects.equals(this.smoothStreaming, cacheBehavior.smoothStreaming) &&
        Objects.equals(this.defaultTTL, cacheBehavior.defaultTTL) &&
        Objects.equals(this.maxTTL, cacheBehavior.maxTTL) &&
        Objects.equals(this.compress, cacheBehavior.compress) &&
        Objects.equals(this.lambdaFunctionAssociations, cacheBehavior.lambdaFunctionAssociations) &&
        Objects.equals(this.fieldLevelEncryptionId, cacheBehavior.fieldLevelEncryptionId);
  }

  @Override
  public int hashCode() {
    return Objects.hash(pathPattern, targetOriginId, forwardedValues, trustedSigners, viewerProtocolPolicy, minTTL, allowedMethods, smoothStreaming, defaultTTL, maxTTL, compress, lambdaFunctionAssociations, fieldLevelEncryptionId);
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class CacheBehavior {\n");
    sb.append("    pathPattern: ").append(toIndentedString(pathPattern)).append("\n");
    sb.append("    targetOriginId: ").append(toIndentedString(targetOriginId)).append("\n");
    sb.append("    forwardedValues: ").append(toIndentedString(forwardedValues)).append("\n");
    sb.append("    trustedSigners: ").append(toIndentedString(trustedSigners)).append("\n");
    sb.append("    viewerProtocolPolicy: ").append(toIndentedString(viewerProtocolPolicy)).append("\n");
    sb.append("    minTTL: ").append(toIndentedString(minTTL)).append("\n");
    sb.append("    allowedMethods: ").append(toIndentedString(allowedMethods)).append("\n");
    sb.append("    smoothStreaming: ").append(toIndentedString(smoothStreaming)).append("\n");
    sb.append("    defaultTTL: ").append(toIndentedString(defaultTTL)).append("\n");
    sb.append("    maxTTL: ").append(toIndentedString(maxTTL)).append("\n");
    sb.append("    compress: ").append(toIndentedString(compress)).append("\n");
    sb.append("    lambdaFunctionAssociations: ").append(toIndentedString(lambdaFunctionAssociations)).append("\n");
    sb.append("    fieldLevelEncryptionId: ").append(toIndentedString(fieldLevelEncryptionId)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }


  public static HashSet<String> openapiFields;
  public static HashSet<String> openapiRequiredFields;

  static {
    // a set of all properties/fields (JSON key names)
    openapiFields = new HashSet<String>();
    openapiFields.add("PathPattern");
    openapiFields.add("TargetOriginId");
    openapiFields.add("ForwardedValues");
    openapiFields.add("TrustedSigners");
    openapiFields.add("ViewerProtocolPolicy");
    openapiFields.add("MinTTL");
    openapiFields.add("AllowedMethods");
    openapiFields.add("SmoothStreaming");
    openapiFields.add("DefaultTTL");
    openapiFields.add("MaxTTL");
    openapiFields.add("Compress");
    openapiFields.add("LambdaFunctionAssociations");
    openapiFields.add("FieldLevelEncryptionId");

    // a set of required properties/fields (JSON key names)
    openapiRequiredFields = new HashSet<String>();
    openapiRequiredFields.add("PathPattern");
    openapiRequiredFields.add("TargetOriginId");
    openapiRequiredFields.add("ForwardedValues");
    openapiRequiredFields.add("TrustedSigners");
    openapiRequiredFields.add("ViewerProtocolPolicy");
    openapiRequiredFields.add("MinTTL");
  }

  /**
   * Validates the JSON Element and throws an exception if issues found
   *
   * @param jsonElement JSON Element
   * @throws IOException if the JSON Element is invalid with respect to CacheBehavior
   */
  public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      if (jsonElement == null) {
        if (!CacheBehavior.openapiRequiredFields.isEmpty()) { // has required fields but JSON element is null
          throw new IllegalArgumentException(String.format("The required field(s) %s in CacheBehavior is not found in the empty JSON string", CacheBehavior.openapiRequiredFields.toString()));
        }
      }

      Set<Map.Entry<String, JsonElement>> entries = jsonElement.getAsJsonObject().entrySet();
      // check to see if the JSON string contains additional fields
      for (Map.Entry<String, JsonElement> entry : entries) {
        if (!CacheBehavior.openapiFields.contains(entry.getKey())) {
          throw new IllegalArgumentException(String.format("The field `%s` in the JSON string is not defined in the `CacheBehavior` properties. JSON: %s", entry.getKey(), jsonElement.toString()));
        }
      }

      // check to make sure all required properties/fields are present in the JSON string
      for (String requiredField : CacheBehavior.openapiRequiredFields) {
        if (jsonElement.getAsJsonObject().get(requiredField) == null) {
          throw new IllegalArgumentException(String.format("The required field `%s` is not found in the JSON string: %s", requiredField, jsonElement.toString()));
        }
      }
        JsonObject jsonObj = jsonElement.getAsJsonObject();
      // validate the required field `PathPattern`
      String.validateJsonElement(jsonObj.get("PathPattern"));
      // validate the required field `TargetOriginId`
      String.validateJsonElement(jsonObj.get("TargetOriginId"));
      // validate the required field `ForwardedValues`
      DefaultCacheBehaviorForwardedValues.validateJsonElement(jsonObj.get("ForwardedValues"));
      // validate the required field `TrustedSigners`
      DefaultCacheBehaviorTrustedSigners.validateJsonElement(jsonObj.get("TrustedSigners"));
      // validate the required field `ViewerProtocolPolicy`
      ViewerProtocolPolicy.validateJsonElement(jsonObj.get("ViewerProtocolPolicy"));
      // validate the required field `MinTTL`
      Integer.validateJsonElement(jsonObj.get("MinTTL"));
      // validate the optional field `AllowedMethods`
      if (jsonObj.get("AllowedMethods") != null && !jsonObj.get("AllowedMethods").isJsonNull()) {
        AllowedMethods.validateJsonElement(jsonObj.get("AllowedMethods"));
      }
      // validate the optional field `SmoothStreaming`
      if (jsonObj.get("SmoothStreaming") != null && !jsonObj.get("SmoothStreaming").isJsonNull()) {
        Boolean.validateJsonElement(jsonObj.get("SmoothStreaming"));
      }
      // validate the optional field `DefaultTTL`
      if (jsonObj.get("DefaultTTL") != null && !jsonObj.get("DefaultTTL").isJsonNull()) {
        Integer.validateJsonElement(jsonObj.get("DefaultTTL"));
      }
      // validate the optional field `MaxTTL`
      if (jsonObj.get("MaxTTL") != null && !jsonObj.get("MaxTTL").isJsonNull()) {
        Integer.validateJsonElement(jsonObj.get("MaxTTL"));
      }
      // validate the optional field `Compress`
      if (jsonObj.get("Compress") != null && !jsonObj.get("Compress").isJsonNull()) {
        Boolean.validateJsonElement(jsonObj.get("Compress"));
      }
      // validate the optional field `LambdaFunctionAssociations`
      if (jsonObj.get("LambdaFunctionAssociations") != null && !jsonObj.get("LambdaFunctionAssociations").isJsonNull()) {
        DefaultCacheBehaviorLambdaFunctionAssociations.validateJsonElement(jsonObj.get("LambdaFunctionAssociations"));
      }
      // validate the optional field `FieldLevelEncryptionId`
      if (jsonObj.get("FieldLevelEncryptionId") != null && !jsonObj.get("FieldLevelEncryptionId").isJsonNull()) {
        String.validateJsonElement(jsonObj.get("FieldLevelEncryptionId"));
      }
  }

  public static class CustomTypeAdapterFactory implements TypeAdapterFactory {
    @SuppressWarnings("unchecked")
    @Override
    public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
       if (!CacheBehavior.class.isAssignableFrom(type.getRawType())) {
         return null; // this class only serializes 'CacheBehavior' and its subtypes
       }
       final TypeAdapter<JsonElement> elementAdapter = gson.getAdapter(JsonElement.class);
       final TypeAdapter<CacheBehavior> thisAdapter
                        = gson.getDelegateAdapter(this, TypeToken.get(CacheBehavior.class));

       return (TypeAdapter<T>) new TypeAdapter<CacheBehavior>() {
           @Override
           public void write(JsonWriter out, CacheBehavior value) throws IOException {
             JsonObject obj = thisAdapter.toJsonTree(value).getAsJsonObject();
             elementAdapter.write(out, obj);
           }

           @Override
           public CacheBehavior read(JsonReader in) throws IOException {
             JsonElement jsonElement = elementAdapter.read(in);
             validateJsonElement(jsonElement);
             return thisAdapter.fromJsonTree(jsonElement);
           }

       }.nullSafe();
    }
  }

  /**
   * Create an instance of CacheBehavior given an JSON string
   *
   * @param jsonString JSON string
   * @return An instance of CacheBehavior
   * @throws IOException if the JSON string is invalid with respect to CacheBehavior
   */
  public static CacheBehavior fromJson(String jsonString) throws IOException {
    return JSON.getGson().fromJson(jsonString, CacheBehavior.class);
  }

  /**
   * Convert an instance of CacheBehavior to an JSON string
   *
   * @return JSON string
   */
  public String toJson() {
    return JSON.getGson().toJson(this);
  }
}

