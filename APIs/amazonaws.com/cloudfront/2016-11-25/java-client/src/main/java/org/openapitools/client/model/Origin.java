/*
 * Amazon CloudFront
 * <fullname>Amazon CloudFront</fullname> <p>This is the <i>Amazon CloudFront API Reference</i>. This guide is for developers who need detailed information about the CloudFront API actions, data types, and errors. For detailed information about CloudFront features and their associated API calls, see the <i>Amazon CloudFront Developer Guide</i>.</p>
 *
 * The version of the OpenAPI document: 2016-11-25
 * Contact: mike.ralphson@gmail.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package org.openapitools.client.model;

import java.util.Objects;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;
import java.util.Arrays;
import org.openapitools.client.model.OriginCustomHeaders;
import org.openapitools.client.model.OriginCustomOriginConfig;
import org.openapitools.client.model.OriginS3OriginConfig;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonArray;
import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;
import com.google.gson.TypeAdapterFactory;
import com.google.gson.reflect.TypeToken;
import com.google.gson.TypeAdapter;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;

import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import org.openapitools.client.JSON;

/**
 * &lt;p&gt;A complex type that describes the Amazon S3 bucket or the HTTP server (for example, a web server) from which CloudFront gets your files. You must create at least one origin.&lt;/p&gt; &lt;p&gt;For the current limit on the number of origins that you can create for a distribution, see &lt;a href&#x3D;\&quot;http://docs.aws.amazon.com/general/latest/gr/aws_service_limits.html#limits_cloudfront\&quot;&gt;Amazon CloudFront Limits&lt;/a&gt; in the &lt;i&gt;AWS General Reference&lt;/i&gt;.&lt;/p&gt;
 */
@javax.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen", date = "2024-10-12T12:04:55.977307-04:00[America/New_York]", comments = "Generator version: 7.9.0")
public class Origin {
  public static final String SERIALIZED_NAME_ID = "Id";
  @SerializedName(SERIALIZED_NAME_ID)
  private String id;

  public static final String SERIALIZED_NAME_DOMAIN_NAME = "DomainName";
  @SerializedName(SERIALIZED_NAME_DOMAIN_NAME)
  private String domainName;

  public static final String SERIALIZED_NAME_ORIGIN_PATH = "OriginPath";
  @SerializedName(SERIALIZED_NAME_ORIGIN_PATH)
  private String originPath;

  public static final String SERIALIZED_NAME_CUSTOM_HEADERS = "CustomHeaders";
  @SerializedName(SERIALIZED_NAME_CUSTOM_HEADERS)
  private OriginCustomHeaders customHeaders;

  public static final String SERIALIZED_NAME_S3_ORIGIN_CONFIG = "S3OriginConfig";
  @SerializedName(SERIALIZED_NAME_S3_ORIGIN_CONFIG)
  private OriginS3OriginConfig s3OriginConfig;

  public static final String SERIALIZED_NAME_CUSTOM_ORIGIN_CONFIG = "CustomOriginConfig";
  @SerializedName(SERIALIZED_NAME_CUSTOM_ORIGIN_CONFIG)
  private OriginCustomOriginConfig customOriginConfig;

  public Origin() {
  }

  public Origin id(String id) {
    this.id = id;
    return this;
  }

  /**
   * Get id
   * @return id
   */
  @javax.annotation.Nonnull
  public String getId() {
    return id;
  }

  public void setId(String id) {
    this.id = id;
  }


  public Origin domainName(String domainName) {
    this.domainName = domainName;
    return this;
  }

  /**
   * Get domainName
   * @return domainName
   */
  @javax.annotation.Nonnull
  public String getDomainName() {
    return domainName;
  }

  public void setDomainName(String domainName) {
    this.domainName = domainName;
  }


  public Origin originPath(String originPath) {
    this.originPath = originPath;
    return this;
  }

  /**
   * Get originPath
   * @return originPath
   */
  @javax.annotation.Nullable
  public String getOriginPath() {
    return originPath;
  }

  public void setOriginPath(String originPath) {
    this.originPath = originPath;
  }


  public Origin customHeaders(OriginCustomHeaders customHeaders) {
    this.customHeaders = customHeaders;
    return this;
  }

  /**
   * Get customHeaders
   * @return customHeaders
   */
  @javax.annotation.Nullable
  public OriginCustomHeaders getCustomHeaders() {
    return customHeaders;
  }

  public void setCustomHeaders(OriginCustomHeaders customHeaders) {
    this.customHeaders = customHeaders;
  }


  public Origin s3OriginConfig(OriginS3OriginConfig s3OriginConfig) {
    this.s3OriginConfig = s3OriginConfig;
    return this;
  }

  /**
   * Get s3OriginConfig
   * @return s3OriginConfig
   */
  @javax.annotation.Nullable
  public OriginS3OriginConfig getS3OriginConfig() {
    return s3OriginConfig;
  }

  public void setS3OriginConfig(OriginS3OriginConfig s3OriginConfig) {
    this.s3OriginConfig = s3OriginConfig;
  }


  public Origin customOriginConfig(OriginCustomOriginConfig customOriginConfig) {
    this.customOriginConfig = customOriginConfig;
    return this;
  }

  /**
   * Get customOriginConfig
   * @return customOriginConfig
   */
  @javax.annotation.Nullable
  public OriginCustomOriginConfig getCustomOriginConfig() {
    return customOriginConfig;
  }

  public void setCustomOriginConfig(OriginCustomOriginConfig customOriginConfig) {
    this.customOriginConfig = customOriginConfig;
  }



  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    Origin origin = (Origin) o;
    return Objects.equals(this.id, origin.id) &&
        Objects.equals(this.domainName, origin.domainName) &&
        Objects.equals(this.originPath, origin.originPath) &&
        Objects.equals(this.customHeaders, origin.customHeaders) &&
        Objects.equals(this.s3OriginConfig, origin.s3OriginConfig) &&
        Objects.equals(this.customOriginConfig, origin.customOriginConfig);
  }

  @Override
  public int hashCode() {
    return Objects.hash(id, domainName, originPath, customHeaders, s3OriginConfig, customOriginConfig);
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class Origin {\n");
    sb.append("    id: ").append(toIndentedString(id)).append("\n");
    sb.append("    domainName: ").append(toIndentedString(domainName)).append("\n");
    sb.append("    originPath: ").append(toIndentedString(originPath)).append("\n");
    sb.append("    customHeaders: ").append(toIndentedString(customHeaders)).append("\n");
    sb.append("    s3OriginConfig: ").append(toIndentedString(s3OriginConfig)).append("\n");
    sb.append("    customOriginConfig: ").append(toIndentedString(customOriginConfig)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }


  public static HashSet<String> openapiFields;
  public static HashSet<String> openapiRequiredFields;

  static {
    // a set of all properties/fields (JSON key names)
    openapiFields = new HashSet<String>();
    openapiFields.add("Id");
    openapiFields.add("DomainName");
    openapiFields.add("OriginPath");
    openapiFields.add("CustomHeaders");
    openapiFields.add("S3OriginConfig");
    openapiFields.add("CustomOriginConfig");

    // a set of required properties/fields (JSON key names)
    openapiRequiredFields = new HashSet<String>();
    openapiRequiredFields.add("Id");
    openapiRequiredFields.add("DomainName");
  }

  /**
   * Validates the JSON Element and throws an exception if issues found
   *
   * @param jsonElement JSON Element
   * @throws IOException if the JSON Element is invalid with respect to Origin
   */
  public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      if (jsonElement == null) {
        if (!Origin.openapiRequiredFields.isEmpty()) { // has required fields but JSON element is null
          throw new IllegalArgumentException(String.format("The required field(s) %s in Origin is not found in the empty JSON string", Origin.openapiRequiredFields.toString()));
        }
      }

      Set<Map.Entry<String, JsonElement>> entries = jsonElement.getAsJsonObject().entrySet();
      // check to see if the JSON string contains additional fields
      for (Map.Entry<String, JsonElement> entry : entries) {
        if (!Origin.openapiFields.contains(entry.getKey())) {
          throw new IllegalArgumentException(String.format("The field `%s` in the JSON string is not defined in the `Origin` properties. JSON: %s", entry.getKey(), jsonElement.toString()));
        }
      }

      // check to make sure all required properties/fields are present in the JSON string
      for (String requiredField : Origin.openapiRequiredFields) {
        if (jsonElement.getAsJsonObject().get(requiredField) == null) {
          throw new IllegalArgumentException(String.format("The required field `%s` is not found in the JSON string: %s", requiredField, jsonElement.toString()));
        }
      }
        JsonObject jsonObj = jsonElement.getAsJsonObject();
      // validate the required field `Id`
      String.validateJsonElement(jsonObj.get("Id"));
      // validate the required field `DomainName`
      String.validateJsonElement(jsonObj.get("DomainName"));
      // validate the optional field `OriginPath`
      if (jsonObj.get("OriginPath") != null && !jsonObj.get("OriginPath").isJsonNull()) {
        String.validateJsonElement(jsonObj.get("OriginPath"));
      }
      // validate the optional field `CustomHeaders`
      if (jsonObj.get("CustomHeaders") != null && !jsonObj.get("CustomHeaders").isJsonNull()) {
        OriginCustomHeaders.validateJsonElement(jsonObj.get("CustomHeaders"));
      }
      // validate the optional field `S3OriginConfig`
      if (jsonObj.get("S3OriginConfig") != null && !jsonObj.get("S3OriginConfig").isJsonNull()) {
        OriginS3OriginConfig.validateJsonElement(jsonObj.get("S3OriginConfig"));
      }
      // validate the optional field `CustomOriginConfig`
      if (jsonObj.get("CustomOriginConfig") != null && !jsonObj.get("CustomOriginConfig").isJsonNull()) {
        OriginCustomOriginConfig.validateJsonElement(jsonObj.get("CustomOriginConfig"));
      }
  }

  public static class CustomTypeAdapterFactory implements TypeAdapterFactory {
    @SuppressWarnings("unchecked")
    @Override
    public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
       if (!Origin.class.isAssignableFrom(type.getRawType())) {
         return null; // this class only serializes 'Origin' and its subtypes
       }
       final TypeAdapter<JsonElement> elementAdapter = gson.getAdapter(JsonElement.class);
       final TypeAdapter<Origin> thisAdapter
                        = gson.getDelegateAdapter(this, TypeToken.get(Origin.class));

       return (TypeAdapter<T>) new TypeAdapter<Origin>() {
           @Override
           public void write(JsonWriter out, Origin value) throws IOException {
             JsonObject obj = thisAdapter.toJsonTree(value).getAsJsonObject();
             elementAdapter.write(out, obj);
           }

           @Override
           public Origin read(JsonReader in) throws IOException {
             JsonElement jsonElement = elementAdapter.read(in);
             validateJsonElement(jsonElement);
             return thisAdapter.fromJsonTree(jsonElement);
           }

       }.nullSafe();
    }
  }

  /**
   * Create an instance of Origin given an JSON string
   *
   * @param jsonString JSON string
   * @return An instance of Origin
   * @throws IOException if the JSON string is invalid with respect to Origin
   */
  public static Origin fromJson(String jsonString) throws IOException {
    return JSON.getGson().fromJson(jsonString, Origin.class);
  }

  /**
   * Convert an instance of Origin to an JSON string
   *
   * @return JSON string
   */
  public String toJson() {
    return JSON.getGson().toJson(this);
  }
}

