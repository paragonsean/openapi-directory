/*
 * Amazon CloudFront
 * <fullname>Amazon CloudFront</fullname> <p>This is the <i>Amazon CloudFront API Reference</i>. This guide is for developers who need detailed information about CloudFront API actions, data types, and errors. For detailed information about CloudFront features, see the <i>Amazon CloudFront Developer Guide</i>.</p>
 *
 * The version of the OpenAPI document: 2020-05-31
 * Contact: mike.ralphson@gmail.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package org.openapitools.client.model;

import java.util.Objects;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;
import java.util.Arrays;
import org.openapitools.client.model.CreateCachePolicy20200531RequestCachePolicyConfigParametersInCacheKeyAndForwardedToOrigin;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonArray;
import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;
import com.google.gson.TypeAdapterFactory;
import com.google.gson.reflect.TypeToken;
import com.google.gson.TypeAdapter;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;

import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import org.openapitools.client.JSON;

/**
 * &lt;p&gt;A cache policy configuration.&lt;/p&gt; &lt;p&gt;This configuration determines the following:&lt;/p&gt; &lt;ul&gt; &lt;li&gt; &lt;p&gt;The values that CloudFront includes in the cache key. These values can include HTTP headers, cookies, and URL query strings. CloudFront uses the cache key to find an object in its cache that it can return to the viewer.&lt;/p&gt; &lt;/li&gt; &lt;li&gt; &lt;p&gt;The default, minimum, and maximum time to live (TTL) values that you want objects to stay in the CloudFront cache.&lt;/p&gt; &lt;/li&gt; &lt;/ul&gt; &lt;p&gt;The headers, cookies, and query strings that are included in the cache key are also included in requests that CloudFront sends to the origin. CloudFront sends a request when it can&#39;t find a valid object in its cache that matches the request&#39;s cache key. If you want to send values to the origin but &lt;i&gt;not&lt;/i&gt; include them in the cache key, use &lt;code&gt;OriginRequestPolicy&lt;/code&gt;.&lt;/p&gt;
 */
@javax.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen", date = "2024-10-12T12:04:51.562194-04:00[America/New_York]", comments = "Generator version: 7.9.0")
public class CachePolicyConfig {
  public static final String SERIALIZED_NAME_COMMENT = "Comment";
  @SerializedName(SERIALIZED_NAME_COMMENT)
  private String comment;

  public static final String SERIALIZED_NAME_NAME = "Name";
  @SerializedName(SERIALIZED_NAME_NAME)
  private String name;

  public static final String SERIALIZED_NAME_DEFAULT_T_T_L = "DefaultTTL";
  @SerializedName(SERIALIZED_NAME_DEFAULT_T_T_L)
  private Integer defaultTTL;

  public static final String SERIALIZED_NAME_MAX_T_T_L = "MaxTTL";
  @SerializedName(SERIALIZED_NAME_MAX_T_T_L)
  private Integer maxTTL;

  public static final String SERIALIZED_NAME_MIN_T_T_L = "MinTTL";
  @SerializedName(SERIALIZED_NAME_MIN_T_T_L)
  private Integer minTTL;

  public static final String SERIALIZED_NAME_PARAMETERS_IN_CACHE_KEY_AND_FORWARDED_TO_ORIGIN = "ParametersInCacheKeyAndForwardedToOrigin";
  @SerializedName(SERIALIZED_NAME_PARAMETERS_IN_CACHE_KEY_AND_FORWARDED_TO_ORIGIN)
  private CreateCachePolicy20200531RequestCachePolicyConfigParametersInCacheKeyAndForwardedToOrigin parametersInCacheKeyAndForwardedToOrigin;

  public CachePolicyConfig() {
  }

  public CachePolicyConfig comment(String comment) {
    this.comment = comment;
    return this;
  }

  /**
   * Get comment
   * @return comment
   */
  @javax.annotation.Nullable
  public String getComment() {
    return comment;
  }

  public void setComment(String comment) {
    this.comment = comment;
  }


  public CachePolicyConfig name(String name) {
    this.name = name;
    return this;
  }

  /**
   * Get name
   * @return name
   */
  @javax.annotation.Nonnull
  public String getName() {
    return name;
  }

  public void setName(String name) {
    this.name = name;
  }


  public CachePolicyConfig defaultTTL(Integer defaultTTL) {
    this.defaultTTL = defaultTTL;
    return this;
  }

  /**
   * Get defaultTTL
   * @return defaultTTL
   */
  @javax.annotation.Nullable
  public Integer getDefaultTTL() {
    return defaultTTL;
  }

  public void setDefaultTTL(Integer defaultTTL) {
    this.defaultTTL = defaultTTL;
  }


  public CachePolicyConfig maxTTL(Integer maxTTL) {
    this.maxTTL = maxTTL;
    return this;
  }

  /**
   * Get maxTTL
   * @return maxTTL
   */
  @javax.annotation.Nullable
  public Integer getMaxTTL() {
    return maxTTL;
  }

  public void setMaxTTL(Integer maxTTL) {
    this.maxTTL = maxTTL;
  }


  public CachePolicyConfig minTTL(Integer minTTL) {
    this.minTTL = minTTL;
    return this;
  }

  /**
   * Get minTTL
   * @return minTTL
   */
  @javax.annotation.Nonnull
  public Integer getMinTTL() {
    return minTTL;
  }

  public void setMinTTL(Integer minTTL) {
    this.minTTL = minTTL;
  }


  public CachePolicyConfig parametersInCacheKeyAndForwardedToOrigin(CreateCachePolicy20200531RequestCachePolicyConfigParametersInCacheKeyAndForwardedToOrigin parametersInCacheKeyAndForwardedToOrigin) {
    this.parametersInCacheKeyAndForwardedToOrigin = parametersInCacheKeyAndForwardedToOrigin;
    return this;
  }

  /**
   * Get parametersInCacheKeyAndForwardedToOrigin
   * @return parametersInCacheKeyAndForwardedToOrigin
   */
  @javax.annotation.Nullable
  public CreateCachePolicy20200531RequestCachePolicyConfigParametersInCacheKeyAndForwardedToOrigin getParametersInCacheKeyAndForwardedToOrigin() {
    return parametersInCacheKeyAndForwardedToOrigin;
  }

  public void setParametersInCacheKeyAndForwardedToOrigin(CreateCachePolicy20200531RequestCachePolicyConfigParametersInCacheKeyAndForwardedToOrigin parametersInCacheKeyAndForwardedToOrigin) {
    this.parametersInCacheKeyAndForwardedToOrigin = parametersInCacheKeyAndForwardedToOrigin;
  }



  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    CachePolicyConfig cachePolicyConfig = (CachePolicyConfig) o;
    return Objects.equals(this.comment, cachePolicyConfig.comment) &&
        Objects.equals(this.name, cachePolicyConfig.name) &&
        Objects.equals(this.defaultTTL, cachePolicyConfig.defaultTTL) &&
        Objects.equals(this.maxTTL, cachePolicyConfig.maxTTL) &&
        Objects.equals(this.minTTL, cachePolicyConfig.minTTL) &&
        Objects.equals(this.parametersInCacheKeyAndForwardedToOrigin, cachePolicyConfig.parametersInCacheKeyAndForwardedToOrigin);
  }

  @Override
  public int hashCode() {
    return Objects.hash(comment, name, defaultTTL, maxTTL, minTTL, parametersInCacheKeyAndForwardedToOrigin);
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class CachePolicyConfig {\n");
    sb.append("    comment: ").append(toIndentedString(comment)).append("\n");
    sb.append("    name: ").append(toIndentedString(name)).append("\n");
    sb.append("    defaultTTL: ").append(toIndentedString(defaultTTL)).append("\n");
    sb.append("    maxTTL: ").append(toIndentedString(maxTTL)).append("\n");
    sb.append("    minTTL: ").append(toIndentedString(minTTL)).append("\n");
    sb.append("    parametersInCacheKeyAndForwardedToOrigin: ").append(toIndentedString(parametersInCacheKeyAndForwardedToOrigin)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }


  public static HashSet<String> openapiFields;
  public static HashSet<String> openapiRequiredFields;

  static {
    // a set of all properties/fields (JSON key names)
    openapiFields = new HashSet<String>();
    openapiFields.add("Comment");
    openapiFields.add("Name");
    openapiFields.add("DefaultTTL");
    openapiFields.add("MaxTTL");
    openapiFields.add("MinTTL");
    openapiFields.add("ParametersInCacheKeyAndForwardedToOrigin");

    // a set of required properties/fields (JSON key names)
    openapiRequiredFields = new HashSet<String>();
    openapiRequiredFields.add("Name");
    openapiRequiredFields.add("MinTTL");
  }

  /**
   * Validates the JSON Element and throws an exception if issues found
   *
   * @param jsonElement JSON Element
   * @throws IOException if the JSON Element is invalid with respect to CachePolicyConfig
   */
  public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      if (jsonElement == null) {
        if (!CachePolicyConfig.openapiRequiredFields.isEmpty()) { // has required fields but JSON element is null
          throw new IllegalArgumentException(String.format("The required field(s) %s in CachePolicyConfig is not found in the empty JSON string", CachePolicyConfig.openapiRequiredFields.toString()));
        }
      }

      Set<Map.Entry<String, JsonElement>> entries = jsonElement.getAsJsonObject().entrySet();
      // check to see if the JSON string contains additional fields
      for (Map.Entry<String, JsonElement> entry : entries) {
        if (!CachePolicyConfig.openapiFields.contains(entry.getKey())) {
          throw new IllegalArgumentException(String.format("The field `%s` in the JSON string is not defined in the `CachePolicyConfig` properties. JSON: %s", entry.getKey(), jsonElement.toString()));
        }
      }

      // check to make sure all required properties/fields are present in the JSON string
      for (String requiredField : CachePolicyConfig.openapiRequiredFields) {
        if (jsonElement.getAsJsonObject().get(requiredField) == null) {
          throw new IllegalArgumentException(String.format("The required field `%s` is not found in the JSON string: %s", requiredField, jsonElement.toString()));
        }
      }
        JsonObject jsonObj = jsonElement.getAsJsonObject();
      // validate the optional field `Comment`
      if (jsonObj.get("Comment") != null && !jsonObj.get("Comment").isJsonNull()) {
        String.validateJsonElement(jsonObj.get("Comment"));
      }
      // validate the required field `Name`
      String.validateJsonElement(jsonObj.get("Name"));
      // validate the optional field `DefaultTTL`
      if (jsonObj.get("DefaultTTL") != null && !jsonObj.get("DefaultTTL").isJsonNull()) {
        Integer.validateJsonElement(jsonObj.get("DefaultTTL"));
      }
      // validate the optional field `MaxTTL`
      if (jsonObj.get("MaxTTL") != null && !jsonObj.get("MaxTTL").isJsonNull()) {
        Integer.validateJsonElement(jsonObj.get("MaxTTL"));
      }
      // validate the required field `MinTTL`
      Integer.validateJsonElement(jsonObj.get("MinTTL"));
      // validate the optional field `ParametersInCacheKeyAndForwardedToOrigin`
      if (jsonObj.get("ParametersInCacheKeyAndForwardedToOrigin") != null && !jsonObj.get("ParametersInCacheKeyAndForwardedToOrigin").isJsonNull()) {
        CreateCachePolicy20200531RequestCachePolicyConfigParametersInCacheKeyAndForwardedToOrigin.validateJsonElement(jsonObj.get("ParametersInCacheKeyAndForwardedToOrigin"));
      }
  }

  public static class CustomTypeAdapterFactory implements TypeAdapterFactory {
    @SuppressWarnings("unchecked")
    @Override
    public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
       if (!CachePolicyConfig.class.isAssignableFrom(type.getRawType())) {
         return null; // this class only serializes 'CachePolicyConfig' and its subtypes
       }
       final TypeAdapter<JsonElement> elementAdapter = gson.getAdapter(JsonElement.class);
       final TypeAdapter<CachePolicyConfig> thisAdapter
                        = gson.getDelegateAdapter(this, TypeToken.get(CachePolicyConfig.class));

       return (TypeAdapter<T>) new TypeAdapter<CachePolicyConfig>() {
           @Override
           public void write(JsonWriter out, CachePolicyConfig value) throws IOException {
             JsonObject obj = thisAdapter.toJsonTree(value).getAsJsonObject();
             elementAdapter.write(out, obj);
           }

           @Override
           public CachePolicyConfig read(JsonReader in) throws IOException {
             JsonElement jsonElement = elementAdapter.read(in);
             validateJsonElement(jsonElement);
             return thisAdapter.fromJsonTree(jsonElement);
           }

       }.nullSafe();
    }
  }

  /**
   * Create an instance of CachePolicyConfig given an JSON string
   *
   * @param jsonString JSON string
   * @return An instance of CachePolicyConfig
   * @throws IOException if the JSON string is invalid with respect to CachePolicyConfig
   */
  public static CachePolicyConfig fromJson(String jsonString) throws IOException {
    return JSON.getGson().fromJson(jsonString, CachePolicyConfig.class);
  }

  /**
   * Convert an instance of CachePolicyConfig to an JSON string
   *
   * @return JSON string
   */
  public String toJson() {
    return JSON.getGson().toJson(this);
  }
}

