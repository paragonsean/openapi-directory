/*
 * Amazon CloudFront
 * <fullname>Amazon CloudFront</fullname> <p>This is the <i>Amazon CloudFront API Reference</i>. This guide is for developers who need detailed information about CloudFront API actions, data types, and errors. For detailed information about CloudFront features, see the <i>Amazon CloudFront Developer Guide</i>.</p>
 *
 * The version of the OpenAPI document: 2020-05-31
 * Contact: mike.ralphson@gmail.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package org.openapitools.client.model;

import java.util.Objects;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;
import java.util.Arrays;
import org.openapitools.client.model.CreateCachePolicy20200531RequestCachePolicyConfigParametersInCacheKeyAndForwardedToOrigin;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonArray;
import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;
import com.google.gson.TypeAdapterFactory;
import com.google.gson.reflect.TypeToken;
import com.google.gson.TypeAdapter;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;

import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import org.openapitools.client.JSON;

/**
 * &lt;p&gt;A cache policy configuration.&lt;/p&gt; &lt;p&gt;This configuration determines the following:&lt;/p&gt; &lt;ul&gt; &lt;li&gt; &lt;p&gt;The values that CloudFront includes in the cache key. These values can include HTTP headers, cookies, and URL query strings. CloudFront uses the cache key to find an object in its cache that it can return to the viewer.&lt;/p&gt; &lt;/li&gt; &lt;li&gt; &lt;p&gt;The default, minimum, and maximum time to live (TTL) values that you want objects to stay in the CloudFront cache.&lt;/p&gt; &lt;/li&gt; &lt;/ul&gt; &lt;p&gt;The headers, cookies, and query strings that are included in the cache key are also included in requests that CloudFront sends to the origin. CloudFront sends a request when it can&#39;t find a valid object in its cache that matches the request&#39;s cache key. If you want to send values to the origin but &lt;i&gt;not&lt;/i&gt; include them in the cache key, use &lt;code&gt;OriginRequestPolicy&lt;/code&gt;.&lt;/p&gt;
 */
@javax.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen", date = "2024-10-12T12:04:51.562194-04:00[America/New_York]", comments = "Generator version: 7.9.0")
public class CreateCachePolicy20200531RequestCachePolicyConfig {
  public static final String SERIALIZED_NAME_COMMENT = "Comment";
  @SerializedName(SERIALIZED_NAME_COMMENT)
  private String comment;

  public static final String SERIALIZED_NAME_NAME = "Name";
  @SerializedName(SERIALIZED_NAME_NAME)
  private String name;

  public static final String SERIALIZED_NAME_DEFAULT_T_T_L = "DefaultTTL";
  @SerializedName(SERIALIZED_NAME_DEFAULT_T_T_L)
  private Integer defaultTTL;

  public static final String SERIALIZED_NAME_MAX_T_T_L = "MaxTTL";
  @SerializedName(SERIALIZED_NAME_MAX_T_T_L)
  private Integer maxTTL;

  public static final String SERIALIZED_NAME_MIN_T_T_L = "MinTTL";
  @SerializedName(SERIALIZED_NAME_MIN_T_T_L)
  private Integer minTTL;

  public static final String SERIALIZED_NAME_PARAMETERS_IN_CACHE_KEY_AND_FORWARDED_TO_ORIGIN = "ParametersInCacheKeyAndForwardedToOrigin";
  @SerializedName(SERIALIZED_NAME_PARAMETERS_IN_CACHE_KEY_AND_FORWARDED_TO_ORIGIN)
  private CreateCachePolicy20200531RequestCachePolicyConfigParametersInCacheKeyAndForwardedToOrigin parametersInCacheKeyAndForwardedToOrigin;

  public CreateCachePolicy20200531RequestCachePolicyConfig() {
  }

  public CreateCachePolicy20200531RequestCachePolicyConfig comment(String comment) {
    this.comment = comment;
    return this;
  }

  /**
   * Get comment
   * @return comment
   */
  @javax.annotation.Nullable
  public String getComment() {
    return comment;
  }

  public void setComment(String comment) {
    this.comment = comment;
  }


  public CreateCachePolicy20200531RequestCachePolicyConfig name(String name) {
    this.name = name;
    return this;
  }

  /**
   * Get name
   * @return name
   */
  @javax.annotation.Nullable
  public String getName() {
    return name;
  }

  public void setName(String name) {
    this.name = name;
  }


  public CreateCachePolicy20200531RequestCachePolicyConfig defaultTTL(Integer defaultTTL) {
    this.defaultTTL = defaultTTL;
    return this;
  }

  /**
   * Get defaultTTL
   * @return defaultTTL
   */
  @javax.annotation.Nullable
  public Integer getDefaultTTL() {
    return defaultTTL;
  }

  public void setDefaultTTL(Integer defaultTTL) {
    this.defaultTTL = defaultTTL;
  }


  public CreateCachePolicy20200531RequestCachePolicyConfig maxTTL(Integer maxTTL) {
    this.maxTTL = maxTTL;
    return this;
  }

  /**
   * Get maxTTL
   * @return maxTTL
   */
  @javax.annotation.Nullable
  public Integer getMaxTTL() {
    return maxTTL;
  }

  public void setMaxTTL(Integer maxTTL) {
    this.maxTTL = maxTTL;
  }


  public CreateCachePolicy20200531RequestCachePolicyConfig minTTL(Integer minTTL) {
    this.minTTL = minTTL;
    return this;
  }

  /**
   * Get minTTL
   * @return minTTL
   */
  @javax.annotation.Nullable
  public Integer getMinTTL() {
    return minTTL;
  }

  public void setMinTTL(Integer minTTL) {
    this.minTTL = minTTL;
  }


  public CreateCachePolicy20200531RequestCachePolicyConfig parametersInCacheKeyAndForwardedToOrigin(CreateCachePolicy20200531RequestCachePolicyConfigParametersInCacheKeyAndForwardedToOrigin parametersInCacheKeyAndForwardedToOrigin) {
    this.parametersInCacheKeyAndForwardedToOrigin = parametersInCacheKeyAndForwardedToOrigin;
    return this;
  }

  /**
   * Get parametersInCacheKeyAndForwardedToOrigin
   * @return parametersInCacheKeyAndForwardedToOrigin
   */
  @javax.annotation.Nullable
  public CreateCachePolicy20200531RequestCachePolicyConfigParametersInCacheKeyAndForwardedToOrigin getParametersInCacheKeyAndForwardedToOrigin() {
    return parametersInCacheKeyAndForwardedToOrigin;
  }

  public void setParametersInCacheKeyAndForwardedToOrigin(CreateCachePolicy20200531RequestCachePolicyConfigParametersInCacheKeyAndForwardedToOrigin parametersInCacheKeyAndForwardedToOrigin) {
    this.parametersInCacheKeyAndForwardedToOrigin = parametersInCacheKeyAndForwardedToOrigin;
  }



  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    CreateCachePolicy20200531RequestCachePolicyConfig createCachePolicy20200531RequestCachePolicyConfig = (CreateCachePolicy20200531RequestCachePolicyConfig) o;
    return Objects.equals(this.comment, createCachePolicy20200531RequestCachePolicyConfig.comment) &&
        Objects.equals(this.name, createCachePolicy20200531RequestCachePolicyConfig.name) &&
        Objects.equals(this.defaultTTL, createCachePolicy20200531RequestCachePolicyConfig.defaultTTL) &&
        Objects.equals(this.maxTTL, createCachePolicy20200531RequestCachePolicyConfig.maxTTL) &&
        Objects.equals(this.minTTL, createCachePolicy20200531RequestCachePolicyConfig.minTTL) &&
        Objects.equals(this.parametersInCacheKeyAndForwardedToOrigin, createCachePolicy20200531RequestCachePolicyConfig.parametersInCacheKeyAndForwardedToOrigin);
  }

  @Override
  public int hashCode() {
    return Objects.hash(comment, name, defaultTTL, maxTTL, minTTL, parametersInCacheKeyAndForwardedToOrigin);
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class CreateCachePolicy20200531RequestCachePolicyConfig {\n");
    sb.append("    comment: ").append(toIndentedString(comment)).append("\n");
    sb.append("    name: ").append(toIndentedString(name)).append("\n");
    sb.append("    defaultTTL: ").append(toIndentedString(defaultTTL)).append("\n");
    sb.append("    maxTTL: ").append(toIndentedString(maxTTL)).append("\n");
    sb.append("    minTTL: ").append(toIndentedString(minTTL)).append("\n");
    sb.append("    parametersInCacheKeyAndForwardedToOrigin: ").append(toIndentedString(parametersInCacheKeyAndForwardedToOrigin)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }


  public static HashSet<String> openapiFields;
  public static HashSet<String> openapiRequiredFields;

  static {
    // a set of all properties/fields (JSON key names)
    openapiFields = new HashSet<String>();
    openapiFields.add("Comment");
    openapiFields.add("Name");
    openapiFields.add("DefaultTTL");
    openapiFields.add("MaxTTL");
    openapiFields.add("MinTTL");
    openapiFields.add("ParametersInCacheKeyAndForwardedToOrigin");

    // a set of required properties/fields (JSON key names)
    openapiRequiredFields = new HashSet<String>();
  }

  /**
   * Validates the JSON Element and throws an exception if issues found
   *
   * @param jsonElement JSON Element
   * @throws IOException if the JSON Element is invalid with respect to CreateCachePolicy20200531RequestCachePolicyConfig
   */
  public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      if (jsonElement == null) {
        if (!CreateCachePolicy20200531RequestCachePolicyConfig.openapiRequiredFields.isEmpty()) { // has required fields but JSON element is null
          throw new IllegalArgumentException(String.format("The required field(s) %s in CreateCachePolicy20200531RequestCachePolicyConfig is not found in the empty JSON string", CreateCachePolicy20200531RequestCachePolicyConfig.openapiRequiredFields.toString()));
        }
      }

      Set<Map.Entry<String, JsonElement>> entries = jsonElement.getAsJsonObject().entrySet();
      // check to see if the JSON string contains additional fields
      for (Map.Entry<String, JsonElement> entry : entries) {
        if (!CreateCachePolicy20200531RequestCachePolicyConfig.openapiFields.contains(entry.getKey())) {
          throw new IllegalArgumentException(String.format("The field `%s` in the JSON string is not defined in the `CreateCachePolicy20200531RequestCachePolicyConfig` properties. JSON: %s", entry.getKey(), jsonElement.toString()));
        }
      }
        JsonObject jsonObj = jsonElement.getAsJsonObject();
      // validate the optional field `Comment`
      if (jsonObj.get("Comment") != null && !jsonObj.get("Comment").isJsonNull()) {
        String.validateJsonElement(jsonObj.get("Comment"));
      }
      // validate the optional field `Name`
      if (jsonObj.get("Name") != null && !jsonObj.get("Name").isJsonNull()) {
        String.validateJsonElement(jsonObj.get("Name"));
      }
      // validate the optional field `DefaultTTL`
      if (jsonObj.get("DefaultTTL") != null && !jsonObj.get("DefaultTTL").isJsonNull()) {
        Integer.validateJsonElement(jsonObj.get("DefaultTTL"));
      }
      // validate the optional field `MaxTTL`
      if (jsonObj.get("MaxTTL") != null && !jsonObj.get("MaxTTL").isJsonNull()) {
        Integer.validateJsonElement(jsonObj.get("MaxTTL"));
      }
      // validate the optional field `MinTTL`
      if (jsonObj.get("MinTTL") != null && !jsonObj.get("MinTTL").isJsonNull()) {
        Integer.validateJsonElement(jsonObj.get("MinTTL"));
      }
      // validate the optional field `ParametersInCacheKeyAndForwardedToOrigin`
      if (jsonObj.get("ParametersInCacheKeyAndForwardedToOrigin") != null && !jsonObj.get("ParametersInCacheKeyAndForwardedToOrigin").isJsonNull()) {
        CreateCachePolicy20200531RequestCachePolicyConfigParametersInCacheKeyAndForwardedToOrigin.validateJsonElement(jsonObj.get("ParametersInCacheKeyAndForwardedToOrigin"));
      }
  }

  public static class CustomTypeAdapterFactory implements TypeAdapterFactory {
    @SuppressWarnings("unchecked")
    @Override
    public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
       if (!CreateCachePolicy20200531RequestCachePolicyConfig.class.isAssignableFrom(type.getRawType())) {
         return null; // this class only serializes 'CreateCachePolicy20200531RequestCachePolicyConfig' and its subtypes
       }
       final TypeAdapter<JsonElement> elementAdapter = gson.getAdapter(JsonElement.class);
       final TypeAdapter<CreateCachePolicy20200531RequestCachePolicyConfig> thisAdapter
                        = gson.getDelegateAdapter(this, TypeToken.get(CreateCachePolicy20200531RequestCachePolicyConfig.class));

       return (TypeAdapter<T>) new TypeAdapter<CreateCachePolicy20200531RequestCachePolicyConfig>() {
           @Override
           public void write(JsonWriter out, CreateCachePolicy20200531RequestCachePolicyConfig value) throws IOException {
             JsonObject obj = thisAdapter.toJsonTree(value).getAsJsonObject();
             elementAdapter.write(out, obj);
           }

           @Override
           public CreateCachePolicy20200531RequestCachePolicyConfig read(JsonReader in) throws IOException {
             JsonElement jsonElement = elementAdapter.read(in);
             validateJsonElement(jsonElement);
             return thisAdapter.fromJsonTree(jsonElement);
           }

       }.nullSafe();
    }
  }

  /**
   * Create an instance of CreateCachePolicy20200531RequestCachePolicyConfig given an JSON string
   *
   * @param jsonString JSON string
   * @return An instance of CreateCachePolicy20200531RequestCachePolicyConfig
   * @throws IOException if the JSON string is invalid with respect to CreateCachePolicy20200531RequestCachePolicyConfig
   */
  public static CreateCachePolicy20200531RequestCachePolicyConfig fromJson(String jsonString) throws IOException {
    return JSON.getGson().fromJson(jsonString, CreateCachePolicy20200531RequestCachePolicyConfig.class);
  }

  /**
   * Convert an instance of CreateCachePolicy20200531RequestCachePolicyConfig to an JSON string
   *
   * @return JSON string
   */
  public String toJson() {
    return JSON.getGson().toJson(this);
  }
}

