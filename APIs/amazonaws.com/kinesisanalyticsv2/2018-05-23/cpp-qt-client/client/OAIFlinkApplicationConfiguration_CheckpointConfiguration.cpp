/**
 * Amazon Kinesis Analytics
 * Amazon Kinesis Data Analytics is a fully managed service that you can use to process and analyze streaming data using Java, SQL, or Scala. The service enables you to quickly author and run Java, SQL, or Scala code against streaming sources to perform time series analytics, feed real-time dashboards, and create real-time metrics.
 *
 * The version of the OpenAPI document: 2018-05-23
 * Contact: mike.ralphson@gmail.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

#include "OAIFlinkApplicationConfiguration_CheckpointConfiguration.h"

#include <QDebug>
#include <QJsonArray>
#include <QJsonDocument>
#include <QObject>

#include "OAIHelpers.h"

namespace OpenAPI {

OAIFlinkApplicationConfiguration_CheckpointConfiguration::OAIFlinkApplicationConfiguration_CheckpointConfiguration(QString json) {
    this->initializeModel();
    this->fromJson(json);
}

OAIFlinkApplicationConfiguration_CheckpointConfiguration::OAIFlinkApplicationConfiguration_CheckpointConfiguration() {
    this->initializeModel();
}

OAIFlinkApplicationConfiguration_CheckpointConfiguration::~OAIFlinkApplicationConfiguration_CheckpointConfiguration() {}

void OAIFlinkApplicationConfiguration_CheckpointConfiguration::initializeModel() {

    m_configuration_type_isSet = false;
    m_configuration_type_isValid = false;

    m_checkpointing_enabled_isSet = false;
    m_checkpointing_enabled_isValid = false;

    m_checkpoint_interval_isSet = false;
    m_checkpoint_interval_isValid = false;

    m_min_pause_between_checkpoints_isSet = false;
    m_min_pause_between_checkpoints_isValid = false;
}

void OAIFlinkApplicationConfiguration_CheckpointConfiguration::fromJson(QString jsonString) {
    QByteArray array(jsonString.toStdString().c_str());
    QJsonDocument doc = QJsonDocument::fromJson(array);
    QJsonObject jsonObject = doc.object();
    this->fromJsonObject(jsonObject);
}

void OAIFlinkApplicationConfiguration_CheckpointConfiguration::fromJsonObject(QJsonObject json) {

    m_configuration_type_isValid = ::OpenAPI::fromJsonValue(m_configuration_type, json[QString("ConfigurationType")]);
    m_configuration_type_isSet = !json[QString("ConfigurationType")].isNull() && m_configuration_type_isValid;

    m_checkpointing_enabled_isValid = ::OpenAPI::fromJsonValue(m_checkpointing_enabled, json[QString("CheckpointingEnabled")]);
    m_checkpointing_enabled_isSet = !json[QString("CheckpointingEnabled")].isNull() && m_checkpointing_enabled_isValid;

    m_checkpoint_interval_isValid = ::OpenAPI::fromJsonValue(m_checkpoint_interval, json[QString("CheckpointInterval")]);
    m_checkpoint_interval_isSet = !json[QString("CheckpointInterval")].isNull() && m_checkpoint_interval_isValid;

    m_min_pause_between_checkpoints_isValid = ::OpenAPI::fromJsonValue(m_min_pause_between_checkpoints, json[QString("MinPauseBetweenCheckpoints")]);
    m_min_pause_between_checkpoints_isSet = !json[QString("MinPauseBetweenCheckpoints")].isNull() && m_min_pause_between_checkpoints_isValid;
}

QString OAIFlinkApplicationConfiguration_CheckpointConfiguration::asJson() const {
    QJsonObject obj = this->asJsonObject();
    QJsonDocument doc(obj);
    QByteArray bytes = doc.toJson();
    return QString(bytes);
}

QJsonObject OAIFlinkApplicationConfiguration_CheckpointConfiguration::asJsonObject() const {
    QJsonObject obj;
    if (m_configuration_type.isSet()) {
        obj.insert(QString("ConfigurationType"), ::OpenAPI::toJsonValue(m_configuration_type));
    }
    if (m_checkpointing_enabled_isSet) {
        obj.insert(QString("CheckpointingEnabled"), ::OpenAPI::toJsonValue(m_checkpointing_enabled));
    }
    if (m_checkpoint_interval_isSet) {
        obj.insert(QString("CheckpointInterval"), ::OpenAPI::toJsonValue(m_checkpoint_interval));
    }
    if (m_min_pause_between_checkpoints_isSet) {
        obj.insert(QString("MinPauseBetweenCheckpoints"), ::OpenAPI::toJsonValue(m_min_pause_between_checkpoints));
    }
    return obj;
}

OAIConfigurationType OAIFlinkApplicationConfiguration_CheckpointConfiguration::getConfigurationType() const {
    return m_configuration_type;
}
void OAIFlinkApplicationConfiguration_CheckpointConfiguration::setConfigurationType(const OAIConfigurationType &configuration_type) {
    m_configuration_type = configuration_type;
    m_configuration_type_isSet = true;
}

bool OAIFlinkApplicationConfiguration_CheckpointConfiguration::is_configuration_type_Set() const{
    return m_configuration_type_isSet;
}

bool OAIFlinkApplicationConfiguration_CheckpointConfiguration::is_configuration_type_Valid() const{
    return m_configuration_type_isValid;
}

bool OAIFlinkApplicationConfiguration_CheckpointConfiguration::getCheckpointingEnabled() const {
    return m_checkpointing_enabled;
}
void OAIFlinkApplicationConfiguration_CheckpointConfiguration::setCheckpointingEnabled(const bool &checkpointing_enabled) {
    m_checkpointing_enabled = checkpointing_enabled;
    m_checkpointing_enabled_isSet = true;
}

bool OAIFlinkApplicationConfiguration_CheckpointConfiguration::is_checkpointing_enabled_Set() const{
    return m_checkpointing_enabled_isSet;
}

bool OAIFlinkApplicationConfiguration_CheckpointConfiguration::is_checkpointing_enabled_Valid() const{
    return m_checkpointing_enabled_isValid;
}

qint32 OAIFlinkApplicationConfiguration_CheckpointConfiguration::getCheckpointInterval() const {
    return m_checkpoint_interval;
}
void OAIFlinkApplicationConfiguration_CheckpointConfiguration::setCheckpointInterval(const qint32 &checkpoint_interval) {
    m_checkpoint_interval = checkpoint_interval;
    m_checkpoint_interval_isSet = true;
}

bool OAIFlinkApplicationConfiguration_CheckpointConfiguration::is_checkpoint_interval_Set() const{
    return m_checkpoint_interval_isSet;
}

bool OAIFlinkApplicationConfiguration_CheckpointConfiguration::is_checkpoint_interval_Valid() const{
    return m_checkpoint_interval_isValid;
}

qint32 OAIFlinkApplicationConfiguration_CheckpointConfiguration::getMinPauseBetweenCheckpoints() const {
    return m_min_pause_between_checkpoints;
}
void OAIFlinkApplicationConfiguration_CheckpointConfiguration::setMinPauseBetweenCheckpoints(const qint32 &min_pause_between_checkpoints) {
    m_min_pause_between_checkpoints = min_pause_between_checkpoints;
    m_min_pause_between_checkpoints_isSet = true;
}

bool OAIFlinkApplicationConfiguration_CheckpointConfiguration::is_min_pause_between_checkpoints_Set() const{
    return m_min_pause_between_checkpoints_isSet;
}

bool OAIFlinkApplicationConfiguration_CheckpointConfiguration::is_min_pause_between_checkpoints_Valid() const{
    return m_min_pause_between_checkpoints_isValid;
}

bool OAIFlinkApplicationConfiguration_CheckpointConfiguration::isSet() const {
    bool isObjectUpdated = false;
    do {
        if (m_configuration_type.isSet()) {
            isObjectUpdated = true;
            break;
        }

        if (m_checkpointing_enabled_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_checkpoint_interval_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_min_pause_between_checkpoints_isSet) {
            isObjectUpdated = true;
            break;
        }
    } while (false);
    return isObjectUpdated;
}

bool OAIFlinkApplicationConfiguration_CheckpointConfiguration::isValid() const {
    // only required properties are required for the object to be considered valid
    return m_configuration_type_isValid && true;
}

} // namespace OpenAPI
