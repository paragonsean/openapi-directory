/*
 * Amazon Connect Service
 * <p>Amazon Connect is a cloud-based contact center solution that you use to set up and manage a customer contact center and provide reliable customer engagement at any scale.</p> <p>Amazon Connect provides metrics and real-time reporting that enable you to optimize contact routing. You can also resolve customer issues more efficiently by getting customers in touch with the appropriate agents.</p> <p>There are limits to the number of Amazon Connect resources that you can create. There are also limits to the number of requests that you can make per second. For more information, see <a href=\"https://docs.aws.amazon.com/connect/latest/adminguide/amazon-connect-service-limits.html\">Amazon Connect Service Quotas</a> in the <i>Amazon Connect Administrator Guide</i>.</p> <p>You can connect programmatically to an Amazon Web Services service by using an endpoint. For a list of Amazon Connect endpoints, see <a href=\"https://docs.aws.amazon.com/general/latest/gr/connect_region.html\">Amazon Connect Endpoints</a>.</p>
 *
 * The version of the OpenAPI document: 2017-08-08
 * Contact: mike.ralphson@gmail.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package org.openapitools.client.model;

import java.util.Objects;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import org.openapitools.client.model.CurrentMetric;
import org.openapitools.client.model.CurrentMetricSortCriteria;
import org.openapitools.client.model.GetCurrentMetricDataRequestFilters;
import org.openapitools.client.model.Grouping;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonArray;
import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;
import com.google.gson.TypeAdapterFactory;
import com.google.gson.reflect.TypeToken;
import com.google.gson.TypeAdapter;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;

import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import org.openapitools.client.JSON;

/**
 * GetCurrentMetricDataRequest
 */
@javax.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen", date = "2024-10-12T12:25:13.911190-04:00[America/New_York]", comments = "Generator version: 7.9.0")
public class GetCurrentMetricDataRequest {
  public static final String SERIALIZED_NAME_FILTERS = "Filters";
  @SerializedName(SERIALIZED_NAME_FILTERS)
  private GetCurrentMetricDataRequestFilters filters;

  public static final String SERIALIZED_NAME_GROUPINGS = "Groupings";
  @SerializedName(SERIALIZED_NAME_GROUPINGS)
  private List<Grouping> groupings = new ArrayList<>();

  public static final String SERIALIZED_NAME_CURRENT_METRICS = "CurrentMetrics";
  @SerializedName(SERIALIZED_NAME_CURRENT_METRICS)
  private List<CurrentMetric> currentMetrics = new ArrayList<>();

  public static final String SERIALIZED_NAME_NEXT_TOKEN = "NextToken";
  @SerializedName(SERIALIZED_NAME_NEXT_TOKEN)
  private String nextToken;

  public static final String SERIALIZED_NAME_MAX_RESULTS = "MaxResults";
  @SerializedName(SERIALIZED_NAME_MAX_RESULTS)
  private Integer maxResults;

  public static final String SERIALIZED_NAME_SORT_CRITERIA = "SortCriteria";
  @SerializedName(SERIALIZED_NAME_SORT_CRITERIA)
  private List<CurrentMetricSortCriteria> sortCriteria = new ArrayList<>();

  public GetCurrentMetricDataRequest() {
  }

  public GetCurrentMetricDataRequest filters(GetCurrentMetricDataRequestFilters filters) {
    this.filters = filters;
    return this;
  }

  /**
   * Get filters
   * @return filters
   */
  @javax.annotation.Nonnull
  public GetCurrentMetricDataRequestFilters getFilters() {
    return filters;
  }

  public void setFilters(GetCurrentMetricDataRequestFilters filters) {
    this.filters = filters;
  }


  public GetCurrentMetricDataRequest groupings(List<Grouping> groupings) {
    this.groupings = groupings;
    return this;
  }

  public GetCurrentMetricDataRequest addGroupingsItem(Grouping groupingsItem) {
    if (this.groupings == null) {
      this.groupings = new ArrayList<>();
    }
    this.groupings.add(groupingsItem);
    return this;
  }

  /**
   * &lt;p&gt;The grouping applied to the metrics returned. For example, when grouped by &lt;code&gt;QUEUE&lt;/code&gt;, the metrics returned apply to each queue rather than aggregated for all queues. &lt;/p&gt; &lt;ul&gt; &lt;li&gt; &lt;p&gt;If you group by &lt;code&gt;CHANNEL&lt;/code&gt;, you should include a Channels filter. VOICE, CHAT, and TASK channels are supported.&lt;/p&gt; &lt;/li&gt; &lt;li&gt; &lt;p&gt;If you group by &lt;code&gt;ROUTING_PROFILE&lt;/code&gt;, you must include either a queue or routing profile filter. In addition, a routing profile filter is required for metrics &lt;code&gt;CONTACTS_SCHEDULED&lt;/code&gt;, &lt;code&gt;CONTACTS_IN_QUEUE&lt;/code&gt;, and &lt;code&gt; OLDEST_CONTACT_AGE&lt;/code&gt;.&lt;/p&gt; &lt;/li&gt; &lt;li&gt; &lt;p&gt;If no &lt;code&gt;Grouping&lt;/code&gt; is included in the request, a summary of metrics is returned.&lt;/p&gt; &lt;/li&gt; &lt;/ul&gt;
   * @return groupings
   */
  @javax.annotation.Nullable
  public List<Grouping> getGroupings() {
    return groupings;
  }

  public void setGroupings(List<Grouping> groupings) {
    this.groupings = groupings;
  }


  public GetCurrentMetricDataRequest currentMetrics(List<CurrentMetric> currentMetrics) {
    this.currentMetrics = currentMetrics;
    return this;
  }

  public GetCurrentMetricDataRequest addCurrentMetricsItem(CurrentMetric currentMetricsItem) {
    if (this.currentMetrics == null) {
      this.currentMetrics = new ArrayList<>();
    }
    this.currentMetrics.add(currentMetricsItem);
    return this;
  }

  /**
   * &lt;p&gt;The metrics to retrieve. Specify the name and unit for each metric. The following metrics are available. For a description of all the metrics, see &lt;a href&#x3D;\&quot;https://docs.aws.amazon.com/connect/latest/adminguide/real-time-metrics-definitions.html\&quot;&gt;Real-time Metrics Definitions&lt;/a&gt; in the &lt;i&gt;Amazon Connect Administrator Guide&lt;/i&gt;.&lt;/p&gt; &lt;dl&gt; &lt;dt&gt;AGENTS_AFTER_CONTACT_WORK&lt;/dt&gt; &lt;dd&gt; &lt;p&gt;Unit: COUNT&lt;/p&gt; &lt;p&gt;Name in real-time metrics report: &lt;a href&#x3D;\&quot;https://docs.aws.amazon.com/connect/latest/adminguide/real-time-metrics-definitions.html#aftercallwork-real-time\&quot;&gt;ACW&lt;/a&gt; &lt;/p&gt; &lt;/dd&gt; &lt;dt&gt;AGENTS_AVAILABLE&lt;/dt&gt; &lt;dd&gt; &lt;p&gt;Unit: COUNT&lt;/p&gt; &lt;p&gt;Name in real-time metrics report: &lt;a href&#x3D;\&quot;https://docs.aws.amazon.com/connect/latest/adminguide/real-time-metrics-definitions.html#available-real-time\&quot;&gt;Available&lt;/a&gt; &lt;/p&gt; &lt;/dd&gt; &lt;dt&gt;AGENTS_ERROR&lt;/dt&gt; &lt;dd&gt; &lt;p&gt;Unit: COUNT&lt;/p&gt; &lt;p&gt;Name in real-time metrics report: &lt;a href&#x3D;\&quot;https://docs.aws.amazon.com/connect/latest/adminguide/real-time-metrics-definitions.html#error-real-time\&quot;&gt;Error&lt;/a&gt; &lt;/p&gt; &lt;/dd&gt; &lt;dt&gt;AGENTS_NON_PRODUCTIVE&lt;/dt&gt; &lt;dd&gt; &lt;p&gt;Unit: COUNT&lt;/p&gt; &lt;p&gt;Name in real-time metrics report: &lt;a href&#x3D;\&quot;https://docs.aws.amazon.com/connect/latest/adminguide/real-time-metrics-definitions.html#non-productive-time-real-time\&quot;&gt;NPT (Non-Productive Time)&lt;/a&gt; &lt;/p&gt; &lt;/dd&gt; &lt;dt&gt;AGENTS_ON_CALL&lt;/dt&gt; &lt;dd&gt; &lt;p&gt;Unit: COUNT&lt;/p&gt; &lt;p&gt;Name in real-time metrics report: &lt;a href&#x3D;\&quot;https://docs.aws.amazon.com/connect/latest/adminguide/real-time-metrics-definitions.html#on-call-real-time\&quot;&gt;On contact&lt;/a&gt; &lt;/p&gt; &lt;/dd&gt; &lt;dt&gt;AGENTS_ON_CONTACT&lt;/dt&gt; &lt;dd&gt; &lt;p&gt;Unit: COUNT&lt;/p&gt; &lt;p&gt;Name in real-time metrics report: &lt;a href&#x3D;\&quot;https://docs.aws.amazon.com/connect/latest/adminguide/real-time-metrics-definitions.html#on-call-real-time\&quot;&gt;On contact&lt;/a&gt; &lt;/p&gt; &lt;/dd&gt; &lt;dt&gt;AGENTS_ONLINE&lt;/dt&gt; &lt;dd&gt; &lt;p&gt;Unit: COUNT&lt;/p&gt; &lt;p&gt;Name in real-time metrics report: &lt;a href&#x3D;\&quot;https://docs.aws.amazon.com/connect/latest/adminguide/real-time-metrics-definitions.html#online-real-time\&quot;&gt;Online&lt;/a&gt; &lt;/p&gt; &lt;/dd&gt; &lt;dt&gt;AGENTS_STAFFED&lt;/dt&gt; &lt;dd&gt; &lt;p&gt;Unit: COUNT&lt;/p&gt; &lt;p&gt;Name in real-time metrics report: &lt;a href&#x3D;\&quot;https://docs.aws.amazon.com/connect/latest/adminguide/real-time-metrics-definitions.html#staffed-real-time\&quot;&gt;Staffed&lt;/a&gt; &lt;/p&gt; &lt;/dd&gt; &lt;dt&gt;CONTACTS_IN_QUEUE&lt;/dt&gt; &lt;dd&gt; &lt;p&gt;Unit: COUNT&lt;/p&gt; &lt;p&gt;Name in real-time metrics report: &lt;a href&#x3D;\&quot;https://docs.aws.amazon.com/connect/latest/adminguide/real-time-metrics-definitions.html#in-queue-real-time\&quot;&gt;In queue&lt;/a&gt; &lt;/p&gt; &lt;/dd&gt; &lt;dt&gt;CONTACTS_SCHEDULED&lt;/dt&gt; &lt;dd&gt; &lt;p&gt;Unit: COUNT&lt;/p&gt; &lt;p&gt;Name in real-time metrics report: &lt;a href&#x3D;\&quot;https://docs.aws.amazon.com/connect/latest/adminguide/real-time-metrics-definitions.html#scheduled-real-time\&quot;&gt;Scheduled&lt;/a&gt; &lt;/p&gt; &lt;/dd&gt; &lt;dt&gt;OLDEST_CONTACT_AGE&lt;/dt&gt; &lt;dd&gt; &lt;p&gt;Unit: SECONDS&lt;/p&gt; &lt;p&gt;When you use groupings, Unit says SECONDS and the Value is returned in SECONDS. &lt;/p&gt; &lt;p&gt;When you do not use groupings, Unit says SECONDS but the Value is returned in MILLISECONDS. For example, if you get a response like this:&lt;/p&gt; &lt;p&gt; &lt;code&gt;{ \&quot;Metric\&quot;: { \&quot;Name\&quot;: \&quot;OLDEST_CONTACT_AGE\&quot;, \&quot;Unit\&quot;: \&quot;SECONDS\&quot; }, \&quot;Value\&quot;: 24113.0 &lt;/code&gt;}&lt;/p&gt; &lt;p&gt;The actual OLDEST_CONTACT_AGE is 24 seconds.&lt;/p&gt; &lt;p&gt;Name in real-time metrics report: &lt;a href&#x3D;\&quot;https://docs.aws.amazon.com/connect/latest/adminguide/real-time-metrics-definitions.html#oldest-real-time\&quot;&gt;Oldest&lt;/a&gt; &lt;/p&gt; &lt;/dd&gt; &lt;dt&gt;SLOTS_ACTIVE&lt;/dt&gt; &lt;dd&gt; &lt;p&gt;Unit: COUNT&lt;/p&gt; &lt;p&gt;Name in real-time metrics report: &lt;a href&#x3D;\&quot;https://docs.aws.amazon.com/connect/latest/adminguide/real-time-metrics-definitions.html#active-real-time\&quot;&gt;Active&lt;/a&gt; &lt;/p&gt; &lt;/dd&gt; &lt;dt&gt;SLOTS_AVAILABLE&lt;/dt&gt; &lt;dd&gt; &lt;p&gt;Unit: COUNT&lt;/p&gt; &lt;p&gt;Name in real-time metrics report: &lt;a href&#x3D;\&quot;https://docs.aws.amazon.com/connect/latest/adminguide/real-time-metrics-definitions.html#availability-real-time\&quot;&gt;Availability&lt;/a&gt; &lt;/p&gt; &lt;/dd&gt; &lt;/dl&gt;
   * @return currentMetrics
   */
  @javax.annotation.Nonnull
  public List<CurrentMetric> getCurrentMetrics() {
    return currentMetrics;
  }

  public void setCurrentMetrics(List<CurrentMetric> currentMetrics) {
    this.currentMetrics = currentMetrics;
  }


  public GetCurrentMetricDataRequest nextToken(String nextToken) {
    this.nextToken = nextToken;
    return this;
  }

  /**
   * &lt;p&gt;The token for the next set of results. Use the value returned in the previous response in the next request to retrieve the next set of results.&lt;/p&gt; &lt;p&gt;The token expires after 5 minutes from the time it is created. Subsequent requests that use the token must use the same request parameters as the request that generated the token.&lt;/p&gt;
   * @return nextToken
   */
  @javax.annotation.Nullable
  public String getNextToken() {
    return nextToken;
  }

  public void setNextToken(String nextToken) {
    this.nextToken = nextToken;
  }


  public GetCurrentMetricDataRequest maxResults(Integer maxResults) {
    this.maxResults = maxResults;
    return this;
  }

  /**
   * The maximum number of results to return per page.
   * minimum: 1
   * maximum: 100
   * @return maxResults
   */
  @javax.annotation.Nullable
  public Integer getMaxResults() {
    return maxResults;
  }

  public void setMaxResults(Integer maxResults) {
    this.maxResults = maxResults;
  }


  public GetCurrentMetricDataRequest sortCriteria(List<CurrentMetricSortCriteria> sortCriteria) {
    this.sortCriteria = sortCriteria;
    return this;
  }

  public GetCurrentMetricDataRequest addSortCriteriaItem(CurrentMetricSortCriteria sortCriteriaItem) {
    if (this.sortCriteria == null) {
      this.sortCriteria = new ArrayList<>();
    }
    this.sortCriteria.add(sortCriteriaItem);
    return this;
  }

  /**
   * &lt;p&gt;The way to sort the resulting response based on metrics. You can enter one sort criteria. By default resources are sorted based on &lt;code&gt;AGENTS_ONLINE&lt;/code&gt;, &lt;code&gt;DESCENDING&lt;/code&gt;. The metric collection is sorted based on the input metrics.&lt;/p&gt; &lt;p&gt;Note the following:&lt;/p&gt; &lt;ul&gt; &lt;li&gt; &lt;p&gt;Sorting on &lt;code&gt;SLOTS_ACTIVE&lt;/code&gt; and &lt;code&gt;SLOTS_AVAILABLE&lt;/code&gt; is not supported.&lt;/p&gt; &lt;/li&gt; &lt;/ul&gt;
   * @return sortCriteria
   */
  @javax.annotation.Nullable
  public List<CurrentMetricSortCriteria> getSortCriteria() {
    return sortCriteria;
  }

  public void setSortCriteria(List<CurrentMetricSortCriteria> sortCriteria) {
    this.sortCriteria = sortCriteria;
  }



  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    GetCurrentMetricDataRequest getCurrentMetricDataRequest = (GetCurrentMetricDataRequest) o;
    return Objects.equals(this.filters, getCurrentMetricDataRequest.filters) &&
        Objects.equals(this.groupings, getCurrentMetricDataRequest.groupings) &&
        Objects.equals(this.currentMetrics, getCurrentMetricDataRequest.currentMetrics) &&
        Objects.equals(this.nextToken, getCurrentMetricDataRequest.nextToken) &&
        Objects.equals(this.maxResults, getCurrentMetricDataRequest.maxResults) &&
        Objects.equals(this.sortCriteria, getCurrentMetricDataRequest.sortCriteria);
  }

  @Override
  public int hashCode() {
    return Objects.hash(filters, groupings, currentMetrics, nextToken, maxResults, sortCriteria);
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class GetCurrentMetricDataRequest {\n");
    sb.append("    filters: ").append(toIndentedString(filters)).append("\n");
    sb.append("    groupings: ").append(toIndentedString(groupings)).append("\n");
    sb.append("    currentMetrics: ").append(toIndentedString(currentMetrics)).append("\n");
    sb.append("    nextToken: ").append(toIndentedString(nextToken)).append("\n");
    sb.append("    maxResults: ").append(toIndentedString(maxResults)).append("\n");
    sb.append("    sortCriteria: ").append(toIndentedString(sortCriteria)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }


  public static HashSet<String> openapiFields;
  public static HashSet<String> openapiRequiredFields;

  static {
    // a set of all properties/fields (JSON key names)
    openapiFields = new HashSet<String>();
    openapiFields.add("Filters");
    openapiFields.add("Groupings");
    openapiFields.add("CurrentMetrics");
    openapiFields.add("NextToken");
    openapiFields.add("MaxResults");
    openapiFields.add("SortCriteria");

    // a set of required properties/fields (JSON key names)
    openapiRequiredFields = new HashSet<String>();
    openapiRequiredFields.add("Filters");
    openapiRequiredFields.add("CurrentMetrics");
  }

  /**
   * Validates the JSON Element and throws an exception if issues found
   *
   * @param jsonElement JSON Element
   * @throws IOException if the JSON Element is invalid with respect to GetCurrentMetricDataRequest
   */
  public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      if (jsonElement == null) {
        if (!GetCurrentMetricDataRequest.openapiRequiredFields.isEmpty()) { // has required fields but JSON element is null
          throw new IllegalArgumentException(String.format("The required field(s) %s in GetCurrentMetricDataRequest is not found in the empty JSON string", GetCurrentMetricDataRequest.openapiRequiredFields.toString()));
        }
      }

      Set<Map.Entry<String, JsonElement>> entries = jsonElement.getAsJsonObject().entrySet();
      // check to see if the JSON string contains additional fields
      for (Map.Entry<String, JsonElement> entry : entries) {
        if (!GetCurrentMetricDataRequest.openapiFields.contains(entry.getKey())) {
          throw new IllegalArgumentException(String.format("The field `%s` in the JSON string is not defined in the `GetCurrentMetricDataRequest` properties. JSON: %s", entry.getKey(), jsonElement.toString()));
        }
      }

      // check to make sure all required properties/fields are present in the JSON string
      for (String requiredField : GetCurrentMetricDataRequest.openapiRequiredFields) {
        if (jsonElement.getAsJsonObject().get(requiredField) == null) {
          throw new IllegalArgumentException(String.format("The required field `%s` is not found in the JSON string: %s", requiredField, jsonElement.toString()));
        }
      }
        JsonObject jsonObj = jsonElement.getAsJsonObject();
      // validate the required field `Filters`
      GetCurrentMetricDataRequestFilters.validateJsonElement(jsonObj.get("Filters"));
      // ensure the optional json data is an array if present
      if (jsonObj.get("Groupings") != null && !jsonObj.get("Groupings").isJsonNull() && !jsonObj.get("Groupings").isJsonArray()) {
        throw new IllegalArgumentException(String.format("Expected the field `Groupings` to be an array in the JSON string but got `%s`", jsonObj.get("Groupings").toString()));
      }
      // ensure the json data is an array
      if (!jsonObj.get("CurrentMetrics").isJsonArray()) {
        throw new IllegalArgumentException(String.format("Expected the field `CurrentMetrics` to be an array in the JSON string but got `%s`", jsonObj.get("CurrentMetrics").toString()));
      }

      JsonArray jsonArraycurrentMetrics = jsonObj.getAsJsonArray("CurrentMetrics");
      // validate the required field `CurrentMetrics` (array)
      for (int i = 0; i < jsonArraycurrentMetrics.size(); i++) {
        CurrentMetric.validateJsonElement(jsonArraycurrentMetrics.get(i));
      };
      if ((jsonObj.get("NextToken") != null && !jsonObj.get("NextToken").isJsonNull()) && !jsonObj.get("NextToken").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `NextToken` to be a primitive type in the JSON string but got `%s`", jsonObj.get("NextToken").toString()));
      }
      if (jsonObj.get("SortCriteria") != null && !jsonObj.get("SortCriteria").isJsonNull()) {
        JsonArray jsonArraysortCriteria = jsonObj.getAsJsonArray("SortCriteria");
        if (jsonArraysortCriteria != null) {
          // ensure the json data is an array
          if (!jsonObj.get("SortCriteria").isJsonArray()) {
            throw new IllegalArgumentException(String.format("Expected the field `SortCriteria` to be an array in the JSON string but got `%s`", jsonObj.get("SortCriteria").toString()));
          }

          // validate the optional field `SortCriteria` (array)
          for (int i = 0; i < jsonArraysortCriteria.size(); i++) {
            CurrentMetricSortCriteria.validateJsonElement(jsonArraysortCriteria.get(i));
          };
        }
      }
  }

  public static class CustomTypeAdapterFactory implements TypeAdapterFactory {
    @SuppressWarnings("unchecked")
    @Override
    public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
       if (!GetCurrentMetricDataRequest.class.isAssignableFrom(type.getRawType())) {
         return null; // this class only serializes 'GetCurrentMetricDataRequest' and its subtypes
       }
       final TypeAdapter<JsonElement> elementAdapter = gson.getAdapter(JsonElement.class);
       final TypeAdapter<GetCurrentMetricDataRequest> thisAdapter
                        = gson.getDelegateAdapter(this, TypeToken.get(GetCurrentMetricDataRequest.class));

       return (TypeAdapter<T>) new TypeAdapter<GetCurrentMetricDataRequest>() {
           @Override
           public void write(JsonWriter out, GetCurrentMetricDataRequest value) throws IOException {
             JsonObject obj = thisAdapter.toJsonTree(value).getAsJsonObject();
             elementAdapter.write(out, obj);
           }

           @Override
           public GetCurrentMetricDataRequest read(JsonReader in) throws IOException {
             JsonElement jsonElement = elementAdapter.read(in);
             validateJsonElement(jsonElement);
             return thisAdapter.fromJsonTree(jsonElement);
           }

       }.nullSafe();
    }
  }

  /**
   * Create an instance of GetCurrentMetricDataRequest given an JSON string
   *
   * @param jsonString JSON string
   * @return An instance of GetCurrentMetricDataRequest
   * @throws IOException if the JSON string is invalid with respect to GetCurrentMetricDataRequest
   */
  public static GetCurrentMetricDataRequest fromJson(String jsonString) throws IOException {
    return JSON.getGson().fromJson(jsonString, GetCurrentMetricDataRequest.class);
  }

  /**
   * Convert an instance of GetCurrentMetricDataRequest to an JSON string
   *
   * @return JSON string
   */
  public String toJson() {
    return JSON.getGson().toJson(this);
  }
}

