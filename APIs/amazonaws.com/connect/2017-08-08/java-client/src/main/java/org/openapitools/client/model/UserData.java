/*
 * Amazon Connect Service
 * <p>Amazon Connect is a cloud-based contact center solution that you use to set up and manage a customer contact center and provide reliable customer engagement at any scale.</p> <p>Amazon Connect provides metrics and real-time reporting that enable you to optimize contact routing. You can also resolve customer issues more efficiently by getting customers in touch with the appropriate agents.</p> <p>There are limits to the number of Amazon Connect resources that you can create. There are also limits to the number of requests that you can make per second. For more information, see <a href=\"https://docs.aws.amazon.com/connect/latest/adminguide/amazon-connect-service-limits.html\">Amazon Connect Service Quotas</a> in the <i>Amazon Connect Administrator Guide</i>.</p> <p>You can connect programmatically to an Amazon Web Services service by using an endpoint. For a list of Amazon Connect endpoints, see <a href=\"https://docs.aws.amazon.com/general/latest/gr/connect_region.html\">Amazon Connect Endpoints</a>.</p>
 *
 * The version of the OpenAPI document: 2017-08-08
 * Contact: mike.ralphson@gmail.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package org.openapitools.client.model;

import java.util.Objects;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;
import java.util.Arrays;
import java.util.List;
import java.util.Map;
import org.openapitools.client.model.UserDataHierarchyPath;
import org.openapitools.client.model.UserDataRoutingProfile;
import org.openapitools.client.model.UserDataStatus;
import org.openapitools.client.model.UserDataUser;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonArray;
import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;
import com.google.gson.TypeAdapterFactory;
import com.google.gson.reflect.TypeToken;
import com.google.gson.TypeAdapter;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;

import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import org.openapitools.client.JSON;

/**
 * Data for a user.
 */
@javax.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen", date = "2024-10-12T12:25:13.911190-04:00[America/New_York]", comments = "Generator version: 7.9.0")
public class UserData {
  public static final String SERIALIZED_NAME_USER = "User";
  @SerializedName(SERIALIZED_NAME_USER)
  private UserDataUser user;

  public static final String SERIALIZED_NAME_ROUTING_PROFILE = "RoutingProfile";
  @SerializedName(SERIALIZED_NAME_ROUTING_PROFILE)
  private UserDataRoutingProfile routingProfile;

  public static final String SERIALIZED_NAME_HIERARCHY_PATH = "HierarchyPath";
  @SerializedName(SERIALIZED_NAME_HIERARCHY_PATH)
  private UserDataHierarchyPath hierarchyPath;

  public static final String SERIALIZED_NAME_STATUS = "Status";
  @SerializedName(SERIALIZED_NAME_STATUS)
  private UserDataStatus status;

  public static final String SERIALIZED_NAME_AVAILABLE_SLOTS_BY_CHANNEL = "AvailableSlotsByChannel";
  @SerializedName(SERIALIZED_NAME_AVAILABLE_SLOTS_BY_CHANNEL)
  private Map availableSlotsByChannel;

  public static final String SERIALIZED_NAME_MAX_SLOTS_BY_CHANNEL = "MaxSlotsByChannel";
  @SerializedName(SERIALIZED_NAME_MAX_SLOTS_BY_CHANNEL)
  private Map maxSlotsByChannel;

  public static final String SERIALIZED_NAME_ACTIVE_SLOTS_BY_CHANNEL = "ActiveSlotsByChannel";
  @SerializedName(SERIALIZED_NAME_ACTIVE_SLOTS_BY_CHANNEL)
  private Map activeSlotsByChannel;

  public static final String SERIALIZED_NAME_CONTACTS = "Contacts";
  @SerializedName(SERIALIZED_NAME_CONTACTS)
  private List contacts;

  public static final String SERIALIZED_NAME_NEXT_STATUS = "NextStatus";
  @SerializedName(SERIALIZED_NAME_NEXT_STATUS)
  private String nextStatus;

  public UserData() {
  }

  public UserData user(UserDataUser user) {
    this.user = user;
    return this;
  }

  /**
   * Get user
   * @return user
   */
  @javax.annotation.Nullable
  public UserDataUser getUser() {
    return user;
  }

  public void setUser(UserDataUser user) {
    this.user = user;
  }


  public UserData routingProfile(UserDataRoutingProfile routingProfile) {
    this.routingProfile = routingProfile;
    return this;
  }

  /**
   * Get routingProfile
   * @return routingProfile
   */
  @javax.annotation.Nullable
  public UserDataRoutingProfile getRoutingProfile() {
    return routingProfile;
  }

  public void setRoutingProfile(UserDataRoutingProfile routingProfile) {
    this.routingProfile = routingProfile;
  }


  public UserData hierarchyPath(UserDataHierarchyPath hierarchyPath) {
    this.hierarchyPath = hierarchyPath;
    return this;
  }

  /**
   * Get hierarchyPath
   * @return hierarchyPath
   */
  @javax.annotation.Nullable
  public UserDataHierarchyPath getHierarchyPath() {
    return hierarchyPath;
  }

  public void setHierarchyPath(UserDataHierarchyPath hierarchyPath) {
    this.hierarchyPath = hierarchyPath;
  }


  public UserData status(UserDataStatus status) {
    this.status = status;
    return this;
  }

  /**
   * Get status
   * @return status
   */
  @javax.annotation.Nullable
  public UserDataStatus getStatus() {
    return status;
  }

  public void setStatus(UserDataStatus status) {
    this.status = status;
  }


  public UserData availableSlotsByChannel(Map availableSlotsByChannel) {
    this.availableSlotsByChannel = availableSlotsByChannel;
    return this;
  }

  /**
   * Get availableSlotsByChannel
   * @return availableSlotsByChannel
   */
  @javax.annotation.Nullable
  public Map getAvailableSlotsByChannel() {
    return availableSlotsByChannel;
  }

  public void setAvailableSlotsByChannel(Map availableSlotsByChannel) {
    this.availableSlotsByChannel = availableSlotsByChannel;
  }


  public UserData maxSlotsByChannel(Map maxSlotsByChannel) {
    this.maxSlotsByChannel = maxSlotsByChannel;
    return this;
  }

  /**
   * Get maxSlotsByChannel
   * @return maxSlotsByChannel
   */
  @javax.annotation.Nullable
  public Map getMaxSlotsByChannel() {
    return maxSlotsByChannel;
  }

  public void setMaxSlotsByChannel(Map maxSlotsByChannel) {
    this.maxSlotsByChannel = maxSlotsByChannel;
  }


  public UserData activeSlotsByChannel(Map activeSlotsByChannel) {
    this.activeSlotsByChannel = activeSlotsByChannel;
    return this;
  }

  /**
   * Get activeSlotsByChannel
   * @return activeSlotsByChannel
   */
  @javax.annotation.Nullable
  public Map getActiveSlotsByChannel() {
    return activeSlotsByChannel;
  }

  public void setActiveSlotsByChannel(Map activeSlotsByChannel) {
    this.activeSlotsByChannel = activeSlotsByChannel;
  }


  public UserData contacts(List contacts) {
    this.contacts = contacts;
    return this;
  }

  /**
   * Get contacts
   * @return contacts
   */
  @javax.annotation.Nullable
  public List getContacts() {
    return contacts;
  }

  public void setContacts(List contacts) {
    this.contacts = contacts;
  }


  public UserData nextStatus(String nextStatus) {
    this.nextStatus = nextStatus;
    return this;
  }

  /**
   * Get nextStatus
   * @return nextStatus
   */
  @javax.annotation.Nullable
  public String getNextStatus() {
    return nextStatus;
  }

  public void setNextStatus(String nextStatus) {
    this.nextStatus = nextStatus;
  }



  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    UserData userData = (UserData) o;
    return Objects.equals(this.user, userData.user) &&
        Objects.equals(this.routingProfile, userData.routingProfile) &&
        Objects.equals(this.hierarchyPath, userData.hierarchyPath) &&
        Objects.equals(this.status, userData.status) &&
        Objects.equals(this.availableSlotsByChannel, userData.availableSlotsByChannel) &&
        Objects.equals(this.maxSlotsByChannel, userData.maxSlotsByChannel) &&
        Objects.equals(this.activeSlotsByChannel, userData.activeSlotsByChannel) &&
        Objects.equals(this.contacts, userData.contacts) &&
        Objects.equals(this.nextStatus, userData.nextStatus);
  }

  @Override
  public int hashCode() {
    return Objects.hash(user, routingProfile, hierarchyPath, status, availableSlotsByChannel, maxSlotsByChannel, activeSlotsByChannel, contacts, nextStatus);
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class UserData {\n");
    sb.append("    user: ").append(toIndentedString(user)).append("\n");
    sb.append("    routingProfile: ").append(toIndentedString(routingProfile)).append("\n");
    sb.append("    hierarchyPath: ").append(toIndentedString(hierarchyPath)).append("\n");
    sb.append("    status: ").append(toIndentedString(status)).append("\n");
    sb.append("    availableSlotsByChannel: ").append(toIndentedString(availableSlotsByChannel)).append("\n");
    sb.append("    maxSlotsByChannel: ").append(toIndentedString(maxSlotsByChannel)).append("\n");
    sb.append("    activeSlotsByChannel: ").append(toIndentedString(activeSlotsByChannel)).append("\n");
    sb.append("    contacts: ").append(toIndentedString(contacts)).append("\n");
    sb.append("    nextStatus: ").append(toIndentedString(nextStatus)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }


  public static HashSet<String> openapiFields;
  public static HashSet<String> openapiRequiredFields;

  static {
    // a set of all properties/fields (JSON key names)
    openapiFields = new HashSet<String>();
    openapiFields.add("User");
    openapiFields.add("RoutingProfile");
    openapiFields.add("HierarchyPath");
    openapiFields.add("Status");
    openapiFields.add("AvailableSlotsByChannel");
    openapiFields.add("MaxSlotsByChannel");
    openapiFields.add("ActiveSlotsByChannel");
    openapiFields.add("Contacts");
    openapiFields.add("NextStatus");

    // a set of required properties/fields (JSON key names)
    openapiRequiredFields = new HashSet<String>();
  }

  /**
   * Validates the JSON Element and throws an exception if issues found
   *
   * @param jsonElement JSON Element
   * @throws IOException if the JSON Element is invalid with respect to UserData
   */
  public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      if (jsonElement == null) {
        if (!UserData.openapiRequiredFields.isEmpty()) { // has required fields but JSON element is null
          throw new IllegalArgumentException(String.format("The required field(s) %s in UserData is not found in the empty JSON string", UserData.openapiRequiredFields.toString()));
        }
      }

      Set<Map.Entry<String, JsonElement>> entries = jsonElement.getAsJsonObject().entrySet();
      // check to see if the JSON string contains additional fields
      for (Map.Entry<String, JsonElement> entry : entries) {
        if (!UserData.openapiFields.contains(entry.getKey())) {
          throw new IllegalArgumentException(String.format("The field `%s` in the JSON string is not defined in the `UserData` properties. JSON: %s", entry.getKey(), jsonElement.toString()));
        }
      }
        JsonObject jsonObj = jsonElement.getAsJsonObject();
      // validate the optional field `User`
      if (jsonObj.get("User") != null && !jsonObj.get("User").isJsonNull()) {
        UserDataUser.validateJsonElement(jsonObj.get("User"));
      }
      // validate the optional field `RoutingProfile`
      if (jsonObj.get("RoutingProfile") != null && !jsonObj.get("RoutingProfile").isJsonNull()) {
        UserDataRoutingProfile.validateJsonElement(jsonObj.get("RoutingProfile"));
      }
      // validate the optional field `HierarchyPath`
      if (jsonObj.get("HierarchyPath") != null && !jsonObj.get("HierarchyPath").isJsonNull()) {
        UserDataHierarchyPath.validateJsonElement(jsonObj.get("HierarchyPath"));
      }
      // validate the optional field `Status`
      if (jsonObj.get("Status") != null && !jsonObj.get("Status").isJsonNull()) {
        UserDataStatus.validateJsonElement(jsonObj.get("Status"));
      }
      // validate the optional field `AvailableSlotsByChannel`
      if (jsonObj.get("AvailableSlotsByChannel") != null && !jsonObj.get("AvailableSlotsByChannel").isJsonNull()) {
        Map.validateJsonElement(jsonObj.get("AvailableSlotsByChannel"));
      }
      // validate the optional field `MaxSlotsByChannel`
      if (jsonObj.get("MaxSlotsByChannel") != null && !jsonObj.get("MaxSlotsByChannel").isJsonNull()) {
        Map.validateJsonElement(jsonObj.get("MaxSlotsByChannel"));
      }
      // validate the optional field `ActiveSlotsByChannel`
      if (jsonObj.get("ActiveSlotsByChannel") != null && !jsonObj.get("ActiveSlotsByChannel").isJsonNull()) {
        Map.validateJsonElement(jsonObj.get("ActiveSlotsByChannel"));
      }
      // validate the optional field `Contacts`
      if (jsonObj.get("Contacts") != null && !jsonObj.get("Contacts").isJsonNull()) {
        List.validateJsonElement(jsonObj.get("Contacts"));
      }
      // validate the optional field `NextStatus`
      if (jsonObj.get("NextStatus") != null && !jsonObj.get("NextStatus").isJsonNull()) {
        String.validateJsonElement(jsonObj.get("NextStatus"));
      }
  }

  public static class CustomTypeAdapterFactory implements TypeAdapterFactory {
    @SuppressWarnings("unchecked")
    @Override
    public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
       if (!UserData.class.isAssignableFrom(type.getRawType())) {
         return null; // this class only serializes 'UserData' and its subtypes
       }
       final TypeAdapter<JsonElement> elementAdapter = gson.getAdapter(JsonElement.class);
       final TypeAdapter<UserData> thisAdapter
                        = gson.getDelegateAdapter(this, TypeToken.get(UserData.class));

       return (TypeAdapter<T>) new TypeAdapter<UserData>() {
           @Override
           public void write(JsonWriter out, UserData value) throws IOException {
             JsonObject obj = thisAdapter.toJsonTree(value).getAsJsonObject();
             elementAdapter.write(out, obj);
           }

           @Override
           public UserData read(JsonReader in) throws IOException {
             JsonElement jsonElement = elementAdapter.read(in);
             validateJsonElement(jsonElement);
             return thisAdapter.fromJsonTree(jsonElement);
           }

       }.nullSafe();
    }
  }

  /**
   * Create an instance of UserData given an JSON string
   *
   * @param jsonString JSON string
   * @return An instance of UserData
   * @throws IOException if the JSON string is invalid with respect to UserData
   */
  public static UserData fromJson(String jsonString) throws IOException {
    return JSON.getGson().fromJson(jsonString, UserData.class);
  }

  /**
   * Convert an instance of UserData to an JSON string
   *
   * @return JSON string
   */
  public String toJson() {
    return JSON.getGson().toJson(this);
  }
}

