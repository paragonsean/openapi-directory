/**
 * AWS Shield
 * <fullname>Shield Advanced</fullname> <p>This is the <i>Shield Advanced API Reference</i>. This guide is for developers who need detailed information about the Shield Advanced API actions, data types, and errors. For detailed information about WAF and Shield Advanced features and an overview of how to use the WAF and Shield Advanced APIs, see the <a href=\"https://docs.aws.amazon.com/waf/latest/developerguide/\">WAF and Shield Developer Guide</a>.</p>
 *
 * The version of the OpenAPI document: 2016-06-02
 * Contact: mike.ralphson@gmail.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

#include "OAISubscription.h"

#include <QDebug>
#include <QJsonArray>
#include <QJsonDocument>
#include <QObject>

#include "OAIHelpers.h"

namespace OpenAPI {

OAISubscription::OAISubscription(QString json) {
    this->initializeModel();
    this->fromJson(json);
}

OAISubscription::OAISubscription() {
    this->initializeModel();
}

OAISubscription::~OAISubscription() {}

void OAISubscription::initializeModel() {

    m_start_time_isSet = false;
    m_start_time_isValid = false;

    m_end_time_isSet = false;
    m_end_time_isValid = false;

    m_time_commitment_in_seconds_isSet = false;
    m_time_commitment_in_seconds_isValid = false;

    m_auto_renew_isSet = false;
    m_auto_renew_isValid = false;

    m_limits_isSet = false;
    m_limits_isValid = false;

    m_proactive_engagement_status_isSet = false;
    m_proactive_engagement_status_isValid = false;

    m_subscription_limits_isSet = false;
    m_subscription_limits_isValid = false;

    m_subscription_arn_isSet = false;
    m_subscription_arn_isValid = false;
}

void OAISubscription::fromJson(QString jsonString) {
    QByteArray array(jsonString.toStdString().c_str());
    QJsonDocument doc = QJsonDocument::fromJson(array);
    QJsonObject jsonObject = doc.object();
    this->fromJsonObject(jsonObject);
}

void OAISubscription::fromJsonObject(QJsonObject json) {

    m_start_time_isValid = ::OpenAPI::fromJsonValue(m_start_time, json[QString("StartTime")]);
    m_start_time_isSet = !json[QString("StartTime")].isNull() && m_start_time_isValid;

    m_end_time_isValid = ::OpenAPI::fromJsonValue(m_end_time, json[QString("EndTime")]);
    m_end_time_isSet = !json[QString("EndTime")].isNull() && m_end_time_isValid;

    m_time_commitment_in_seconds_isValid = ::OpenAPI::fromJsonValue(m_time_commitment_in_seconds, json[QString("TimeCommitmentInSeconds")]);
    m_time_commitment_in_seconds_isSet = !json[QString("TimeCommitmentInSeconds")].isNull() && m_time_commitment_in_seconds_isValid;

    m_auto_renew_isValid = ::OpenAPI::fromJsonValue(m_auto_renew, json[QString("AutoRenew")]);
    m_auto_renew_isSet = !json[QString("AutoRenew")].isNull() && m_auto_renew_isValid;

    m_limits_isValid = ::OpenAPI::fromJsonValue(m_limits, json[QString("Limits")]);
    m_limits_isSet = !json[QString("Limits")].isNull() && m_limits_isValid;

    m_proactive_engagement_status_isValid = ::OpenAPI::fromJsonValue(m_proactive_engagement_status, json[QString("ProactiveEngagementStatus")]);
    m_proactive_engagement_status_isSet = !json[QString("ProactiveEngagementStatus")].isNull() && m_proactive_engagement_status_isValid;

    m_subscription_limits_isValid = ::OpenAPI::fromJsonValue(m_subscription_limits, json[QString("SubscriptionLimits")]);
    m_subscription_limits_isSet = !json[QString("SubscriptionLimits")].isNull() && m_subscription_limits_isValid;

    m_subscription_arn_isValid = ::OpenAPI::fromJsonValue(m_subscription_arn, json[QString("SubscriptionArn")]);
    m_subscription_arn_isSet = !json[QString("SubscriptionArn")].isNull() && m_subscription_arn_isValid;
}

QString OAISubscription::asJson() const {
    QJsonObject obj = this->asJsonObject();
    QJsonDocument doc(obj);
    QByteArray bytes = doc.toJson();
    return QString(bytes);
}

QJsonObject OAISubscription::asJsonObject() const {
    QJsonObject obj;
    if (m_start_time_isSet) {
        obj.insert(QString("StartTime"), ::OpenAPI::toJsonValue(m_start_time));
    }
    if (m_end_time_isSet) {
        obj.insert(QString("EndTime"), ::OpenAPI::toJsonValue(m_end_time));
    }
    if (m_time_commitment_in_seconds_isSet) {
        obj.insert(QString("TimeCommitmentInSeconds"), ::OpenAPI::toJsonValue(m_time_commitment_in_seconds));
    }
    if (m_auto_renew.isSet()) {
        obj.insert(QString("AutoRenew"), ::OpenAPI::toJsonValue(m_auto_renew));
    }
    if (m_limits.isSet()) {
        obj.insert(QString("Limits"), ::OpenAPI::toJsonValue(m_limits));
    }
    if (m_proactive_engagement_status.isSet()) {
        obj.insert(QString("ProactiveEngagementStatus"), ::OpenAPI::toJsonValue(m_proactive_engagement_status));
    }
    if (m_subscription_limits.isSet()) {
        obj.insert(QString("SubscriptionLimits"), ::OpenAPI::toJsonValue(m_subscription_limits));
    }
    if (m_subscription_arn_isSet) {
        obj.insert(QString("SubscriptionArn"), ::OpenAPI::toJsonValue(m_subscription_arn));
    }
    return obj;
}

QDateTime OAISubscription::getStartTime() const {
    return m_start_time;
}
void OAISubscription::setStartTime(const QDateTime &start_time) {
    m_start_time = start_time;
    m_start_time_isSet = true;
}

bool OAISubscription::is_start_time_Set() const{
    return m_start_time_isSet;
}

bool OAISubscription::is_start_time_Valid() const{
    return m_start_time_isValid;
}

QDateTime OAISubscription::getEndTime() const {
    return m_end_time;
}
void OAISubscription::setEndTime(const QDateTime &end_time) {
    m_end_time = end_time;
    m_end_time_isSet = true;
}

bool OAISubscription::is_end_time_Set() const{
    return m_end_time_isSet;
}

bool OAISubscription::is_end_time_Valid() const{
    return m_end_time_isValid;
}

qint32 OAISubscription::getTimeCommitmentInSeconds() const {
    return m_time_commitment_in_seconds;
}
void OAISubscription::setTimeCommitmentInSeconds(const qint32 &time_commitment_in_seconds) {
    m_time_commitment_in_seconds = time_commitment_in_seconds;
    m_time_commitment_in_seconds_isSet = true;
}

bool OAISubscription::is_time_commitment_in_seconds_Set() const{
    return m_time_commitment_in_seconds_isSet;
}

bool OAISubscription::is_time_commitment_in_seconds_Valid() const{
    return m_time_commitment_in_seconds_isValid;
}

OAIAutoRenew OAISubscription::getAutoRenew() const {
    return m_auto_renew;
}
void OAISubscription::setAutoRenew(const OAIAutoRenew &auto_renew) {
    m_auto_renew = auto_renew;
    m_auto_renew_isSet = true;
}

bool OAISubscription::is_auto_renew_Set() const{
    return m_auto_renew_isSet;
}

bool OAISubscription::is_auto_renew_Valid() const{
    return m_auto_renew_isValid;
}

QList OAISubscription::getLimits() const {
    return m_limits;
}
void OAISubscription::setLimits(const QList &limits) {
    m_limits = limits;
    m_limits_isSet = true;
}

bool OAISubscription::is_limits_Set() const{
    return m_limits_isSet;
}

bool OAISubscription::is_limits_Valid() const{
    return m_limits_isValid;
}

OAIProactiveEngagementStatus OAISubscription::getProactiveEngagementStatus() const {
    return m_proactive_engagement_status;
}
void OAISubscription::setProactiveEngagementStatus(const OAIProactiveEngagementStatus &proactive_engagement_status) {
    m_proactive_engagement_status = proactive_engagement_status;
    m_proactive_engagement_status_isSet = true;
}

bool OAISubscription::is_proactive_engagement_status_Set() const{
    return m_proactive_engagement_status_isSet;
}

bool OAISubscription::is_proactive_engagement_status_Valid() const{
    return m_proactive_engagement_status_isValid;
}

OAISubscription_SubscriptionLimits OAISubscription::getSubscriptionLimits() const {
    return m_subscription_limits;
}
void OAISubscription::setSubscriptionLimits(const OAISubscription_SubscriptionLimits &subscription_limits) {
    m_subscription_limits = subscription_limits;
    m_subscription_limits_isSet = true;
}

bool OAISubscription::is_subscription_limits_Set() const{
    return m_subscription_limits_isSet;
}

bool OAISubscription::is_subscription_limits_Valid() const{
    return m_subscription_limits_isValid;
}

QString OAISubscription::getSubscriptionArn() const {
    return m_subscription_arn;
}
void OAISubscription::setSubscriptionArn(const QString &subscription_arn) {
    m_subscription_arn = subscription_arn;
    m_subscription_arn_isSet = true;
}

bool OAISubscription::is_subscription_arn_Set() const{
    return m_subscription_arn_isSet;
}

bool OAISubscription::is_subscription_arn_Valid() const{
    return m_subscription_arn_isValid;
}

bool OAISubscription::isSet() const {
    bool isObjectUpdated = false;
    do {
        if (m_start_time_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_end_time_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_time_commitment_in_seconds_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_auto_renew.isSet()) {
            isObjectUpdated = true;
            break;
        }

        if (m_limits.isSet()) {
            isObjectUpdated = true;
            break;
        }

        if (m_proactive_engagement_status.isSet()) {
            isObjectUpdated = true;
            break;
        }

        if (m_subscription_limits.isSet()) {
            isObjectUpdated = true;
            break;
        }

        if (m_subscription_arn_isSet) {
            isObjectUpdated = true;
            break;
        }
    } while (false);
    return isObjectUpdated;
}

bool OAISubscription::isValid() const {
    // only required properties are required for the object to be considered valid
    return m_subscription_limits_isValid && true;
}

} // namespace OpenAPI
