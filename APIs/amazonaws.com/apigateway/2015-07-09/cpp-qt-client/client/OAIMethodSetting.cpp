/**
 * Amazon API Gateway
 * <fullname>Amazon API Gateway</fullname> <p>Amazon API Gateway helps developers deliver robust, secure, and scalable mobile and web application back ends. API Gateway allows developers to securely connect mobile and web applications to APIs that run on AWS Lambda, Amazon EC2, or other publicly addressable web services that are hosted outside of AWS.</p>
 *
 * The version of the OpenAPI document: 2015-07-09
 * Contact: mike.ralphson@gmail.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

#include "OAIMethodSetting.h"

#include <QDebug>
#include <QJsonArray>
#include <QJsonDocument>
#include <QObject>

#include "OAIHelpers.h"

namespace OpenAPI {

OAIMethodSetting::OAIMethodSetting(QString json) {
    this->initializeModel();
    this->fromJson(json);
}

OAIMethodSetting::OAIMethodSetting() {
    this->initializeModel();
}

OAIMethodSetting::~OAIMethodSetting() {}

void OAIMethodSetting::initializeModel() {

    m_metrics_enabled_isSet = false;
    m_metrics_enabled_isValid = false;

    m_logging_level_isSet = false;
    m_logging_level_isValid = false;

    m_data_trace_enabled_isSet = false;
    m_data_trace_enabled_isValid = false;

    m_throttling_burst_limit_isSet = false;
    m_throttling_burst_limit_isValid = false;

    m_throttling_rate_limit_isSet = false;
    m_throttling_rate_limit_isValid = false;

    m_caching_enabled_isSet = false;
    m_caching_enabled_isValid = false;

    m_cache_ttl_in_seconds_isSet = false;
    m_cache_ttl_in_seconds_isValid = false;

    m_cache_data_encrypted_isSet = false;
    m_cache_data_encrypted_isValid = false;

    m_require_authorization_for_cache_control_isSet = false;
    m_require_authorization_for_cache_control_isValid = false;

    m_unauthorized_cache_control_header_strategy_isSet = false;
    m_unauthorized_cache_control_header_strategy_isValid = false;
}

void OAIMethodSetting::fromJson(QString jsonString) {
    QByteArray array(jsonString.toStdString().c_str());
    QJsonDocument doc = QJsonDocument::fromJson(array);
    QJsonObject jsonObject = doc.object();
    this->fromJsonObject(jsonObject);
}

void OAIMethodSetting::fromJsonObject(QJsonObject json) {

    m_metrics_enabled_isValid = ::OpenAPI::fromJsonValue(m_metrics_enabled, json[QString("metricsEnabled")]);
    m_metrics_enabled_isSet = !json[QString("metricsEnabled")].isNull() && m_metrics_enabled_isValid;

    m_logging_level_isValid = ::OpenAPI::fromJsonValue(m_logging_level, json[QString("loggingLevel")]);
    m_logging_level_isSet = !json[QString("loggingLevel")].isNull() && m_logging_level_isValid;

    m_data_trace_enabled_isValid = ::OpenAPI::fromJsonValue(m_data_trace_enabled, json[QString("dataTraceEnabled")]);
    m_data_trace_enabled_isSet = !json[QString("dataTraceEnabled")].isNull() && m_data_trace_enabled_isValid;

    m_throttling_burst_limit_isValid = ::OpenAPI::fromJsonValue(m_throttling_burst_limit, json[QString("throttlingBurstLimit")]);
    m_throttling_burst_limit_isSet = !json[QString("throttlingBurstLimit")].isNull() && m_throttling_burst_limit_isValid;

    m_throttling_rate_limit_isValid = ::OpenAPI::fromJsonValue(m_throttling_rate_limit, json[QString("throttlingRateLimit")]);
    m_throttling_rate_limit_isSet = !json[QString("throttlingRateLimit")].isNull() && m_throttling_rate_limit_isValid;

    m_caching_enabled_isValid = ::OpenAPI::fromJsonValue(m_caching_enabled, json[QString("cachingEnabled")]);
    m_caching_enabled_isSet = !json[QString("cachingEnabled")].isNull() && m_caching_enabled_isValid;

    m_cache_ttl_in_seconds_isValid = ::OpenAPI::fromJsonValue(m_cache_ttl_in_seconds, json[QString("cacheTtlInSeconds")]);
    m_cache_ttl_in_seconds_isSet = !json[QString("cacheTtlInSeconds")].isNull() && m_cache_ttl_in_seconds_isValid;

    m_cache_data_encrypted_isValid = ::OpenAPI::fromJsonValue(m_cache_data_encrypted, json[QString("cacheDataEncrypted")]);
    m_cache_data_encrypted_isSet = !json[QString("cacheDataEncrypted")].isNull() && m_cache_data_encrypted_isValid;

    m_require_authorization_for_cache_control_isValid = ::OpenAPI::fromJsonValue(m_require_authorization_for_cache_control, json[QString("requireAuthorizationForCacheControl")]);
    m_require_authorization_for_cache_control_isSet = !json[QString("requireAuthorizationForCacheControl")].isNull() && m_require_authorization_for_cache_control_isValid;

    m_unauthorized_cache_control_header_strategy_isValid = ::OpenAPI::fromJsonValue(m_unauthorized_cache_control_header_strategy, json[QString("unauthorizedCacheControlHeaderStrategy")]);
    m_unauthorized_cache_control_header_strategy_isSet = !json[QString("unauthorizedCacheControlHeaderStrategy")].isNull() && m_unauthorized_cache_control_header_strategy_isValid;
}

QString OAIMethodSetting::asJson() const {
    QJsonObject obj = this->asJsonObject();
    QJsonDocument doc(obj);
    QByteArray bytes = doc.toJson();
    return QString(bytes);
}

QJsonObject OAIMethodSetting::asJsonObject() const {
    QJsonObject obj;
    if (m_metrics_enabled_isSet) {
        obj.insert(QString("metricsEnabled"), ::OpenAPI::toJsonValue(m_metrics_enabled));
    }
    if (m_logging_level_isSet) {
        obj.insert(QString("loggingLevel"), ::OpenAPI::toJsonValue(m_logging_level));
    }
    if (m_data_trace_enabled_isSet) {
        obj.insert(QString("dataTraceEnabled"), ::OpenAPI::toJsonValue(m_data_trace_enabled));
    }
    if (m_throttling_burst_limit_isSet) {
        obj.insert(QString("throttlingBurstLimit"), ::OpenAPI::toJsonValue(m_throttling_burst_limit));
    }
    if (m_throttling_rate_limit_isSet) {
        obj.insert(QString("throttlingRateLimit"), ::OpenAPI::toJsonValue(m_throttling_rate_limit));
    }
    if (m_caching_enabled_isSet) {
        obj.insert(QString("cachingEnabled"), ::OpenAPI::toJsonValue(m_caching_enabled));
    }
    if (m_cache_ttl_in_seconds_isSet) {
        obj.insert(QString("cacheTtlInSeconds"), ::OpenAPI::toJsonValue(m_cache_ttl_in_seconds));
    }
    if (m_cache_data_encrypted_isSet) {
        obj.insert(QString("cacheDataEncrypted"), ::OpenAPI::toJsonValue(m_cache_data_encrypted));
    }
    if (m_require_authorization_for_cache_control_isSet) {
        obj.insert(QString("requireAuthorizationForCacheControl"), ::OpenAPI::toJsonValue(m_require_authorization_for_cache_control));
    }
    if (m_unauthorized_cache_control_header_strategy.isSet()) {
        obj.insert(QString("unauthorizedCacheControlHeaderStrategy"), ::OpenAPI::toJsonValue(m_unauthorized_cache_control_header_strategy));
    }
    return obj;
}

bool OAIMethodSetting::getMetricsEnabled() const {
    return m_metrics_enabled;
}
void OAIMethodSetting::setMetricsEnabled(const bool &metrics_enabled) {
    m_metrics_enabled = metrics_enabled;
    m_metrics_enabled_isSet = true;
}

bool OAIMethodSetting::is_metrics_enabled_Set() const{
    return m_metrics_enabled_isSet;
}

bool OAIMethodSetting::is_metrics_enabled_Valid() const{
    return m_metrics_enabled_isValid;
}

QString OAIMethodSetting::getLoggingLevel() const {
    return m_logging_level;
}
void OAIMethodSetting::setLoggingLevel(const QString &logging_level) {
    m_logging_level = logging_level;
    m_logging_level_isSet = true;
}

bool OAIMethodSetting::is_logging_level_Set() const{
    return m_logging_level_isSet;
}

bool OAIMethodSetting::is_logging_level_Valid() const{
    return m_logging_level_isValid;
}

bool OAIMethodSetting::getDataTraceEnabled() const {
    return m_data_trace_enabled;
}
void OAIMethodSetting::setDataTraceEnabled(const bool &data_trace_enabled) {
    m_data_trace_enabled = data_trace_enabled;
    m_data_trace_enabled_isSet = true;
}

bool OAIMethodSetting::is_data_trace_enabled_Set() const{
    return m_data_trace_enabled_isSet;
}

bool OAIMethodSetting::is_data_trace_enabled_Valid() const{
    return m_data_trace_enabled_isValid;
}

qint32 OAIMethodSetting::getThrottlingBurstLimit() const {
    return m_throttling_burst_limit;
}
void OAIMethodSetting::setThrottlingBurstLimit(const qint32 &throttling_burst_limit) {
    m_throttling_burst_limit = throttling_burst_limit;
    m_throttling_burst_limit_isSet = true;
}

bool OAIMethodSetting::is_throttling_burst_limit_Set() const{
    return m_throttling_burst_limit_isSet;
}

bool OAIMethodSetting::is_throttling_burst_limit_Valid() const{
    return m_throttling_burst_limit_isValid;
}

double OAIMethodSetting::getThrottlingRateLimit() const {
    return m_throttling_rate_limit;
}
void OAIMethodSetting::setThrottlingRateLimit(const double &throttling_rate_limit) {
    m_throttling_rate_limit = throttling_rate_limit;
    m_throttling_rate_limit_isSet = true;
}

bool OAIMethodSetting::is_throttling_rate_limit_Set() const{
    return m_throttling_rate_limit_isSet;
}

bool OAIMethodSetting::is_throttling_rate_limit_Valid() const{
    return m_throttling_rate_limit_isValid;
}

bool OAIMethodSetting::getCachingEnabled() const {
    return m_caching_enabled;
}
void OAIMethodSetting::setCachingEnabled(const bool &caching_enabled) {
    m_caching_enabled = caching_enabled;
    m_caching_enabled_isSet = true;
}

bool OAIMethodSetting::is_caching_enabled_Set() const{
    return m_caching_enabled_isSet;
}

bool OAIMethodSetting::is_caching_enabled_Valid() const{
    return m_caching_enabled_isValid;
}

qint32 OAIMethodSetting::getCacheTtlInSeconds() const {
    return m_cache_ttl_in_seconds;
}
void OAIMethodSetting::setCacheTtlInSeconds(const qint32 &cache_ttl_in_seconds) {
    m_cache_ttl_in_seconds = cache_ttl_in_seconds;
    m_cache_ttl_in_seconds_isSet = true;
}

bool OAIMethodSetting::is_cache_ttl_in_seconds_Set() const{
    return m_cache_ttl_in_seconds_isSet;
}

bool OAIMethodSetting::is_cache_ttl_in_seconds_Valid() const{
    return m_cache_ttl_in_seconds_isValid;
}

bool OAIMethodSetting::getCacheDataEncrypted() const {
    return m_cache_data_encrypted;
}
void OAIMethodSetting::setCacheDataEncrypted(const bool &cache_data_encrypted) {
    m_cache_data_encrypted = cache_data_encrypted;
    m_cache_data_encrypted_isSet = true;
}

bool OAIMethodSetting::is_cache_data_encrypted_Set() const{
    return m_cache_data_encrypted_isSet;
}

bool OAIMethodSetting::is_cache_data_encrypted_Valid() const{
    return m_cache_data_encrypted_isValid;
}

bool OAIMethodSetting::getRequireAuthorizationForCacheControl() const {
    return m_require_authorization_for_cache_control;
}
void OAIMethodSetting::setRequireAuthorizationForCacheControl(const bool &require_authorization_for_cache_control) {
    m_require_authorization_for_cache_control = require_authorization_for_cache_control;
    m_require_authorization_for_cache_control_isSet = true;
}

bool OAIMethodSetting::is_require_authorization_for_cache_control_Set() const{
    return m_require_authorization_for_cache_control_isSet;
}

bool OAIMethodSetting::is_require_authorization_for_cache_control_Valid() const{
    return m_require_authorization_for_cache_control_isValid;
}

OAIUnauthorizedCacheControlHeaderStrategy OAIMethodSetting::getUnauthorizedCacheControlHeaderStrategy() const {
    return m_unauthorized_cache_control_header_strategy;
}
void OAIMethodSetting::setUnauthorizedCacheControlHeaderStrategy(const OAIUnauthorizedCacheControlHeaderStrategy &unauthorized_cache_control_header_strategy) {
    m_unauthorized_cache_control_header_strategy = unauthorized_cache_control_header_strategy;
    m_unauthorized_cache_control_header_strategy_isSet = true;
}

bool OAIMethodSetting::is_unauthorized_cache_control_header_strategy_Set() const{
    return m_unauthorized_cache_control_header_strategy_isSet;
}

bool OAIMethodSetting::is_unauthorized_cache_control_header_strategy_Valid() const{
    return m_unauthorized_cache_control_header_strategy_isValid;
}

bool OAIMethodSetting::isSet() const {
    bool isObjectUpdated = false;
    do {
        if (m_metrics_enabled_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_logging_level_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_data_trace_enabled_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_throttling_burst_limit_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_throttling_rate_limit_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_caching_enabled_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_cache_ttl_in_seconds_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_cache_data_encrypted_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_require_authorization_for_cache_control_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_unauthorized_cache_control_header_strategy.isSet()) {
            isObjectUpdated = true;
            break;
        }
    } while (false);
    return isObjectUpdated;
}

bool OAIMethodSetting::isValid() const {
    // only required properties are required for the object to be considered valid
    return true;
}

} // namespace OpenAPI
