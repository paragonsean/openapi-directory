/**
 * Amazon QuickSight
 * <fullname>Amazon QuickSight API Reference</fullname> <p>Amazon QuickSight is a fully managed, serverless business intelligence service for the Amazon Web Services Cloud that makes it easy to extend data and insights to every user in your organization. This API reference contains documentation for a programming interface that you can use to manage Amazon QuickSight. </p>
 *
 * The version of the OpenAPI document: 2018-04-01
 * Contact: mike.ralphson@gmail.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

#include "OAIIngestion.h"

#include <QDebug>
#include <QJsonArray>
#include <QJsonDocument>
#include <QObject>

#include "OAIHelpers.h"

namespace OpenAPI {

OAIIngestion::OAIIngestion(QString json) {
    this->initializeModel();
    this->fromJson(json);
}

OAIIngestion::OAIIngestion() {
    this->initializeModel();
}

OAIIngestion::~OAIIngestion() {}

void OAIIngestion::initializeModel() {

    m_arn_isSet = false;
    m_arn_isValid = false;

    m_ingestion_id_isSet = false;
    m_ingestion_id_isValid = false;

    m_ingestion_status_isSet = false;
    m_ingestion_status_isValid = false;

    m_error_info_isSet = false;
    m_error_info_isValid = false;

    m_row_info_isSet = false;
    m_row_info_isValid = false;

    m_queue_info_isSet = false;
    m_queue_info_isValid = false;

    m_created_time_isSet = false;
    m_created_time_isValid = false;

    m_ingestion_time_in_seconds_isSet = false;
    m_ingestion_time_in_seconds_isValid = false;

    m_ingestion_size_in_bytes_isSet = false;
    m_ingestion_size_in_bytes_isValid = false;

    m_request_source_isSet = false;
    m_request_source_isValid = false;

    m_request_type_isSet = false;
    m_request_type_isValid = false;
}

void OAIIngestion::fromJson(QString jsonString) {
    QByteArray array(jsonString.toStdString().c_str());
    QJsonDocument doc = QJsonDocument::fromJson(array);
    QJsonObject jsonObject = doc.object();
    this->fromJsonObject(jsonObject);
}

void OAIIngestion::fromJsonObject(QJsonObject json) {

    m_arn_isValid = ::OpenAPI::fromJsonValue(m_arn, json[QString("Arn")]);
    m_arn_isSet = !json[QString("Arn")].isNull() && m_arn_isValid;

    m_ingestion_id_isValid = ::OpenAPI::fromJsonValue(m_ingestion_id, json[QString("IngestionId")]);
    m_ingestion_id_isSet = !json[QString("IngestionId")].isNull() && m_ingestion_id_isValid;

    m_ingestion_status_isValid = ::OpenAPI::fromJsonValue(m_ingestion_status, json[QString("IngestionStatus")]);
    m_ingestion_status_isSet = !json[QString("IngestionStatus")].isNull() && m_ingestion_status_isValid;

    m_error_info_isValid = ::OpenAPI::fromJsonValue(m_error_info, json[QString("ErrorInfo")]);
    m_error_info_isSet = !json[QString("ErrorInfo")].isNull() && m_error_info_isValid;

    m_row_info_isValid = ::OpenAPI::fromJsonValue(m_row_info, json[QString("RowInfo")]);
    m_row_info_isSet = !json[QString("RowInfo")].isNull() && m_row_info_isValid;

    m_queue_info_isValid = ::OpenAPI::fromJsonValue(m_queue_info, json[QString("QueueInfo")]);
    m_queue_info_isSet = !json[QString("QueueInfo")].isNull() && m_queue_info_isValid;

    m_created_time_isValid = ::OpenAPI::fromJsonValue(m_created_time, json[QString("CreatedTime")]);
    m_created_time_isSet = !json[QString("CreatedTime")].isNull() && m_created_time_isValid;

    m_ingestion_time_in_seconds_isValid = ::OpenAPI::fromJsonValue(m_ingestion_time_in_seconds, json[QString("IngestionTimeInSeconds")]);
    m_ingestion_time_in_seconds_isSet = !json[QString("IngestionTimeInSeconds")].isNull() && m_ingestion_time_in_seconds_isValid;

    m_ingestion_size_in_bytes_isValid = ::OpenAPI::fromJsonValue(m_ingestion_size_in_bytes, json[QString("IngestionSizeInBytes")]);
    m_ingestion_size_in_bytes_isSet = !json[QString("IngestionSizeInBytes")].isNull() && m_ingestion_size_in_bytes_isValid;

    m_request_source_isValid = ::OpenAPI::fromJsonValue(m_request_source, json[QString("RequestSource")]);
    m_request_source_isSet = !json[QString("RequestSource")].isNull() && m_request_source_isValid;

    m_request_type_isValid = ::OpenAPI::fromJsonValue(m_request_type, json[QString("RequestType")]);
    m_request_type_isSet = !json[QString("RequestType")].isNull() && m_request_type_isValid;
}

QString OAIIngestion::asJson() const {
    QJsonObject obj = this->asJsonObject();
    QJsonDocument doc(obj);
    QByteArray bytes = doc.toJson();
    return QString(bytes);
}

QJsonObject OAIIngestion::asJsonObject() const {
    QJsonObject obj;
    if (m_arn_isSet) {
        obj.insert(QString("Arn"), ::OpenAPI::toJsonValue(m_arn));
    }
    if (m_ingestion_id_isSet) {
        obj.insert(QString("IngestionId"), ::OpenAPI::toJsonValue(m_ingestion_id));
    }
    if (m_ingestion_status.isSet()) {
        obj.insert(QString("IngestionStatus"), ::OpenAPI::toJsonValue(m_ingestion_status));
    }
    if (m_error_info.isSet()) {
        obj.insert(QString("ErrorInfo"), ::OpenAPI::toJsonValue(m_error_info));
    }
    if (m_row_info.isSet()) {
        obj.insert(QString("RowInfo"), ::OpenAPI::toJsonValue(m_row_info));
    }
    if (m_queue_info.isSet()) {
        obj.insert(QString("QueueInfo"), ::OpenAPI::toJsonValue(m_queue_info));
    }
    if (m_created_time_isSet) {
        obj.insert(QString("CreatedTime"), ::OpenAPI::toJsonValue(m_created_time));
    }
    if (m_ingestion_time_in_seconds_isSet) {
        obj.insert(QString("IngestionTimeInSeconds"), ::OpenAPI::toJsonValue(m_ingestion_time_in_seconds));
    }
    if (m_ingestion_size_in_bytes_isSet) {
        obj.insert(QString("IngestionSizeInBytes"), ::OpenAPI::toJsonValue(m_ingestion_size_in_bytes));
    }
    if (m_request_source.isSet()) {
        obj.insert(QString("RequestSource"), ::OpenAPI::toJsonValue(m_request_source));
    }
    if (m_request_type.isSet()) {
        obj.insert(QString("RequestType"), ::OpenAPI::toJsonValue(m_request_type));
    }
    return obj;
}

QString OAIIngestion::getArn() const {
    return m_arn;
}
void OAIIngestion::setArn(const QString &arn) {
    m_arn = arn;
    m_arn_isSet = true;
}

bool OAIIngestion::is_arn_Set() const{
    return m_arn_isSet;
}

bool OAIIngestion::is_arn_Valid() const{
    return m_arn_isValid;
}

QString OAIIngestion::getIngestionId() const {
    return m_ingestion_id;
}
void OAIIngestion::setIngestionId(const QString &ingestion_id) {
    m_ingestion_id = ingestion_id;
    m_ingestion_id_isSet = true;
}

bool OAIIngestion::is_ingestion_id_Set() const{
    return m_ingestion_id_isSet;
}

bool OAIIngestion::is_ingestion_id_Valid() const{
    return m_ingestion_id_isValid;
}

OAIIngestionStatus OAIIngestion::getIngestionStatus() const {
    return m_ingestion_status;
}
void OAIIngestion::setIngestionStatus(const OAIIngestionStatus &ingestion_status) {
    m_ingestion_status = ingestion_status;
    m_ingestion_status_isSet = true;
}

bool OAIIngestion::is_ingestion_status_Set() const{
    return m_ingestion_status_isSet;
}

bool OAIIngestion::is_ingestion_status_Valid() const{
    return m_ingestion_status_isValid;
}

OAIIngestion_ErrorInfo OAIIngestion::getErrorInfo() const {
    return m_error_info;
}
void OAIIngestion::setErrorInfo(const OAIIngestion_ErrorInfo &error_info) {
    m_error_info = error_info;
    m_error_info_isSet = true;
}

bool OAIIngestion::is_error_info_Set() const{
    return m_error_info_isSet;
}

bool OAIIngestion::is_error_info_Valid() const{
    return m_error_info_isValid;
}

OAIRowInfo OAIIngestion::getRowInfo() const {
    return m_row_info;
}
void OAIIngestion::setRowInfo(const OAIRowInfo &row_info) {
    m_row_info = row_info;
    m_row_info_isSet = true;
}

bool OAIIngestion::is_row_info_Set() const{
    return m_row_info_isSet;
}

bool OAIIngestion::is_row_info_Valid() const{
    return m_row_info_isValid;
}

OAIQueueInfo OAIIngestion::getQueueInfo() const {
    return m_queue_info;
}
void OAIIngestion::setQueueInfo(const OAIQueueInfo &queue_info) {
    m_queue_info = queue_info;
    m_queue_info_isSet = true;
}

bool OAIIngestion::is_queue_info_Set() const{
    return m_queue_info_isSet;
}

bool OAIIngestion::is_queue_info_Valid() const{
    return m_queue_info_isValid;
}

QDateTime OAIIngestion::getCreatedTime() const {
    return m_created_time;
}
void OAIIngestion::setCreatedTime(const QDateTime &created_time) {
    m_created_time = created_time;
    m_created_time_isSet = true;
}

bool OAIIngestion::is_created_time_Set() const{
    return m_created_time_isSet;
}

bool OAIIngestion::is_created_time_Valid() const{
    return m_created_time_isValid;
}

qint32 OAIIngestion::getIngestionTimeInSeconds() const {
    return m_ingestion_time_in_seconds;
}
void OAIIngestion::setIngestionTimeInSeconds(const qint32 &ingestion_time_in_seconds) {
    m_ingestion_time_in_seconds = ingestion_time_in_seconds;
    m_ingestion_time_in_seconds_isSet = true;
}

bool OAIIngestion::is_ingestion_time_in_seconds_Set() const{
    return m_ingestion_time_in_seconds_isSet;
}

bool OAIIngestion::is_ingestion_time_in_seconds_Valid() const{
    return m_ingestion_time_in_seconds_isValid;
}

qint32 OAIIngestion::getIngestionSizeInBytes() const {
    return m_ingestion_size_in_bytes;
}
void OAIIngestion::setIngestionSizeInBytes(const qint32 &ingestion_size_in_bytes) {
    m_ingestion_size_in_bytes = ingestion_size_in_bytes;
    m_ingestion_size_in_bytes_isSet = true;
}

bool OAIIngestion::is_ingestion_size_in_bytes_Set() const{
    return m_ingestion_size_in_bytes_isSet;
}

bool OAIIngestion::is_ingestion_size_in_bytes_Valid() const{
    return m_ingestion_size_in_bytes_isValid;
}

OAIIngestionRequestSource OAIIngestion::getRequestSource() const {
    return m_request_source;
}
void OAIIngestion::setRequestSource(const OAIIngestionRequestSource &request_source) {
    m_request_source = request_source;
    m_request_source_isSet = true;
}

bool OAIIngestion::is_request_source_Set() const{
    return m_request_source_isSet;
}

bool OAIIngestion::is_request_source_Valid() const{
    return m_request_source_isValid;
}

OAIIngestionRequestType OAIIngestion::getRequestType() const {
    return m_request_type;
}
void OAIIngestion::setRequestType(const OAIIngestionRequestType &request_type) {
    m_request_type = request_type;
    m_request_type_isSet = true;
}

bool OAIIngestion::is_request_type_Set() const{
    return m_request_type_isSet;
}

bool OAIIngestion::is_request_type_Valid() const{
    return m_request_type_isValid;
}

bool OAIIngestion::isSet() const {
    bool isObjectUpdated = false;
    do {
        if (m_arn_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_ingestion_id_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_ingestion_status.isSet()) {
            isObjectUpdated = true;
            break;
        }

        if (m_error_info.isSet()) {
            isObjectUpdated = true;
            break;
        }

        if (m_row_info.isSet()) {
            isObjectUpdated = true;
            break;
        }

        if (m_queue_info.isSet()) {
            isObjectUpdated = true;
            break;
        }

        if (m_created_time_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_ingestion_time_in_seconds_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_ingestion_size_in_bytes_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_request_source.isSet()) {
            isObjectUpdated = true;
            break;
        }

        if (m_request_type.isSet()) {
            isObjectUpdated = true;
            break;
        }
    } while (false);
    return isObjectUpdated;
}

bool OAIIngestion::isValid() const {
    // only required properties are required for the object to be considered valid
    return m_arn_isValid && m_ingestion_status_isValid && m_created_time_isValid && true;
}

} // namespace OpenAPI
