/**
 * Amazon QuickSight
 * <fullname>Amazon QuickSight API Reference</fullname> <p>Amazon QuickSight is a fully managed, serverless business intelligence service for the Amazon Web Services Cloud that makes it easy to extend data and insights to every user in your organization. This API reference contains documentation for a programming interface that you can use to manage Amazon QuickSight. </p>
 *
 * The version of the OpenAPI document: 2018-04-01
 * Contact: mike.ralphson@gmail.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

#include "OAIComputation.h"

#include <QDebug>
#include <QJsonArray>
#include <QJsonDocument>
#include <QObject>

#include "OAIHelpers.h"

namespace OpenAPI {

OAIComputation::OAIComputation(QString json) {
    this->initializeModel();
    this->fromJson(json);
}

OAIComputation::OAIComputation() {
    this->initializeModel();
}

OAIComputation::~OAIComputation() {}

void OAIComputation::initializeModel() {

    m_top_bottom_ranked_isSet = false;
    m_top_bottom_ranked_isValid = false;

    m_top_bottom_movers_isSet = false;
    m_top_bottom_movers_isValid = false;

    m_total_aggregation_isSet = false;
    m_total_aggregation_isValid = false;

    m_maximum_minimum_isSet = false;
    m_maximum_minimum_isValid = false;

    m_metric_comparison_isSet = false;
    m_metric_comparison_isValid = false;

    m_period_over_period_isSet = false;
    m_period_over_period_isValid = false;

    m_period_to_date_isSet = false;
    m_period_to_date_isValid = false;

    m_growth_rate_isSet = false;
    m_growth_rate_isValid = false;

    m_unique_values_isSet = false;
    m_unique_values_isValid = false;

    m_forecast_isSet = false;
    m_forecast_isValid = false;
}

void OAIComputation::fromJson(QString jsonString) {
    QByteArray array(jsonString.toStdString().c_str());
    QJsonDocument doc = QJsonDocument::fromJson(array);
    QJsonObject jsonObject = doc.object();
    this->fromJsonObject(jsonObject);
}

void OAIComputation::fromJsonObject(QJsonObject json) {

    m_top_bottom_ranked_isValid = ::OpenAPI::fromJsonValue(m_top_bottom_ranked, json[QString("TopBottomRanked")]);
    m_top_bottom_ranked_isSet = !json[QString("TopBottomRanked")].isNull() && m_top_bottom_ranked_isValid;

    m_top_bottom_movers_isValid = ::OpenAPI::fromJsonValue(m_top_bottom_movers, json[QString("TopBottomMovers")]);
    m_top_bottom_movers_isSet = !json[QString("TopBottomMovers")].isNull() && m_top_bottom_movers_isValid;

    m_total_aggregation_isValid = ::OpenAPI::fromJsonValue(m_total_aggregation, json[QString("TotalAggregation")]);
    m_total_aggregation_isSet = !json[QString("TotalAggregation")].isNull() && m_total_aggregation_isValid;

    m_maximum_minimum_isValid = ::OpenAPI::fromJsonValue(m_maximum_minimum, json[QString("MaximumMinimum")]);
    m_maximum_minimum_isSet = !json[QString("MaximumMinimum")].isNull() && m_maximum_minimum_isValid;

    m_metric_comparison_isValid = ::OpenAPI::fromJsonValue(m_metric_comparison, json[QString("MetricComparison")]);
    m_metric_comparison_isSet = !json[QString("MetricComparison")].isNull() && m_metric_comparison_isValid;

    m_period_over_period_isValid = ::OpenAPI::fromJsonValue(m_period_over_period, json[QString("PeriodOverPeriod")]);
    m_period_over_period_isSet = !json[QString("PeriodOverPeriod")].isNull() && m_period_over_period_isValid;

    m_period_to_date_isValid = ::OpenAPI::fromJsonValue(m_period_to_date, json[QString("PeriodToDate")]);
    m_period_to_date_isSet = !json[QString("PeriodToDate")].isNull() && m_period_to_date_isValid;

    m_growth_rate_isValid = ::OpenAPI::fromJsonValue(m_growth_rate, json[QString("GrowthRate")]);
    m_growth_rate_isSet = !json[QString("GrowthRate")].isNull() && m_growth_rate_isValid;

    m_unique_values_isValid = ::OpenAPI::fromJsonValue(m_unique_values, json[QString("UniqueValues")]);
    m_unique_values_isSet = !json[QString("UniqueValues")].isNull() && m_unique_values_isValid;

    m_forecast_isValid = ::OpenAPI::fromJsonValue(m_forecast, json[QString("Forecast")]);
    m_forecast_isSet = !json[QString("Forecast")].isNull() && m_forecast_isValid;
}

QString OAIComputation::asJson() const {
    QJsonObject obj = this->asJsonObject();
    QJsonDocument doc(obj);
    QByteArray bytes = doc.toJson();
    return QString(bytes);
}

QJsonObject OAIComputation::asJsonObject() const {
    QJsonObject obj;
    if (m_top_bottom_ranked.isSet()) {
        obj.insert(QString("TopBottomRanked"), ::OpenAPI::toJsonValue(m_top_bottom_ranked));
    }
    if (m_top_bottom_movers.isSet()) {
        obj.insert(QString("TopBottomMovers"), ::OpenAPI::toJsonValue(m_top_bottom_movers));
    }
    if (m_total_aggregation.isSet()) {
        obj.insert(QString("TotalAggregation"), ::OpenAPI::toJsonValue(m_total_aggregation));
    }
    if (m_maximum_minimum.isSet()) {
        obj.insert(QString("MaximumMinimum"), ::OpenAPI::toJsonValue(m_maximum_minimum));
    }
    if (m_metric_comparison.isSet()) {
        obj.insert(QString("MetricComparison"), ::OpenAPI::toJsonValue(m_metric_comparison));
    }
    if (m_period_over_period.isSet()) {
        obj.insert(QString("PeriodOverPeriod"), ::OpenAPI::toJsonValue(m_period_over_period));
    }
    if (m_period_to_date.isSet()) {
        obj.insert(QString("PeriodToDate"), ::OpenAPI::toJsonValue(m_period_to_date));
    }
    if (m_growth_rate.isSet()) {
        obj.insert(QString("GrowthRate"), ::OpenAPI::toJsonValue(m_growth_rate));
    }
    if (m_unique_values.isSet()) {
        obj.insert(QString("UniqueValues"), ::OpenAPI::toJsonValue(m_unique_values));
    }
    if (m_forecast.isSet()) {
        obj.insert(QString("Forecast"), ::OpenAPI::toJsonValue(m_forecast));
    }
    return obj;
}

OAIComputation_TopBottomRanked OAIComputation::getTopBottomRanked() const {
    return m_top_bottom_ranked;
}
void OAIComputation::setTopBottomRanked(const OAIComputation_TopBottomRanked &top_bottom_ranked) {
    m_top_bottom_ranked = top_bottom_ranked;
    m_top_bottom_ranked_isSet = true;
}

bool OAIComputation::is_top_bottom_ranked_Set() const{
    return m_top_bottom_ranked_isSet;
}

bool OAIComputation::is_top_bottom_ranked_Valid() const{
    return m_top_bottom_ranked_isValid;
}

OAIComputation_TopBottomMovers OAIComputation::getTopBottomMovers() const {
    return m_top_bottom_movers;
}
void OAIComputation::setTopBottomMovers(const OAIComputation_TopBottomMovers &top_bottom_movers) {
    m_top_bottom_movers = top_bottom_movers;
    m_top_bottom_movers_isSet = true;
}

bool OAIComputation::is_top_bottom_movers_Set() const{
    return m_top_bottom_movers_isSet;
}

bool OAIComputation::is_top_bottom_movers_Valid() const{
    return m_top_bottom_movers_isValid;
}

OAIComputation_TotalAggregation OAIComputation::getTotalAggregation() const {
    return m_total_aggregation;
}
void OAIComputation::setTotalAggregation(const OAIComputation_TotalAggregation &total_aggregation) {
    m_total_aggregation = total_aggregation;
    m_total_aggregation_isSet = true;
}

bool OAIComputation::is_total_aggregation_Set() const{
    return m_total_aggregation_isSet;
}

bool OAIComputation::is_total_aggregation_Valid() const{
    return m_total_aggregation_isValid;
}

OAIComputation_MaximumMinimum OAIComputation::getMaximumMinimum() const {
    return m_maximum_minimum;
}
void OAIComputation::setMaximumMinimum(const OAIComputation_MaximumMinimum &maximum_minimum) {
    m_maximum_minimum = maximum_minimum;
    m_maximum_minimum_isSet = true;
}

bool OAIComputation::is_maximum_minimum_Set() const{
    return m_maximum_minimum_isSet;
}

bool OAIComputation::is_maximum_minimum_Valid() const{
    return m_maximum_minimum_isValid;
}

OAIComputation_MetricComparison OAIComputation::getMetricComparison() const {
    return m_metric_comparison;
}
void OAIComputation::setMetricComparison(const OAIComputation_MetricComparison &metric_comparison) {
    m_metric_comparison = metric_comparison;
    m_metric_comparison_isSet = true;
}

bool OAIComputation::is_metric_comparison_Set() const{
    return m_metric_comparison_isSet;
}

bool OAIComputation::is_metric_comparison_Valid() const{
    return m_metric_comparison_isValid;
}

OAIComputation_PeriodOverPeriod OAIComputation::getPeriodOverPeriod() const {
    return m_period_over_period;
}
void OAIComputation::setPeriodOverPeriod(const OAIComputation_PeriodOverPeriod &period_over_period) {
    m_period_over_period = period_over_period;
    m_period_over_period_isSet = true;
}

bool OAIComputation::is_period_over_period_Set() const{
    return m_period_over_period_isSet;
}

bool OAIComputation::is_period_over_period_Valid() const{
    return m_period_over_period_isValid;
}

OAIComputation_PeriodToDate OAIComputation::getPeriodToDate() const {
    return m_period_to_date;
}
void OAIComputation::setPeriodToDate(const OAIComputation_PeriodToDate &period_to_date) {
    m_period_to_date = period_to_date;
    m_period_to_date_isSet = true;
}

bool OAIComputation::is_period_to_date_Set() const{
    return m_period_to_date_isSet;
}

bool OAIComputation::is_period_to_date_Valid() const{
    return m_period_to_date_isValid;
}

OAIComputation_GrowthRate OAIComputation::getGrowthRate() const {
    return m_growth_rate;
}
void OAIComputation::setGrowthRate(const OAIComputation_GrowthRate &growth_rate) {
    m_growth_rate = growth_rate;
    m_growth_rate_isSet = true;
}

bool OAIComputation::is_growth_rate_Set() const{
    return m_growth_rate_isSet;
}

bool OAIComputation::is_growth_rate_Valid() const{
    return m_growth_rate_isValid;
}

OAIComputation_UniqueValues OAIComputation::getUniqueValues() const {
    return m_unique_values;
}
void OAIComputation::setUniqueValues(const OAIComputation_UniqueValues &unique_values) {
    m_unique_values = unique_values;
    m_unique_values_isSet = true;
}

bool OAIComputation::is_unique_values_Set() const{
    return m_unique_values_isSet;
}

bool OAIComputation::is_unique_values_Valid() const{
    return m_unique_values_isValid;
}

OAIComputation_Forecast OAIComputation::getForecast() const {
    return m_forecast;
}
void OAIComputation::setForecast(const OAIComputation_Forecast &forecast) {
    m_forecast = forecast;
    m_forecast_isSet = true;
}

bool OAIComputation::is_forecast_Set() const{
    return m_forecast_isSet;
}

bool OAIComputation::is_forecast_Valid() const{
    return m_forecast_isValid;
}

bool OAIComputation::isSet() const {
    bool isObjectUpdated = false;
    do {
        if (m_top_bottom_ranked.isSet()) {
            isObjectUpdated = true;
            break;
        }

        if (m_top_bottom_movers.isSet()) {
            isObjectUpdated = true;
            break;
        }

        if (m_total_aggregation.isSet()) {
            isObjectUpdated = true;
            break;
        }

        if (m_maximum_minimum.isSet()) {
            isObjectUpdated = true;
            break;
        }

        if (m_metric_comparison.isSet()) {
            isObjectUpdated = true;
            break;
        }

        if (m_period_over_period.isSet()) {
            isObjectUpdated = true;
            break;
        }

        if (m_period_to_date.isSet()) {
            isObjectUpdated = true;
            break;
        }

        if (m_growth_rate.isSet()) {
            isObjectUpdated = true;
            break;
        }

        if (m_unique_values.isSet()) {
            isObjectUpdated = true;
            break;
        }

        if (m_forecast.isSet()) {
            isObjectUpdated = true;
            break;
        }
    } while (false);
    return isObjectUpdated;
}

bool OAIComputation::isValid() const {
    // only required properties are required for the object to be considered valid
    return true;
}

} // namespace OpenAPI
