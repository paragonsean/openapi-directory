/**
 * Amazon QuickSight
 * <fullname>Amazon QuickSight API Reference</fullname> <p>Amazon QuickSight is a fully managed, serverless business intelligence service for the Amazon Web Services Cloud that makes it easy to extend data and insights to every user in your organization. This API reference contains documentation for a programming interface that you can use to manage Amazon QuickSight. </p>
 *
 * The version of the OpenAPI document: 2018-04-01
 * Contact: mike.ralphson@gmail.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

#include "OAITopicColumn.h"

#include <QDebug>
#include <QJsonArray>
#include <QJsonDocument>
#include <QObject>

#include "OAIHelpers.h"

namespace OpenAPI {

OAITopicColumn::OAITopicColumn(QString json) {
    this->initializeModel();
    this->fromJson(json);
}

OAITopicColumn::OAITopicColumn() {
    this->initializeModel();
}

OAITopicColumn::~OAITopicColumn() {}

void OAITopicColumn::initializeModel() {

    m_column_name_isSet = false;
    m_column_name_isValid = false;

    m_column_friendly_name_isSet = false;
    m_column_friendly_name_isValid = false;

    m_column_description_isSet = false;
    m_column_description_isValid = false;

    m_column_synonyms_isSet = false;
    m_column_synonyms_isValid = false;

    m_column_data_role_isSet = false;
    m_column_data_role_isValid = false;

    m_aggregation_isSet = false;
    m_aggregation_isValid = false;

    m_is_included_in_topic_isSet = false;
    m_is_included_in_topic_isValid = false;

    m_disable_indexing_isSet = false;
    m_disable_indexing_isValid = false;

    m_comparative_order_isSet = false;
    m_comparative_order_isValid = false;

    m_semantic_type_isSet = false;
    m_semantic_type_isValid = false;

    m_time_granularity_isSet = false;
    m_time_granularity_isValid = false;

    m_allowed_aggregations_isSet = false;
    m_allowed_aggregations_isValid = false;

    m_not_allowed_aggregations_isSet = false;
    m_not_allowed_aggregations_isValid = false;

    m_default_formatting_isSet = false;
    m_default_formatting_isValid = false;

    m_never_aggregate_in_filter_isSet = false;
    m_never_aggregate_in_filter_isValid = false;

    m_cell_value_synonyms_isSet = false;
    m_cell_value_synonyms_isValid = false;
}

void OAITopicColumn::fromJson(QString jsonString) {
    QByteArray array(jsonString.toStdString().c_str());
    QJsonDocument doc = QJsonDocument::fromJson(array);
    QJsonObject jsonObject = doc.object();
    this->fromJsonObject(jsonObject);
}

void OAITopicColumn::fromJsonObject(QJsonObject json) {

    m_column_name_isValid = ::OpenAPI::fromJsonValue(m_column_name, json[QString("ColumnName")]);
    m_column_name_isSet = !json[QString("ColumnName")].isNull() && m_column_name_isValid;

    m_column_friendly_name_isValid = ::OpenAPI::fromJsonValue(m_column_friendly_name, json[QString("ColumnFriendlyName")]);
    m_column_friendly_name_isSet = !json[QString("ColumnFriendlyName")].isNull() && m_column_friendly_name_isValid;

    m_column_description_isValid = ::OpenAPI::fromJsonValue(m_column_description, json[QString("ColumnDescription")]);
    m_column_description_isSet = !json[QString("ColumnDescription")].isNull() && m_column_description_isValid;

    m_column_synonyms_isValid = ::OpenAPI::fromJsonValue(m_column_synonyms, json[QString("ColumnSynonyms")]);
    m_column_synonyms_isSet = !json[QString("ColumnSynonyms")].isNull() && m_column_synonyms_isValid;

    m_column_data_role_isValid = ::OpenAPI::fromJsonValue(m_column_data_role, json[QString("ColumnDataRole")]);
    m_column_data_role_isSet = !json[QString("ColumnDataRole")].isNull() && m_column_data_role_isValid;

    m_aggregation_isValid = ::OpenAPI::fromJsonValue(m_aggregation, json[QString("Aggregation")]);
    m_aggregation_isSet = !json[QString("Aggregation")].isNull() && m_aggregation_isValid;

    m_is_included_in_topic_isValid = ::OpenAPI::fromJsonValue(m_is_included_in_topic, json[QString("IsIncludedInTopic")]);
    m_is_included_in_topic_isSet = !json[QString("IsIncludedInTopic")].isNull() && m_is_included_in_topic_isValid;

    m_disable_indexing_isValid = ::OpenAPI::fromJsonValue(m_disable_indexing, json[QString("DisableIndexing")]);
    m_disable_indexing_isSet = !json[QString("DisableIndexing")].isNull() && m_disable_indexing_isValid;

    m_comparative_order_isValid = ::OpenAPI::fromJsonValue(m_comparative_order, json[QString("ComparativeOrder")]);
    m_comparative_order_isSet = !json[QString("ComparativeOrder")].isNull() && m_comparative_order_isValid;

    m_semantic_type_isValid = ::OpenAPI::fromJsonValue(m_semantic_type, json[QString("SemanticType")]);
    m_semantic_type_isSet = !json[QString("SemanticType")].isNull() && m_semantic_type_isValid;

    m_time_granularity_isValid = ::OpenAPI::fromJsonValue(m_time_granularity, json[QString("TimeGranularity")]);
    m_time_granularity_isSet = !json[QString("TimeGranularity")].isNull() && m_time_granularity_isValid;

    m_allowed_aggregations_isValid = ::OpenAPI::fromJsonValue(m_allowed_aggregations, json[QString("AllowedAggregations")]);
    m_allowed_aggregations_isSet = !json[QString("AllowedAggregations")].isNull() && m_allowed_aggregations_isValid;

    m_not_allowed_aggregations_isValid = ::OpenAPI::fromJsonValue(m_not_allowed_aggregations, json[QString("NotAllowedAggregations")]);
    m_not_allowed_aggregations_isSet = !json[QString("NotAllowedAggregations")].isNull() && m_not_allowed_aggregations_isValid;

    m_default_formatting_isValid = ::OpenAPI::fromJsonValue(m_default_formatting, json[QString("DefaultFormatting")]);
    m_default_formatting_isSet = !json[QString("DefaultFormatting")].isNull() && m_default_formatting_isValid;

    m_never_aggregate_in_filter_isValid = ::OpenAPI::fromJsonValue(m_never_aggregate_in_filter, json[QString("NeverAggregateInFilter")]);
    m_never_aggregate_in_filter_isSet = !json[QString("NeverAggregateInFilter")].isNull() && m_never_aggregate_in_filter_isValid;

    m_cell_value_synonyms_isValid = ::OpenAPI::fromJsonValue(m_cell_value_synonyms, json[QString("CellValueSynonyms")]);
    m_cell_value_synonyms_isSet = !json[QString("CellValueSynonyms")].isNull() && m_cell_value_synonyms_isValid;
}

QString OAITopicColumn::asJson() const {
    QJsonObject obj = this->asJsonObject();
    QJsonDocument doc(obj);
    QByteArray bytes = doc.toJson();
    return QString(bytes);
}

QJsonObject OAITopicColumn::asJsonObject() const {
    QJsonObject obj;
    if (m_column_name_isSet) {
        obj.insert(QString("ColumnName"), ::OpenAPI::toJsonValue(m_column_name));
    }
    if (m_column_friendly_name_isSet) {
        obj.insert(QString("ColumnFriendlyName"), ::OpenAPI::toJsonValue(m_column_friendly_name));
    }
    if (m_column_description_isSet) {
        obj.insert(QString("ColumnDescription"), ::OpenAPI::toJsonValue(m_column_description));
    }
    if (m_column_synonyms.isSet()) {
        obj.insert(QString("ColumnSynonyms"), ::OpenAPI::toJsonValue(m_column_synonyms));
    }
    if (m_column_data_role.isSet()) {
        obj.insert(QString("ColumnDataRole"), ::OpenAPI::toJsonValue(m_column_data_role));
    }
    if (m_aggregation.isSet()) {
        obj.insert(QString("Aggregation"), ::OpenAPI::toJsonValue(m_aggregation));
    }
    if (m_is_included_in_topic_isSet) {
        obj.insert(QString("IsIncludedInTopic"), ::OpenAPI::toJsonValue(m_is_included_in_topic));
    }
    if (m_disable_indexing_isSet) {
        obj.insert(QString("DisableIndexing"), ::OpenAPI::toJsonValue(m_disable_indexing));
    }
    if (m_comparative_order.isSet()) {
        obj.insert(QString("ComparativeOrder"), ::OpenAPI::toJsonValue(m_comparative_order));
    }
    if (m_semantic_type.isSet()) {
        obj.insert(QString("SemanticType"), ::OpenAPI::toJsonValue(m_semantic_type));
    }
    if (m_time_granularity.isSet()) {
        obj.insert(QString("TimeGranularity"), ::OpenAPI::toJsonValue(m_time_granularity));
    }
    if (m_allowed_aggregations.isSet()) {
        obj.insert(QString("AllowedAggregations"), ::OpenAPI::toJsonValue(m_allowed_aggregations));
    }
    if (m_not_allowed_aggregations.isSet()) {
        obj.insert(QString("NotAllowedAggregations"), ::OpenAPI::toJsonValue(m_not_allowed_aggregations));
    }
    if (m_default_formatting.isSet()) {
        obj.insert(QString("DefaultFormatting"), ::OpenAPI::toJsonValue(m_default_formatting));
    }
    if (m_never_aggregate_in_filter_isSet) {
        obj.insert(QString("NeverAggregateInFilter"), ::OpenAPI::toJsonValue(m_never_aggregate_in_filter));
    }
    if (m_cell_value_synonyms.isSet()) {
        obj.insert(QString("CellValueSynonyms"), ::OpenAPI::toJsonValue(m_cell_value_synonyms));
    }
    return obj;
}

QString OAITopicColumn::getColumnName() const {
    return m_column_name;
}
void OAITopicColumn::setColumnName(const QString &column_name) {
    m_column_name = column_name;
    m_column_name_isSet = true;
}

bool OAITopicColumn::is_column_name_Set() const{
    return m_column_name_isSet;
}

bool OAITopicColumn::is_column_name_Valid() const{
    return m_column_name_isValid;
}

QString OAITopicColumn::getColumnFriendlyName() const {
    return m_column_friendly_name;
}
void OAITopicColumn::setColumnFriendlyName(const QString &column_friendly_name) {
    m_column_friendly_name = column_friendly_name;
    m_column_friendly_name_isSet = true;
}

bool OAITopicColumn::is_column_friendly_name_Set() const{
    return m_column_friendly_name_isSet;
}

bool OAITopicColumn::is_column_friendly_name_Valid() const{
    return m_column_friendly_name_isValid;
}

QString OAITopicColumn::getColumnDescription() const {
    return m_column_description;
}
void OAITopicColumn::setColumnDescription(const QString &column_description) {
    m_column_description = column_description;
    m_column_description_isSet = true;
}

bool OAITopicColumn::is_column_description_Set() const{
    return m_column_description_isSet;
}

bool OAITopicColumn::is_column_description_Valid() const{
    return m_column_description_isValid;
}

QList OAITopicColumn::getColumnSynonyms() const {
    return m_column_synonyms;
}
void OAITopicColumn::setColumnSynonyms(const QList &column_synonyms) {
    m_column_synonyms = column_synonyms;
    m_column_synonyms_isSet = true;
}

bool OAITopicColumn::is_column_synonyms_Set() const{
    return m_column_synonyms_isSet;
}

bool OAITopicColumn::is_column_synonyms_Valid() const{
    return m_column_synonyms_isValid;
}

OAIColumnDataRole OAITopicColumn::getColumnDataRole() const {
    return m_column_data_role;
}
void OAITopicColumn::setColumnDataRole(const OAIColumnDataRole &column_data_role) {
    m_column_data_role = column_data_role;
    m_column_data_role_isSet = true;
}

bool OAITopicColumn::is_column_data_role_Set() const{
    return m_column_data_role_isSet;
}

bool OAITopicColumn::is_column_data_role_Valid() const{
    return m_column_data_role_isValid;
}

OAIDefaultAggregation OAITopicColumn::getAggregation() const {
    return m_aggregation;
}
void OAITopicColumn::setAggregation(const OAIDefaultAggregation &aggregation) {
    m_aggregation = aggregation;
    m_aggregation_isSet = true;
}

bool OAITopicColumn::is_aggregation_Set() const{
    return m_aggregation_isSet;
}

bool OAITopicColumn::is_aggregation_Valid() const{
    return m_aggregation_isValid;
}

bool OAITopicColumn::getIsIncludedInTopic() const {
    return m_is_included_in_topic;
}
void OAITopicColumn::setIsIncludedInTopic(const bool &is_included_in_topic) {
    m_is_included_in_topic = is_included_in_topic;
    m_is_included_in_topic_isSet = true;
}

bool OAITopicColumn::is_is_included_in_topic_Set() const{
    return m_is_included_in_topic_isSet;
}

bool OAITopicColumn::is_is_included_in_topic_Valid() const{
    return m_is_included_in_topic_isValid;
}

bool OAITopicColumn::getDisableIndexing() const {
    return m_disable_indexing;
}
void OAITopicColumn::setDisableIndexing(const bool &disable_indexing) {
    m_disable_indexing = disable_indexing;
    m_disable_indexing_isSet = true;
}

bool OAITopicColumn::is_disable_indexing_Set() const{
    return m_disable_indexing_isSet;
}

bool OAITopicColumn::is_disable_indexing_Valid() const{
    return m_disable_indexing_isValid;
}

OAITopicColumn_ComparativeOrder OAITopicColumn::getComparativeOrder() const {
    return m_comparative_order;
}
void OAITopicColumn::setComparativeOrder(const OAITopicColumn_ComparativeOrder &comparative_order) {
    m_comparative_order = comparative_order;
    m_comparative_order_isSet = true;
}

bool OAITopicColumn::is_comparative_order_Set() const{
    return m_comparative_order_isSet;
}

bool OAITopicColumn::is_comparative_order_Valid() const{
    return m_comparative_order_isValid;
}

OAITopicColumn_SemanticType OAITopicColumn::getSemanticType() const {
    return m_semantic_type;
}
void OAITopicColumn::setSemanticType(const OAITopicColumn_SemanticType &semantic_type) {
    m_semantic_type = semantic_type;
    m_semantic_type_isSet = true;
}

bool OAITopicColumn::is_semantic_type_Set() const{
    return m_semantic_type_isSet;
}

bool OAITopicColumn::is_semantic_type_Valid() const{
    return m_semantic_type_isValid;
}

OAITopicTimeGranularity OAITopicColumn::getTimeGranularity() const {
    return m_time_granularity;
}
void OAITopicColumn::setTimeGranularity(const OAITopicTimeGranularity &time_granularity) {
    m_time_granularity = time_granularity;
    m_time_granularity_isSet = true;
}

bool OAITopicColumn::is_time_granularity_Set() const{
    return m_time_granularity_isSet;
}

bool OAITopicColumn::is_time_granularity_Valid() const{
    return m_time_granularity_isValid;
}

QList OAITopicColumn::getAllowedAggregations() const {
    return m_allowed_aggregations;
}
void OAITopicColumn::setAllowedAggregations(const QList &allowed_aggregations) {
    m_allowed_aggregations = allowed_aggregations;
    m_allowed_aggregations_isSet = true;
}

bool OAITopicColumn::is_allowed_aggregations_Set() const{
    return m_allowed_aggregations_isSet;
}

bool OAITopicColumn::is_allowed_aggregations_Valid() const{
    return m_allowed_aggregations_isValid;
}

QList OAITopicColumn::getNotAllowedAggregations() const {
    return m_not_allowed_aggregations;
}
void OAITopicColumn::setNotAllowedAggregations(const QList &not_allowed_aggregations) {
    m_not_allowed_aggregations = not_allowed_aggregations;
    m_not_allowed_aggregations_isSet = true;
}

bool OAITopicColumn::is_not_allowed_aggregations_Set() const{
    return m_not_allowed_aggregations_isSet;
}

bool OAITopicColumn::is_not_allowed_aggregations_Valid() const{
    return m_not_allowed_aggregations_isValid;
}

OAITopicColumn_DefaultFormatting OAITopicColumn::getDefaultFormatting() const {
    return m_default_formatting;
}
void OAITopicColumn::setDefaultFormatting(const OAITopicColumn_DefaultFormatting &default_formatting) {
    m_default_formatting = default_formatting;
    m_default_formatting_isSet = true;
}

bool OAITopicColumn::is_default_formatting_Set() const{
    return m_default_formatting_isSet;
}

bool OAITopicColumn::is_default_formatting_Valid() const{
    return m_default_formatting_isValid;
}

bool OAITopicColumn::getNeverAggregateInFilter() const {
    return m_never_aggregate_in_filter;
}
void OAITopicColumn::setNeverAggregateInFilter(const bool &never_aggregate_in_filter) {
    m_never_aggregate_in_filter = never_aggregate_in_filter;
    m_never_aggregate_in_filter_isSet = true;
}

bool OAITopicColumn::is_never_aggregate_in_filter_Set() const{
    return m_never_aggregate_in_filter_isSet;
}

bool OAITopicColumn::is_never_aggregate_in_filter_Valid() const{
    return m_never_aggregate_in_filter_isValid;
}

QList OAITopicColumn::getCellValueSynonyms() const {
    return m_cell_value_synonyms;
}
void OAITopicColumn::setCellValueSynonyms(const QList &cell_value_synonyms) {
    m_cell_value_synonyms = cell_value_synonyms;
    m_cell_value_synonyms_isSet = true;
}

bool OAITopicColumn::is_cell_value_synonyms_Set() const{
    return m_cell_value_synonyms_isSet;
}

bool OAITopicColumn::is_cell_value_synonyms_Valid() const{
    return m_cell_value_synonyms_isValid;
}

bool OAITopicColumn::isSet() const {
    bool isObjectUpdated = false;
    do {
        if (m_column_name_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_column_friendly_name_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_column_description_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_column_synonyms.isSet()) {
            isObjectUpdated = true;
            break;
        }

        if (m_column_data_role.isSet()) {
            isObjectUpdated = true;
            break;
        }

        if (m_aggregation.isSet()) {
            isObjectUpdated = true;
            break;
        }

        if (m_is_included_in_topic_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_disable_indexing_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_comparative_order.isSet()) {
            isObjectUpdated = true;
            break;
        }

        if (m_semantic_type.isSet()) {
            isObjectUpdated = true;
            break;
        }

        if (m_time_granularity.isSet()) {
            isObjectUpdated = true;
            break;
        }

        if (m_allowed_aggregations.isSet()) {
            isObjectUpdated = true;
            break;
        }

        if (m_not_allowed_aggregations.isSet()) {
            isObjectUpdated = true;
            break;
        }

        if (m_default_formatting.isSet()) {
            isObjectUpdated = true;
            break;
        }

        if (m_never_aggregate_in_filter_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_cell_value_synonyms.isSet()) {
            isObjectUpdated = true;
            break;
        }
    } while (false);
    return isObjectUpdated;
}

bool OAITopicColumn::isValid() const {
    // only required properties are required for the object to be considered valid
    return m_column_name_isValid && true;
}

} // namespace OpenAPI
