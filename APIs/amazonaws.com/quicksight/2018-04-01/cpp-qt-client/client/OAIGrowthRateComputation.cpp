/**
 * Amazon QuickSight
 * <fullname>Amazon QuickSight API Reference</fullname> <p>Amazon QuickSight is a fully managed, serverless business intelligence service for the Amazon Web Services Cloud that makes it easy to extend data and insights to every user in your organization. This API reference contains documentation for a programming interface that you can use to manage Amazon QuickSight. </p>
 *
 * The version of the OpenAPI document: 2018-04-01
 * Contact: mike.ralphson@gmail.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

#include "OAIGrowthRateComputation.h"

#include <QDebug>
#include <QJsonArray>
#include <QJsonDocument>
#include <QObject>

#include "OAIHelpers.h"

namespace OpenAPI {

OAIGrowthRateComputation::OAIGrowthRateComputation(QString json) {
    this->initializeModel();
    this->fromJson(json);
}

OAIGrowthRateComputation::OAIGrowthRateComputation() {
    this->initializeModel();
}

OAIGrowthRateComputation::~OAIGrowthRateComputation() {}

void OAIGrowthRateComputation::initializeModel() {

    m_computation_id_isSet = false;
    m_computation_id_isValid = false;

    m_name_isSet = false;
    m_name_isValid = false;

    m_time_isSet = false;
    m_time_isValid = false;

    m_value_isSet = false;
    m_value_isValid = false;

    m_period_size_isSet = false;
    m_period_size_isValid = false;
}

void OAIGrowthRateComputation::fromJson(QString jsonString) {
    QByteArray array(jsonString.toStdString().c_str());
    QJsonDocument doc = QJsonDocument::fromJson(array);
    QJsonObject jsonObject = doc.object();
    this->fromJsonObject(jsonObject);
}

void OAIGrowthRateComputation::fromJsonObject(QJsonObject json) {

    m_computation_id_isValid = ::OpenAPI::fromJsonValue(m_computation_id, json[QString("ComputationId")]);
    m_computation_id_isSet = !json[QString("ComputationId")].isNull() && m_computation_id_isValid;

    m_name_isValid = ::OpenAPI::fromJsonValue(m_name, json[QString("Name")]);
    m_name_isSet = !json[QString("Name")].isNull() && m_name_isValid;

    m_time_isValid = ::OpenAPI::fromJsonValue(m_time, json[QString("Time")]);
    m_time_isSet = !json[QString("Time")].isNull() && m_time_isValid;

    m_value_isValid = ::OpenAPI::fromJsonValue(m_value, json[QString("Value")]);
    m_value_isSet = !json[QString("Value")].isNull() && m_value_isValid;

    m_period_size_isValid = ::OpenAPI::fromJsonValue(m_period_size, json[QString("PeriodSize")]);
    m_period_size_isSet = !json[QString("PeriodSize")].isNull() && m_period_size_isValid;
}

QString OAIGrowthRateComputation::asJson() const {
    QJsonObject obj = this->asJsonObject();
    QJsonDocument doc(obj);
    QByteArray bytes = doc.toJson();
    return QString(bytes);
}

QJsonObject OAIGrowthRateComputation::asJsonObject() const {
    QJsonObject obj;
    if (m_computation_id_isSet) {
        obj.insert(QString("ComputationId"), ::OpenAPI::toJsonValue(m_computation_id));
    }
    if (m_name_isSet) {
        obj.insert(QString("Name"), ::OpenAPI::toJsonValue(m_name));
    }
    if (m_time.isSet()) {
        obj.insert(QString("Time"), ::OpenAPI::toJsonValue(m_time));
    }
    if (m_value.isSet()) {
        obj.insert(QString("Value"), ::OpenAPI::toJsonValue(m_value));
    }
    if (m_period_size_isSet) {
        obj.insert(QString("PeriodSize"), ::OpenAPI::toJsonValue(m_period_size));
    }
    return obj;
}

QString OAIGrowthRateComputation::getComputationId() const {
    return m_computation_id;
}
void OAIGrowthRateComputation::setComputationId(const QString &computation_id) {
    m_computation_id = computation_id;
    m_computation_id_isSet = true;
}

bool OAIGrowthRateComputation::is_computation_id_Set() const{
    return m_computation_id_isSet;
}

bool OAIGrowthRateComputation::is_computation_id_Valid() const{
    return m_computation_id_isValid;
}

QString OAIGrowthRateComputation::getName() const {
    return m_name;
}
void OAIGrowthRateComputation::setName(const QString &name) {
    m_name = name;
    m_name_isSet = true;
}

bool OAIGrowthRateComputation::is_name_Set() const{
    return m_name_isSet;
}

bool OAIGrowthRateComputation::is_name_Valid() const{
    return m_name_isValid;
}

OAITopBottomMoversComputation_Time OAIGrowthRateComputation::getTime() const {
    return m_time;
}
void OAIGrowthRateComputation::setTime(const OAITopBottomMoversComputation_Time &time) {
    m_time = time;
    m_time_isSet = true;
}

bool OAIGrowthRateComputation::is_time_Set() const{
    return m_time_isSet;
}

bool OAIGrowthRateComputation::is_time_Valid() const{
    return m_time_isValid;
}

OAITopBottomRankedComputation_Value OAIGrowthRateComputation::getValue() const {
    return m_value;
}
void OAIGrowthRateComputation::setValue(const OAITopBottomRankedComputation_Value &value) {
    m_value = value;
    m_value_isSet = true;
}

bool OAIGrowthRateComputation::is_value_Set() const{
    return m_value_isSet;
}

bool OAIGrowthRateComputation::is_value_Valid() const{
    return m_value_isValid;
}

qint32 OAIGrowthRateComputation::getPeriodSize() const {
    return m_period_size;
}
void OAIGrowthRateComputation::setPeriodSize(const qint32 &period_size) {
    m_period_size = period_size;
    m_period_size_isSet = true;
}

bool OAIGrowthRateComputation::is_period_size_Set() const{
    return m_period_size_isSet;
}

bool OAIGrowthRateComputation::is_period_size_Valid() const{
    return m_period_size_isValid;
}

bool OAIGrowthRateComputation::isSet() const {
    bool isObjectUpdated = false;
    do {
        if (m_computation_id_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_name_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_time.isSet()) {
            isObjectUpdated = true;
            break;
        }

        if (m_value.isSet()) {
            isObjectUpdated = true;
            break;
        }

        if (m_period_size_isSet) {
            isObjectUpdated = true;
            break;
        }
    } while (false);
    return isObjectUpdated;
}

bool OAIGrowthRateComputation::isValid() const {
    // only required properties are required for the object to be considered valid
    return m_computation_id_isValid && m_time_isValid && true;
}

} // namespace OpenAPI
