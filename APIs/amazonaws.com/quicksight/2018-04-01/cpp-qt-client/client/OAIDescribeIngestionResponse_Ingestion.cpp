/**
 * Amazon QuickSight
 * <fullname>Amazon QuickSight API Reference</fullname> <p>Amazon QuickSight is a fully managed, serverless business intelligence service for the Amazon Web Services Cloud that makes it easy to extend data and insights to every user in your organization. This API reference contains documentation for a programming interface that you can use to manage Amazon QuickSight. </p>
 *
 * The version of the OpenAPI document: 2018-04-01
 * Contact: mike.ralphson@gmail.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

#include "OAIDescribeIngestionResponse_Ingestion.h"

#include <QDebug>
#include <QJsonArray>
#include <QJsonDocument>
#include <QObject>

#include "OAIHelpers.h"

namespace OpenAPI {

OAIDescribeIngestionResponse_Ingestion::OAIDescribeIngestionResponse_Ingestion(QString json) {
    this->initializeModel();
    this->fromJson(json);
}

OAIDescribeIngestionResponse_Ingestion::OAIDescribeIngestionResponse_Ingestion() {
    this->initializeModel();
}

OAIDescribeIngestionResponse_Ingestion::~OAIDescribeIngestionResponse_Ingestion() {}

void OAIDescribeIngestionResponse_Ingestion::initializeModel() {

    m_arn_isSet = false;
    m_arn_isValid = false;

    m_ingestion_id_isSet = false;
    m_ingestion_id_isValid = false;

    m_ingestion_status_isSet = false;
    m_ingestion_status_isValid = false;

    m_error_info_isSet = false;
    m_error_info_isValid = false;

    m_row_info_isSet = false;
    m_row_info_isValid = false;

    m_queue_info_isSet = false;
    m_queue_info_isValid = false;

    m_created_time_isSet = false;
    m_created_time_isValid = false;

    m_ingestion_time_in_seconds_isSet = false;
    m_ingestion_time_in_seconds_isValid = false;

    m_ingestion_size_in_bytes_isSet = false;
    m_ingestion_size_in_bytes_isValid = false;

    m_request_source_isSet = false;
    m_request_source_isValid = false;

    m_request_type_isSet = false;
    m_request_type_isValid = false;
}

void OAIDescribeIngestionResponse_Ingestion::fromJson(QString jsonString) {
    QByteArray array(jsonString.toStdString().c_str());
    QJsonDocument doc = QJsonDocument::fromJson(array);
    QJsonObject jsonObject = doc.object();
    this->fromJsonObject(jsonObject);
}

void OAIDescribeIngestionResponse_Ingestion::fromJsonObject(QJsonObject json) {

    m_arn_isValid = ::OpenAPI::fromJsonValue(m_arn, json[QString("Arn")]);
    m_arn_isSet = !json[QString("Arn")].isNull() && m_arn_isValid;

    m_ingestion_id_isValid = ::OpenAPI::fromJsonValue(m_ingestion_id, json[QString("IngestionId")]);
    m_ingestion_id_isSet = !json[QString("IngestionId")].isNull() && m_ingestion_id_isValid;

    m_ingestion_status_isValid = ::OpenAPI::fromJsonValue(m_ingestion_status, json[QString("IngestionStatus")]);
    m_ingestion_status_isSet = !json[QString("IngestionStatus")].isNull() && m_ingestion_status_isValid;

    m_error_info_isValid = ::OpenAPI::fromJsonValue(m_error_info, json[QString("ErrorInfo")]);
    m_error_info_isSet = !json[QString("ErrorInfo")].isNull() && m_error_info_isValid;

    m_row_info_isValid = ::OpenAPI::fromJsonValue(m_row_info, json[QString("RowInfo")]);
    m_row_info_isSet = !json[QString("RowInfo")].isNull() && m_row_info_isValid;

    m_queue_info_isValid = ::OpenAPI::fromJsonValue(m_queue_info, json[QString("QueueInfo")]);
    m_queue_info_isSet = !json[QString("QueueInfo")].isNull() && m_queue_info_isValid;

    m_created_time_isValid = ::OpenAPI::fromJsonValue(m_created_time, json[QString("CreatedTime")]);
    m_created_time_isSet = !json[QString("CreatedTime")].isNull() && m_created_time_isValid;

    m_ingestion_time_in_seconds_isValid = ::OpenAPI::fromJsonValue(m_ingestion_time_in_seconds, json[QString("IngestionTimeInSeconds")]);
    m_ingestion_time_in_seconds_isSet = !json[QString("IngestionTimeInSeconds")].isNull() && m_ingestion_time_in_seconds_isValid;

    m_ingestion_size_in_bytes_isValid = ::OpenAPI::fromJsonValue(m_ingestion_size_in_bytes, json[QString("IngestionSizeInBytes")]);
    m_ingestion_size_in_bytes_isSet = !json[QString("IngestionSizeInBytes")].isNull() && m_ingestion_size_in_bytes_isValid;

    m_request_source_isValid = ::OpenAPI::fromJsonValue(m_request_source, json[QString("RequestSource")]);
    m_request_source_isSet = !json[QString("RequestSource")].isNull() && m_request_source_isValid;

    m_request_type_isValid = ::OpenAPI::fromJsonValue(m_request_type, json[QString("RequestType")]);
    m_request_type_isSet = !json[QString("RequestType")].isNull() && m_request_type_isValid;
}

QString OAIDescribeIngestionResponse_Ingestion::asJson() const {
    QJsonObject obj = this->asJsonObject();
    QJsonDocument doc(obj);
    QByteArray bytes = doc.toJson();
    return QString(bytes);
}

QJsonObject OAIDescribeIngestionResponse_Ingestion::asJsonObject() const {
    QJsonObject obj;
    if (m_arn_isSet) {
        obj.insert(QString("Arn"), ::OpenAPI::toJsonValue(m_arn));
    }
    if (m_ingestion_id_isSet) {
        obj.insert(QString("IngestionId"), ::OpenAPI::toJsonValue(m_ingestion_id));
    }
    if (m_ingestion_status.isSet()) {
        obj.insert(QString("IngestionStatus"), ::OpenAPI::toJsonValue(m_ingestion_status));
    }
    if (m_error_info.isSet()) {
        obj.insert(QString("ErrorInfo"), ::OpenAPI::toJsonValue(m_error_info));
    }
    if (m_row_info.isSet()) {
        obj.insert(QString("RowInfo"), ::OpenAPI::toJsonValue(m_row_info));
    }
    if (m_queue_info.isSet()) {
        obj.insert(QString("QueueInfo"), ::OpenAPI::toJsonValue(m_queue_info));
    }
    if (m_created_time_isSet) {
        obj.insert(QString("CreatedTime"), ::OpenAPI::toJsonValue(m_created_time));
    }
    if (m_ingestion_time_in_seconds_isSet) {
        obj.insert(QString("IngestionTimeInSeconds"), ::OpenAPI::toJsonValue(m_ingestion_time_in_seconds));
    }
    if (m_ingestion_size_in_bytes_isSet) {
        obj.insert(QString("IngestionSizeInBytes"), ::OpenAPI::toJsonValue(m_ingestion_size_in_bytes));
    }
    if (m_request_source.isSet()) {
        obj.insert(QString("RequestSource"), ::OpenAPI::toJsonValue(m_request_source));
    }
    if (m_request_type.isSet()) {
        obj.insert(QString("RequestType"), ::OpenAPI::toJsonValue(m_request_type));
    }
    return obj;
}

QString OAIDescribeIngestionResponse_Ingestion::getArn() const {
    return m_arn;
}
void OAIDescribeIngestionResponse_Ingestion::setArn(const QString &arn) {
    m_arn = arn;
    m_arn_isSet = true;
}

bool OAIDescribeIngestionResponse_Ingestion::is_arn_Set() const{
    return m_arn_isSet;
}

bool OAIDescribeIngestionResponse_Ingestion::is_arn_Valid() const{
    return m_arn_isValid;
}

QString OAIDescribeIngestionResponse_Ingestion::getIngestionId() const {
    return m_ingestion_id;
}
void OAIDescribeIngestionResponse_Ingestion::setIngestionId(const QString &ingestion_id) {
    m_ingestion_id = ingestion_id;
    m_ingestion_id_isSet = true;
}

bool OAIDescribeIngestionResponse_Ingestion::is_ingestion_id_Set() const{
    return m_ingestion_id_isSet;
}

bool OAIDescribeIngestionResponse_Ingestion::is_ingestion_id_Valid() const{
    return m_ingestion_id_isValid;
}

OAIIngestionStatus OAIDescribeIngestionResponse_Ingestion::getIngestionStatus() const {
    return m_ingestion_status;
}
void OAIDescribeIngestionResponse_Ingestion::setIngestionStatus(const OAIIngestionStatus &ingestion_status) {
    m_ingestion_status = ingestion_status;
    m_ingestion_status_isSet = true;
}

bool OAIDescribeIngestionResponse_Ingestion::is_ingestion_status_Set() const{
    return m_ingestion_status_isSet;
}

bool OAIDescribeIngestionResponse_Ingestion::is_ingestion_status_Valid() const{
    return m_ingestion_status_isValid;
}

OAIIngestion_ErrorInfo OAIDescribeIngestionResponse_Ingestion::getErrorInfo() const {
    return m_error_info;
}
void OAIDescribeIngestionResponse_Ingestion::setErrorInfo(const OAIIngestion_ErrorInfo &error_info) {
    m_error_info = error_info;
    m_error_info_isSet = true;
}

bool OAIDescribeIngestionResponse_Ingestion::is_error_info_Set() const{
    return m_error_info_isSet;
}

bool OAIDescribeIngestionResponse_Ingestion::is_error_info_Valid() const{
    return m_error_info_isValid;
}

OAIRowInfo OAIDescribeIngestionResponse_Ingestion::getRowInfo() const {
    return m_row_info;
}
void OAIDescribeIngestionResponse_Ingestion::setRowInfo(const OAIRowInfo &row_info) {
    m_row_info = row_info;
    m_row_info_isSet = true;
}

bool OAIDescribeIngestionResponse_Ingestion::is_row_info_Set() const{
    return m_row_info_isSet;
}

bool OAIDescribeIngestionResponse_Ingestion::is_row_info_Valid() const{
    return m_row_info_isValid;
}

OAIQueueInfo OAIDescribeIngestionResponse_Ingestion::getQueueInfo() const {
    return m_queue_info;
}
void OAIDescribeIngestionResponse_Ingestion::setQueueInfo(const OAIQueueInfo &queue_info) {
    m_queue_info = queue_info;
    m_queue_info_isSet = true;
}

bool OAIDescribeIngestionResponse_Ingestion::is_queue_info_Set() const{
    return m_queue_info_isSet;
}

bool OAIDescribeIngestionResponse_Ingestion::is_queue_info_Valid() const{
    return m_queue_info_isValid;
}

QDateTime OAIDescribeIngestionResponse_Ingestion::getCreatedTime() const {
    return m_created_time;
}
void OAIDescribeIngestionResponse_Ingestion::setCreatedTime(const QDateTime &created_time) {
    m_created_time = created_time;
    m_created_time_isSet = true;
}

bool OAIDescribeIngestionResponse_Ingestion::is_created_time_Set() const{
    return m_created_time_isSet;
}

bool OAIDescribeIngestionResponse_Ingestion::is_created_time_Valid() const{
    return m_created_time_isValid;
}

qint32 OAIDescribeIngestionResponse_Ingestion::getIngestionTimeInSeconds() const {
    return m_ingestion_time_in_seconds;
}
void OAIDescribeIngestionResponse_Ingestion::setIngestionTimeInSeconds(const qint32 &ingestion_time_in_seconds) {
    m_ingestion_time_in_seconds = ingestion_time_in_seconds;
    m_ingestion_time_in_seconds_isSet = true;
}

bool OAIDescribeIngestionResponse_Ingestion::is_ingestion_time_in_seconds_Set() const{
    return m_ingestion_time_in_seconds_isSet;
}

bool OAIDescribeIngestionResponse_Ingestion::is_ingestion_time_in_seconds_Valid() const{
    return m_ingestion_time_in_seconds_isValid;
}

qint32 OAIDescribeIngestionResponse_Ingestion::getIngestionSizeInBytes() const {
    return m_ingestion_size_in_bytes;
}
void OAIDescribeIngestionResponse_Ingestion::setIngestionSizeInBytes(const qint32 &ingestion_size_in_bytes) {
    m_ingestion_size_in_bytes = ingestion_size_in_bytes;
    m_ingestion_size_in_bytes_isSet = true;
}

bool OAIDescribeIngestionResponse_Ingestion::is_ingestion_size_in_bytes_Set() const{
    return m_ingestion_size_in_bytes_isSet;
}

bool OAIDescribeIngestionResponse_Ingestion::is_ingestion_size_in_bytes_Valid() const{
    return m_ingestion_size_in_bytes_isValid;
}

OAIIngestionRequestSource OAIDescribeIngestionResponse_Ingestion::getRequestSource() const {
    return m_request_source;
}
void OAIDescribeIngestionResponse_Ingestion::setRequestSource(const OAIIngestionRequestSource &request_source) {
    m_request_source = request_source;
    m_request_source_isSet = true;
}

bool OAIDescribeIngestionResponse_Ingestion::is_request_source_Set() const{
    return m_request_source_isSet;
}

bool OAIDescribeIngestionResponse_Ingestion::is_request_source_Valid() const{
    return m_request_source_isValid;
}

OAIIngestionRequestType OAIDescribeIngestionResponse_Ingestion::getRequestType() const {
    return m_request_type;
}
void OAIDescribeIngestionResponse_Ingestion::setRequestType(const OAIIngestionRequestType &request_type) {
    m_request_type = request_type;
    m_request_type_isSet = true;
}

bool OAIDescribeIngestionResponse_Ingestion::is_request_type_Set() const{
    return m_request_type_isSet;
}

bool OAIDescribeIngestionResponse_Ingestion::is_request_type_Valid() const{
    return m_request_type_isValid;
}

bool OAIDescribeIngestionResponse_Ingestion::isSet() const {
    bool isObjectUpdated = false;
    do {
        if (m_arn_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_ingestion_id_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_ingestion_status.isSet()) {
            isObjectUpdated = true;
            break;
        }

        if (m_error_info.isSet()) {
            isObjectUpdated = true;
            break;
        }

        if (m_row_info.isSet()) {
            isObjectUpdated = true;
            break;
        }

        if (m_queue_info.isSet()) {
            isObjectUpdated = true;
            break;
        }

        if (m_created_time_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_ingestion_time_in_seconds_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_ingestion_size_in_bytes_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_request_source.isSet()) {
            isObjectUpdated = true;
            break;
        }

        if (m_request_type.isSet()) {
            isObjectUpdated = true;
            break;
        }
    } while (false);
    return isObjectUpdated;
}

bool OAIDescribeIngestionResponse_Ingestion::isValid() const {
    // only required properties are required for the object to be considered valid
    return m_arn_isValid && m_ingestion_status_isValid && m_created_time_isValid && true;
}

} // namespace OpenAPI
