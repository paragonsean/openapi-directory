/**
 * Amazon QuickSight
 * <fullname>Amazon QuickSight API Reference</fullname> <p>Amazon QuickSight is a fully managed, serverless business intelligence service for the Amazon Web Services Cloud that makes it easy to extend data and insights to every user in your organization. This API reference contains documentation for a programming interface that you can use to manage Amazon QuickSight. </p>
 *
 * The version of the OpenAPI document: 2018-04-01
 * Contact: mike.ralphson@gmail.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

#include "OAITopicColumn_ComparativeOrder.h"

#include <QDebug>
#include <QJsonArray>
#include <QJsonDocument>
#include <QObject>

#include "OAIHelpers.h"

namespace OpenAPI {

OAITopicColumn_ComparativeOrder::OAITopicColumn_ComparativeOrder(QString json) {
    this->initializeModel();
    this->fromJson(json);
}

OAITopicColumn_ComparativeOrder::OAITopicColumn_ComparativeOrder() {
    this->initializeModel();
}

OAITopicColumn_ComparativeOrder::~OAITopicColumn_ComparativeOrder() {}

void OAITopicColumn_ComparativeOrder::initializeModel() {

    m_use_ordering_isSet = false;
    m_use_ordering_isValid = false;

    m_specifed_order_isSet = false;
    m_specifed_order_isValid = false;

    m_treat_undefined_specified_values_isSet = false;
    m_treat_undefined_specified_values_isValid = false;
}

void OAITopicColumn_ComparativeOrder::fromJson(QString jsonString) {
    QByteArray array(jsonString.toStdString().c_str());
    QJsonDocument doc = QJsonDocument::fromJson(array);
    QJsonObject jsonObject = doc.object();
    this->fromJsonObject(jsonObject);
}

void OAITopicColumn_ComparativeOrder::fromJsonObject(QJsonObject json) {

    m_use_ordering_isValid = ::OpenAPI::fromJsonValue(m_use_ordering, json[QString("UseOrdering")]);
    m_use_ordering_isSet = !json[QString("UseOrdering")].isNull() && m_use_ordering_isValid;

    m_specifed_order_isValid = ::OpenAPI::fromJsonValue(m_specifed_order, json[QString("SpecifedOrder")]);
    m_specifed_order_isSet = !json[QString("SpecifedOrder")].isNull() && m_specifed_order_isValid;

    m_treat_undefined_specified_values_isValid = ::OpenAPI::fromJsonValue(m_treat_undefined_specified_values, json[QString("TreatUndefinedSpecifiedValues")]);
    m_treat_undefined_specified_values_isSet = !json[QString("TreatUndefinedSpecifiedValues")].isNull() && m_treat_undefined_specified_values_isValid;
}

QString OAITopicColumn_ComparativeOrder::asJson() const {
    QJsonObject obj = this->asJsonObject();
    QJsonDocument doc(obj);
    QByteArray bytes = doc.toJson();
    return QString(bytes);
}

QJsonObject OAITopicColumn_ComparativeOrder::asJsonObject() const {
    QJsonObject obj;
    if (m_use_ordering.isSet()) {
        obj.insert(QString("UseOrdering"), ::OpenAPI::toJsonValue(m_use_ordering));
    }
    if (m_specifed_order.isSet()) {
        obj.insert(QString("SpecifedOrder"), ::OpenAPI::toJsonValue(m_specifed_order));
    }
    if (m_treat_undefined_specified_values.isSet()) {
        obj.insert(QString("TreatUndefinedSpecifiedValues"), ::OpenAPI::toJsonValue(m_treat_undefined_specified_values));
    }
    return obj;
}

OAIColumnOrderingType OAITopicColumn_ComparativeOrder::getUseOrdering() const {
    return m_use_ordering;
}
void OAITopicColumn_ComparativeOrder::setUseOrdering(const OAIColumnOrderingType &use_ordering) {
    m_use_ordering = use_ordering;
    m_use_ordering_isSet = true;
}

bool OAITopicColumn_ComparativeOrder::is_use_ordering_Set() const{
    return m_use_ordering_isSet;
}

bool OAITopicColumn_ComparativeOrder::is_use_ordering_Valid() const{
    return m_use_ordering_isValid;
}

QList OAITopicColumn_ComparativeOrder::getSpecifedOrder() const {
    return m_specifed_order;
}
void OAITopicColumn_ComparativeOrder::setSpecifedOrder(const QList &specifed_order) {
    m_specifed_order = specifed_order;
    m_specifed_order_isSet = true;
}

bool OAITopicColumn_ComparativeOrder::is_specifed_order_Set() const{
    return m_specifed_order_isSet;
}

bool OAITopicColumn_ComparativeOrder::is_specifed_order_Valid() const{
    return m_specifed_order_isValid;
}

OAIUndefinedSpecifiedValueType OAITopicColumn_ComparativeOrder::getTreatUndefinedSpecifiedValues() const {
    return m_treat_undefined_specified_values;
}
void OAITopicColumn_ComparativeOrder::setTreatUndefinedSpecifiedValues(const OAIUndefinedSpecifiedValueType &treat_undefined_specified_values) {
    m_treat_undefined_specified_values = treat_undefined_specified_values;
    m_treat_undefined_specified_values_isSet = true;
}

bool OAITopicColumn_ComparativeOrder::is_treat_undefined_specified_values_Set() const{
    return m_treat_undefined_specified_values_isSet;
}

bool OAITopicColumn_ComparativeOrder::is_treat_undefined_specified_values_Valid() const{
    return m_treat_undefined_specified_values_isValid;
}

bool OAITopicColumn_ComparativeOrder::isSet() const {
    bool isObjectUpdated = false;
    do {
        if (m_use_ordering.isSet()) {
            isObjectUpdated = true;
            break;
        }

        if (m_specifed_order.isSet()) {
            isObjectUpdated = true;
            break;
        }

        if (m_treat_undefined_specified_values.isSet()) {
            isObjectUpdated = true;
            break;
        }
    } while (false);
    return isObjectUpdated;
}

bool OAITopicColumn_ComparativeOrder::isValid() const {
    // only required properties are required for the object to be considered valid
    return true;
}

} // namespace OpenAPI
