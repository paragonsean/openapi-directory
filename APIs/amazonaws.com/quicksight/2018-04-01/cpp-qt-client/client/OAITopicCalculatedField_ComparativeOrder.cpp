/**
 * Amazon QuickSight
 * <fullname>Amazon QuickSight API Reference</fullname> <p>Amazon QuickSight is a fully managed, serverless business intelligence service for the Amazon Web Services Cloud that makes it easy to extend data and insights to every user in your organization. This API reference contains documentation for a programming interface that you can use to manage Amazon QuickSight. </p>
 *
 * The version of the OpenAPI document: 2018-04-01
 * Contact: mike.ralphson@gmail.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

#include "OAITopicCalculatedField_ComparativeOrder.h"

#include <QDebug>
#include <QJsonArray>
#include <QJsonDocument>
#include <QObject>

#include "OAIHelpers.h"

namespace OpenAPI {

OAITopicCalculatedField_ComparativeOrder::OAITopicCalculatedField_ComparativeOrder(QString json) {
    this->initializeModel();
    this->fromJson(json);
}

OAITopicCalculatedField_ComparativeOrder::OAITopicCalculatedField_ComparativeOrder() {
    this->initializeModel();
}

OAITopicCalculatedField_ComparativeOrder::~OAITopicCalculatedField_ComparativeOrder() {}

void OAITopicCalculatedField_ComparativeOrder::initializeModel() {

    m_use_ordering_isSet = false;
    m_use_ordering_isValid = false;

    m_specifed_order_isSet = false;
    m_specifed_order_isValid = false;

    m_treat_undefined_specified_values_isSet = false;
    m_treat_undefined_specified_values_isValid = false;
}

void OAITopicCalculatedField_ComparativeOrder::fromJson(QString jsonString) {
    QByteArray array(jsonString.toStdString().c_str());
    QJsonDocument doc = QJsonDocument::fromJson(array);
    QJsonObject jsonObject = doc.object();
    this->fromJsonObject(jsonObject);
}

void OAITopicCalculatedField_ComparativeOrder::fromJsonObject(QJsonObject json) {

    m_use_ordering_isValid = ::OpenAPI::fromJsonValue(m_use_ordering, json[QString("UseOrdering")]);
    m_use_ordering_isSet = !json[QString("UseOrdering")].isNull() && m_use_ordering_isValid;

    m_specifed_order_isValid = ::OpenAPI::fromJsonValue(m_specifed_order, json[QString("SpecifedOrder")]);
    m_specifed_order_isSet = !json[QString("SpecifedOrder")].isNull() && m_specifed_order_isValid;

    m_treat_undefined_specified_values_isValid = ::OpenAPI::fromJsonValue(m_treat_undefined_specified_values, json[QString("TreatUndefinedSpecifiedValues")]);
    m_treat_undefined_specified_values_isSet = !json[QString("TreatUndefinedSpecifiedValues")].isNull() && m_treat_undefined_specified_values_isValid;
}

QString OAITopicCalculatedField_ComparativeOrder::asJson() const {
    QJsonObject obj = this->asJsonObject();
    QJsonDocument doc(obj);
    QByteArray bytes = doc.toJson();
    return QString(bytes);
}

QJsonObject OAITopicCalculatedField_ComparativeOrder::asJsonObject() const {
    QJsonObject obj;
    if (m_use_ordering.isSet()) {
        obj.insert(QString("UseOrdering"), ::OpenAPI::toJsonValue(m_use_ordering));
    }
    if (m_specifed_order.isSet()) {
        obj.insert(QString("SpecifedOrder"), ::OpenAPI::toJsonValue(m_specifed_order));
    }
    if (m_treat_undefined_specified_values.isSet()) {
        obj.insert(QString("TreatUndefinedSpecifiedValues"), ::OpenAPI::toJsonValue(m_treat_undefined_specified_values));
    }
    return obj;
}

OAIColumnOrderingType OAITopicCalculatedField_ComparativeOrder::getUseOrdering() const {
    return m_use_ordering;
}
void OAITopicCalculatedField_ComparativeOrder::setUseOrdering(const OAIColumnOrderingType &use_ordering) {
    m_use_ordering = use_ordering;
    m_use_ordering_isSet = true;
}

bool OAITopicCalculatedField_ComparativeOrder::is_use_ordering_Set() const{
    return m_use_ordering_isSet;
}

bool OAITopicCalculatedField_ComparativeOrder::is_use_ordering_Valid() const{
    return m_use_ordering_isValid;
}

QList OAITopicCalculatedField_ComparativeOrder::getSpecifedOrder() const {
    return m_specifed_order;
}
void OAITopicCalculatedField_ComparativeOrder::setSpecifedOrder(const QList &specifed_order) {
    m_specifed_order = specifed_order;
    m_specifed_order_isSet = true;
}

bool OAITopicCalculatedField_ComparativeOrder::is_specifed_order_Set() const{
    return m_specifed_order_isSet;
}

bool OAITopicCalculatedField_ComparativeOrder::is_specifed_order_Valid() const{
    return m_specifed_order_isValid;
}

OAIUndefinedSpecifiedValueType OAITopicCalculatedField_ComparativeOrder::getTreatUndefinedSpecifiedValues() const {
    return m_treat_undefined_specified_values;
}
void OAITopicCalculatedField_ComparativeOrder::setTreatUndefinedSpecifiedValues(const OAIUndefinedSpecifiedValueType &treat_undefined_specified_values) {
    m_treat_undefined_specified_values = treat_undefined_specified_values;
    m_treat_undefined_specified_values_isSet = true;
}

bool OAITopicCalculatedField_ComparativeOrder::is_treat_undefined_specified_values_Set() const{
    return m_treat_undefined_specified_values_isSet;
}

bool OAITopicCalculatedField_ComparativeOrder::is_treat_undefined_specified_values_Valid() const{
    return m_treat_undefined_specified_values_isValid;
}

bool OAITopicCalculatedField_ComparativeOrder::isSet() const {
    bool isObjectUpdated = false;
    do {
        if (m_use_ordering.isSet()) {
            isObjectUpdated = true;
            break;
        }

        if (m_specifed_order.isSet()) {
            isObjectUpdated = true;
            break;
        }

        if (m_treat_undefined_specified_values.isSet()) {
            isObjectUpdated = true;
            break;
        }
    } while (false);
    return isObjectUpdated;
}

bool OAITopicCalculatedField_ComparativeOrder::isValid() const {
    // only required properties are required for the object to be considered valid
    return true;
}

} // namespace OpenAPI
