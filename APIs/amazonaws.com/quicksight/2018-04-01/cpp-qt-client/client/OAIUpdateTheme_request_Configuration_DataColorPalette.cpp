/**
 * Amazon QuickSight
 * <fullname>Amazon QuickSight API Reference</fullname> <p>Amazon QuickSight is a fully managed, serverless business intelligence service for the Amazon Web Services Cloud that makes it easy to extend data and insights to every user in your organization. This API reference contains documentation for a programming interface that you can use to manage Amazon QuickSight. </p>
 *
 * The version of the OpenAPI document: 2018-04-01
 * Contact: mike.ralphson@gmail.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

#include "OAIUpdateTheme_request_Configuration_DataColorPalette.h"

#include <QDebug>
#include <QJsonArray>
#include <QJsonDocument>
#include <QObject>

#include "OAIHelpers.h"

namespace OpenAPI {

OAIUpdateTheme_request_Configuration_DataColorPalette::OAIUpdateTheme_request_Configuration_DataColorPalette(QString json) {
    this->initializeModel();
    this->fromJson(json);
}

OAIUpdateTheme_request_Configuration_DataColorPalette::OAIUpdateTheme_request_Configuration_DataColorPalette() {
    this->initializeModel();
}

OAIUpdateTheme_request_Configuration_DataColorPalette::~OAIUpdateTheme_request_Configuration_DataColorPalette() {}

void OAIUpdateTheme_request_Configuration_DataColorPalette::initializeModel() {

    m_colors_isSet = false;
    m_colors_isValid = false;

    m_min_max_gradient_isSet = false;
    m_min_max_gradient_isValid = false;

    m_empty_fill_color_isSet = false;
    m_empty_fill_color_isValid = false;
}

void OAIUpdateTheme_request_Configuration_DataColorPalette::fromJson(QString jsonString) {
    QByteArray array(jsonString.toStdString().c_str());
    QJsonDocument doc = QJsonDocument::fromJson(array);
    QJsonObject jsonObject = doc.object();
    this->fromJsonObject(jsonObject);
}

void OAIUpdateTheme_request_Configuration_DataColorPalette::fromJsonObject(QJsonObject json) {

    m_colors_isValid = ::OpenAPI::fromJsonValue(m_colors, json[QString("Colors")]);
    m_colors_isSet = !json[QString("Colors")].isNull() && m_colors_isValid;

    m_min_max_gradient_isValid = ::OpenAPI::fromJsonValue(m_min_max_gradient, json[QString("MinMaxGradient")]);
    m_min_max_gradient_isSet = !json[QString("MinMaxGradient")].isNull() && m_min_max_gradient_isValid;

    m_empty_fill_color_isValid = ::OpenAPI::fromJsonValue(m_empty_fill_color, json[QString("EmptyFillColor")]);
    m_empty_fill_color_isSet = !json[QString("EmptyFillColor")].isNull() && m_empty_fill_color_isValid;
}

QString OAIUpdateTheme_request_Configuration_DataColorPalette::asJson() const {
    QJsonObject obj = this->asJsonObject();
    QJsonDocument doc(obj);
    QByteArray bytes = doc.toJson();
    return QString(bytes);
}

QJsonObject OAIUpdateTheme_request_Configuration_DataColorPalette::asJsonObject() const {
    QJsonObject obj;
    if (m_colors.isSet()) {
        obj.insert(QString("Colors"), ::OpenAPI::toJsonValue(m_colors));
    }
    if (m_min_max_gradient.isSet()) {
        obj.insert(QString("MinMaxGradient"), ::OpenAPI::toJsonValue(m_min_max_gradient));
    }
    if (m_empty_fill_color_isSet) {
        obj.insert(QString("EmptyFillColor"), ::OpenAPI::toJsonValue(m_empty_fill_color));
    }
    return obj;
}

QList OAIUpdateTheme_request_Configuration_DataColorPalette::getColors() const {
    return m_colors;
}
void OAIUpdateTheme_request_Configuration_DataColorPalette::setColors(const QList &colors) {
    m_colors = colors;
    m_colors_isSet = true;
}

bool OAIUpdateTheme_request_Configuration_DataColorPalette::is_colors_Set() const{
    return m_colors_isSet;
}

bool OAIUpdateTheme_request_Configuration_DataColorPalette::is_colors_Valid() const{
    return m_colors_isValid;
}

QList OAIUpdateTheme_request_Configuration_DataColorPalette::getMinMaxGradient() const {
    return m_min_max_gradient;
}
void OAIUpdateTheme_request_Configuration_DataColorPalette::setMinMaxGradient(const QList &min_max_gradient) {
    m_min_max_gradient = min_max_gradient;
    m_min_max_gradient_isSet = true;
}

bool OAIUpdateTheme_request_Configuration_DataColorPalette::is_min_max_gradient_Set() const{
    return m_min_max_gradient_isSet;
}

bool OAIUpdateTheme_request_Configuration_DataColorPalette::is_min_max_gradient_Valid() const{
    return m_min_max_gradient_isValid;
}

QString OAIUpdateTheme_request_Configuration_DataColorPalette::getEmptyFillColor() const {
    return m_empty_fill_color;
}
void OAIUpdateTheme_request_Configuration_DataColorPalette::setEmptyFillColor(const QString &empty_fill_color) {
    m_empty_fill_color = empty_fill_color;
    m_empty_fill_color_isSet = true;
}

bool OAIUpdateTheme_request_Configuration_DataColorPalette::is_empty_fill_color_Set() const{
    return m_empty_fill_color_isSet;
}

bool OAIUpdateTheme_request_Configuration_DataColorPalette::is_empty_fill_color_Valid() const{
    return m_empty_fill_color_isValid;
}

bool OAIUpdateTheme_request_Configuration_DataColorPalette::isSet() const {
    bool isObjectUpdated = false;
    do {
        if (m_colors.isSet()) {
            isObjectUpdated = true;
            break;
        }

        if (m_min_max_gradient.isSet()) {
            isObjectUpdated = true;
            break;
        }

        if (m_empty_fill_color_isSet) {
            isObjectUpdated = true;
            break;
        }
    } while (false);
    return isObjectUpdated;
}

bool OAIUpdateTheme_request_Configuration_DataColorPalette::isValid() const {
    // only required properties are required for the object to be considered valid
    return true;
}

} // namespace OpenAPI
