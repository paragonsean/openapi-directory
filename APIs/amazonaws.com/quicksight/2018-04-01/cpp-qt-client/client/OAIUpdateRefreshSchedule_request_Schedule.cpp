/**
 * Amazon QuickSight
 * <fullname>Amazon QuickSight API Reference</fullname> <p>Amazon QuickSight is a fully managed, serverless business intelligence service for the Amazon Web Services Cloud that makes it easy to extend data and insights to every user in your organization. This API reference contains documentation for a programming interface that you can use to manage Amazon QuickSight. </p>
 *
 * The version of the OpenAPI document: 2018-04-01
 * Contact: mike.ralphson@gmail.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

#include "OAIUpdateRefreshSchedule_request_Schedule.h"

#include <QDebug>
#include <QJsonArray>
#include <QJsonDocument>
#include <QObject>

#include "OAIHelpers.h"

namespace OpenAPI {

OAIUpdateRefreshSchedule_request_Schedule::OAIUpdateRefreshSchedule_request_Schedule(QString json) {
    this->initializeModel();
    this->fromJson(json);
}

OAIUpdateRefreshSchedule_request_Schedule::OAIUpdateRefreshSchedule_request_Schedule() {
    this->initializeModel();
}

OAIUpdateRefreshSchedule_request_Schedule::~OAIUpdateRefreshSchedule_request_Schedule() {}

void OAIUpdateRefreshSchedule_request_Schedule::initializeModel() {

    m_schedule_id_isSet = false;
    m_schedule_id_isValid = false;

    m_schedule_frequency_isSet = false;
    m_schedule_frequency_isValid = false;

    m_start_after_date_time_isSet = false;
    m_start_after_date_time_isValid = false;

    m_refresh_type_isSet = false;
    m_refresh_type_isValid = false;

    m_arn_isSet = false;
    m_arn_isValid = false;
}

void OAIUpdateRefreshSchedule_request_Schedule::fromJson(QString jsonString) {
    QByteArray array(jsonString.toStdString().c_str());
    QJsonDocument doc = QJsonDocument::fromJson(array);
    QJsonObject jsonObject = doc.object();
    this->fromJsonObject(jsonObject);
}

void OAIUpdateRefreshSchedule_request_Schedule::fromJsonObject(QJsonObject json) {

    m_schedule_id_isValid = ::OpenAPI::fromJsonValue(m_schedule_id, json[QString("ScheduleId")]);
    m_schedule_id_isSet = !json[QString("ScheduleId")].isNull() && m_schedule_id_isValid;

    m_schedule_frequency_isValid = ::OpenAPI::fromJsonValue(m_schedule_frequency, json[QString("ScheduleFrequency")]);
    m_schedule_frequency_isSet = !json[QString("ScheduleFrequency")].isNull() && m_schedule_frequency_isValid;

    m_start_after_date_time_isValid = ::OpenAPI::fromJsonValue(m_start_after_date_time, json[QString("StartAfterDateTime")]);
    m_start_after_date_time_isSet = !json[QString("StartAfterDateTime")].isNull() && m_start_after_date_time_isValid;

    m_refresh_type_isValid = ::OpenAPI::fromJsonValue(m_refresh_type, json[QString("RefreshType")]);
    m_refresh_type_isSet = !json[QString("RefreshType")].isNull() && m_refresh_type_isValid;

    m_arn_isValid = ::OpenAPI::fromJsonValue(m_arn, json[QString("Arn")]);
    m_arn_isSet = !json[QString("Arn")].isNull() && m_arn_isValid;
}

QString OAIUpdateRefreshSchedule_request_Schedule::asJson() const {
    QJsonObject obj = this->asJsonObject();
    QJsonDocument doc(obj);
    QByteArray bytes = doc.toJson();
    return QString(bytes);
}

QJsonObject OAIUpdateRefreshSchedule_request_Schedule::asJsonObject() const {
    QJsonObject obj;
    if (m_schedule_id_isSet) {
        obj.insert(QString("ScheduleId"), ::OpenAPI::toJsonValue(m_schedule_id));
    }
    if (m_schedule_frequency.isSet()) {
        obj.insert(QString("ScheduleFrequency"), ::OpenAPI::toJsonValue(m_schedule_frequency));
    }
    if (m_start_after_date_time_isSet) {
        obj.insert(QString("StartAfterDateTime"), ::OpenAPI::toJsonValue(m_start_after_date_time));
    }
    if (m_refresh_type.isSet()) {
        obj.insert(QString("RefreshType"), ::OpenAPI::toJsonValue(m_refresh_type));
    }
    if (m_arn_isSet) {
        obj.insert(QString("Arn"), ::OpenAPI::toJsonValue(m_arn));
    }
    return obj;
}

QString OAIUpdateRefreshSchedule_request_Schedule::getScheduleId() const {
    return m_schedule_id;
}
void OAIUpdateRefreshSchedule_request_Schedule::setScheduleId(const QString &schedule_id) {
    m_schedule_id = schedule_id;
    m_schedule_id_isSet = true;
}

bool OAIUpdateRefreshSchedule_request_Schedule::is_schedule_id_Set() const{
    return m_schedule_id_isSet;
}

bool OAIUpdateRefreshSchedule_request_Schedule::is_schedule_id_Valid() const{
    return m_schedule_id_isValid;
}

OAIUpdateRefreshSchedule_request_Schedule_ScheduleFrequency OAIUpdateRefreshSchedule_request_Schedule::getScheduleFrequency() const {
    return m_schedule_frequency;
}
void OAIUpdateRefreshSchedule_request_Schedule::setScheduleFrequency(const OAIUpdateRefreshSchedule_request_Schedule_ScheduleFrequency &schedule_frequency) {
    m_schedule_frequency = schedule_frequency;
    m_schedule_frequency_isSet = true;
}

bool OAIUpdateRefreshSchedule_request_Schedule::is_schedule_frequency_Set() const{
    return m_schedule_frequency_isSet;
}

bool OAIUpdateRefreshSchedule_request_Schedule::is_schedule_frequency_Valid() const{
    return m_schedule_frequency_isValid;
}

QDateTime OAIUpdateRefreshSchedule_request_Schedule::getStartAfterDateTime() const {
    return m_start_after_date_time;
}
void OAIUpdateRefreshSchedule_request_Schedule::setStartAfterDateTime(const QDateTime &start_after_date_time) {
    m_start_after_date_time = start_after_date_time;
    m_start_after_date_time_isSet = true;
}

bool OAIUpdateRefreshSchedule_request_Schedule::is_start_after_date_time_Set() const{
    return m_start_after_date_time_isSet;
}

bool OAIUpdateRefreshSchedule_request_Schedule::is_start_after_date_time_Valid() const{
    return m_start_after_date_time_isValid;
}

OAIIngestionType OAIUpdateRefreshSchedule_request_Schedule::getRefreshType() const {
    return m_refresh_type;
}
void OAIUpdateRefreshSchedule_request_Schedule::setRefreshType(const OAIIngestionType &refresh_type) {
    m_refresh_type = refresh_type;
    m_refresh_type_isSet = true;
}

bool OAIUpdateRefreshSchedule_request_Schedule::is_refresh_type_Set() const{
    return m_refresh_type_isSet;
}

bool OAIUpdateRefreshSchedule_request_Schedule::is_refresh_type_Valid() const{
    return m_refresh_type_isValid;
}

QString OAIUpdateRefreshSchedule_request_Schedule::getArn() const {
    return m_arn;
}
void OAIUpdateRefreshSchedule_request_Schedule::setArn(const QString &arn) {
    m_arn = arn;
    m_arn_isSet = true;
}

bool OAIUpdateRefreshSchedule_request_Schedule::is_arn_Set() const{
    return m_arn_isSet;
}

bool OAIUpdateRefreshSchedule_request_Schedule::is_arn_Valid() const{
    return m_arn_isValid;
}

bool OAIUpdateRefreshSchedule_request_Schedule::isSet() const {
    bool isObjectUpdated = false;
    do {
        if (m_schedule_id_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_schedule_frequency.isSet()) {
            isObjectUpdated = true;
            break;
        }

        if (m_start_after_date_time_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_refresh_type.isSet()) {
            isObjectUpdated = true;
            break;
        }

        if (m_arn_isSet) {
            isObjectUpdated = true;
            break;
        }
    } while (false);
    return isObjectUpdated;
}

bool OAIUpdateRefreshSchedule_request_Schedule::isValid() const {
    // only required properties are required for the object to be considered valid
    return true;
}

} // namespace OpenAPI
