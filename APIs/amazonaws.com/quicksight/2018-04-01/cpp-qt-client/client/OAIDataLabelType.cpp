/**
 * Amazon QuickSight
 * <fullname>Amazon QuickSight API Reference</fullname> <p>Amazon QuickSight is a fully managed, serverless business intelligence service for the Amazon Web Services Cloud that makes it easy to extend data and insights to every user in your organization. This API reference contains documentation for a programming interface that you can use to manage Amazon QuickSight. </p>
 *
 * The version of the OpenAPI document: 2018-04-01
 * Contact: mike.ralphson@gmail.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

#include "OAIDataLabelType.h"

#include <QDebug>
#include <QJsonArray>
#include <QJsonDocument>
#include <QObject>

#include "OAIHelpers.h"

namespace OpenAPI {

OAIDataLabelType::OAIDataLabelType(QString json) {
    this->initializeModel();
    this->fromJson(json);
}

OAIDataLabelType::OAIDataLabelType() {
    this->initializeModel();
}

OAIDataLabelType::~OAIDataLabelType() {}

void OAIDataLabelType::initializeModel() {

    m_field_label_type_isSet = false;
    m_field_label_type_isValid = false;

    m_data_path_label_type_isSet = false;
    m_data_path_label_type_isValid = false;

    m_range_ends_label_type_isSet = false;
    m_range_ends_label_type_isValid = false;

    m_minimum_label_type_isSet = false;
    m_minimum_label_type_isValid = false;

    m_maximum_label_type_isSet = false;
    m_maximum_label_type_isValid = false;
}

void OAIDataLabelType::fromJson(QString jsonString) {
    QByteArray array(jsonString.toStdString().c_str());
    QJsonDocument doc = QJsonDocument::fromJson(array);
    QJsonObject jsonObject = doc.object();
    this->fromJsonObject(jsonObject);
}

void OAIDataLabelType::fromJsonObject(QJsonObject json) {

    m_field_label_type_isValid = ::OpenAPI::fromJsonValue(m_field_label_type, json[QString("FieldLabelType")]);
    m_field_label_type_isSet = !json[QString("FieldLabelType")].isNull() && m_field_label_type_isValid;

    m_data_path_label_type_isValid = ::OpenAPI::fromJsonValue(m_data_path_label_type, json[QString("DataPathLabelType")]);
    m_data_path_label_type_isSet = !json[QString("DataPathLabelType")].isNull() && m_data_path_label_type_isValid;

    m_range_ends_label_type_isValid = ::OpenAPI::fromJsonValue(m_range_ends_label_type, json[QString("RangeEndsLabelType")]);
    m_range_ends_label_type_isSet = !json[QString("RangeEndsLabelType")].isNull() && m_range_ends_label_type_isValid;

    m_minimum_label_type_isValid = ::OpenAPI::fromJsonValue(m_minimum_label_type, json[QString("MinimumLabelType")]);
    m_minimum_label_type_isSet = !json[QString("MinimumLabelType")].isNull() && m_minimum_label_type_isValid;

    m_maximum_label_type_isValid = ::OpenAPI::fromJsonValue(m_maximum_label_type, json[QString("MaximumLabelType")]);
    m_maximum_label_type_isSet = !json[QString("MaximumLabelType")].isNull() && m_maximum_label_type_isValid;
}

QString OAIDataLabelType::asJson() const {
    QJsonObject obj = this->asJsonObject();
    QJsonDocument doc(obj);
    QByteArray bytes = doc.toJson();
    return QString(bytes);
}

QJsonObject OAIDataLabelType::asJsonObject() const {
    QJsonObject obj;
    if (m_field_label_type.isSet()) {
        obj.insert(QString("FieldLabelType"), ::OpenAPI::toJsonValue(m_field_label_type));
    }
    if (m_data_path_label_type.isSet()) {
        obj.insert(QString("DataPathLabelType"), ::OpenAPI::toJsonValue(m_data_path_label_type));
    }
    if (m_range_ends_label_type.isSet()) {
        obj.insert(QString("RangeEndsLabelType"), ::OpenAPI::toJsonValue(m_range_ends_label_type));
    }
    if (m_minimum_label_type.isSet()) {
        obj.insert(QString("MinimumLabelType"), ::OpenAPI::toJsonValue(m_minimum_label_type));
    }
    if (m_maximum_label_type.isSet()) {
        obj.insert(QString("MaximumLabelType"), ::OpenAPI::toJsonValue(m_maximum_label_type));
    }
    return obj;
}

OAIDataLabelType_FieldLabelType OAIDataLabelType::getFieldLabelType() const {
    return m_field_label_type;
}
void OAIDataLabelType::setFieldLabelType(const OAIDataLabelType_FieldLabelType &field_label_type) {
    m_field_label_type = field_label_type;
    m_field_label_type_isSet = true;
}

bool OAIDataLabelType::is_field_label_type_Set() const{
    return m_field_label_type_isSet;
}

bool OAIDataLabelType::is_field_label_type_Valid() const{
    return m_field_label_type_isValid;
}

OAIDataLabelType_DataPathLabelType OAIDataLabelType::getDataPathLabelType() const {
    return m_data_path_label_type;
}
void OAIDataLabelType::setDataPathLabelType(const OAIDataLabelType_DataPathLabelType &data_path_label_type) {
    m_data_path_label_type = data_path_label_type;
    m_data_path_label_type_isSet = true;
}

bool OAIDataLabelType::is_data_path_label_type_Set() const{
    return m_data_path_label_type_isSet;
}

bool OAIDataLabelType::is_data_path_label_type_Valid() const{
    return m_data_path_label_type_isValid;
}

OAIDataLabelType_RangeEndsLabelType OAIDataLabelType::getRangeEndsLabelType() const {
    return m_range_ends_label_type;
}
void OAIDataLabelType::setRangeEndsLabelType(const OAIDataLabelType_RangeEndsLabelType &range_ends_label_type) {
    m_range_ends_label_type = range_ends_label_type;
    m_range_ends_label_type_isSet = true;
}

bool OAIDataLabelType::is_range_ends_label_type_Set() const{
    return m_range_ends_label_type_isSet;
}

bool OAIDataLabelType::is_range_ends_label_type_Valid() const{
    return m_range_ends_label_type_isValid;
}

OAIDataLabelType_MinimumLabelType OAIDataLabelType::getMinimumLabelType() const {
    return m_minimum_label_type;
}
void OAIDataLabelType::setMinimumLabelType(const OAIDataLabelType_MinimumLabelType &minimum_label_type) {
    m_minimum_label_type = minimum_label_type;
    m_minimum_label_type_isSet = true;
}

bool OAIDataLabelType::is_minimum_label_type_Set() const{
    return m_minimum_label_type_isSet;
}

bool OAIDataLabelType::is_minimum_label_type_Valid() const{
    return m_minimum_label_type_isValid;
}

OAIDataLabelType_MaximumLabelType OAIDataLabelType::getMaximumLabelType() const {
    return m_maximum_label_type;
}
void OAIDataLabelType::setMaximumLabelType(const OAIDataLabelType_MaximumLabelType &maximum_label_type) {
    m_maximum_label_type = maximum_label_type;
    m_maximum_label_type_isSet = true;
}

bool OAIDataLabelType::is_maximum_label_type_Set() const{
    return m_maximum_label_type_isSet;
}

bool OAIDataLabelType::is_maximum_label_type_Valid() const{
    return m_maximum_label_type_isValid;
}

bool OAIDataLabelType::isSet() const {
    bool isObjectUpdated = false;
    do {
        if (m_field_label_type.isSet()) {
            isObjectUpdated = true;
            break;
        }

        if (m_data_path_label_type.isSet()) {
            isObjectUpdated = true;
            break;
        }

        if (m_range_ends_label_type.isSet()) {
            isObjectUpdated = true;
            break;
        }

        if (m_minimum_label_type.isSet()) {
            isObjectUpdated = true;
            break;
        }

        if (m_maximum_label_type.isSet()) {
            isObjectUpdated = true;
            break;
        }
    } while (false);
    return isObjectUpdated;
}

bool OAIDataLabelType::isValid() const {
    // only required properties are required for the object to be considered valid
    return true;
}

} // namespace OpenAPI
