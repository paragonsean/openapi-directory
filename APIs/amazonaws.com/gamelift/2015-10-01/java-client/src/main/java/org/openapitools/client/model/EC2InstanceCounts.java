/*
 * Amazon GameLift
 * <p>Amazon GameLift provides solutions for hosting session-based multiplayer game servers in the cloud, including tools for deploying, operating, and scaling game servers. Built on Amazon Web Services global computing infrastructure, GameLift helps you deliver high-performance, high-reliability, low-cost game servers while dynamically scaling your resource usage to meet player demand. </p> <p> <b>About Amazon GameLift solutions</b> </p> <p>Get more information on these Amazon GameLift solutions in the <a href=\"https://docs.aws.amazon.com/gamelift/latest/developerguide/\">Amazon GameLift Developer Guide</a>.</p> <ul> <li> <p>Amazon GameLift managed hosting -- Amazon GameLift offers a fully managed service to set up and maintain computing machines for hosting, manage game session and player session life cycle, and handle security, storage, and performance tracking. You can use automatic scaling tools to balance player demand and hosting costs, configure your game session management to minimize player latency, and add FlexMatch for matchmaking.</p> </li> <li> <p>Managed hosting with Realtime Servers -- With Amazon GameLift Realtime Servers, you can quickly configure and set up ready-to-go game servers for your game. Realtime Servers provides a game server framework with core Amazon GameLift infrastructure already built in. Then use the full range of Amazon GameLift managed hosting features, including FlexMatch, for your game.</p> </li> <li> <p>Amazon GameLift FleetIQ -- Use Amazon GameLift FleetIQ as a standalone service while hosting your games using EC2 instances and Auto Scaling groups. Amazon GameLift FleetIQ provides optimizations for game hosting, including boosting the viability of low-cost Spot Instances gaming. For a complete solution, pair the Amazon GameLift FleetIQ and FlexMatch standalone services.</p> </li> <li> <p>Amazon GameLift FlexMatch -- Add matchmaking to your game hosting solution. FlexMatch is a customizable matchmaking service for multiplayer games. Use FlexMatch as integrated with Amazon GameLift managed hosting or incorporate FlexMatch as a standalone service into your own hosting solution.</p> </li> </ul> <p> <b>About this API Reference</b> </p> <p>This reference guide describes the low-level service API for Amazon GameLift. With each topic in this guide, you can find links to language-specific SDK guides and the Amazon Web Services CLI reference. Useful links:</p> <ul> <li> <p> <a href=\"https://docs.aws.amazon.com/gamelift/latest/developerguide/reference-awssdk.html\">Amazon GameLift API operations listed by tasks</a> </p> </li> <li> <p> <a href=\"https://docs.aws.amazon.com/gamelift/latest/developerguide/gamelift-components.html\"> Amazon GameLift tools and resources</a> </p> </li> </ul>
 *
 * The version of the OpenAPI document: 2015-10-01
 * Contact: mike.ralphson@gmail.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package org.openapitools.client.model;

import java.util.Objects;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;
import java.util.Arrays;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonArray;
import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;
import com.google.gson.TypeAdapterFactory;
import com.google.gson.reflect.TypeToken;
import com.google.gson.TypeAdapter;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;

import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import org.openapitools.client.JSON;

/**
 * Resource capacity settings. Fleet capacity is measured in Amazon EC2 instances. Pending and terminating counts are non-zero when the fleet capacity is adjusting to a scaling event or if access to resources is temporarily affected.
 */
@javax.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen", date = "2024-10-12T12:09:49.380048-04:00[America/New_York]", comments = "Generator version: 7.9.0")
public class EC2InstanceCounts {
  public static final String SERIALIZED_NAME_D_E_S_I_R_E_D = "DESIRED";
  @SerializedName(SERIALIZED_NAME_D_E_S_I_R_E_D)
  private Integer DESIRED;

  public static final String SERIALIZED_NAME_M_I_N_I_M_U_M = "MINIMUM";
  @SerializedName(SERIALIZED_NAME_M_I_N_I_M_U_M)
  private Integer MINIMUM;

  public static final String SERIALIZED_NAME_M_A_X_I_M_U_M = "MAXIMUM";
  @SerializedName(SERIALIZED_NAME_M_A_X_I_M_U_M)
  private Integer MAXIMUM;

  public static final String SERIALIZED_NAME_P_E_N_D_I_N_G = "PENDING";
  @SerializedName(SERIALIZED_NAME_P_E_N_D_I_N_G)
  private Integer PENDING;

  public static final String SERIALIZED_NAME_A_C_T_I_V_E = "ACTIVE";
  @SerializedName(SERIALIZED_NAME_A_C_T_I_V_E)
  private Integer ACTIVE;

  public static final String SERIALIZED_NAME_I_D_L_E = "IDLE";
  @SerializedName(SERIALIZED_NAME_I_D_L_E)
  private Integer IDLE;

  public static final String SERIALIZED_NAME_T_E_R_M_I_N_A_T_I_N_G = "TERMINATING";
  @SerializedName(SERIALIZED_NAME_T_E_R_M_I_N_A_T_I_N_G)
  private Integer TERMINATING;

  public EC2InstanceCounts() {
  }

  public EC2InstanceCounts DESIRED(Integer DESIRED) {
    this.DESIRED = DESIRED;
    return this;
  }

  /**
   * Get DESIRED
   * @return DESIRED
   */
  @javax.annotation.Nullable
  public Integer getDESIRED() {
    return DESIRED;
  }

  public void setDESIRED(Integer DESIRED) {
    this.DESIRED = DESIRED;
  }


  public EC2InstanceCounts MINIMUM(Integer MINIMUM) {
    this.MINIMUM = MINIMUM;
    return this;
  }

  /**
   * Get MINIMUM
   * @return MINIMUM
   */
  @javax.annotation.Nullable
  public Integer getMINIMUM() {
    return MINIMUM;
  }

  public void setMINIMUM(Integer MINIMUM) {
    this.MINIMUM = MINIMUM;
  }


  public EC2InstanceCounts MAXIMUM(Integer MAXIMUM) {
    this.MAXIMUM = MAXIMUM;
    return this;
  }

  /**
   * Get MAXIMUM
   * @return MAXIMUM
   */
  @javax.annotation.Nullable
  public Integer getMAXIMUM() {
    return MAXIMUM;
  }

  public void setMAXIMUM(Integer MAXIMUM) {
    this.MAXIMUM = MAXIMUM;
  }


  public EC2InstanceCounts PENDING(Integer PENDING) {
    this.PENDING = PENDING;
    return this;
  }

  /**
   * Get PENDING
   * @return PENDING
   */
  @javax.annotation.Nullable
  public Integer getPENDING() {
    return PENDING;
  }

  public void setPENDING(Integer PENDING) {
    this.PENDING = PENDING;
  }


  public EC2InstanceCounts ACTIVE(Integer ACTIVE) {
    this.ACTIVE = ACTIVE;
    return this;
  }

  /**
   * Get ACTIVE
   * @return ACTIVE
   */
  @javax.annotation.Nullable
  public Integer getACTIVE() {
    return ACTIVE;
  }

  public void setACTIVE(Integer ACTIVE) {
    this.ACTIVE = ACTIVE;
  }


  public EC2InstanceCounts IDLE(Integer IDLE) {
    this.IDLE = IDLE;
    return this;
  }

  /**
   * Get IDLE
   * @return IDLE
   */
  @javax.annotation.Nullable
  public Integer getIDLE() {
    return IDLE;
  }

  public void setIDLE(Integer IDLE) {
    this.IDLE = IDLE;
  }


  public EC2InstanceCounts TERMINATING(Integer TERMINATING) {
    this.TERMINATING = TERMINATING;
    return this;
  }

  /**
   * Get TERMINATING
   * @return TERMINATING
   */
  @javax.annotation.Nullable
  public Integer getTERMINATING() {
    return TERMINATING;
  }

  public void setTERMINATING(Integer TERMINATING) {
    this.TERMINATING = TERMINATING;
  }



  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    EC2InstanceCounts ec2InstanceCounts = (EC2InstanceCounts) o;
    return Objects.equals(this.DESIRED, ec2InstanceCounts.DESIRED) &&
        Objects.equals(this.MINIMUM, ec2InstanceCounts.MINIMUM) &&
        Objects.equals(this.MAXIMUM, ec2InstanceCounts.MAXIMUM) &&
        Objects.equals(this.PENDING, ec2InstanceCounts.PENDING) &&
        Objects.equals(this.ACTIVE, ec2InstanceCounts.ACTIVE) &&
        Objects.equals(this.IDLE, ec2InstanceCounts.IDLE) &&
        Objects.equals(this.TERMINATING, ec2InstanceCounts.TERMINATING);
  }

  @Override
  public int hashCode() {
    return Objects.hash(DESIRED, MINIMUM, MAXIMUM, PENDING, ACTIVE, IDLE, TERMINATING);
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class EC2InstanceCounts {\n");
    sb.append("    DESIRED: ").append(toIndentedString(DESIRED)).append("\n");
    sb.append("    MINIMUM: ").append(toIndentedString(MINIMUM)).append("\n");
    sb.append("    MAXIMUM: ").append(toIndentedString(MAXIMUM)).append("\n");
    sb.append("    PENDING: ").append(toIndentedString(PENDING)).append("\n");
    sb.append("    ACTIVE: ").append(toIndentedString(ACTIVE)).append("\n");
    sb.append("    IDLE: ").append(toIndentedString(IDLE)).append("\n");
    sb.append("    TERMINATING: ").append(toIndentedString(TERMINATING)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }


  public static HashSet<String> openapiFields;
  public static HashSet<String> openapiRequiredFields;

  static {
    // a set of all properties/fields (JSON key names)
    openapiFields = new HashSet<String>();
    openapiFields.add("DESIRED");
    openapiFields.add("MINIMUM");
    openapiFields.add("MAXIMUM");
    openapiFields.add("PENDING");
    openapiFields.add("ACTIVE");
    openapiFields.add("IDLE");
    openapiFields.add("TERMINATING");

    // a set of required properties/fields (JSON key names)
    openapiRequiredFields = new HashSet<String>();
  }

  /**
   * Validates the JSON Element and throws an exception if issues found
   *
   * @param jsonElement JSON Element
   * @throws IOException if the JSON Element is invalid with respect to EC2InstanceCounts
   */
  public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      if (jsonElement == null) {
        if (!EC2InstanceCounts.openapiRequiredFields.isEmpty()) { // has required fields but JSON element is null
          throw new IllegalArgumentException(String.format("The required field(s) %s in EC2InstanceCounts is not found in the empty JSON string", EC2InstanceCounts.openapiRequiredFields.toString()));
        }
      }

      Set<Map.Entry<String, JsonElement>> entries = jsonElement.getAsJsonObject().entrySet();
      // check to see if the JSON string contains additional fields
      for (Map.Entry<String, JsonElement> entry : entries) {
        if (!EC2InstanceCounts.openapiFields.contains(entry.getKey())) {
          throw new IllegalArgumentException(String.format("The field `%s` in the JSON string is not defined in the `EC2InstanceCounts` properties. JSON: %s", entry.getKey(), jsonElement.toString()));
        }
      }
        JsonObject jsonObj = jsonElement.getAsJsonObject();
      // validate the optional field `DESIRED`
      if (jsonObj.get("DESIRED") != null && !jsonObj.get("DESIRED").isJsonNull()) {
        Integer.validateJsonElement(jsonObj.get("DESIRED"));
      }
      // validate the optional field `MINIMUM`
      if (jsonObj.get("MINIMUM") != null && !jsonObj.get("MINIMUM").isJsonNull()) {
        Integer.validateJsonElement(jsonObj.get("MINIMUM"));
      }
      // validate the optional field `MAXIMUM`
      if (jsonObj.get("MAXIMUM") != null && !jsonObj.get("MAXIMUM").isJsonNull()) {
        Integer.validateJsonElement(jsonObj.get("MAXIMUM"));
      }
      // validate the optional field `PENDING`
      if (jsonObj.get("PENDING") != null && !jsonObj.get("PENDING").isJsonNull()) {
        Integer.validateJsonElement(jsonObj.get("PENDING"));
      }
      // validate the optional field `ACTIVE`
      if (jsonObj.get("ACTIVE") != null && !jsonObj.get("ACTIVE").isJsonNull()) {
        Integer.validateJsonElement(jsonObj.get("ACTIVE"));
      }
      // validate the optional field `IDLE`
      if (jsonObj.get("IDLE") != null && !jsonObj.get("IDLE").isJsonNull()) {
        Integer.validateJsonElement(jsonObj.get("IDLE"));
      }
      // validate the optional field `TERMINATING`
      if (jsonObj.get("TERMINATING") != null && !jsonObj.get("TERMINATING").isJsonNull()) {
        Integer.validateJsonElement(jsonObj.get("TERMINATING"));
      }
  }

  public static class CustomTypeAdapterFactory implements TypeAdapterFactory {
    @SuppressWarnings("unchecked")
    @Override
    public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
       if (!EC2InstanceCounts.class.isAssignableFrom(type.getRawType())) {
         return null; // this class only serializes 'EC2InstanceCounts' and its subtypes
       }
       final TypeAdapter<JsonElement> elementAdapter = gson.getAdapter(JsonElement.class);
       final TypeAdapter<EC2InstanceCounts> thisAdapter
                        = gson.getDelegateAdapter(this, TypeToken.get(EC2InstanceCounts.class));

       return (TypeAdapter<T>) new TypeAdapter<EC2InstanceCounts>() {
           @Override
           public void write(JsonWriter out, EC2InstanceCounts value) throws IOException {
             JsonObject obj = thisAdapter.toJsonTree(value).getAsJsonObject();
             elementAdapter.write(out, obj);
           }

           @Override
           public EC2InstanceCounts read(JsonReader in) throws IOException {
             JsonElement jsonElement = elementAdapter.read(in);
             validateJsonElement(jsonElement);
             return thisAdapter.fromJsonTree(jsonElement);
           }

       }.nullSafe();
    }
  }

  /**
   * Create an instance of EC2InstanceCounts given an JSON string
   *
   * @param jsonString JSON string
   * @return An instance of EC2InstanceCounts
   * @throws IOException if the JSON string is invalid with respect to EC2InstanceCounts
   */
  public static EC2InstanceCounts fromJson(String jsonString) throws IOException {
    return JSON.getGson().fromJson(jsonString, EC2InstanceCounts.class);
  }

  /**
   * Convert an instance of EC2InstanceCounts to an JSON string
   *
   * @return JSON string
   */
  public String toJson() {
    return JSON.getGson().toJson(this);
  }
}

