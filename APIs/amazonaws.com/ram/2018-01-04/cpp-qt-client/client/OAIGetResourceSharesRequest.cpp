/**
 * AWS Resource Access Manager
 * <p>This is the <i>Resource Access Manager API Reference</i>. This documentation provides descriptions and syntax for each of the actions and data types in RAM. RAM is a service that helps you securely share your Amazon Web Services resources to other Amazon Web Services accounts. If you use Organizations to manage your accounts, then you can share your resources with your entire organization or to organizational units (OUs). For supported resource types, you can also share resources with individual Identity and Access Management (IAM) roles and users. </p> <p>To learn more about RAM, see the following resources:</p> <ul> <li> <p> <a href=\"http://aws.amazon.com/ram\">Resource Access Manager product page</a> </p> </li> <li> <p> <a href=\"https://docs.aws.amazon.com/ram/latest/userguide/\">Resource Access Manager User Guide</a> </p> </li> </ul>
 *
 * The version of the OpenAPI document: 2018-01-04
 * Contact: mike.ralphson@gmail.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

#include "OAIGetResourceSharesRequest.h"

#include <QDebug>
#include <QJsonArray>
#include <QJsonDocument>
#include <QObject>

#include "OAIHelpers.h"

namespace OpenAPI {

OAIGetResourceSharesRequest::OAIGetResourceSharesRequest(QString json) {
    this->initializeModel();
    this->fromJson(json);
}

OAIGetResourceSharesRequest::OAIGetResourceSharesRequest() {
    this->initializeModel();
}

OAIGetResourceSharesRequest::~OAIGetResourceSharesRequest() {}

void OAIGetResourceSharesRequest::initializeModel() {

    m_resource_share_arns_isSet = false;
    m_resource_share_arns_isValid = false;

    m_resource_share_status_isSet = false;
    m_resource_share_status_isValid = false;

    m_resource_owner_isSet = false;
    m_resource_owner_isValid = false;

    m_name_isSet = false;
    m_name_isValid = false;

    m_tag_filters_isSet = false;
    m_tag_filters_isValid = false;

    m_next_token_isSet = false;
    m_next_token_isValid = false;

    m_max_results_isSet = false;
    m_max_results_isValid = false;

    m_permission_arn_isSet = false;
    m_permission_arn_isValid = false;

    m_permission_version_isSet = false;
    m_permission_version_isValid = false;
}

void OAIGetResourceSharesRequest::fromJson(QString jsonString) {
    QByteArray array(jsonString.toStdString().c_str());
    QJsonDocument doc = QJsonDocument::fromJson(array);
    QJsonObject jsonObject = doc.object();
    this->fromJsonObject(jsonObject);
}

void OAIGetResourceSharesRequest::fromJsonObject(QJsonObject json) {

    m_resource_share_arns_isValid = ::OpenAPI::fromJsonValue(m_resource_share_arns, json[QString("resourceShareArns")]);
    m_resource_share_arns_isSet = !json[QString("resourceShareArns")].isNull() && m_resource_share_arns_isValid;

    m_resource_share_status_isValid = ::OpenAPI::fromJsonValue(m_resource_share_status, json[QString("resourceShareStatus")]);
    m_resource_share_status_isSet = !json[QString("resourceShareStatus")].isNull() && m_resource_share_status_isValid;

    m_resource_owner_isValid = ::OpenAPI::fromJsonValue(m_resource_owner, json[QString("resourceOwner")]);
    m_resource_owner_isSet = !json[QString("resourceOwner")].isNull() && m_resource_owner_isValid;

    m_name_isValid = ::OpenAPI::fromJsonValue(m_name, json[QString("name")]);
    m_name_isSet = !json[QString("name")].isNull() && m_name_isValid;

    m_tag_filters_isValid = ::OpenAPI::fromJsonValue(m_tag_filters, json[QString("tagFilters")]);
    m_tag_filters_isSet = !json[QString("tagFilters")].isNull() && m_tag_filters_isValid;

    m_next_token_isValid = ::OpenAPI::fromJsonValue(m_next_token, json[QString("nextToken")]);
    m_next_token_isSet = !json[QString("nextToken")].isNull() && m_next_token_isValid;

    m_max_results_isValid = ::OpenAPI::fromJsonValue(m_max_results, json[QString("maxResults")]);
    m_max_results_isSet = !json[QString("maxResults")].isNull() && m_max_results_isValid;

    m_permission_arn_isValid = ::OpenAPI::fromJsonValue(m_permission_arn, json[QString("permissionArn")]);
    m_permission_arn_isSet = !json[QString("permissionArn")].isNull() && m_permission_arn_isValid;

    m_permission_version_isValid = ::OpenAPI::fromJsonValue(m_permission_version, json[QString("permissionVersion")]);
    m_permission_version_isSet = !json[QString("permissionVersion")].isNull() && m_permission_version_isValid;
}

QString OAIGetResourceSharesRequest::asJson() const {
    QJsonObject obj = this->asJsonObject();
    QJsonDocument doc(obj);
    QByteArray bytes = doc.toJson();
    return QString(bytes);
}

QJsonObject OAIGetResourceSharesRequest::asJsonObject() const {
    QJsonObject obj;
    if (m_resource_share_arns.isSet()) {
        obj.insert(QString("resourceShareArns"), ::OpenAPI::toJsonValue(m_resource_share_arns));
    }
    if (m_resource_share_status.isSet()) {
        obj.insert(QString("resourceShareStatus"), ::OpenAPI::toJsonValue(m_resource_share_status));
    }
    if (m_resource_owner.isSet()) {
        obj.insert(QString("resourceOwner"), ::OpenAPI::toJsonValue(m_resource_owner));
    }
    if (m_name_isSet) {
        obj.insert(QString("name"), ::OpenAPI::toJsonValue(m_name));
    }
    if (m_tag_filters.isSet()) {
        obj.insert(QString("tagFilters"), ::OpenAPI::toJsonValue(m_tag_filters));
    }
    if (m_next_token_isSet) {
        obj.insert(QString("nextToken"), ::OpenAPI::toJsonValue(m_next_token));
    }
    if (m_max_results_isSet) {
        obj.insert(QString("maxResults"), ::OpenAPI::toJsonValue(m_max_results));
    }
    if (m_permission_arn_isSet) {
        obj.insert(QString("permissionArn"), ::OpenAPI::toJsonValue(m_permission_arn));
    }
    if (m_permission_version_isSet) {
        obj.insert(QString("permissionVersion"), ::OpenAPI::toJsonValue(m_permission_version));
    }
    return obj;
}

QList OAIGetResourceSharesRequest::getResourceShareArns() const {
    return m_resource_share_arns;
}
void OAIGetResourceSharesRequest::setResourceShareArns(const QList &resource_share_arns) {
    m_resource_share_arns = resource_share_arns;
    m_resource_share_arns_isSet = true;
}

bool OAIGetResourceSharesRequest::is_resource_share_arns_Set() const{
    return m_resource_share_arns_isSet;
}

bool OAIGetResourceSharesRequest::is_resource_share_arns_Valid() const{
    return m_resource_share_arns_isValid;
}

OAIResourceShareStatus OAIGetResourceSharesRequest::getResourceShareStatus() const {
    return m_resource_share_status;
}
void OAIGetResourceSharesRequest::setResourceShareStatus(const OAIResourceShareStatus &resource_share_status) {
    m_resource_share_status = resource_share_status;
    m_resource_share_status_isSet = true;
}

bool OAIGetResourceSharesRequest::is_resource_share_status_Set() const{
    return m_resource_share_status_isSet;
}

bool OAIGetResourceSharesRequest::is_resource_share_status_Valid() const{
    return m_resource_share_status_isValid;
}

OAIResourceOwner OAIGetResourceSharesRequest::getResourceOwner() const {
    return m_resource_owner;
}
void OAIGetResourceSharesRequest::setResourceOwner(const OAIResourceOwner &resource_owner) {
    m_resource_owner = resource_owner;
    m_resource_owner_isSet = true;
}

bool OAIGetResourceSharesRequest::is_resource_owner_Set() const{
    return m_resource_owner_isSet;
}

bool OAIGetResourceSharesRequest::is_resource_owner_Valid() const{
    return m_resource_owner_isValid;
}

QString OAIGetResourceSharesRequest::getName() const {
    return m_name;
}
void OAIGetResourceSharesRequest::setName(const QString &name) {
    m_name = name;
    m_name_isSet = true;
}

bool OAIGetResourceSharesRequest::is_name_Set() const{
    return m_name_isSet;
}

bool OAIGetResourceSharesRequest::is_name_Valid() const{
    return m_name_isValid;
}

QList OAIGetResourceSharesRequest::getTagFilters() const {
    return m_tag_filters;
}
void OAIGetResourceSharesRequest::setTagFilters(const QList &tag_filters) {
    m_tag_filters = tag_filters;
    m_tag_filters_isSet = true;
}

bool OAIGetResourceSharesRequest::is_tag_filters_Set() const{
    return m_tag_filters_isSet;
}

bool OAIGetResourceSharesRequest::is_tag_filters_Valid() const{
    return m_tag_filters_isValid;
}

QString OAIGetResourceSharesRequest::getNextToken() const {
    return m_next_token;
}
void OAIGetResourceSharesRequest::setNextToken(const QString &next_token) {
    m_next_token = next_token;
    m_next_token_isSet = true;
}

bool OAIGetResourceSharesRequest::is_next_token_Set() const{
    return m_next_token_isSet;
}

bool OAIGetResourceSharesRequest::is_next_token_Valid() const{
    return m_next_token_isValid;
}

qint32 OAIGetResourceSharesRequest::getMaxResults() const {
    return m_max_results;
}
void OAIGetResourceSharesRequest::setMaxResults(const qint32 &max_results) {
    m_max_results = max_results;
    m_max_results_isSet = true;
}

bool OAIGetResourceSharesRequest::is_max_results_Set() const{
    return m_max_results_isSet;
}

bool OAIGetResourceSharesRequest::is_max_results_Valid() const{
    return m_max_results_isValid;
}

QString OAIGetResourceSharesRequest::getPermissionArn() const {
    return m_permission_arn;
}
void OAIGetResourceSharesRequest::setPermissionArn(const QString &permission_arn) {
    m_permission_arn = permission_arn;
    m_permission_arn_isSet = true;
}

bool OAIGetResourceSharesRequest::is_permission_arn_Set() const{
    return m_permission_arn_isSet;
}

bool OAIGetResourceSharesRequest::is_permission_arn_Valid() const{
    return m_permission_arn_isValid;
}

qint32 OAIGetResourceSharesRequest::getPermissionVersion() const {
    return m_permission_version;
}
void OAIGetResourceSharesRequest::setPermissionVersion(const qint32 &permission_version) {
    m_permission_version = permission_version;
    m_permission_version_isSet = true;
}

bool OAIGetResourceSharesRequest::is_permission_version_Set() const{
    return m_permission_version_isSet;
}

bool OAIGetResourceSharesRequest::is_permission_version_Valid() const{
    return m_permission_version_isValid;
}

bool OAIGetResourceSharesRequest::isSet() const {
    bool isObjectUpdated = false;
    do {
        if (m_resource_share_arns.isSet()) {
            isObjectUpdated = true;
            break;
        }

        if (m_resource_share_status.isSet()) {
            isObjectUpdated = true;
            break;
        }

        if (m_resource_owner.isSet()) {
            isObjectUpdated = true;
            break;
        }

        if (m_name_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_tag_filters.isSet()) {
            isObjectUpdated = true;
            break;
        }

        if (m_next_token_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_max_results_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_permission_arn_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_permission_version_isSet) {
            isObjectUpdated = true;
            break;
        }
    } while (false);
    return isObjectUpdated;
}

bool OAIGetResourceSharesRequest::isValid() const {
    // only required properties are required for the object to be considered valid
    return m_resource_owner_isValid && true;
}

} // namespace OpenAPI
