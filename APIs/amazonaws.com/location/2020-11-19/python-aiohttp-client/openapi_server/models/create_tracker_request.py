# coding: utf-8

from datetime import date, datetime

from typing import List, Dict, Type

from openapi_server.models.base_model import Model
import re
from openapi_server import util


class CreateTrackerRequest(Model):
    """NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).

    Do not edit the class manually.
    """

    def __init__(self, description: str=None, event_bridge_enabled: bool=None, kms_key_id: str=None, position_filtering: str=None, pricing_plan: str=None, pricing_plan_data_source: str=None, tags: Dict[str, str]=None, tracker_name: str=None):
        """CreateTrackerRequest - a model defined in OpenAPI

        :param description: The description of this CreateTrackerRequest.
        :param event_bridge_enabled: The event_bridge_enabled of this CreateTrackerRequest.
        :param kms_key_id: The kms_key_id of this CreateTrackerRequest.
        :param position_filtering: The position_filtering of this CreateTrackerRequest.
        :param pricing_plan: The pricing_plan of this CreateTrackerRequest.
        :param pricing_plan_data_source: The pricing_plan_data_source of this CreateTrackerRequest.
        :param tags: The tags of this CreateTrackerRequest.
        :param tracker_name: The tracker_name of this CreateTrackerRequest.
        """
        self.openapi_types = {
            'description': str,
            'event_bridge_enabled': bool,
            'kms_key_id': str,
            'position_filtering': str,
            'pricing_plan': str,
            'pricing_plan_data_source': str,
            'tags': Dict[str, str],
            'tracker_name': str
        }

        self.attribute_map = {
            'description': 'Description',
            'event_bridge_enabled': 'EventBridgeEnabled',
            'kms_key_id': 'KmsKeyId',
            'position_filtering': 'PositionFiltering',
            'pricing_plan': 'PricingPlan',
            'pricing_plan_data_source': 'PricingPlanDataSource',
            'tags': 'Tags',
            'tracker_name': 'TrackerName'
        }

        self._description = description
        self._event_bridge_enabled = event_bridge_enabled
        self._kms_key_id = kms_key_id
        self._position_filtering = position_filtering
        self._pricing_plan = pricing_plan
        self._pricing_plan_data_source = pricing_plan_data_source
        self._tags = tags
        self._tracker_name = tracker_name

    @classmethod
    def from_dict(cls, dikt: dict) -> 'CreateTrackerRequest':
        """Returns the dict as a model

        :param dikt: A dict.
        :return: The CreateTracker_request of this CreateTrackerRequest.
        """
        return util.deserialize_model(dikt, cls)

    @property
    def description(self):
        """Gets the description of this CreateTrackerRequest.

        An optional description for the tracker resource.

        :return: The description of this CreateTrackerRequest.
        :rtype: str
        """
        return self._description

    @description.setter
    def description(self, description):
        """Sets the description of this CreateTrackerRequest.

        An optional description for the tracker resource.

        :param description: The description of this CreateTrackerRequest.
        :type description: str
        """
        if description is not None and len(description) > 1000:
            raise ValueError("Invalid value for `description`, length must be less than or equal to `1000`")
        if description is not None and len(description) < 0:
            raise ValueError("Invalid value for `description`, length must be greater than or equal to `0`")

        self._description = description

    @property
    def event_bridge_enabled(self):
        """Gets the event_bridge_enabled of this CreateTrackerRequest.

        <p>Whether to enable position <code>UPDATE</code> events from this tracker to be sent to EventBridge.</p> <note> <p>You do not need enable this feature to get <code>ENTER</code> and <code>EXIT</code> events for geofences with this tracker. Those events are always sent to EventBridge.</p> </note>

        :return: The event_bridge_enabled of this CreateTrackerRequest.
        :rtype: bool
        """
        return self._event_bridge_enabled

    @event_bridge_enabled.setter
    def event_bridge_enabled(self, event_bridge_enabled):
        """Sets the event_bridge_enabled of this CreateTrackerRequest.

        <p>Whether to enable position <code>UPDATE</code> events from this tracker to be sent to EventBridge.</p> <note> <p>You do not need enable this feature to get <code>ENTER</code> and <code>EXIT</code> events for geofences with this tracker. Those events are always sent to EventBridge.</p> </note>

        :param event_bridge_enabled: The event_bridge_enabled of this CreateTrackerRequest.
        :type event_bridge_enabled: bool
        """

        self._event_bridge_enabled = event_bridge_enabled

    @property
    def kms_key_id(self):
        """Gets the kms_key_id of this CreateTrackerRequest.

        A key identifier for an <a href=\"https://docs.aws.amazon.com/kms/latest/developerguide/create-keys.html\">Amazon Web Services KMS customer managed key</a>. Enter a key ID, key ARN, alias name, or alias ARN.

        :return: The kms_key_id of this CreateTrackerRequest.
        :rtype: str
        """
        return self._kms_key_id

    @kms_key_id.setter
    def kms_key_id(self, kms_key_id):
        """Sets the kms_key_id of this CreateTrackerRequest.

        A key identifier for an <a href=\"https://docs.aws.amazon.com/kms/latest/developerguide/create-keys.html\">Amazon Web Services KMS customer managed key</a>. Enter a key ID, key ARN, alias name, or alias ARN.

        :param kms_key_id: The kms_key_id of this CreateTrackerRequest.
        :type kms_key_id: str
        """
        if kms_key_id is not None and len(kms_key_id) > 2048:
            raise ValueError("Invalid value for `kms_key_id`, length must be less than or equal to `2048`")
        if kms_key_id is not None and len(kms_key_id) < 1:
            raise ValueError("Invalid value for `kms_key_id`, length must be greater than or equal to `1`")

        self._kms_key_id = kms_key_id

    @property
    def position_filtering(self):
        """Gets the position_filtering of this CreateTrackerRequest.

        <p>Specifies the position filtering for the tracker resource.</p> <p>Valid values:</p> <ul> <li> <p> <code>TimeBased</code> - Location updates are evaluated against linked geofence collections, but not every location update is stored. If your update frequency is more often than 30 seconds, only one update per 30 seconds is stored for each unique device ID. </p> </li> <li> <p> <code>DistanceBased</code> - If the device has moved less than 30 m (98.4 ft), location updates are ignored. Location updates within this area are neither evaluated against linked geofence collections, nor stored. This helps control costs by reducing the number of geofence evaluations and historical device positions to paginate through. Distance-based filtering can also reduce the effects of GPS noise when displaying device trajectories on a map. </p> </li> <li> <p> <code>AccuracyBased</code> - If the device has moved less than the measured accuracy, location updates are ignored. For example, if two consecutive updates from a device have a horizontal accuracy of 5 m and 10 m, the second update is ignored if the device has moved less than 15 m. Ignored location updates are neither evaluated against linked geofence collections, nor stored. This can reduce the effects of GPS noise when displaying device trajectories on a map, and can help control your costs by reducing the number of geofence evaluations. </p> </li> </ul> <p>This field is optional. If not specified, the default value is <code>TimeBased</code>.</p>

        :return: The position_filtering of this CreateTrackerRequest.
        :rtype: str
        """
        return self._position_filtering

    @position_filtering.setter
    def position_filtering(self, position_filtering):
        """Sets the position_filtering of this CreateTrackerRequest.

        <p>Specifies the position filtering for the tracker resource.</p> <p>Valid values:</p> <ul> <li> <p> <code>TimeBased</code> - Location updates are evaluated against linked geofence collections, but not every location update is stored. If your update frequency is more often than 30 seconds, only one update per 30 seconds is stored for each unique device ID. </p> </li> <li> <p> <code>DistanceBased</code> - If the device has moved less than 30 m (98.4 ft), location updates are ignored. Location updates within this area are neither evaluated against linked geofence collections, nor stored. This helps control costs by reducing the number of geofence evaluations and historical device positions to paginate through. Distance-based filtering can also reduce the effects of GPS noise when displaying device trajectories on a map. </p> </li> <li> <p> <code>AccuracyBased</code> - If the device has moved less than the measured accuracy, location updates are ignored. For example, if two consecutive updates from a device have a horizontal accuracy of 5 m and 10 m, the second update is ignored if the device has moved less than 15 m. Ignored location updates are neither evaluated against linked geofence collections, nor stored. This can reduce the effects of GPS noise when displaying device trajectories on a map, and can help control your costs by reducing the number of geofence evaluations. </p> </li> </ul> <p>This field is optional. If not specified, the default value is <code>TimeBased</code>.</p>

        :param position_filtering: The position_filtering of this CreateTrackerRequest.
        :type position_filtering: str
        """
        allowed_values = ["TimeBased", "DistanceBased", "AccuracyBased"]  # noqa: E501
        if position_filtering not in allowed_values:
            raise ValueError(
                "Invalid value for `position_filtering` ({0}), must be one of {1}"
                .format(position_filtering, allowed_values)
            )

        self._position_filtering = position_filtering

    @property
    def pricing_plan(self):
        """Gets the pricing_plan of this CreateTrackerRequest.

        No longer used. If included, the only allowed value is <code>RequestBasedUsage</code>.

        :return: The pricing_plan of this CreateTrackerRequest.
        :rtype: str
        """
        return self._pricing_plan

    @pricing_plan.setter
    def pricing_plan(self, pricing_plan):
        """Sets the pricing_plan of this CreateTrackerRequest.

        No longer used. If included, the only allowed value is <code>RequestBasedUsage</code>.

        :param pricing_plan: The pricing_plan of this CreateTrackerRequest.
        :type pricing_plan: str
        """
        allowed_values = ["RequestBasedUsage", "MobileAssetTracking", "MobileAssetManagement"]  # noqa: E501
        if pricing_plan not in allowed_values:
            raise ValueError(
                "Invalid value for `pricing_plan` ({0}), must be one of {1}"
                .format(pricing_plan, allowed_values)
            )

        self._pricing_plan = pricing_plan

    @property
    def pricing_plan_data_source(self):
        """Gets the pricing_plan_data_source of this CreateTrackerRequest.

        This parameter is no longer used.

        :return: The pricing_plan_data_source of this CreateTrackerRequest.
        :rtype: str
        """
        return self._pricing_plan_data_source

    @pricing_plan_data_source.setter
    def pricing_plan_data_source(self, pricing_plan_data_source):
        """Sets the pricing_plan_data_source of this CreateTrackerRequest.

        This parameter is no longer used.

        :param pricing_plan_data_source: The pricing_plan_data_source of this CreateTrackerRequest.
        :type pricing_plan_data_source: str
        """

        self._pricing_plan_data_source = pricing_plan_data_source

    @property
    def tags(self):
        """Gets the tags of this CreateTrackerRequest.

        <p>Applies one or more tags to the tracker resource. A tag is a key-value pair helps manage, identify, search, and filter your resources by labelling them.</p> <p>Format: <code>\"key\" : \"value\"</code> </p> <p>Restrictions:</p> <ul> <li> <p>Maximum 50 tags per resource</p> </li> <li> <p>Each resource tag must be unique with a maximum of one value.</p> </li> <li> <p>Maximum key length: 128 Unicode characters in UTF-8</p> </li> <li> <p>Maximum value length: 256 Unicode characters in UTF-8</p> </li> <li> <p>Can use alphanumeric characters (A–Z, a–z, 0–9), and the following characters: + - = . _ : / @. </p> </li> <li> <p>Cannot use \"aws:\" as a prefix for a key.</p> </li> </ul>

        :return: The tags of this CreateTrackerRequest.
        :rtype: Dict[str, str]
        """
        return self._tags

    @tags.setter
    def tags(self, tags):
        """Sets the tags of this CreateTrackerRequest.

        <p>Applies one or more tags to the tracker resource. A tag is a key-value pair helps manage, identify, search, and filter your resources by labelling them.</p> <p>Format: <code>\"key\" : \"value\"</code> </p> <p>Restrictions:</p> <ul> <li> <p>Maximum 50 tags per resource</p> </li> <li> <p>Each resource tag must be unique with a maximum of one value.</p> </li> <li> <p>Maximum key length: 128 Unicode characters in UTF-8</p> </li> <li> <p>Maximum value length: 256 Unicode characters in UTF-8</p> </li> <li> <p>Can use alphanumeric characters (A–Z, a–z, 0–9), and the following characters: + - = . _ : / @. </p> </li> <li> <p>Cannot use \"aws:\" as a prefix for a key.</p> </li> </ul>

        :param tags: The tags of this CreateTrackerRequest.
        :type tags: Dict[str, str]
        """
        if tags is not None and len(tags) > 50:
            raise ValueError("Invalid value for `tags`, number of items must be less than or equal to `50`")
        if tags is not None and len(tags) < 0:
            raise ValueError("Invalid value for `tags`, number of items must be greater than or equal to `0`")

        self._tags = tags

    @property
    def tracker_name(self):
        """Gets the tracker_name of this CreateTrackerRequest.

        <p>The name for the tracker resource.</p> <p>Requirements:</p> <ul> <li> <p>Contain only alphanumeric characters (A-Z, a-z, 0-9) , hyphens (-), periods (.), and underscores (_).</p> </li> <li> <p>Must be a unique tracker resource name.</p> </li> <li> <p>No spaces allowed. For example, <code>ExampleTracker</code>.</p> </li> </ul>

        :return: The tracker_name of this CreateTrackerRequest.
        :rtype: str
        """
        return self._tracker_name

    @tracker_name.setter
    def tracker_name(self, tracker_name):
        """Sets the tracker_name of this CreateTrackerRequest.

        <p>The name for the tracker resource.</p> <p>Requirements:</p> <ul> <li> <p>Contain only alphanumeric characters (A-Z, a-z, 0-9) , hyphens (-), periods (.), and underscores (_).</p> </li> <li> <p>Must be a unique tracker resource name.</p> </li> <li> <p>No spaces allowed. For example, <code>ExampleTracker</code>.</p> </li> </ul>

        :param tracker_name: The tracker_name of this CreateTrackerRequest.
        :type tracker_name: str
        """
        if tracker_name is None:
            raise ValueError("Invalid value for `tracker_name`, must not be `None`")
        if tracker_name is not None and len(tracker_name) > 100:
            raise ValueError("Invalid value for `tracker_name`, length must be less than or equal to `100`")
        if tracker_name is not None and len(tracker_name) < 1:
            raise ValueError("Invalid value for `tracker_name`, length must be greater than or equal to `1`")
        if tracker_name is not None and not re.search(r'^[-._\w]+$', tracker_name):
            raise ValueError("Invalid value for `tracker_name`, must be a follow pattern or equal to `/^[-._\w]+$/`")

        self._tracker_name = tracker_name
