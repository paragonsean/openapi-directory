# coding: utf-8

from datetime import date, datetime

from typing import List, Dict, Type

from openapi_server.models.base_model import Model
from openapi_server import util


class UpdateTrackerRequest(Model):
    """NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).

    Do not edit the class manually.
    """

    def __init__(self, description: str=None, event_bridge_enabled: bool=None, position_filtering: str=None, pricing_plan: str=None, pricing_plan_data_source: str=None):
        """UpdateTrackerRequest - a model defined in OpenAPI

        :param description: The description of this UpdateTrackerRequest.
        :param event_bridge_enabled: The event_bridge_enabled of this UpdateTrackerRequest.
        :param position_filtering: The position_filtering of this UpdateTrackerRequest.
        :param pricing_plan: The pricing_plan of this UpdateTrackerRequest.
        :param pricing_plan_data_source: The pricing_plan_data_source of this UpdateTrackerRequest.
        """
        self.openapi_types = {
            'description': str,
            'event_bridge_enabled': bool,
            'position_filtering': str,
            'pricing_plan': str,
            'pricing_plan_data_source': str
        }

        self.attribute_map = {
            'description': 'Description',
            'event_bridge_enabled': 'EventBridgeEnabled',
            'position_filtering': 'PositionFiltering',
            'pricing_plan': 'PricingPlan',
            'pricing_plan_data_source': 'PricingPlanDataSource'
        }

        self._description = description
        self._event_bridge_enabled = event_bridge_enabled
        self._position_filtering = position_filtering
        self._pricing_plan = pricing_plan
        self._pricing_plan_data_source = pricing_plan_data_source

    @classmethod
    def from_dict(cls, dikt: dict) -> 'UpdateTrackerRequest':
        """Returns the dict as a model

        :param dikt: A dict.
        :return: The UpdateTracker_request of this UpdateTrackerRequest.
        """
        return util.deserialize_model(dikt, cls)

    @property
    def description(self):
        """Gets the description of this UpdateTrackerRequest.

        Updates the description for the tracker resource.

        :return: The description of this UpdateTrackerRequest.
        :rtype: str
        """
        return self._description

    @description.setter
    def description(self, description):
        """Sets the description of this UpdateTrackerRequest.

        Updates the description for the tracker resource.

        :param description: The description of this UpdateTrackerRequest.
        :type description: str
        """
        if description is not None and len(description) > 1000:
            raise ValueError("Invalid value for `description`, length must be less than or equal to `1000`")
        if description is not None and len(description) < 0:
            raise ValueError("Invalid value for `description`, length must be greater than or equal to `0`")

        self._description = description

    @property
    def event_bridge_enabled(self):
        """Gets the event_bridge_enabled of this UpdateTrackerRequest.

        <p>Whether to enable position <code>UPDATE</code> events from this tracker to be sent to EventBridge.</p> <note> <p>You do not need enable this feature to get <code>ENTER</code> and <code>EXIT</code> events for geofences with this tracker. Those events are always sent to EventBridge.</p> </note>

        :return: The event_bridge_enabled of this UpdateTrackerRequest.
        :rtype: bool
        """
        return self._event_bridge_enabled

    @event_bridge_enabled.setter
    def event_bridge_enabled(self, event_bridge_enabled):
        """Sets the event_bridge_enabled of this UpdateTrackerRequest.

        <p>Whether to enable position <code>UPDATE</code> events from this tracker to be sent to EventBridge.</p> <note> <p>You do not need enable this feature to get <code>ENTER</code> and <code>EXIT</code> events for geofences with this tracker. Those events are always sent to EventBridge.</p> </note>

        :param event_bridge_enabled: The event_bridge_enabled of this UpdateTrackerRequest.
        :type event_bridge_enabled: bool
        """

        self._event_bridge_enabled = event_bridge_enabled

    @property
    def position_filtering(self):
        """Gets the position_filtering of this UpdateTrackerRequest.

        <p>Updates the position filtering for the tracker resource.</p> <p>Valid values:</p> <ul> <li> <p> <code>TimeBased</code> - Location updates are evaluated against linked geofence collections, but not every location update is stored. If your update frequency is more often than 30 seconds, only one update per 30 seconds is stored for each unique device ID. </p> </li> <li> <p> <code>DistanceBased</code> - If the device has moved less than 30 m (98.4 ft), location updates are ignored. Location updates within this distance are neither evaluated against linked geofence collections, nor stored. This helps control costs by reducing the number of geofence evaluations and historical device positions to paginate through. Distance-based filtering can also reduce the effects of GPS noise when displaying device trajectories on a map. </p> </li> <li> <p> <code>AccuracyBased</code> - If the device has moved less than the measured accuracy, location updates are ignored. For example, if two consecutive updates from a device have a horizontal accuracy of 5 m and 10 m, the second update is ignored if the device has moved less than 15 m. Ignored location updates are neither evaluated against linked geofence collections, nor stored. This helps educe the effects of GPS noise when displaying device trajectories on a map, and can help control costs by reducing the number of geofence evaluations. </p> </li> </ul>

        :return: The position_filtering of this UpdateTrackerRequest.
        :rtype: str
        """
        return self._position_filtering

    @position_filtering.setter
    def position_filtering(self, position_filtering):
        """Sets the position_filtering of this UpdateTrackerRequest.

        <p>Updates the position filtering for the tracker resource.</p> <p>Valid values:</p> <ul> <li> <p> <code>TimeBased</code> - Location updates are evaluated against linked geofence collections, but not every location update is stored. If your update frequency is more often than 30 seconds, only one update per 30 seconds is stored for each unique device ID. </p> </li> <li> <p> <code>DistanceBased</code> - If the device has moved less than 30 m (98.4 ft), location updates are ignored. Location updates within this distance are neither evaluated against linked geofence collections, nor stored. This helps control costs by reducing the number of geofence evaluations and historical device positions to paginate through. Distance-based filtering can also reduce the effects of GPS noise when displaying device trajectories on a map. </p> </li> <li> <p> <code>AccuracyBased</code> - If the device has moved less than the measured accuracy, location updates are ignored. For example, if two consecutive updates from a device have a horizontal accuracy of 5 m and 10 m, the second update is ignored if the device has moved less than 15 m. Ignored location updates are neither evaluated against linked geofence collections, nor stored. This helps educe the effects of GPS noise when displaying device trajectories on a map, and can help control costs by reducing the number of geofence evaluations. </p> </li> </ul>

        :param position_filtering: The position_filtering of this UpdateTrackerRequest.
        :type position_filtering: str
        """
        allowed_values = ["TimeBased", "DistanceBased", "AccuracyBased"]  # noqa: E501
        if position_filtering not in allowed_values:
            raise ValueError(
                "Invalid value for `position_filtering` ({0}), must be one of {1}"
                .format(position_filtering, allowed_values)
            )

        self._position_filtering = position_filtering

    @property
    def pricing_plan(self):
        """Gets the pricing_plan of this UpdateTrackerRequest.

        No longer used. If included, the only allowed value is <code>RequestBasedUsage</code>.

        :return: The pricing_plan of this UpdateTrackerRequest.
        :rtype: str
        """
        return self._pricing_plan

    @pricing_plan.setter
    def pricing_plan(self, pricing_plan):
        """Sets the pricing_plan of this UpdateTrackerRequest.

        No longer used. If included, the only allowed value is <code>RequestBasedUsage</code>.

        :param pricing_plan: The pricing_plan of this UpdateTrackerRequest.
        :type pricing_plan: str
        """
        allowed_values = ["RequestBasedUsage", "MobileAssetTracking", "MobileAssetManagement"]  # noqa: E501
        if pricing_plan not in allowed_values:
            raise ValueError(
                "Invalid value for `pricing_plan` ({0}), must be one of {1}"
                .format(pricing_plan, allowed_values)
            )

        self._pricing_plan = pricing_plan

    @property
    def pricing_plan_data_source(self):
        """Gets the pricing_plan_data_source of this UpdateTrackerRequest.

        This parameter is no longer used.

        :return: The pricing_plan_data_source of this UpdateTrackerRequest.
        :rtype: str
        """
        return self._pricing_plan_data_source

    @pricing_plan_data_source.setter
    def pricing_plan_data_source(self, pricing_plan_data_source):
        """Sets the pricing_plan_data_source of this UpdateTrackerRequest.

        This parameter is no longer used.

        :param pricing_plan_data_source: The pricing_plan_data_source of this UpdateTrackerRequest.
        :type pricing_plan_data_source: str
        """

        self._pricing_plan_data_source = pricing_plan_data_source
