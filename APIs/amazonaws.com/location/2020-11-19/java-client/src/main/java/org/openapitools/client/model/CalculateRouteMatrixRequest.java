/*
 * Amazon Location Service
 * \"Suite of geospatial services including Maps, Places, Routes, Tracking, and Geofencing\"
 *
 * The version of the OpenAPI document: 2020-11-19
 * Contact: mike.ralphson@gmail.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package org.openapitools.client.model;

import java.util.Objects;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;
import java.time.OffsetDateTime;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import org.openapitools.client.model.CalculateRouteRequestCarModeOptions;
import org.openapitools.client.model.CalculateRouteRequestTruckModeOptions;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonArray;
import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;
import com.google.gson.TypeAdapterFactory;
import com.google.gson.reflect.TypeToken;
import com.google.gson.TypeAdapter;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;

import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import org.openapitools.client.JSON;

/**
 * CalculateRouteMatrixRequest
 */
@javax.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen", date = "2024-10-12T12:28:39.499739-04:00[America/New_York]", comments = "Generator version: 7.9.0")
public class CalculateRouteMatrixRequest {
  public static final String SERIALIZED_NAME_CAR_MODE_OPTIONS = "CarModeOptions";
  @SerializedName(SERIALIZED_NAME_CAR_MODE_OPTIONS)
  private CalculateRouteRequestCarModeOptions carModeOptions;

  public static final String SERIALIZED_NAME_DEPART_NOW = "DepartNow";
  @SerializedName(SERIALIZED_NAME_DEPART_NOW)
  private Boolean departNow;

  public static final String SERIALIZED_NAME_DEPARTURE_POSITIONS = "DeparturePositions";
  @SerializedName(SERIALIZED_NAME_DEPARTURE_POSITIONS)
  private List<List<Double>> departurePositions = new ArrayList<>();

  public static final String SERIALIZED_NAME_DEPARTURE_TIME = "DepartureTime";
  @SerializedName(SERIALIZED_NAME_DEPARTURE_TIME)
  private OffsetDateTime departureTime;

  public static final String SERIALIZED_NAME_DESTINATION_POSITIONS = "DestinationPositions";
  @SerializedName(SERIALIZED_NAME_DESTINATION_POSITIONS)
  private List<List<Double>> destinationPositions = new ArrayList<>();

  /**
   * &lt;p&gt;Set the unit system to specify the distance.&lt;/p&gt; &lt;p&gt;Default Value: &lt;code&gt;Kilometers&lt;/code&gt; &lt;/p&gt;
   */
  @JsonAdapter(DistanceUnitEnum.Adapter.class)
  public enum DistanceUnitEnum {
    KILOMETERS("Kilometers"),
    
    MILES("Miles");

    private String value;

    DistanceUnitEnum(String value) {
      this.value = value;
    }

    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }

    public static DistanceUnitEnum fromValue(String value) {
      for (DistanceUnitEnum b : DistanceUnitEnum.values()) {
        if (b.value.equals(value)) {
          return b;
        }
      }
      throw new IllegalArgumentException("Unexpected value '" + value + "'");
    }

    public static class Adapter extends TypeAdapter<DistanceUnitEnum> {
      @Override
      public void write(final JsonWriter jsonWriter, final DistanceUnitEnum enumeration) throws IOException {
        jsonWriter.value(enumeration.getValue());
      }

      @Override
      public DistanceUnitEnum read(final JsonReader jsonReader) throws IOException {
        String value =  jsonReader.nextString();
        return DistanceUnitEnum.fromValue(value);
      }
    }

    public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      String value = jsonElement.getAsString();
      DistanceUnitEnum.fromValue(value);
    }
  }

  public static final String SERIALIZED_NAME_DISTANCE_UNIT = "DistanceUnit";
  @SerializedName(SERIALIZED_NAME_DISTANCE_UNIT)
  private DistanceUnitEnum distanceUnit;

  /**
   * &lt;p&gt;Specifies the mode of transport when calculating a route. Used in estimating the speed of travel and road compatibility.&lt;/p&gt; &lt;p&gt;The &lt;code&gt;TravelMode&lt;/code&gt; you specify also determines how you specify route preferences: &lt;/p&gt; &lt;ul&gt; &lt;li&gt; &lt;p&gt;If traveling by &lt;code&gt;Car&lt;/code&gt; use the &lt;code&gt;CarModeOptions&lt;/code&gt; parameter.&lt;/p&gt; &lt;/li&gt; &lt;li&gt; &lt;p&gt;If traveling by &lt;code&gt;Truck&lt;/code&gt; use the &lt;code&gt;TruckModeOptions&lt;/code&gt; parameter.&lt;/p&gt; &lt;/li&gt; &lt;/ul&gt; &lt;note&gt; &lt;p&gt; &lt;code&gt;Bicycle&lt;/code&gt; or &lt;code&gt;Motorcycle&lt;/code&gt; are only valid when using &lt;code&gt;Grab&lt;/code&gt; as a data provider, and only within Southeast Asia.&lt;/p&gt; &lt;p&gt; &lt;code&gt;Truck&lt;/code&gt; is not available for Grab.&lt;/p&gt; &lt;p&gt;For more information about using Grab as a data provider, see &lt;a href&#x3D;\&quot;https://docs.aws.amazon.com/location/latest/developerguide/grab.html\&quot;&gt;GrabMaps&lt;/a&gt; in the &lt;i&gt;Amazon Location Service Developer Guide&lt;/i&gt;.&lt;/p&gt; &lt;/note&gt; &lt;p&gt;Default Value: &lt;code&gt;Car&lt;/code&gt; &lt;/p&gt;
   */
  @JsonAdapter(TravelModeEnum.Adapter.class)
  public enum TravelModeEnum {
    CAR("Car"),
    
    TRUCK("Truck"),
    
    WALKING("Walking"),
    
    BICYCLE("Bicycle"),
    
    MOTORCYCLE("Motorcycle");

    private String value;

    TravelModeEnum(String value) {
      this.value = value;
    }

    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }

    public static TravelModeEnum fromValue(String value) {
      for (TravelModeEnum b : TravelModeEnum.values()) {
        if (b.value.equals(value)) {
          return b;
        }
      }
      throw new IllegalArgumentException("Unexpected value '" + value + "'");
    }

    public static class Adapter extends TypeAdapter<TravelModeEnum> {
      @Override
      public void write(final JsonWriter jsonWriter, final TravelModeEnum enumeration) throws IOException {
        jsonWriter.value(enumeration.getValue());
      }

      @Override
      public TravelModeEnum read(final JsonReader jsonReader) throws IOException {
        String value =  jsonReader.nextString();
        return TravelModeEnum.fromValue(value);
      }
    }

    public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      String value = jsonElement.getAsString();
      TravelModeEnum.fromValue(value);
    }
  }

  public static final String SERIALIZED_NAME_TRAVEL_MODE = "TravelMode";
  @SerializedName(SERIALIZED_NAME_TRAVEL_MODE)
  private TravelModeEnum travelMode;

  public static final String SERIALIZED_NAME_TRUCK_MODE_OPTIONS = "TruckModeOptions";
  @SerializedName(SERIALIZED_NAME_TRUCK_MODE_OPTIONS)
  private CalculateRouteRequestTruckModeOptions truckModeOptions;

  public CalculateRouteMatrixRequest() {
  }

  public CalculateRouteMatrixRequest carModeOptions(CalculateRouteRequestCarModeOptions carModeOptions) {
    this.carModeOptions = carModeOptions;
    return this;
  }

  /**
   * Get carModeOptions
   * @return carModeOptions
   */
  @javax.annotation.Nullable
  public CalculateRouteRequestCarModeOptions getCarModeOptions() {
    return carModeOptions;
  }

  public void setCarModeOptions(CalculateRouteRequestCarModeOptions carModeOptions) {
    this.carModeOptions = carModeOptions;
  }


  public CalculateRouteMatrixRequest departNow(Boolean departNow) {
    this.departNow = departNow;
    return this;
  }

  /**
   * &lt;p&gt;Sets the time of departure as the current time. Uses the current time to calculate the route matrix. You can&#39;t set both &lt;code&gt;DepartureTime&lt;/code&gt; and &lt;code&gt;DepartNow&lt;/code&gt;. If neither is set, the best time of day to travel with the best traffic conditions is used to calculate the route matrix.&lt;/p&gt; &lt;p&gt;Default Value: &lt;code&gt;false&lt;/code&gt; &lt;/p&gt; &lt;p&gt;Valid Values: &lt;code&gt;false&lt;/code&gt; | &lt;code&gt;true&lt;/code&gt; &lt;/p&gt;
   * @return departNow
   */
  @javax.annotation.Nullable
  public Boolean getDepartNow() {
    return departNow;
  }

  public void setDepartNow(Boolean departNow) {
    this.departNow = departNow;
  }


  public CalculateRouteMatrixRequest departurePositions(List<List<Double>> departurePositions) {
    this.departurePositions = departurePositions;
    return this;
  }

  public CalculateRouteMatrixRequest addDeparturePositionsItem(List<Double> departurePositionsItem) {
    if (this.departurePositions == null) {
      this.departurePositions = new ArrayList<>();
    }
    this.departurePositions.add(departurePositionsItem);
    return this;
  }

  /**
   * &lt;p&gt;The list of departure (origin) positions for the route matrix. An array of points, each of which is itself a 2-value array defined in &lt;a href&#x3D;\&quot;https://earth-info.nga.mil/GandG/wgs84/index.html\&quot;&gt;WGS 84&lt;/a&gt; format: &lt;code&gt;[longitude, latitude]&lt;/code&gt;. For example, &lt;code&gt;[-123.115, 49.285]&lt;/code&gt;.&lt;/p&gt; &lt;important&gt; &lt;p&gt;Depending on the data provider selected in the route calculator resource there may be additional restrictions on the inputs you can choose. See &lt;a href&#x3D;\&quot;https://docs.aws.amazon.com/location/latest/developerguide/calculate-route-matrix.html#matrix-routing-position-limits\&quot;&gt; Position restrictions&lt;/a&gt; in the &lt;i&gt;Amazon Location Service Developer Guide&lt;/i&gt;.&lt;/p&gt; &lt;/important&gt; &lt;note&gt; &lt;p&gt;For route calculators that use Esri as the data provider, if you specify a departure that&#39;s not located on a road, Amazon Location &lt;a href&#x3D;\&quot;https://docs.aws.amazon.com/location/latest/developerguide/snap-to-nearby-road.html\&quot;&gt; moves the position to the nearest road&lt;/a&gt;. The snapped value is available in the result in &lt;code&gt;SnappedDeparturePositions&lt;/code&gt;.&lt;/p&gt; &lt;/note&gt; &lt;p&gt;Valid Values: &lt;code&gt;[-180 to 180,-90 to 90]&lt;/code&gt; &lt;/p&gt;
   * @return departurePositions
   */
  @javax.annotation.Nonnull
  public List<List<Double>> getDeparturePositions() {
    return departurePositions;
  }

  public void setDeparturePositions(List<List<Double>> departurePositions) {
    this.departurePositions = departurePositions;
  }


  public CalculateRouteMatrixRequest departureTime(OffsetDateTime departureTime) {
    this.departureTime = departureTime;
    return this;
  }

  /**
   * &lt;p&gt;Specifies the desired time of departure. Uses the given time to calculate the route matrix. You can&#39;t set both &lt;code&gt;DepartureTime&lt;/code&gt; and &lt;code&gt;DepartNow&lt;/code&gt;. If neither is set, the best time of day to travel with the best traffic conditions is used to calculate the route matrix.&lt;/p&gt; &lt;note&gt; &lt;p&gt;Setting a departure time in the past returns a &lt;code&gt;400 ValidationException&lt;/code&gt; error.&lt;/p&gt; &lt;/note&gt; &lt;ul&gt; &lt;li&gt; &lt;p&gt;In &lt;a href&#x3D;\&quot;https://www.iso.org/iso-8601-date-and-time-format.html\&quot;&gt;ISO 8601&lt;/a&gt; format: &lt;code&gt;YYYY-MM-DDThh:mm:ss.sssZ&lt;/code&gt;. For example, &lt;code&gt;2020–07-2T12:15:20.000Z+01:00&lt;/code&gt; &lt;/p&gt; &lt;/li&gt; &lt;/ul&gt;
   * @return departureTime
   */
  @javax.annotation.Nullable
  public OffsetDateTime getDepartureTime() {
    return departureTime;
  }

  public void setDepartureTime(OffsetDateTime departureTime) {
    this.departureTime = departureTime;
  }


  public CalculateRouteMatrixRequest destinationPositions(List<List<Double>> destinationPositions) {
    this.destinationPositions = destinationPositions;
    return this;
  }

  public CalculateRouteMatrixRequest addDestinationPositionsItem(List<Double> destinationPositionsItem) {
    if (this.destinationPositions == null) {
      this.destinationPositions = new ArrayList<>();
    }
    this.destinationPositions.add(destinationPositionsItem);
    return this;
  }

  /**
   * &lt;p&gt;The list of destination positions for the route matrix. An array of points, each of which is itself a 2-value array defined in &lt;a href&#x3D;\&quot;https://earth-info.nga.mil/GandG/wgs84/index.html\&quot;&gt;WGS 84&lt;/a&gt; format: &lt;code&gt;[longitude, latitude]&lt;/code&gt;. For example, &lt;code&gt;[-122.339, 47.615]&lt;/code&gt; &lt;/p&gt; &lt;important&gt; &lt;p&gt;Depending on the data provider selected in the route calculator resource there may be additional restrictions on the inputs you can choose. See &lt;a href&#x3D;\&quot;https://docs.aws.amazon.com/location/latest/developerguide/calculate-route-matrix.html#matrix-routing-position-limits\&quot;&gt; Position restrictions&lt;/a&gt; in the &lt;i&gt;Amazon Location Service Developer Guide&lt;/i&gt;.&lt;/p&gt; &lt;/important&gt; &lt;note&gt; &lt;p&gt;For route calculators that use Esri as the data provider, if you specify a destination that&#39;s not located on a road, Amazon Location &lt;a href&#x3D;\&quot;https://docs.aws.amazon.com/location/latest/developerguide/snap-to-nearby-road.html\&quot;&gt; moves the position to the nearest road&lt;/a&gt;. The snapped value is available in the result in &lt;code&gt;SnappedDestinationPositions&lt;/code&gt;.&lt;/p&gt; &lt;/note&gt; &lt;p&gt;Valid Values: &lt;code&gt;[-180 to 180,-90 to 90]&lt;/code&gt; &lt;/p&gt;
   * @return destinationPositions
   */
  @javax.annotation.Nonnull
  public List<List<Double>> getDestinationPositions() {
    return destinationPositions;
  }

  public void setDestinationPositions(List<List<Double>> destinationPositions) {
    this.destinationPositions = destinationPositions;
  }


  public CalculateRouteMatrixRequest distanceUnit(DistanceUnitEnum distanceUnit) {
    this.distanceUnit = distanceUnit;
    return this;
  }

  /**
   * &lt;p&gt;Set the unit system to specify the distance.&lt;/p&gt; &lt;p&gt;Default Value: &lt;code&gt;Kilometers&lt;/code&gt; &lt;/p&gt;
   * @return distanceUnit
   */
  @javax.annotation.Nullable
  public DistanceUnitEnum getDistanceUnit() {
    return distanceUnit;
  }

  public void setDistanceUnit(DistanceUnitEnum distanceUnit) {
    this.distanceUnit = distanceUnit;
  }


  public CalculateRouteMatrixRequest travelMode(TravelModeEnum travelMode) {
    this.travelMode = travelMode;
    return this;
  }

  /**
   * &lt;p&gt;Specifies the mode of transport when calculating a route. Used in estimating the speed of travel and road compatibility.&lt;/p&gt; &lt;p&gt;The &lt;code&gt;TravelMode&lt;/code&gt; you specify also determines how you specify route preferences: &lt;/p&gt; &lt;ul&gt; &lt;li&gt; &lt;p&gt;If traveling by &lt;code&gt;Car&lt;/code&gt; use the &lt;code&gt;CarModeOptions&lt;/code&gt; parameter.&lt;/p&gt; &lt;/li&gt; &lt;li&gt; &lt;p&gt;If traveling by &lt;code&gt;Truck&lt;/code&gt; use the &lt;code&gt;TruckModeOptions&lt;/code&gt; parameter.&lt;/p&gt; &lt;/li&gt; &lt;/ul&gt; &lt;note&gt; &lt;p&gt; &lt;code&gt;Bicycle&lt;/code&gt; or &lt;code&gt;Motorcycle&lt;/code&gt; are only valid when using &lt;code&gt;Grab&lt;/code&gt; as a data provider, and only within Southeast Asia.&lt;/p&gt; &lt;p&gt; &lt;code&gt;Truck&lt;/code&gt; is not available for Grab.&lt;/p&gt; &lt;p&gt;For more information about using Grab as a data provider, see &lt;a href&#x3D;\&quot;https://docs.aws.amazon.com/location/latest/developerguide/grab.html\&quot;&gt;GrabMaps&lt;/a&gt; in the &lt;i&gt;Amazon Location Service Developer Guide&lt;/i&gt;.&lt;/p&gt; &lt;/note&gt; &lt;p&gt;Default Value: &lt;code&gt;Car&lt;/code&gt; &lt;/p&gt;
   * @return travelMode
   */
  @javax.annotation.Nullable
  public TravelModeEnum getTravelMode() {
    return travelMode;
  }

  public void setTravelMode(TravelModeEnum travelMode) {
    this.travelMode = travelMode;
  }


  public CalculateRouteMatrixRequest truckModeOptions(CalculateRouteRequestTruckModeOptions truckModeOptions) {
    this.truckModeOptions = truckModeOptions;
    return this;
  }

  /**
   * Get truckModeOptions
   * @return truckModeOptions
   */
  @javax.annotation.Nullable
  public CalculateRouteRequestTruckModeOptions getTruckModeOptions() {
    return truckModeOptions;
  }

  public void setTruckModeOptions(CalculateRouteRequestTruckModeOptions truckModeOptions) {
    this.truckModeOptions = truckModeOptions;
  }



  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    CalculateRouteMatrixRequest calculateRouteMatrixRequest = (CalculateRouteMatrixRequest) o;
    return Objects.equals(this.carModeOptions, calculateRouteMatrixRequest.carModeOptions) &&
        Objects.equals(this.departNow, calculateRouteMatrixRequest.departNow) &&
        Objects.equals(this.departurePositions, calculateRouteMatrixRequest.departurePositions) &&
        Objects.equals(this.departureTime, calculateRouteMatrixRequest.departureTime) &&
        Objects.equals(this.destinationPositions, calculateRouteMatrixRequest.destinationPositions) &&
        Objects.equals(this.distanceUnit, calculateRouteMatrixRequest.distanceUnit) &&
        Objects.equals(this.travelMode, calculateRouteMatrixRequest.travelMode) &&
        Objects.equals(this.truckModeOptions, calculateRouteMatrixRequest.truckModeOptions);
  }

  @Override
  public int hashCode() {
    return Objects.hash(carModeOptions, departNow, departurePositions, departureTime, destinationPositions, distanceUnit, travelMode, truckModeOptions);
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class CalculateRouteMatrixRequest {\n");
    sb.append("    carModeOptions: ").append(toIndentedString(carModeOptions)).append("\n");
    sb.append("    departNow: ").append(toIndentedString(departNow)).append("\n");
    sb.append("    departurePositions: ").append(toIndentedString(departurePositions)).append("\n");
    sb.append("    departureTime: ").append(toIndentedString(departureTime)).append("\n");
    sb.append("    destinationPositions: ").append(toIndentedString(destinationPositions)).append("\n");
    sb.append("    distanceUnit: ").append(toIndentedString(distanceUnit)).append("\n");
    sb.append("    travelMode: ").append(toIndentedString(travelMode)).append("\n");
    sb.append("    truckModeOptions: ").append(toIndentedString(truckModeOptions)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }


  public static HashSet<String> openapiFields;
  public static HashSet<String> openapiRequiredFields;

  static {
    // a set of all properties/fields (JSON key names)
    openapiFields = new HashSet<String>();
    openapiFields.add("CarModeOptions");
    openapiFields.add("DepartNow");
    openapiFields.add("DeparturePositions");
    openapiFields.add("DepartureTime");
    openapiFields.add("DestinationPositions");
    openapiFields.add("DistanceUnit");
    openapiFields.add("TravelMode");
    openapiFields.add("TruckModeOptions");

    // a set of required properties/fields (JSON key names)
    openapiRequiredFields = new HashSet<String>();
    openapiRequiredFields.add("DeparturePositions");
    openapiRequiredFields.add("DestinationPositions");
  }

  /**
   * Validates the JSON Element and throws an exception if issues found
   *
   * @param jsonElement JSON Element
   * @throws IOException if the JSON Element is invalid with respect to CalculateRouteMatrixRequest
   */
  public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      if (jsonElement == null) {
        if (!CalculateRouteMatrixRequest.openapiRequiredFields.isEmpty()) { // has required fields but JSON element is null
          throw new IllegalArgumentException(String.format("The required field(s) %s in CalculateRouteMatrixRequest is not found in the empty JSON string", CalculateRouteMatrixRequest.openapiRequiredFields.toString()));
        }
      }

      Set<Map.Entry<String, JsonElement>> entries = jsonElement.getAsJsonObject().entrySet();
      // check to see if the JSON string contains additional fields
      for (Map.Entry<String, JsonElement> entry : entries) {
        if (!CalculateRouteMatrixRequest.openapiFields.contains(entry.getKey())) {
          throw new IllegalArgumentException(String.format("The field `%s` in the JSON string is not defined in the `CalculateRouteMatrixRequest` properties. JSON: %s", entry.getKey(), jsonElement.toString()));
        }
      }

      // check to make sure all required properties/fields are present in the JSON string
      for (String requiredField : CalculateRouteMatrixRequest.openapiRequiredFields) {
        if (jsonElement.getAsJsonObject().get(requiredField) == null) {
          throw new IllegalArgumentException(String.format("The required field `%s` is not found in the JSON string: %s", requiredField, jsonElement.toString()));
        }
      }
        JsonObject jsonObj = jsonElement.getAsJsonObject();
      // validate the optional field `CarModeOptions`
      if (jsonObj.get("CarModeOptions") != null && !jsonObj.get("CarModeOptions").isJsonNull()) {
        CalculateRouteRequestCarModeOptions.validateJsonElement(jsonObj.get("CarModeOptions"));
      }
      // ensure the required json array is present
      if (jsonObj.get("DeparturePositions") == null) {
        throw new IllegalArgumentException("Expected the field `linkedContent` to be an array in the JSON string but got `null`");
      } else if (!jsonObj.get("DeparturePositions").isJsonArray()) {
        throw new IllegalArgumentException(String.format("Expected the field `DeparturePositions` to be an array in the JSON string but got `%s`", jsonObj.get("DeparturePositions").toString()));
      }
      // ensure the required json array is present
      if (jsonObj.get("DestinationPositions") == null) {
        throw new IllegalArgumentException("Expected the field `linkedContent` to be an array in the JSON string but got `null`");
      } else if (!jsonObj.get("DestinationPositions").isJsonArray()) {
        throw new IllegalArgumentException(String.format("Expected the field `DestinationPositions` to be an array in the JSON string but got `%s`", jsonObj.get("DestinationPositions").toString()));
      }
      if ((jsonObj.get("DistanceUnit") != null && !jsonObj.get("DistanceUnit").isJsonNull()) && !jsonObj.get("DistanceUnit").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `DistanceUnit` to be a primitive type in the JSON string but got `%s`", jsonObj.get("DistanceUnit").toString()));
      }
      // validate the optional field `DistanceUnit`
      if (jsonObj.get("DistanceUnit") != null && !jsonObj.get("DistanceUnit").isJsonNull()) {
        DistanceUnitEnum.validateJsonElement(jsonObj.get("DistanceUnit"));
      }
      if ((jsonObj.get("TravelMode") != null && !jsonObj.get("TravelMode").isJsonNull()) && !jsonObj.get("TravelMode").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `TravelMode` to be a primitive type in the JSON string but got `%s`", jsonObj.get("TravelMode").toString()));
      }
      // validate the optional field `TravelMode`
      if (jsonObj.get("TravelMode") != null && !jsonObj.get("TravelMode").isJsonNull()) {
        TravelModeEnum.validateJsonElement(jsonObj.get("TravelMode"));
      }
      // validate the optional field `TruckModeOptions`
      if (jsonObj.get("TruckModeOptions") != null && !jsonObj.get("TruckModeOptions").isJsonNull()) {
        CalculateRouteRequestTruckModeOptions.validateJsonElement(jsonObj.get("TruckModeOptions"));
      }
  }

  public static class CustomTypeAdapterFactory implements TypeAdapterFactory {
    @SuppressWarnings("unchecked")
    @Override
    public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
       if (!CalculateRouteMatrixRequest.class.isAssignableFrom(type.getRawType())) {
         return null; // this class only serializes 'CalculateRouteMatrixRequest' and its subtypes
       }
       final TypeAdapter<JsonElement> elementAdapter = gson.getAdapter(JsonElement.class);
       final TypeAdapter<CalculateRouteMatrixRequest> thisAdapter
                        = gson.getDelegateAdapter(this, TypeToken.get(CalculateRouteMatrixRequest.class));

       return (TypeAdapter<T>) new TypeAdapter<CalculateRouteMatrixRequest>() {
           @Override
           public void write(JsonWriter out, CalculateRouteMatrixRequest value) throws IOException {
             JsonObject obj = thisAdapter.toJsonTree(value).getAsJsonObject();
             elementAdapter.write(out, obj);
           }

           @Override
           public CalculateRouteMatrixRequest read(JsonReader in) throws IOException {
             JsonElement jsonElement = elementAdapter.read(in);
             validateJsonElement(jsonElement);
             return thisAdapter.fromJsonTree(jsonElement);
           }

       }.nullSafe();
    }
  }

  /**
   * Create an instance of CalculateRouteMatrixRequest given an JSON string
   *
   * @param jsonString JSON string
   * @return An instance of CalculateRouteMatrixRequest
   * @throws IOException if the JSON string is invalid with respect to CalculateRouteMatrixRequest
   */
  public static CalculateRouteMatrixRequest fromJson(String jsonString) throws IOException {
    return JSON.getGson().fromJson(jsonString, CalculateRouteMatrixRequest.class);
  }

  /**
   * Convert an instance of CalculateRouteMatrixRequest to an JSON string
   *
   * @return JSON string
   */
  public String toJson() {
    return JSON.getGson().toJson(this);
  }
}

