/*
 * Amazon Location Service
 * \"Suite of geospatial services including Maps, Places, Routes, Tracking, and Geofencing\"
 *
 * The version of the OpenAPI document: 2020-11-19
 * Contact: mike.ralphson@gmail.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package org.openapitools.client.model;

import java.util.Objects;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;
import java.time.OffsetDateTime;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import org.openapitools.client.model.CalculateRouteRequestCarModeOptions;
import org.openapitools.client.model.CalculateRouteRequestTruckModeOptions;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonArray;
import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;
import com.google.gson.TypeAdapterFactory;
import com.google.gson.reflect.TypeToken;
import com.google.gson.TypeAdapter;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;

import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import org.openapitools.client.JSON;

/**
 * CalculateRouteRequest
 */
@javax.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen", date = "2024-10-12T12:28:39.499739-04:00[America/New_York]", comments = "Generator version: 7.9.0")
public class CalculateRouteRequest {
  public static final String SERIALIZED_NAME_CAR_MODE_OPTIONS = "CarModeOptions";
  @SerializedName(SERIALIZED_NAME_CAR_MODE_OPTIONS)
  private CalculateRouteRequestCarModeOptions carModeOptions;

  public static final String SERIALIZED_NAME_DEPART_NOW = "DepartNow";
  @SerializedName(SERIALIZED_NAME_DEPART_NOW)
  private Boolean departNow;

  public static final String SERIALIZED_NAME_DEPARTURE_POSITION = "DeparturePosition";
  @SerializedName(SERIALIZED_NAME_DEPARTURE_POSITION)
  private List<Double> departurePosition = new ArrayList<>();

  public static final String SERIALIZED_NAME_DEPARTURE_TIME = "DepartureTime";
  @SerializedName(SERIALIZED_NAME_DEPARTURE_TIME)
  private OffsetDateTime departureTime;

  public static final String SERIALIZED_NAME_DESTINATION_POSITION = "DestinationPosition";
  @SerializedName(SERIALIZED_NAME_DESTINATION_POSITION)
  private List<Double> destinationPosition = new ArrayList<>();

  /**
   * &lt;p&gt;Set the unit system to specify the distance.&lt;/p&gt; &lt;p&gt;Default Value: &lt;code&gt;Kilometers&lt;/code&gt; &lt;/p&gt;
   */
  @JsonAdapter(DistanceUnitEnum.Adapter.class)
  public enum DistanceUnitEnum {
    KILOMETERS("Kilometers"),
    
    MILES("Miles");

    private String value;

    DistanceUnitEnum(String value) {
      this.value = value;
    }

    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }

    public static DistanceUnitEnum fromValue(String value) {
      for (DistanceUnitEnum b : DistanceUnitEnum.values()) {
        if (b.value.equals(value)) {
          return b;
        }
      }
      throw new IllegalArgumentException("Unexpected value '" + value + "'");
    }

    public static class Adapter extends TypeAdapter<DistanceUnitEnum> {
      @Override
      public void write(final JsonWriter jsonWriter, final DistanceUnitEnum enumeration) throws IOException {
        jsonWriter.value(enumeration.getValue());
      }

      @Override
      public DistanceUnitEnum read(final JsonReader jsonReader) throws IOException {
        String value =  jsonReader.nextString();
        return DistanceUnitEnum.fromValue(value);
      }
    }

    public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      String value = jsonElement.getAsString();
      DistanceUnitEnum.fromValue(value);
    }
  }

  public static final String SERIALIZED_NAME_DISTANCE_UNIT = "DistanceUnit";
  @SerializedName(SERIALIZED_NAME_DISTANCE_UNIT)
  private DistanceUnitEnum distanceUnit;

  public static final String SERIALIZED_NAME_INCLUDE_LEG_GEOMETRY = "IncludeLegGeometry";
  @SerializedName(SERIALIZED_NAME_INCLUDE_LEG_GEOMETRY)
  private Boolean includeLegGeometry;

  /**
   * &lt;p&gt;Specifies the mode of transport when calculating a route. Used in estimating the speed of travel and road compatibility. You can choose &lt;code&gt;Car&lt;/code&gt;, &lt;code&gt;Truck&lt;/code&gt;, &lt;code&gt;Walking&lt;/code&gt;, &lt;code&gt;Bicycle&lt;/code&gt; or &lt;code&gt;Motorcycle&lt;/code&gt; as options for the &lt;code&gt;TravelMode&lt;/code&gt;.&lt;/p&gt; &lt;note&gt; &lt;p&gt; &lt;code&gt;Bicycle&lt;/code&gt; and &lt;code&gt;Motorcycle&lt;/code&gt; are only valid when using Grab as a data provider, and only within Southeast Asia.&lt;/p&gt; &lt;p&gt; &lt;code&gt;Truck&lt;/code&gt; is not available for Grab.&lt;/p&gt; &lt;p&gt;For more details on the using Grab for routing, including areas of coverage, see &lt;a href&#x3D;\&quot;https://docs.aws.amazon.com/location/latest/developerguide/grab.html\&quot;&gt;GrabMaps&lt;/a&gt; in the &lt;i&gt;Amazon Location Service Developer Guide&lt;/i&gt;.&lt;/p&gt; &lt;/note&gt; &lt;p&gt;The &lt;code&gt;TravelMode&lt;/code&gt; you specify also determines how you specify route preferences: &lt;/p&gt; &lt;ul&gt; &lt;li&gt; &lt;p&gt;If traveling by &lt;code&gt;Car&lt;/code&gt; use the &lt;code&gt;CarModeOptions&lt;/code&gt; parameter.&lt;/p&gt; &lt;/li&gt; &lt;li&gt; &lt;p&gt;If traveling by &lt;code&gt;Truck&lt;/code&gt; use the &lt;code&gt;TruckModeOptions&lt;/code&gt; parameter.&lt;/p&gt; &lt;/li&gt; &lt;/ul&gt; &lt;p&gt;Default Value: &lt;code&gt;Car&lt;/code&gt; &lt;/p&gt;
   */
  @JsonAdapter(TravelModeEnum.Adapter.class)
  public enum TravelModeEnum {
    CAR("Car"),
    
    TRUCK("Truck"),
    
    WALKING("Walking"),
    
    BICYCLE("Bicycle"),
    
    MOTORCYCLE("Motorcycle");

    private String value;

    TravelModeEnum(String value) {
      this.value = value;
    }

    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }

    public static TravelModeEnum fromValue(String value) {
      for (TravelModeEnum b : TravelModeEnum.values()) {
        if (b.value.equals(value)) {
          return b;
        }
      }
      throw new IllegalArgumentException("Unexpected value '" + value + "'");
    }

    public static class Adapter extends TypeAdapter<TravelModeEnum> {
      @Override
      public void write(final JsonWriter jsonWriter, final TravelModeEnum enumeration) throws IOException {
        jsonWriter.value(enumeration.getValue());
      }

      @Override
      public TravelModeEnum read(final JsonReader jsonReader) throws IOException {
        String value =  jsonReader.nextString();
        return TravelModeEnum.fromValue(value);
      }
    }

    public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      String value = jsonElement.getAsString();
      TravelModeEnum.fromValue(value);
    }
  }

  public static final String SERIALIZED_NAME_TRAVEL_MODE = "TravelMode";
  @SerializedName(SERIALIZED_NAME_TRAVEL_MODE)
  private TravelModeEnum travelMode;

  public static final String SERIALIZED_NAME_TRUCK_MODE_OPTIONS = "TruckModeOptions";
  @SerializedName(SERIALIZED_NAME_TRUCK_MODE_OPTIONS)
  private CalculateRouteRequestTruckModeOptions truckModeOptions;

  public static final String SERIALIZED_NAME_WAYPOINT_POSITIONS = "WaypointPositions";
  @SerializedName(SERIALIZED_NAME_WAYPOINT_POSITIONS)
  private List<List<Double>> waypointPositions = new ArrayList<>();

  public CalculateRouteRequest() {
  }

  public CalculateRouteRequest carModeOptions(CalculateRouteRequestCarModeOptions carModeOptions) {
    this.carModeOptions = carModeOptions;
    return this;
  }

  /**
   * Get carModeOptions
   * @return carModeOptions
   */
  @javax.annotation.Nullable
  public CalculateRouteRequestCarModeOptions getCarModeOptions() {
    return carModeOptions;
  }

  public void setCarModeOptions(CalculateRouteRequestCarModeOptions carModeOptions) {
    this.carModeOptions = carModeOptions;
  }


  public CalculateRouteRequest departNow(Boolean departNow) {
    this.departNow = departNow;
    return this;
  }

  /**
   * &lt;p&gt;Sets the time of departure as the current time. Uses the current time to calculate a route. Otherwise, the best time of day to travel with the best traffic conditions is used to calculate the route.&lt;/p&gt; &lt;p&gt;Default Value: &lt;code&gt;false&lt;/code&gt; &lt;/p&gt; &lt;p&gt;Valid Values: &lt;code&gt;false&lt;/code&gt; | &lt;code&gt;true&lt;/code&gt; &lt;/p&gt;
   * @return departNow
   */
  @javax.annotation.Nullable
  public Boolean getDepartNow() {
    return departNow;
  }

  public void setDepartNow(Boolean departNow) {
    this.departNow = departNow;
  }


  public CalculateRouteRequest departurePosition(List<Double> departurePosition) {
    this.departurePosition = departurePosition;
    return this;
  }

  public CalculateRouteRequest addDeparturePositionItem(Double departurePositionItem) {
    if (this.departurePosition == null) {
      this.departurePosition = new ArrayList<>();
    }
    this.departurePosition.add(departurePositionItem);
    return this;
  }

  /**
   * &lt;p&gt;The start position for the route. Defined in &lt;a href&#x3D;\&quot;https://earth-info.nga.mil/index.php?dir&#x3D;wgs84&amp;amp;action&#x3D;wgs84\&quot;&gt;World Geodetic System (WGS 84)&lt;/a&gt; format: &lt;code&gt;[longitude, latitude]&lt;/code&gt;.&lt;/p&gt; &lt;ul&gt; &lt;li&gt; &lt;p&gt;For example, &lt;code&gt;[-123.115, 49.285]&lt;/code&gt; &lt;/p&gt; &lt;/li&gt; &lt;/ul&gt; &lt;note&gt; &lt;p&gt;If you specify a departure that&#39;s not located on a road, Amazon Location &lt;a href&#x3D;\&quot;https://docs.aws.amazon.com/location/latest/developerguide/snap-to-nearby-road.html\&quot;&gt;moves the position to the nearest road&lt;/a&gt;. If Esri is the provider for your route calculator, specifying a route that is longer than 400 km returns a &lt;code&gt;400 RoutesValidationException&lt;/code&gt; error.&lt;/p&gt; &lt;/note&gt; &lt;p&gt;Valid Values: &lt;code&gt;[-180 to 180,-90 to 90]&lt;/code&gt; &lt;/p&gt;
   * @return departurePosition
   */
  @javax.annotation.Nonnull
  public List<Double> getDeparturePosition() {
    return departurePosition;
  }

  public void setDeparturePosition(List<Double> departurePosition) {
    this.departurePosition = departurePosition;
  }


  public CalculateRouteRequest departureTime(OffsetDateTime departureTime) {
    this.departureTime = departureTime;
    return this;
  }

  /**
   * &lt;p&gt;Specifies the desired time of departure. Uses the given time to calculate the route. Otherwise, the best time of day to travel with the best traffic conditions is used to calculate the route.&lt;/p&gt; &lt;note&gt; &lt;p&gt;Setting a departure time in the past returns a &lt;code&gt;400 ValidationException&lt;/code&gt; error.&lt;/p&gt; &lt;/note&gt; &lt;ul&gt; &lt;li&gt; &lt;p&gt;In &lt;a href&#x3D;\&quot;https://www.iso.org/iso-8601-date-and-time-format.html\&quot;&gt;ISO 8601&lt;/a&gt; format: &lt;code&gt;YYYY-MM-DDThh:mm:ss.sssZ&lt;/code&gt;. For example, &lt;code&gt;2020â€“07-2T12:15:20.000Z+01:00&lt;/code&gt; &lt;/p&gt; &lt;/li&gt; &lt;/ul&gt;
   * @return departureTime
   */
  @javax.annotation.Nullable
  public OffsetDateTime getDepartureTime() {
    return departureTime;
  }

  public void setDepartureTime(OffsetDateTime departureTime) {
    this.departureTime = departureTime;
  }


  public CalculateRouteRequest destinationPosition(List<Double> destinationPosition) {
    this.destinationPosition = destinationPosition;
    return this;
  }

  public CalculateRouteRequest addDestinationPositionItem(Double destinationPositionItem) {
    if (this.destinationPosition == null) {
      this.destinationPosition = new ArrayList<>();
    }
    this.destinationPosition.add(destinationPositionItem);
    return this;
  }

  /**
   * &lt;p&gt;The finish position for the route. Defined in &lt;a href&#x3D;\&quot;https://earth-info.nga.mil/index.php?dir&#x3D;wgs84&amp;amp;action&#x3D;wgs84\&quot;&gt;World Geodetic System (WGS 84)&lt;/a&gt; format: &lt;code&gt;[longitude, latitude]&lt;/code&gt;.&lt;/p&gt; &lt;ul&gt; &lt;li&gt; &lt;p&gt; For example, &lt;code&gt;[-122.339, 47.615]&lt;/code&gt; &lt;/p&gt; &lt;/li&gt; &lt;/ul&gt; &lt;note&gt; &lt;p&gt;If you specify a destination that&#39;s not located on a road, Amazon Location &lt;a href&#x3D;\&quot;https://docs.aws.amazon.com/location/latest/developerguide/snap-to-nearby-road.html\&quot;&gt;moves the position to the nearest road&lt;/a&gt;. &lt;/p&gt; &lt;/note&gt; &lt;p&gt;Valid Values: &lt;code&gt;[-180 to 180,-90 to 90]&lt;/code&gt; &lt;/p&gt;
   * @return destinationPosition
   */
  @javax.annotation.Nonnull
  public List<Double> getDestinationPosition() {
    return destinationPosition;
  }

  public void setDestinationPosition(List<Double> destinationPosition) {
    this.destinationPosition = destinationPosition;
  }


  public CalculateRouteRequest distanceUnit(DistanceUnitEnum distanceUnit) {
    this.distanceUnit = distanceUnit;
    return this;
  }

  /**
   * &lt;p&gt;Set the unit system to specify the distance.&lt;/p&gt; &lt;p&gt;Default Value: &lt;code&gt;Kilometers&lt;/code&gt; &lt;/p&gt;
   * @return distanceUnit
   */
  @javax.annotation.Nullable
  public DistanceUnitEnum getDistanceUnit() {
    return distanceUnit;
  }

  public void setDistanceUnit(DistanceUnitEnum distanceUnit) {
    this.distanceUnit = distanceUnit;
  }


  public CalculateRouteRequest includeLegGeometry(Boolean includeLegGeometry) {
    this.includeLegGeometry = includeLegGeometry;
    return this;
  }

  /**
   * &lt;p&gt;Set to include the geometry details in the result for each path between a pair of positions.&lt;/p&gt; &lt;p&gt;Default Value: &lt;code&gt;false&lt;/code&gt; &lt;/p&gt; &lt;p&gt;Valid Values: &lt;code&gt;false&lt;/code&gt; | &lt;code&gt;true&lt;/code&gt; &lt;/p&gt;
   * @return includeLegGeometry
   */
  @javax.annotation.Nullable
  public Boolean getIncludeLegGeometry() {
    return includeLegGeometry;
  }

  public void setIncludeLegGeometry(Boolean includeLegGeometry) {
    this.includeLegGeometry = includeLegGeometry;
  }


  public CalculateRouteRequest travelMode(TravelModeEnum travelMode) {
    this.travelMode = travelMode;
    return this;
  }

  /**
   * &lt;p&gt;Specifies the mode of transport when calculating a route. Used in estimating the speed of travel and road compatibility. You can choose &lt;code&gt;Car&lt;/code&gt;, &lt;code&gt;Truck&lt;/code&gt;, &lt;code&gt;Walking&lt;/code&gt;, &lt;code&gt;Bicycle&lt;/code&gt; or &lt;code&gt;Motorcycle&lt;/code&gt; as options for the &lt;code&gt;TravelMode&lt;/code&gt;.&lt;/p&gt; &lt;note&gt; &lt;p&gt; &lt;code&gt;Bicycle&lt;/code&gt; and &lt;code&gt;Motorcycle&lt;/code&gt; are only valid when using Grab as a data provider, and only within Southeast Asia.&lt;/p&gt; &lt;p&gt; &lt;code&gt;Truck&lt;/code&gt; is not available for Grab.&lt;/p&gt; &lt;p&gt;For more details on the using Grab for routing, including areas of coverage, see &lt;a href&#x3D;\&quot;https://docs.aws.amazon.com/location/latest/developerguide/grab.html\&quot;&gt;GrabMaps&lt;/a&gt; in the &lt;i&gt;Amazon Location Service Developer Guide&lt;/i&gt;.&lt;/p&gt; &lt;/note&gt; &lt;p&gt;The &lt;code&gt;TravelMode&lt;/code&gt; you specify also determines how you specify route preferences: &lt;/p&gt; &lt;ul&gt; &lt;li&gt; &lt;p&gt;If traveling by &lt;code&gt;Car&lt;/code&gt; use the &lt;code&gt;CarModeOptions&lt;/code&gt; parameter.&lt;/p&gt; &lt;/li&gt; &lt;li&gt; &lt;p&gt;If traveling by &lt;code&gt;Truck&lt;/code&gt; use the &lt;code&gt;TruckModeOptions&lt;/code&gt; parameter.&lt;/p&gt; &lt;/li&gt; &lt;/ul&gt; &lt;p&gt;Default Value: &lt;code&gt;Car&lt;/code&gt; &lt;/p&gt;
   * @return travelMode
   */
  @javax.annotation.Nullable
  public TravelModeEnum getTravelMode() {
    return travelMode;
  }

  public void setTravelMode(TravelModeEnum travelMode) {
    this.travelMode = travelMode;
  }


  public CalculateRouteRequest truckModeOptions(CalculateRouteRequestTruckModeOptions truckModeOptions) {
    this.truckModeOptions = truckModeOptions;
    return this;
  }

  /**
   * Get truckModeOptions
   * @return truckModeOptions
   */
  @javax.annotation.Nullable
  public CalculateRouteRequestTruckModeOptions getTruckModeOptions() {
    return truckModeOptions;
  }

  public void setTruckModeOptions(CalculateRouteRequestTruckModeOptions truckModeOptions) {
    this.truckModeOptions = truckModeOptions;
  }


  public CalculateRouteRequest waypointPositions(List<List<Double>> waypointPositions) {
    this.waypointPositions = waypointPositions;
    return this;
  }

  public CalculateRouteRequest addWaypointPositionsItem(List<Double> waypointPositionsItem) {
    if (this.waypointPositions == null) {
      this.waypointPositions = new ArrayList<>();
    }
    this.waypointPositions.add(waypointPositionsItem);
    return this;
  }

  /**
   * &lt;p&gt;Specifies an ordered list of up to 23 intermediate positions to include along a route between the departure position and destination position. &lt;/p&gt; &lt;ul&gt; &lt;li&gt; &lt;p&gt;For example, from the &lt;code&gt;DeparturePosition&lt;/code&gt; &lt;code&gt;[-123.115, 49.285]&lt;/code&gt;, the route follows the order that the waypoint positions are given &lt;code&gt;[[-122.757, 49.0021],[-122.349, 47.620]]&lt;/code&gt; &lt;/p&gt; &lt;/li&gt; &lt;/ul&gt; &lt;note&gt; &lt;p&gt;If you specify a waypoint position that&#39;s not located on a road, Amazon Location &lt;a href&#x3D;\&quot;https://docs.aws.amazon.com/location/latest/developerguide/snap-to-nearby-road.html\&quot;&gt;moves the position to the nearest road&lt;/a&gt;. &lt;/p&gt; &lt;p&gt;Specifying more than 23 waypoints returns a &lt;code&gt;400 ValidationException&lt;/code&gt; error.&lt;/p&gt; &lt;p&gt;If Esri is the provider for your route calculator, specifying a route that is longer than 400 km returns a &lt;code&gt;400 RoutesValidationException&lt;/code&gt; error.&lt;/p&gt; &lt;/note&gt; &lt;p&gt;Valid Values: &lt;code&gt;[-180 to 180,-90 to 90]&lt;/code&gt; &lt;/p&gt;
   * @return waypointPositions
   */
  @javax.annotation.Nullable
  public List<List<Double>> getWaypointPositions() {
    return waypointPositions;
  }

  public void setWaypointPositions(List<List<Double>> waypointPositions) {
    this.waypointPositions = waypointPositions;
  }



  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    CalculateRouteRequest calculateRouteRequest = (CalculateRouteRequest) o;
    return Objects.equals(this.carModeOptions, calculateRouteRequest.carModeOptions) &&
        Objects.equals(this.departNow, calculateRouteRequest.departNow) &&
        Objects.equals(this.departurePosition, calculateRouteRequest.departurePosition) &&
        Objects.equals(this.departureTime, calculateRouteRequest.departureTime) &&
        Objects.equals(this.destinationPosition, calculateRouteRequest.destinationPosition) &&
        Objects.equals(this.distanceUnit, calculateRouteRequest.distanceUnit) &&
        Objects.equals(this.includeLegGeometry, calculateRouteRequest.includeLegGeometry) &&
        Objects.equals(this.travelMode, calculateRouteRequest.travelMode) &&
        Objects.equals(this.truckModeOptions, calculateRouteRequest.truckModeOptions) &&
        Objects.equals(this.waypointPositions, calculateRouteRequest.waypointPositions);
  }

  @Override
  public int hashCode() {
    return Objects.hash(carModeOptions, departNow, departurePosition, departureTime, destinationPosition, distanceUnit, includeLegGeometry, travelMode, truckModeOptions, waypointPositions);
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class CalculateRouteRequest {\n");
    sb.append("    carModeOptions: ").append(toIndentedString(carModeOptions)).append("\n");
    sb.append("    departNow: ").append(toIndentedString(departNow)).append("\n");
    sb.append("    departurePosition: ").append(toIndentedString(departurePosition)).append("\n");
    sb.append("    departureTime: ").append(toIndentedString(departureTime)).append("\n");
    sb.append("    destinationPosition: ").append(toIndentedString(destinationPosition)).append("\n");
    sb.append("    distanceUnit: ").append(toIndentedString(distanceUnit)).append("\n");
    sb.append("    includeLegGeometry: ").append(toIndentedString(includeLegGeometry)).append("\n");
    sb.append("    travelMode: ").append(toIndentedString(travelMode)).append("\n");
    sb.append("    truckModeOptions: ").append(toIndentedString(truckModeOptions)).append("\n");
    sb.append("    waypointPositions: ").append(toIndentedString(waypointPositions)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }


  public static HashSet<String> openapiFields;
  public static HashSet<String> openapiRequiredFields;

  static {
    // a set of all properties/fields (JSON key names)
    openapiFields = new HashSet<String>();
    openapiFields.add("CarModeOptions");
    openapiFields.add("DepartNow");
    openapiFields.add("DeparturePosition");
    openapiFields.add("DepartureTime");
    openapiFields.add("DestinationPosition");
    openapiFields.add("DistanceUnit");
    openapiFields.add("IncludeLegGeometry");
    openapiFields.add("TravelMode");
    openapiFields.add("TruckModeOptions");
    openapiFields.add("WaypointPositions");

    // a set of required properties/fields (JSON key names)
    openapiRequiredFields = new HashSet<String>();
    openapiRequiredFields.add("DeparturePosition");
    openapiRequiredFields.add("DestinationPosition");
  }

  /**
   * Validates the JSON Element and throws an exception if issues found
   *
   * @param jsonElement JSON Element
   * @throws IOException if the JSON Element is invalid with respect to CalculateRouteRequest
   */
  public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      if (jsonElement == null) {
        if (!CalculateRouteRequest.openapiRequiredFields.isEmpty()) { // has required fields but JSON element is null
          throw new IllegalArgumentException(String.format("The required field(s) %s in CalculateRouteRequest is not found in the empty JSON string", CalculateRouteRequest.openapiRequiredFields.toString()));
        }
      }

      Set<Map.Entry<String, JsonElement>> entries = jsonElement.getAsJsonObject().entrySet();
      // check to see if the JSON string contains additional fields
      for (Map.Entry<String, JsonElement> entry : entries) {
        if (!CalculateRouteRequest.openapiFields.contains(entry.getKey())) {
          throw new IllegalArgumentException(String.format("The field `%s` in the JSON string is not defined in the `CalculateRouteRequest` properties. JSON: %s", entry.getKey(), jsonElement.toString()));
        }
      }

      // check to make sure all required properties/fields are present in the JSON string
      for (String requiredField : CalculateRouteRequest.openapiRequiredFields) {
        if (jsonElement.getAsJsonObject().get(requiredField) == null) {
          throw new IllegalArgumentException(String.format("The required field `%s` is not found in the JSON string: %s", requiredField, jsonElement.toString()));
        }
      }
        JsonObject jsonObj = jsonElement.getAsJsonObject();
      // validate the optional field `CarModeOptions`
      if (jsonObj.get("CarModeOptions") != null && !jsonObj.get("CarModeOptions").isJsonNull()) {
        CalculateRouteRequestCarModeOptions.validateJsonElement(jsonObj.get("CarModeOptions"));
      }
      // ensure the required json array is present
      if (jsonObj.get("DeparturePosition") == null) {
        throw new IllegalArgumentException("Expected the field `linkedContent` to be an array in the JSON string but got `null`");
      } else if (!jsonObj.get("DeparturePosition").isJsonArray()) {
        throw new IllegalArgumentException(String.format("Expected the field `DeparturePosition` to be an array in the JSON string but got `%s`", jsonObj.get("DeparturePosition").toString()));
      }
      // ensure the required json array is present
      if (jsonObj.get("DestinationPosition") == null) {
        throw new IllegalArgumentException("Expected the field `linkedContent` to be an array in the JSON string but got `null`");
      } else if (!jsonObj.get("DestinationPosition").isJsonArray()) {
        throw new IllegalArgumentException(String.format("Expected the field `DestinationPosition` to be an array in the JSON string but got `%s`", jsonObj.get("DestinationPosition").toString()));
      }
      if ((jsonObj.get("DistanceUnit") != null && !jsonObj.get("DistanceUnit").isJsonNull()) && !jsonObj.get("DistanceUnit").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `DistanceUnit` to be a primitive type in the JSON string but got `%s`", jsonObj.get("DistanceUnit").toString()));
      }
      // validate the optional field `DistanceUnit`
      if (jsonObj.get("DistanceUnit") != null && !jsonObj.get("DistanceUnit").isJsonNull()) {
        DistanceUnitEnum.validateJsonElement(jsonObj.get("DistanceUnit"));
      }
      if ((jsonObj.get("TravelMode") != null && !jsonObj.get("TravelMode").isJsonNull()) && !jsonObj.get("TravelMode").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `TravelMode` to be a primitive type in the JSON string but got `%s`", jsonObj.get("TravelMode").toString()));
      }
      // validate the optional field `TravelMode`
      if (jsonObj.get("TravelMode") != null && !jsonObj.get("TravelMode").isJsonNull()) {
        TravelModeEnum.validateJsonElement(jsonObj.get("TravelMode"));
      }
      // validate the optional field `TruckModeOptions`
      if (jsonObj.get("TruckModeOptions") != null && !jsonObj.get("TruckModeOptions").isJsonNull()) {
        CalculateRouteRequestTruckModeOptions.validateJsonElement(jsonObj.get("TruckModeOptions"));
      }
      // ensure the optional json data is an array if present
      if (jsonObj.get("WaypointPositions") != null && !jsonObj.get("WaypointPositions").isJsonNull() && !jsonObj.get("WaypointPositions").isJsonArray()) {
        throw new IllegalArgumentException(String.format("Expected the field `WaypointPositions` to be an array in the JSON string but got `%s`", jsonObj.get("WaypointPositions").toString()));
      }
  }

  public static class CustomTypeAdapterFactory implements TypeAdapterFactory {
    @SuppressWarnings("unchecked")
    @Override
    public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
       if (!CalculateRouteRequest.class.isAssignableFrom(type.getRawType())) {
         return null; // this class only serializes 'CalculateRouteRequest' and its subtypes
       }
       final TypeAdapter<JsonElement> elementAdapter = gson.getAdapter(JsonElement.class);
       final TypeAdapter<CalculateRouteRequest> thisAdapter
                        = gson.getDelegateAdapter(this, TypeToken.get(CalculateRouteRequest.class));

       return (TypeAdapter<T>) new TypeAdapter<CalculateRouteRequest>() {
           @Override
           public void write(JsonWriter out, CalculateRouteRequest value) throws IOException {
             JsonObject obj = thisAdapter.toJsonTree(value).getAsJsonObject();
             elementAdapter.write(out, obj);
           }

           @Override
           public CalculateRouteRequest read(JsonReader in) throws IOException {
             JsonElement jsonElement = elementAdapter.read(in);
             validateJsonElement(jsonElement);
             return thisAdapter.fromJsonTree(jsonElement);
           }

       }.nullSafe();
    }
  }

  /**
   * Create an instance of CalculateRouteRequest given an JSON string
   *
   * @param jsonString JSON string
   * @return An instance of CalculateRouteRequest
   * @throws IOException if the JSON string is invalid with respect to CalculateRouteRequest
   */
  public static CalculateRouteRequest fromJson(String jsonString) throws IOException {
    return JSON.getGson().fromJson(jsonString, CalculateRouteRequest.class);
  }

  /**
   * Convert an instance of CalculateRouteRequest to an JSON string
   *
   * @return JSON string
   */
  public String toJson() {
    return JSON.getGson().toJson(this);
  }
}

