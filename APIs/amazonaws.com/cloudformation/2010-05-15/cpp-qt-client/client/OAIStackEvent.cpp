/**
 * AWS CloudFormation
 * <fullname>CloudFormation</fullname> <p>CloudFormation allows you to create and manage Amazon Web Services infrastructure deployments predictably and repeatedly. You can use CloudFormation to leverage Amazon Web Services products, such as Amazon Elastic Compute Cloud, Amazon Elastic Block Store, Amazon Simple Notification Service, Elastic Load Balancing, and Auto Scaling to build highly reliable, highly scalable, cost-effective applications without creating or configuring the underlying Amazon Web Services infrastructure.</p> <p>With CloudFormation, you declare all your resources and dependencies in a template file. The template defines a collection of resources as a single unit called a stack. CloudFormation creates and deletes all member resources of the stack together and manages all dependencies between the resources for you.</p> <p>For more information about CloudFormation, see the <a href=\"http://aws.amazon.com/cloudformation/\">CloudFormation product page</a>.</p> <p>CloudFormation makes use of other Amazon Web Services products. If you need additional technical information about a specific Amazon Web Services product, you can find the product's technical documentation at <a href=\"https://docs.aws.amazon.com/\">docs.aws.amazon.com</a>.</p>
 *
 * The version of the OpenAPI document: 2010-05-15
 * Contact: mike.ralphson@gmail.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

#include "OAIStackEvent.h"

#include <QDebug>
#include <QJsonArray>
#include <QJsonDocument>
#include <QObject>

#include "OAIHelpers.h"

namespace OpenAPI {

OAIStackEvent::OAIStackEvent(QString json) {
    this->initializeModel();
    this->fromJson(json);
}

OAIStackEvent::OAIStackEvent() {
    this->initializeModel();
}

OAIStackEvent::~OAIStackEvent() {}

void OAIStackEvent::initializeModel() {

    m_stack_id_isSet = false;
    m_stack_id_isValid = false;

    m_event_id_isSet = false;
    m_event_id_isValid = false;

    m_stack_name_isSet = false;
    m_stack_name_isValid = false;

    m_logical_resource_id_isSet = false;
    m_logical_resource_id_isValid = false;

    m_physical_resource_id_isSet = false;
    m_physical_resource_id_isValid = false;

    m_resource_type_isSet = false;
    m_resource_type_isValid = false;

    m_timestamp_isSet = false;
    m_timestamp_isValid = false;

    m_resource_status_isSet = false;
    m_resource_status_isValid = false;

    m_resource_status_reason_isSet = false;
    m_resource_status_reason_isValid = false;

    m_resource_properties_isSet = false;
    m_resource_properties_isValid = false;

    m_client_request_token_isSet = false;
    m_client_request_token_isValid = false;

    m_hook_type_isSet = false;
    m_hook_type_isValid = false;

    m_hook_status_isSet = false;
    m_hook_status_isValid = false;

    m_hook_status_reason_isSet = false;
    m_hook_status_reason_isValid = false;

    m_hook_invocation_point_isSet = false;
    m_hook_invocation_point_isValid = false;

    m_hook_failure_mode_isSet = false;
    m_hook_failure_mode_isValid = false;
}

void OAIStackEvent::fromJson(QString jsonString) {
    QByteArray array(jsonString.toStdString().c_str());
    QJsonDocument doc = QJsonDocument::fromJson(array);
    QJsonObject jsonObject = doc.object();
    this->fromJsonObject(jsonObject);
}

void OAIStackEvent::fromJsonObject(QJsonObject json) {

    m_stack_id_isValid = ::OpenAPI::fromJsonValue(m_stack_id, json[QString("StackId")]);
    m_stack_id_isSet = !json[QString("StackId")].isNull() && m_stack_id_isValid;

    m_event_id_isValid = ::OpenAPI::fromJsonValue(m_event_id, json[QString("EventId")]);
    m_event_id_isSet = !json[QString("EventId")].isNull() && m_event_id_isValid;

    m_stack_name_isValid = ::OpenAPI::fromJsonValue(m_stack_name, json[QString("StackName")]);
    m_stack_name_isSet = !json[QString("StackName")].isNull() && m_stack_name_isValid;

    m_logical_resource_id_isValid = ::OpenAPI::fromJsonValue(m_logical_resource_id, json[QString("LogicalResourceId")]);
    m_logical_resource_id_isSet = !json[QString("LogicalResourceId")].isNull() && m_logical_resource_id_isValid;

    m_physical_resource_id_isValid = ::OpenAPI::fromJsonValue(m_physical_resource_id, json[QString("PhysicalResourceId")]);
    m_physical_resource_id_isSet = !json[QString("PhysicalResourceId")].isNull() && m_physical_resource_id_isValid;

    m_resource_type_isValid = ::OpenAPI::fromJsonValue(m_resource_type, json[QString("ResourceType")]);
    m_resource_type_isSet = !json[QString("ResourceType")].isNull() && m_resource_type_isValid;

    m_timestamp_isValid = ::OpenAPI::fromJsonValue(m_timestamp, json[QString("Timestamp")]);
    m_timestamp_isSet = !json[QString("Timestamp")].isNull() && m_timestamp_isValid;

    m_resource_status_isValid = ::OpenAPI::fromJsonValue(m_resource_status, json[QString("ResourceStatus")]);
    m_resource_status_isSet = !json[QString("ResourceStatus")].isNull() && m_resource_status_isValid;

    m_resource_status_reason_isValid = ::OpenAPI::fromJsonValue(m_resource_status_reason, json[QString("ResourceStatusReason")]);
    m_resource_status_reason_isSet = !json[QString("ResourceStatusReason")].isNull() && m_resource_status_reason_isValid;

    m_resource_properties_isValid = ::OpenAPI::fromJsonValue(m_resource_properties, json[QString("ResourceProperties")]);
    m_resource_properties_isSet = !json[QString("ResourceProperties")].isNull() && m_resource_properties_isValid;

    m_client_request_token_isValid = ::OpenAPI::fromJsonValue(m_client_request_token, json[QString("ClientRequestToken")]);
    m_client_request_token_isSet = !json[QString("ClientRequestToken")].isNull() && m_client_request_token_isValid;

    m_hook_type_isValid = ::OpenAPI::fromJsonValue(m_hook_type, json[QString("HookType")]);
    m_hook_type_isSet = !json[QString("HookType")].isNull() && m_hook_type_isValid;

    m_hook_status_isValid = ::OpenAPI::fromJsonValue(m_hook_status, json[QString("HookStatus")]);
    m_hook_status_isSet = !json[QString("HookStatus")].isNull() && m_hook_status_isValid;

    m_hook_status_reason_isValid = ::OpenAPI::fromJsonValue(m_hook_status_reason, json[QString("HookStatusReason")]);
    m_hook_status_reason_isSet = !json[QString("HookStatusReason")].isNull() && m_hook_status_reason_isValid;

    m_hook_invocation_point_isValid = ::OpenAPI::fromJsonValue(m_hook_invocation_point, json[QString("HookInvocationPoint")]);
    m_hook_invocation_point_isSet = !json[QString("HookInvocationPoint")].isNull() && m_hook_invocation_point_isValid;

    m_hook_failure_mode_isValid = ::OpenAPI::fromJsonValue(m_hook_failure_mode, json[QString("HookFailureMode")]);
    m_hook_failure_mode_isSet = !json[QString("HookFailureMode")].isNull() && m_hook_failure_mode_isValid;
}

QString OAIStackEvent::asJson() const {
    QJsonObject obj = this->asJsonObject();
    QJsonDocument doc(obj);
    QByteArray bytes = doc.toJson();
    return QString(bytes);
}

QJsonObject OAIStackEvent::asJsonObject() const {
    QJsonObject obj;
    if (m_stack_id_isSet) {
        obj.insert(QString("StackId"), ::OpenAPI::toJsonValue(m_stack_id));
    }
    if (m_event_id_isSet) {
        obj.insert(QString("EventId"), ::OpenAPI::toJsonValue(m_event_id));
    }
    if (m_stack_name_isSet) {
        obj.insert(QString("StackName"), ::OpenAPI::toJsonValue(m_stack_name));
    }
    if (m_logical_resource_id_isSet) {
        obj.insert(QString("LogicalResourceId"), ::OpenAPI::toJsonValue(m_logical_resource_id));
    }
    if (m_physical_resource_id_isSet) {
        obj.insert(QString("PhysicalResourceId"), ::OpenAPI::toJsonValue(m_physical_resource_id));
    }
    if (m_resource_type_isSet) {
        obj.insert(QString("ResourceType"), ::OpenAPI::toJsonValue(m_resource_type));
    }
    if (m_timestamp_isSet) {
        obj.insert(QString("Timestamp"), ::OpenAPI::toJsonValue(m_timestamp));
    }
    if (m_resource_status.isSet()) {
        obj.insert(QString("ResourceStatus"), ::OpenAPI::toJsonValue(m_resource_status));
    }
    if (m_resource_status_reason_isSet) {
        obj.insert(QString("ResourceStatusReason"), ::OpenAPI::toJsonValue(m_resource_status_reason));
    }
    if (m_resource_properties_isSet) {
        obj.insert(QString("ResourceProperties"), ::OpenAPI::toJsonValue(m_resource_properties));
    }
    if (m_client_request_token_isSet) {
        obj.insert(QString("ClientRequestToken"), ::OpenAPI::toJsonValue(m_client_request_token));
    }
    if (m_hook_type_isSet) {
        obj.insert(QString("HookType"), ::OpenAPI::toJsonValue(m_hook_type));
    }
    if (m_hook_status.isSet()) {
        obj.insert(QString("HookStatus"), ::OpenAPI::toJsonValue(m_hook_status));
    }
    if (m_hook_status_reason_isSet) {
        obj.insert(QString("HookStatusReason"), ::OpenAPI::toJsonValue(m_hook_status_reason));
    }
    if (m_hook_invocation_point.isSet()) {
        obj.insert(QString("HookInvocationPoint"), ::OpenAPI::toJsonValue(m_hook_invocation_point));
    }
    if (m_hook_failure_mode.isSet()) {
        obj.insert(QString("HookFailureMode"), ::OpenAPI::toJsonValue(m_hook_failure_mode));
    }
    return obj;
}

QString OAIStackEvent::getStackId() const {
    return m_stack_id;
}
void OAIStackEvent::setStackId(const QString &stack_id) {
    m_stack_id = stack_id;
    m_stack_id_isSet = true;
}

bool OAIStackEvent::is_stack_id_Set() const{
    return m_stack_id_isSet;
}

bool OAIStackEvent::is_stack_id_Valid() const{
    return m_stack_id_isValid;
}

QString OAIStackEvent::getEventId() const {
    return m_event_id;
}
void OAIStackEvent::setEventId(const QString &event_id) {
    m_event_id = event_id;
    m_event_id_isSet = true;
}

bool OAIStackEvent::is_event_id_Set() const{
    return m_event_id_isSet;
}

bool OAIStackEvent::is_event_id_Valid() const{
    return m_event_id_isValid;
}

QString OAIStackEvent::getStackName() const {
    return m_stack_name;
}
void OAIStackEvent::setStackName(const QString &stack_name) {
    m_stack_name = stack_name;
    m_stack_name_isSet = true;
}

bool OAIStackEvent::is_stack_name_Set() const{
    return m_stack_name_isSet;
}

bool OAIStackEvent::is_stack_name_Valid() const{
    return m_stack_name_isValid;
}

QString OAIStackEvent::getLogicalResourceId() const {
    return m_logical_resource_id;
}
void OAIStackEvent::setLogicalResourceId(const QString &logical_resource_id) {
    m_logical_resource_id = logical_resource_id;
    m_logical_resource_id_isSet = true;
}

bool OAIStackEvent::is_logical_resource_id_Set() const{
    return m_logical_resource_id_isSet;
}

bool OAIStackEvent::is_logical_resource_id_Valid() const{
    return m_logical_resource_id_isValid;
}

QString OAIStackEvent::getPhysicalResourceId() const {
    return m_physical_resource_id;
}
void OAIStackEvent::setPhysicalResourceId(const QString &physical_resource_id) {
    m_physical_resource_id = physical_resource_id;
    m_physical_resource_id_isSet = true;
}

bool OAIStackEvent::is_physical_resource_id_Set() const{
    return m_physical_resource_id_isSet;
}

bool OAIStackEvent::is_physical_resource_id_Valid() const{
    return m_physical_resource_id_isValid;
}

QString OAIStackEvent::getResourceType() const {
    return m_resource_type;
}
void OAIStackEvent::setResourceType(const QString &resource_type) {
    m_resource_type = resource_type;
    m_resource_type_isSet = true;
}

bool OAIStackEvent::is_resource_type_Set() const{
    return m_resource_type_isSet;
}

bool OAIStackEvent::is_resource_type_Valid() const{
    return m_resource_type_isValid;
}

QDateTime OAIStackEvent::getTimestamp() const {
    return m_timestamp;
}
void OAIStackEvent::setTimestamp(const QDateTime &timestamp) {
    m_timestamp = timestamp;
    m_timestamp_isSet = true;
}

bool OAIStackEvent::is_timestamp_Set() const{
    return m_timestamp_isSet;
}

bool OAIStackEvent::is_timestamp_Valid() const{
    return m_timestamp_isValid;
}

OAIResourceStatus OAIStackEvent::getResourceStatus() const {
    return m_resource_status;
}
void OAIStackEvent::setResourceStatus(const OAIResourceStatus &resource_status) {
    m_resource_status = resource_status;
    m_resource_status_isSet = true;
}

bool OAIStackEvent::is_resource_status_Set() const{
    return m_resource_status_isSet;
}

bool OAIStackEvent::is_resource_status_Valid() const{
    return m_resource_status_isValid;
}

QString OAIStackEvent::getResourceStatusReason() const {
    return m_resource_status_reason;
}
void OAIStackEvent::setResourceStatusReason(const QString &resource_status_reason) {
    m_resource_status_reason = resource_status_reason;
    m_resource_status_reason_isSet = true;
}

bool OAIStackEvent::is_resource_status_reason_Set() const{
    return m_resource_status_reason_isSet;
}

bool OAIStackEvent::is_resource_status_reason_Valid() const{
    return m_resource_status_reason_isValid;
}

QString OAIStackEvent::getResourceProperties() const {
    return m_resource_properties;
}
void OAIStackEvent::setResourceProperties(const QString &resource_properties) {
    m_resource_properties = resource_properties;
    m_resource_properties_isSet = true;
}

bool OAIStackEvent::is_resource_properties_Set() const{
    return m_resource_properties_isSet;
}

bool OAIStackEvent::is_resource_properties_Valid() const{
    return m_resource_properties_isValid;
}

QString OAIStackEvent::getClientRequestToken() const {
    return m_client_request_token;
}
void OAIStackEvent::setClientRequestToken(const QString &client_request_token) {
    m_client_request_token = client_request_token;
    m_client_request_token_isSet = true;
}

bool OAIStackEvent::is_client_request_token_Set() const{
    return m_client_request_token_isSet;
}

bool OAIStackEvent::is_client_request_token_Valid() const{
    return m_client_request_token_isValid;
}

QString OAIStackEvent::getHookType() const {
    return m_hook_type;
}
void OAIStackEvent::setHookType(const QString &hook_type) {
    m_hook_type = hook_type;
    m_hook_type_isSet = true;
}

bool OAIStackEvent::is_hook_type_Set() const{
    return m_hook_type_isSet;
}

bool OAIStackEvent::is_hook_type_Valid() const{
    return m_hook_type_isValid;
}

OAIHookStatus OAIStackEvent::getHookStatus() const {
    return m_hook_status;
}
void OAIStackEvent::setHookStatus(const OAIHookStatus &hook_status) {
    m_hook_status = hook_status;
    m_hook_status_isSet = true;
}

bool OAIStackEvent::is_hook_status_Set() const{
    return m_hook_status_isSet;
}

bool OAIStackEvent::is_hook_status_Valid() const{
    return m_hook_status_isValid;
}

QString OAIStackEvent::getHookStatusReason() const {
    return m_hook_status_reason;
}
void OAIStackEvent::setHookStatusReason(const QString &hook_status_reason) {
    m_hook_status_reason = hook_status_reason;
    m_hook_status_reason_isSet = true;
}

bool OAIStackEvent::is_hook_status_reason_Set() const{
    return m_hook_status_reason_isSet;
}

bool OAIStackEvent::is_hook_status_reason_Valid() const{
    return m_hook_status_reason_isValid;
}

OAIHookInvocationPoint OAIStackEvent::getHookInvocationPoint() const {
    return m_hook_invocation_point;
}
void OAIStackEvent::setHookInvocationPoint(const OAIHookInvocationPoint &hook_invocation_point) {
    m_hook_invocation_point = hook_invocation_point;
    m_hook_invocation_point_isSet = true;
}

bool OAIStackEvent::is_hook_invocation_point_Set() const{
    return m_hook_invocation_point_isSet;
}

bool OAIStackEvent::is_hook_invocation_point_Valid() const{
    return m_hook_invocation_point_isValid;
}

OAIHookFailureMode OAIStackEvent::getHookFailureMode() const {
    return m_hook_failure_mode;
}
void OAIStackEvent::setHookFailureMode(const OAIHookFailureMode &hook_failure_mode) {
    m_hook_failure_mode = hook_failure_mode;
    m_hook_failure_mode_isSet = true;
}

bool OAIStackEvent::is_hook_failure_mode_Set() const{
    return m_hook_failure_mode_isSet;
}

bool OAIStackEvent::is_hook_failure_mode_Valid() const{
    return m_hook_failure_mode_isValid;
}

bool OAIStackEvent::isSet() const {
    bool isObjectUpdated = false;
    do {
        if (m_stack_id_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_event_id_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_stack_name_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_logical_resource_id_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_physical_resource_id_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_resource_type_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_timestamp_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_resource_status.isSet()) {
            isObjectUpdated = true;
            break;
        }

        if (m_resource_status_reason_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_resource_properties_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_client_request_token_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_hook_type_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_hook_status.isSet()) {
            isObjectUpdated = true;
            break;
        }

        if (m_hook_status_reason_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_hook_invocation_point.isSet()) {
            isObjectUpdated = true;
            break;
        }

        if (m_hook_failure_mode.isSet()) {
            isObjectUpdated = true;
            break;
        }
    } while (false);
    return isObjectUpdated;
}

bool OAIStackEvent::isValid() const {
    // only required properties are required for the object to be considered valid
    return m_stack_id_isValid && m_event_id_isValid && m_stack_name_isValid && m_timestamp_isValid && true;
}

} // namespace OpenAPI
