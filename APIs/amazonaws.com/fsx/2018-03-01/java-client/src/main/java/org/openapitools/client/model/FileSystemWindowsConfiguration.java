/*
 * Amazon FSx
 * Amazon FSx is a fully managed service that makes it easy for storage and application administrators to launch and use shared file storage.
 *
 * The version of the OpenAPI document: 2018-03-01
 * Contact: mike.ralphson@gmail.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package org.openapitools.client.model;

import java.util.Objects;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import org.openapitools.client.model.Alias;
import org.openapitools.client.model.SelfManagedActiveDirectoryAttributes;
import org.openapitools.client.model.WindowsDeploymentType;
import org.openapitools.client.model.WindowsFileSystemConfigurationAuditLogConfiguration;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonArray;
import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;
import com.google.gson.TypeAdapterFactory;
import com.google.gson.reflect.TypeToken;
import com.google.gson.TypeAdapter;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;

import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import org.openapitools.client.JSON;

/**
 * FileSystemWindowsConfiguration
 */
@javax.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen", date = "2024-10-12T12:04:01.724479-04:00[America/New_York]", comments = "Generator version: 7.9.0")
public class FileSystemWindowsConfiguration {
  public static final String SERIALIZED_NAME_ACTIVE_DIRECTORY_ID = "ActiveDirectoryId";
  @SerializedName(SERIALIZED_NAME_ACTIVE_DIRECTORY_ID)
  private String activeDirectoryId;

  public static final String SERIALIZED_NAME_SELF_MANAGED_ACTIVE_DIRECTORY_CONFIGURATION = "SelfManagedActiveDirectoryConfiguration";
  @SerializedName(SERIALIZED_NAME_SELF_MANAGED_ACTIVE_DIRECTORY_CONFIGURATION)
  private SelfManagedActiveDirectoryAttributes selfManagedActiveDirectoryConfiguration;

  public static final String SERIALIZED_NAME_DEPLOYMENT_TYPE = "DeploymentType";
  @SerializedName(SERIALIZED_NAME_DEPLOYMENT_TYPE)
  private WindowsDeploymentType deploymentType;

  public static final String SERIALIZED_NAME_REMOTE_ADMINISTRATION_ENDPOINT = "RemoteAdministrationEndpoint";
  @SerializedName(SERIALIZED_NAME_REMOTE_ADMINISTRATION_ENDPOINT)
  private String remoteAdministrationEndpoint;

  public static final String SERIALIZED_NAME_PREFERRED_SUBNET_ID = "PreferredSubnetId";
  @SerializedName(SERIALIZED_NAME_PREFERRED_SUBNET_ID)
  private String preferredSubnetId;

  public static final String SERIALIZED_NAME_PREFERRED_FILE_SERVER_IP = "PreferredFileServerIp";
  @SerializedName(SERIALIZED_NAME_PREFERRED_FILE_SERVER_IP)
  private String preferredFileServerIp;

  public static final String SERIALIZED_NAME_THROUGHPUT_CAPACITY = "ThroughputCapacity";
  @SerializedName(SERIALIZED_NAME_THROUGHPUT_CAPACITY)
  private Integer throughputCapacity;

  public static final String SERIALIZED_NAME_MAINTENANCE_OPERATIONS_IN_PROGRESS = "MaintenanceOperationsInProgress";
  @SerializedName(SERIALIZED_NAME_MAINTENANCE_OPERATIONS_IN_PROGRESS)
  private List maintenanceOperationsInProgress;

  public static final String SERIALIZED_NAME_WEEKLY_MAINTENANCE_START_TIME = "WeeklyMaintenanceStartTime";
  @SerializedName(SERIALIZED_NAME_WEEKLY_MAINTENANCE_START_TIME)
  private String weeklyMaintenanceStartTime;

  public static final String SERIALIZED_NAME_DAILY_AUTOMATIC_BACKUP_START_TIME = "DailyAutomaticBackupStartTime";
  @SerializedName(SERIALIZED_NAME_DAILY_AUTOMATIC_BACKUP_START_TIME)
  private String dailyAutomaticBackupStartTime;

  public static final String SERIALIZED_NAME_AUTOMATIC_BACKUP_RETENTION_DAYS = "AutomaticBackupRetentionDays";
  @SerializedName(SERIALIZED_NAME_AUTOMATIC_BACKUP_RETENTION_DAYS)
  private Integer automaticBackupRetentionDays;

  public static final String SERIALIZED_NAME_COPY_TAGS_TO_BACKUPS = "CopyTagsToBackups";
  @SerializedName(SERIALIZED_NAME_COPY_TAGS_TO_BACKUPS)
  private Boolean copyTagsToBackups;

  public static final String SERIALIZED_NAME_ALIASES = "Aliases";
  @SerializedName(SERIALIZED_NAME_ALIASES)
  private List<Alias> aliases = new ArrayList<>();

  public static final String SERIALIZED_NAME_AUDIT_LOG_CONFIGURATION = "AuditLogConfiguration";
  @SerializedName(SERIALIZED_NAME_AUDIT_LOG_CONFIGURATION)
  private WindowsFileSystemConfigurationAuditLogConfiguration auditLogConfiguration;

  public FileSystemWindowsConfiguration() {
  }

  public FileSystemWindowsConfiguration activeDirectoryId(String activeDirectoryId) {
    this.activeDirectoryId = activeDirectoryId;
    return this;
  }

  /**
   * Get activeDirectoryId
   * @return activeDirectoryId
   */
  @javax.annotation.Nullable
  public String getActiveDirectoryId() {
    return activeDirectoryId;
  }

  public void setActiveDirectoryId(String activeDirectoryId) {
    this.activeDirectoryId = activeDirectoryId;
  }


  public FileSystemWindowsConfiguration selfManagedActiveDirectoryConfiguration(SelfManagedActiveDirectoryAttributes selfManagedActiveDirectoryConfiguration) {
    this.selfManagedActiveDirectoryConfiguration = selfManagedActiveDirectoryConfiguration;
    return this;
  }

  /**
   * Get selfManagedActiveDirectoryConfiguration
   * @return selfManagedActiveDirectoryConfiguration
   */
  @javax.annotation.Nullable
  public SelfManagedActiveDirectoryAttributes getSelfManagedActiveDirectoryConfiguration() {
    return selfManagedActiveDirectoryConfiguration;
  }

  public void setSelfManagedActiveDirectoryConfiguration(SelfManagedActiveDirectoryAttributes selfManagedActiveDirectoryConfiguration) {
    this.selfManagedActiveDirectoryConfiguration = selfManagedActiveDirectoryConfiguration;
  }


  public FileSystemWindowsConfiguration deploymentType(WindowsDeploymentType deploymentType) {
    this.deploymentType = deploymentType;
    return this;
  }

  /**
   * Get deploymentType
   * @return deploymentType
   */
  @javax.annotation.Nullable
  public WindowsDeploymentType getDeploymentType() {
    return deploymentType;
  }

  public void setDeploymentType(WindowsDeploymentType deploymentType) {
    this.deploymentType = deploymentType;
  }


  public FileSystemWindowsConfiguration remoteAdministrationEndpoint(String remoteAdministrationEndpoint) {
    this.remoteAdministrationEndpoint = remoteAdministrationEndpoint;
    return this;
  }

  /**
   * Get remoteAdministrationEndpoint
   * @return remoteAdministrationEndpoint
   */
  @javax.annotation.Nullable
  public String getRemoteAdministrationEndpoint() {
    return remoteAdministrationEndpoint;
  }

  public void setRemoteAdministrationEndpoint(String remoteAdministrationEndpoint) {
    this.remoteAdministrationEndpoint = remoteAdministrationEndpoint;
  }


  public FileSystemWindowsConfiguration preferredSubnetId(String preferredSubnetId) {
    this.preferredSubnetId = preferredSubnetId;
    return this;
  }

  /**
   * Get preferredSubnetId
   * @return preferredSubnetId
   */
  @javax.annotation.Nullable
  public String getPreferredSubnetId() {
    return preferredSubnetId;
  }

  public void setPreferredSubnetId(String preferredSubnetId) {
    this.preferredSubnetId = preferredSubnetId;
  }


  public FileSystemWindowsConfiguration preferredFileServerIp(String preferredFileServerIp) {
    this.preferredFileServerIp = preferredFileServerIp;
    return this;
  }

  /**
   * Get preferredFileServerIp
   * @return preferredFileServerIp
   */
  @javax.annotation.Nullable
  public String getPreferredFileServerIp() {
    return preferredFileServerIp;
  }

  public void setPreferredFileServerIp(String preferredFileServerIp) {
    this.preferredFileServerIp = preferredFileServerIp;
  }


  public FileSystemWindowsConfiguration throughputCapacity(Integer throughputCapacity) {
    this.throughputCapacity = throughputCapacity;
    return this;
  }

  /**
   * Get throughputCapacity
   * @return throughputCapacity
   */
  @javax.annotation.Nullable
  public Integer getThroughputCapacity() {
    return throughputCapacity;
  }

  public void setThroughputCapacity(Integer throughputCapacity) {
    this.throughputCapacity = throughputCapacity;
  }


  public FileSystemWindowsConfiguration maintenanceOperationsInProgress(List maintenanceOperationsInProgress) {
    this.maintenanceOperationsInProgress = maintenanceOperationsInProgress;
    return this;
  }

  /**
   * Get maintenanceOperationsInProgress
   * @return maintenanceOperationsInProgress
   */
  @javax.annotation.Nullable
  public List getMaintenanceOperationsInProgress() {
    return maintenanceOperationsInProgress;
  }

  public void setMaintenanceOperationsInProgress(List maintenanceOperationsInProgress) {
    this.maintenanceOperationsInProgress = maintenanceOperationsInProgress;
  }


  public FileSystemWindowsConfiguration weeklyMaintenanceStartTime(String weeklyMaintenanceStartTime) {
    this.weeklyMaintenanceStartTime = weeklyMaintenanceStartTime;
    return this;
  }

  /**
   * Get weeklyMaintenanceStartTime
   * @return weeklyMaintenanceStartTime
   */
  @javax.annotation.Nullable
  public String getWeeklyMaintenanceStartTime() {
    return weeklyMaintenanceStartTime;
  }

  public void setWeeklyMaintenanceStartTime(String weeklyMaintenanceStartTime) {
    this.weeklyMaintenanceStartTime = weeklyMaintenanceStartTime;
  }


  public FileSystemWindowsConfiguration dailyAutomaticBackupStartTime(String dailyAutomaticBackupStartTime) {
    this.dailyAutomaticBackupStartTime = dailyAutomaticBackupStartTime;
    return this;
  }

  /**
   * Get dailyAutomaticBackupStartTime
   * @return dailyAutomaticBackupStartTime
   */
  @javax.annotation.Nullable
  public String getDailyAutomaticBackupStartTime() {
    return dailyAutomaticBackupStartTime;
  }

  public void setDailyAutomaticBackupStartTime(String dailyAutomaticBackupStartTime) {
    this.dailyAutomaticBackupStartTime = dailyAutomaticBackupStartTime;
  }


  public FileSystemWindowsConfiguration automaticBackupRetentionDays(Integer automaticBackupRetentionDays) {
    this.automaticBackupRetentionDays = automaticBackupRetentionDays;
    return this;
  }

  /**
   * Get automaticBackupRetentionDays
   * @return automaticBackupRetentionDays
   */
  @javax.annotation.Nullable
  public Integer getAutomaticBackupRetentionDays() {
    return automaticBackupRetentionDays;
  }

  public void setAutomaticBackupRetentionDays(Integer automaticBackupRetentionDays) {
    this.automaticBackupRetentionDays = automaticBackupRetentionDays;
  }


  public FileSystemWindowsConfiguration copyTagsToBackups(Boolean copyTagsToBackups) {
    this.copyTagsToBackups = copyTagsToBackups;
    return this;
  }

  /**
   * Get copyTagsToBackups
   * @return copyTagsToBackups
   */
  @javax.annotation.Nullable
  public Boolean getCopyTagsToBackups() {
    return copyTagsToBackups;
  }

  public void setCopyTagsToBackups(Boolean copyTagsToBackups) {
    this.copyTagsToBackups = copyTagsToBackups;
  }


  public FileSystemWindowsConfiguration aliases(List<Alias> aliases) {
    this.aliases = aliases;
    return this;
  }

  public FileSystemWindowsConfiguration addAliasesItem(Alias aliasesItem) {
    if (this.aliases == null) {
      this.aliases = new ArrayList<>();
    }
    this.aliases.add(aliasesItem);
    return this;
  }

  /**
   * An array of one or more DNS aliases that are currently associated with the Amazon FSx file system. Aliases allow you to use existing DNS names to access the data in your Amazon FSx file system. You can associate up to 50 aliases with a file system at any time. You can associate additional DNS aliases after you create the file system using the AssociateFileSystemAliases operation. You can remove DNS aliases from the file system after it is created using the DisassociateFileSystemAliases operation. You only need to specify the alias name in the request payload. For more information, see &lt;a href&#x3D;\&quot;https://docs.aws.amazon.com/fsx/latest/WindowsGuide/managing-dns-aliases.html\&quot;&gt;DNS aliases&lt;/a&gt;.
   * @return aliases
   */
  @javax.annotation.Nullable
  public List<Alias> getAliases() {
    return aliases;
  }

  public void setAliases(List<Alias> aliases) {
    this.aliases = aliases;
  }


  public FileSystemWindowsConfiguration auditLogConfiguration(WindowsFileSystemConfigurationAuditLogConfiguration auditLogConfiguration) {
    this.auditLogConfiguration = auditLogConfiguration;
    return this;
  }

  /**
   * Get auditLogConfiguration
   * @return auditLogConfiguration
   */
  @javax.annotation.Nullable
  public WindowsFileSystemConfigurationAuditLogConfiguration getAuditLogConfiguration() {
    return auditLogConfiguration;
  }

  public void setAuditLogConfiguration(WindowsFileSystemConfigurationAuditLogConfiguration auditLogConfiguration) {
    this.auditLogConfiguration = auditLogConfiguration;
  }



  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    FileSystemWindowsConfiguration fileSystemWindowsConfiguration = (FileSystemWindowsConfiguration) o;
    return Objects.equals(this.activeDirectoryId, fileSystemWindowsConfiguration.activeDirectoryId) &&
        Objects.equals(this.selfManagedActiveDirectoryConfiguration, fileSystemWindowsConfiguration.selfManagedActiveDirectoryConfiguration) &&
        Objects.equals(this.deploymentType, fileSystemWindowsConfiguration.deploymentType) &&
        Objects.equals(this.remoteAdministrationEndpoint, fileSystemWindowsConfiguration.remoteAdministrationEndpoint) &&
        Objects.equals(this.preferredSubnetId, fileSystemWindowsConfiguration.preferredSubnetId) &&
        Objects.equals(this.preferredFileServerIp, fileSystemWindowsConfiguration.preferredFileServerIp) &&
        Objects.equals(this.throughputCapacity, fileSystemWindowsConfiguration.throughputCapacity) &&
        Objects.equals(this.maintenanceOperationsInProgress, fileSystemWindowsConfiguration.maintenanceOperationsInProgress) &&
        Objects.equals(this.weeklyMaintenanceStartTime, fileSystemWindowsConfiguration.weeklyMaintenanceStartTime) &&
        Objects.equals(this.dailyAutomaticBackupStartTime, fileSystemWindowsConfiguration.dailyAutomaticBackupStartTime) &&
        Objects.equals(this.automaticBackupRetentionDays, fileSystemWindowsConfiguration.automaticBackupRetentionDays) &&
        Objects.equals(this.copyTagsToBackups, fileSystemWindowsConfiguration.copyTagsToBackups) &&
        Objects.equals(this.aliases, fileSystemWindowsConfiguration.aliases) &&
        Objects.equals(this.auditLogConfiguration, fileSystemWindowsConfiguration.auditLogConfiguration);
  }

  @Override
  public int hashCode() {
    return Objects.hash(activeDirectoryId, selfManagedActiveDirectoryConfiguration, deploymentType, remoteAdministrationEndpoint, preferredSubnetId, preferredFileServerIp, throughputCapacity, maintenanceOperationsInProgress, weeklyMaintenanceStartTime, dailyAutomaticBackupStartTime, automaticBackupRetentionDays, copyTagsToBackups, aliases, auditLogConfiguration);
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class FileSystemWindowsConfiguration {\n");
    sb.append("    activeDirectoryId: ").append(toIndentedString(activeDirectoryId)).append("\n");
    sb.append("    selfManagedActiveDirectoryConfiguration: ").append(toIndentedString(selfManagedActiveDirectoryConfiguration)).append("\n");
    sb.append("    deploymentType: ").append(toIndentedString(deploymentType)).append("\n");
    sb.append("    remoteAdministrationEndpoint: ").append(toIndentedString(remoteAdministrationEndpoint)).append("\n");
    sb.append("    preferredSubnetId: ").append(toIndentedString(preferredSubnetId)).append("\n");
    sb.append("    preferredFileServerIp: ").append(toIndentedString(preferredFileServerIp)).append("\n");
    sb.append("    throughputCapacity: ").append(toIndentedString(throughputCapacity)).append("\n");
    sb.append("    maintenanceOperationsInProgress: ").append(toIndentedString(maintenanceOperationsInProgress)).append("\n");
    sb.append("    weeklyMaintenanceStartTime: ").append(toIndentedString(weeklyMaintenanceStartTime)).append("\n");
    sb.append("    dailyAutomaticBackupStartTime: ").append(toIndentedString(dailyAutomaticBackupStartTime)).append("\n");
    sb.append("    automaticBackupRetentionDays: ").append(toIndentedString(automaticBackupRetentionDays)).append("\n");
    sb.append("    copyTagsToBackups: ").append(toIndentedString(copyTagsToBackups)).append("\n");
    sb.append("    aliases: ").append(toIndentedString(aliases)).append("\n");
    sb.append("    auditLogConfiguration: ").append(toIndentedString(auditLogConfiguration)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }


  public static HashSet<String> openapiFields;
  public static HashSet<String> openapiRequiredFields;

  static {
    // a set of all properties/fields (JSON key names)
    openapiFields = new HashSet<String>();
    openapiFields.add("ActiveDirectoryId");
    openapiFields.add("SelfManagedActiveDirectoryConfiguration");
    openapiFields.add("DeploymentType");
    openapiFields.add("RemoteAdministrationEndpoint");
    openapiFields.add("PreferredSubnetId");
    openapiFields.add("PreferredFileServerIp");
    openapiFields.add("ThroughputCapacity");
    openapiFields.add("MaintenanceOperationsInProgress");
    openapiFields.add("WeeklyMaintenanceStartTime");
    openapiFields.add("DailyAutomaticBackupStartTime");
    openapiFields.add("AutomaticBackupRetentionDays");
    openapiFields.add("CopyTagsToBackups");
    openapiFields.add("Aliases");
    openapiFields.add("AuditLogConfiguration");

    // a set of required properties/fields (JSON key names)
    openapiRequiredFields = new HashSet<String>();
  }

  /**
   * Validates the JSON Element and throws an exception if issues found
   *
   * @param jsonElement JSON Element
   * @throws IOException if the JSON Element is invalid with respect to FileSystemWindowsConfiguration
   */
  public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      if (jsonElement == null) {
        if (!FileSystemWindowsConfiguration.openapiRequiredFields.isEmpty()) { // has required fields but JSON element is null
          throw new IllegalArgumentException(String.format("The required field(s) %s in FileSystemWindowsConfiguration is not found in the empty JSON string", FileSystemWindowsConfiguration.openapiRequiredFields.toString()));
        }
      }

      Set<Map.Entry<String, JsonElement>> entries = jsonElement.getAsJsonObject().entrySet();
      // check to see if the JSON string contains additional fields
      for (Map.Entry<String, JsonElement> entry : entries) {
        if (!FileSystemWindowsConfiguration.openapiFields.contains(entry.getKey())) {
          throw new IllegalArgumentException(String.format("The field `%s` in the JSON string is not defined in the `FileSystemWindowsConfiguration` properties. JSON: %s", entry.getKey(), jsonElement.toString()));
        }
      }
        JsonObject jsonObj = jsonElement.getAsJsonObject();
      // validate the optional field `ActiveDirectoryId`
      if (jsonObj.get("ActiveDirectoryId") != null && !jsonObj.get("ActiveDirectoryId").isJsonNull()) {
        String.validateJsonElement(jsonObj.get("ActiveDirectoryId"));
      }
      // validate the optional field `SelfManagedActiveDirectoryConfiguration`
      if (jsonObj.get("SelfManagedActiveDirectoryConfiguration") != null && !jsonObj.get("SelfManagedActiveDirectoryConfiguration").isJsonNull()) {
        SelfManagedActiveDirectoryAttributes.validateJsonElement(jsonObj.get("SelfManagedActiveDirectoryConfiguration"));
      }
      // validate the optional field `DeploymentType`
      if (jsonObj.get("DeploymentType") != null && !jsonObj.get("DeploymentType").isJsonNull()) {
        WindowsDeploymentType.validateJsonElement(jsonObj.get("DeploymentType"));
      }
      // validate the optional field `RemoteAdministrationEndpoint`
      if (jsonObj.get("RemoteAdministrationEndpoint") != null && !jsonObj.get("RemoteAdministrationEndpoint").isJsonNull()) {
        String.validateJsonElement(jsonObj.get("RemoteAdministrationEndpoint"));
      }
      // validate the optional field `PreferredSubnetId`
      if (jsonObj.get("PreferredSubnetId") != null && !jsonObj.get("PreferredSubnetId").isJsonNull()) {
        String.validateJsonElement(jsonObj.get("PreferredSubnetId"));
      }
      // validate the optional field `PreferredFileServerIp`
      if (jsonObj.get("PreferredFileServerIp") != null && !jsonObj.get("PreferredFileServerIp").isJsonNull()) {
        String.validateJsonElement(jsonObj.get("PreferredFileServerIp"));
      }
      // validate the optional field `ThroughputCapacity`
      if (jsonObj.get("ThroughputCapacity") != null && !jsonObj.get("ThroughputCapacity").isJsonNull()) {
        Integer.validateJsonElement(jsonObj.get("ThroughputCapacity"));
      }
      // validate the optional field `MaintenanceOperationsInProgress`
      if (jsonObj.get("MaintenanceOperationsInProgress") != null && !jsonObj.get("MaintenanceOperationsInProgress").isJsonNull()) {
        List.validateJsonElement(jsonObj.get("MaintenanceOperationsInProgress"));
      }
      // validate the optional field `WeeklyMaintenanceStartTime`
      if (jsonObj.get("WeeklyMaintenanceStartTime") != null && !jsonObj.get("WeeklyMaintenanceStartTime").isJsonNull()) {
        String.validateJsonElement(jsonObj.get("WeeklyMaintenanceStartTime"));
      }
      // validate the optional field `DailyAutomaticBackupStartTime`
      if (jsonObj.get("DailyAutomaticBackupStartTime") != null && !jsonObj.get("DailyAutomaticBackupStartTime").isJsonNull()) {
        String.validateJsonElement(jsonObj.get("DailyAutomaticBackupStartTime"));
      }
      // validate the optional field `AutomaticBackupRetentionDays`
      if (jsonObj.get("AutomaticBackupRetentionDays") != null && !jsonObj.get("AutomaticBackupRetentionDays").isJsonNull()) {
        Integer.validateJsonElement(jsonObj.get("AutomaticBackupRetentionDays"));
      }
      // validate the optional field `CopyTagsToBackups`
      if (jsonObj.get("CopyTagsToBackups") != null && !jsonObj.get("CopyTagsToBackups").isJsonNull()) {
        Boolean.validateJsonElement(jsonObj.get("CopyTagsToBackups"));
      }
      if (jsonObj.get("Aliases") != null && !jsonObj.get("Aliases").isJsonNull()) {
        JsonArray jsonArrayaliases = jsonObj.getAsJsonArray("Aliases");
        if (jsonArrayaliases != null) {
          // ensure the json data is an array
          if (!jsonObj.get("Aliases").isJsonArray()) {
            throw new IllegalArgumentException(String.format("Expected the field `Aliases` to be an array in the JSON string but got `%s`", jsonObj.get("Aliases").toString()));
          }

          // validate the optional field `Aliases` (array)
          for (int i = 0; i < jsonArrayaliases.size(); i++) {
            Alias.validateJsonElement(jsonArrayaliases.get(i));
          };
        }
      }
      // validate the optional field `AuditLogConfiguration`
      if (jsonObj.get("AuditLogConfiguration") != null && !jsonObj.get("AuditLogConfiguration").isJsonNull()) {
        WindowsFileSystemConfigurationAuditLogConfiguration.validateJsonElement(jsonObj.get("AuditLogConfiguration"));
      }
  }

  public static class CustomTypeAdapterFactory implements TypeAdapterFactory {
    @SuppressWarnings("unchecked")
    @Override
    public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
       if (!FileSystemWindowsConfiguration.class.isAssignableFrom(type.getRawType())) {
         return null; // this class only serializes 'FileSystemWindowsConfiguration' and its subtypes
       }
       final TypeAdapter<JsonElement> elementAdapter = gson.getAdapter(JsonElement.class);
       final TypeAdapter<FileSystemWindowsConfiguration> thisAdapter
                        = gson.getDelegateAdapter(this, TypeToken.get(FileSystemWindowsConfiguration.class));

       return (TypeAdapter<T>) new TypeAdapter<FileSystemWindowsConfiguration>() {
           @Override
           public void write(JsonWriter out, FileSystemWindowsConfiguration value) throws IOException {
             JsonObject obj = thisAdapter.toJsonTree(value).getAsJsonObject();
             elementAdapter.write(out, obj);
           }

           @Override
           public FileSystemWindowsConfiguration read(JsonReader in) throws IOException {
             JsonElement jsonElement = elementAdapter.read(in);
             validateJsonElement(jsonElement);
             return thisAdapter.fromJsonTree(jsonElement);
           }

       }.nullSafe();
    }
  }

  /**
   * Create an instance of FileSystemWindowsConfiguration given an JSON string
   *
   * @param jsonString JSON string
   * @return An instance of FileSystemWindowsConfiguration
   * @throws IOException if the JSON string is invalid with respect to FileSystemWindowsConfiguration
   */
  public static FileSystemWindowsConfiguration fromJson(String jsonString) throws IOException {
    return JSON.getGson().fromJson(jsonString, FileSystemWindowsConfiguration.class);
  }

  /**
   * Convert an instance of FileSystemWindowsConfiguration to an JSON string
   *
   * @return JSON string
   */
  public String toJson() {
    return JSON.getGson().toJson(this);
  }
}

