/**
 * AWS Network Firewall
 * <p>This is the API Reference for Network Firewall. This guide is for developers who need detailed information about the Network Firewall API actions, data types, and errors. </p> <ul> <li> <p>The REST API requires you to handle connection details, such as calculating signatures, handling request retries, and error handling. For general information about using the Amazon Web Services REST APIs, see <a href=\"https://docs.aws.amazon.com/general/latest/gr/aws-apis.html\">Amazon Web Services APIs</a>. </p> <p>To access Network Firewall using the REST API endpoint: <code>https://network-firewall.&lt;region&gt;.amazonaws.com </code> </p> </li> <li> <p>Alternatively, you can use one of the Amazon Web Services SDKs to access an API that's tailored to the programming language or platform that you're using. For more information, see <a href=\"http://aws.amazon.com/tools/#SDKs\">Amazon Web Services SDKs</a>.</p> </li> <li> <p>For descriptions of Network Firewall features, including and step-by-step instructions on how to use them through the Network Firewall console, see the <a href=\"https://docs.aws.amazon.com/network-firewall/latest/developerguide/\">Network Firewall Developer Guide</a>.</p> </li> </ul> <p>Network Firewall is a stateful, managed, network firewall and intrusion detection and prevention service for Amazon Virtual Private Cloud (Amazon VPC). With Network Firewall, you can filter traffic at the perimeter of your VPC. This includes filtering traffic going to and coming from an internet gateway, NAT gateway, or over VPN or Direct Connect. Network Firewall uses rules that are compatible with Suricata, a free, open source network analysis and threat detection engine. Network Firewall supports Suricata version 6.0.9. For information about Suricata, see the <a href=\"https://suricata.io/\">Suricata website</a>.</p> <p>You can use Network Firewall to monitor and protect your VPC traffic in a number of ways. The following are just a few examples: </p> <ul> <li> <p>Allow domains or IP addresses for known Amazon Web Services service endpoints, such as Amazon S3, and block all other forms of traffic.</p> </li> <li> <p>Use custom lists of known bad domains to limit the types of domain names that your applications can access.</p> </li> <li> <p>Perform deep packet inspection on traffic entering or leaving your VPC.</p> </li> <li> <p>Use stateful protocol detection to filter protocols like HTTPS, regardless of the port used.</p> </li> </ul> <p>To enable Network Firewall for your VPCs, you perform steps in both Amazon VPC and in Network Firewall. For information about using Amazon VPC, see <a href=\"https://docs.aws.amazon.com/vpc/latest/userguide/\">Amazon VPC User Guide</a>.</p> <p>To start using Network Firewall, do the following: </p> <ol> <li> <p>(Optional) If you don't already have a VPC that you want to protect, create it in Amazon VPC. </p> </li> <li> <p>In Amazon VPC, in each Availability Zone where you want to have a firewall endpoint, create a subnet for the sole use of Network Firewall. </p> </li> <li> <p>In Network Firewall, create stateless and stateful rule groups, to define the components of the network traffic filtering behavior that you want your firewall to have. </p> </li> <li> <p>In Network Firewall, create a firewall policy that uses your rule groups and specifies additional default traffic filtering behavior. </p> </li> <li> <p>In Network Firewall, create a firewall and specify your new firewall policy and VPC subnets. Network Firewall creates a firewall endpoint in each subnet that you specify, with the behavior that's defined in the firewall policy.</p> </li> <li> <p>In Amazon VPC, use ingress routing enhancements to route traffic through the new firewall endpoints.</p> </li> </ol>
 *
 * The version of the OpenAPI document: 2020-11-12
 * Contact: mike.ralphson@gmail.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

/*
 * OAICreateRuleGroupResponse_RuleGroupResponse.h
 *
 * 
 */

#ifndef OAICreateRuleGroupResponse_RuleGroupResponse_H
#define OAICreateRuleGroupResponse_RuleGroupResponse_H

#include <QJsonObject>

#include "OAIResourceStatus.h"
#include "OAIRuleGroupResponse_EncryptionConfiguration.h"
#include "OAIRuleGroupResponse_SourceMetadata.h"
#include "OAIRuleGroupType.h"
#include <QDateTime>
#include <QList>
#include <QString>

#include "OAIEnum.h"
#include "OAIObject.h"

namespace OpenAPI {
class OAIRuleGroupResponse_EncryptionConfiguration;
class OAIRuleGroupResponse_SourceMetadata;

class OAICreateRuleGroupResponse_RuleGroupResponse : public OAIObject {
public:
    OAICreateRuleGroupResponse_RuleGroupResponse();
    OAICreateRuleGroupResponse_RuleGroupResponse(QString json);
    ~OAICreateRuleGroupResponse_RuleGroupResponse() override;

    QString asJson() const override;
    QJsonObject asJsonObject() const override;
    void fromJsonObject(QJsonObject json) override;
    void fromJson(QString jsonString) override;

    QString getRuleGroupArn() const;
    void setRuleGroupArn(const QString &rule_group_arn);
    bool is_rule_group_arn_Set() const;
    bool is_rule_group_arn_Valid() const;

    QString getRuleGroupName() const;
    void setRuleGroupName(const QString &rule_group_name);
    bool is_rule_group_name_Set() const;
    bool is_rule_group_name_Valid() const;

    QString getRuleGroupId() const;
    void setRuleGroupId(const QString &rule_group_id);
    bool is_rule_group_id_Set() const;
    bool is_rule_group_id_Valid() const;

    QString getDescription() const;
    void setDescription(const QString &description);
    bool is_description_Set() const;
    bool is_description_Valid() const;

    OAIRuleGroupType getType() const;
    void setType(const OAIRuleGroupType &type);
    bool is_type_Set() const;
    bool is_type_Valid() const;

    qint32 getCapacity() const;
    void setCapacity(const qint32 &capacity);
    bool is_capacity_Set() const;
    bool is_capacity_Valid() const;

    OAIResourceStatus getRuleGroupStatus() const;
    void setRuleGroupStatus(const OAIResourceStatus &rule_group_status);
    bool is_rule_group_status_Set() const;
    bool is_rule_group_status_Valid() const;

    QList getTags() const;
    void setTags(const QList &tags);
    bool is_tags_Set() const;
    bool is_tags_Valid() const;

    qint32 getConsumedCapacity() const;
    void setConsumedCapacity(const qint32 &consumed_capacity);
    bool is_consumed_capacity_Set() const;
    bool is_consumed_capacity_Valid() const;

    qint32 getNumberOfAssociations() const;
    void setNumberOfAssociations(const qint32 &number_of_associations);
    bool is_number_of_associations_Set() const;
    bool is_number_of_associations_Valid() const;

    OAIRuleGroupResponse_EncryptionConfiguration getEncryptionConfiguration() const;
    void setEncryptionConfiguration(const OAIRuleGroupResponse_EncryptionConfiguration &encryption_configuration);
    bool is_encryption_configuration_Set() const;
    bool is_encryption_configuration_Valid() const;

    OAIRuleGroupResponse_SourceMetadata getSourceMetadata() const;
    void setSourceMetadata(const OAIRuleGroupResponse_SourceMetadata &source_metadata);
    bool is_source_metadata_Set() const;
    bool is_source_metadata_Valid() const;

    QString getSnsTopic() const;
    void setSnsTopic(const QString &sns_topic);
    bool is_sns_topic_Set() const;
    bool is_sns_topic_Valid() const;

    QDateTime getLastModifiedTime() const;
    void setLastModifiedTime(const QDateTime &last_modified_time);
    bool is_last_modified_time_Set() const;
    bool is_last_modified_time_Valid() const;

    virtual bool isSet() const override;
    virtual bool isValid() const override;

private:
    void initializeModel();

    QString m_rule_group_arn;
    bool m_rule_group_arn_isSet;
    bool m_rule_group_arn_isValid;

    QString m_rule_group_name;
    bool m_rule_group_name_isSet;
    bool m_rule_group_name_isValid;

    QString m_rule_group_id;
    bool m_rule_group_id_isSet;
    bool m_rule_group_id_isValid;

    QString m_description;
    bool m_description_isSet;
    bool m_description_isValid;

    OAIRuleGroupType m_type;
    bool m_type_isSet;
    bool m_type_isValid;

    qint32 m_capacity;
    bool m_capacity_isSet;
    bool m_capacity_isValid;

    OAIResourceStatus m_rule_group_status;
    bool m_rule_group_status_isSet;
    bool m_rule_group_status_isValid;

    QList m_tags;
    bool m_tags_isSet;
    bool m_tags_isValid;

    qint32 m_consumed_capacity;
    bool m_consumed_capacity_isSet;
    bool m_consumed_capacity_isValid;

    qint32 m_number_of_associations;
    bool m_number_of_associations_isSet;
    bool m_number_of_associations_isValid;

    OAIRuleGroupResponse_EncryptionConfiguration m_encryption_configuration;
    bool m_encryption_configuration_isSet;
    bool m_encryption_configuration_isValid;

    OAIRuleGroupResponse_SourceMetadata m_source_metadata;
    bool m_source_metadata_isSet;
    bool m_source_metadata_isValid;

    QString m_sns_topic;
    bool m_sns_topic_isSet;
    bool m_sns_topic_isValid;

    QDateTime m_last_modified_time;
    bool m_last_modified_time_isSet;
    bool m_last_modified_time_isValid;
};

} // namespace OpenAPI

Q_DECLARE_METATYPE(OpenAPI::OAICreateRuleGroupResponse_RuleGroupResponse)

#endif // OAICreateRuleGroupResponse_RuleGroupResponse_H
