/**
 * Amazon Forecast Service
 * Provides APIs for creating and managing Amazon Forecast resources.
 *
 * The version of the OpenAPI document: 2018-06-26
 * Contact: mike.ralphson@gmail.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

#include "OAIStatistics.h"

#include <QDebug>
#include <QJsonArray>
#include <QJsonDocument>
#include <QObject>

#include "OAIHelpers.h"

namespace OpenAPI {

OAIStatistics::OAIStatistics(QString json) {
    this->initializeModel();
    this->fromJson(json);
}

OAIStatistics::OAIStatistics() {
    this->initializeModel();
}

OAIStatistics::~OAIStatistics() {}

void OAIStatistics::initializeModel() {

    m_count_isSet = false;
    m_count_isValid = false;

    m_count_distinct_isSet = false;
    m_count_distinct_isValid = false;

    m_count_null_isSet = false;
    m_count_null_isValid = false;

    m_count_nan_isSet = false;
    m_count_nan_isValid = false;

    m_min_isSet = false;
    m_min_isValid = false;

    m_max_isSet = false;
    m_max_isValid = false;

    m_avg_isSet = false;
    m_avg_isValid = false;

    m_stddev_isSet = false;
    m_stddev_isValid = false;

    m_count_long_isSet = false;
    m_count_long_isValid = false;

    m_count_distinct_long_isSet = false;
    m_count_distinct_long_isValid = false;

    m_count_null_long_isSet = false;
    m_count_null_long_isValid = false;

    m_count_nan_long_isSet = false;
    m_count_nan_long_isValid = false;
}

void OAIStatistics::fromJson(QString jsonString) {
    QByteArray array(jsonString.toStdString().c_str());
    QJsonDocument doc = QJsonDocument::fromJson(array);
    QJsonObject jsonObject = doc.object();
    this->fromJsonObject(jsonObject);
}

void OAIStatistics::fromJsonObject(QJsonObject json) {

    m_count_isValid = ::OpenAPI::fromJsonValue(m_count, json[QString("Count")]);
    m_count_isSet = !json[QString("Count")].isNull() && m_count_isValid;

    m_count_distinct_isValid = ::OpenAPI::fromJsonValue(m_count_distinct, json[QString("CountDistinct")]);
    m_count_distinct_isSet = !json[QString("CountDistinct")].isNull() && m_count_distinct_isValid;

    m_count_null_isValid = ::OpenAPI::fromJsonValue(m_count_null, json[QString("CountNull")]);
    m_count_null_isSet = !json[QString("CountNull")].isNull() && m_count_null_isValid;

    m_count_nan_isValid = ::OpenAPI::fromJsonValue(m_count_nan, json[QString("CountNan")]);
    m_count_nan_isSet = !json[QString("CountNan")].isNull() && m_count_nan_isValid;

    m_min_isValid = ::OpenAPI::fromJsonValue(m_min, json[QString("Min")]);
    m_min_isSet = !json[QString("Min")].isNull() && m_min_isValid;

    m_max_isValid = ::OpenAPI::fromJsonValue(m_max, json[QString("Max")]);
    m_max_isSet = !json[QString("Max")].isNull() && m_max_isValid;

    m_avg_isValid = ::OpenAPI::fromJsonValue(m_avg, json[QString("Avg")]);
    m_avg_isSet = !json[QString("Avg")].isNull() && m_avg_isValid;

    m_stddev_isValid = ::OpenAPI::fromJsonValue(m_stddev, json[QString("Stddev")]);
    m_stddev_isSet = !json[QString("Stddev")].isNull() && m_stddev_isValid;

    m_count_long_isValid = ::OpenAPI::fromJsonValue(m_count_long, json[QString("CountLong")]);
    m_count_long_isSet = !json[QString("CountLong")].isNull() && m_count_long_isValid;

    m_count_distinct_long_isValid = ::OpenAPI::fromJsonValue(m_count_distinct_long, json[QString("CountDistinctLong")]);
    m_count_distinct_long_isSet = !json[QString("CountDistinctLong")].isNull() && m_count_distinct_long_isValid;

    m_count_null_long_isValid = ::OpenAPI::fromJsonValue(m_count_null_long, json[QString("CountNullLong")]);
    m_count_null_long_isSet = !json[QString("CountNullLong")].isNull() && m_count_null_long_isValid;

    m_count_nan_long_isValid = ::OpenAPI::fromJsonValue(m_count_nan_long, json[QString("CountNanLong")]);
    m_count_nan_long_isSet = !json[QString("CountNanLong")].isNull() && m_count_nan_long_isValid;
}

QString OAIStatistics::asJson() const {
    QJsonObject obj = this->asJsonObject();
    QJsonDocument doc(obj);
    QByteArray bytes = doc.toJson();
    return QString(bytes);
}

QJsonObject OAIStatistics::asJsonObject() const {
    QJsonObject obj;
    if (m_count_isSet) {
        obj.insert(QString("Count"), ::OpenAPI::toJsonValue(m_count));
    }
    if (m_count_distinct_isSet) {
        obj.insert(QString("CountDistinct"), ::OpenAPI::toJsonValue(m_count_distinct));
    }
    if (m_count_null_isSet) {
        obj.insert(QString("CountNull"), ::OpenAPI::toJsonValue(m_count_null));
    }
    if (m_count_nan_isSet) {
        obj.insert(QString("CountNan"), ::OpenAPI::toJsonValue(m_count_nan));
    }
    if (m_min_isSet) {
        obj.insert(QString("Min"), ::OpenAPI::toJsonValue(m_min));
    }
    if (m_max_isSet) {
        obj.insert(QString("Max"), ::OpenAPI::toJsonValue(m_max));
    }
    if (m_avg_isSet) {
        obj.insert(QString("Avg"), ::OpenAPI::toJsonValue(m_avg));
    }
    if (m_stddev_isSet) {
        obj.insert(QString("Stddev"), ::OpenAPI::toJsonValue(m_stddev));
    }
    if (m_count_long_isSet) {
        obj.insert(QString("CountLong"), ::OpenAPI::toJsonValue(m_count_long));
    }
    if (m_count_distinct_long_isSet) {
        obj.insert(QString("CountDistinctLong"), ::OpenAPI::toJsonValue(m_count_distinct_long));
    }
    if (m_count_null_long_isSet) {
        obj.insert(QString("CountNullLong"), ::OpenAPI::toJsonValue(m_count_null_long));
    }
    if (m_count_nan_long_isSet) {
        obj.insert(QString("CountNanLong"), ::OpenAPI::toJsonValue(m_count_nan_long));
    }
    return obj;
}

qint32 OAIStatistics::getCount() const {
    return m_count;
}
void OAIStatistics::setCount(const qint32 &count) {
    m_count = count;
    m_count_isSet = true;
}

bool OAIStatistics::is_count_Set() const{
    return m_count_isSet;
}

bool OAIStatistics::is_count_Valid() const{
    return m_count_isValid;
}

qint32 OAIStatistics::getCountDistinct() const {
    return m_count_distinct;
}
void OAIStatistics::setCountDistinct(const qint32 &count_distinct) {
    m_count_distinct = count_distinct;
    m_count_distinct_isSet = true;
}

bool OAIStatistics::is_count_distinct_Set() const{
    return m_count_distinct_isSet;
}

bool OAIStatistics::is_count_distinct_Valid() const{
    return m_count_distinct_isValid;
}

qint32 OAIStatistics::getCountNull() const {
    return m_count_null;
}
void OAIStatistics::setCountNull(const qint32 &count_null) {
    m_count_null = count_null;
    m_count_null_isSet = true;
}

bool OAIStatistics::is_count_null_Set() const{
    return m_count_null_isSet;
}

bool OAIStatistics::is_count_null_Valid() const{
    return m_count_null_isValid;
}

qint32 OAIStatistics::getCountNan() const {
    return m_count_nan;
}
void OAIStatistics::setCountNan(const qint32 &count_nan) {
    m_count_nan = count_nan;
    m_count_nan_isSet = true;
}

bool OAIStatistics::is_count_nan_Set() const{
    return m_count_nan_isSet;
}

bool OAIStatistics::is_count_nan_Valid() const{
    return m_count_nan_isValid;
}

QString OAIStatistics::getMin() const {
    return m_min;
}
void OAIStatistics::setMin(const QString &min) {
    m_min = min;
    m_min_isSet = true;
}

bool OAIStatistics::is_min_Set() const{
    return m_min_isSet;
}

bool OAIStatistics::is_min_Valid() const{
    return m_min_isValid;
}

QString OAIStatistics::getMax() const {
    return m_max;
}
void OAIStatistics::setMax(const QString &max) {
    m_max = max;
    m_max_isSet = true;
}

bool OAIStatistics::is_max_Set() const{
    return m_max_isSet;
}

bool OAIStatistics::is_max_Valid() const{
    return m_max_isValid;
}

double OAIStatistics::getAvg() const {
    return m_avg;
}
void OAIStatistics::setAvg(const double &avg) {
    m_avg = avg;
    m_avg_isSet = true;
}

bool OAIStatistics::is_avg_Set() const{
    return m_avg_isSet;
}

bool OAIStatistics::is_avg_Valid() const{
    return m_avg_isValid;
}

double OAIStatistics::getStddev() const {
    return m_stddev;
}
void OAIStatistics::setStddev(const double &stddev) {
    m_stddev = stddev;
    m_stddev_isSet = true;
}

bool OAIStatistics::is_stddev_Set() const{
    return m_stddev_isSet;
}

bool OAIStatistics::is_stddev_Valid() const{
    return m_stddev_isValid;
}

qint32 OAIStatistics::getCountLong() const {
    return m_count_long;
}
void OAIStatistics::setCountLong(const qint32 &count_long) {
    m_count_long = count_long;
    m_count_long_isSet = true;
}

bool OAIStatistics::is_count_long_Set() const{
    return m_count_long_isSet;
}

bool OAIStatistics::is_count_long_Valid() const{
    return m_count_long_isValid;
}

qint32 OAIStatistics::getCountDistinctLong() const {
    return m_count_distinct_long;
}
void OAIStatistics::setCountDistinctLong(const qint32 &count_distinct_long) {
    m_count_distinct_long = count_distinct_long;
    m_count_distinct_long_isSet = true;
}

bool OAIStatistics::is_count_distinct_long_Set() const{
    return m_count_distinct_long_isSet;
}

bool OAIStatistics::is_count_distinct_long_Valid() const{
    return m_count_distinct_long_isValid;
}

qint32 OAIStatistics::getCountNullLong() const {
    return m_count_null_long;
}
void OAIStatistics::setCountNullLong(const qint32 &count_null_long) {
    m_count_null_long = count_null_long;
    m_count_null_long_isSet = true;
}

bool OAIStatistics::is_count_null_long_Set() const{
    return m_count_null_long_isSet;
}

bool OAIStatistics::is_count_null_long_Valid() const{
    return m_count_null_long_isValid;
}

qint32 OAIStatistics::getCountNanLong() const {
    return m_count_nan_long;
}
void OAIStatistics::setCountNanLong(const qint32 &count_nan_long) {
    m_count_nan_long = count_nan_long;
    m_count_nan_long_isSet = true;
}

bool OAIStatistics::is_count_nan_long_Set() const{
    return m_count_nan_long_isSet;
}

bool OAIStatistics::is_count_nan_long_Valid() const{
    return m_count_nan_long_isValid;
}

bool OAIStatistics::isSet() const {
    bool isObjectUpdated = false;
    do {
        if (m_count_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_count_distinct_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_count_null_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_count_nan_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_min_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_max_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_avg_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_stddev_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_count_long_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_count_distinct_long_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_count_null_long_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_count_nan_long_isSet) {
            isObjectUpdated = true;
            break;
        }
    } while (false);
    return isObjectUpdated;
}

bool OAIStatistics::isValid() const {
    // only required properties are required for the object to be considered valid
    return true;
}

} // namespace OpenAPI
