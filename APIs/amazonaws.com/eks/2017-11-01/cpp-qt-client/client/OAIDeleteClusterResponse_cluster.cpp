/**
 * Amazon Elastic Kubernetes Service
 * <p>Amazon Elastic Kubernetes Service (Amazon EKS) is a managed service that makes it easy for you to run Kubernetes on Amazon Web Services without needing to stand up or maintain your own Kubernetes control plane. Kubernetes is an open-source system for automating the deployment, scaling, and management of containerized applications. </p> <p>Amazon EKS runs up-to-date versions of the open-source Kubernetes software, so you can use all the existing plugins and tooling from the Kubernetes community. Applications running on Amazon EKS are fully compatible with applications running on any standard Kubernetes environment, whether running in on-premises data centers or public clouds. This means that you can easily migrate any standard Kubernetes application to Amazon EKS without any code modification required.</p>
 *
 * The version of the OpenAPI document: 2017-11-01
 * Contact: mike.ralphson@gmail.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

#include "OAIDeleteClusterResponse_cluster.h"

#include <QDebug>
#include <QJsonArray>
#include <QJsonDocument>
#include <QObject>

#include "OAIHelpers.h"

namespace OpenAPI {

OAIDeleteClusterResponse_cluster::OAIDeleteClusterResponse_cluster(QString json) {
    this->initializeModel();
    this->fromJson(json);
}

OAIDeleteClusterResponse_cluster::OAIDeleteClusterResponse_cluster() {
    this->initializeModel();
}

OAIDeleteClusterResponse_cluster::~OAIDeleteClusterResponse_cluster() {}

void OAIDeleteClusterResponse_cluster::initializeModel() {

    m_name_isSet = false;
    m_name_isValid = false;

    m_arn_isSet = false;
    m_arn_isValid = false;

    m_created_at_isSet = false;
    m_created_at_isValid = false;

    m_version_isSet = false;
    m_version_isValid = false;

    m_endpoint_isSet = false;
    m_endpoint_isValid = false;

    m_role_arn_isSet = false;
    m_role_arn_isValid = false;

    m_resources_vpc_config_isSet = false;
    m_resources_vpc_config_isValid = false;

    m_kubernetes_network_config_isSet = false;
    m_kubernetes_network_config_isValid = false;

    m_logging_isSet = false;
    m_logging_isValid = false;

    m_identity_isSet = false;
    m_identity_isValid = false;

    m_status_isSet = false;
    m_status_isValid = false;

    m_certificate_authority_isSet = false;
    m_certificate_authority_isValid = false;

    m_client_request_token_isSet = false;
    m_client_request_token_isValid = false;

    m_platform_version_isSet = false;
    m_platform_version_isValid = false;

    m_tags_isSet = false;
    m_tags_isValid = false;

    m_encryption_config_isSet = false;
    m_encryption_config_isValid = false;

    m_connector_config_isSet = false;
    m_connector_config_isValid = false;

    m_id_isSet = false;
    m_id_isValid = false;

    m_health_isSet = false;
    m_health_isValid = false;

    m_outpost_config_isSet = false;
    m_outpost_config_isValid = false;
}

void OAIDeleteClusterResponse_cluster::fromJson(QString jsonString) {
    QByteArray array(jsonString.toStdString().c_str());
    QJsonDocument doc = QJsonDocument::fromJson(array);
    QJsonObject jsonObject = doc.object();
    this->fromJsonObject(jsonObject);
}

void OAIDeleteClusterResponse_cluster::fromJsonObject(QJsonObject json) {

    m_name_isValid = ::OpenAPI::fromJsonValue(m_name, json[QString("name")]);
    m_name_isSet = !json[QString("name")].isNull() && m_name_isValid;

    m_arn_isValid = ::OpenAPI::fromJsonValue(m_arn, json[QString("arn")]);
    m_arn_isSet = !json[QString("arn")].isNull() && m_arn_isValid;

    m_created_at_isValid = ::OpenAPI::fromJsonValue(m_created_at, json[QString("createdAt")]);
    m_created_at_isSet = !json[QString("createdAt")].isNull() && m_created_at_isValid;

    m_version_isValid = ::OpenAPI::fromJsonValue(m_version, json[QString("version")]);
    m_version_isSet = !json[QString("version")].isNull() && m_version_isValid;

    m_endpoint_isValid = ::OpenAPI::fromJsonValue(m_endpoint, json[QString("endpoint")]);
    m_endpoint_isSet = !json[QString("endpoint")].isNull() && m_endpoint_isValid;

    m_role_arn_isValid = ::OpenAPI::fromJsonValue(m_role_arn, json[QString("roleArn")]);
    m_role_arn_isSet = !json[QString("roleArn")].isNull() && m_role_arn_isValid;

    m_resources_vpc_config_isValid = ::OpenAPI::fromJsonValue(m_resources_vpc_config, json[QString("resourcesVpcConfig")]);
    m_resources_vpc_config_isSet = !json[QString("resourcesVpcConfig")].isNull() && m_resources_vpc_config_isValid;

    m_kubernetes_network_config_isValid = ::OpenAPI::fromJsonValue(m_kubernetes_network_config, json[QString("kubernetesNetworkConfig")]);
    m_kubernetes_network_config_isSet = !json[QString("kubernetesNetworkConfig")].isNull() && m_kubernetes_network_config_isValid;

    m_logging_isValid = ::OpenAPI::fromJsonValue(m_logging, json[QString("logging")]);
    m_logging_isSet = !json[QString("logging")].isNull() && m_logging_isValid;

    m_identity_isValid = ::OpenAPI::fromJsonValue(m_identity, json[QString("identity")]);
    m_identity_isSet = !json[QString("identity")].isNull() && m_identity_isValid;

    m_status_isValid = ::OpenAPI::fromJsonValue(m_status, json[QString("status")]);
    m_status_isSet = !json[QString("status")].isNull() && m_status_isValid;

    m_certificate_authority_isValid = ::OpenAPI::fromJsonValue(m_certificate_authority, json[QString("certificateAuthority")]);
    m_certificate_authority_isSet = !json[QString("certificateAuthority")].isNull() && m_certificate_authority_isValid;

    m_client_request_token_isValid = ::OpenAPI::fromJsonValue(m_client_request_token, json[QString("clientRequestToken")]);
    m_client_request_token_isSet = !json[QString("clientRequestToken")].isNull() && m_client_request_token_isValid;

    m_platform_version_isValid = ::OpenAPI::fromJsonValue(m_platform_version, json[QString("platformVersion")]);
    m_platform_version_isSet = !json[QString("platformVersion")].isNull() && m_platform_version_isValid;

    m_tags_isValid = ::OpenAPI::fromJsonValue(m_tags, json[QString("tags")]);
    m_tags_isSet = !json[QString("tags")].isNull() && m_tags_isValid;

    m_encryption_config_isValid = ::OpenAPI::fromJsonValue(m_encryption_config, json[QString("encryptionConfig")]);
    m_encryption_config_isSet = !json[QString("encryptionConfig")].isNull() && m_encryption_config_isValid;

    m_connector_config_isValid = ::OpenAPI::fromJsonValue(m_connector_config, json[QString("connectorConfig")]);
    m_connector_config_isSet = !json[QString("connectorConfig")].isNull() && m_connector_config_isValid;

    m_id_isValid = ::OpenAPI::fromJsonValue(m_id, json[QString("id")]);
    m_id_isSet = !json[QString("id")].isNull() && m_id_isValid;

    m_health_isValid = ::OpenAPI::fromJsonValue(m_health, json[QString("health")]);
    m_health_isSet = !json[QString("health")].isNull() && m_health_isValid;

    m_outpost_config_isValid = ::OpenAPI::fromJsonValue(m_outpost_config, json[QString("outpostConfig")]);
    m_outpost_config_isSet = !json[QString("outpostConfig")].isNull() && m_outpost_config_isValid;
}

QString OAIDeleteClusterResponse_cluster::asJson() const {
    QJsonObject obj = this->asJsonObject();
    QJsonDocument doc(obj);
    QByteArray bytes = doc.toJson();
    return QString(bytes);
}

QJsonObject OAIDeleteClusterResponse_cluster::asJsonObject() const {
    QJsonObject obj;
    if (m_name_isSet) {
        obj.insert(QString("name"), ::OpenAPI::toJsonValue(m_name));
    }
    if (m_arn_isSet) {
        obj.insert(QString("arn"), ::OpenAPI::toJsonValue(m_arn));
    }
    if (m_created_at_isSet) {
        obj.insert(QString("createdAt"), ::OpenAPI::toJsonValue(m_created_at));
    }
    if (m_version_isSet) {
        obj.insert(QString("version"), ::OpenAPI::toJsonValue(m_version));
    }
    if (m_endpoint_isSet) {
        obj.insert(QString("endpoint"), ::OpenAPI::toJsonValue(m_endpoint));
    }
    if (m_role_arn_isSet) {
        obj.insert(QString("roleArn"), ::OpenAPI::toJsonValue(m_role_arn));
    }
    if (m_resources_vpc_config.isSet()) {
        obj.insert(QString("resourcesVpcConfig"), ::OpenAPI::toJsonValue(m_resources_vpc_config));
    }
    if (m_kubernetes_network_config.isSet()) {
        obj.insert(QString("kubernetesNetworkConfig"), ::OpenAPI::toJsonValue(m_kubernetes_network_config));
    }
    if (m_logging.isSet()) {
        obj.insert(QString("logging"), ::OpenAPI::toJsonValue(m_logging));
    }
    if (m_identity.isSet()) {
        obj.insert(QString("identity"), ::OpenAPI::toJsonValue(m_identity));
    }
    if (m_status.isSet()) {
        obj.insert(QString("status"), ::OpenAPI::toJsonValue(m_status));
    }
    if (m_certificate_authority.isSet()) {
        obj.insert(QString("certificateAuthority"), ::OpenAPI::toJsonValue(m_certificate_authority));
    }
    if (m_client_request_token_isSet) {
        obj.insert(QString("clientRequestToken"), ::OpenAPI::toJsonValue(m_client_request_token));
    }
    if (m_platform_version_isSet) {
        obj.insert(QString("platformVersion"), ::OpenAPI::toJsonValue(m_platform_version));
    }
    if (m_tags.isSet()) {
        obj.insert(QString("tags"), ::OpenAPI::toJsonValue(m_tags));
    }
    if (m_encryption_config.isSet()) {
        obj.insert(QString("encryptionConfig"), ::OpenAPI::toJsonValue(m_encryption_config));
    }
    if (m_connector_config.isSet()) {
        obj.insert(QString("connectorConfig"), ::OpenAPI::toJsonValue(m_connector_config));
    }
    if (m_id_isSet) {
        obj.insert(QString("id"), ::OpenAPI::toJsonValue(m_id));
    }
    if (m_health.isSet()) {
        obj.insert(QString("health"), ::OpenAPI::toJsonValue(m_health));
    }
    if (m_outpost_config.isSet()) {
        obj.insert(QString("outpostConfig"), ::OpenAPI::toJsonValue(m_outpost_config));
    }
    return obj;
}

QString OAIDeleteClusterResponse_cluster::getName() const {
    return m_name;
}
void OAIDeleteClusterResponse_cluster::setName(const QString &name) {
    m_name = name;
    m_name_isSet = true;
}

bool OAIDeleteClusterResponse_cluster::is_name_Set() const{
    return m_name_isSet;
}

bool OAIDeleteClusterResponse_cluster::is_name_Valid() const{
    return m_name_isValid;
}

QString OAIDeleteClusterResponse_cluster::getArn() const {
    return m_arn;
}
void OAIDeleteClusterResponse_cluster::setArn(const QString &arn) {
    m_arn = arn;
    m_arn_isSet = true;
}

bool OAIDeleteClusterResponse_cluster::is_arn_Set() const{
    return m_arn_isSet;
}

bool OAIDeleteClusterResponse_cluster::is_arn_Valid() const{
    return m_arn_isValid;
}

QDateTime OAIDeleteClusterResponse_cluster::getCreatedAt() const {
    return m_created_at;
}
void OAIDeleteClusterResponse_cluster::setCreatedAt(const QDateTime &created_at) {
    m_created_at = created_at;
    m_created_at_isSet = true;
}

bool OAIDeleteClusterResponse_cluster::is_created_at_Set() const{
    return m_created_at_isSet;
}

bool OAIDeleteClusterResponse_cluster::is_created_at_Valid() const{
    return m_created_at_isValid;
}

QString OAIDeleteClusterResponse_cluster::getVersion() const {
    return m_version;
}
void OAIDeleteClusterResponse_cluster::setVersion(const QString &version) {
    m_version = version;
    m_version_isSet = true;
}

bool OAIDeleteClusterResponse_cluster::is_version_Set() const{
    return m_version_isSet;
}

bool OAIDeleteClusterResponse_cluster::is_version_Valid() const{
    return m_version_isValid;
}

QString OAIDeleteClusterResponse_cluster::getEndpoint() const {
    return m_endpoint;
}
void OAIDeleteClusterResponse_cluster::setEndpoint(const QString &endpoint) {
    m_endpoint = endpoint;
    m_endpoint_isSet = true;
}

bool OAIDeleteClusterResponse_cluster::is_endpoint_Set() const{
    return m_endpoint_isSet;
}

bool OAIDeleteClusterResponse_cluster::is_endpoint_Valid() const{
    return m_endpoint_isValid;
}

QString OAIDeleteClusterResponse_cluster::getRoleArn() const {
    return m_role_arn;
}
void OAIDeleteClusterResponse_cluster::setRoleArn(const QString &role_arn) {
    m_role_arn = role_arn;
    m_role_arn_isSet = true;
}

bool OAIDeleteClusterResponse_cluster::is_role_arn_Set() const{
    return m_role_arn_isSet;
}

bool OAIDeleteClusterResponse_cluster::is_role_arn_Valid() const{
    return m_role_arn_isValid;
}

OAICluster_resourcesVpcConfig OAIDeleteClusterResponse_cluster::getResourcesVpcConfig() const {
    return m_resources_vpc_config;
}
void OAIDeleteClusterResponse_cluster::setResourcesVpcConfig(const OAICluster_resourcesVpcConfig &resources_vpc_config) {
    m_resources_vpc_config = resources_vpc_config;
    m_resources_vpc_config_isSet = true;
}

bool OAIDeleteClusterResponse_cluster::is_resources_vpc_config_Set() const{
    return m_resources_vpc_config_isSet;
}

bool OAIDeleteClusterResponse_cluster::is_resources_vpc_config_Valid() const{
    return m_resources_vpc_config_isValid;
}

OAICluster_kubernetesNetworkConfig OAIDeleteClusterResponse_cluster::getKubernetesNetworkConfig() const {
    return m_kubernetes_network_config;
}
void OAIDeleteClusterResponse_cluster::setKubernetesNetworkConfig(const OAICluster_kubernetesNetworkConfig &kubernetes_network_config) {
    m_kubernetes_network_config = kubernetes_network_config;
    m_kubernetes_network_config_isSet = true;
}

bool OAIDeleteClusterResponse_cluster::is_kubernetes_network_config_Set() const{
    return m_kubernetes_network_config_isSet;
}

bool OAIDeleteClusterResponse_cluster::is_kubernetes_network_config_Valid() const{
    return m_kubernetes_network_config_isValid;
}

OAICluster_logging OAIDeleteClusterResponse_cluster::getLogging() const {
    return m_logging;
}
void OAIDeleteClusterResponse_cluster::setLogging(const OAICluster_logging &logging) {
    m_logging = logging;
    m_logging_isSet = true;
}

bool OAIDeleteClusterResponse_cluster::is_logging_Set() const{
    return m_logging_isSet;
}

bool OAIDeleteClusterResponse_cluster::is_logging_Valid() const{
    return m_logging_isValid;
}

OAICluster_identity OAIDeleteClusterResponse_cluster::getIdentity() const {
    return m_identity;
}
void OAIDeleteClusterResponse_cluster::setIdentity(const OAICluster_identity &identity) {
    m_identity = identity;
    m_identity_isSet = true;
}

bool OAIDeleteClusterResponse_cluster::is_identity_Set() const{
    return m_identity_isSet;
}

bool OAIDeleteClusterResponse_cluster::is_identity_Valid() const{
    return m_identity_isValid;
}

OAIClusterStatus OAIDeleteClusterResponse_cluster::getStatus() const {
    return m_status;
}
void OAIDeleteClusterResponse_cluster::setStatus(const OAIClusterStatus &status) {
    m_status = status;
    m_status_isSet = true;
}

bool OAIDeleteClusterResponse_cluster::is_status_Set() const{
    return m_status_isSet;
}

bool OAIDeleteClusterResponse_cluster::is_status_Valid() const{
    return m_status_isValid;
}

OAICluster_certificateAuthority OAIDeleteClusterResponse_cluster::getCertificateAuthority() const {
    return m_certificate_authority;
}
void OAIDeleteClusterResponse_cluster::setCertificateAuthority(const OAICluster_certificateAuthority &certificate_authority) {
    m_certificate_authority = certificate_authority;
    m_certificate_authority_isSet = true;
}

bool OAIDeleteClusterResponse_cluster::is_certificate_authority_Set() const{
    return m_certificate_authority_isSet;
}

bool OAIDeleteClusterResponse_cluster::is_certificate_authority_Valid() const{
    return m_certificate_authority_isValid;
}

QString OAIDeleteClusterResponse_cluster::getClientRequestToken() const {
    return m_client_request_token;
}
void OAIDeleteClusterResponse_cluster::setClientRequestToken(const QString &client_request_token) {
    m_client_request_token = client_request_token;
    m_client_request_token_isSet = true;
}

bool OAIDeleteClusterResponse_cluster::is_client_request_token_Set() const{
    return m_client_request_token_isSet;
}

bool OAIDeleteClusterResponse_cluster::is_client_request_token_Valid() const{
    return m_client_request_token_isValid;
}

QString OAIDeleteClusterResponse_cluster::getPlatformVersion() const {
    return m_platform_version;
}
void OAIDeleteClusterResponse_cluster::setPlatformVersion(const QString &platform_version) {
    m_platform_version = platform_version;
    m_platform_version_isSet = true;
}

bool OAIDeleteClusterResponse_cluster::is_platform_version_Set() const{
    return m_platform_version_isSet;
}

bool OAIDeleteClusterResponse_cluster::is_platform_version_Valid() const{
    return m_platform_version_isValid;
}

QMap OAIDeleteClusterResponse_cluster::getTags() const {
    return m_tags;
}
void OAIDeleteClusterResponse_cluster::setTags(const QMap &tags) {
    m_tags = tags;
    m_tags_isSet = true;
}

bool OAIDeleteClusterResponse_cluster::is_tags_Set() const{
    return m_tags_isSet;
}

bool OAIDeleteClusterResponse_cluster::is_tags_Valid() const{
    return m_tags_isValid;
}

QList OAIDeleteClusterResponse_cluster::getEncryptionConfig() const {
    return m_encryption_config;
}
void OAIDeleteClusterResponse_cluster::setEncryptionConfig(const QList &encryption_config) {
    m_encryption_config = encryption_config;
    m_encryption_config_isSet = true;
}

bool OAIDeleteClusterResponse_cluster::is_encryption_config_Set() const{
    return m_encryption_config_isSet;
}

bool OAIDeleteClusterResponse_cluster::is_encryption_config_Valid() const{
    return m_encryption_config_isValid;
}

OAICluster_connectorConfig OAIDeleteClusterResponse_cluster::getConnectorConfig() const {
    return m_connector_config;
}
void OAIDeleteClusterResponse_cluster::setConnectorConfig(const OAICluster_connectorConfig &connector_config) {
    m_connector_config = connector_config;
    m_connector_config_isSet = true;
}

bool OAIDeleteClusterResponse_cluster::is_connector_config_Set() const{
    return m_connector_config_isSet;
}

bool OAIDeleteClusterResponse_cluster::is_connector_config_Valid() const{
    return m_connector_config_isValid;
}

QString OAIDeleteClusterResponse_cluster::getId() const {
    return m_id;
}
void OAIDeleteClusterResponse_cluster::setId(const QString &id) {
    m_id = id;
    m_id_isSet = true;
}

bool OAIDeleteClusterResponse_cluster::is_id_Set() const{
    return m_id_isSet;
}

bool OAIDeleteClusterResponse_cluster::is_id_Valid() const{
    return m_id_isValid;
}

OAICluster_health OAIDeleteClusterResponse_cluster::getHealth() const {
    return m_health;
}
void OAIDeleteClusterResponse_cluster::setHealth(const OAICluster_health &health) {
    m_health = health;
    m_health_isSet = true;
}

bool OAIDeleteClusterResponse_cluster::is_health_Set() const{
    return m_health_isSet;
}

bool OAIDeleteClusterResponse_cluster::is_health_Valid() const{
    return m_health_isValid;
}

OAICluster_outpostConfig OAIDeleteClusterResponse_cluster::getOutpostConfig() const {
    return m_outpost_config;
}
void OAIDeleteClusterResponse_cluster::setOutpostConfig(const OAICluster_outpostConfig &outpost_config) {
    m_outpost_config = outpost_config;
    m_outpost_config_isSet = true;
}

bool OAIDeleteClusterResponse_cluster::is_outpost_config_Set() const{
    return m_outpost_config_isSet;
}

bool OAIDeleteClusterResponse_cluster::is_outpost_config_Valid() const{
    return m_outpost_config_isValid;
}

bool OAIDeleteClusterResponse_cluster::isSet() const {
    bool isObjectUpdated = false;
    do {
        if (m_name_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_arn_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_created_at_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_version_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_endpoint_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_role_arn_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_resources_vpc_config.isSet()) {
            isObjectUpdated = true;
            break;
        }

        if (m_kubernetes_network_config.isSet()) {
            isObjectUpdated = true;
            break;
        }

        if (m_logging.isSet()) {
            isObjectUpdated = true;
            break;
        }

        if (m_identity.isSet()) {
            isObjectUpdated = true;
            break;
        }

        if (m_status.isSet()) {
            isObjectUpdated = true;
            break;
        }

        if (m_certificate_authority.isSet()) {
            isObjectUpdated = true;
            break;
        }

        if (m_client_request_token_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_platform_version_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_tags.isSet()) {
            isObjectUpdated = true;
            break;
        }

        if (m_encryption_config.isSet()) {
            isObjectUpdated = true;
            break;
        }

        if (m_connector_config.isSet()) {
            isObjectUpdated = true;
            break;
        }

        if (m_id_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_health.isSet()) {
            isObjectUpdated = true;
            break;
        }

        if (m_outpost_config.isSet()) {
            isObjectUpdated = true;
            break;
        }
    } while (false);
    return isObjectUpdated;
}

bool OAIDeleteClusterResponse_cluster::isValid() const {
    // only required properties are required for the object to be considered valid
    return true;
}

} // namespace OpenAPI
