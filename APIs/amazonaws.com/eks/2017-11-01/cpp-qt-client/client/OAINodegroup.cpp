/**
 * Amazon Elastic Kubernetes Service
 * <p>Amazon Elastic Kubernetes Service (Amazon EKS) is a managed service that makes it easy for you to run Kubernetes on Amazon Web Services without needing to stand up or maintain your own Kubernetes control plane. Kubernetes is an open-source system for automating the deployment, scaling, and management of containerized applications. </p> <p>Amazon EKS runs up-to-date versions of the open-source Kubernetes software, so you can use all the existing plugins and tooling from the Kubernetes community. Applications running on Amazon EKS are fully compatible with applications running on any standard Kubernetes environment, whether running in on-premises data centers or public clouds. This means that you can easily migrate any standard Kubernetes application to Amazon EKS without any code modification required.</p>
 *
 * The version of the OpenAPI document: 2017-11-01
 * Contact: mike.ralphson@gmail.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

#include "OAINodegroup.h"

#include <QDebug>
#include <QJsonArray>
#include <QJsonDocument>
#include <QObject>

#include "OAIHelpers.h"

namespace OpenAPI {

OAINodegroup::OAINodegroup(QString json) {
    this->initializeModel();
    this->fromJson(json);
}

OAINodegroup::OAINodegroup() {
    this->initializeModel();
}

OAINodegroup::~OAINodegroup() {}

void OAINodegroup::initializeModel() {

    m_nodegroup_name_isSet = false;
    m_nodegroup_name_isValid = false;

    m_nodegroup_arn_isSet = false;
    m_nodegroup_arn_isValid = false;

    m_cluster_name_isSet = false;
    m_cluster_name_isValid = false;

    m_version_isSet = false;
    m_version_isValid = false;

    m_release_version_isSet = false;
    m_release_version_isValid = false;

    m_created_at_isSet = false;
    m_created_at_isValid = false;

    m_modified_at_isSet = false;
    m_modified_at_isValid = false;

    m_status_isSet = false;
    m_status_isValid = false;

    m_capacity_type_isSet = false;
    m_capacity_type_isValid = false;

    m_scaling_config_isSet = false;
    m_scaling_config_isValid = false;

    m_instance_types_isSet = false;
    m_instance_types_isValid = false;

    m_subnets_isSet = false;
    m_subnets_isValid = false;

    m_remote_access_isSet = false;
    m_remote_access_isValid = false;

    m_ami_type_isSet = false;
    m_ami_type_isValid = false;

    m_node_role_isSet = false;
    m_node_role_isValid = false;

    m_labels_isSet = false;
    m_labels_isValid = false;

    m_taints_isSet = false;
    m_taints_isValid = false;

    m_resources_isSet = false;
    m_resources_isValid = false;

    m_disk_size_isSet = false;
    m_disk_size_isValid = false;

    m_health_isSet = false;
    m_health_isValid = false;

    m_update_config_isSet = false;
    m_update_config_isValid = false;

    m_launch_template_isSet = false;
    m_launch_template_isValid = false;

    m_tags_isSet = false;
    m_tags_isValid = false;
}

void OAINodegroup::fromJson(QString jsonString) {
    QByteArray array(jsonString.toStdString().c_str());
    QJsonDocument doc = QJsonDocument::fromJson(array);
    QJsonObject jsonObject = doc.object();
    this->fromJsonObject(jsonObject);
}

void OAINodegroup::fromJsonObject(QJsonObject json) {

    m_nodegroup_name_isValid = ::OpenAPI::fromJsonValue(m_nodegroup_name, json[QString("nodegroupName")]);
    m_nodegroup_name_isSet = !json[QString("nodegroupName")].isNull() && m_nodegroup_name_isValid;

    m_nodegroup_arn_isValid = ::OpenAPI::fromJsonValue(m_nodegroup_arn, json[QString("nodegroupArn")]);
    m_nodegroup_arn_isSet = !json[QString("nodegroupArn")].isNull() && m_nodegroup_arn_isValid;

    m_cluster_name_isValid = ::OpenAPI::fromJsonValue(m_cluster_name, json[QString("clusterName")]);
    m_cluster_name_isSet = !json[QString("clusterName")].isNull() && m_cluster_name_isValid;

    m_version_isValid = ::OpenAPI::fromJsonValue(m_version, json[QString("version")]);
    m_version_isSet = !json[QString("version")].isNull() && m_version_isValid;

    m_release_version_isValid = ::OpenAPI::fromJsonValue(m_release_version, json[QString("releaseVersion")]);
    m_release_version_isSet = !json[QString("releaseVersion")].isNull() && m_release_version_isValid;

    m_created_at_isValid = ::OpenAPI::fromJsonValue(m_created_at, json[QString("createdAt")]);
    m_created_at_isSet = !json[QString("createdAt")].isNull() && m_created_at_isValid;

    m_modified_at_isValid = ::OpenAPI::fromJsonValue(m_modified_at, json[QString("modifiedAt")]);
    m_modified_at_isSet = !json[QString("modifiedAt")].isNull() && m_modified_at_isValid;

    m_status_isValid = ::OpenAPI::fromJsonValue(m_status, json[QString("status")]);
    m_status_isSet = !json[QString("status")].isNull() && m_status_isValid;

    m_capacity_type_isValid = ::OpenAPI::fromJsonValue(m_capacity_type, json[QString("capacityType")]);
    m_capacity_type_isSet = !json[QString("capacityType")].isNull() && m_capacity_type_isValid;

    m_scaling_config_isValid = ::OpenAPI::fromJsonValue(m_scaling_config, json[QString("scalingConfig")]);
    m_scaling_config_isSet = !json[QString("scalingConfig")].isNull() && m_scaling_config_isValid;

    m_instance_types_isValid = ::OpenAPI::fromJsonValue(m_instance_types, json[QString("instanceTypes")]);
    m_instance_types_isSet = !json[QString("instanceTypes")].isNull() && m_instance_types_isValid;

    m_subnets_isValid = ::OpenAPI::fromJsonValue(m_subnets, json[QString("subnets")]);
    m_subnets_isSet = !json[QString("subnets")].isNull() && m_subnets_isValid;

    m_remote_access_isValid = ::OpenAPI::fromJsonValue(m_remote_access, json[QString("remoteAccess")]);
    m_remote_access_isSet = !json[QString("remoteAccess")].isNull() && m_remote_access_isValid;

    m_ami_type_isValid = ::OpenAPI::fromJsonValue(m_ami_type, json[QString("amiType")]);
    m_ami_type_isSet = !json[QString("amiType")].isNull() && m_ami_type_isValid;

    m_node_role_isValid = ::OpenAPI::fromJsonValue(m_node_role, json[QString("nodeRole")]);
    m_node_role_isSet = !json[QString("nodeRole")].isNull() && m_node_role_isValid;

    m_labels_isValid = ::OpenAPI::fromJsonValue(m_labels, json[QString("labels")]);
    m_labels_isSet = !json[QString("labels")].isNull() && m_labels_isValid;

    m_taints_isValid = ::OpenAPI::fromJsonValue(m_taints, json[QString("taints")]);
    m_taints_isSet = !json[QString("taints")].isNull() && m_taints_isValid;

    m_resources_isValid = ::OpenAPI::fromJsonValue(m_resources, json[QString("resources")]);
    m_resources_isSet = !json[QString("resources")].isNull() && m_resources_isValid;

    m_disk_size_isValid = ::OpenAPI::fromJsonValue(m_disk_size, json[QString("diskSize")]);
    m_disk_size_isSet = !json[QString("diskSize")].isNull() && m_disk_size_isValid;

    m_health_isValid = ::OpenAPI::fromJsonValue(m_health, json[QString("health")]);
    m_health_isSet = !json[QString("health")].isNull() && m_health_isValid;

    m_update_config_isValid = ::OpenAPI::fromJsonValue(m_update_config, json[QString("updateConfig")]);
    m_update_config_isSet = !json[QString("updateConfig")].isNull() && m_update_config_isValid;

    m_launch_template_isValid = ::OpenAPI::fromJsonValue(m_launch_template, json[QString("launchTemplate")]);
    m_launch_template_isSet = !json[QString("launchTemplate")].isNull() && m_launch_template_isValid;

    m_tags_isValid = ::OpenAPI::fromJsonValue(m_tags, json[QString("tags")]);
    m_tags_isSet = !json[QString("tags")].isNull() && m_tags_isValid;
}

QString OAINodegroup::asJson() const {
    QJsonObject obj = this->asJsonObject();
    QJsonDocument doc(obj);
    QByteArray bytes = doc.toJson();
    return QString(bytes);
}

QJsonObject OAINodegroup::asJsonObject() const {
    QJsonObject obj;
    if (m_nodegroup_name_isSet) {
        obj.insert(QString("nodegroupName"), ::OpenAPI::toJsonValue(m_nodegroup_name));
    }
    if (m_nodegroup_arn_isSet) {
        obj.insert(QString("nodegroupArn"), ::OpenAPI::toJsonValue(m_nodegroup_arn));
    }
    if (m_cluster_name_isSet) {
        obj.insert(QString("clusterName"), ::OpenAPI::toJsonValue(m_cluster_name));
    }
    if (m_version_isSet) {
        obj.insert(QString("version"), ::OpenAPI::toJsonValue(m_version));
    }
    if (m_release_version_isSet) {
        obj.insert(QString("releaseVersion"), ::OpenAPI::toJsonValue(m_release_version));
    }
    if (m_created_at_isSet) {
        obj.insert(QString("createdAt"), ::OpenAPI::toJsonValue(m_created_at));
    }
    if (m_modified_at_isSet) {
        obj.insert(QString("modifiedAt"), ::OpenAPI::toJsonValue(m_modified_at));
    }
    if (m_status.isSet()) {
        obj.insert(QString("status"), ::OpenAPI::toJsonValue(m_status));
    }
    if (m_capacity_type.isSet()) {
        obj.insert(QString("capacityType"), ::OpenAPI::toJsonValue(m_capacity_type));
    }
    if (m_scaling_config.isSet()) {
        obj.insert(QString("scalingConfig"), ::OpenAPI::toJsonValue(m_scaling_config));
    }
    if (m_instance_types.isSet()) {
        obj.insert(QString("instanceTypes"), ::OpenAPI::toJsonValue(m_instance_types));
    }
    if (m_subnets.isSet()) {
        obj.insert(QString("subnets"), ::OpenAPI::toJsonValue(m_subnets));
    }
    if (m_remote_access.isSet()) {
        obj.insert(QString("remoteAccess"), ::OpenAPI::toJsonValue(m_remote_access));
    }
    if (m_ami_type.isSet()) {
        obj.insert(QString("amiType"), ::OpenAPI::toJsonValue(m_ami_type));
    }
    if (m_node_role_isSet) {
        obj.insert(QString("nodeRole"), ::OpenAPI::toJsonValue(m_node_role));
    }
    if (m_labels.isSet()) {
        obj.insert(QString("labels"), ::OpenAPI::toJsonValue(m_labels));
    }
    if (m_taints.isSet()) {
        obj.insert(QString("taints"), ::OpenAPI::toJsonValue(m_taints));
    }
    if (m_resources.isSet()) {
        obj.insert(QString("resources"), ::OpenAPI::toJsonValue(m_resources));
    }
    if (m_disk_size_isSet) {
        obj.insert(QString("diskSize"), ::OpenAPI::toJsonValue(m_disk_size));
    }
    if (m_health.isSet()) {
        obj.insert(QString("health"), ::OpenAPI::toJsonValue(m_health));
    }
    if (m_update_config.isSet()) {
        obj.insert(QString("updateConfig"), ::OpenAPI::toJsonValue(m_update_config));
    }
    if (m_launch_template.isSet()) {
        obj.insert(QString("launchTemplate"), ::OpenAPI::toJsonValue(m_launch_template));
    }
    if (m_tags.isSet()) {
        obj.insert(QString("tags"), ::OpenAPI::toJsonValue(m_tags));
    }
    return obj;
}

QString OAINodegroup::getNodegroupName() const {
    return m_nodegroup_name;
}
void OAINodegroup::setNodegroupName(const QString &nodegroup_name) {
    m_nodegroup_name = nodegroup_name;
    m_nodegroup_name_isSet = true;
}

bool OAINodegroup::is_nodegroup_name_Set() const{
    return m_nodegroup_name_isSet;
}

bool OAINodegroup::is_nodegroup_name_Valid() const{
    return m_nodegroup_name_isValid;
}

QString OAINodegroup::getNodegroupArn() const {
    return m_nodegroup_arn;
}
void OAINodegroup::setNodegroupArn(const QString &nodegroup_arn) {
    m_nodegroup_arn = nodegroup_arn;
    m_nodegroup_arn_isSet = true;
}

bool OAINodegroup::is_nodegroup_arn_Set() const{
    return m_nodegroup_arn_isSet;
}

bool OAINodegroup::is_nodegroup_arn_Valid() const{
    return m_nodegroup_arn_isValid;
}

QString OAINodegroup::getClusterName() const {
    return m_cluster_name;
}
void OAINodegroup::setClusterName(const QString &cluster_name) {
    m_cluster_name = cluster_name;
    m_cluster_name_isSet = true;
}

bool OAINodegroup::is_cluster_name_Set() const{
    return m_cluster_name_isSet;
}

bool OAINodegroup::is_cluster_name_Valid() const{
    return m_cluster_name_isValid;
}

QString OAINodegroup::getVersion() const {
    return m_version;
}
void OAINodegroup::setVersion(const QString &version) {
    m_version = version;
    m_version_isSet = true;
}

bool OAINodegroup::is_version_Set() const{
    return m_version_isSet;
}

bool OAINodegroup::is_version_Valid() const{
    return m_version_isValid;
}

QString OAINodegroup::getReleaseVersion() const {
    return m_release_version;
}
void OAINodegroup::setReleaseVersion(const QString &release_version) {
    m_release_version = release_version;
    m_release_version_isSet = true;
}

bool OAINodegroup::is_release_version_Set() const{
    return m_release_version_isSet;
}

bool OAINodegroup::is_release_version_Valid() const{
    return m_release_version_isValid;
}

QDateTime OAINodegroup::getCreatedAt() const {
    return m_created_at;
}
void OAINodegroup::setCreatedAt(const QDateTime &created_at) {
    m_created_at = created_at;
    m_created_at_isSet = true;
}

bool OAINodegroup::is_created_at_Set() const{
    return m_created_at_isSet;
}

bool OAINodegroup::is_created_at_Valid() const{
    return m_created_at_isValid;
}

QDateTime OAINodegroup::getModifiedAt() const {
    return m_modified_at;
}
void OAINodegroup::setModifiedAt(const QDateTime &modified_at) {
    m_modified_at = modified_at;
    m_modified_at_isSet = true;
}

bool OAINodegroup::is_modified_at_Set() const{
    return m_modified_at_isSet;
}

bool OAINodegroup::is_modified_at_Valid() const{
    return m_modified_at_isValid;
}

OAINodegroupStatus OAINodegroup::getStatus() const {
    return m_status;
}
void OAINodegroup::setStatus(const OAINodegroupStatus &status) {
    m_status = status;
    m_status_isSet = true;
}

bool OAINodegroup::is_status_Set() const{
    return m_status_isSet;
}

bool OAINodegroup::is_status_Valid() const{
    return m_status_isValid;
}

OAICapacityTypes OAINodegroup::getCapacityType() const {
    return m_capacity_type;
}
void OAINodegroup::setCapacityType(const OAICapacityTypes &capacity_type) {
    m_capacity_type = capacity_type;
    m_capacity_type_isSet = true;
}

bool OAINodegroup::is_capacity_type_Set() const{
    return m_capacity_type_isSet;
}

bool OAINodegroup::is_capacity_type_Valid() const{
    return m_capacity_type_isValid;
}

OAINodegroup_scalingConfig OAINodegroup::getScalingConfig() const {
    return m_scaling_config;
}
void OAINodegroup::setScalingConfig(const OAINodegroup_scalingConfig &scaling_config) {
    m_scaling_config = scaling_config;
    m_scaling_config_isSet = true;
}

bool OAINodegroup::is_scaling_config_Set() const{
    return m_scaling_config_isSet;
}

bool OAINodegroup::is_scaling_config_Valid() const{
    return m_scaling_config_isValid;
}

QList OAINodegroup::getInstanceTypes() const {
    return m_instance_types;
}
void OAINodegroup::setInstanceTypes(const QList &instance_types) {
    m_instance_types = instance_types;
    m_instance_types_isSet = true;
}

bool OAINodegroup::is_instance_types_Set() const{
    return m_instance_types_isSet;
}

bool OAINodegroup::is_instance_types_Valid() const{
    return m_instance_types_isValid;
}

QList OAINodegroup::getSubnets() const {
    return m_subnets;
}
void OAINodegroup::setSubnets(const QList &subnets) {
    m_subnets = subnets;
    m_subnets_isSet = true;
}

bool OAINodegroup::is_subnets_Set() const{
    return m_subnets_isSet;
}

bool OAINodegroup::is_subnets_Valid() const{
    return m_subnets_isValid;
}

OAINodegroup_remoteAccess OAINodegroup::getRemoteAccess() const {
    return m_remote_access;
}
void OAINodegroup::setRemoteAccess(const OAINodegroup_remoteAccess &remote_access) {
    m_remote_access = remote_access;
    m_remote_access_isSet = true;
}

bool OAINodegroup::is_remote_access_Set() const{
    return m_remote_access_isSet;
}

bool OAINodegroup::is_remote_access_Valid() const{
    return m_remote_access_isValid;
}

OAIAMITypes OAINodegroup::getAmiType() const {
    return m_ami_type;
}
void OAINodegroup::setAmiType(const OAIAMITypes &ami_type) {
    m_ami_type = ami_type;
    m_ami_type_isSet = true;
}

bool OAINodegroup::is_ami_type_Set() const{
    return m_ami_type_isSet;
}

bool OAINodegroup::is_ami_type_Valid() const{
    return m_ami_type_isValid;
}

QString OAINodegroup::getNodeRole() const {
    return m_node_role;
}
void OAINodegroup::setNodeRole(const QString &node_role) {
    m_node_role = node_role;
    m_node_role_isSet = true;
}

bool OAINodegroup::is_node_role_Set() const{
    return m_node_role_isSet;
}

bool OAINodegroup::is_node_role_Valid() const{
    return m_node_role_isValid;
}

QMap OAINodegroup::getLabels() const {
    return m_labels;
}
void OAINodegroup::setLabels(const QMap &labels) {
    m_labels = labels;
    m_labels_isSet = true;
}

bool OAINodegroup::is_labels_Set() const{
    return m_labels_isSet;
}

bool OAINodegroup::is_labels_Valid() const{
    return m_labels_isValid;
}

QList OAINodegroup::getTaints() const {
    return m_taints;
}
void OAINodegroup::setTaints(const QList &taints) {
    m_taints = taints;
    m_taints_isSet = true;
}

bool OAINodegroup::is_taints_Set() const{
    return m_taints_isSet;
}

bool OAINodegroup::is_taints_Valid() const{
    return m_taints_isValid;
}

OAINodegroup_resources OAINodegroup::getResources() const {
    return m_resources;
}
void OAINodegroup::setResources(const OAINodegroup_resources &resources) {
    m_resources = resources;
    m_resources_isSet = true;
}

bool OAINodegroup::is_resources_Set() const{
    return m_resources_isSet;
}

bool OAINodegroup::is_resources_Valid() const{
    return m_resources_isValid;
}

qint32 OAINodegroup::getDiskSize() const {
    return m_disk_size;
}
void OAINodegroup::setDiskSize(const qint32 &disk_size) {
    m_disk_size = disk_size;
    m_disk_size_isSet = true;
}

bool OAINodegroup::is_disk_size_Set() const{
    return m_disk_size_isSet;
}

bool OAINodegroup::is_disk_size_Valid() const{
    return m_disk_size_isValid;
}

OAINodegroup_health OAINodegroup::getHealth() const {
    return m_health;
}
void OAINodegroup::setHealth(const OAINodegroup_health &health) {
    m_health = health;
    m_health_isSet = true;
}

bool OAINodegroup::is_health_Set() const{
    return m_health_isSet;
}

bool OAINodegroup::is_health_Valid() const{
    return m_health_isValid;
}

OAICreateNodegroupRequest_updateConfig OAINodegroup::getUpdateConfig() const {
    return m_update_config;
}
void OAINodegroup::setUpdateConfig(const OAICreateNodegroupRequest_updateConfig &update_config) {
    m_update_config = update_config;
    m_update_config_isSet = true;
}

bool OAINodegroup::is_update_config_Set() const{
    return m_update_config_isSet;
}

bool OAINodegroup::is_update_config_Valid() const{
    return m_update_config_isValid;
}

OAINodegroup_launchTemplate OAINodegroup::getLaunchTemplate() const {
    return m_launch_template;
}
void OAINodegroup::setLaunchTemplate(const OAINodegroup_launchTemplate &launch_template) {
    m_launch_template = launch_template;
    m_launch_template_isSet = true;
}

bool OAINodegroup::is_launch_template_Set() const{
    return m_launch_template_isSet;
}

bool OAINodegroup::is_launch_template_Valid() const{
    return m_launch_template_isValid;
}

QMap OAINodegroup::getTags() const {
    return m_tags;
}
void OAINodegroup::setTags(const QMap &tags) {
    m_tags = tags;
    m_tags_isSet = true;
}

bool OAINodegroup::is_tags_Set() const{
    return m_tags_isSet;
}

bool OAINodegroup::is_tags_Valid() const{
    return m_tags_isValid;
}

bool OAINodegroup::isSet() const {
    bool isObjectUpdated = false;
    do {
        if (m_nodegroup_name_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_nodegroup_arn_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_cluster_name_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_version_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_release_version_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_created_at_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_modified_at_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_status.isSet()) {
            isObjectUpdated = true;
            break;
        }

        if (m_capacity_type.isSet()) {
            isObjectUpdated = true;
            break;
        }

        if (m_scaling_config.isSet()) {
            isObjectUpdated = true;
            break;
        }

        if (m_instance_types.isSet()) {
            isObjectUpdated = true;
            break;
        }

        if (m_subnets.isSet()) {
            isObjectUpdated = true;
            break;
        }

        if (m_remote_access.isSet()) {
            isObjectUpdated = true;
            break;
        }

        if (m_ami_type.isSet()) {
            isObjectUpdated = true;
            break;
        }

        if (m_node_role_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_labels.isSet()) {
            isObjectUpdated = true;
            break;
        }

        if (m_taints.isSet()) {
            isObjectUpdated = true;
            break;
        }

        if (m_resources.isSet()) {
            isObjectUpdated = true;
            break;
        }

        if (m_disk_size_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_health.isSet()) {
            isObjectUpdated = true;
            break;
        }

        if (m_update_config.isSet()) {
            isObjectUpdated = true;
            break;
        }

        if (m_launch_template.isSet()) {
            isObjectUpdated = true;
            break;
        }

        if (m_tags.isSet()) {
            isObjectUpdated = true;
            break;
        }
    } while (false);
    return isObjectUpdated;
}

bool OAINodegroup::isValid() const {
    // only required properties are required for the object to be considered valid
    return true;
}

} // namespace OpenAPI
