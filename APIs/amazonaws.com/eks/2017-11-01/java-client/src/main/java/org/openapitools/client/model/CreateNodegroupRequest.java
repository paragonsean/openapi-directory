/*
 * Amazon Elastic Kubernetes Service
 * <p>Amazon Elastic Kubernetes Service (Amazon EKS) is a managed service that makes it easy for you to run Kubernetes on Amazon Web Services without needing to stand up or maintain your own Kubernetes control plane. Kubernetes is an open-source system for automating the deployment, scaling, and management of containerized applications. </p> <p>Amazon EKS runs up-to-date versions of the open-source Kubernetes software, so you can use all the existing plugins and tooling from the Kubernetes community. Applications running on Amazon EKS are fully compatible with applications running on any standard Kubernetes environment, whether running in on-premises data centers or public clouds. This means that you can easily migrate any standard Kubernetes application to Amazon EKS without any code modification required.</p>
 *
 * The version of the OpenAPI document: 2017-11-01
 * Contact: mike.ralphson@gmail.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package org.openapitools.client.model;

import java.util.Objects;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import org.openapitools.client.model.CreateNodegroupRequestLaunchTemplate;
import org.openapitools.client.model.CreateNodegroupRequestRemoteAccess;
import org.openapitools.client.model.CreateNodegroupRequestScalingConfig;
import org.openapitools.client.model.CreateNodegroupRequestUpdateConfig;
import org.openapitools.client.model.Taint;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonArray;
import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;
import com.google.gson.TypeAdapterFactory;
import com.google.gson.reflect.TypeToken;
import com.google.gson.TypeAdapter;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;

import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import org.openapitools.client.JSON;

/**
 * CreateNodegroupRequest
 */
@javax.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen", date = "2024-10-12T12:26:04.017338-04:00[America/New_York]", comments = "Generator version: 7.9.0")
public class CreateNodegroupRequest {
  public static final String SERIALIZED_NAME_NODEGROUP_NAME = "nodegroupName";
  @SerializedName(SERIALIZED_NAME_NODEGROUP_NAME)
  private String nodegroupName;

  public static final String SERIALIZED_NAME_SCALING_CONFIG = "scalingConfig";
  @SerializedName(SERIALIZED_NAME_SCALING_CONFIG)
  private CreateNodegroupRequestScalingConfig scalingConfig;

  public static final String SERIALIZED_NAME_DISK_SIZE = "diskSize";
  @SerializedName(SERIALIZED_NAME_DISK_SIZE)
  private Integer diskSize;

  public static final String SERIALIZED_NAME_SUBNETS = "subnets";
  @SerializedName(SERIALIZED_NAME_SUBNETS)
  private List<String> subnets = new ArrayList<>();

  public static final String SERIALIZED_NAME_INSTANCE_TYPES = "instanceTypes";
  @SerializedName(SERIALIZED_NAME_INSTANCE_TYPES)
  private List<String> instanceTypes = new ArrayList<>();

  /**
   * The AMI type for your node group. If you specify &lt;code&gt;launchTemplate&lt;/code&gt;, and your launch template uses a custom AMI, then don&#39;t specify &lt;code&gt;amiType&lt;/code&gt;, or the node group deployment will fail. If your launch template uses a Windows custom AMI, then add &lt;code&gt;eks:kube-proxy-windows&lt;/code&gt; to your Windows nodes &lt;code&gt;rolearn&lt;/code&gt; in the &lt;code&gt;aws-auth&lt;/code&gt; &lt;code&gt;ConfigMap&lt;/code&gt;. For more information about using launch templates with Amazon EKS, see &lt;a href&#x3D;\&quot;https://docs.aws.amazon.com/eks/latest/userguide/launch-templates.html\&quot;&gt;Launch template support&lt;/a&gt; in the &lt;i&gt;Amazon EKS User Guide&lt;/i&gt;.
   */
  @JsonAdapter(AmiTypeEnum.Adapter.class)
  public enum AmiTypeEnum {
    AL2_X86_64("AL2_x86_64"),
    
    AL2_X86_64_GPU("AL2_x86_64_GPU"),
    
    AL2_ARM_64("AL2_ARM_64"),
    
    CUSTOM("CUSTOM"),
    
    BOTTLEROCKET_ARM_64("BOTTLEROCKET_ARM_64"),
    
    BOTTLEROCKET_X86_64("BOTTLEROCKET_x86_64"),
    
    BOTTLEROCKET_ARM_64_NVIDIA("BOTTLEROCKET_ARM_64_NVIDIA"),
    
    BOTTLEROCKET_X86_64_NVIDIA("BOTTLEROCKET_x86_64_NVIDIA"),
    
    WINDOWS_CORE_2019_X86_64("WINDOWS_CORE_2019_x86_64"),
    
    WINDOWS_FULL_2019_X86_64("WINDOWS_FULL_2019_x86_64"),
    
    WINDOWS_CORE_2022_X86_64("WINDOWS_CORE_2022_x86_64"),
    
    WINDOWS_FULL_2022_X86_64("WINDOWS_FULL_2022_x86_64");

    private String value;

    AmiTypeEnum(String value) {
      this.value = value;
    }

    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }

    public static AmiTypeEnum fromValue(String value) {
      for (AmiTypeEnum b : AmiTypeEnum.values()) {
        if (b.value.equals(value)) {
          return b;
        }
      }
      throw new IllegalArgumentException("Unexpected value '" + value + "'");
    }

    public static class Adapter extends TypeAdapter<AmiTypeEnum> {
      @Override
      public void write(final JsonWriter jsonWriter, final AmiTypeEnum enumeration) throws IOException {
        jsonWriter.value(enumeration.getValue());
      }

      @Override
      public AmiTypeEnum read(final JsonReader jsonReader) throws IOException {
        String value =  jsonReader.nextString();
        return AmiTypeEnum.fromValue(value);
      }
    }

    public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      String value = jsonElement.getAsString();
      AmiTypeEnum.fromValue(value);
    }
  }

  public static final String SERIALIZED_NAME_AMI_TYPE = "amiType";
  @SerializedName(SERIALIZED_NAME_AMI_TYPE)
  private AmiTypeEnum amiType;

  public static final String SERIALIZED_NAME_REMOTE_ACCESS = "remoteAccess";
  @SerializedName(SERIALIZED_NAME_REMOTE_ACCESS)
  private CreateNodegroupRequestRemoteAccess remoteAccess;

  public static final String SERIALIZED_NAME_NODE_ROLE = "nodeRole";
  @SerializedName(SERIALIZED_NAME_NODE_ROLE)
  private String nodeRole;

  public static final String SERIALIZED_NAME_LABELS = "labels";
  @SerializedName(SERIALIZED_NAME_LABELS)
  private Map<String, String> labels = new HashMap<>();

  public static final String SERIALIZED_NAME_TAINTS = "taints";
  @SerializedName(SERIALIZED_NAME_TAINTS)
  private List<Taint> taints = new ArrayList<>();

  public static final String SERIALIZED_NAME_TAGS = "tags";
  @SerializedName(SERIALIZED_NAME_TAGS)
  private Map<String, String> tags = new HashMap<>();

  public static final String SERIALIZED_NAME_CLIENT_REQUEST_TOKEN = "clientRequestToken";
  @SerializedName(SERIALIZED_NAME_CLIENT_REQUEST_TOKEN)
  private String clientRequestToken;

  public static final String SERIALIZED_NAME_LAUNCH_TEMPLATE = "launchTemplate";
  @SerializedName(SERIALIZED_NAME_LAUNCH_TEMPLATE)
  private CreateNodegroupRequestLaunchTemplate launchTemplate;

  public static final String SERIALIZED_NAME_UPDATE_CONFIG = "updateConfig";
  @SerializedName(SERIALIZED_NAME_UPDATE_CONFIG)
  private CreateNodegroupRequestUpdateConfig updateConfig;

  /**
   * The capacity type for your node group.
   */
  @JsonAdapter(CapacityTypeEnum.Adapter.class)
  public enum CapacityTypeEnum {
    ON_DEMAND("ON_DEMAND"),
    
    SPOT("SPOT");

    private String value;

    CapacityTypeEnum(String value) {
      this.value = value;
    }

    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }

    public static CapacityTypeEnum fromValue(String value) {
      for (CapacityTypeEnum b : CapacityTypeEnum.values()) {
        if (b.value.equals(value)) {
          return b;
        }
      }
      throw new IllegalArgumentException("Unexpected value '" + value + "'");
    }

    public static class Adapter extends TypeAdapter<CapacityTypeEnum> {
      @Override
      public void write(final JsonWriter jsonWriter, final CapacityTypeEnum enumeration) throws IOException {
        jsonWriter.value(enumeration.getValue());
      }

      @Override
      public CapacityTypeEnum read(final JsonReader jsonReader) throws IOException {
        String value =  jsonReader.nextString();
        return CapacityTypeEnum.fromValue(value);
      }
    }

    public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      String value = jsonElement.getAsString();
      CapacityTypeEnum.fromValue(value);
    }
  }

  public static final String SERIALIZED_NAME_CAPACITY_TYPE = "capacityType";
  @SerializedName(SERIALIZED_NAME_CAPACITY_TYPE)
  private CapacityTypeEnum capacityType;

  public static final String SERIALIZED_NAME_VERSION = "version";
  @SerializedName(SERIALIZED_NAME_VERSION)
  private String version;

  public static final String SERIALIZED_NAME_RELEASE_VERSION = "releaseVersion";
  @SerializedName(SERIALIZED_NAME_RELEASE_VERSION)
  private String releaseVersion;

  public CreateNodegroupRequest() {
  }

  public CreateNodegroupRequest nodegroupName(String nodegroupName) {
    this.nodegroupName = nodegroupName;
    return this;
  }

  /**
   * The unique name to give your node group.
   * @return nodegroupName
   */
  @javax.annotation.Nonnull
  public String getNodegroupName() {
    return nodegroupName;
  }

  public void setNodegroupName(String nodegroupName) {
    this.nodegroupName = nodegroupName;
  }


  public CreateNodegroupRequest scalingConfig(CreateNodegroupRequestScalingConfig scalingConfig) {
    this.scalingConfig = scalingConfig;
    return this;
  }

  /**
   * Get scalingConfig
   * @return scalingConfig
   */
  @javax.annotation.Nullable
  public CreateNodegroupRequestScalingConfig getScalingConfig() {
    return scalingConfig;
  }

  public void setScalingConfig(CreateNodegroupRequestScalingConfig scalingConfig) {
    this.scalingConfig = scalingConfig;
  }


  public CreateNodegroupRequest diskSize(Integer diskSize) {
    this.diskSize = diskSize;
    return this;
  }

  /**
   * The root device disk size (in GiB) for your node group instances. The default disk size is 20 GiB for Linux and Bottlerocket. The default disk size is 50 GiB for Windows. If you specify &lt;code&gt;launchTemplate&lt;/code&gt;, then don&#39;t specify &lt;code&gt;diskSize&lt;/code&gt;, or the node group deployment will fail. For more information about using launch templates with Amazon EKS, see &lt;a href&#x3D;\&quot;https://docs.aws.amazon.com/eks/latest/userguide/launch-templates.html\&quot;&gt;Launch template support&lt;/a&gt; in the &lt;i&gt;Amazon EKS User Guide&lt;/i&gt;.
   * @return diskSize
   */
  @javax.annotation.Nullable
  public Integer getDiskSize() {
    return diskSize;
  }

  public void setDiskSize(Integer diskSize) {
    this.diskSize = diskSize;
  }


  public CreateNodegroupRequest subnets(List<String> subnets) {
    this.subnets = subnets;
    return this;
  }

  public CreateNodegroupRequest addSubnetsItem(String subnetsItem) {
    if (this.subnets == null) {
      this.subnets = new ArrayList<>();
    }
    this.subnets.add(subnetsItem);
    return this;
  }

  /**
   * The subnets to use for the Auto Scaling group that is created for your node group. If you specify &lt;code&gt;launchTemplate&lt;/code&gt;, then don&#39;t specify &lt;a href&#x3D;\&quot;https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_CreateNetworkInterface.html\&quot;&gt; &lt;code&gt;SubnetId&lt;/code&gt; &lt;/a&gt; in your launch template, or the node group deployment will fail. For more information about using launch templates with Amazon EKS, see &lt;a href&#x3D;\&quot;https://docs.aws.amazon.com/eks/latest/userguide/launch-templates.html\&quot;&gt;Launch template support&lt;/a&gt; in the &lt;i&gt;Amazon EKS User Guide&lt;/i&gt;.
   * @return subnets
   */
  @javax.annotation.Nonnull
  public List<String> getSubnets() {
    return subnets;
  }

  public void setSubnets(List<String> subnets) {
    this.subnets = subnets;
  }


  public CreateNodegroupRequest instanceTypes(List<String> instanceTypes) {
    this.instanceTypes = instanceTypes;
    return this;
  }

  public CreateNodegroupRequest addInstanceTypesItem(String instanceTypesItem) {
    if (this.instanceTypes == null) {
      this.instanceTypes = new ArrayList<>();
    }
    this.instanceTypes.add(instanceTypesItem);
    return this;
  }

  /**
   * Specify the instance types for a node group. If you specify a GPU instance type, make sure to also specify an applicable GPU AMI type with the &lt;code&gt;amiType&lt;/code&gt; parameter. If you specify &lt;code&gt;launchTemplate&lt;/code&gt;, then you can specify zero or one instance type in your launch template &lt;i&gt;or&lt;/i&gt; you can specify 0-20 instance types for &lt;code&gt;instanceTypes&lt;/code&gt;. If however, you specify an instance type in your launch template &lt;i&gt;and&lt;/i&gt; specify any &lt;code&gt;instanceTypes&lt;/code&gt;, the node group deployment will fail. If you don&#39;t specify an instance type in a launch template or for &lt;code&gt;instanceTypes&lt;/code&gt;, then &lt;code&gt;t3.medium&lt;/code&gt; is used, by default. If you specify &lt;code&gt;Spot&lt;/code&gt; for &lt;code&gt;capacityType&lt;/code&gt;, then we recommend specifying multiple values for &lt;code&gt;instanceTypes&lt;/code&gt;. For more information, see &lt;a href&#x3D;\&quot;https://docs.aws.amazon.com/eks/latest/userguide/managed-node-groups.html#managed-node-group-capacity-types\&quot;&gt;Managed node group capacity types&lt;/a&gt; and &lt;a href&#x3D;\&quot;https://docs.aws.amazon.com/eks/latest/userguide/launch-templates.html\&quot;&gt;Launch template support&lt;/a&gt; in the &lt;i&gt;Amazon EKS User Guide&lt;/i&gt;.
   * @return instanceTypes
   */
  @javax.annotation.Nullable
  public List<String> getInstanceTypes() {
    return instanceTypes;
  }

  public void setInstanceTypes(List<String> instanceTypes) {
    this.instanceTypes = instanceTypes;
  }


  public CreateNodegroupRequest amiType(AmiTypeEnum amiType) {
    this.amiType = amiType;
    return this;
  }

  /**
   * The AMI type for your node group. If you specify &lt;code&gt;launchTemplate&lt;/code&gt;, and your launch template uses a custom AMI, then don&#39;t specify &lt;code&gt;amiType&lt;/code&gt;, or the node group deployment will fail. If your launch template uses a Windows custom AMI, then add &lt;code&gt;eks:kube-proxy-windows&lt;/code&gt; to your Windows nodes &lt;code&gt;rolearn&lt;/code&gt; in the &lt;code&gt;aws-auth&lt;/code&gt; &lt;code&gt;ConfigMap&lt;/code&gt;. For more information about using launch templates with Amazon EKS, see &lt;a href&#x3D;\&quot;https://docs.aws.amazon.com/eks/latest/userguide/launch-templates.html\&quot;&gt;Launch template support&lt;/a&gt; in the &lt;i&gt;Amazon EKS User Guide&lt;/i&gt;.
   * @return amiType
   */
  @javax.annotation.Nullable
  public AmiTypeEnum getAmiType() {
    return amiType;
  }

  public void setAmiType(AmiTypeEnum amiType) {
    this.amiType = amiType;
  }


  public CreateNodegroupRequest remoteAccess(CreateNodegroupRequestRemoteAccess remoteAccess) {
    this.remoteAccess = remoteAccess;
    return this;
  }

  /**
   * Get remoteAccess
   * @return remoteAccess
   */
  @javax.annotation.Nullable
  public CreateNodegroupRequestRemoteAccess getRemoteAccess() {
    return remoteAccess;
  }

  public void setRemoteAccess(CreateNodegroupRequestRemoteAccess remoteAccess) {
    this.remoteAccess = remoteAccess;
  }


  public CreateNodegroupRequest nodeRole(String nodeRole) {
    this.nodeRole = nodeRole;
    return this;
  }

  /**
   * The Amazon Resource Name (ARN) of the IAM role to associate with your node group. The Amazon EKS worker node &lt;code&gt;kubelet&lt;/code&gt; daemon makes calls to Amazon Web Services APIs on your behalf. Nodes receive permissions for these API calls through an IAM instance profile and associated policies. Before you can launch nodes and register them into a cluster, you must create an IAM role for those nodes to use when they are launched. For more information, see &lt;a href&#x3D;\&quot;https://docs.aws.amazon.com/eks/latest/userguide/create-node-role.html\&quot;&gt;Amazon EKS node IAM role&lt;/a&gt; in the &lt;i&gt; &lt;i&gt;Amazon EKS User Guide&lt;/i&gt; &lt;/i&gt;. If you specify &lt;code&gt;launchTemplate&lt;/code&gt;, then don&#39;t specify &lt;a href&#x3D;\&quot;https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_IamInstanceProfile.html\&quot;&gt; &lt;code&gt;IamInstanceProfile&lt;/code&gt; &lt;/a&gt; in your launch template, or the node group deployment will fail. For more information about using launch templates with Amazon EKS, see &lt;a href&#x3D;\&quot;https://docs.aws.amazon.com/eks/latest/userguide/launch-templates.html\&quot;&gt;Launch template support&lt;/a&gt; in the &lt;i&gt;Amazon EKS User Guide&lt;/i&gt;.
   * @return nodeRole
   */
  @javax.annotation.Nonnull
  public String getNodeRole() {
    return nodeRole;
  }

  public void setNodeRole(String nodeRole) {
    this.nodeRole = nodeRole;
  }


  public CreateNodegroupRequest labels(Map<String, String> labels) {
    this.labels = labels;
    return this;
  }

  public CreateNodegroupRequest putLabelsItem(String key, String labelsItem) {
    if (this.labels == null) {
      this.labels = new HashMap<>();
    }
    this.labels.put(key, labelsItem);
    return this;
  }

  /**
   * The Kubernetes labels to be applied to the nodes in the node group when they are created.
   * @return labels
   */
  @javax.annotation.Nullable
  public Map<String, String> getLabels() {
    return labels;
  }

  public void setLabels(Map<String, String> labels) {
    this.labels = labels;
  }


  public CreateNodegroupRequest taints(List<Taint> taints) {
    this.taints = taints;
    return this;
  }

  public CreateNodegroupRequest addTaintsItem(Taint taintsItem) {
    if (this.taints == null) {
      this.taints = new ArrayList<>();
    }
    this.taints.add(taintsItem);
    return this;
  }

  /**
   * The Kubernetes taints to be applied to the nodes in the node group. For more information, see &lt;a href&#x3D;\&quot;https://docs.aws.amazon.com/eks/latest/userguide/node-taints-managed-node-groups.html\&quot;&gt;Node taints on managed node groups&lt;/a&gt;.
   * @return taints
   */
  @javax.annotation.Nullable
  public List<Taint> getTaints() {
    return taints;
  }

  public void setTaints(List<Taint> taints) {
    this.taints = taints;
  }


  public CreateNodegroupRequest tags(Map<String, String> tags) {
    this.tags = tags;
    return this;
  }

  public CreateNodegroupRequest putTagsItem(String key, String tagsItem) {
    if (this.tags == null) {
      this.tags = new HashMap<>();
    }
    this.tags.put(key, tagsItem);
    return this;
  }

  /**
   * The metadata to apply to the node group to assist with categorization and organization. Each tag consists of a key and an optional value. You define both. Node group tags do not propagate to any other resources associated with the node group, such as the Amazon EC2 instances or subnets.
   * @return tags
   */
  @javax.annotation.Nullable
  public Map<String, String> getTags() {
    return tags;
  }

  public void setTags(Map<String, String> tags) {
    this.tags = tags;
  }


  public CreateNodegroupRequest clientRequestToken(String clientRequestToken) {
    this.clientRequestToken = clientRequestToken;
    return this;
  }

  /**
   * Unique, case-sensitive identifier that you provide to ensure the idempotency of the request.
   * @return clientRequestToken
   */
  @javax.annotation.Nullable
  public String getClientRequestToken() {
    return clientRequestToken;
  }

  public void setClientRequestToken(String clientRequestToken) {
    this.clientRequestToken = clientRequestToken;
  }


  public CreateNodegroupRequest launchTemplate(CreateNodegroupRequestLaunchTemplate launchTemplate) {
    this.launchTemplate = launchTemplate;
    return this;
  }

  /**
   * Get launchTemplate
   * @return launchTemplate
   */
  @javax.annotation.Nullable
  public CreateNodegroupRequestLaunchTemplate getLaunchTemplate() {
    return launchTemplate;
  }

  public void setLaunchTemplate(CreateNodegroupRequestLaunchTemplate launchTemplate) {
    this.launchTemplate = launchTemplate;
  }


  public CreateNodegroupRequest updateConfig(CreateNodegroupRequestUpdateConfig updateConfig) {
    this.updateConfig = updateConfig;
    return this;
  }

  /**
   * Get updateConfig
   * @return updateConfig
   */
  @javax.annotation.Nullable
  public CreateNodegroupRequestUpdateConfig getUpdateConfig() {
    return updateConfig;
  }

  public void setUpdateConfig(CreateNodegroupRequestUpdateConfig updateConfig) {
    this.updateConfig = updateConfig;
  }


  public CreateNodegroupRequest capacityType(CapacityTypeEnum capacityType) {
    this.capacityType = capacityType;
    return this;
  }

  /**
   * The capacity type for your node group.
   * @return capacityType
   */
  @javax.annotation.Nullable
  public CapacityTypeEnum getCapacityType() {
    return capacityType;
  }

  public void setCapacityType(CapacityTypeEnum capacityType) {
    this.capacityType = capacityType;
  }


  public CreateNodegroupRequest version(String version) {
    this.version = version;
    return this;
  }

  /**
   * The Kubernetes version to use for your managed nodes. By default, the Kubernetes version of the cluster is used, and this is the only accepted specified value. If you specify &lt;code&gt;launchTemplate&lt;/code&gt;, and your launch template uses a custom AMI, then don&#39;t specify &lt;code&gt;version&lt;/code&gt;, or the node group deployment will fail. For more information about using launch templates with Amazon EKS, see &lt;a href&#x3D;\&quot;https://docs.aws.amazon.com/eks/latest/userguide/launch-templates.html\&quot;&gt;Launch template support&lt;/a&gt; in the &lt;i&gt;Amazon EKS User Guide&lt;/i&gt;.
   * @return version
   */
  @javax.annotation.Nullable
  public String getVersion() {
    return version;
  }

  public void setVersion(String version) {
    this.version = version;
  }


  public CreateNodegroupRequest releaseVersion(String releaseVersion) {
    this.releaseVersion = releaseVersion;
    return this;
  }

  /**
   * &lt;p&gt;The AMI version of the Amazon EKS optimized AMI to use with your node group. By default, the latest available AMI version for the node group&#39;s current Kubernetes version is used. For information about Linux versions, see &lt;a href&#x3D;\&quot;https://docs.aws.amazon.com/eks/latest/userguide/eks-linux-ami-versions.html\&quot;&gt;Amazon EKS optimized Amazon Linux AMI versions&lt;/a&gt; in the &lt;i&gt;Amazon EKS User Guide&lt;/i&gt;. Amazon EKS managed node groups support the November 2022 and later releases of the Windows AMIs. For information about Windows versions, see &lt;a href&#x3D;\&quot;https://docs.aws.amazon.com/eks/latest/userguide/eks-ami-versions-windows.html\&quot;&gt;Amazon EKS optimized Windows AMI versions&lt;/a&gt; in the &lt;i&gt;Amazon EKS User Guide&lt;/i&gt;.&lt;/p&gt; &lt;p&gt;If you specify &lt;code&gt;launchTemplate&lt;/code&gt;, and your launch template uses a custom AMI, then don&#39;t specify &lt;code&gt;releaseVersion&lt;/code&gt;, or the node group deployment will fail. For more information about using launch templates with Amazon EKS, see &lt;a href&#x3D;\&quot;https://docs.aws.amazon.com/eks/latest/userguide/launch-templates.html\&quot;&gt;Launch template support&lt;/a&gt; in the &lt;i&gt;Amazon EKS User Guide&lt;/i&gt;.&lt;/p&gt;
   * @return releaseVersion
   */
  @javax.annotation.Nullable
  public String getReleaseVersion() {
    return releaseVersion;
  }

  public void setReleaseVersion(String releaseVersion) {
    this.releaseVersion = releaseVersion;
  }



  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    CreateNodegroupRequest createNodegroupRequest = (CreateNodegroupRequest) o;
    return Objects.equals(this.nodegroupName, createNodegroupRequest.nodegroupName) &&
        Objects.equals(this.scalingConfig, createNodegroupRequest.scalingConfig) &&
        Objects.equals(this.diskSize, createNodegroupRequest.diskSize) &&
        Objects.equals(this.subnets, createNodegroupRequest.subnets) &&
        Objects.equals(this.instanceTypes, createNodegroupRequest.instanceTypes) &&
        Objects.equals(this.amiType, createNodegroupRequest.amiType) &&
        Objects.equals(this.remoteAccess, createNodegroupRequest.remoteAccess) &&
        Objects.equals(this.nodeRole, createNodegroupRequest.nodeRole) &&
        Objects.equals(this.labels, createNodegroupRequest.labels) &&
        Objects.equals(this.taints, createNodegroupRequest.taints) &&
        Objects.equals(this.tags, createNodegroupRequest.tags) &&
        Objects.equals(this.clientRequestToken, createNodegroupRequest.clientRequestToken) &&
        Objects.equals(this.launchTemplate, createNodegroupRequest.launchTemplate) &&
        Objects.equals(this.updateConfig, createNodegroupRequest.updateConfig) &&
        Objects.equals(this.capacityType, createNodegroupRequest.capacityType) &&
        Objects.equals(this.version, createNodegroupRequest.version) &&
        Objects.equals(this.releaseVersion, createNodegroupRequest.releaseVersion);
  }

  @Override
  public int hashCode() {
    return Objects.hash(nodegroupName, scalingConfig, diskSize, subnets, instanceTypes, amiType, remoteAccess, nodeRole, labels, taints, tags, clientRequestToken, launchTemplate, updateConfig, capacityType, version, releaseVersion);
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class CreateNodegroupRequest {\n");
    sb.append("    nodegroupName: ").append(toIndentedString(nodegroupName)).append("\n");
    sb.append("    scalingConfig: ").append(toIndentedString(scalingConfig)).append("\n");
    sb.append("    diskSize: ").append(toIndentedString(diskSize)).append("\n");
    sb.append("    subnets: ").append(toIndentedString(subnets)).append("\n");
    sb.append("    instanceTypes: ").append(toIndentedString(instanceTypes)).append("\n");
    sb.append("    amiType: ").append(toIndentedString(amiType)).append("\n");
    sb.append("    remoteAccess: ").append(toIndentedString(remoteAccess)).append("\n");
    sb.append("    nodeRole: ").append(toIndentedString(nodeRole)).append("\n");
    sb.append("    labels: ").append(toIndentedString(labels)).append("\n");
    sb.append("    taints: ").append(toIndentedString(taints)).append("\n");
    sb.append("    tags: ").append(toIndentedString(tags)).append("\n");
    sb.append("    clientRequestToken: ").append(toIndentedString(clientRequestToken)).append("\n");
    sb.append("    launchTemplate: ").append(toIndentedString(launchTemplate)).append("\n");
    sb.append("    updateConfig: ").append(toIndentedString(updateConfig)).append("\n");
    sb.append("    capacityType: ").append(toIndentedString(capacityType)).append("\n");
    sb.append("    version: ").append(toIndentedString(version)).append("\n");
    sb.append("    releaseVersion: ").append(toIndentedString(releaseVersion)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }


  public static HashSet<String> openapiFields;
  public static HashSet<String> openapiRequiredFields;

  static {
    // a set of all properties/fields (JSON key names)
    openapiFields = new HashSet<String>();
    openapiFields.add("nodegroupName");
    openapiFields.add("scalingConfig");
    openapiFields.add("diskSize");
    openapiFields.add("subnets");
    openapiFields.add("instanceTypes");
    openapiFields.add("amiType");
    openapiFields.add("remoteAccess");
    openapiFields.add("nodeRole");
    openapiFields.add("labels");
    openapiFields.add("taints");
    openapiFields.add("tags");
    openapiFields.add("clientRequestToken");
    openapiFields.add("launchTemplate");
    openapiFields.add("updateConfig");
    openapiFields.add("capacityType");
    openapiFields.add("version");
    openapiFields.add("releaseVersion");

    // a set of required properties/fields (JSON key names)
    openapiRequiredFields = new HashSet<String>();
    openapiRequiredFields.add("nodegroupName");
    openapiRequiredFields.add("subnets");
    openapiRequiredFields.add("nodeRole");
  }

  /**
   * Validates the JSON Element and throws an exception if issues found
   *
   * @param jsonElement JSON Element
   * @throws IOException if the JSON Element is invalid with respect to CreateNodegroupRequest
   */
  public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      if (jsonElement == null) {
        if (!CreateNodegroupRequest.openapiRequiredFields.isEmpty()) { // has required fields but JSON element is null
          throw new IllegalArgumentException(String.format("The required field(s) %s in CreateNodegroupRequest is not found in the empty JSON string", CreateNodegroupRequest.openapiRequiredFields.toString()));
        }
      }

      Set<Map.Entry<String, JsonElement>> entries = jsonElement.getAsJsonObject().entrySet();
      // check to see if the JSON string contains additional fields
      for (Map.Entry<String, JsonElement> entry : entries) {
        if (!CreateNodegroupRequest.openapiFields.contains(entry.getKey())) {
          throw new IllegalArgumentException(String.format("The field `%s` in the JSON string is not defined in the `CreateNodegroupRequest` properties. JSON: %s", entry.getKey(), jsonElement.toString()));
        }
      }

      // check to make sure all required properties/fields are present in the JSON string
      for (String requiredField : CreateNodegroupRequest.openapiRequiredFields) {
        if (jsonElement.getAsJsonObject().get(requiredField) == null) {
          throw new IllegalArgumentException(String.format("The required field `%s` is not found in the JSON string: %s", requiredField, jsonElement.toString()));
        }
      }
        JsonObject jsonObj = jsonElement.getAsJsonObject();
      if (!jsonObj.get("nodegroupName").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `nodegroupName` to be a primitive type in the JSON string but got `%s`", jsonObj.get("nodegroupName").toString()));
      }
      // validate the optional field `scalingConfig`
      if (jsonObj.get("scalingConfig") != null && !jsonObj.get("scalingConfig").isJsonNull()) {
        CreateNodegroupRequestScalingConfig.validateJsonElement(jsonObj.get("scalingConfig"));
      }
      // ensure the required json array is present
      if (jsonObj.get("subnets") == null) {
        throw new IllegalArgumentException("Expected the field `linkedContent` to be an array in the JSON string but got `null`");
      } else if (!jsonObj.get("subnets").isJsonArray()) {
        throw new IllegalArgumentException(String.format("Expected the field `subnets` to be an array in the JSON string but got `%s`", jsonObj.get("subnets").toString()));
      }
      // ensure the optional json data is an array if present
      if (jsonObj.get("instanceTypes") != null && !jsonObj.get("instanceTypes").isJsonNull() && !jsonObj.get("instanceTypes").isJsonArray()) {
        throw new IllegalArgumentException(String.format("Expected the field `instanceTypes` to be an array in the JSON string but got `%s`", jsonObj.get("instanceTypes").toString()));
      }
      if ((jsonObj.get("amiType") != null && !jsonObj.get("amiType").isJsonNull()) && !jsonObj.get("amiType").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `amiType` to be a primitive type in the JSON string but got `%s`", jsonObj.get("amiType").toString()));
      }
      // validate the optional field `amiType`
      if (jsonObj.get("amiType") != null && !jsonObj.get("amiType").isJsonNull()) {
        AmiTypeEnum.validateJsonElement(jsonObj.get("amiType"));
      }
      // validate the optional field `remoteAccess`
      if (jsonObj.get("remoteAccess") != null && !jsonObj.get("remoteAccess").isJsonNull()) {
        CreateNodegroupRequestRemoteAccess.validateJsonElement(jsonObj.get("remoteAccess"));
      }
      if (!jsonObj.get("nodeRole").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `nodeRole` to be a primitive type in the JSON string but got `%s`", jsonObj.get("nodeRole").toString()));
      }
      if (jsonObj.get("taints") != null && !jsonObj.get("taints").isJsonNull()) {
        JsonArray jsonArraytaints = jsonObj.getAsJsonArray("taints");
        if (jsonArraytaints != null) {
          // ensure the json data is an array
          if (!jsonObj.get("taints").isJsonArray()) {
            throw new IllegalArgumentException(String.format("Expected the field `taints` to be an array in the JSON string but got `%s`", jsonObj.get("taints").toString()));
          }

          // validate the optional field `taints` (array)
          for (int i = 0; i < jsonArraytaints.size(); i++) {
            Taint.validateJsonElement(jsonArraytaints.get(i));
          };
        }
      }
      if ((jsonObj.get("clientRequestToken") != null && !jsonObj.get("clientRequestToken").isJsonNull()) && !jsonObj.get("clientRequestToken").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `clientRequestToken` to be a primitive type in the JSON string but got `%s`", jsonObj.get("clientRequestToken").toString()));
      }
      // validate the optional field `launchTemplate`
      if (jsonObj.get("launchTemplate") != null && !jsonObj.get("launchTemplate").isJsonNull()) {
        CreateNodegroupRequestLaunchTemplate.validateJsonElement(jsonObj.get("launchTemplate"));
      }
      // validate the optional field `updateConfig`
      if (jsonObj.get("updateConfig") != null && !jsonObj.get("updateConfig").isJsonNull()) {
        CreateNodegroupRequestUpdateConfig.validateJsonElement(jsonObj.get("updateConfig"));
      }
      if ((jsonObj.get("capacityType") != null && !jsonObj.get("capacityType").isJsonNull()) && !jsonObj.get("capacityType").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `capacityType` to be a primitive type in the JSON string but got `%s`", jsonObj.get("capacityType").toString()));
      }
      // validate the optional field `capacityType`
      if (jsonObj.get("capacityType") != null && !jsonObj.get("capacityType").isJsonNull()) {
        CapacityTypeEnum.validateJsonElement(jsonObj.get("capacityType"));
      }
      if ((jsonObj.get("version") != null && !jsonObj.get("version").isJsonNull()) && !jsonObj.get("version").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `version` to be a primitive type in the JSON string but got `%s`", jsonObj.get("version").toString()));
      }
      if ((jsonObj.get("releaseVersion") != null && !jsonObj.get("releaseVersion").isJsonNull()) && !jsonObj.get("releaseVersion").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `releaseVersion` to be a primitive type in the JSON string but got `%s`", jsonObj.get("releaseVersion").toString()));
      }
  }

  public static class CustomTypeAdapterFactory implements TypeAdapterFactory {
    @SuppressWarnings("unchecked")
    @Override
    public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
       if (!CreateNodegroupRequest.class.isAssignableFrom(type.getRawType())) {
         return null; // this class only serializes 'CreateNodegroupRequest' and its subtypes
       }
       final TypeAdapter<JsonElement> elementAdapter = gson.getAdapter(JsonElement.class);
       final TypeAdapter<CreateNodegroupRequest> thisAdapter
                        = gson.getDelegateAdapter(this, TypeToken.get(CreateNodegroupRequest.class));

       return (TypeAdapter<T>) new TypeAdapter<CreateNodegroupRequest>() {
           @Override
           public void write(JsonWriter out, CreateNodegroupRequest value) throws IOException {
             JsonObject obj = thisAdapter.toJsonTree(value).getAsJsonObject();
             elementAdapter.write(out, obj);
           }

           @Override
           public CreateNodegroupRequest read(JsonReader in) throws IOException {
             JsonElement jsonElement = elementAdapter.read(in);
             validateJsonElement(jsonElement);
             return thisAdapter.fromJsonTree(jsonElement);
           }

       }.nullSafe();
    }
  }

  /**
   * Create an instance of CreateNodegroupRequest given an JSON string
   *
   * @param jsonString JSON string
   * @return An instance of CreateNodegroupRequest
   * @throws IOException if the JSON string is invalid with respect to CreateNodegroupRequest
   */
  public static CreateNodegroupRequest fromJson(String jsonString) throws IOException {
    return JSON.getGson().fromJson(jsonString, CreateNodegroupRequest.class);
  }

  /**
   * Convert an instance of CreateNodegroupRequest to an JSON string
   *
   * @return JSON string
   */
  public String toJson() {
    return JSON.getGson().toJson(this);
  }
}

