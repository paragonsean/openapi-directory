/**
 * AWS IoT Greengrass V2
 * <p>IoT Greengrass brings local compute, messaging, data management, sync, and ML inference capabilities to edge devices. This enables devices to collect and analyze data closer to the source of information, react autonomously to local events, and communicate securely with each other on local networks. Local devices can also communicate securely with Amazon Web Services IoT Core and export IoT data to the Amazon Web Services Cloud. IoT Greengrass developers can use Lambda functions and components to create and deploy applications to fleets of edge devices for local operation.</p> <p>IoT Greengrass Version 2 provides a new major version of the IoT Greengrass Core software, new APIs, and a new console. Use this API reference to learn how to use the IoT Greengrass V2 API operations to manage components, manage deployments, and core devices.</p> <p>For more information, see <a href=\"https://docs.aws.amazon.com/greengrass/v2/developerguide/what-is-iot-greengrass.html\">What is IoT Greengrass?</a> in the <i>IoT Greengrass V2 Developer Guide</i>.</p>
 *
 * The version of the OpenAPI document: 2020-11-30
 * Contact: mike.ralphson@gmail.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

#include "OAILambdaExecutionParameters.h"

#include <QDebug>
#include <QJsonArray>
#include <QJsonDocument>
#include <QObject>

#include "OAIHelpers.h"

namespace OpenAPI {

OAILambdaExecutionParameters::OAILambdaExecutionParameters(QString json) {
    this->initializeModel();
    this->fromJson(json);
}

OAILambdaExecutionParameters::OAILambdaExecutionParameters() {
    this->initializeModel();
}

OAILambdaExecutionParameters::~OAILambdaExecutionParameters() {}

void OAILambdaExecutionParameters::initializeModel() {

    m_event_sources_isSet = false;
    m_event_sources_isValid = false;

    m_max_queue_size_isSet = false;
    m_max_queue_size_isValid = false;

    m_max_instances_count_isSet = false;
    m_max_instances_count_isValid = false;

    m_max_idle_time_in_seconds_isSet = false;
    m_max_idle_time_in_seconds_isValid = false;

    m_timeout_in_seconds_isSet = false;
    m_timeout_in_seconds_isValid = false;

    m_status_timeout_in_seconds_isSet = false;
    m_status_timeout_in_seconds_isValid = false;

    m_pinned_isSet = false;
    m_pinned_isValid = false;

    m_input_payload_encoding_type_isSet = false;
    m_input_payload_encoding_type_isValid = false;

    m_exec_args_isSet = false;
    m_exec_args_isValid = false;

    m_environment_variables_isSet = false;
    m_environment_variables_isValid = false;

    m_linux_process_params_isSet = false;
    m_linux_process_params_isValid = false;
}

void OAILambdaExecutionParameters::fromJson(QString jsonString) {
    QByteArray array(jsonString.toStdString().c_str());
    QJsonDocument doc = QJsonDocument::fromJson(array);
    QJsonObject jsonObject = doc.object();
    this->fromJsonObject(jsonObject);
}

void OAILambdaExecutionParameters::fromJsonObject(QJsonObject json) {

    m_event_sources_isValid = ::OpenAPI::fromJsonValue(m_event_sources, json[QString("eventSources")]);
    m_event_sources_isSet = !json[QString("eventSources")].isNull() && m_event_sources_isValid;

    m_max_queue_size_isValid = ::OpenAPI::fromJsonValue(m_max_queue_size, json[QString("maxQueueSize")]);
    m_max_queue_size_isSet = !json[QString("maxQueueSize")].isNull() && m_max_queue_size_isValid;

    m_max_instances_count_isValid = ::OpenAPI::fromJsonValue(m_max_instances_count, json[QString("maxInstancesCount")]);
    m_max_instances_count_isSet = !json[QString("maxInstancesCount")].isNull() && m_max_instances_count_isValid;

    m_max_idle_time_in_seconds_isValid = ::OpenAPI::fromJsonValue(m_max_idle_time_in_seconds, json[QString("maxIdleTimeInSeconds")]);
    m_max_idle_time_in_seconds_isSet = !json[QString("maxIdleTimeInSeconds")].isNull() && m_max_idle_time_in_seconds_isValid;

    m_timeout_in_seconds_isValid = ::OpenAPI::fromJsonValue(m_timeout_in_seconds, json[QString("timeoutInSeconds")]);
    m_timeout_in_seconds_isSet = !json[QString("timeoutInSeconds")].isNull() && m_timeout_in_seconds_isValid;

    m_status_timeout_in_seconds_isValid = ::OpenAPI::fromJsonValue(m_status_timeout_in_seconds, json[QString("statusTimeoutInSeconds")]);
    m_status_timeout_in_seconds_isSet = !json[QString("statusTimeoutInSeconds")].isNull() && m_status_timeout_in_seconds_isValid;

    m_pinned_isValid = ::OpenAPI::fromJsonValue(m_pinned, json[QString("pinned")]);
    m_pinned_isSet = !json[QString("pinned")].isNull() && m_pinned_isValid;

    m_input_payload_encoding_type_isValid = ::OpenAPI::fromJsonValue(m_input_payload_encoding_type, json[QString("inputPayloadEncodingType")]);
    m_input_payload_encoding_type_isSet = !json[QString("inputPayloadEncodingType")].isNull() && m_input_payload_encoding_type_isValid;

    m_exec_args_isValid = ::OpenAPI::fromJsonValue(m_exec_args, json[QString("execArgs")]);
    m_exec_args_isSet = !json[QString("execArgs")].isNull() && m_exec_args_isValid;

    m_environment_variables_isValid = ::OpenAPI::fromJsonValue(m_environment_variables, json[QString("environmentVariables")]);
    m_environment_variables_isSet = !json[QString("environmentVariables")].isNull() && m_environment_variables_isValid;

    m_linux_process_params_isValid = ::OpenAPI::fromJsonValue(m_linux_process_params, json[QString("linuxProcessParams")]);
    m_linux_process_params_isSet = !json[QString("linuxProcessParams")].isNull() && m_linux_process_params_isValid;
}

QString OAILambdaExecutionParameters::asJson() const {
    QJsonObject obj = this->asJsonObject();
    QJsonDocument doc(obj);
    QByteArray bytes = doc.toJson();
    return QString(bytes);
}

QJsonObject OAILambdaExecutionParameters::asJsonObject() const {
    QJsonObject obj;
    if (m_event_sources.isSet()) {
        obj.insert(QString("eventSources"), ::OpenAPI::toJsonValue(m_event_sources));
    }
    if (m_max_queue_size_isSet) {
        obj.insert(QString("maxQueueSize"), ::OpenAPI::toJsonValue(m_max_queue_size));
    }
    if (m_max_instances_count_isSet) {
        obj.insert(QString("maxInstancesCount"), ::OpenAPI::toJsonValue(m_max_instances_count));
    }
    if (m_max_idle_time_in_seconds_isSet) {
        obj.insert(QString("maxIdleTimeInSeconds"), ::OpenAPI::toJsonValue(m_max_idle_time_in_seconds));
    }
    if (m_timeout_in_seconds_isSet) {
        obj.insert(QString("timeoutInSeconds"), ::OpenAPI::toJsonValue(m_timeout_in_seconds));
    }
    if (m_status_timeout_in_seconds_isSet) {
        obj.insert(QString("statusTimeoutInSeconds"), ::OpenAPI::toJsonValue(m_status_timeout_in_seconds));
    }
    if (m_pinned_isSet) {
        obj.insert(QString("pinned"), ::OpenAPI::toJsonValue(m_pinned));
    }
    if (m_input_payload_encoding_type.isSet()) {
        obj.insert(QString("inputPayloadEncodingType"), ::OpenAPI::toJsonValue(m_input_payload_encoding_type));
    }
    if (m_exec_args.isSet()) {
        obj.insert(QString("execArgs"), ::OpenAPI::toJsonValue(m_exec_args));
    }
    if (m_environment_variables.isSet()) {
        obj.insert(QString("environmentVariables"), ::OpenAPI::toJsonValue(m_environment_variables));
    }
    if (m_linux_process_params.isSet()) {
        obj.insert(QString("linuxProcessParams"), ::OpenAPI::toJsonValue(m_linux_process_params));
    }
    return obj;
}

QList OAILambdaExecutionParameters::getEventSources() const {
    return m_event_sources;
}
void OAILambdaExecutionParameters::setEventSources(const QList &event_sources) {
    m_event_sources = event_sources;
    m_event_sources_isSet = true;
}

bool OAILambdaExecutionParameters::is_event_sources_Set() const{
    return m_event_sources_isSet;
}

bool OAILambdaExecutionParameters::is_event_sources_Valid() const{
    return m_event_sources_isValid;
}

qint32 OAILambdaExecutionParameters::getMaxQueueSize() const {
    return m_max_queue_size;
}
void OAILambdaExecutionParameters::setMaxQueueSize(const qint32 &max_queue_size) {
    m_max_queue_size = max_queue_size;
    m_max_queue_size_isSet = true;
}

bool OAILambdaExecutionParameters::is_max_queue_size_Set() const{
    return m_max_queue_size_isSet;
}

bool OAILambdaExecutionParameters::is_max_queue_size_Valid() const{
    return m_max_queue_size_isValid;
}

qint32 OAILambdaExecutionParameters::getMaxInstancesCount() const {
    return m_max_instances_count;
}
void OAILambdaExecutionParameters::setMaxInstancesCount(const qint32 &max_instances_count) {
    m_max_instances_count = max_instances_count;
    m_max_instances_count_isSet = true;
}

bool OAILambdaExecutionParameters::is_max_instances_count_Set() const{
    return m_max_instances_count_isSet;
}

bool OAILambdaExecutionParameters::is_max_instances_count_Valid() const{
    return m_max_instances_count_isValid;
}

qint32 OAILambdaExecutionParameters::getMaxIdleTimeInSeconds() const {
    return m_max_idle_time_in_seconds;
}
void OAILambdaExecutionParameters::setMaxIdleTimeInSeconds(const qint32 &max_idle_time_in_seconds) {
    m_max_idle_time_in_seconds = max_idle_time_in_seconds;
    m_max_idle_time_in_seconds_isSet = true;
}

bool OAILambdaExecutionParameters::is_max_idle_time_in_seconds_Set() const{
    return m_max_idle_time_in_seconds_isSet;
}

bool OAILambdaExecutionParameters::is_max_idle_time_in_seconds_Valid() const{
    return m_max_idle_time_in_seconds_isValid;
}

qint32 OAILambdaExecutionParameters::getTimeoutInSeconds() const {
    return m_timeout_in_seconds;
}
void OAILambdaExecutionParameters::setTimeoutInSeconds(const qint32 &timeout_in_seconds) {
    m_timeout_in_seconds = timeout_in_seconds;
    m_timeout_in_seconds_isSet = true;
}

bool OAILambdaExecutionParameters::is_timeout_in_seconds_Set() const{
    return m_timeout_in_seconds_isSet;
}

bool OAILambdaExecutionParameters::is_timeout_in_seconds_Valid() const{
    return m_timeout_in_seconds_isValid;
}

qint32 OAILambdaExecutionParameters::getStatusTimeoutInSeconds() const {
    return m_status_timeout_in_seconds;
}
void OAILambdaExecutionParameters::setStatusTimeoutInSeconds(const qint32 &status_timeout_in_seconds) {
    m_status_timeout_in_seconds = status_timeout_in_seconds;
    m_status_timeout_in_seconds_isSet = true;
}

bool OAILambdaExecutionParameters::is_status_timeout_in_seconds_Set() const{
    return m_status_timeout_in_seconds_isSet;
}

bool OAILambdaExecutionParameters::is_status_timeout_in_seconds_Valid() const{
    return m_status_timeout_in_seconds_isValid;
}

bool OAILambdaExecutionParameters::getPinned() const {
    return m_pinned;
}
void OAILambdaExecutionParameters::setPinned(const bool &pinned) {
    m_pinned = pinned;
    m_pinned_isSet = true;
}

bool OAILambdaExecutionParameters::is_pinned_Set() const{
    return m_pinned_isSet;
}

bool OAILambdaExecutionParameters::is_pinned_Valid() const{
    return m_pinned_isValid;
}

OAILambdaInputPayloadEncodingType OAILambdaExecutionParameters::getInputPayloadEncodingType() const {
    return m_input_payload_encoding_type;
}
void OAILambdaExecutionParameters::setInputPayloadEncodingType(const OAILambdaInputPayloadEncodingType &input_payload_encoding_type) {
    m_input_payload_encoding_type = input_payload_encoding_type;
    m_input_payload_encoding_type_isSet = true;
}

bool OAILambdaExecutionParameters::is_input_payload_encoding_type_Set() const{
    return m_input_payload_encoding_type_isSet;
}

bool OAILambdaExecutionParameters::is_input_payload_encoding_type_Valid() const{
    return m_input_payload_encoding_type_isValid;
}

QList OAILambdaExecutionParameters::getExecArgs() const {
    return m_exec_args;
}
void OAILambdaExecutionParameters::setExecArgs(const QList &exec_args) {
    m_exec_args = exec_args;
    m_exec_args_isSet = true;
}

bool OAILambdaExecutionParameters::is_exec_args_Set() const{
    return m_exec_args_isSet;
}

bool OAILambdaExecutionParameters::is_exec_args_Valid() const{
    return m_exec_args_isValid;
}

QMap OAILambdaExecutionParameters::getEnvironmentVariables() const {
    return m_environment_variables;
}
void OAILambdaExecutionParameters::setEnvironmentVariables(const QMap &environment_variables) {
    m_environment_variables = environment_variables;
    m_environment_variables_isSet = true;
}

bool OAILambdaExecutionParameters::is_environment_variables_Set() const{
    return m_environment_variables_isSet;
}

bool OAILambdaExecutionParameters::is_environment_variables_Valid() const{
    return m_environment_variables_isValid;
}

OAILambdaExecutionParameters_linuxProcessParams OAILambdaExecutionParameters::getLinuxProcessParams() const {
    return m_linux_process_params;
}
void OAILambdaExecutionParameters::setLinuxProcessParams(const OAILambdaExecutionParameters_linuxProcessParams &linux_process_params) {
    m_linux_process_params = linux_process_params;
    m_linux_process_params_isSet = true;
}

bool OAILambdaExecutionParameters::is_linux_process_params_Set() const{
    return m_linux_process_params_isSet;
}

bool OAILambdaExecutionParameters::is_linux_process_params_Valid() const{
    return m_linux_process_params_isValid;
}

bool OAILambdaExecutionParameters::isSet() const {
    bool isObjectUpdated = false;
    do {
        if (m_event_sources.isSet()) {
            isObjectUpdated = true;
            break;
        }

        if (m_max_queue_size_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_max_instances_count_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_max_idle_time_in_seconds_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_timeout_in_seconds_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_status_timeout_in_seconds_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_pinned_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_input_payload_encoding_type.isSet()) {
            isObjectUpdated = true;
            break;
        }

        if (m_exec_args.isSet()) {
            isObjectUpdated = true;
            break;
        }

        if (m_environment_variables.isSet()) {
            isObjectUpdated = true;
            break;
        }

        if (m_linux_process_params.isSet()) {
            isObjectUpdated = true;
            break;
        }
    } while (false);
    return isObjectUpdated;
}

bool OAILambdaExecutionParameters::isValid() const {
    // only required properties are required for the object to be considered valid
    return true;
}

} // namespace OpenAPI
