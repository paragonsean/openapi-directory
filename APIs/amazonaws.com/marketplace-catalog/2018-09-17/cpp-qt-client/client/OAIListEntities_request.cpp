/**
 * AWS Marketplace Catalog Service
 * <p>Catalog API actions allow you to manage your entities through list, describe, and update capabilities. An entity can be a product or an offer on AWS Marketplace. </p> <p>You can automate your entity update process by integrating the AWS Marketplace Catalog API with your AWS Marketplace product build or deployment pipelines. You can also create your own applications on top of the Catalog API to manage your products on AWS Marketplace.</p>
 *
 * The version of the OpenAPI document: 2018-09-17
 * Contact: mike.ralphson@gmail.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

#include "OAIListEntities_request.h"

#include <QDebug>
#include <QJsonArray>
#include <QJsonDocument>
#include <QObject>

#include "OAIHelpers.h"

namespace OpenAPI {

OAIListEntities_request::OAIListEntities_request(QString json) {
    this->initializeModel();
    this->fromJson(json);
}

OAIListEntities_request::OAIListEntities_request() {
    this->initializeModel();
}

OAIListEntities_request::~OAIListEntities_request() {}

void OAIListEntities_request::initializeModel() {

    m_catalog_isSet = false;
    m_catalog_isValid = false;

    m_entity_type_isSet = false;
    m_entity_type_isValid = false;

    m_filter_list_isSet = false;
    m_filter_list_isValid = false;

    m_sort_isSet = false;
    m_sort_isValid = false;

    m_next_token_isSet = false;
    m_next_token_isValid = false;

    m_max_results_isSet = false;
    m_max_results_isValid = false;

    m_ownership_type_isSet = false;
    m_ownership_type_isValid = false;
}

void OAIListEntities_request::fromJson(QString jsonString) {
    QByteArray array(jsonString.toStdString().c_str());
    QJsonDocument doc = QJsonDocument::fromJson(array);
    QJsonObject jsonObject = doc.object();
    this->fromJsonObject(jsonObject);
}

void OAIListEntities_request::fromJsonObject(QJsonObject json) {

    m_catalog_isValid = ::OpenAPI::fromJsonValue(m_catalog, json[QString("Catalog")]);
    m_catalog_isSet = !json[QString("Catalog")].isNull() && m_catalog_isValid;

    m_entity_type_isValid = ::OpenAPI::fromJsonValue(m_entity_type, json[QString("EntityType")]);
    m_entity_type_isSet = !json[QString("EntityType")].isNull() && m_entity_type_isValid;

    m_filter_list_isValid = ::OpenAPI::fromJsonValue(m_filter_list, json[QString("FilterList")]);
    m_filter_list_isSet = !json[QString("FilterList")].isNull() && m_filter_list_isValid;

    m_sort_isValid = ::OpenAPI::fromJsonValue(m_sort, json[QString("Sort")]);
    m_sort_isSet = !json[QString("Sort")].isNull() && m_sort_isValid;

    m_next_token_isValid = ::OpenAPI::fromJsonValue(m_next_token, json[QString("NextToken")]);
    m_next_token_isSet = !json[QString("NextToken")].isNull() && m_next_token_isValid;

    m_max_results_isValid = ::OpenAPI::fromJsonValue(m_max_results, json[QString("MaxResults")]);
    m_max_results_isSet = !json[QString("MaxResults")].isNull() && m_max_results_isValid;

    m_ownership_type_isValid = ::OpenAPI::fromJsonValue(m_ownership_type, json[QString("OwnershipType")]);
    m_ownership_type_isSet = !json[QString("OwnershipType")].isNull() && m_ownership_type_isValid;
}

QString OAIListEntities_request::asJson() const {
    QJsonObject obj = this->asJsonObject();
    QJsonDocument doc(obj);
    QByteArray bytes = doc.toJson();
    return QString(bytes);
}

QJsonObject OAIListEntities_request::asJsonObject() const {
    QJsonObject obj;
    if (m_catalog_isSet) {
        obj.insert(QString("Catalog"), ::OpenAPI::toJsonValue(m_catalog));
    }
    if (m_entity_type_isSet) {
        obj.insert(QString("EntityType"), ::OpenAPI::toJsonValue(m_entity_type));
    }
    if (m_filter_list.size() > 0) {
        obj.insert(QString("FilterList"), ::OpenAPI::toJsonValue(m_filter_list));
    }
    if (m_sort.isSet()) {
        obj.insert(QString("Sort"), ::OpenAPI::toJsonValue(m_sort));
    }
    if (m_next_token_isSet) {
        obj.insert(QString("NextToken"), ::OpenAPI::toJsonValue(m_next_token));
    }
    if (m_max_results_isSet) {
        obj.insert(QString("MaxResults"), ::OpenAPI::toJsonValue(m_max_results));
    }
    if (m_ownership_type_isSet) {
        obj.insert(QString("OwnershipType"), ::OpenAPI::toJsonValue(m_ownership_type));
    }
    return obj;
}

QString OAIListEntities_request::getCatalog() const {
    return m_catalog;
}
void OAIListEntities_request::setCatalog(const QString &catalog) {
    m_catalog = catalog;
    m_catalog_isSet = true;
}

bool OAIListEntities_request::is_catalog_Set() const{
    return m_catalog_isSet;
}

bool OAIListEntities_request::is_catalog_Valid() const{
    return m_catalog_isValid;
}

QString OAIListEntities_request::getEntityType() const {
    return m_entity_type;
}
void OAIListEntities_request::setEntityType(const QString &entity_type) {
    m_entity_type = entity_type;
    m_entity_type_isSet = true;
}

bool OAIListEntities_request::is_entity_type_Set() const{
    return m_entity_type_isSet;
}

bool OAIListEntities_request::is_entity_type_Valid() const{
    return m_entity_type_isValid;
}

QList<OAIFilter> OAIListEntities_request::getFilterList() const {
    return m_filter_list;
}
void OAIListEntities_request::setFilterList(const QList<OAIFilter> &filter_list) {
    m_filter_list = filter_list;
    m_filter_list_isSet = true;
}

bool OAIListEntities_request::is_filter_list_Set() const{
    return m_filter_list_isSet;
}

bool OAIListEntities_request::is_filter_list_Valid() const{
    return m_filter_list_isValid;
}

OAIListChangeSets_request_Sort OAIListEntities_request::getSort() const {
    return m_sort;
}
void OAIListEntities_request::setSort(const OAIListChangeSets_request_Sort &sort) {
    m_sort = sort;
    m_sort_isSet = true;
}

bool OAIListEntities_request::is_sort_Set() const{
    return m_sort_isSet;
}

bool OAIListEntities_request::is_sort_Valid() const{
    return m_sort_isValid;
}

QString OAIListEntities_request::getNextToken() const {
    return m_next_token;
}
void OAIListEntities_request::setNextToken(const QString &next_token) {
    m_next_token = next_token;
    m_next_token_isSet = true;
}

bool OAIListEntities_request::is_next_token_Set() const{
    return m_next_token_isSet;
}

bool OAIListEntities_request::is_next_token_Valid() const{
    return m_next_token_isValid;
}

qint32 OAIListEntities_request::getMaxResults() const {
    return m_max_results;
}
void OAIListEntities_request::setMaxResults(const qint32 &max_results) {
    m_max_results = max_results;
    m_max_results_isSet = true;
}

bool OAIListEntities_request::is_max_results_Set() const{
    return m_max_results_isSet;
}

bool OAIListEntities_request::is_max_results_Valid() const{
    return m_max_results_isValid;
}

QString OAIListEntities_request::getOwnershipType() const {
    return m_ownership_type;
}
void OAIListEntities_request::setOwnershipType(const QString &ownership_type) {
    m_ownership_type = ownership_type;
    m_ownership_type_isSet = true;
}

bool OAIListEntities_request::is_ownership_type_Set() const{
    return m_ownership_type_isSet;
}

bool OAIListEntities_request::is_ownership_type_Valid() const{
    return m_ownership_type_isValid;
}

bool OAIListEntities_request::isSet() const {
    bool isObjectUpdated = false;
    do {
        if (m_catalog_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_entity_type_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_filter_list.size() > 0) {
            isObjectUpdated = true;
            break;
        }

        if (m_sort.isSet()) {
            isObjectUpdated = true;
            break;
        }

        if (m_next_token_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_max_results_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_ownership_type_isSet) {
            isObjectUpdated = true;
            break;
        }
    } while (false);
    return isObjectUpdated;
}

bool OAIListEntities_request::isValid() const {
    // only required properties are required for the object to be considered valid
    return m_catalog_isValid && m_entity_type_isValid && true;
}

} // namespace OpenAPI
