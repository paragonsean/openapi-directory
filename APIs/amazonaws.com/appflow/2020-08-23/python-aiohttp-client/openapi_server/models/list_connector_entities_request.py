# coding: utf-8

from datetime import date, datetime

from typing import List, Dict, Type

from openapi_server.models.base_model import Model
import re
from openapi_server import util


class ListConnectorEntitiesRequest(Model):
    """NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).

    Do not edit the class manually.
    """

    def __init__(self, connector_profile_name: str=None, connector_type: str=None, entities_path: str=None, api_version: str=None, max_results: int=None, next_token: str=None):
        """ListConnectorEntitiesRequest - a model defined in OpenAPI

        :param connector_profile_name: The connector_profile_name of this ListConnectorEntitiesRequest.
        :param connector_type: The connector_type of this ListConnectorEntitiesRequest.
        :param entities_path: The entities_path of this ListConnectorEntitiesRequest.
        :param api_version: The api_version of this ListConnectorEntitiesRequest.
        :param max_results: The max_results of this ListConnectorEntitiesRequest.
        :param next_token: The next_token of this ListConnectorEntitiesRequest.
        """
        self.openapi_types = {
            'connector_profile_name': str,
            'connector_type': str,
            'entities_path': str,
            'api_version': str,
            'max_results': int,
            'next_token': str
        }

        self.attribute_map = {
            'connector_profile_name': 'connectorProfileName',
            'connector_type': 'connectorType',
            'entities_path': 'entitiesPath',
            'api_version': 'apiVersion',
            'max_results': 'maxResults',
            'next_token': 'nextToken'
        }

        self._connector_profile_name = connector_profile_name
        self._connector_type = connector_type
        self._entities_path = entities_path
        self._api_version = api_version
        self._max_results = max_results
        self._next_token = next_token

    @classmethod
    def from_dict(cls, dikt: dict) -> 'ListConnectorEntitiesRequest':
        """Returns the dict as a model

        :param dikt: A dict.
        :return: The ListConnectorEntities_request of this ListConnectorEntitiesRequest.
        """
        return util.deserialize_model(dikt, cls)

    @property
    def connector_profile_name(self):
        """Gets the connector_profile_name of this ListConnectorEntitiesRequest.

         The name of the connector profile. The name is unique for each <code>ConnectorProfile</code> in the Amazon Web Services account, and is used to query the downstream connector. 

        :return: The connector_profile_name of this ListConnectorEntitiesRequest.
        :rtype: str
        """
        return self._connector_profile_name

    @connector_profile_name.setter
    def connector_profile_name(self, connector_profile_name):
        """Sets the connector_profile_name of this ListConnectorEntitiesRequest.

         The name of the connector profile. The name is unique for each <code>ConnectorProfile</code> in the Amazon Web Services account, and is used to query the downstream connector. 

        :param connector_profile_name: The connector_profile_name of this ListConnectorEntitiesRequest.
        :type connector_profile_name: str
        """
        if connector_profile_name is not None and len(connector_profile_name) > 256:
            raise ValueError("Invalid value for `connector_profile_name`, length must be less than or equal to `256`")
        if connector_profile_name is not None and not re.search(r'[\w\/!@#+=.-]+', connector_profile_name):
            raise ValueError("Invalid value for `connector_profile_name`, must be a follow pattern or equal to `/[\w\/!@#+=.-]+/`")

        self._connector_profile_name = connector_profile_name

    @property
    def connector_type(self):
        """Gets the connector_type of this ListConnectorEntitiesRequest.

         The type of connector, such as Salesforce, Amplitude, and so on. 

        :return: The connector_type of this ListConnectorEntitiesRequest.
        :rtype: str
        """
        return self._connector_type

    @connector_type.setter
    def connector_type(self, connector_type):
        """Sets the connector_type of this ListConnectorEntitiesRequest.

         The type of connector, such as Salesforce, Amplitude, and so on. 

        :param connector_type: The connector_type of this ListConnectorEntitiesRequest.
        :type connector_type: str
        """
        allowed_values = ["Salesforce", "Singular", "Slack", "Redshift", "S3", "Marketo", "Googleanalytics", "Zendesk", "Servicenow", "Datadog", "Trendmicro", "Snowflake", "Dynatrace", "Infornexus", "Amplitude", "Veeva", "EventBridge", "LookoutMetrics", "Upsolver", "Honeycode", "CustomerProfiles", "SAPOData", "CustomConnector", "Pardot"]  # noqa: E501
        if connector_type not in allowed_values:
            raise ValueError(
                "Invalid value for `connector_type` ({0}), must be one of {1}"
                .format(connector_type, allowed_values)
            )

        self._connector_type = connector_type

    @property
    def entities_path(self):
        """Gets the entities_path of this ListConnectorEntitiesRequest.

         This optional parameter is specific to connector implementation. Some connectors support multiple levels or categories of entities. You can find out the list of roots for such providers by sending a request without the <code>entitiesPath</code> parameter. If the connector supports entities at different roots, this initial request returns the list of roots. Otherwise, this request returns all entities supported by the provider. 

        :return: The entities_path of this ListConnectorEntitiesRequest.
        :rtype: str
        """
        return self._entities_path

    @entities_path.setter
    def entities_path(self, entities_path):
        """Sets the entities_path of this ListConnectorEntitiesRequest.

         This optional parameter is specific to connector implementation. Some connectors support multiple levels or categories of entities. You can find out the list of roots for such providers by sending a request without the <code>entitiesPath</code> parameter. If the connector supports entities at different roots, this initial request returns the list of roots. Otherwise, this request returns all entities supported by the provider. 

        :param entities_path: The entities_path of this ListConnectorEntitiesRequest.
        :type entities_path: str
        """
        if entities_path is not None and len(entities_path) > 256:
            raise ValueError("Invalid value for `entities_path`, length must be less than or equal to `256`")
        if entities_path is not None and not re.search(r'[\s\w\/!@#+=,.-]*', entities_path):
            raise ValueError("Invalid value for `entities_path`, must be a follow pattern or equal to `/[\s\w\/!@#+=,.-]*/`")

        self._entities_path = entities_path

    @property
    def api_version(self):
        """Gets the api_version of this ListConnectorEntitiesRequest.

        The version of the API that's used by the connector.

        :return: The api_version of this ListConnectorEntitiesRequest.
        :rtype: str
        """
        return self._api_version

    @api_version.setter
    def api_version(self, api_version):
        """Sets the api_version of this ListConnectorEntitiesRequest.

        The version of the API that's used by the connector.

        :param api_version: The api_version of this ListConnectorEntitiesRequest.
        :type api_version: str
        """
        if api_version is not None and len(api_version) > 256:
            raise ValueError("Invalid value for `api_version`, length must be less than or equal to `256`")
        if api_version is not None and not re.search(r'\S+', api_version):
            raise ValueError("Invalid value for `api_version`, must be a follow pattern or equal to `/\S+/`")

        self._api_version = api_version

    @property
    def max_results(self):
        """Gets the max_results of this ListConnectorEntitiesRequest.

        The maximum number of items that the operation returns in the response.

        :return: The max_results of this ListConnectorEntitiesRequest.
        :rtype: int
        """
        return self._max_results

    @max_results.setter
    def max_results(self, max_results):
        """Sets the max_results of this ListConnectorEntitiesRequest.

        The maximum number of items that the operation returns in the response.

        :param max_results: The max_results of this ListConnectorEntitiesRequest.
        :type max_results: int
        """
        if max_results is not None and max_results > 10000:
            raise ValueError("Invalid value for `max_results`, must be a value less than or equal to `10000`")
        if max_results is not None and max_results < 1:
            raise ValueError("Invalid value for `max_results`, must be a value greater than or equal to `1`")

        self._max_results = max_results

    @property
    def next_token(self):
        """Gets the next_token of this ListConnectorEntitiesRequest.

        A token that was provided by your prior <code>ListConnectorEntities</code> operation if the response was too big for the page size. You specify this token to get the next page of results in paginated response.

        :return: The next_token of this ListConnectorEntitiesRequest.
        :rtype: str
        """
        return self._next_token

    @next_token.setter
    def next_token(self, next_token):
        """Sets the next_token of this ListConnectorEntitiesRequest.

        A token that was provided by your prior <code>ListConnectorEntities</code> operation if the response was too big for the page size. You specify this token to get the next page of results in paginated response.

        :param next_token: The next_token of this ListConnectorEntitiesRequest.
        :type next_token: str
        """
        if next_token is not None and len(next_token) > 2048:
            raise ValueError("Invalid value for `next_token`, length must be less than or equal to `2048`")
        if next_token is not None and not re.search(r'\S+', next_token):
            raise ValueError("Invalid value for `next_token`, must be a follow pattern or equal to `/\S+/`")

        self._next_token = next_token
