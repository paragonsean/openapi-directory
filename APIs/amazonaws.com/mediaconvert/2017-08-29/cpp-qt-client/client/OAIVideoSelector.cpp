/**
 * AWS Elemental MediaConvert
 * AWS Elemental MediaConvert
 *
 * The version of the OpenAPI document: 2017-08-29
 * Contact: mike.ralphson@gmail.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

#include "OAIVideoSelector.h"

#include <QDebug>
#include <QJsonArray>
#include <QJsonDocument>
#include <QObject>

#include "OAIHelpers.h"

namespace OpenAPI {

OAIVideoSelector::OAIVideoSelector(QString json) {
    this->initializeModel();
    this->fromJson(json);
}

OAIVideoSelector::OAIVideoSelector() {
    this->initializeModel();
}

OAIVideoSelector::~OAIVideoSelector() {}

void OAIVideoSelector::initializeModel() {

    m_alpha_behavior_isSet = false;
    m_alpha_behavior_isValid = false;

    m_color_space_isSet = false;
    m_color_space_isValid = false;

    m_color_space_usage_isSet = false;
    m_color_space_usage_isValid = false;

    m_embedded_timecode_override_isSet = false;
    m_embedded_timecode_override_isValid = false;

    m_hdr10_metadata_isSet = false;
    m_hdr10_metadata_isValid = false;

    m_pad_video_isSet = false;
    m_pad_video_isValid = false;

    m_pid_isSet = false;
    m_pid_isValid = false;

    m_program_number_isSet = false;
    m_program_number_isValid = false;

    m_rotate_isSet = false;
    m_rotate_isValid = false;

    m_sample_range_isSet = false;
    m_sample_range_isValid = false;
}

void OAIVideoSelector::fromJson(QString jsonString) {
    QByteArray array(jsonString.toStdString().c_str());
    QJsonDocument doc = QJsonDocument::fromJson(array);
    QJsonObject jsonObject = doc.object();
    this->fromJsonObject(jsonObject);
}

void OAIVideoSelector::fromJsonObject(QJsonObject json) {

    m_alpha_behavior_isValid = ::OpenAPI::fromJsonValue(m_alpha_behavior, json[QString("AlphaBehavior")]);
    m_alpha_behavior_isSet = !json[QString("AlphaBehavior")].isNull() && m_alpha_behavior_isValid;

    m_color_space_isValid = ::OpenAPI::fromJsonValue(m_color_space, json[QString("ColorSpace")]);
    m_color_space_isSet = !json[QString("ColorSpace")].isNull() && m_color_space_isValid;

    m_color_space_usage_isValid = ::OpenAPI::fromJsonValue(m_color_space_usage, json[QString("ColorSpaceUsage")]);
    m_color_space_usage_isSet = !json[QString("ColorSpaceUsage")].isNull() && m_color_space_usage_isValid;

    m_embedded_timecode_override_isValid = ::OpenAPI::fromJsonValue(m_embedded_timecode_override, json[QString("EmbeddedTimecodeOverride")]);
    m_embedded_timecode_override_isSet = !json[QString("EmbeddedTimecodeOverride")].isNull() && m_embedded_timecode_override_isValid;

    m_hdr10_metadata_isValid = ::OpenAPI::fromJsonValue(m_hdr10_metadata, json[QString("Hdr10Metadata")]);
    m_hdr10_metadata_isSet = !json[QString("Hdr10Metadata")].isNull() && m_hdr10_metadata_isValid;

    m_pad_video_isValid = ::OpenAPI::fromJsonValue(m_pad_video, json[QString("PadVideo")]);
    m_pad_video_isSet = !json[QString("PadVideo")].isNull() && m_pad_video_isValid;

    m_pid_isValid = ::OpenAPI::fromJsonValue(m_pid, json[QString("Pid")]);
    m_pid_isSet = !json[QString("Pid")].isNull() && m_pid_isValid;

    m_program_number_isValid = ::OpenAPI::fromJsonValue(m_program_number, json[QString("ProgramNumber")]);
    m_program_number_isSet = !json[QString("ProgramNumber")].isNull() && m_program_number_isValid;

    m_rotate_isValid = ::OpenAPI::fromJsonValue(m_rotate, json[QString("Rotate")]);
    m_rotate_isSet = !json[QString("Rotate")].isNull() && m_rotate_isValid;

    m_sample_range_isValid = ::OpenAPI::fromJsonValue(m_sample_range, json[QString("SampleRange")]);
    m_sample_range_isSet = !json[QString("SampleRange")].isNull() && m_sample_range_isValid;
}

QString OAIVideoSelector::asJson() const {
    QJsonObject obj = this->asJsonObject();
    QJsonDocument doc(obj);
    QByteArray bytes = doc.toJson();
    return QString(bytes);
}

QJsonObject OAIVideoSelector::asJsonObject() const {
    QJsonObject obj;
    if (m_alpha_behavior.isSet()) {
        obj.insert(QString("AlphaBehavior"), ::OpenAPI::toJsonValue(m_alpha_behavior));
    }
    if (m_color_space.isSet()) {
        obj.insert(QString("ColorSpace"), ::OpenAPI::toJsonValue(m_color_space));
    }
    if (m_color_space_usage.isSet()) {
        obj.insert(QString("ColorSpaceUsage"), ::OpenAPI::toJsonValue(m_color_space_usage));
    }
    if (m_embedded_timecode_override.isSet()) {
        obj.insert(QString("EmbeddedTimecodeOverride"), ::OpenAPI::toJsonValue(m_embedded_timecode_override));
    }
    if (m_hdr10_metadata.isSet()) {
        obj.insert(QString("Hdr10Metadata"), ::OpenAPI::toJsonValue(m_hdr10_metadata));
    }
    if (m_pad_video.isSet()) {
        obj.insert(QString("PadVideo"), ::OpenAPI::toJsonValue(m_pad_video));
    }
    if (m_pid_isSet) {
        obj.insert(QString("Pid"), ::OpenAPI::toJsonValue(m_pid));
    }
    if (m_program_number_isSet) {
        obj.insert(QString("ProgramNumber"), ::OpenAPI::toJsonValue(m_program_number));
    }
    if (m_rotate.isSet()) {
        obj.insert(QString("Rotate"), ::OpenAPI::toJsonValue(m_rotate));
    }
    if (m_sample_range.isSet()) {
        obj.insert(QString("SampleRange"), ::OpenAPI::toJsonValue(m_sample_range));
    }
    return obj;
}

OAIAlphaBehavior OAIVideoSelector::getAlphaBehavior() const {
    return m_alpha_behavior;
}
void OAIVideoSelector::setAlphaBehavior(const OAIAlphaBehavior &alpha_behavior) {
    m_alpha_behavior = alpha_behavior;
    m_alpha_behavior_isSet = true;
}

bool OAIVideoSelector::is_alpha_behavior_Set() const{
    return m_alpha_behavior_isSet;
}

bool OAIVideoSelector::is_alpha_behavior_Valid() const{
    return m_alpha_behavior_isValid;
}

OAIColorSpace OAIVideoSelector::getColorSpace() const {
    return m_color_space;
}
void OAIVideoSelector::setColorSpace(const OAIColorSpace &color_space) {
    m_color_space = color_space;
    m_color_space_isSet = true;
}

bool OAIVideoSelector::is_color_space_Set() const{
    return m_color_space_isSet;
}

bool OAIVideoSelector::is_color_space_Valid() const{
    return m_color_space_isValid;
}

OAIColorSpaceUsage OAIVideoSelector::getColorSpaceUsage() const {
    return m_color_space_usage;
}
void OAIVideoSelector::setColorSpaceUsage(const OAIColorSpaceUsage &color_space_usage) {
    m_color_space_usage = color_space_usage;
    m_color_space_usage_isSet = true;
}

bool OAIVideoSelector::is_color_space_usage_Set() const{
    return m_color_space_usage_isSet;
}

bool OAIVideoSelector::is_color_space_usage_Valid() const{
    return m_color_space_usage_isValid;
}

OAIEmbeddedTimecodeOverride OAIVideoSelector::getEmbeddedTimecodeOverride() const {
    return m_embedded_timecode_override;
}
void OAIVideoSelector::setEmbeddedTimecodeOverride(const OAIEmbeddedTimecodeOverride &embedded_timecode_override) {
    m_embedded_timecode_override = embedded_timecode_override;
    m_embedded_timecode_override_isSet = true;
}

bool OAIVideoSelector::is_embedded_timecode_override_Set() const{
    return m_embedded_timecode_override_isSet;
}

bool OAIVideoSelector::is_embedded_timecode_override_Valid() const{
    return m_embedded_timecode_override_isValid;
}

OAIVideoSelector_Hdr10Metadata OAIVideoSelector::getHdr10Metadata() const {
    return m_hdr10_metadata;
}
void OAIVideoSelector::setHdr10Metadata(const OAIVideoSelector_Hdr10Metadata &hdr10_metadata) {
    m_hdr10_metadata = hdr10_metadata;
    m_hdr10_metadata_isSet = true;
}

bool OAIVideoSelector::is_hdr10_metadata_Set() const{
    return m_hdr10_metadata_isSet;
}

bool OAIVideoSelector::is_hdr10_metadata_Valid() const{
    return m_hdr10_metadata_isValid;
}

OAIPadVideo OAIVideoSelector::getPadVideo() const {
    return m_pad_video;
}
void OAIVideoSelector::setPadVideo(const OAIPadVideo &pad_video) {
    m_pad_video = pad_video;
    m_pad_video_isSet = true;
}

bool OAIVideoSelector::is_pad_video_Set() const{
    return m_pad_video_isSet;
}

bool OAIVideoSelector::is_pad_video_Valid() const{
    return m_pad_video_isValid;
}

qint32 OAIVideoSelector::getPid() const {
    return m_pid;
}
void OAIVideoSelector::setPid(const qint32 &pid) {
    m_pid = pid;
    m_pid_isSet = true;
}

bool OAIVideoSelector::is_pid_Set() const{
    return m_pid_isSet;
}

bool OAIVideoSelector::is_pid_Valid() const{
    return m_pid_isValid;
}

qint32 OAIVideoSelector::getProgramNumber() const {
    return m_program_number;
}
void OAIVideoSelector::setProgramNumber(const qint32 &program_number) {
    m_program_number = program_number;
    m_program_number_isSet = true;
}

bool OAIVideoSelector::is_program_number_Set() const{
    return m_program_number_isSet;
}

bool OAIVideoSelector::is_program_number_Valid() const{
    return m_program_number_isValid;
}

OAIInputRotate OAIVideoSelector::getRotate() const {
    return m_rotate;
}
void OAIVideoSelector::setRotate(const OAIInputRotate &rotate) {
    m_rotate = rotate;
    m_rotate_isSet = true;
}

bool OAIVideoSelector::is_rotate_Set() const{
    return m_rotate_isSet;
}

bool OAIVideoSelector::is_rotate_Valid() const{
    return m_rotate_isValid;
}

OAIInputSampleRange OAIVideoSelector::getSampleRange() const {
    return m_sample_range;
}
void OAIVideoSelector::setSampleRange(const OAIInputSampleRange &sample_range) {
    m_sample_range = sample_range;
    m_sample_range_isSet = true;
}

bool OAIVideoSelector::is_sample_range_Set() const{
    return m_sample_range_isSet;
}

bool OAIVideoSelector::is_sample_range_Valid() const{
    return m_sample_range_isValid;
}

bool OAIVideoSelector::isSet() const {
    bool isObjectUpdated = false;
    do {
        if (m_alpha_behavior.isSet()) {
            isObjectUpdated = true;
            break;
        }

        if (m_color_space.isSet()) {
            isObjectUpdated = true;
            break;
        }

        if (m_color_space_usage.isSet()) {
            isObjectUpdated = true;
            break;
        }

        if (m_embedded_timecode_override.isSet()) {
            isObjectUpdated = true;
            break;
        }

        if (m_hdr10_metadata.isSet()) {
            isObjectUpdated = true;
            break;
        }

        if (m_pad_video.isSet()) {
            isObjectUpdated = true;
            break;
        }

        if (m_pid_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_program_number_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_rotate.isSet()) {
            isObjectUpdated = true;
            break;
        }

        if (m_sample_range.isSet()) {
            isObjectUpdated = true;
            break;
        }
    } while (false);
    return isObjectUpdated;
}

bool OAIVideoSelector::isValid() const {
    // only required properties are required for the object to be considered valid
    return true;
}

} // namespace OpenAPI
