/**
 * AWS Elemental MediaConvert
 * AWS Elemental MediaConvert
 *
 * The version of the OpenAPI document: 2017-08-29
 * Contact: mike.ralphson@gmail.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

#include "OAIVideoPreprocessor.h"

#include <QDebug>
#include <QJsonArray>
#include <QJsonDocument>
#include <QObject>

#include "OAIHelpers.h"

namespace OpenAPI {

OAIVideoPreprocessor::OAIVideoPreprocessor(QString json) {
    this->initializeModel();
    this->fromJson(json);
}

OAIVideoPreprocessor::OAIVideoPreprocessor() {
    this->initializeModel();
}

OAIVideoPreprocessor::~OAIVideoPreprocessor() {}

void OAIVideoPreprocessor::initializeModel() {

    m_color_corrector_isSet = false;
    m_color_corrector_isValid = false;

    m_deinterlacer_isSet = false;
    m_deinterlacer_isValid = false;

    m_dolby_vision_isSet = false;
    m_dolby_vision_isValid = false;

    m_hdr10_plus_isSet = false;
    m_hdr10_plus_isValid = false;

    m_image_inserter_isSet = false;
    m_image_inserter_isValid = false;

    m_noise_reducer_isSet = false;
    m_noise_reducer_isValid = false;

    m_partner_watermarking_isSet = false;
    m_partner_watermarking_isValid = false;

    m_timecode_burnin_isSet = false;
    m_timecode_burnin_isValid = false;
}

void OAIVideoPreprocessor::fromJson(QString jsonString) {
    QByteArray array(jsonString.toStdString().c_str());
    QJsonDocument doc = QJsonDocument::fromJson(array);
    QJsonObject jsonObject = doc.object();
    this->fromJsonObject(jsonObject);
}

void OAIVideoPreprocessor::fromJsonObject(QJsonObject json) {

    m_color_corrector_isValid = ::OpenAPI::fromJsonValue(m_color_corrector, json[QString("ColorCorrector")]);
    m_color_corrector_isSet = !json[QString("ColorCorrector")].isNull() && m_color_corrector_isValid;

    m_deinterlacer_isValid = ::OpenAPI::fromJsonValue(m_deinterlacer, json[QString("Deinterlacer")]);
    m_deinterlacer_isSet = !json[QString("Deinterlacer")].isNull() && m_deinterlacer_isValid;

    m_dolby_vision_isValid = ::OpenAPI::fromJsonValue(m_dolby_vision, json[QString("DolbyVision")]);
    m_dolby_vision_isSet = !json[QString("DolbyVision")].isNull() && m_dolby_vision_isValid;

    m_hdr10_plus_isValid = ::OpenAPI::fromJsonValue(m_hdr10_plus, json[QString("Hdr10Plus")]);
    m_hdr10_plus_isSet = !json[QString("Hdr10Plus")].isNull() && m_hdr10_plus_isValid;

    m_image_inserter_isValid = ::OpenAPI::fromJsonValue(m_image_inserter, json[QString("ImageInserter")]);
    m_image_inserter_isSet = !json[QString("ImageInserter")].isNull() && m_image_inserter_isValid;

    m_noise_reducer_isValid = ::OpenAPI::fromJsonValue(m_noise_reducer, json[QString("NoiseReducer")]);
    m_noise_reducer_isSet = !json[QString("NoiseReducer")].isNull() && m_noise_reducer_isValid;

    m_partner_watermarking_isValid = ::OpenAPI::fromJsonValue(m_partner_watermarking, json[QString("PartnerWatermarking")]);
    m_partner_watermarking_isSet = !json[QString("PartnerWatermarking")].isNull() && m_partner_watermarking_isValid;

    m_timecode_burnin_isValid = ::OpenAPI::fromJsonValue(m_timecode_burnin, json[QString("TimecodeBurnin")]);
    m_timecode_burnin_isSet = !json[QString("TimecodeBurnin")].isNull() && m_timecode_burnin_isValid;
}

QString OAIVideoPreprocessor::asJson() const {
    QJsonObject obj = this->asJsonObject();
    QJsonDocument doc(obj);
    QByteArray bytes = doc.toJson();
    return QString(bytes);
}

QJsonObject OAIVideoPreprocessor::asJsonObject() const {
    QJsonObject obj;
    if (m_color_corrector.isSet()) {
        obj.insert(QString("ColorCorrector"), ::OpenAPI::toJsonValue(m_color_corrector));
    }
    if (m_deinterlacer.isSet()) {
        obj.insert(QString("Deinterlacer"), ::OpenAPI::toJsonValue(m_deinterlacer));
    }
    if (m_dolby_vision.isSet()) {
        obj.insert(QString("DolbyVision"), ::OpenAPI::toJsonValue(m_dolby_vision));
    }
    if (m_hdr10_plus.isSet()) {
        obj.insert(QString("Hdr10Plus"), ::OpenAPI::toJsonValue(m_hdr10_plus));
    }
    if (m_image_inserter.isSet()) {
        obj.insert(QString("ImageInserter"), ::OpenAPI::toJsonValue(m_image_inserter));
    }
    if (m_noise_reducer.isSet()) {
        obj.insert(QString("NoiseReducer"), ::OpenAPI::toJsonValue(m_noise_reducer));
    }
    if (m_partner_watermarking.isSet()) {
        obj.insert(QString("PartnerWatermarking"), ::OpenAPI::toJsonValue(m_partner_watermarking));
    }
    if (m_timecode_burnin.isSet()) {
        obj.insert(QString("TimecodeBurnin"), ::OpenAPI::toJsonValue(m_timecode_burnin));
    }
    return obj;
}

OAIVideoPreprocessor_ColorCorrector OAIVideoPreprocessor::getColorCorrector() const {
    return m_color_corrector;
}
void OAIVideoPreprocessor::setColorCorrector(const OAIVideoPreprocessor_ColorCorrector &color_corrector) {
    m_color_corrector = color_corrector;
    m_color_corrector_isSet = true;
}

bool OAIVideoPreprocessor::is_color_corrector_Set() const{
    return m_color_corrector_isSet;
}

bool OAIVideoPreprocessor::is_color_corrector_Valid() const{
    return m_color_corrector_isValid;
}

OAIVideoPreprocessor_Deinterlacer OAIVideoPreprocessor::getDeinterlacer() const {
    return m_deinterlacer;
}
void OAIVideoPreprocessor::setDeinterlacer(const OAIVideoPreprocessor_Deinterlacer &deinterlacer) {
    m_deinterlacer = deinterlacer;
    m_deinterlacer_isSet = true;
}

bool OAIVideoPreprocessor::is_deinterlacer_Set() const{
    return m_deinterlacer_isSet;
}

bool OAIVideoPreprocessor::is_deinterlacer_Valid() const{
    return m_deinterlacer_isValid;
}

OAIVideoPreprocessor_DolbyVision OAIVideoPreprocessor::getDolbyVision() const {
    return m_dolby_vision;
}
void OAIVideoPreprocessor::setDolbyVision(const OAIVideoPreprocessor_DolbyVision &dolby_vision) {
    m_dolby_vision = dolby_vision;
    m_dolby_vision_isSet = true;
}

bool OAIVideoPreprocessor::is_dolby_vision_Set() const{
    return m_dolby_vision_isSet;
}

bool OAIVideoPreprocessor::is_dolby_vision_Valid() const{
    return m_dolby_vision_isValid;
}

OAIVideoPreprocessor_Hdr10Plus OAIVideoPreprocessor::getHdr10Plus() const {
    return m_hdr10_plus;
}
void OAIVideoPreprocessor::setHdr10Plus(const OAIVideoPreprocessor_Hdr10Plus &hdr10_plus) {
    m_hdr10_plus = hdr10_plus;
    m_hdr10_plus_isSet = true;
}

bool OAIVideoPreprocessor::is_hdr10_plus_Set() const{
    return m_hdr10_plus_isSet;
}

bool OAIVideoPreprocessor::is_hdr10_plus_Valid() const{
    return m_hdr10_plus_isValid;
}

OAIVideoPreprocessor_ImageInserter OAIVideoPreprocessor::getImageInserter() const {
    return m_image_inserter;
}
void OAIVideoPreprocessor::setImageInserter(const OAIVideoPreprocessor_ImageInserter &image_inserter) {
    m_image_inserter = image_inserter;
    m_image_inserter_isSet = true;
}

bool OAIVideoPreprocessor::is_image_inserter_Set() const{
    return m_image_inserter_isSet;
}

bool OAIVideoPreprocessor::is_image_inserter_Valid() const{
    return m_image_inserter_isValid;
}

OAIVideoPreprocessor_NoiseReducer OAIVideoPreprocessor::getNoiseReducer() const {
    return m_noise_reducer;
}
void OAIVideoPreprocessor::setNoiseReducer(const OAIVideoPreprocessor_NoiseReducer &noise_reducer) {
    m_noise_reducer = noise_reducer;
    m_noise_reducer_isSet = true;
}

bool OAIVideoPreprocessor::is_noise_reducer_Set() const{
    return m_noise_reducer_isSet;
}

bool OAIVideoPreprocessor::is_noise_reducer_Valid() const{
    return m_noise_reducer_isValid;
}

OAIVideoPreprocessor_PartnerWatermarking OAIVideoPreprocessor::getPartnerWatermarking() const {
    return m_partner_watermarking;
}
void OAIVideoPreprocessor::setPartnerWatermarking(const OAIVideoPreprocessor_PartnerWatermarking &partner_watermarking) {
    m_partner_watermarking = partner_watermarking;
    m_partner_watermarking_isSet = true;
}

bool OAIVideoPreprocessor::is_partner_watermarking_Set() const{
    return m_partner_watermarking_isSet;
}

bool OAIVideoPreprocessor::is_partner_watermarking_Valid() const{
    return m_partner_watermarking_isValid;
}

OAIVideoPreprocessor_TimecodeBurnin OAIVideoPreprocessor::getTimecodeBurnin() const {
    return m_timecode_burnin;
}
void OAIVideoPreprocessor::setTimecodeBurnin(const OAIVideoPreprocessor_TimecodeBurnin &timecode_burnin) {
    m_timecode_burnin = timecode_burnin;
    m_timecode_burnin_isSet = true;
}

bool OAIVideoPreprocessor::is_timecode_burnin_Set() const{
    return m_timecode_burnin_isSet;
}

bool OAIVideoPreprocessor::is_timecode_burnin_Valid() const{
    return m_timecode_burnin_isValid;
}

bool OAIVideoPreprocessor::isSet() const {
    bool isObjectUpdated = false;
    do {
        if (m_color_corrector.isSet()) {
            isObjectUpdated = true;
            break;
        }

        if (m_deinterlacer.isSet()) {
            isObjectUpdated = true;
            break;
        }

        if (m_dolby_vision.isSet()) {
            isObjectUpdated = true;
            break;
        }

        if (m_hdr10_plus.isSet()) {
            isObjectUpdated = true;
            break;
        }

        if (m_image_inserter.isSet()) {
            isObjectUpdated = true;
            break;
        }

        if (m_noise_reducer.isSet()) {
            isObjectUpdated = true;
            break;
        }

        if (m_partner_watermarking.isSet()) {
            isObjectUpdated = true;
            break;
        }

        if (m_timecode_burnin.isSet()) {
            isObjectUpdated = true;
            break;
        }
    } while (false);
    return isObjectUpdated;
}

bool OAIVideoPreprocessor::isValid() const {
    // only required properties are required for the object to be considered valid
    return true;
}

} // namespace OpenAPI
