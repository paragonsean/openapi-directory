/**
 * AWS Elemental MediaConvert
 * AWS Elemental MediaConvert
 *
 * The version of the OpenAPI document: 2017-08-29
 * Contact: mike.ralphson@gmail.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

#include "OAIVideoCodecSettings_Av1Settings.h"

#include <QDebug>
#include <QJsonArray>
#include <QJsonDocument>
#include <QObject>

#include "OAIHelpers.h"

namespace OpenAPI {

OAIVideoCodecSettings_Av1Settings::OAIVideoCodecSettings_Av1Settings(QString json) {
    this->initializeModel();
    this->fromJson(json);
}

OAIVideoCodecSettings_Av1Settings::OAIVideoCodecSettings_Av1Settings() {
    this->initializeModel();
}

OAIVideoCodecSettings_Av1Settings::~OAIVideoCodecSettings_Av1Settings() {}

void OAIVideoCodecSettings_Av1Settings::initializeModel() {

    m_adaptive_quantization_isSet = false;
    m_adaptive_quantization_isValid = false;

    m_bit_depth_isSet = false;
    m_bit_depth_isValid = false;

    m_framerate_control_isSet = false;
    m_framerate_control_isValid = false;

    m_framerate_conversion_algorithm_isSet = false;
    m_framerate_conversion_algorithm_isValid = false;

    m_framerate_denominator_isSet = false;
    m_framerate_denominator_isValid = false;

    m_framerate_numerator_isSet = false;
    m_framerate_numerator_isValid = false;

    m_gop_size_isSet = false;
    m_gop_size_isValid = false;

    m_max_bitrate_isSet = false;
    m_max_bitrate_isValid = false;

    m_number_b_frames_between_reference_frames_isSet = false;
    m_number_b_frames_between_reference_frames_isValid = false;

    m_qvbr_settings_isSet = false;
    m_qvbr_settings_isValid = false;

    m_rate_control_mode_isSet = false;
    m_rate_control_mode_isValid = false;

    m_slices_isSet = false;
    m_slices_isValid = false;

    m_spatial_adaptive_quantization_isSet = false;
    m_spatial_adaptive_quantization_isValid = false;
}

void OAIVideoCodecSettings_Av1Settings::fromJson(QString jsonString) {
    QByteArray array(jsonString.toStdString().c_str());
    QJsonDocument doc = QJsonDocument::fromJson(array);
    QJsonObject jsonObject = doc.object();
    this->fromJsonObject(jsonObject);
}

void OAIVideoCodecSettings_Av1Settings::fromJsonObject(QJsonObject json) {

    m_adaptive_quantization_isValid = ::OpenAPI::fromJsonValue(m_adaptive_quantization, json[QString("AdaptiveQuantization")]);
    m_adaptive_quantization_isSet = !json[QString("AdaptiveQuantization")].isNull() && m_adaptive_quantization_isValid;

    m_bit_depth_isValid = ::OpenAPI::fromJsonValue(m_bit_depth, json[QString("BitDepth")]);
    m_bit_depth_isSet = !json[QString("BitDepth")].isNull() && m_bit_depth_isValid;

    m_framerate_control_isValid = ::OpenAPI::fromJsonValue(m_framerate_control, json[QString("FramerateControl")]);
    m_framerate_control_isSet = !json[QString("FramerateControl")].isNull() && m_framerate_control_isValid;

    m_framerate_conversion_algorithm_isValid = ::OpenAPI::fromJsonValue(m_framerate_conversion_algorithm, json[QString("FramerateConversionAlgorithm")]);
    m_framerate_conversion_algorithm_isSet = !json[QString("FramerateConversionAlgorithm")].isNull() && m_framerate_conversion_algorithm_isValid;

    m_framerate_denominator_isValid = ::OpenAPI::fromJsonValue(m_framerate_denominator, json[QString("FramerateDenominator")]);
    m_framerate_denominator_isSet = !json[QString("FramerateDenominator")].isNull() && m_framerate_denominator_isValid;

    m_framerate_numerator_isValid = ::OpenAPI::fromJsonValue(m_framerate_numerator, json[QString("FramerateNumerator")]);
    m_framerate_numerator_isSet = !json[QString("FramerateNumerator")].isNull() && m_framerate_numerator_isValid;

    m_gop_size_isValid = ::OpenAPI::fromJsonValue(m_gop_size, json[QString("GopSize")]);
    m_gop_size_isSet = !json[QString("GopSize")].isNull() && m_gop_size_isValid;

    m_max_bitrate_isValid = ::OpenAPI::fromJsonValue(m_max_bitrate, json[QString("MaxBitrate")]);
    m_max_bitrate_isSet = !json[QString("MaxBitrate")].isNull() && m_max_bitrate_isValid;

    m_number_b_frames_between_reference_frames_isValid = ::OpenAPI::fromJsonValue(m_number_b_frames_between_reference_frames, json[QString("NumberBFramesBetweenReferenceFrames")]);
    m_number_b_frames_between_reference_frames_isSet = !json[QString("NumberBFramesBetweenReferenceFrames")].isNull() && m_number_b_frames_between_reference_frames_isValid;

    m_qvbr_settings_isValid = ::OpenAPI::fromJsonValue(m_qvbr_settings, json[QString("QvbrSettings")]);
    m_qvbr_settings_isSet = !json[QString("QvbrSettings")].isNull() && m_qvbr_settings_isValid;

    m_rate_control_mode_isValid = ::OpenAPI::fromJsonValue(m_rate_control_mode, json[QString("RateControlMode")]);
    m_rate_control_mode_isSet = !json[QString("RateControlMode")].isNull() && m_rate_control_mode_isValid;

    m_slices_isValid = ::OpenAPI::fromJsonValue(m_slices, json[QString("Slices")]);
    m_slices_isSet = !json[QString("Slices")].isNull() && m_slices_isValid;

    m_spatial_adaptive_quantization_isValid = ::OpenAPI::fromJsonValue(m_spatial_adaptive_quantization, json[QString("SpatialAdaptiveQuantization")]);
    m_spatial_adaptive_quantization_isSet = !json[QString("SpatialAdaptiveQuantization")].isNull() && m_spatial_adaptive_quantization_isValid;
}

QString OAIVideoCodecSettings_Av1Settings::asJson() const {
    QJsonObject obj = this->asJsonObject();
    QJsonDocument doc(obj);
    QByteArray bytes = doc.toJson();
    return QString(bytes);
}

QJsonObject OAIVideoCodecSettings_Av1Settings::asJsonObject() const {
    QJsonObject obj;
    if (m_adaptive_quantization.isSet()) {
        obj.insert(QString("AdaptiveQuantization"), ::OpenAPI::toJsonValue(m_adaptive_quantization));
    }
    if (m_bit_depth.isSet()) {
        obj.insert(QString("BitDepth"), ::OpenAPI::toJsonValue(m_bit_depth));
    }
    if (m_framerate_control.isSet()) {
        obj.insert(QString("FramerateControl"), ::OpenAPI::toJsonValue(m_framerate_control));
    }
    if (m_framerate_conversion_algorithm.isSet()) {
        obj.insert(QString("FramerateConversionAlgorithm"), ::OpenAPI::toJsonValue(m_framerate_conversion_algorithm));
    }
    if (m_framerate_denominator_isSet) {
        obj.insert(QString("FramerateDenominator"), ::OpenAPI::toJsonValue(m_framerate_denominator));
    }
    if (m_framerate_numerator_isSet) {
        obj.insert(QString("FramerateNumerator"), ::OpenAPI::toJsonValue(m_framerate_numerator));
    }
    if (m_gop_size_isSet) {
        obj.insert(QString("GopSize"), ::OpenAPI::toJsonValue(m_gop_size));
    }
    if (m_max_bitrate_isSet) {
        obj.insert(QString("MaxBitrate"), ::OpenAPI::toJsonValue(m_max_bitrate));
    }
    if (m_number_b_frames_between_reference_frames_isSet) {
        obj.insert(QString("NumberBFramesBetweenReferenceFrames"), ::OpenAPI::toJsonValue(m_number_b_frames_between_reference_frames));
    }
    if (m_qvbr_settings.isSet()) {
        obj.insert(QString("QvbrSettings"), ::OpenAPI::toJsonValue(m_qvbr_settings));
    }
    if (m_rate_control_mode.isSet()) {
        obj.insert(QString("RateControlMode"), ::OpenAPI::toJsonValue(m_rate_control_mode));
    }
    if (m_slices_isSet) {
        obj.insert(QString("Slices"), ::OpenAPI::toJsonValue(m_slices));
    }
    if (m_spatial_adaptive_quantization.isSet()) {
        obj.insert(QString("SpatialAdaptiveQuantization"), ::OpenAPI::toJsonValue(m_spatial_adaptive_quantization));
    }
    return obj;
}

OAIAv1AdaptiveQuantization OAIVideoCodecSettings_Av1Settings::getAdaptiveQuantization() const {
    return m_adaptive_quantization;
}
void OAIVideoCodecSettings_Av1Settings::setAdaptiveQuantization(const OAIAv1AdaptiveQuantization &adaptive_quantization) {
    m_adaptive_quantization = adaptive_quantization;
    m_adaptive_quantization_isSet = true;
}

bool OAIVideoCodecSettings_Av1Settings::is_adaptive_quantization_Set() const{
    return m_adaptive_quantization_isSet;
}

bool OAIVideoCodecSettings_Av1Settings::is_adaptive_quantization_Valid() const{
    return m_adaptive_quantization_isValid;
}

OAIAv1BitDepth OAIVideoCodecSettings_Av1Settings::getBitDepth() const {
    return m_bit_depth;
}
void OAIVideoCodecSettings_Av1Settings::setBitDepth(const OAIAv1BitDepth &bit_depth) {
    m_bit_depth = bit_depth;
    m_bit_depth_isSet = true;
}

bool OAIVideoCodecSettings_Av1Settings::is_bit_depth_Set() const{
    return m_bit_depth_isSet;
}

bool OAIVideoCodecSettings_Av1Settings::is_bit_depth_Valid() const{
    return m_bit_depth_isValid;
}

OAIAv1FramerateControl OAIVideoCodecSettings_Av1Settings::getFramerateControl() const {
    return m_framerate_control;
}
void OAIVideoCodecSettings_Av1Settings::setFramerateControl(const OAIAv1FramerateControl &framerate_control) {
    m_framerate_control = framerate_control;
    m_framerate_control_isSet = true;
}

bool OAIVideoCodecSettings_Av1Settings::is_framerate_control_Set() const{
    return m_framerate_control_isSet;
}

bool OAIVideoCodecSettings_Av1Settings::is_framerate_control_Valid() const{
    return m_framerate_control_isValid;
}

OAIAv1FramerateConversionAlgorithm OAIVideoCodecSettings_Av1Settings::getFramerateConversionAlgorithm() const {
    return m_framerate_conversion_algorithm;
}
void OAIVideoCodecSettings_Av1Settings::setFramerateConversionAlgorithm(const OAIAv1FramerateConversionAlgorithm &framerate_conversion_algorithm) {
    m_framerate_conversion_algorithm = framerate_conversion_algorithm;
    m_framerate_conversion_algorithm_isSet = true;
}

bool OAIVideoCodecSettings_Av1Settings::is_framerate_conversion_algorithm_Set() const{
    return m_framerate_conversion_algorithm_isSet;
}

bool OAIVideoCodecSettings_Av1Settings::is_framerate_conversion_algorithm_Valid() const{
    return m_framerate_conversion_algorithm_isValid;
}

qint32 OAIVideoCodecSettings_Av1Settings::getFramerateDenominator() const {
    return m_framerate_denominator;
}
void OAIVideoCodecSettings_Av1Settings::setFramerateDenominator(const qint32 &framerate_denominator) {
    m_framerate_denominator = framerate_denominator;
    m_framerate_denominator_isSet = true;
}

bool OAIVideoCodecSettings_Av1Settings::is_framerate_denominator_Set() const{
    return m_framerate_denominator_isSet;
}

bool OAIVideoCodecSettings_Av1Settings::is_framerate_denominator_Valid() const{
    return m_framerate_denominator_isValid;
}

qint32 OAIVideoCodecSettings_Av1Settings::getFramerateNumerator() const {
    return m_framerate_numerator;
}
void OAIVideoCodecSettings_Av1Settings::setFramerateNumerator(const qint32 &framerate_numerator) {
    m_framerate_numerator = framerate_numerator;
    m_framerate_numerator_isSet = true;
}

bool OAIVideoCodecSettings_Av1Settings::is_framerate_numerator_Set() const{
    return m_framerate_numerator_isSet;
}

bool OAIVideoCodecSettings_Av1Settings::is_framerate_numerator_Valid() const{
    return m_framerate_numerator_isValid;
}

double OAIVideoCodecSettings_Av1Settings::getGopSize() const {
    return m_gop_size;
}
void OAIVideoCodecSettings_Av1Settings::setGopSize(const double &gop_size) {
    m_gop_size = gop_size;
    m_gop_size_isSet = true;
}

bool OAIVideoCodecSettings_Av1Settings::is_gop_size_Set() const{
    return m_gop_size_isSet;
}

bool OAIVideoCodecSettings_Av1Settings::is_gop_size_Valid() const{
    return m_gop_size_isValid;
}

qint32 OAIVideoCodecSettings_Av1Settings::getMaxBitrate() const {
    return m_max_bitrate;
}
void OAIVideoCodecSettings_Av1Settings::setMaxBitrate(const qint32 &max_bitrate) {
    m_max_bitrate = max_bitrate;
    m_max_bitrate_isSet = true;
}

bool OAIVideoCodecSettings_Av1Settings::is_max_bitrate_Set() const{
    return m_max_bitrate_isSet;
}

bool OAIVideoCodecSettings_Av1Settings::is_max_bitrate_Valid() const{
    return m_max_bitrate_isValid;
}

qint32 OAIVideoCodecSettings_Av1Settings::getNumberBFramesBetweenReferenceFrames() const {
    return m_number_b_frames_between_reference_frames;
}
void OAIVideoCodecSettings_Av1Settings::setNumberBFramesBetweenReferenceFrames(const qint32 &number_b_frames_between_reference_frames) {
    m_number_b_frames_between_reference_frames = number_b_frames_between_reference_frames;
    m_number_b_frames_between_reference_frames_isSet = true;
}

bool OAIVideoCodecSettings_Av1Settings::is_number_b_frames_between_reference_frames_Set() const{
    return m_number_b_frames_between_reference_frames_isSet;
}

bool OAIVideoCodecSettings_Av1Settings::is_number_b_frames_between_reference_frames_Valid() const{
    return m_number_b_frames_between_reference_frames_isValid;
}

OAIAv1Settings_QvbrSettings OAIVideoCodecSettings_Av1Settings::getQvbrSettings() const {
    return m_qvbr_settings;
}
void OAIVideoCodecSettings_Av1Settings::setQvbrSettings(const OAIAv1Settings_QvbrSettings &qvbr_settings) {
    m_qvbr_settings = qvbr_settings;
    m_qvbr_settings_isSet = true;
}

bool OAIVideoCodecSettings_Av1Settings::is_qvbr_settings_Set() const{
    return m_qvbr_settings_isSet;
}

bool OAIVideoCodecSettings_Av1Settings::is_qvbr_settings_Valid() const{
    return m_qvbr_settings_isValid;
}

OAIAv1RateControlMode OAIVideoCodecSettings_Av1Settings::getRateControlMode() const {
    return m_rate_control_mode;
}
void OAIVideoCodecSettings_Av1Settings::setRateControlMode(const OAIAv1RateControlMode &rate_control_mode) {
    m_rate_control_mode = rate_control_mode;
    m_rate_control_mode_isSet = true;
}

bool OAIVideoCodecSettings_Av1Settings::is_rate_control_mode_Set() const{
    return m_rate_control_mode_isSet;
}

bool OAIVideoCodecSettings_Av1Settings::is_rate_control_mode_Valid() const{
    return m_rate_control_mode_isValid;
}

qint32 OAIVideoCodecSettings_Av1Settings::getSlices() const {
    return m_slices;
}
void OAIVideoCodecSettings_Av1Settings::setSlices(const qint32 &slices) {
    m_slices = slices;
    m_slices_isSet = true;
}

bool OAIVideoCodecSettings_Av1Settings::is_slices_Set() const{
    return m_slices_isSet;
}

bool OAIVideoCodecSettings_Av1Settings::is_slices_Valid() const{
    return m_slices_isValid;
}

OAIAv1SpatialAdaptiveQuantization OAIVideoCodecSettings_Av1Settings::getSpatialAdaptiveQuantization() const {
    return m_spatial_adaptive_quantization;
}
void OAIVideoCodecSettings_Av1Settings::setSpatialAdaptiveQuantization(const OAIAv1SpatialAdaptiveQuantization &spatial_adaptive_quantization) {
    m_spatial_adaptive_quantization = spatial_adaptive_quantization;
    m_spatial_adaptive_quantization_isSet = true;
}

bool OAIVideoCodecSettings_Av1Settings::is_spatial_adaptive_quantization_Set() const{
    return m_spatial_adaptive_quantization_isSet;
}

bool OAIVideoCodecSettings_Av1Settings::is_spatial_adaptive_quantization_Valid() const{
    return m_spatial_adaptive_quantization_isValid;
}

bool OAIVideoCodecSettings_Av1Settings::isSet() const {
    bool isObjectUpdated = false;
    do {
        if (m_adaptive_quantization.isSet()) {
            isObjectUpdated = true;
            break;
        }

        if (m_bit_depth.isSet()) {
            isObjectUpdated = true;
            break;
        }

        if (m_framerate_control.isSet()) {
            isObjectUpdated = true;
            break;
        }

        if (m_framerate_conversion_algorithm.isSet()) {
            isObjectUpdated = true;
            break;
        }

        if (m_framerate_denominator_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_framerate_numerator_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_gop_size_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_max_bitrate_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_number_b_frames_between_reference_frames_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_qvbr_settings.isSet()) {
            isObjectUpdated = true;
            break;
        }

        if (m_rate_control_mode.isSet()) {
            isObjectUpdated = true;
            break;
        }

        if (m_slices_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_spatial_adaptive_quantization.isSet()) {
            isObjectUpdated = true;
            break;
        }
    } while (false);
    return isObjectUpdated;
}

bool OAIVideoCodecSettings_Av1Settings::isValid() const {
    // only required properties are required for the object to be considered valid
    return true;
}

} // namespace OpenAPI
