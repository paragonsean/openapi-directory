/**
 * AWS Elemental MediaConvert
 * AWS Elemental MediaConvert
 *
 * The version of the OpenAPI document: 2017-08-29
 * Contact: mike.ralphson@gmail.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

#include "OAIVideoCodecSettings_H264Settings.h"

#include <QDebug>
#include <QJsonArray>
#include <QJsonDocument>
#include <QObject>

#include "OAIHelpers.h"

namespace OpenAPI {

OAIVideoCodecSettings_H264Settings::OAIVideoCodecSettings_H264Settings(QString json) {
    this->initializeModel();
    this->fromJson(json);
}

OAIVideoCodecSettings_H264Settings::OAIVideoCodecSettings_H264Settings() {
    this->initializeModel();
}

OAIVideoCodecSettings_H264Settings::~OAIVideoCodecSettings_H264Settings() {}

void OAIVideoCodecSettings_H264Settings::initializeModel() {

    m_adaptive_quantization_isSet = false;
    m_adaptive_quantization_isValid = false;

    m_bandwidth_reduction_filter_isSet = false;
    m_bandwidth_reduction_filter_isValid = false;

    m_bitrate_isSet = false;
    m_bitrate_isValid = false;

    m_codec_level_isSet = false;
    m_codec_level_isValid = false;

    m_codec_profile_isSet = false;
    m_codec_profile_isValid = false;

    m_dynamic_sub_gop_isSet = false;
    m_dynamic_sub_gop_isValid = false;

    m_entropy_encoding_isSet = false;
    m_entropy_encoding_isValid = false;

    m_field_encoding_isSet = false;
    m_field_encoding_isValid = false;

    m_flicker_adaptive_quantization_isSet = false;
    m_flicker_adaptive_quantization_isValid = false;

    m_framerate_control_isSet = false;
    m_framerate_control_isValid = false;

    m_framerate_conversion_algorithm_isSet = false;
    m_framerate_conversion_algorithm_isValid = false;

    m_framerate_denominator_isSet = false;
    m_framerate_denominator_isValid = false;

    m_framerate_numerator_isSet = false;
    m_framerate_numerator_isValid = false;

    m_gop_b_reference_isSet = false;
    m_gop_b_reference_isValid = false;

    m_gop_closed_cadence_isSet = false;
    m_gop_closed_cadence_isValid = false;

    m_gop_size_isSet = false;
    m_gop_size_isValid = false;

    m_gop_size_units_isSet = false;
    m_gop_size_units_isValid = false;

    m_hrd_buffer_final_fill_percentage_isSet = false;
    m_hrd_buffer_final_fill_percentage_isValid = false;

    m_hrd_buffer_initial_fill_percentage_isSet = false;
    m_hrd_buffer_initial_fill_percentage_isValid = false;

    m_hrd_buffer_size_isSet = false;
    m_hrd_buffer_size_isValid = false;

    m_interlace_mode_isSet = false;
    m_interlace_mode_isValid = false;

    m_max_bitrate_isSet = false;
    m_max_bitrate_isValid = false;

    m_min_i_interval_isSet = false;
    m_min_i_interval_isValid = false;

    m_number_b_frames_between_reference_frames_isSet = false;
    m_number_b_frames_between_reference_frames_isValid = false;

    m_number_reference_frames_isSet = false;
    m_number_reference_frames_isValid = false;

    m_par_control_isSet = false;
    m_par_control_isValid = false;

    m_par_denominator_isSet = false;
    m_par_denominator_isValid = false;

    m_par_numerator_isSet = false;
    m_par_numerator_isValid = false;

    m_quality_tuning_level_isSet = false;
    m_quality_tuning_level_isValid = false;

    m_qvbr_settings_isSet = false;
    m_qvbr_settings_isValid = false;

    m_rate_control_mode_isSet = false;
    m_rate_control_mode_isValid = false;

    m_repeat_pps_isSet = false;
    m_repeat_pps_isValid = false;

    m_scan_type_conversion_mode_isSet = false;
    m_scan_type_conversion_mode_isValid = false;

    m_scene_change_detect_isSet = false;
    m_scene_change_detect_isValid = false;

    m_slices_isSet = false;
    m_slices_isValid = false;

    m_slow_pal_isSet = false;
    m_slow_pal_isValid = false;

    m_softness_isSet = false;
    m_softness_isValid = false;

    m_spatial_adaptive_quantization_isSet = false;
    m_spatial_adaptive_quantization_isValid = false;

    m_syntax_isSet = false;
    m_syntax_isValid = false;

    m_telecine_isSet = false;
    m_telecine_isValid = false;

    m_temporal_adaptive_quantization_isSet = false;
    m_temporal_adaptive_quantization_isValid = false;

    m_unregistered_sei_timecode_isSet = false;
    m_unregistered_sei_timecode_isValid = false;
}

void OAIVideoCodecSettings_H264Settings::fromJson(QString jsonString) {
    QByteArray array(jsonString.toStdString().c_str());
    QJsonDocument doc = QJsonDocument::fromJson(array);
    QJsonObject jsonObject = doc.object();
    this->fromJsonObject(jsonObject);
}

void OAIVideoCodecSettings_H264Settings::fromJsonObject(QJsonObject json) {

    m_adaptive_quantization_isValid = ::OpenAPI::fromJsonValue(m_adaptive_quantization, json[QString("AdaptiveQuantization")]);
    m_adaptive_quantization_isSet = !json[QString("AdaptiveQuantization")].isNull() && m_adaptive_quantization_isValid;

    m_bandwidth_reduction_filter_isValid = ::OpenAPI::fromJsonValue(m_bandwidth_reduction_filter, json[QString("BandwidthReductionFilter")]);
    m_bandwidth_reduction_filter_isSet = !json[QString("BandwidthReductionFilter")].isNull() && m_bandwidth_reduction_filter_isValid;

    m_bitrate_isValid = ::OpenAPI::fromJsonValue(m_bitrate, json[QString("Bitrate")]);
    m_bitrate_isSet = !json[QString("Bitrate")].isNull() && m_bitrate_isValid;

    m_codec_level_isValid = ::OpenAPI::fromJsonValue(m_codec_level, json[QString("CodecLevel")]);
    m_codec_level_isSet = !json[QString("CodecLevel")].isNull() && m_codec_level_isValid;

    m_codec_profile_isValid = ::OpenAPI::fromJsonValue(m_codec_profile, json[QString("CodecProfile")]);
    m_codec_profile_isSet = !json[QString("CodecProfile")].isNull() && m_codec_profile_isValid;

    m_dynamic_sub_gop_isValid = ::OpenAPI::fromJsonValue(m_dynamic_sub_gop, json[QString("DynamicSubGop")]);
    m_dynamic_sub_gop_isSet = !json[QString("DynamicSubGop")].isNull() && m_dynamic_sub_gop_isValid;

    m_entropy_encoding_isValid = ::OpenAPI::fromJsonValue(m_entropy_encoding, json[QString("EntropyEncoding")]);
    m_entropy_encoding_isSet = !json[QString("EntropyEncoding")].isNull() && m_entropy_encoding_isValid;

    m_field_encoding_isValid = ::OpenAPI::fromJsonValue(m_field_encoding, json[QString("FieldEncoding")]);
    m_field_encoding_isSet = !json[QString("FieldEncoding")].isNull() && m_field_encoding_isValid;

    m_flicker_adaptive_quantization_isValid = ::OpenAPI::fromJsonValue(m_flicker_adaptive_quantization, json[QString("FlickerAdaptiveQuantization")]);
    m_flicker_adaptive_quantization_isSet = !json[QString("FlickerAdaptiveQuantization")].isNull() && m_flicker_adaptive_quantization_isValid;

    m_framerate_control_isValid = ::OpenAPI::fromJsonValue(m_framerate_control, json[QString("FramerateControl")]);
    m_framerate_control_isSet = !json[QString("FramerateControl")].isNull() && m_framerate_control_isValid;

    m_framerate_conversion_algorithm_isValid = ::OpenAPI::fromJsonValue(m_framerate_conversion_algorithm, json[QString("FramerateConversionAlgorithm")]);
    m_framerate_conversion_algorithm_isSet = !json[QString("FramerateConversionAlgorithm")].isNull() && m_framerate_conversion_algorithm_isValid;

    m_framerate_denominator_isValid = ::OpenAPI::fromJsonValue(m_framerate_denominator, json[QString("FramerateDenominator")]);
    m_framerate_denominator_isSet = !json[QString("FramerateDenominator")].isNull() && m_framerate_denominator_isValid;

    m_framerate_numerator_isValid = ::OpenAPI::fromJsonValue(m_framerate_numerator, json[QString("FramerateNumerator")]);
    m_framerate_numerator_isSet = !json[QString("FramerateNumerator")].isNull() && m_framerate_numerator_isValid;

    m_gop_b_reference_isValid = ::OpenAPI::fromJsonValue(m_gop_b_reference, json[QString("GopBReference")]);
    m_gop_b_reference_isSet = !json[QString("GopBReference")].isNull() && m_gop_b_reference_isValid;

    m_gop_closed_cadence_isValid = ::OpenAPI::fromJsonValue(m_gop_closed_cadence, json[QString("GopClosedCadence")]);
    m_gop_closed_cadence_isSet = !json[QString("GopClosedCadence")].isNull() && m_gop_closed_cadence_isValid;

    m_gop_size_isValid = ::OpenAPI::fromJsonValue(m_gop_size, json[QString("GopSize")]);
    m_gop_size_isSet = !json[QString("GopSize")].isNull() && m_gop_size_isValid;

    m_gop_size_units_isValid = ::OpenAPI::fromJsonValue(m_gop_size_units, json[QString("GopSizeUnits")]);
    m_gop_size_units_isSet = !json[QString("GopSizeUnits")].isNull() && m_gop_size_units_isValid;

    m_hrd_buffer_final_fill_percentage_isValid = ::OpenAPI::fromJsonValue(m_hrd_buffer_final_fill_percentage, json[QString("HrdBufferFinalFillPercentage")]);
    m_hrd_buffer_final_fill_percentage_isSet = !json[QString("HrdBufferFinalFillPercentage")].isNull() && m_hrd_buffer_final_fill_percentage_isValid;

    m_hrd_buffer_initial_fill_percentage_isValid = ::OpenAPI::fromJsonValue(m_hrd_buffer_initial_fill_percentage, json[QString("HrdBufferInitialFillPercentage")]);
    m_hrd_buffer_initial_fill_percentage_isSet = !json[QString("HrdBufferInitialFillPercentage")].isNull() && m_hrd_buffer_initial_fill_percentage_isValid;

    m_hrd_buffer_size_isValid = ::OpenAPI::fromJsonValue(m_hrd_buffer_size, json[QString("HrdBufferSize")]);
    m_hrd_buffer_size_isSet = !json[QString("HrdBufferSize")].isNull() && m_hrd_buffer_size_isValid;

    m_interlace_mode_isValid = ::OpenAPI::fromJsonValue(m_interlace_mode, json[QString("InterlaceMode")]);
    m_interlace_mode_isSet = !json[QString("InterlaceMode")].isNull() && m_interlace_mode_isValid;

    m_max_bitrate_isValid = ::OpenAPI::fromJsonValue(m_max_bitrate, json[QString("MaxBitrate")]);
    m_max_bitrate_isSet = !json[QString("MaxBitrate")].isNull() && m_max_bitrate_isValid;

    m_min_i_interval_isValid = ::OpenAPI::fromJsonValue(m_min_i_interval, json[QString("MinIInterval")]);
    m_min_i_interval_isSet = !json[QString("MinIInterval")].isNull() && m_min_i_interval_isValid;

    m_number_b_frames_between_reference_frames_isValid = ::OpenAPI::fromJsonValue(m_number_b_frames_between_reference_frames, json[QString("NumberBFramesBetweenReferenceFrames")]);
    m_number_b_frames_between_reference_frames_isSet = !json[QString("NumberBFramesBetweenReferenceFrames")].isNull() && m_number_b_frames_between_reference_frames_isValid;

    m_number_reference_frames_isValid = ::OpenAPI::fromJsonValue(m_number_reference_frames, json[QString("NumberReferenceFrames")]);
    m_number_reference_frames_isSet = !json[QString("NumberReferenceFrames")].isNull() && m_number_reference_frames_isValid;

    m_par_control_isValid = ::OpenAPI::fromJsonValue(m_par_control, json[QString("ParControl")]);
    m_par_control_isSet = !json[QString("ParControl")].isNull() && m_par_control_isValid;

    m_par_denominator_isValid = ::OpenAPI::fromJsonValue(m_par_denominator, json[QString("ParDenominator")]);
    m_par_denominator_isSet = !json[QString("ParDenominator")].isNull() && m_par_denominator_isValid;

    m_par_numerator_isValid = ::OpenAPI::fromJsonValue(m_par_numerator, json[QString("ParNumerator")]);
    m_par_numerator_isSet = !json[QString("ParNumerator")].isNull() && m_par_numerator_isValid;

    m_quality_tuning_level_isValid = ::OpenAPI::fromJsonValue(m_quality_tuning_level, json[QString("QualityTuningLevel")]);
    m_quality_tuning_level_isSet = !json[QString("QualityTuningLevel")].isNull() && m_quality_tuning_level_isValid;

    m_qvbr_settings_isValid = ::OpenAPI::fromJsonValue(m_qvbr_settings, json[QString("QvbrSettings")]);
    m_qvbr_settings_isSet = !json[QString("QvbrSettings")].isNull() && m_qvbr_settings_isValid;

    m_rate_control_mode_isValid = ::OpenAPI::fromJsonValue(m_rate_control_mode, json[QString("RateControlMode")]);
    m_rate_control_mode_isSet = !json[QString("RateControlMode")].isNull() && m_rate_control_mode_isValid;

    m_repeat_pps_isValid = ::OpenAPI::fromJsonValue(m_repeat_pps, json[QString("RepeatPps")]);
    m_repeat_pps_isSet = !json[QString("RepeatPps")].isNull() && m_repeat_pps_isValid;

    m_scan_type_conversion_mode_isValid = ::OpenAPI::fromJsonValue(m_scan_type_conversion_mode, json[QString("ScanTypeConversionMode")]);
    m_scan_type_conversion_mode_isSet = !json[QString("ScanTypeConversionMode")].isNull() && m_scan_type_conversion_mode_isValid;

    m_scene_change_detect_isValid = ::OpenAPI::fromJsonValue(m_scene_change_detect, json[QString("SceneChangeDetect")]);
    m_scene_change_detect_isSet = !json[QString("SceneChangeDetect")].isNull() && m_scene_change_detect_isValid;

    m_slices_isValid = ::OpenAPI::fromJsonValue(m_slices, json[QString("Slices")]);
    m_slices_isSet = !json[QString("Slices")].isNull() && m_slices_isValid;

    m_slow_pal_isValid = ::OpenAPI::fromJsonValue(m_slow_pal, json[QString("SlowPal")]);
    m_slow_pal_isSet = !json[QString("SlowPal")].isNull() && m_slow_pal_isValid;

    m_softness_isValid = ::OpenAPI::fromJsonValue(m_softness, json[QString("Softness")]);
    m_softness_isSet = !json[QString("Softness")].isNull() && m_softness_isValid;

    m_spatial_adaptive_quantization_isValid = ::OpenAPI::fromJsonValue(m_spatial_adaptive_quantization, json[QString("SpatialAdaptiveQuantization")]);
    m_spatial_adaptive_quantization_isSet = !json[QString("SpatialAdaptiveQuantization")].isNull() && m_spatial_adaptive_quantization_isValid;

    m_syntax_isValid = ::OpenAPI::fromJsonValue(m_syntax, json[QString("Syntax")]);
    m_syntax_isSet = !json[QString("Syntax")].isNull() && m_syntax_isValid;

    m_telecine_isValid = ::OpenAPI::fromJsonValue(m_telecine, json[QString("Telecine")]);
    m_telecine_isSet = !json[QString("Telecine")].isNull() && m_telecine_isValid;

    m_temporal_adaptive_quantization_isValid = ::OpenAPI::fromJsonValue(m_temporal_adaptive_quantization, json[QString("TemporalAdaptiveQuantization")]);
    m_temporal_adaptive_quantization_isSet = !json[QString("TemporalAdaptiveQuantization")].isNull() && m_temporal_adaptive_quantization_isValid;

    m_unregistered_sei_timecode_isValid = ::OpenAPI::fromJsonValue(m_unregistered_sei_timecode, json[QString("UnregisteredSeiTimecode")]);
    m_unregistered_sei_timecode_isSet = !json[QString("UnregisteredSeiTimecode")].isNull() && m_unregistered_sei_timecode_isValid;
}

QString OAIVideoCodecSettings_H264Settings::asJson() const {
    QJsonObject obj = this->asJsonObject();
    QJsonDocument doc(obj);
    QByteArray bytes = doc.toJson();
    return QString(bytes);
}

QJsonObject OAIVideoCodecSettings_H264Settings::asJsonObject() const {
    QJsonObject obj;
    if (m_adaptive_quantization.isSet()) {
        obj.insert(QString("AdaptiveQuantization"), ::OpenAPI::toJsonValue(m_adaptive_quantization));
    }
    if (m_bandwidth_reduction_filter.isSet()) {
        obj.insert(QString("BandwidthReductionFilter"), ::OpenAPI::toJsonValue(m_bandwidth_reduction_filter));
    }
    if (m_bitrate_isSet) {
        obj.insert(QString("Bitrate"), ::OpenAPI::toJsonValue(m_bitrate));
    }
    if (m_codec_level.isSet()) {
        obj.insert(QString("CodecLevel"), ::OpenAPI::toJsonValue(m_codec_level));
    }
    if (m_codec_profile.isSet()) {
        obj.insert(QString("CodecProfile"), ::OpenAPI::toJsonValue(m_codec_profile));
    }
    if (m_dynamic_sub_gop.isSet()) {
        obj.insert(QString("DynamicSubGop"), ::OpenAPI::toJsonValue(m_dynamic_sub_gop));
    }
    if (m_entropy_encoding.isSet()) {
        obj.insert(QString("EntropyEncoding"), ::OpenAPI::toJsonValue(m_entropy_encoding));
    }
    if (m_field_encoding.isSet()) {
        obj.insert(QString("FieldEncoding"), ::OpenAPI::toJsonValue(m_field_encoding));
    }
    if (m_flicker_adaptive_quantization.isSet()) {
        obj.insert(QString("FlickerAdaptiveQuantization"), ::OpenAPI::toJsonValue(m_flicker_adaptive_quantization));
    }
    if (m_framerate_control.isSet()) {
        obj.insert(QString("FramerateControl"), ::OpenAPI::toJsonValue(m_framerate_control));
    }
    if (m_framerate_conversion_algorithm.isSet()) {
        obj.insert(QString("FramerateConversionAlgorithm"), ::OpenAPI::toJsonValue(m_framerate_conversion_algorithm));
    }
    if (m_framerate_denominator_isSet) {
        obj.insert(QString("FramerateDenominator"), ::OpenAPI::toJsonValue(m_framerate_denominator));
    }
    if (m_framerate_numerator_isSet) {
        obj.insert(QString("FramerateNumerator"), ::OpenAPI::toJsonValue(m_framerate_numerator));
    }
    if (m_gop_b_reference.isSet()) {
        obj.insert(QString("GopBReference"), ::OpenAPI::toJsonValue(m_gop_b_reference));
    }
    if (m_gop_closed_cadence_isSet) {
        obj.insert(QString("GopClosedCadence"), ::OpenAPI::toJsonValue(m_gop_closed_cadence));
    }
    if (m_gop_size_isSet) {
        obj.insert(QString("GopSize"), ::OpenAPI::toJsonValue(m_gop_size));
    }
    if (m_gop_size_units.isSet()) {
        obj.insert(QString("GopSizeUnits"), ::OpenAPI::toJsonValue(m_gop_size_units));
    }
    if (m_hrd_buffer_final_fill_percentage_isSet) {
        obj.insert(QString("HrdBufferFinalFillPercentage"), ::OpenAPI::toJsonValue(m_hrd_buffer_final_fill_percentage));
    }
    if (m_hrd_buffer_initial_fill_percentage_isSet) {
        obj.insert(QString("HrdBufferInitialFillPercentage"), ::OpenAPI::toJsonValue(m_hrd_buffer_initial_fill_percentage));
    }
    if (m_hrd_buffer_size_isSet) {
        obj.insert(QString("HrdBufferSize"), ::OpenAPI::toJsonValue(m_hrd_buffer_size));
    }
    if (m_interlace_mode.isSet()) {
        obj.insert(QString("InterlaceMode"), ::OpenAPI::toJsonValue(m_interlace_mode));
    }
    if (m_max_bitrate_isSet) {
        obj.insert(QString("MaxBitrate"), ::OpenAPI::toJsonValue(m_max_bitrate));
    }
    if (m_min_i_interval_isSet) {
        obj.insert(QString("MinIInterval"), ::OpenAPI::toJsonValue(m_min_i_interval));
    }
    if (m_number_b_frames_between_reference_frames_isSet) {
        obj.insert(QString("NumberBFramesBetweenReferenceFrames"), ::OpenAPI::toJsonValue(m_number_b_frames_between_reference_frames));
    }
    if (m_number_reference_frames_isSet) {
        obj.insert(QString("NumberReferenceFrames"), ::OpenAPI::toJsonValue(m_number_reference_frames));
    }
    if (m_par_control.isSet()) {
        obj.insert(QString("ParControl"), ::OpenAPI::toJsonValue(m_par_control));
    }
    if (m_par_denominator_isSet) {
        obj.insert(QString("ParDenominator"), ::OpenAPI::toJsonValue(m_par_denominator));
    }
    if (m_par_numerator_isSet) {
        obj.insert(QString("ParNumerator"), ::OpenAPI::toJsonValue(m_par_numerator));
    }
    if (m_quality_tuning_level.isSet()) {
        obj.insert(QString("QualityTuningLevel"), ::OpenAPI::toJsonValue(m_quality_tuning_level));
    }
    if (m_qvbr_settings.isSet()) {
        obj.insert(QString("QvbrSettings"), ::OpenAPI::toJsonValue(m_qvbr_settings));
    }
    if (m_rate_control_mode.isSet()) {
        obj.insert(QString("RateControlMode"), ::OpenAPI::toJsonValue(m_rate_control_mode));
    }
    if (m_repeat_pps.isSet()) {
        obj.insert(QString("RepeatPps"), ::OpenAPI::toJsonValue(m_repeat_pps));
    }
    if (m_scan_type_conversion_mode.isSet()) {
        obj.insert(QString("ScanTypeConversionMode"), ::OpenAPI::toJsonValue(m_scan_type_conversion_mode));
    }
    if (m_scene_change_detect.isSet()) {
        obj.insert(QString("SceneChangeDetect"), ::OpenAPI::toJsonValue(m_scene_change_detect));
    }
    if (m_slices_isSet) {
        obj.insert(QString("Slices"), ::OpenAPI::toJsonValue(m_slices));
    }
    if (m_slow_pal.isSet()) {
        obj.insert(QString("SlowPal"), ::OpenAPI::toJsonValue(m_slow_pal));
    }
    if (m_softness_isSet) {
        obj.insert(QString("Softness"), ::OpenAPI::toJsonValue(m_softness));
    }
    if (m_spatial_adaptive_quantization.isSet()) {
        obj.insert(QString("SpatialAdaptiveQuantization"), ::OpenAPI::toJsonValue(m_spatial_adaptive_quantization));
    }
    if (m_syntax.isSet()) {
        obj.insert(QString("Syntax"), ::OpenAPI::toJsonValue(m_syntax));
    }
    if (m_telecine.isSet()) {
        obj.insert(QString("Telecine"), ::OpenAPI::toJsonValue(m_telecine));
    }
    if (m_temporal_adaptive_quantization.isSet()) {
        obj.insert(QString("TemporalAdaptiveQuantization"), ::OpenAPI::toJsonValue(m_temporal_adaptive_quantization));
    }
    if (m_unregistered_sei_timecode.isSet()) {
        obj.insert(QString("UnregisteredSeiTimecode"), ::OpenAPI::toJsonValue(m_unregistered_sei_timecode));
    }
    return obj;
}

OAIH264AdaptiveQuantization OAIVideoCodecSettings_H264Settings::getAdaptiveQuantization() const {
    return m_adaptive_quantization;
}
void OAIVideoCodecSettings_H264Settings::setAdaptiveQuantization(const OAIH264AdaptiveQuantization &adaptive_quantization) {
    m_adaptive_quantization = adaptive_quantization;
    m_adaptive_quantization_isSet = true;
}

bool OAIVideoCodecSettings_H264Settings::is_adaptive_quantization_Set() const{
    return m_adaptive_quantization_isSet;
}

bool OAIVideoCodecSettings_H264Settings::is_adaptive_quantization_Valid() const{
    return m_adaptive_quantization_isValid;
}

OAIH264Settings_BandwidthReductionFilter OAIVideoCodecSettings_H264Settings::getBandwidthReductionFilter() const {
    return m_bandwidth_reduction_filter;
}
void OAIVideoCodecSettings_H264Settings::setBandwidthReductionFilter(const OAIH264Settings_BandwidthReductionFilter &bandwidth_reduction_filter) {
    m_bandwidth_reduction_filter = bandwidth_reduction_filter;
    m_bandwidth_reduction_filter_isSet = true;
}

bool OAIVideoCodecSettings_H264Settings::is_bandwidth_reduction_filter_Set() const{
    return m_bandwidth_reduction_filter_isSet;
}

bool OAIVideoCodecSettings_H264Settings::is_bandwidth_reduction_filter_Valid() const{
    return m_bandwidth_reduction_filter_isValid;
}

qint32 OAIVideoCodecSettings_H264Settings::getBitrate() const {
    return m_bitrate;
}
void OAIVideoCodecSettings_H264Settings::setBitrate(const qint32 &bitrate) {
    m_bitrate = bitrate;
    m_bitrate_isSet = true;
}

bool OAIVideoCodecSettings_H264Settings::is_bitrate_Set() const{
    return m_bitrate_isSet;
}

bool OAIVideoCodecSettings_H264Settings::is_bitrate_Valid() const{
    return m_bitrate_isValid;
}

OAIH264CodecLevel OAIVideoCodecSettings_H264Settings::getCodecLevel() const {
    return m_codec_level;
}
void OAIVideoCodecSettings_H264Settings::setCodecLevel(const OAIH264CodecLevel &codec_level) {
    m_codec_level = codec_level;
    m_codec_level_isSet = true;
}

bool OAIVideoCodecSettings_H264Settings::is_codec_level_Set() const{
    return m_codec_level_isSet;
}

bool OAIVideoCodecSettings_H264Settings::is_codec_level_Valid() const{
    return m_codec_level_isValid;
}

OAIH264CodecProfile OAIVideoCodecSettings_H264Settings::getCodecProfile() const {
    return m_codec_profile;
}
void OAIVideoCodecSettings_H264Settings::setCodecProfile(const OAIH264CodecProfile &codec_profile) {
    m_codec_profile = codec_profile;
    m_codec_profile_isSet = true;
}

bool OAIVideoCodecSettings_H264Settings::is_codec_profile_Set() const{
    return m_codec_profile_isSet;
}

bool OAIVideoCodecSettings_H264Settings::is_codec_profile_Valid() const{
    return m_codec_profile_isValid;
}

OAIH264DynamicSubGop OAIVideoCodecSettings_H264Settings::getDynamicSubGop() const {
    return m_dynamic_sub_gop;
}
void OAIVideoCodecSettings_H264Settings::setDynamicSubGop(const OAIH264DynamicSubGop &dynamic_sub_gop) {
    m_dynamic_sub_gop = dynamic_sub_gop;
    m_dynamic_sub_gop_isSet = true;
}

bool OAIVideoCodecSettings_H264Settings::is_dynamic_sub_gop_Set() const{
    return m_dynamic_sub_gop_isSet;
}

bool OAIVideoCodecSettings_H264Settings::is_dynamic_sub_gop_Valid() const{
    return m_dynamic_sub_gop_isValid;
}

OAIH264EntropyEncoding OAIVideoCodecSettings_H264Settings::getEntropyEncoding() const {
    return m_entropy_encoding;
}
void OAIVideoCodecSettings_H264Settings::setEntropyEncoding(const OAIH264EntropyEncoding &entropy_encoding) {
    m_entropy_encoding = entropy_encoding;
    m_entropy_encoding_isSet = true;
}

bool OAIVideoCodecSettings_H264Settings::is_entropy_encoding_Set() const{
    return m_entropy_encoding_isSet;
}

bool OAIVideoCodecSettings_H264Settings::is_entropy_encoding_Valid() const{
    return m_entropy_encoding_isValid;
}

OAIH264FieldEncoding OAIVideoCodecSettings_H264Settings::getFieldEncoding() const {
    return m_field_encoding;
}
void OAIVideoCodecSettings_H264Settings::setFieldEncoding(const OAIH264FieldEncoding &field_encoding) {
    m_field_encoding = field_encoding;
    m_field_encoding_isSet = true;
}

bool OAIVideoCodecSettings_H264Settings::is_field_encoding_Set() const{
    return m_field_encoding_isSet;
}

bool OAIVideoCodecSettings_H264Settings::is_field_encoding_Valid() const{
    return m_field_encoding_isValid;
}

OAIH264FlickerAdaptiveQuantization OAIVideoCodecSettings_H264Settings::getFlickerAdaptiveQuantization() const {
    return m_flicker_adaptive_quantization;
}
void OAIVideoCodecSettings_H264Settings::setFlickerAdaptiveQuantization(const OAIH264FlickerAdaptiveQuantization &flicker_adaptive_quantization) {
    m_flicker_adaptive_quantization = flicker_adaptive_quantization;
    m_flicker_adaptive_quantization_isSet = true;
}

bool OAIVideoCodecSettings_H264Settings::is_flicker_adaptive_quantization_Set() const{
    return m_flicker_adaptive_quantization_isSet;
}

bool OAIVideoCodecSettings_H264Settings::is_flicker_adaptive_quantization_Valid() const{
    return m_flicker_adaptive_quantization_isValid;
}

OAIH264FramerateControl OAIVideoCodecSettings_H264Settings::getFramerateControl() const {
    return m_framerate_control;
}
void OAIVideoCodecSettings_H264Settings::setFramerateControl(const OAIH264FramerateControl &framerate_control) {
    m_framerate_control = framerate_control;
    m_framerate_control_isSet = true;
}

bool OAIVideoCodecSettings_H264Settings::is_framerate_control_Set() const{
    return m_framerate_control_isSet;
}

bool OAIVideoCodecSettings_H264Settings::is_framerate_control_Valid() const{
    return m_framerate_control_isValid;
}

OAIH264FramerateConversionAlgorithm OAIVideoCodecSettings_H264Settings::getFramerateConversionAlgorithm() const {
    return m_framerate_conversion_algorithm;
}
void OAIVideoCodecSettings_H264Settings::setFramerateConversionAlgorithm(const OAIH264FramerateConversionAlgorithm &framerate_conversion_algorithm) {
    m_framerate_conversion_algorithm = framerate_conversion_algorithm;
    m_framerate_conversion_algorithm_isSet = true;
}

bool OAIVideoCodecSettings_H264Settings::is_framerate_conversion_algorithm_Set() const{
    return m_framerate_conversion_algorithm_isSet;
}

bool OAIVideoCodecSettings_H264Settings::is_framerate_conversion_algorithm_Valid() const{
    return m_framerate_conversion_algorithm_isValid;
}

qint32 OAIVideoCodecSettings_H264Settings::getFramerateDenominator() const {
    return m_framerate_denominator;
}
void OAIVideoCodecSettings_H264Settings::setFramerateDenominator(const qint32 &framerate_denominator) {
    m_framerate_denominator = framerate_denominator;
    m_framerate_denominator_isSet = true;
}

bool OAIVideoCodecSettings_H264Settings::is_framerate_denominator_Set() const{
    return m_framerate_denominator_isSet;
}

bool OAIVideoCodecSettings_H264Settings::is_framerate_denominator_Valid() const{
    return m_framerate_denominator_isValid;
}

qint32 OAIVideoCodecSettings_H264Settings::getFramerateNumerator() const {
    return m_framerate_numerator;
}
void OAIVideoCodecSettings_H264Settings::setFramerateNumerator(const qint32 &framerate_numerator) {
    m_framerate_numerator = framerate_numerator;
    m_framerate_numerator_isSet = true;
}

bool OAIVideoCodecSettings_H264Settings::is_framerate_numerator_Set() const{
    return m_framerate_numerator_isSet;
}

bool OAIVideoCodecSettings_H264Settings::is_framerate_numerator_Valid() const{
    return m_framerate_numerator_isValid;
}

OAIH264GopBReference OAIVideoCodecSettings_H264Settings::getGopBReference() const {
    return m_gop_b_reference;
}
void OAIVideoCodecSettings_H264Settings::setGopBReference(const OAIH264GopBReference &gop_b_reference) {
    m_gop_b_reference = gop_b_reference;
    m_gop_b_reference_isSet = true;
}

bool OAIVideoCodecSettings_H264Settings::is_gop_b_reference_Set() const{
    return m_gop_b_reference_isSet;
}

bool OAIVideoCodecSettings_H264Settings::is_gop_b_reference_Valid() const{
    return m_gop_b_reference_isValid;
}

qint32 OAIVideoCodecSettings_H264Settings::getGopClosedCadence() const {
    return m_gop_closed_cadence;
}
void OAIVideoCodecSettings_H264Settings::setGopClosedCadence(const qint32 &gop_closed_cadence) {
    m_gop_closed_cadence = gop_closed_cadence;
    m_gop_closed_cadence_isSet = true;
}

bool OAIVideoCodecSettings_H264Settings::is_gop_closed_cadence_Set() const{
    return m_gop_closed_cadence_isSet;
}

bool OAIVideoCodecSettings_H264Settings::is_gop_closed_cadence_Valid() const{
    return m_gop_closed_cadence_isValid;
}

double OAIVideoCodecSettings_H264Settings::getGopSize() const {
    return m_gop_size;
}
void OAIVideoCodecSettings_H264Settings::setGopSize(const double &gop_size) {
    m_gop_size = gop_size;
    m_gop_size_isSet = true;
}

bool OAIVideoCodecSettings_H264Settings::is_gop_size_Set() const{
    return m_gop_size_isSet;
}

bool OAIVideoCodecSettings_H264Settings::is_gop_size_Valid() const{
    return m_gop_size_isValid;
}

OAIH264GopSizeUnits OAIVideoCodecSettings_H264Settings::getGopSizeUnits() const {
    return m_gop_size_units;
}
void OAIVideoCodecSettings_H264Settings::setGopSizeUnits(const OAIH264GopSizeUnits &gop_size_units) {
    m_gop_size_units = gop_size_units;
    m_gop_size_units_isSet = true;
}

bool OAIVideoCodecSettings_H264Settings::is_gop_size_units_Set() const{
    return m_gop_size_units_isSet;
}

bool OAIVideoCodecSettings_H264Settings::is_gop_size_units_Valid() const{
    return m_gop_size_units_isValid;
}

qint32 OAIVideoCodecSettings_H264Settings::getHrdBufferFinalFillPercentage() const {
    return m_hrd_buffer_final_fill_percentage;
}
void OAIVideoCodecSettings_H264Settings::setHrdBufferFinalFillPercentage(const qint32 &hrd_buffer_final_fill_percentage) {
    m_hrd_buffer_final_fill_percentage = hrd_buffer_final_fill_percentage;
    m_hrd_buffer_final_fill_percentage_isSet = true;
}

bool OAIVideoCodecSettings_H264Settings::is_hrd_buffer_final_fill_percentage_Set() const{
    return m_hrd_buffer_final_fill_percentage_isSet;
}

bool OAIVideoCodecSettings_H264Settings::is_hrd_buffer_final_fill_percentage_Valid() const{
    return m_hrd_buffer_final_fill_percentage_isValid;
}

qint32 OAIVideoCodecSettings_H264Settings::getHrdBufferInitialFillPercentage() const {
    return m_hrd_buffer_initial_fill_percentage;
}
void OAIVideoCodecSettings_H264Settings::setHrdBufferInitialFillPercentage(const qint32 &hrd_buffer_initial_fill_percentage) {
    m_hrd_buffer_initial_fill_percentage = hrd_buffer_initial_fill_percentage;
    m_hrd_buffer_initial_fill_percentage_isSet = true;
}

bool OAIVideoCodecSettings_H264Settings::is_hrd_buffer_initial_fill_percentage_Set() const{
    return m_hrd_buffer_initial_fill_percentage_isSet;
}

bool OAIVideoCodecSettings_H264Settings::is_hrd_buffer_initial_fill_percentage_Valid() const{
    return m_hrd_buffer_initial_fill_percentage_isValid;
}

qint32 OAIVideoCodecSettings_H264Settings::getHrdBufferSize() const {
    return m_hrd_buffer_size;
}
void OAIVideoCodecSettings_H264Settings::setHrdBufferSize(const qint32 &hrd_buffer_size) {
    m_hrd_buffer_size = hrd_buffer_size;
    m_hrd_buffer_size_isSet = true;
}

bool OAIVideoCodecSettings_H264Settings::is_hrd_buffer_size_Set() const{
    return m_hrd_buffer_size_isSet;
}

bool OAIVideoCodecSettings_H264Settings::is_hrd_buffer_size_Valid() const{
    return m_hrd_buffer_size_isValid;
}

OAIH264InterlaceMode OAIVideoCodecSettings_H264Settings::getInterlaceMode() const {
    return m_interlace_mode;
}
void OAIVideoCodecSettings_H264Settings::setInterlaceMode(const OAIH264InterlaceMode &interlace_mode) {
    m_interlace_mode = interlace_mode;
    m_interlace_mode_isSet = true;
}

bool OAIVideoCodecSettings_H264Settings::is_interlace_mode_Set() const{
    return m_interlace_mode_isSet;
}

bool OAIVideoCodecSettings_H264Settings::is_interlace_mode_Valid() const{
    return m_interlace_mode_isValid;
}

qint32 OAIVideoCodecSettings_H264Settings::getMaxBitrate() const {
    return m_max_bitrate;
}
void OAIVideoCodecSettings_H264Settings::setMaxBitrate(const qint32 &max_bitrate) {
    m_max_bitrate = max_bitrate;
    m_max_bitrate_isSet = true;
}

bool OAIVideoCodecSettings_H264Settings::is_max_bitrate_Set() const{
    return m_max_bitrate_isSet;
}

bool OAIVideoCodecSettings_H264Settings::is_max_bitrate_Valid() const{
    return m_max_bitrate_isValid;
}

qint32 OAIVideoCodecSettings_H264Settings::getMinIInterval() const {
    return m_min_i_interval;
}
void OAIVideoCodecSettings_H264Settings::setMinIInterval(const qint32 &min_i_interval) {
    m_min_i_interval = min_i_interval;
    m_min_i_interval_isSet = true;
}

bool OAIVideoCodecSettings_H264Settings::is_min_i_interval_Set() const{
    return m_min_i_interval_isSet;
}

bool OAIVideoCodecSettings_H264Settings::is_min_i_interval_Valid() const{
    return m_min_i_interval_isValid;
}

qint32 OAIVideoCodecSettings_H264Settings::getNumberBFramesBetweenReferenceFrames() const {
    return m_number_b_frames_between_reference_frames;
}
void OAIVideoCodecSettings_H264Settings::setNumberBFramesBetweenReferenceFrames(const qint32 &number_b_frames_between_reference_frames) {
    m_number_b_frames_between_reference_frames = number_b_frames_between_reference_frames;
    m_number_b_frames_between_reference_frames_isSet = true;
}

bool OAIVideoCodecSettings_H264Settings::is_number_b_frames_between_reference_frames_Set() const{
    return m_number_b_frames_between_reference_frames_isSet;
}

bool OAIVideoCodecSettings_H264Settings::is_number_b_frames_between_reference_frames_Valid() const{
    return m_number_b_frames_between_reference_frames_isValid;
}

qint32 OAIVideoCodecSettings_H264Settings::getNumberReferenceFrames() const {
    return m_number_reference_frames;
}
void OAIVideoCodecSettings_H264Settings::setNumberReferenceFrames(const qint32 &number_reference_frames) {
    m_number_reference_frames = number_reference_frames;
    m_number_reference_frames_isSet = true;
}

bool OAIVideoCodecSettings_H264Settings::is_number_reference_frames_Set() const{
    return m_number_reference_frames_isSet;
}

bool OAIVideoCodecSettings_H264Settings::is_number_reference_frames_Valid() const{
    return m_number_reference_frames_isValid;
}

OAIH264ParControl OAIVideoCodecSettings_H264Settings::getParControl() const {
    return m_par_control;
}
void OAIVideoCodecSettings_H264Settings::setParControl(const OAIH264ParControl &par_control) {
    m_par_control = par_control;
    m_par_control_isSet = true;
}

bool OAIVideoCodecSettings_H264Settings::is_par_control_Set() const{
    return m_par_control_isSet;
}

bool OAIVideoCodecSettings_H264Settings::is_par_control_Valid() const{
    return m_par_control_isValid;
}

qint32 OAIVideoCodecSettings_H264Settings::getParDenominator() const {
    return m_par_denominator;
}
void OAIVideoCodecSettings_H264Settings::setParDenominator(const qint32 &par_denominator) {
    m_par_denominator = par_denominator;
    m_par_denominator_isSet = true;
}

bool OAIVideoCodecSettings_H264Settings::is_par_denominator_Set() const{
    return m_par_denominator_isSet;
}

bool OAIVideoCodecSettings_H264Settings::is_par_denominator_Valid() const{
    return m_par_denominator_isValid;
}

qint32 OAIVideoCodecSettings_H264Settings::getParNumerator() const {
    return m_par_numerator;
}
void OAIVideoCodecSettings_H264Settings::setParNumerator(const qint32 &par_numerator) {
    m_par_numerator = par_numerator;
    m_par_numerator_isSet = true;
}

bool OAIVideoCodecSettings_H264Settings::is_par_numerator_Set() const{
    return m_par_numerator_isSet;
}

bool OAIVideoCodecSettings_H264Settings::is_par_numerator_Valid() const{
    return m_par_numerator_isValid;
}

OAIH264QualityTuningLevel OAIVideoCodecSettings_H264Settings::getQualityTuningLevel() const {
    return m_quality_tuning_level;
}
void OAIVideoCodecSettings_H264Settings::setQualityTuningLevel(const OAIH264QualityTuningLevel &quality_tuning_level) {
    m_quality_tuning_level = quality_tuning_level;
    m_quality_tuning_level_isSet = true;
}

bool OAIVideoCodecSettings_H264Settings::is_quality_tuning_level_Set() const{
    return m_quality_tuning_level_isSet;
}

bool OAIVideoCodecSettings_H264Settings::is_quality_tuning_level_Valid() const{
    return m_quality_tuning_level_isValid;
}

OAIH264Settings_QvbrSettings OAIVideoCodecSettings_H264Settings::getQvbrSettings() const {
    return m_qvbr_settings;
}
void OAIVideoCodecSettings_H264Settings::setQvbrSettings(const OAIH264Settings_QvbrSettings &qvbr_settings) {
    m_qvbr_settings = qvbr_settings;
    m_qvbr_settings_isSet = true;
}

bool OAIVideoCodecSettings_H264Settings::is_qvbr_settings_Set() const{
    return m_qvbr_settings_isSet;
}

bool OAIVideoCodecSettings_H264Settings::is_qvbr_settings_Valid() const{
    return m_qvbr_settings_isValid;
}

OAIH264RateControlMode OAIVideoCodecSettings_H264Settings::getRateControlMode() const {
    return m_rate_control_mode;
}
void OAIVideoCodecSettings_H264Settings::setRateControlMode(const OAIH264RateControlMode &rate_control_mode) {
    m_rate_control_mode = rate_control_mode;
    m_rate_control_mode_isSet = true;
}

bool OAIVideoCodecSettings_H264Settings::is_rate_control_mode_Set() const{
    return m_rate_control_mode_isSet;
}

bool OAIVideoCodecSettings_H264Settings::is_rate_control_mode_Valid() const{
    return m_rate_control_mode_isValid;
}

OAIH264RepeatPps OAIVideoCodecSettings_H264Settings::getRepeatPps() const {
    return m_repeat_pps;
}
void OAIVideoCodecSettings_H264Settings::setRepeatPps(const OAIH264RepeatPps &repeat_pps) {
    m_repeat_pps = repeat_pps;
    m_repeat_pps_isSet = true;
}

bool OAIVideoCodecSettings_H264Settings::is_repeat_pps_Set() const{
    return m_repeat_pps_isSet;
}

bool OAIVideoCodecSettings_H264Settings::is_repeat_pps_Valid() const{
    return m_repeat_pps_isValid;
}

OAIH264ScanTypeConversionMode OAIVideoCodecSettings_H264Settings::getScanTypeConversionMode() const {
    return m_scan_type_conversion_mode;
}
void OAIVideoCodecSettings_H264Settings::setScanTypeConversionMode(const OAIH264ScanTypeConversionMode &scan_type_conversion_mode) {
    m_scan_type_conversion_mode = scan_type_conversion_mode;
    m_scan_type_conversion_mode_isSet = true;
}

bool OAIVideoCodecSettings_H264Settings::is_scan_type_conversion_mode_Set() const{
    return m_scan_type_conversion_mode_isSet;
}

bool OAIVideoCodecSettings_H264Settings::is_scan_type_conversion_mode_Valid() const{
    return m_scan_type_conversion_mode_isValid;
}

OAIH264SceneChangeDetect OAIVideoCodecSettings_H264Settings::getSceneChangeDetect() const {
    return m_scene_change_detect;
}
void OAIVideoCodecSettings_H264Settings::setSceneChangeDetect(const OAIH264SceneChangeDetect &scene_change_detect) {
    m_scene_change_detect = scene_change_detect;
    m_scene_change_detect_isSet = true;
}

bool OAIVideoCodecSettings_H264Settings::is_scene_change_detect_Set() const{
    return m_scene_change_detect_isSet;
}

bool OAIVideoCodecSettings_H264Settings::is_scene_change_detect_Valid() const{
    return m_scene_change_detect_isValid;
}

qint32 OAIVideoCodecSettings_H264Settings::getSlices() const {
    return m_slices;
}
void OAIVideoCodecSettings_H264Settings::setSlices(const qint32 &slices) {
    m_slices = slices;
    m_slices_isSet = true;
}

bool OAIVideoCodecSettings_H264Settings::is_slices_Set() const{
    return m_slices_isSet;
}

bool OAIVideoCodecSettings_H264Settings::is_slices_Valid() const{
    return m_slices_isValid;
}

OAIH264SlowPal OAIVideoCodecSettings_H264Settings::getSlowPal() const {
    return m_slow_pal;
}
void OAIVideoCodecSettings_H264Settings::setSlowPal(const OAIH264SlowPal &slow_pal) {
    m_slow_pal = slow_pal;
    m_slow_pal_isSet = true;
}

bool OAIVideoCodecSettings_H264Settings::is_slow_pal_Set() const{
    return m_slow_pal_isSet;
}

bool OAIVideoCodecSettings_H264Settings::is_slow_pal_Valid() const{
    return m_slow_pal_isValid;
}

qint32 OAIVideoCodecSettings_H264Settings::getSoftness() const {
    return m_softness;
}
void OAIVideoCodecSettings_H264Settings::setSoftness(const qint32 &softness) {
    m_softness = softness;
    m_softness_isSet = true;
}

bool OAIVideoCodecSettings_H264Settings::is_softness_Set() const{
    return m_softness_isSet;
}

bool OAIVideoCodecSettings_H264Settings::is_softness_Valid() const{
    return m_softness_isValid;
}

OAIH264SpatialAdaptiveQuantization OAIVideoCodecSettings_H264Settings::getSpatialAdaptiveQuantization() const {
    return m_spatial_adaptive_quantization;
}
void OAIVideoCodecSettings_H264Settings::setSpatialAdaptiveQuantization(const OAIH264SpatialAdaptiveQuantization &spatial_adaptive_quantization) {
    m_spatial_adaptive_quantization = spatial_adaptive_quantization;
    m_spatial_adaptive_quantization_isSet = true;
}

bool OAIVideoCodecSettings_H264Settings::is_spatial_adaptive_quantization_Set() const{
    return m_spatial_adaptive_quantization_isSet;
}

bool OAIVideoCodecSettings_H264Settings::is_spatial_adaptive_quantization_Valid() const{
    return m_spatial_adaptive_quantization_isValid;
}

OAIH264Syntax OAIVideoCodecSettings_H264Settings::getSyntax() const {
    return m_syntax;
}
void OAIVideoCodecSettings_H264Settings::setSyntax(const OAIH264Syntax &syntax) {
    m_syntax = syntax;
    m_syntax_isSet = true;
}

bool OAIVideoCodecSettings_H264Settings::is_syntax_Set() const{
    return m_syntax_isSet;
}

bool OAIVideoCodecSettings_H264Settings::is_syntax_Valid() const{
    return m_syntax_isValid;
}

OAIH264Telecine OAIVideoCodecSettings_H264Settings::getTelecine() const {
    return m_telecine;
}
void OAIVideoCodecSettings_H264Settings::setTelecine(const OAIH264Telecine &telecine) {
    m_telecine = telecine;
    m_telecine_isSet = true;
}

bool OAIVideoCodecSettings_H264Settings::is_telecine_Set() const{
    return m_telecine_isSet;
}

bool OAIVideoCodecSettings_H264Settings::is_telecine_Valid() const{
    return m_telecine_isValid;
}

OAIH264TemporalAdaptiveQuantization OAIVideoCodecSettings_H264Settings::getTemporalAdaptiveQuantization() const {
    return m_temporal_adaptive_quantization;
}
void OAIVideoCodecSettings_H264Settings::setTemporalAdaptiveQuantization(const OAIH264TemporalAdaptiveQuantization &temporal_adaptive_quantization) {
    m_temporal_adaptive_quantization = temporal_adaptive_quantization;
    m_temporal_adaptive_quantization_isSet = true;
}

bool OAIVideoCodecSettings_H264Settings::is_temporal_adaptive_quantization_Set() const{
    return m_temporal_adaptive_quantization_isSet;
}

bool OAIVideoCodecSettings_H264Settings::is_temporal_adaptive_quantization_Valid() const{
    return m_temporal_adaptive_quantization_isValid;
}

OAIH264UnregisteredSeiTimecode OAIVideoCodecSettings_H264Settings::getUnregisteredSeiTimecode() const {
    return m_unregistered_sei_timecode;
}
void OAIVideoCodecSettings_H264Settings::setUnregisteredSeiTimecode(const OAIH264UnregisteredSeiTimecode &unregistered_sei_timecode) {
    m_unregistered_sei_timecode = unregistered_sei_timecode;
    m_unregistered_sei_timecode_isSet = true;
}

bool OAIVideoCodecSettings_H264Settings::is_unregistered_sei_timecode_Set() const{
    return m_unregistered_sei_timecode_isSet;
}

bool OAIVideoCodecSettings_H264Settings::is_unregistered_sei_timecode_Valid() const{
    return m_unregistered_sei_timecode_isValid;
}

bool OAIVideoCodecSettings_H264Settings::isSet() const {
    bool isObjectUpdated = false;
    do {
        if (m_adaptive_quantization.isSet()) {
            isObjectUpdated = true;
            break;
        }

        if (m_bandwidth_reduction_filter.isSet()) {
            isObjectUpdated = true;
            break;
        }

        if (m_bitrate_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_codec_level.isSet()) {
            isObjectUpdated = true;
            break;
        }

        if (m_codec_profile.isSet()) {
            isObjectUpdated = true;
            break;
        }

        if (m_dynamic_sub_gop.isSet()) {
            isObjectUpdated = true;
            break;
        }

        if (m_entropy_encoding.isSet()) {
            isObjectUpdated = true;
            break;
        }

        if (m_field_encoding.isSet()) {
            isObjectUpdated = true;
            break;
        }

        if (m_flicker_adaptive_quantization.isSet()) {
            isObjectUpdated = true;
            break;
        }

        if (m_framerate_control.isSet()) {
            isObjectUpdated = true;
            break;
        }

        if (m_framerate_conversion_algorithm.isSet()) {
            isObjectUpdated = true;
            break;
        }

        if (m_framerate_denominator_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_framerate_numerator_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_gop_b_reference.isSet()) {
            isObjectUpdated = true;
            break;
        }

        if (m_gop_closed_cadence_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_gop_size_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_gop_size_units.isSet()) {
            isObjectUpdated = true;
            break;
        }

        if (m_hrd_buffer_final_fill_percentage_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_hrd_buffer_initial_fill_percentage_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_hrd_buffer_size_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_interlace_mode.isSet()) {
            isObjectUpdated = true;
            break;
        }

        if (m_max_bitrate_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_min_i_interval_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_number_b_frames_between_reference_frames_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_number_reference_frames_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_par_control.isSet()) {
            isObjectUpdated = true;
            break;
        }

        if (m_par_denominator_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_par_numerator_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_quality_tuning_level.isSet()) {
            isObjectUpdated = true;
            break;
        }

        if (m_qvbr_settings.isSet()) {
            isObjectUpdated = true;
            break;
        }

        if (m_rate_control_mode.isSet()) {
            isObjectUpdated = true;
            break;
        }

        if (m_repeat_pps.isSet()) {
            isObjectUpdated = true;
            break;
        }

        if (m_scan_type_conversion_mode.isSet()) {
            isObjectUpdated = true;
            break;
        }

        if (m_scene_change_detect.isSet()) {
            isObjectUpdated = true;
            break;
        }

        if (m_slices_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_slow_pal.isSet()) {
            isObjectUpdated = true;
            break;
        }

        if (m_softness_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_spatial_adaptive_quantization.isSet()) {
            isObjectUpdated = true;
            break;
        }

        if (m_syntax.isSet()) {
            isObjectUpdated = true;
            break;
        }

        if (m_telecine.isSet()) {
            isObjectUpdated = true;
            break;
        }

        if (m_temporal_adaptive_quantization.isSet()) {
            isObjectUpdated = true;
            break;
        }

        if (m_unregistered_sei_timecode.isSet()) {
            isObjectUpdated = true;
            break;
        }
    } while (false);
    return isObjectUpdated;
}

bool OAIVideoCodecSettings_H264Settings::isValid() const {
    // only required properties are required for the object to be considered valid
    return true;
}

} // namespace OpenAPI
