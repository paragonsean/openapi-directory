/**
 * AWS Elemental MediaConvert
 * AWS Elemental MediaConvert
 *
 * The version of the OpenAPI document: 2017-08-29
 * Contact: mike.ralphson@gmail.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

#include "OAIColorCorrector.h"

#include <QDebug>
#include <QJsonArray>
#include <QJsonDocument>
#include <QObject>

#include "OAIHelpers.h"

namespace OpenAPI {

OAIColorCorrector::OAIColorCorrector(QString json) {
    this->initializeModel();
    this->fromJson(json);
}

OAIColorCorrector::OAIColorCorrector() {
    this->initializeModel();
}

OAIColorCorrector::~OAIColorCorrector() {}

void OAIColorCorrector::initializeModel() {

    m_brightness_isSet = false;
    m_brightness_isValid = false;

    m_clip_limits_isSet = false;
    m_clip_limits_isValid = false;

    m_color_space_conversion_isSet = false;
    m_color_space_conversion_isValid = false;

    m_contrast_isSet = false;
    m_contrast_isValid = false;

    m_hdr10_metadata_isSet = false;
    m_hdr10_metadata_isValid = false;

    m_hdr_to_sdr_tone_mapper_isSet = false;
    m_hdr_to_sdr_tone_mapper_isValid = false;

    m_hue_isSet = false;
    m_hue_isValid = false;

    m_sample_range_conversion_isSet = false;
    m_sample_range_conversion_isValid = false;

    m_saturation_isSet = false;
    m_saturation_isValid = false;

    m_sdr_reference_white_level_isSet = false;
    m_sdr_reference_white_level_isValid = false;
}

void OAIColorCorrector::fromJson(QString jsonString) {
    QByteArray array(jsonString.toStdString().c_str());
    QJsonDocument doc = QJsonDocument::fromJson(array);
    QJsonObject jsonObject = doc.object();
    this->fromJsonObject(jsonObject);
}

void OAIColorCorrector::fromJsonObject(QJsonObject json) {

    m_brightness_isValid = ::OpenAPI::fromJsonValue(m_brightness, json[QString("Brightness")]);
    m_brightness_isSet = !json[QString("Brightness")].isNull() && m_brightness_isValid;

    m_clip_limits_isValid = ::OpenAPI::fromJsonValue(m_clip_limits, json[QString("ClipLimits")]);
    m_clip_limits_isSet = !json[QString("ClipLimits")].isNull() && m_clip_limits_isValid;

    m_color_space_conversion_isValid = ::OpenAPI::fromJsonValue(m_color_space_conversion, json[QString("ColorSpaceConversion")]);
    m_color_space_conversion_isSet = !json[QString("ColorSpaceConversion")].isNull() && m_color_space_conversion_isValid;

    m_contrast_isValid = ::OpenAPI::fromJsonValue(m_contrast, json[QString("Contrast")]);
    m_contrast_isSet = !json[QString("Contrast")].isNull() && m_contrast_isValid;

    m_hdr10_metadata_isValid = ::OpenAPI::fromJsonValue(m_hdr10_metadata, json[QString("Hdr10Metadata")]);
    m_hdr10_metadata_isSet = !json[QString("Hdr10Metadata")].isNull() && m_hdr10_metadata_isValid;

    m_hdr_to_sdr_tone_mapper_isValid = ::OpenAPI::fromJsonValue(m_hdr_to_sdr_tone_mapper, json[QString("HdrToSdrToneMapper")]);
    m_hdr_to_sdr_tone_mapper_isSet = !json[QString("HdrToSdrToneMapper")].isNull() && m_hdr_to_sdr_tone_mapper_isValid;

    m_hue_isValid = ::OpenAPI::fromJsonValue(m_hue, json[QString("Hue")]);
    m_hue_isSet = !json[QString("Hue")].isNull() && m_hue_isValid;

    m_sample_range_conversion_isValid = ::OpenAPI::fromJsonValue(m_sample_range_conversion, json[QString("SampleRangeConversion")]);
    m_sample_range_conversion_isSet = !json[QString("SampleRangeConversion")].isNull() && m_sample_range_conversion_isValid;

    m_saturation_isValid = ::OpenAPI::fromJsonValue(m_saturation, json[QString("Saturation")]);
    m_saturation_isSet = !json[QString("Saturation")].isNull() && m_saturation_isValid;

    m_sdr_reference_white_level_isValid = ::OpenAPI::fromJsonValue(m_sdr_reference_white_level, json[QString("SdrReferenceWhiteLevel")]);
    m_sdr_reference_white_level_isSet = !json[QString("SdrReferenceWhiteLevel")].isNull() && m_sdr_reference_white_level_isValid;
}

QString OAIColorCorrector::asJson() const {
    QJsonObject obj = this->asJsonObject();
    QJsonDocument doc(obj);
    QByteArray bytes = doc.toJson();
    return QString(bytes);
}

QJsonObject OAIColorCorrector::asJsonObject() const {
    QJsonObject obj;
    if (m_brightness_isSet) {
        obj.insert(QString("Brightness"), ::OpenAPI::toJsonValue(m_brightness));
    }
    if (m_clip_limits.isSet()) {
        obj.insert(QString("ClipLimits"), ::OpenAPI::toJsonValue(m_clip_limits));
    }
    if (m_color_space_conversion.isSet()) {
        obj.insert(QString("ColorSpaceConversion"), ::OpenAPI::toJsonValue(m_color_space_conversion));
    }
    if (m_contrast_isSet) {
        obj.insert(QString("Contrast"), ::OpenAPI::toJsonValue(m_contrast));
    }
    if (m_hdr10_metadata.isSet()) {
        obj.insert(QString("Hdr10Metadata"), ::OpenAPI::toJsonValue(m_hdr10_metadata));
    }
    if (m_hdr_to_sdr_tone_mapper.isSet()) {
        obj.insert(QString("HdrToSdrToneMapper"), ::OpenAPI::toJsonValue(m_hdr_to_sdr_tone_mapper));
    }
    if (m_hue_isSet) {
        obj.insert(QString("Hue"), ::OpenAPI::toJsonValue(m_hue));
    }
    if (m_sample_range_conversion.isSet()) {
        obj.insert(QString("SampleRangeConversion"), ::OpenAPI::toJsonValue(m_sample_range_conversion));
    }
    if (m_saturation_isSet) {
        obj.insert(QString("Saturation"), ::OpenAPI::toJsonValue(m_saturation));
    }
    if (m_sdr_reference_white_level_isSet) {
        obj.insert(QString("SdrReferenceWhiteLevel"), ::OpenAPI::toJsonValue(m_sdr_reference_white_level));
    }
    return obj;
}

qint32 OAIColorCorrector::getBrightness() const {
    return m_brightness;
}
void OAIColorCorrector::setBrightness(const qint32 &brightness) {
    m_brightness = brightness;
    m_brightness_isSet = true;
}

bool OAIColorCorrector::is_brightness_Set() const{
    return m_brightness_isSet;
}

bool OAIColorCorrector::is_brightness_Valid() const{
    return m_brightness_isValid;
}

OAIColorCorrector_ClipLimits OAIColorCorrector::getClipLimits() const {
    return m_clip_limits;
}
void OAIColorCorrector::setClipLimits(const OAIColorCorrector_ClipLimits &clip_limits) {
    m_clip_limits = clip_limits;
    m_clip_limits_isSet = true;
}

bool OAIColorCorrector::is_clip_limits_Set() const{
    return m_clip_limits_isSet;
}

bool OAIColorCorrector::is_clip_limits_Valid() const{
    return m_clip_limits_isValid;
}

OAIColorSpaceConversion OAIColorCorrector::getColorSpaceConversion() const {
    return m_color_space_conversion;
}
void OAIColorCorrector::setColorSpaceConversion(const OAIColorSpaceConversion &color_space_conversion) {
    m_color_space_conversion = color_space_conversion;
    m_color_space_conversion_isSet = true;
}

bool OAIColorCorrector::is_color_space_conversion_Set() const{
    return m_color_space_conversion_isSet;
}

bool OAIColorCorrector::is_color_space_conversion_Valid() const{
    return m_color_space_conversion_isValid;
}

qint32 OAIColorCorrector::getContrast() const {
    return m_contrast;
}
void OAIColorCorrector::setContrast(const qint32 &contrast) {
    m_contrast = contrast;
    m_contrast_isSet = true;
}

bool OAIColorCorrector::is_contrast_Set() const{
    return m_contrast_isSet;
}

bool OAIColorCorrector::is_contrast_Valid() const{
    return m_contrast_isValid;
}

OAIColorCorrector_Hdr10Metadata OAIColorCorrector::getHdr10Metadata() const {
    return m_hdr10_metadata;
}
void OAIColorCorrector::setHdr10Metadata(const OAIColorCorrector_Hdr10Metadata &hdr10_metadata) {
    m_hdr10_metadata = hdr10_metadata;
    m_hdr10_metadata_isSet = true;
}

bool OAIColorCorrector::is_hdr10_metadata_Set() const{
    return m_hdr10_metadata_isSet;
}

bool OAIColorCorrector::is_hdr10_metadata_Valid() const{
    return m_hdr10_metadata_isValid;
}

OAIHDRToSDRToneMapper OAIColorCorrector::getHdrToSdrToneMapper() const {
    return m_hdr_to_sdr_tone_mapper;
}
void OAIColorCorrector::setHdrToSdrToneMapper(const OAIHDRToSDRToneMapper &hdr_to_sdr_tone_mapper) {
    m_hdr_to_sdr_tone_mapper = hdr_to_sdr_tone_mapper;
    m_hdr_to_sdr_tone_mapper_isSet = true;
}

bool OAIColorCorrector::is_hdr_to_sdr_tone_mapper_Set() const{
    return m_hdr_to_sdr_tone_mapper_isSet;
}

bool OAIColorCorrector::is_hdr_to_sdr_tone_mapper_Valid() const{
    return m_hdr_to_sdr_tone_mapper_isValid;
}

qint32 OAIColorCorrector::getHue() const {
    return m_hue;
}
void OAIColorCorrector::setHue(const qint32 &hue) {
    m_hue = hue;
    m_hue_isSet = true;
}

bool OAIColorCorrector::is_hue_Set() const{
    return m_hue_isSet;
}

bool OAIColorCorrector::is_hue_Valid() const{
    return m_hue_isValid;
}

OAISampleRangeConversion OAIColorCorrector::getSampleRangeConversion() const {
    return m_sample_range_conversion;
}
void OAIColorCorrector::setSampleRangeConversion(const OAISampleRangeConversion &sample_range_conversion) {
    m_sample_range_conversion = sample_range_conversion;
    m_sample_range_conversion_isSet = true;
}

bool OAIColorCorrector::is_sample_range_conversion_Set() const{
    return m_sample_range_conversion_isSet;
}

bool OAIColorCorrector::is_sample_range_conversion_Valid() const{
    return m_sample_range_conversion_isValid;
}

qint32 OAIColorCorrector::getSaturation() const {
    return m_saturation;
}
void OAIColorCorrector::setSaturation(const qint32 &saturation) {
    m_saturation = saturation;
    m_saturation_isSet = true;
}

bool OAIColorCorrector::is_saturation_Set() const{
    return m_saturation_isSet;
}

bool OAIColorCorrector::is_saturation_Valid() const{
    return m_saturation_isValid;
}

qint32 OAIColorCorrector::getSdrReferenceWhiteLevel() const {
    return m_sdr_reference_white_level;
}
void OAIColorCorrector::setSdrReferenceWhiteLevel(const qint32 &sdr_reference_white_level) {
    m_sdr_reference_white_level = sdr_reference_white_level;
    m_sdr_reference_white_level_isSet = true;
}

bool OAIColorCorrector::is_sdr_reference_white_level_Set() const{
    return m_sdr_reference_white_level_isSet;
}

bool OAIColorCorrector::is_sdr_reference_white_level_Valid() const{
    return m_sdr_reference_white_level_isValid;
}

bool OAIColorCorrector::isSet() const {
    bool isObjectUpdated = false;
    do {
        if (m_brightness_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_clip_limits.isSet()) {
            isObjectUpdated = true;
            break;
        }

        if (m_color_space_conversion.isSet()) {
            isObjectUpdated = true;
            break;
        }

        if (m_contrast_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_hdr10_metadata.isSet()) {
            isObjectUpdated = true;
            break;
        }

        if (m_hdr_to_sdr_tone_mapper.isSet()) {
            isObjectUpdated = true;
            break;
        }

        if (m_hue_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_sample_range_conversion.isSet()) {
            isObjectUpdated = true;
            break;
        }

        if (m_saturation_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_sdr_reference_white_level_isSet) {
            isObjectUpdated = true;
            break;
        }
    } while (false);
    return isObjectUpdated;
}

bool OAIColorCorrector::isValid() const {
    // only required properties are required for the object to be considered valid
    return true;
}

} // namespace OpenAPI
