/*
 * AWS Elemental MediaConvert
 * AWS Elemental MediaConvert
 *
 * The version of the OpenAPI document: 2017-08-29
 * Contact: mike.ralphson@gmail.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package org.openapitools.client.model;

import java.util.Objects;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;
import java.util.Arrays;
import org.openapitools.client.model.H264SettingsBandwidthReductionFilter;
import org.openapitools.client.model.H265AdaptiveQuantization;
import org.openapitools.client.model.H265AlternateTransferFunctionSei;
import org.openapitools.client.model.H265CodecLevel;
import org.openapitools.client.model.H265CodecProfile;
import org.openapitools.client.model.H265DynamicSubGop;
import org.openapitools.client.model.H265FlickerAdaptiveQuantization;
import org.openapitools.client.model.H265FramerateControl;
import org.openapitools.client.model.H265FramerateConversionAlgorithm;
import org.openapitools.client.model.H265GopBReference;
import org.openapitools.client.model.H265GopSizeUnits;
import org.openapitools.client.model.H265InterlaceMode;
import org.openapitools.client.model.H265ParControl;
import org.openapitools.client.model.H265QualityTuningLevel;
import org.openapitools.client.model.H265RateControlMode;
import org.openapitools.client.model.H265SampleAdaptiveOffsetFilterMode;
import org.openapitools.client.model.H265ScanTypeConversionMode;
import org.openapitools.client.model.H265SceneChangeDetect;
import org.openapitools.client.model.H265SettingsQvbrSettings;
import org.openapitools.client.model.H265SlowPal;
import org.openapitools.client.model.H265SpatialAdaptiveQuantization;
import org.openapitools.client.model.H265Telecine;
import org.openapitools.client.model.H265TemporalAdaptiveQuantization;
import org.openapitools.client.model.H265TemporalIds;
import org.openapitools.client.model.H265Tiles;
import org.openapitools.client.model.H265UnregisteredSeiTimecode;
import org.openapitools.client.model.H265WriteMp4PackagingType;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonArray;
import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;
import com.google.gson.TypeAdapterFactory;
import com.google.gson.reflect.TypeToken;
import com.google.gson.TypeAdapter;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;

import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import org.openapitools.client.JSON;

/**
 * VideoCodecSettingsH265Settings
 */
@javax.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen", date = "2024-10-12T12:24:13.098140-04:00[America/New_York]", comments = "Generator version: 7.9.0")
public class VideoCodecSettingsH265Settings {
  public static final String SERIALIZED_NAME_ADAPTIVE_QUANTIZATION = "AdaptiveQuantization";
  @SerializedName(SERIALIZED_NAME_ADAPTIVE_QUANTIZATION)
  private H265AdaptiveQuantization adaptiveQuantization;

  public static final String SERIALIZED_NAME_ALTERNATE_TRANSFER_FUNCTION_SEI = "AlternateTransferFunctionSei";
  @SerializedName(SERIALIZED_NAME_ALTERNATE_TRANSFER_FUNCTION_SEI)
  private H265AlternateTransferFunctionSei alternateTransferFunctionSei;

  public static final String SERIALIZED_NAME_BANDWIDTH_REDUCTION_FILTER = "BandwidthReductionFilter";
  @SerializedName(SERIALIZED_NAME_BANDWIDTH_REDUCTION_FILTER)
  private H264SettingsBandwidthReductionFilter bandwidthReductionFilter;

  public static final String SERIALIZED_NAME_BITRATE = "Bitrate";
  @SerializedName(SERIALIZED_NAME_BITRATE)
  private Integer bitrate;

  public static final String SERIALIZED_NAME_CODEC_LEVEL = "CodecLevel";
  @SerializedName(SERIALIZED_NAME_CODEC_LEVEL)
  private H265CodecLevel codecLevel;

  public static final String SERIALIZED_NAME_CODEC_PROFILE = "CodecProfile";
  @SerializedName(SERIALIZED_NAME_CODEC_PROFILE)
  private H265CodecProfile codecProfile;

  public static final String SERIALIZED_NAME_DYNAMIC_SUB_GOP = "DynamicSubGop";
  @SerializedName(SERIALIZED_NAME_DYNAMIC_SUB_GOP)
  private H265DynamicSubGop dynamicSubGop;

  public static final String SERIALIZED_NAME_FLICKER_ADAPTIVE_QUANTIZATION = "FlickerAdaptiveQuantization";
  @SerializedName(SERIALIZED_NAME_FLICKER_ADAPTIVE_QUANTIZATION)
  private H265FlickerAdaptiveQuantization flickerAdaptiveQuantization;

  public static final String SERIALIZED_NAME_FRAMERATE_CONTROL = "FramerateControl";
  @SerializedName(SERIALIZED_NAME_FRAMERATE_CONTROL)
  private H265FramerateControl framerateControl;

  public static final String SERIALIZED_NAME_FRAMERATE_CONVERSION_ALGORITHM = "FramerateConversionAlgorithm";
  @SerializedName(SERIALIZED_NAME_FRAMERATE_CONVERSION_ALGORITHM)
  private H265FramerateConversionAlgorithm framerateConversionAlgorithm;

  public static final String SERIALIZED_NAME_FRAMERATE_DENOMINATOR = "FramerateDenominator";
  @SerializedName(SERIALIZED_NAME_FRAMERATE_DENOMINATOR)
  private Integer framerateDenominator;

  public static final String SERIALIZED_NAME_FRAMERATE_NUMERATOR = "FramerateNumerator";
  @SerializedName(SERIALIZED_NAME_FRAMERATE_NUMERATOR)
  private Integer framerateNumerator;

  public static final String SERIALIZED_NAME_GOP_B_REFERENCE = "GopBReference";
  @SerializedName(SERIALIZED_NAME_GOP_B_REFERENCE)
  private H265GopBReference gopBReference;

  public static final String SERIALIZED_NAME_GOP_CLOSED_CADENCE = "GopClosedCadence";
  @SerializedName(SERIALIZED_NAME_GOP_CLOSED_CADENCE)
  private Integer gopClosedCadence;

  public static final String SERIALIZED_NAME_GOP_SIZE = "GopSize";
  @SerializedName(SERIALIZED_NAME_GOP_SIZE)
  private Double gopSize;

  public static final String SERIALIZED_NAME_GOP_SIZE_UNITS = "GopSizeUnits";
  @SerializedName(SERIALIZED_NAME_GOP_SIZE_UNITS)
  private H265GopSizeUnits gopSizeUnits;

  public static final String SERIALIZED_NAME_HRD_BUFFER_FINAL_FILL_PERCENTAGE = "HrdBufferFinalFillPercentage";
  @SerializedName(SERIALIZED_NAME_HRD_BUFFER_FINAL_FILL_PERCENTAGE)
  private Integer hrdBufferFinalFillPercentage;

  public static final String SERIALIZED_NAME_HRD_BUFFER_INITIAL_FILL_PERCENTAGE = "HrdBufferInitialFillPercentage";
  @SerializedName(SERIALIZED_NAME_HRD_BUFFER_INITIAL_FILL_PERCENTAGE)
  private Integer hrdBufferInitialFillPercentage;

  public static final String SERIALIZED_NAME_HRD_BUFFER_SIZE = "HrdBufferSize";
  @SerializedName(SERIALIZED_NAME_HRD_BUFFER_SIZE)
  private Integer hrdBufferSize;

  public static final String SERIALIZED_NAME_INTERLACE_MODE = "InterlaceMode";
  @SerializedName(SERIALIZED_NAME_INTERLACE_MODE)
  private H265InterlaceMode interlaceMode;

  public static final String SERIALIZED_NAME_MAX_BITRATE = "MaxBitrate";
  @SerializedName(SERIALIZED_NAME_MAX_BITRATE)
  private Integer maxBitrate;

  public static final String SERIALIZED_NAME_MIN_I_INTERVAL = "MinIInterval";
  @SerializedName(SERIALIZED_NAME_MIN_I_INTERVAL)
  private Integer minIInterval;

  public static final String SERIALIZED_NAME_NUMBER_B_FRAMES_BETWEEN_REFERENCE_FRAMES = "NumberBFramesBetweenReferenceFrames";
  @SerializedName(SERIALIZED_NAME_NUMBER_B_FRAMES_BETWEEN_REFERENCE_FRAMES)
  private Integer numberBFramesBetweenReferenceFrames;

  public static final String SERIALIZED_NAME_NUMBER_REFERENCE_FRAMES = "NumberReferenceFrames";
  @SerializedName(SERIALIZED_NAME_NUMBER_REFERENCE_FRAMES)
  private Integer numberReferenceFrames;

  public static final String SERIALIZED_NAME_PAR_CONTROL = "ParControl";
  @SerializedName(SERIALIZED_NAME_PAR_CONTROL)
  private H265ParControl parControl;

  public static final String SERIALIZED_NAME_PAR_DENOMINATOR = "ParDenominator";
  @SerializedName(SERIALIZED_NAME_PAR_DENOMINATOR)
  private Integer parDenominator;

  public static final String SERIALIZED_NAME_PAR_NUMERATOR = "ParNumerator";
  @SerializedName(SERIALIZED_NAME_PAR_NUMERATOR)
  private Integer parNumerator;

  public static final String SERIALIZED_NAME_QUALITY_TUNING_LEVEL = "QualityTuningLevel";
  @SerializedName(SERIALIZED_NAME_QUALITY_TUNING_LEVEL)
  private H265QualityTuningLevel qualityTuningLevel;

  public static final String SERIALIZED_NAME_QVBR_SETTINGS = "QvbrSettings";
  @SerializedName(SERIALIZED_NAME_QVBR_SETTINGS)
  private H265SettingsQvbrSettings qvbrSettings;

  public static final String SERIALIZED_NAME_RATE_CONTROL_MODE = "RateControlMode";
  @SerializedName(SERIALIZED_NAME_RATE_CONTROL_MODE)
  private H265RateControlMode rateControlMode;

  public static final String SERIALIZED_NAME_SAMPLE_ADAPTIVE_OFFSET_FILTER_MODE = "SampleAdaptiveOffsetFilterMode";
  @SerializedName(SERIALIZED_NAME_SAMPLE_ADAPTIVE_OFFSET_FILTER_MODE)
  private H265SampleAdaptiveOffsetFilterMode sampleAdaptiveOffsetFilterMode;

  public static final String SERIALIZED_NAME_SCAN_TYPE_CONVERSION_MODE = "ScanTypeConversionMode";
  @SerializedName(SERIALIZED_NAME_SCAN_TYPE_CONVERSION_MODE)
  private H265ScanTypeConversionMode scanTypeConversionMode;

  public static final String SERIALIZED_NAME_SCENE_CHANGE_DETECT = "SceneChangeDetect";
  @SerializedName(SERIALIZED_NAME_SCENE_CHANGE_DETECT)
  private H265SceneChangeDetect sceneChangeDetect;

  public static final String SERIALIZED_NAME_SLICES = "Slices";
  @SerializedName(SERIALIZED_NAME_SLICES)
  private Integer slices;

  public static final String SERIALIZED_NAME_SLOW_PAL = "SlowPal";
  @SerializedName(SERIALIZED_NAME_SLOW_PAL)
  private H265SlowPal slowPal;

  public static final String SERIALIZED_NAME_SPATIAL_ADAPTIVE_QUANTIZATION = "SpatialAdaptiveQuantization";
  @SerializedName(SERIALIZED_NAME_SPATIAL_ADAPTIVE_QUANTIZATION)
  private H265SpatialAdaptiveQuantization spatialAdaptiveQuantization;

  public static final String SERIALIZED_NAME_TELECINE = "Telecine";
  @SerializedName(SERIALIZED_NAME_TELECINE)
  private H265Telecine telecine;

  public static final String SERIALIZED_NAME_TEMPORAL_ADAPTIVE_QUANTIZATION = "TemporalAdaptiveQuantization";
  @SerializedName(SERIALIZED_NAME_TEMPORAL_ADAPTIVE_QUANTIZATION)
  private H265TemporalAdaptiveQuantization temporalAdaptiveQuantization;

  public static final String SERIALIZED_NAME_TEMPORAL_IDS = "TemporalIds";
  @SerializedName(SERIALIZED_NAME_TEMPORAL_IDS)
  private H265TemporalIds temporalIds;

  public static final String SERIALIZED_NAME_TILES = "Tiles";
  @SerializedName(SERIALIZED_NAME_TILES)
  private H265Tiles tiles;

  public static final String SERIALIZED_NAME_UNREGISTERED_SEI_TIMECODE = "UnregisteredSeiTimecode";
  @SerializedName(SERIALIZED_NAME_UNREGISTERED_SEI_TIMECODE)
  private H265UnregisteredSeiTimecode unregisteredSeiTimecode;

  public static final String SERIALIZED_NAME_WRITE_MP4_PACKAGING_TYPE = "WriteMp4PackagingType";
  @SerializedName(SERIALIZED_NAME_WRITE_MP4_PACKAGING_TYPE)
  private H265WriteMp4PackagingType writeMp4PackagingType;

  public VideoCodecSettingsH265Settings() {
  }

  public VideoCodecSettingsH265Settings adaptiveQuantization(H265AdaptiveQuantization adaptiveQuantization) {
    this.adaptiveQuantization = adaptiveQuantization;
    return this;
  }

  /**
   * Get adaptiveQuantization
   * @return adaptiveQuantization
   */
  @javax.annotation.Nullable
  public H265AdaptiveQuantization getAdaptiveQuantization() {
    return adaptiveQuantization;
  }

  public void setAdaptiveQuantization(H265AdaptiveQuantization adaptiveQuantization) {
    this.adaptiveQuantization = adaptiveQuantization;
  }


  public VideoCodecSettingsH265Settings alternateTransferFunctionSei(H265AlternateTransferFunctionSei alternateTransferFunctionSei) {
    this.alternateTransferFunctionSei = alternateTransferFunctionSei;
    return this;
  }

  /**
   * Get alternateTransferFunctionSei
   * @return alternateTransferFunctionSei
   */
  @javax.annotation.Nullable
  public H265AlternateTransferFunctionSei getAlternateTransferFunctionSei() {
    return alternateTransferFunctionSei;
  }

  public void setAlternateTransferFunctionSei(H265AlternateTransferFunctionSei alternateTransferFunctionSei) {
    this.alternateTransferFunctionSei = alternateTransferFunctionSei;
  }


  public VideoCodecSettingsH265Settings bandwidthReductionFilter(H264SettingsBandwidthReductionFilter bandwidthReductionFilter) {
    this.bandwidthReductionFilter = bandwidthReductionFilter;
    return this;
  }

  /**
   * Get bandwidthReductionFilter
   * @return bandwidthReductionFilter
   */
  @javax.annotation.Nullable
  public H264SettingsBandwidthReductionFilter getBandwidthReductionFilter() {
    return bandwidthReductionFilter;
  }

  public void setBandwidthReductionFilter(H264SettingsBandwidthReductionFilter bandwidthReductionFilter) {
    this.bandwidthReductionFilter = bandwidthReductionFilter;
  }


  public VideoCodecSettingsH265Settings bitrate(Integer bitrate) {
    this.bitrate = bitrate;
    return this;
  }

  /**
   * Get bitrate
   * @return bitrate
   */
  @javax.annotation.Nullable
  public Integer getBitrate() {
    return bitrate;
  }

  public void setBitrate(Integer bitrate) {
    this.bitrate = bitrate;
  }


  public VideoCodecSettingsH265Settings codecLevel(H265CodecLevel codecLevel) {
    this.codecLevel = codecLevel;
    return this;
  }

  /**
   * Get codecLevel
   * @return codecLevel
   */
  @javax.annotation.Nullable
  public H265CodecLevel getCodecLevel() {
    return codecLevel;
  }

  public void setCodecLevel(H265CodecLevel codecLevel) {
    this.codecLevel = codecLevel;
  }


  public VideoCodecSettingsH265Settings codecProfile(H265CodecProfile codecProfile) {
    this.codecProfile = codecProfile;
    return this;
  }

  /**
   * Get codecProfile
   * @return codecProfile
   */
  @javax.annotation.Nullable
  public H265CodecProfile getCodecProfile() {
    return codecProfile;
  }

  public void setCodecProfile(H265CodecProfile codecProfile) {
    this.codecProfile = codecProfile;
  }


  public VideoCodecSettingsH265Settings dynamicSubGop(H265DynamicSubGop dynamicSubGop) {
    this.dynamicSubGop = dynamicSubGop;
    return this;
  }

  /**
   * Get dynamicSubGop
   * @return dynamicSubGop
   */
  @javax.annotation.Nullable
  public H265DynamicSubGop getDynamicSubGop() {
    return dynamicSubGop;
  }

  public void setDynamicSubGop(H265DynamicSubGop dynamicSubGop) {
    this.dynamicSubGop = dynamicSubGop;
  }


  public VideoCodecSettingsH265Settings flickerAdaptiveQuantization(H265FlickerAdaptiveQuantization flickerAdaptiveQuantization) {
    this.flickerAdaptiveQuantization = flickerAdaptiveQuantization;
    return this;
  }

  /**
   * Get flickerAdaptiveQuantization
   * @return flickerAdaptiveQuantization
   */
  @javax.annotation.Nullable
  public H265FlickerAdaptiveQuantization getFlickerAdaptiveQuantization() {
    return flickerAdaptiveQuantization;
  }

  public void setFlickerAdaptiveQuantization(H265FlickerAdaptiveQuantization flickerAdaptiveQuantization) {
    this.flickerAdaptiveQuantization = flickerAdaptiveQuantization;
  }


  public VideoCodecSettingsH265Settings framerateControl(H265FramerateControl framerateControl) {
    this.framerateControl = framerateControl;
    return this;
  }

  /**
   * Get framerateControl
   * @return framerateControl
   */
  @javax.annotation.Nullable
  public H265FramerateControl getFramerateControl() {
    return framerateControl;
  }

  public void setFramerateControl(H265FramerateControl framerateControl) {
    this.framerateControl = framerateControl;
  }


  public VideoCodecSettingsH265Settings framerateConversionAlgorithm(H265FramerateConversionAlgorithm framerateConversionAlgorithm) {
    this.framerateConversionAlgorithm = framerateConversionAlgorithm;
    return this;
  }

  /**
   * Get framerateConversionAlgorithm
   * @return framerateConversionAlgorithm
   */
  @javax.annotation.Nullable
  public H265FramerateConversionAlgorithm getFramerateConversionAlgorithm() {
    return framerateConversionAlgorithm;
  }

  public void setFramerateConversionAlgorithm(H265FramerateConversionAlgorithm framerateConversionAlgorithm) {
    this.framerateConversionAlgorithm = framerateConversionAlgorithm;
  }


  public VideoCodecSettingsH265Settings framerateDenominator(Integer framerateDenominator) {
    this.framerateDenominator = framerateDenominator;
    return this;
  }

  /**
   * Get framerateDenominator
   * @return framerateDenominator
   */
  @javax.annotation.Nullable
  public Integer getFramerateDenominator() {
    return framerateDenominator;
  }

  public void setFramerateDenominator(Integer framerateDenominator) {
    this.framerateDenominator = framerateDenominator;
  }


  public VideoCodecSettingsH265Settings framerateNumerator(Integer framerateNumerator) {
    this.framerateNumerator = framerateNumerator;
    return this;
  }

  /**
   * Get framerateNumerator
   * @return framerateNumerator
   */
  @javax.annotation.Nullable
  public Integer getFramerateNumerator() {
    return framerateNumerator;
  }

  public void setFramerateNumerator(Integer framerateNumerator) {
    this.framerateNumerator = framerateNumerator;
  }


  public VideoCodecSettingsH265Settings gopBReference(H265GopBReference gopBReference) {
    this.gopBReference = gopBReference;
    return this;
  }

  /**
   * Get gopBReference
   * @return gopBReference
   */
  @javax.annotation.Nullable
  public H265GopBReference getGopBReference() {
    return gopBReference;
  }

  public void setGopBReference(H265GopBReference gopBReference) {
    this.gopBReference = gopBReference;
  }


  public VideoCodecSettingsH265Settings gopClosedCadence(Integer gopClosedCadence) {
    this.gopClosedCadence = gopClosedCadence;
    return this;
  }

  /**
   * Get gopClosedCadence
   * @return gopClosedCadence
   */
  @javax.annotation.Nullable
  public Integer getGopClosedCadence() {
    return gopClosedCadence;
  }

  public void setGopClosedCadence(Integer gopClosedCadence) {
    this.gopClosedCadence = gopClosedCadence;
  }


  public VideoCodecSettingsH265Settings gopSize(Double gopSize) {
    this.gopSize = gopSize;
    return this;
  }

  /**
   * Get gopSize
   * @return gopSize
   */
  @javax.annotation.Nullable
  public Double getGopSize() {
    return gopSize;
  }

  public void setGopSize(Double gopSize) {
    this.gopSize = gopSize;
  }


  public VideoCodecSettingsH265Settings gopSizeUnits(H265GopSizeUnits gopSizeUnits) {
    this.gopSizeUnits = gopSizeUnits;
    return this;
  }

  /**
   * Get gopSizeUnits
   * @return gopSizeUnits
   */
  @javax.annotation.Nullable
  public H265GopSizeUnits getGopSizeUnits() {
    return gopSizeUnits;
  }

  public void setGopSizeUnits(H265GopSizeUnits gopSizeUnits) {
    this.gopSizeUnits = gopSizeUnits;
  }


  public VideoCodecSettingsH265Settings hrdBufferFinalFillPercentage(Integer hrdBufferFinalFillPercentage) {
    this.hrdBufferFinalFillPercentage = hrdBufferFinalFillPercentage;
    return this;
  }

  /**
   * Get hrdBufferFinalFillPercentage
   * @return hrdBufferFinalFillPercentage
   */
  @javax.annotation.Nullable
  public Integer getHrdBufferFinalFillPercentage() {
    return hrdBufferFinalFillPercentage;
  }

  public void setHrdBufferFinalFillPercentage(Integer hrdBufferFinalFillPercentage) {
    this.hrdBufferFinalFillPercentage = hrdBufferFinalFillPercentage;
  }


  public VideoCodecSettingsH265Settings hrdBufferInitialFillPercentage(Integer hrdBufferInitialFillPercentage) {
    this.hrdBufferInitialFillPercentage = hrdBufferInitialFillPercentage;
    return this;
  }

  /**
   * Get hrdBufferInitialFillPercentage
   * @return hrdBufferInitialFillPercentage
   */
  @javax.annotation.Nullable
  public Integer getHrdBufferInitialFillPercentage() {
    return hrdBufferInitialFillPercentage;
  }

  public void setHrdBufferInitialFillPercentage(Integer hrdBufferInitialFillPercentage) {
    this.hrdBufferInitialFillPercentage = hrdBufferInitialFillPercentage;
  }


  public VideoCodecSettingsH265Settings hrdBufferSize(Integer hrdBufferSize) {
    this.hrdBufferSize = hrdBufferSize;
    return this;
  }

  /**
   * Get hrdBufferSize
   * @return hrdBufferSize
   */
  @javax.annotation.Nullable
  public Integer getHrdBufferSize() {
    return hrdBufferSize;
  }

  public void setHrdBufferSize(Integer hrdBufferSize) {
    this.hrdBufferSize = hrdBufferSize;
  }


  public VideoCodecSettingsH265Settings interlaceMode(H265InterlaceMode interlaceMode) {
    this.interlaceMode = interlaceMode;
    return this;
  }

  /**
   * Get interlaceMode
   * @return interlaceMode
   */
  @javax.annotation.Nullable
  public H265InterlaceMode getInterlaceMode() {
    return interlaceMode;
  }

  public void setInterlaceMode(H265InterlaceMode interlaceMode) {
    this.interlaceMode = interlaceMode;
  }


  public VideoCodecSettingsH265Settings maxBitrate(Integer maxBitrate) {
    this.maxBitrate = maxBitrate;
    return this;
  }

  /**
   * Get maxBitrate
   * @return maxBitrate
   */
  @javax.annotation.Nullable
  public Integer getMaxBitrate() {
    return maxBitrate;
  }

  public void setMaxBitrate(Integer maxBitrate) {
    this.maxBitrate = maxBitrate;
  }


  public VideoCodecSettingsH265Settings minIInterval(Integer minIInterval) {
    this.minIInterval = minIInterval;
    return this;
  }

  /**
   * Get minIInterval
   * @return minIInterval
   */
  @javax.annotation.Nullable
  public Integer getMinIInterval() {
    return minIInterval;
  }

  public void setMinIInterval(Integer minIInterval) {
    this.minIInterval = minIInterval;
  }


  public VideoCodecSettingsH265Settings numberBFramesBetweenReferenceFrames(Integer numberBFramesBetweenReferenceFrames) {
    this.numberBFramesBetweenReferenceFrames = numberBFramesBetweenReferenceFrames;
    return this;
  }

  /**
   * Get numberBFramesBetweenReferenceFrames
   * @return numberBFramesBetweenReferenceFrames
   */
  @javax.annotation.Nullable
  public Integer getNumberBFramesBetweenReferenceFrames() {
    return numberBFramesBetweenReferenceFrames;
  }

  public void setNumberBFramesBetweenReferenceFrames(Integer numberBFramesBetweenReferenceFrames) {
    this.numberBFramesBetweenReferenceFrames = numberBFramesBetweenReferenceFrames;
  }


  public VideoCodecSettingsH265Settings numberReferenceFrames(Integer numberReferenceFrames) {
    this.numberReferenceFrames = numberReferenceFrames;
    return this;
  }

  /**
   * Get numberReferenceFrames
   * @return numberReferenceFrames
   */
  @javax.annotation.Nullable
  public Integer getNumberReferenceFrames() {
    return numberReferenceFrames;
  }

  public void setNumberReferenceFrames(Integer numberReferenceFrames) {
    this.numberReferenceFrames = numberReferenceFrames;
  }


  public VideoCodecSettingsH265Settings parControl(H265ParControl parControl) {
    this.parControl = parControl;
    return this;
  }

  /**
   * Get parControl
   * @return parControl
   */
  @javax.annotation.Nullable
  public H265ParControl getParControl() {
    return parControl;
  }

  public void setParControl(H265ParControl parControl) {
    this.parControl = parControl;
  }


  public VideoCodecSettingsH265Settings parDenominator(Integer parDenominator) {
    this.parDenominator = parDenominator;
    return this;
  }

  /**
   * Get parDenominator
   * @return parDenominator
   */
  @javax.annotation.Nullable
  public Integer getParDenominator() {
    return parDenominator;
  }

  public void setParDenominator(Integer parDenominator) {
    this.parDenominator = parDenominator;
  }


  public VideoCodecSettingsH265Settings parNumerator(Integer parNumerator) {
    this.parNumerator = parNumerator;
    return this;
  }

  /**
   * Get parNumerator
   * @return parNumerator
   */
  @javax.annotation.Nullable
  public Integer getParNumerator() {
    return parNumerator;
  }

  public void setParNumerator(Integer parNumerator) {
    this.parNumerator = parNumerator;
  }


  public VideoCodecSettingsH265Settings qualityTuningLevel(H265QualityTuningLevel qualityTuningLevel) {
    this.qualityTuningLevel = qualityTuningLevel;
    return this;
  }

  /**
   * Get qualityTuningLevel
   * @return qualityTuningLevel
   */
  @javax.annotation.Nullable
  public H265QualityTuningLevel getQualityTuningLevel() {
    return qualityTuningLevel;
  }

  public void setQualityTuningLevel(H265QualityTuningLevel qualityTuningLevel) {
    this.qualityTuningLevel = qualityTuningLevel;
  }


  public VideoCodecSettingsH265Settings qvbrSettings(H265SettingsQvbrSettings qvbrSettings) {
    this.qvbrSettings = qvbrSettings;
    return this;
  }

  /**
   * Get qvbrSettings
   * @return qvbrSettings
   */
  @javax.annotation.Nullable
  public H265SettingsQvbrSettings getQvbrSettings() {
    return qvbrSettings;
  }

  public void setQvbrSettings(H265SettingsQvbrSettings qvbrSettings) {
    this.qvbrSettings = qvbrSettings;
  }


  public VideoCodecSettingsH265Settings rateControlMode(H265RateControlMode rateControlMode) {
    this.rateControlMode = rateControlMode;
    return this;
  }

  /**
   * Get rateControlMode
   * @return rateControlMode
   */
  @javax.annotation.Nullable
  public H265RateControlMode getRateControlMode() {
    return rateControlMode;
  }

  public void setRateControlMode(H265RateControlMode rateControlMode) {
    this.rateControlMode = rateControlMode;
  }


  public VideoCodecSettingsH265Settings sampleAdaptiveOffsetFilterMode(H265SampleAdaptiveOffsetFilterMode sampleAdaptiveOffsetFilterMode) {
    this.sampleAdaptiveOffsetFilterMode = sampleAdaptiveOffsetFilterMode;
    return this;
  }

  /**
   * Get sampleAdaptiveOffsetFilterMode
   * @return sampleAdaptiveOffsetFilterMode
   */
  @javax.annotation.Nullable
  public H265SampleAdaptiveOffsetFilterMode getSampleAdaptiveOffsetFilterMode() {
    return sampleAdaptiveOffsetFilterMode;
  }

  public void setSampleAdaptiveOffsetFilterMode(H265SampleAdaptiveOffsetFilterMode sampleAdaptiveOffsetFilterMode) {
    this.sampleAdaptiveOffsetFilterMode = sampleAdaptiveOffsetFilterMode;
  }


  public VideoCodecSettingsH265Settings scanTypeConversionMode(H265ScanTypeConversionMode scanTypeConversionMode) {
    this.scanTypeConversionMode = scanTypeConversionMode;
    return this;
  }

  /**
   * Get scanTypeConversionMode
   * @return scanTypeConversionMode
   */
  @javax.annotation.Nullable
  public H265ScanTypeConversionMode getScanTypeConversionMode() {
    return scanTypeConversionMode;
  }

  public void setScanTypeConversionMode(H265ScanTypeConversionMode scanTypeConversionMode) {
    this.scanTypeConversionMode = scanTypeConversionMode;
  }


  public VideoCodecSettingsH265Settings sceneChangeDetect(H265SceneChangeDetect sceneChangeDetect) {
    this.sceneChangeDetect = sceneChangeDetect;
    return this;
  }

  /**
   * Get sceneChangeDetect
   * @return sceneChangeDetect
   */
  @javax.annotation.Nullable
  public H265SceneChangeDetect getSceneChangeDetect() {
    return sceneChangeDetect;
  }

  public void setSceneChangeDetect(H265SceneChangeDetect sceneChangeDetect) {
    this.sceneChangeDetect = sceneChangeDetect;
  }


  public VideoCodecSettingsH265Settings slices(Integer slices) {
    this.slices = slices;
    return this;
  }

  /**
   * Get slices
   * @return slices
   */
  @javax.annotation.Nullable
  public Integer getSlices() {
    return slices;
  }

  public void setSlices(Integer slices) {
    this.slices = slices;
  }


  public VideoCodecSettingsH265Settings slowPal(H265SlowPal slowPal) {
    this.slowPal = slowPal;
    return this;
  }

  /**
   * Get slowPal
   * @return slowPal
   */
  @javax.annotation.Nullable
  public H265SlowPal getSlowPal() {
    return slowPal;
  }

  public void setSlowPal(H265SlowPal slowPal) {
    this.slowPal = slowPal;
  }


  public VideoCodecSettingsH265Settings spatialAdaptiveQuantization(H265SpatialAdaptiveQuantization spatialAdaptiveQuantization) {
    this.spatialAdaptiveQuantization = spatialAdaptiveQuantization;
    return this;
  }

  /**
   * Get spatialAdaptiveQuantization
   * @return spatialAdaptiveQuantization
   */
  @javax.annotation.Nullable
  public H265SpatialAdaptiveQuantization getSpatialAdaptiveQuantization() {
    return spatialAdaptiveQuantization;
  }

  public void setSpatialAdaptiveQuantization(H265SpatialAdaptiveQuantization spatialAdaptiveQuantization) {
    this.spatialAdaptiveQuantization = spatialAdaptiveQuantization;
  }


  public VideoCodecSettingsH265Settings telecine(H265Telecine telecine) {
    this.telecine = telecine;
    return this;
  }

  /**
   * Get telecine
   * @return telecine
   */
  @javax.annotation.Nullable
  public H265Telecine getTelecine() {
    return telecine;
  }

  public void setTelecine(H265Telecine telecine) {
    this.telecine = telecine;
  }


  public VideoCodecSettingsH265Settings temporalAdaptiveQuantization(H265TemporalAdaptiveQuantization temporalAdaptiveQuantization) {
    this.temporalAdaptiveQuantization = temporalAdaptiveQuantization;
    return this;
  }

  /**
   * Get temporalAdaptiveQuantization
   * @return temporalAdaptiveQuantization
   */
  @javax.annotation.Nullable
  public H265TemporalAdaptiveQuantization getTemporalAdaptiveQuantization() {
    return temporalAdaptiveQuantization;
  }

  public void setTemporalAdaptiveQuantization(H265TemporalAdaptiveQuantization temporalAdaptiveQuantization) {
    this.temporalAdaptiveQuantization = temporalAdaptiveQuantization;
  }


  public VideoCodecSettingsH265Settings temporalIds(H265TemporalIds temporalIds) {
    this.temporalIds = temporalIds;
    return this;
  }

  /**
   * Get temporalIds
   * @return temporalIds
   */
  @javax.annotation.Nullable
  public H265TemporalIds getTemporalIds() {
    return temporalIds;
  }

  public void setTemporalIds(H265TemporalIds temporalIds) {
    this.temporalIds = temporalIds;
  }


  public VideoCodecSettingsH265Settings tiles(H265Tiles tiles) {
    this.tiles = tiles;
    return this;
  }

  /**
   * Get tiles
   * @return tiles
   */
  @javax.annotation.Nullable
  public H265Tiles getTiles() {
    return tiles;
  }

  public void setTiles(H265Tiles tiles) {
    this.tiles = tiles;
  }


  public VideoCodecSettingsH265Settings unregisteredSeiTimecode(H265UnregisteredSeiTimecode unregisteredSeiTimecode) {
    this.unregisteredSeiTimecode = unregisteredSeiTimecode;
    return this;
  }

  /**
   * Get unregisteredSeiTimecode
   * @return unregisteredSeiTimecode
   */
  @javax.annotation.Nullable
  public H265UnregisteredSeiTimecode getUnregisteredSeiTimecode() {
    return unregisteredSeiTimecode;
  }

  public void setUnregisteredSeiTimecode(H265UnregisteredSeiTimecode unregisteredSeiTimecode) {
    this.unregisteredSeiTimecode = unregisteredSeiTimecode;
  }


  public VideoCodecSettingsH265Settings writeMp4PackagingType(H265WriteMp4PackagingType writeMp4PackagingType) {
    this.writeMp4PackagingType = writeMp4PackagingType;
    return this;
  }

  /**
   * Get writeMp4PackagingType
   * @return writeMp4PackagingType
   */
  @javax.annotation.Nullable
  public H265WriteMp4PackagingType getWriteMp4PackagingType() {
    return writeMp4PackagingType;
  }

  public void setWriteMp4PackagingType(H265WriteMp4PackagingType writeMp4PackagingType) {
    this.writeMp4PackagingType = writeMp4PackagingType;
  }



  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    VideoCodecSettingsH265Settings videoCodecSettingsH265Settings = (VideoCodecSettingsH265Settings) o;
    return Objects.equals(this.adaptiveQuantization, videoCodecSettingsH265Settings.adaptiveQuantization) &&
        Objects.equals(this.alternateTransferFunctionSei, videoCodecSettingsH265Settings.alternateTransferFunctionSei) &&
        Objects.equals(this.bandwidthReductionFilter, videoCodecSettingsH265Settings.bandwidthReductionFilter) &&
        Objects.equals(this.bitrate, videoCodecSettingsH265Settings.bitrate) &&
        Objects.equals(this.codecLevel, videoCodecSettingsH265Settings.codecLevel) &&
        Objects.equals(this.codecProfile, videoCodecSettingsH265Settings.codecProfile) &&
        Objects.equals(this.dynamicSubGop, videoCodecSettingsH265Settings.dynamicSubGop) &&
        Objects.equals(this.flickerAdaptiveQuantization, videoCodecSettingsH265Settings.flickerAdaptiveQuantization) &&
        Objects.equals(this.framerateControl, videoCodecSettingsH265Settings.framerateControl) &&
        Objects.equals(this.framerateConversionAlgorithm, videoCodecSettingsH265Settings.framerateConversionAlgorithm) &&
        Objects.equals(this.framerateDenominator, videoCodecSettingsH265Settings.framerateDenominator) &&
        Objects.equals(this.framerateNumerator, videoCodecSettingsH265Settings.framerateNumerator) &&
        Objects.equals(this.gopBReference, videoCodecSettingsH265Settings.gopBReference) &&
        Objects.equals(this.gopClosedCadence, videoCodecSettingsH265Settings.gopClosedCadence) &&
        Objects.equals(this.gopSize, videoCodecSettingsH265Settings.gopSize) &&
        Objects.equals(this.gopSizeUnits, videoCodecSettingsH265Settings.gopSizeUnits) &&
        Objects.equals(this.hrdBufferFinalFillPercentage, videoCodecSettingsH265Settings.hrdBufferFinalFillPercentage) &&
        Objects.equals(this.hrdBufferInitialFillPercentage, videoCodecSettingsH265Settings.hrdBufferInitialFillPercentage) &&
        Objects.equals(this.hrdBufferSize, videoCodecSettingsH265Settings.hrdBufferSize) &&
        Objects.equals(this.interlaceMode, videoCodecSettingsH265Settings.interlaceMode) &&
        Objects.equals(this.maxBitrate, videoCodecSettingsH265Settings.maxBitrate) &&
        Objects.equals(this.minIInterval, videoCodecSettingsH265Settings.minIInterval) &&
        Objects.equals(this.numberBFramesBetweenReferenceFrames, videoCodecSettingsH265Settings.numberBFramesBetweenReferenceFrames) &&
        Objects.equals(this.numberReferenceFrames, videoCodecSettingsH265Settings.numberReferenceFrames) &&
        Objects.equals(this.parControl, videoCodecSettingsH265Settings.parControl) &&
        Objects.equals(this.parDenominator, videoCodecSettingsH265Settings.parDenominator) &&
        Objects.equals(this.parNumerator, videoCodecSettingsH265Settings.parNumerator) &&
        Objects.equals(this.qualityTuningLevel, videoCodecSettingsH265Settings.qualityTuningLevel) &&
        Objects.equals(this.qvbrSettings, videoCodecSettingsH265Settings.qvbrSettings) &&
        Objects.equals(this.rateControlMode, videoCodecSettingsH265Settings.rateControlMode) &&
        Objects.equals(this.sampleAdaptiveOffsetFilterMode, videoCodecSettingsH265Settings.sampleAdaptiveOffsetFilterMode) &&
        Objects.equals(this.scanTypeConversionMode, videoCodecSettingsH265Settings.scanTypeConversionMode) &&
        Objects.equals(this.sceneChangeDetect, videoCodecSettingsH265Settings.sceneChangeDetect) &&
        Objects.equals(this.slices, videoCodecSettingsH265Settings.slices) &&
        Objects.equals(this.slowPal, videoCodecSettingsH265Settings.slowPal) &&
        Objects.equals(this.spatialAdaptiveQuantization, videoCodecSettingsH265Settings.spatialAdaptiveQuantization) &&
        Objects.equals(this.telecine, videoCodecSettingsH265Settings.telecine) &&
        Objects.equals(this.temporalAdaptiveQuantization, videoCodecSettingsH265Settings.temporalAdaptiveQuantization) &&
        Objects.equals(this.temporalIds, videoCodecSettingsH265Settings.temporalIds) &&
        Objects.equals(this.tiles, videoCodecSettingsH265Settings.tiles) &&
        Objects.equals(this.unregisteredSeiTimecode, videoCodecSettingsH265Settings.unregisteredSeiTimecode) &&
        Objects.equals(this.writeMp4PackagingType, videoCodecSettingsH265Settings.writeMp4PackagingType);
  }

  @Override
  public int hashCode() {
    return Objects.hash(adaptiveQuantization, alternateTransferFunctionSei, bandwidthReductionFilter, bitrate, codecLevel, codecProfile, dynamicSubGop, flickerAdaptiveQuantization, framerateControl, framerateConversionAlgorithm, framerateDenominator, framerateNumerator, gopBReference, gopClosedCadence, gopSize, gopSizeUnits, hrdBufferFinalFillPercentage, hrdBufferInitialFillPercentage, hrdBufferSize, interlaceMode, maxBitrate, minIInterval, numberBFramesBetweenReferenceFrames, numberReferenceFrames, parControl, parDenominator, parNumerator, qualityTuningLevel, qvbrSettings, rateControlMode, sampleAdaptiveOffsetFilterMode, scanTypeConversionMode, sceneChangeDetect, slices, slowPal, spatialAdaptiveQuantization, telecine, temporalAdaptiveQuantization, temporalIds, tiles, unregisteredSeiTimecode, writeMp4PackagingType);
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class VideoCodecSettingsH265Settings {\n");
    sb.append("    adaptiveQuantization: ").append(toIndentedString(adaptiveQuantization)).append("\n");
    sb.append("    alternateTransferFunctionSei: ").append(toIndentedString(alternateTransferFunctionSei)).append("\n");
    sb.append("    bandwidthReductionFilter: ").append(toIndentedString(bandwidthReductionFilter)).append("\n");
    sb.append("    bitrate: ").append(toIndentedString(bitrate)).append("\n");
    sb.append("    codecLevel: ").append(toIndentedString(codecLevel)).append("\n");
    sb.append("    codecProfile: ").append(toIndentedString(codecProfile)).append("\n");
    sb.append("    dynamicSubGop: ").append(toIndentedString(dynamicSubGop)).append("\n");
    sb.append("    flickerAdaptiveQuantization: ").append(toIndentedString(flickerAdaptiveQuantization)).append("\n");
    sb.append("    framerateControl: ").append(toIndentedString(framerateControl)).append("\n");
    sb.append("    framerateConversionAlgorithm: ").append(toIndentedString(framerateConversionAlgorithm)).append("\n");
    sb.append("    framerateDenominator: ").append(toIndentedString(framerateDenominator)).append("\n");
    sb.append("    framerateNumerator: ").append(toIndentedString(framerateNumerator)).append("\n");
    sb.append("    gopBReference: ").append(toIndentedString(gopBReference)).append("\n");
    sb.append("    gopClosedCadence: ").append(toIndentedString(gopClosedCadence)).append("\n");
    sb.append("    gopSize: ").append(toIndentedString(gopSize)).append("\n");
    sb.append("    gopSizeUnits: ").append(toIndentedString(gopSizeUnits)).append("\n");
    sb.append("    hrdBufferFinalFillPercentage: ").append(toIndentedString(hrdBufferFinalFillPercentage)).append("\n");
    sb.append("    hrdBufferInitialFillPercentage: ").append(toIndentedString(hrdBufferInitialFillPercentage)).append("\n");
    sb.append("    hrdBufferSize: ").append(toIndentedString(hrdBufferSize)).append("\n");
    sb.append("    interlaceMode: ").append(toIndentedString(interlaceMode)).append("\n");
    sb.append("    maxBitrate: ").append(toIndentedString(maxBitrate)).append("\n");
    sb.append("    minIInterval: ").append(toIndentedString(minIInterval)).append("\n");
    sb.append("    numberBFramesBetweenReferenceFrames: ").append(toIndentedString(numberBFramesBetweenReferenceFrames)).append("\n");
    sb.append("    numberReferenceFrames: ").append(toIndentedString(numberReferenceFrames)).append("\n");
    sb.append("    parControl: ").append(toIndentedString(parControl)).append("\n");
    sb.append("    parDenominator: ").append(toIndentedString(parDenominator)).append("\n");
    sb.append("    parNumerator: ").append(toIndentedString(parNumerator)).append("\n");
    sb.append("    qualityTuningLevel: ").append(toIndentedString(qualityTuningLevel)).append("\n");
    sb.append("    qvbrSettings: ").append(toIndentedString(qvbrSettings)).append("\n");
    sb.append("    rateControlMode: ").append(toIndentedString(rateControlMode)).append("\n");
    sb.append("    sampleAdaptiveOffsetFilterMode: ").append(toIndentedString(sampleAdaptiveOffsetFilterMode)).append("\n");
    sb.append("    scanTypeConversionMode: ").append(toIndentedString(scanTypeConversionMode)).append("\n");
    sb.append("    sceneChangeDetect: ").append(toIndentedString(sceneChangeDetect)).append("\n");
    sb.append("    slices: ").append(toIndentedString(slices)).append("\n");
    sb.append("    slowPal: ").append(toIndentedString(slowPal)).append("\n");
    sb.append("    spatialAdaptiveQuantization: ").append(toIndentedString(spatialAdaptiveQuantization)).append("\n");
    sb.append("    telecine: ").append(toIndentedString(telecine)).append("\n");
    sb.append("    temporalAdaptiveQuantization: ").append(toIndentedString(temporalAdaptiveQuantization)).append("\n");
    sb.append("    temporalIds: ").append(toIndentedString(temporalIds)).append("\n");
    sb.append("    tiles: ").append(toIndentedString(tiles)).append("\n");
    sb.append("    unregisteredSeiTimecode: ").append(toIndentedString(unregisteredSeiTimecode)).append("\n");
    sb.append("    writeMp4PackagingType: ").append(toIndentedString(writeMp4PackagingType)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }


  public static HashSet<String> openapiFields;
  public static HashSet<String> openapiRequiredFields;

  static {
    // a set of all properties/fields (JSON key names)
    openapiFields = new HashSet<String>();
    openapiFields.add("AdaptiveQuantization");
    openapiFields.add("AlternateTransferFunctionSei");
    openapiFields.add("BandwidthReductionFilter");
    openapiFields.add("Bitrate");
    openapiFields.add("CodecLevel");
    openapiFields.add("CodecProfile");
    openapiFields.add("DynamicSubGop");
    openapiFields.add("FlickerAdaptiveQuantization");
    openapiFields.add("FramerateControl");
    openapiFields.add("FramerateConversionAlgorithm");
    openapiFields.add("FramerateDenominator");
    openapiFields.add("FramerateNumerator");
    openapiFields.add("GopBReference");
    openapiFields.add("GopClosedCadence");
    openapiFields.add("GopSize");
    openapiFields.add("GopSizeUnits");
    openapiFields.add("HrdBufferFinalFillPercentage");
    openapiFields.add("HrdBufferInitialFillPercentage");
    openapiFields.add("HrdBufferSize");
    openapiFields.add("InterlaceMode");
    openapiFields.add("MaxBitrate");
    openapiFields.add("MinIInterval");
    openapiFields.add("NumberBFramesBetweenReferenceFrames");
    openapiFields.add("NumberReferenceFrames");
    openapiFields.add("ParControl");
    openapiFields.add("ParDenominator");
    openapiFields.add("ParNumerator");
    openapiFields.add("QualityTuningLevel");
    openapiFields.add("QvbrSettings");
    openapiFields.add("RateControlMode");
    openapiFields.add("SampleAdaptiveOffsetFilterMode");
    openapiFields.add("ScanTypeConversionMode");
    openapiFields.add("SceneChangeDetect");
    openapiFields.add("Slices");
    openapiFields.add("SlowPal");
    openapiFields.add("SpatialAdaptiveQuantization");
    openapiFields.add("Telecine");
    openapiFields.add("TemporalAdaptiveQuantization");
    openapiFields.add("TemporalIds");
    openapiFields.add("Tiles");
    openapiFields.add("UnregisteredSeiTimecode");
    openapiFields.add("WriteMp4PackagingType");

    // a set of required properties/fields (JSON key names)
    openapiRequiredFields = new HashSet<String>();
  }

  /**
   * Validates the JSON Element and throws an exception if issues found
   *
   * @param jsonElement JSON Element
   * @throws IOException if the JSON Element is invalid with respect to VideoCodecSettingsH265Settings
   */
  public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      if (jsonElement == null) {
        if (!VideoCodecSettingsH265Settings.openapiRequiredFields.isEmpty()) { // has required fields but JSON element is null
          throw new IllegalArgumentException(String.format("The required field(s) %s in VideoCodecSettingsH265Settings is not found in the empty JSON string", VideoCodecSettingsH265Settings.openapiRequiredFields.toString()));
        }
      }

      Set<Map.Entry<String, JsonElement>> entries = jsonElement.getAsJsonObject().entrySet();
      // check to see if the JSON string contains additional fields
      for (Map.Entry<String, JsonElement> entry : entries) {
        if (!VideoCodecSettingsH265Settings.openapiFields.contains(entry.getKey())) {
          throw new IllegalArgumentException(String.format("The field `%s` in the JSON string is not defined in the `VideoCodecSettingsH265Settings` properties. JSON: %s", entry.getKey(), jsonElement.toString()));
        }
      }
        JsonObject jsonObj = jsonElement.getAsJsonObject();
      // validate the optional field `AdaptiveQuantization`
      if (jsonObj.get("AdaptiveQuantization") != null && !jsonObj.get("AdaptiveQuantization").isJsonNull()) {
        H265AdaptiveQuantization.validateJsonElement(jsonObj.get("AdaptiveQuantization"));
      }
      // validate the optional field `AlternateTransferFunctionSei`
      if (jsonObj.get("AlternateTransferFunctionSei") != null && !jsonObj.get("AlternateTransferFunctionSei").isJsonNull()) {
        H265AlternateTransferFunctionSei.validateJsonElement(jsonObj.get("AlternateTransferFunctionSei"));
      }
      // validate the optional field `BandwidthReductionFilter`
      if (jsonObj.get("BandwidthReductionFilter") != null && !jsonObj.get("BandwidthReductionFilter").isJsonNull()) {
        H264SettingsBandwidthReductionFilter.validateJsonElement(jsonObj.get("BandwidthReductionFilter"));
      }
      // validate the optional field `Bitrate`
      if (jsonObj.get("Bitrate") != null && !jsonObj.get("Bitrate").isJsonNull()) {
        Integer.validateJsonElement(jsonObj.get("Bitrate"));
      }
      // validate the optional field `CodecLevel`
      if (jsonObj.get("CodecLevel") != null && !jsonObj.get("CodecLevel").isJsonNull()) {
        H265CodecLevel.validateJsonElement(jsonObj.get("CodecLevel"));
      }
      // validate the optional field `CodecProfile`
      if (jsonObj.get("CodecProfile") != null && !jsonObj.get("CodecProfile").isJsonNull()) {
        H265CodecProfile.validateJsonElement(jsonObj.get("CodecProfile"));
      }
      // validate the optional field `DynamicSubGop`
      if (jsonObj.get("DynamicSubGop") != null && !jsonObj.get("DynamicSubGop").isJsonNull()) {
        H265DynamicSubGop.validateJsonElement(jsonObj.get("DynamicSubGop"));
      }
      // validate the optional field `FlickerAdaptiveQuantization`
      if (jsonObj.get("FlickerAdaptiveQuantization") != null && !jsonObj.get("FlickerAdaptiveQuantization").isJsonNull()) {
        H265FlickerAdaptiveQuantization.validateJsonElement(jsonObj.get("FlickerAdaptiveQuantization"));
      }
      // validate the optional field `FramerateControl`
      if (jsonObj.get("FramerateControl") != null && !jsonObj.get("FramerateControl").isJsonNull()) {
        H265FramerateControl.validateJsonElement(jsonObj.get("FramerateControl"));
      }
      // validate the optional field `FramerateConversionAlgorithm`
      if (jsonObj.get("FramerateConversionAlgorithm") != null && !jsonObj.get("FramerateConversionAlgorithm").isJsonNull()) {
        H265FramerateConversionAlgorithm.validateJsonElement(jsonObj.get("FramerateConversionAlgorithm"));
      }
      // validate the optional field `FramerateDenominator`
      if (jsonObj.get("FramerateDenominator") != null && !jsonObj.get("FramerateDenominator").isJsonNull()) {
        Integer.validateJsonElement(jsonObj.get("FramerateDenominator"));
      }
      // validate the optional field `FramerateNumerator`
      if (jsonObj.get("FramerateNumerator") != null && !jsonObj.get("FramerateNumerator").isJsonNull()) {
        Integer.validateJsonElement(jsonObj.get("FramerateNumerator"));
      }
      // validate the optional field `GopBReference`
      if (jsonObj.get("GopBReference") != null && !jsonObj.get("GopBReference").isJsonNull()) {
        H265GopBReference.validateJsonElement(jsonObj.get("GopBReference"));
      }
      // validate the optional field `GopClosedCadence`
      if (jsonObj.get("GopClosedCadence") != null && !jsonObj.get("GopClosedCadence").isJsonNull()) {
        Integer.validateJsonElement(jsonObj.get("GopClosedCadence"));
      }
      // validate the optional field `GopSize`
      if (jsonObj.get("GopSize") != null && !jsonObj.get("GopSize").isJsonNull()) {
        Double.validateJsonElement(jsonObj.get("GopSize"));
      }
      // validate the optional field `GopSizeUnits`
      if (jsonObj.get("GopSizeUnits") != null && !jsonObj.get("GopSizeUnits").isJsonNull()) {
        H265GopSizeUnits.validateJsonElement(jsonObj.get("GopSizeUnits"));
      }
      // validate the optional field `HrdBufferFinalFillPercentage`
      if (jsonObj.get("HrdBufferFinalFillPercentage") != null && !jsonObj.get("HrdBufferFinalFillPercentage").isJsonNull()) {
        Integer.validateJsonElement(jsonObj.get("HrdBufferFinalFillPercentage"));
      }
      // validate the optional field `HrdBufferInitialFillPercentage`
      if (jsonObj.get("HrdBufferInitialFillPercentage") != null && !jsonObj.get("HrdBufferInitialFillPercentage").isJsonNull()) {
        Integer.validateJsonElement(jsonObj.get("HrdBufferInitialFillPercentage"));
      }
      // validate the optional field `HrdBufferSize`
      if (jsonObj.get("HrdBufferSize") != null && !jsonObj.get("HrdBufferSize").isJsonNull()) {
        Integer.validateJsonElement(jsonObj.get("HrdBufferSize"));
      }
      // validate the optional field `InterlaceMode`
      if (jsonObj.get("InterlaceMode") != null && !jsonObj.get("InterlaceMode").isJsonNull()) {
        H265InterlaceMode.validateJsonElement(jsonObj.get("InterlaceMode"));
      }
      // validate the optional field `MaxBitrate`
      if (jsonObj.get("MaxBitrate") != null && !jsonObj.get("MaxBitrate").isJsonNull()) {
        Integer.validateJsonElement(jsonObj.get("MaxBitrate"));
      }
      // validate the optional field `MinIInterval`
      if (jsonObj.get("MinIInterval") != null && !jsonObj.get("MinIInterval").isJsonNull()) {
        Integer.validateJsonElement(jsonObj.get("MinIInterval"));
      }
      // validate the optional field `NumberBFramesBetweenReferenceFrames`
      if (jsonObj.get("NumberBFramesBetweenReferenceFrames") != null && !jsonObj.get("NumberBFramesBetweenReferenceFrames").isJsonNull()) {
        Integer.validateJsonElement(jsonObj.get("NumberBFramesBetweenReferenceFrames"));
      }
      // validate the optional field `NumberReferenceFrames`
      if (jsonObj.get("NumberReferenceFrames") != null && !jsonObj.get("NumberReferenceFrames").isJsonNull()) {
        Integer.validateJsonElement(jsonObj.get("NumberReferenceFrames"));
      }
      // validate the optional field `ParControl`
      if (jsonObj.get("ParControl") != null && !jsonObj.get("ParControl").isJsonNull()) {
        H265ParControl.validateJsonElement(jsonObj.get("ParControl"));
      }
      // validate the optional field `ParDenominator`
      if (jsonObj.get("ParDenominator") != null && !jsonObj.get("ParDenominator").isJsonNull()) {
        Integer.validateJsonElement(jsonObj.get("ParDenominator"));
      }
      // validate the optional field `ParNumerator`
      if (jsonObj.get("ParNumerator") != null && !jsonObj.get("ParNumerator").isJsonNull()) {
        Integer.validateJsonElement(jsonObj.get("ParNumerator"));
      }
      // validate the optional field `QualityTuningLevel`
      if (jsonObj.get("QualityTuningLevel") != null && !jsonObj.get("QualityTuningLevel").isJsonNull()) {
        H265QualityTuningLevel.validateJsonElement(jsonObj.get("QualityTuningLevel"));
      }
      // validate the optional field `QvbrSettings`
      if (jsonObj.get("QvbrSettings") != null && !jsonObj.get("QvbrSettings").isJsonNull()) {
        H265SettingsQvbrSettings.validateJsonElement(jsonObj.get("QvbrSettings"));
      }
      // validate the optional field `RateControlMode`
      if (jsonObj.get("RateControlMode") != null && !jsonObj.get("RateControlMode").isJsonNull()) {
        H265RateControlMode.validateJsonElement(jsonObj.get("RateControlMode"));
      }
      // validate the optional field `SampleAdaptiveOffsetFilterMode`
      if (jsonObj.get("SampleAdaptiveOffsetFilterMode") != null && !jsonObj.get("SampleAdaptiveOffsetFilterMode").isJsonNull()) {
        H265SampleAdaptiveOffsetFilterMode.validateJsonElement(jsonObj.get("SampleAdaptiveOffsetFilterMode"));
      }
      // validate the optional field `ScanTypeConversionMode`
      if (jsonObj.get("ScanTypeConversionMode") != null && !jsonObj.get("ScanTypeConversionMode").isJsonNull()) {
        H265ScanTypeConversionMode.validateJsonElement(jsonObj.get("ScanTypeConversionMode"));
      }
      // validate the optional field `SceneChangeDetect`
      if (jsonObj.get("SceneChangeDetect") != null && !jsonObj.get("SceneChangeDetect").isJsonNull()) {
        H265SceneChangeDetect.validateJsonElement(jsonObj.get("SceneChangeDetect"));
      }
      // validate the optional field `Slices`
      if (jsonObj.get("Slices") != null && !jsonObj.get("Slices").isJsonNull()) {
        Integer.validateJsonElement(jsonObj.get("Slices"));
      }
      // validate the optional field `SlowPal`
      if (jsonObj.get("SlowPal") != null && !jsonObj.get("SlowPal").isJsonNull()) {
        H265SlowPal.validateJsonElement(jsonObj.get("SlowPal"));
      }
      // validate the optional field `SpatialAdaptiveQuantization`
      if (jsonObj.get("SpatialAdaptiveQuantization") != null && !jsonObj.get("SpatialAdaptiveQuantization").isJsonNull()) {
        H265SpatialAdaptiveQuantization.validateJsonElement(jsonObj.get("SpatialAdaptiveQuantization"));
      }
      // validate the optional field `Telecine`
      if (jsonObj.get("Telecine") != null && !jsonObj.get("Telecine").isJsonNull()) {
        H265Telecine.validateJsonElement(jsonObj.get("Telecine"));
      }
      // validate the optional field `TemporalAdaptiveQuantization`
      if (jsonObj.get("TemporalAdaptiveQuantization") != null && !jsonObj.get("TemporalAdaptiveQuantization").isJsonNull()) {
        H265TemporalAdaptiveQuantization.validateJsonElement(jsonObj.get("TemporalAdaptiveQuantization"));
      }
      // validate the optional field `TemporalIds`
      if (jsonObj.get("TemporalIds") != null && !jsonObj.get("TemporalIds").isJsonNull()) {
        H265TemporalIds.validateJsonElement(jsonObj.get("TemporalIds"));
      }
      // validate the optional field `Tiles`
      if (jsonObj.get("Tiles") != null && !jsonObj.get("Tiles").isJsonNull()) {
        H265Tiles.validateJsonElement(jsonObj.get("Tiles"));
      }
      // validate the optional field `UnregisteredSeiTimecode`
      if (jsonObj.get("UnregisteredSeiTimecode") != null && !jsonObj.get("UnregisteredSeiTimecode").isJsonNull()) {
        H265UnregisteredSeiTimecode.validateJsonElement(jsonObj.get("UnregisteredSeiTimecode"));
      }
      // validate the optional field `WriteMp4PackagingType`
      if (jsonObj.get("WriteMp4PackagingType") != null && !jsonObj.get("WriteMp4PackagingType").isJsonNull()) {
        H265WriteMp4PackagingType.validateJsonElement(jsonObj.get("WriteMp4PackagingType"));
      }
  }

  public static class CustomTypeAdapterFactory implements TypeAdapterFactory {
    @SuppressWarnings("unchecked")
    @Override
    public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
       if (!VideoCodecSettingsH265Settings.class.isAssignableFrom(type.getRawType())) {
         return null; // this class only serializes 'VideoCodecSettingsH265Settings' and its subtypes
       }
       final TypeAdapter<JsonElement> elementAdapter = gson.getAdapter(JsonElement.class);
       final TypeAdapter<VideoCodecSettingsH265Settings> thisAdapter
                        = gson.getDelegateAdapter(this, TypeToken.get(VideoCodecSettingsH265Settings.class));

       return (TypeAdapter<T>) new TypeAdapter<VideoCodecSettingsH265Settings>() {
           @Override
           public void write(JsonWriter out, VideoCodecSettingsH265Settings value) throws IOException {
             JsonObject obj = thisAdapter.toJsonTree(value).getAsJsonObject();
             elementAdapter.write(out, obj);
           }

           @Override
           public VideoCodecSettingsH265Settings read(JsonReader in) throws IOException {
             JsonElement jsonElement = elementAdapter.read(in);
             validateJsonElement(jsonElement);
             return thisAdapter.fromJsonTree(jsonElement);
           }

       }.nullSafe();
    }
  }

  /**
   * Create an instance of VideoCodecSettingsH265Settings given an JSON string
   *
   * @param jsonString JSON string
   * @return An instance of VideoCodecSettingsH265Settings
   * @throws IOException if the JSON string is invalid with respect to VideoCodecSettingsH265Settings
   */
  public static VideoCodecSettingsH265Settings fromJson(String jsonString) throws IOException {
    return JSON.getGson().fromJson(jsonString, VideoCodecSettingsH265Settings.class);
  }

  /**
   * Convert an instance of VideoCodecSettingsH265Settings to an JSON string
   *
   * @return JSON string
   */
  public String toJson() {
    return JSON.getGson().toJson(this);
  }
}

