/*
 * AWS Elemental MediaConvert
 * AWS Elemental MediaConvert
 *
 * The version of the OpenAPI document: 2017-08-29
 * Contact: mike.ralphson@gmail.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package org.openapitools.client.model;

import java.util.Objects;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;
import java.util.Arrays;
import org.openapitools.client.model.H264AdaptiveQuantization;
import org.openapitools.client.model.H264CodecLevel;
import org.openapitools.client.model.H264CodecProfile;
import org.openapitools.client.model.H264DynamicSubGop;
import org.openapitools.client.model.H264EntropyEncoding;
import org.openapitools.client.model.H264FieldEncoding;
import org.openapitools.client.model.H264FlickerAdaptiveQuantization;
import org.openapitools.client.model.H264FramerateControl;
import org.openapitools.client.model.H264FramerateConversionAlgorithm;
import org.openapitools.client.model.H264GopBReference;
import org.openapitools.client.model.H264GopSizeUnits;
import org.openapitools.client.model.H264InterlaceMode;
import org.openapitools.client.model.H264ParControl;
import org.openapitools.client.model.H264QualityTuningLevel;
import org.openapitools.client.model.H264RateControlMode;
import org.openapitools.client.model.H264RepeatPps;
import org.openapitools.client.model.H264ScanTypeConversionMode;
import org.openapitools.client.model.H264SceneChangeDetect;
import org.openapitools.client.model.H264SettingsBandwidthReductionFilter;
import org.openapitools.client.model.H264SettingsQvbrSettings;
import org.openapitools.client.model.H264SlowPal;
import org.openapitools.client.model.H264SpatialAdaptiveQuantization;
import org.openapitools.client.model.H264Syntax;
import org.openapitools.client.model.H264Telecine;
import org.openapitools.client.model.H264TemporalAdaptiveQuantization;
import org.openapitools.client.model.H264UnregisteredSeiTimecode;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonArray;
import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;
import com.google.gson.TypeAdapterFactory;
import com.google.gson.reflect.TypeToken;
import com.google.gson.TypeAdapter;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;

import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import org.openapitools.client.JSON;

/**
 * Required when you set Codec to the value H_264.
 */
@javax.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen", date = "2024-10-12T12:24:13.098140-04:00[America/New_York]", comments = "Generator version: 7.9.0")
public class H264Settings {
  public static final String SERIALIZED_NAME_ADAPTIVE_QUANTIZATION = "AdaptiveQuantization";
  @SerializedName(SERIALIZED_NAME_ADAPTIVE_QUANTIZATION)
  private H264AdaptiveQuantization adaptiveQuantization;

  public static final String SERIALIZED_NAME_BANDWIDTH_REDUCTION_FILTER = "BandwidthReductionFilter";
  @SerializedName(SERIALIZED_NAME_BANDWIDTH_REDUCTION_FILTER)
  private H264SettingsBandwidthReductionFilter bandwidthReductionFilter;

  public static final String SERIALIZED_NAME_BITRATE = "Bitrate";
  @SerializedName(SERIALIZED_NAME_BITRATE)
  private Integer bitrate;

  public static final String SERIALIZED_NAME_CODEC_LEVEL = "CodecLevel";
  @SerializedName(SERIALIZED_NAME_CODEC_LEVEL)
  private H264CodecLevel codecLevel;

  public static final String SERIALIZED_NAME_CODEC_PROFILE = "CodecProfile";
  @SerializedName(SERIALIZED_NAME_CODEC_PROFILE)
  private H264CodecProfile codecProfile;

  public static final String SERIALIZED_NAME_DYNAMIC_SUB_GOP = "DynamicSubGop";
  @SerializedName(SERIALIZED_NAME_DYNAMIC_SUB_GOP)
  private H264DynamicSubGop dynamicSubGop;

  public static final String SERIALIZED_NAME_ENTROPY_ENCODING = "EntropyEncoding";
  @SerializedName(SERIALIZED_NAME_ENTROPY_ENCODING)
  private H264EntropyEncoding entropyEncoding;

  public static final String SERIALIZED_NAME_FIELD_ENCODING = "FieldEncoding";
  @SerializedName(SERIALIZED_NAME_FIELD_ENCODING)
  private H264FieldEncoding fieldEncoding;

  public static final String SERIALIZED_NAME_FLICKER_ADAPTIVE_QUANTIZATION = "FlickerAdaptiveQuantization";
  @SerializedName(SERIALIZED_NAME_FLICKER_ADAPTIVE_QUANTIZATION)
  private H264FlickerAdaptiveQuantization flickerAdaptiveQuantization;

  public static final String SERIALIZED_NAME_FRAMERATE_CONTROL = "FramerateControl";
  @SerializedName(SERIALIZED_NAME_FRAMERATE_CONTROL)
  private H264FramerateControl framerateControl;

  public static final String SERIALIZED_NAME_FRAMERATE_CONVERSION_ALGORITHM = "FramerateConversionAlgorithm";
  @SerializedName(SERIALIZED_NAME_FRAMERATE_CONVERSION_ALGORITHM)
  private H264FramerateConversionAlgorithm framerateConversionAlgorithm;

  public static final String SERIALIZED_NAME_FRAMERATE_DENOMINATOR = "FramerateDenominator";
  @SerializedName(SERIALIZED_NAME_FRAMERATE_DENOMINATOR)
  private Integer framerateDenominator;

  public static final String SERIALIZED_NAME_FRAMERATE_NUMERATOR = "FramerateNumerator";
  @SerializedName(SERIALIZED_NAME_FRAMERATE_NUMERATOR)
  private Integer framerateNumerator;

  public static final String SERIALIZED_NAME_GOP_B_REFERENCE = "GopBReference";
  @SerializedName(SERIALIZED_NAME_GOP_B_REFERENCE)
  private H264GopBReference gopBReference;

  public static final String SERIALIZED_NAME_GOP_CLOSED_CADENCE = "GopClosedCadence";
  @SerializedName(SERIALIZED_NAME_GOP_CLOSED_CADENCE)
  private Integer gopClosedCadence;

  public static final String SERIALIZED_NAME_GOP_SIZE = "GopSize";
  @SerializedName(SERIALIZED_NAME_GOP_SIZE)
  private Double gopSize;

  public static final String SERIALIZED_NAME_GOP_SIZE_UNITS = "GopSizeUnits";
  @SerializedName(SERIALIZED_NAME_GOP_SIZE_UNITS)
  private H264GopSizeUnits gopSizeUnits;

  public static final String SERIALIZED_NAME_HRD_BUFFER_FINAL_FILL_PERCENTAGE = "HrdBufferFinalFillPercentage";
  @SerializedName(SERIALIZED_NAME_HRD_BUFFER_FINAL_FILL_PERCENTAGE)
  private Integer hrdBufferFinalFillPercentage;

  public static final String SERIALIZED_NAME_HRD_BUFFER_INITIAL_FILL_PERCENTAGE = "HrdBufferInitialFillPercentage";
  @SerializedName(SERIALIZED_NAME_HRD_BUFFER_INITIAL_FILL_PERCENTAGE)
  private Integer hrdBufferInitialFillPercentage;

  public static final String SERIALIZED_NAME_HRD_BUFFER_SIZE = "HrdBufferSize";
  @SerializedName(SERIALIZED_NAME_HRD_BUFFER_SIZE)
  private Integer hrdBufferSize;

  public static final String SERIALIZED_NAME_INTERLACE_MODE = "InterlaceMode";
  @SerializedName(SERIALIZED_NAME_INTERLACE_MODE)
  private H264InterlaceMode interlaceMode;

  public static final String SERIALIZED_NAME_MAX_BITRATE = "MaxBitrate";
  @SerializedName(SERIALIZED_NAME_MAX_BITRATE)
  private Integer maxBitrate;

  public static final String SERIALIZED_NAME_MIN_I_INTERVAL = "MinIInterval";
  @SerializedName(SERIALIZED_NAME_MIN_I_INTERVAL)
  private Integer minIInterval;

  public static final String SERIALIZED_NAME_NUMBER_B_FRAMES_BETWEEN_REFERENCE_FRAMES = "NumberBFramesBetweenReferenceFrames";
  @SerializedName(SERIALIZED_NAME_NUMBER_B_FRAMES_BETWEEN_REFERENCE_FRAMES)
  private Integer numberBFramesBetweenReferenceFrames;

  public static final String SERIALIZED_NAME_NUMBER_REFERENCE_FRAMES = "NumberReferenceFrames";
  @SerializedName(SERIALIZED_NAME_NUMBER_REFERENCE_FRAMES)
  private Integer numberReferenceFrames;

  public static final String SERIALIZED_NAME_PAR_CONTROL = "ParControl";
  @SerializedName(SERIALIZED_NAME_PAR_CONTROL)
  private H264ParControl parControl;

  public static final String SERIALIZED_NAME_PAR_DENOMINATOR = "ParDenominator";
  @SerializedName(SERIALIZED_NAME_PAR_DENOMINATOR)
  private Integer parDenominator;

  public static final String SERIALIZED_NAME_PAR_NUMERATOR = "ParNumerator";
  @SerializedName(SERIALIZED_NAME_PAR_NUMERATOR)
  private Integer parNumerator;

  public static final String SERIALIZED_NAME_QUALITY_TUNING_LEVEL = "QualityTuningLevel";
  @SerializedName(SERIALIZED_NAME_QUALITY_TUNING_LEVEL)
  private H264QualityTuningLevel qualityTuningLevel;

  public static final String SERIALIZED_NAME_QVBR_SETTINGS = "QvbrSettings";
  @SerializedName(SERIALIZED_NAME_QVBR_SETTINGS)
  private H264SettingsQvbrSettings qvbrSettings;

  public static final String SERIALIZED_NAME_RATE_CONTROL_MODE = "RateControlMode";
  @SerializedName(SERIALIZED_NAME_RATE_CONTROL_MODE)
  private H264RateControlMode rateControlMode;

  public static final String SERIALIZED_NAME_REPEAT_PPS = "RepeatPps";
  @SerializedName(SERIALIZED_NAME_REPEAT_PPS)
  private H264RepeatPps repeatPps;

  public static final String SERIALIZED_NAME_SCAN_TYPE_CONVERSION_MODE = "ScanTypeConversionMode";
  @SerializedName(SERIALIZED_NAME_SCAN_TYPE_CONVERSION_MODE)
  private H264ScanTypeConversionMode scanTypeConversionMode;

  public static final String SERIALIZED_NAME_SCENE_CHANGE_DETECT = "SceneChangeDetect";
  @SerializedName(SERIALIZED_NAME_SCENE_CHANGE_DETECT)
  private H264SceneChangeDetect sceneChangeDetect;

  public static final String SERIALIZED_NAME_SLICES = "Slices";
  @SerializedName(SERIALIZED_NAME_SLICES)
  private Integer slices;

  public static final String SERIALIZED_NAME_SLOW_PAL = "SlowPal";
  @SerializedName(SERIALIZED_NAME_SLOW_PAL)
  private H264SlowPal slowPal;

  public static final String SERIALIZED_NAME_SOFTNESS = "Softness";
  @SerializedName(SERIALIZED_NAME_SOFTNESS)
  private Integer softness;

  public static final String SERIALIZED_NAME_SPATIAL_ADAPTIVE_QUANTIZATION = "SpatialAdaptiveQuantization";
  @SerializedName(SERIALIZED_NAME_SPATIAL_ADAPTIVE_QUANTIZATION)
  private H264SpatialAdaptiveQuantization spatialAdaptiveQuantization;

  public static final String SERIALIZED_NAME_SYNTAX = "Syntax";
  @SerializedName(SERIALIZED_NAME_SYNTAX)
  private H264Syntax syntax;

  public static final String SERIALIZED_NAME_TELECINE = "Telecine";
  @SerializedName(SERIALIZED_NAME_TELECINE)
  private H264Telecine telecine;

  public static final String SERIALIZED_NAME_TEMPORAL_ADAPTIVE_QUANTIZATION = "TemporalAdaptiveQuantization";
  @SerializedName(SERIALIZED_NAME_TEMPORAL_ADAPTIVE_QUANTIZATION)
  private H264TemporalAdaptiveQuantization temporalAdaptiveQuantization;

  public static final String SERIALIZED_NAME_UNREGISTERED_SEI_TIMECODE = "UnregisteredSeiTimecode";
  @SerializedName(SERIALIZED_NAME_UNREGISTERED_SEI_TIMECODE)
  private H264UnregisteredSeiTimecode unregisteredSeiTimecode;

  public H264Settings() {
  }

  public H264Settings adaptiveQuantization(H264AdaptiveQuantization adaptiveQuantization) {
    this.adaptiveQuantization = adaptiveQuantization;
    return this;
  }

  /**
   * Get adaptiveQuantization
   * @return adaptiveQuantization
   */
  @javax.annotation.Nullable
  public H264AdaptiveQuantization getAdaptiveQuantization() {
    return adaptiveQuantization;
  }

  public void setAdaptiveQuantization(H264AdaptiveQuantization adaptiveQuantization) {
    this.adaptiveQuantization = adaptiveQuantization;
  }


  public H264Settings bandwidthReductionFilter(H264SettingsBandwidthReductionFilter bandwidthReductionFilter) {
    this.bandwidthReductionFilter = bandwidthReductionFilter;
    return this;
  }

  /**
   * Get bandwidthReductionFilter
   * @return bandwidthReductionFilter
   */
  @javax.annotation.Nullable
  public H264SettingsBandwidthReductionFilter getBandwidthReductionFilter() {
    return bandwidthReductionFilter;
  }

  public void setBandwidthReductionFilter(H264SettingsBandwidthReductionFilter bandwidthReductionFilter) {
    this.bandwidthReductionFilter = bandwidthReductionFilter;
  }


  public H264Settings bitrate(Integer bitrate) {
    this.bitrate = bitrate;
    return this;
  }

  /**
   * Get bitrate
   * @return bitrate
   */
  @javax.annotation.Nullable
  public Integer getBitrate() {
    return bitrate;
  }

  public void setBitrate(Integer bitrate) {
    this.bitrate = bitrate;
  }


  public H264Settings codecLevel(H264CodecLevel codecLevel) {
    this.codecLevel = codecLevel;
    return this;
  }

  /**
   * Get codecLevel
   * @return codecLevel
   */
  @javax.annotation.Nullable
  public H264CodecLevel getCodecLevel() {
    return codecLevel;
  }

  public void setCodecLevel(H264CodecLevel codecLevel) {
    this.codecLevel = codecLevel;
  }


  public H264Settings codecProfile(H264CodecProfile codecProfile) {
    this.codecProfile = codecProfile;
    return this;
  }

  /**
   * Get codecProfile
   * @return codecProfile
   */
  @javax.annotation.Nullable
  public H264CodecProfile getCodecProfile() {
    return codecProfile;
  }

  public void setCodecProfile(H264CodecProfile codecProfile) {
    this.codecProfile = codecProfile;
  }


  public H264Settings dynamicSubGop(H264DynamicSubGop dynamicSubGop) {
    this.dynamicSubGop = dynamicSubGop;
    return this;
  }

  /**
   * Get dynamicSubGop
   * @return dynamicSubGop
   */
  @javax.annotation.Nullable
  public H264DynamicSubGop getDynamicSubGop() {
    return dynamicSubGop;
  }

  public void setDynamicSubGop(H264DynamicSubGop dynamicSubGop) {
    this.dynamicSubGop = dynamicSubGop;
  }


  public H264Settings entropyEncoding(H264EntropyEncoding entropyEncoding) {
    this.entropyEncoding = entropyEncoding;
    return this;
  }

  /**
   * Get entropyEncoding
   * @return entropyEncoding
   */
  @javax.annotation.Nullable
  public H264EntropyEncoding getEntropyEncoding() {
    return entropyEncoding;
  }

  public void setEntropyEncoding(H264EntropyEncoding entropyEncoding) {
    this.entropyEncoding = entropyEncoding;
  }


  public H264Settings fieldEncoding(H264FieldEncoding fieldEncoding) {
    this.fieldEncoding = fieldEncoding;
    return this;
  }

  /**
   * Get fieldEncoding
   * @return fieldEncoding
   */
  @javax.annotation.Nullable
  public H264FieldEncoding getFieldEncoding() {
    return fieldEncoding;
  }

  public void setFieldEncoding(H264FieldEncoding fieldEncoding) {
    this.fieldEncoding = fieldEncoding;
  }


  public H264Settings flickerAdaptiveQuantization(H264FlickerAdaptiveQuantization flickerAdaptiveQuantization) {
    this.flickerAdaptiveQuantization = flickerAdaptiveQuantization;
    return this;
  }

  /**
   * Get flickerAdaptiveQuantization
   * @return flickerAdaptiveQuantization
   */
  @javax.annotation.Nullable
  public H264FlickerAdaptiveQuantization getFlickerAdaptiveQuantization() {
    return flickerAdaptiveQuantization;
  }

  public void setFlickerAdaptiveQuantization(H264FlickerAdaptiveQuantization flickerAdaptiveQuantization) {
    this.flickerAdaptiveQuantization = flickerAdaptiveQuantization;
  }


  public H264Settings framerateControl(H264FramerateControl framerateControl) {
    this.framerateControl = framerateControl;
    return this;
  }

  /**
   * Get framerateControl
   * @return framerateControl
   */
  @javax.annotation.Nullable
  public H264FramerateControl getFramerateControl() {
    return framerateControl;
  }

  public void setFramerateControl(H264FramerateControl framerateControl) {
    this.framerateControl = framerateControl;
  }


  public H264Settings framerateConversionAlgorithm(H264FramerateConversionAlgorithm framerateConversionAlgorithm) {
    this.framerateConversionAlgorithm = framerateConversionAlgorithm;
    return this;
  }

  /**
   * Get framerateConversionAlgorithm
   * @return framerateConversionAlgorithm
   */
  @javax.annotation.Nullable
  public H264FramerateConversionAlgorithm getFramerateConversionAlgorithm() {
    return framerateConversionAlgorithm;
  }

  public void setFramerateConversionAlgorithm(H264FramerateConversionAlgorithm framerateConversionAlgorithm) {
    this.framerateConversionAlgorithm = framerateConversionAlgorithm;
  }


  public H264Settings framerateDenominator(Integer framerateDenominator) {
    this.framerateDenominator = framerateDenominator;
    return this;
  }

  /**
   * Get framerateDenominator
   * @return framerateDenominator
   */
  @javax.annotation.Nullable
  public Integer getFramerateDenominator() {
    return framerateDenominator;
  }

  public void setFramerateDenominator(Integer framerateDenominator) {
    this.framerateDenominator = framerateDenominator;
  }


  public H264Settings framerateNumerator(Integer framerateNumerator) {
    this.framerateNumerator = framerateNumerator;
    return this;
  }

  /**
   * Get framerateNumerator
   * @return framerateNumerator
   */
  @javax.annotation.Nullable
  public Integer getFramerateNumerator() {
    return framerateNumerator;
  }

  public void setFramerateNumerator(Integer framerateNumerator) {
    this.framerateNumerator = framerateNumerator;
  }


  public H264Settings gopBReference(H264GopBReference gopBReference) {
    this.gopBReference = gopBReference;
    return this;
  }

  /**
   * Get gopBReference
   * @return gopBReference
   */
  @javax.annotation.Nullable
  public H264GopBReference getGopBReference() {
    return gopBReference;
  }

  public void setGopBReference(H264GopBReference gopBReference) {
    this.gopBReference = gopBReference;
  }


  public H264Settings gopClosedCadence(Integer gopClosedCadence) {
    this.gopClosedCadence = gopClosedCadence;
    return this;
  }

  /**
   * Get gopClosedCadence
   * @return gopClosedCadence
   */
  @javax.annotation.Nullable
  public Integer getGopClosedCadence() {
    return gopClosedCadence;
  }

  public void setGopClosedCadence(Integer gopClosedCadence) {
    this.gopClosedCadence = gopClosedCadence;
  }


  public H264Settings gopSize(Double gopSize) {
    this.gopSize = gopSize;
    return this;
  }

  /**
   * Get gopSize
   * @return gopSize
   */
  @javax.annotation.Nullable
  public Double getGopSize() {
    return gopSize;
  }

  public void setGopSize(Double gopSize) {
    this.gopSize = gopSize;
  }


  public H264Settings gopSizeUnits(H264GopSizeUnits gopSizeUnits) {
    this.gopSizeUnits = gopSizeUnits;
    return this;
  }

  /**
   * Get gopSizeUnits
   * @return gopSizeUnits
   */
  @javax.annotation.Nullable
  public H264GopSizeUnits getGopSizeUnits() {
    return gopSizeUnits;
  }

  public void setGopSizeUnits(H264GopSizeUnits gopSizeUnits) {
    this.gopSizeUnits = gopSizeUnits;
  }


  public H264Settings hrdBufferFinalFillPercentage(Integer hrdBufferFinalFillPercentage) {
    this.hrdBufferFinalFillPercentage = hrdBufferFinalFillPercentage;
    return this;
  }

  /**
   * Get hrdBufferFinalFillPercentage
   * @return hrdBufferFinalFillPercentage
   */
  @javax.annotation.Nullable
  public Integer getHrdBufferFinalFillPercentage() {
    return hrdBufferFinalFillPercentage;
  }

  public void setHrdBufferFinalFillPercentage(Integer hrdBufferFinalFillPercentage) {
    this.hrdBufferFinalFillPercentage = hrdBufferFinalFillPercentage;
  }


  public H264Settings hrdBufferInitialFillPercentage(Integer hrdBufferInitialFillPercentage) {
    this.hrdBufferInitialFillPercentage = hrdBufferInitialFillPercentage;
    return this;
  }

  /**
   * Get hrdBufferInitialFillPercentage
   * @return hrdBufferInitialFillPercentage
   */
  @javax.annotation.Nullable
  public Integer getHrdBufferInitialFillPercentage() {
    return hrdBufferInitialFillPercentage;
  }

  public void setHrdBufferInitialFillPercentage(Integer hrdBufferInitialFillPercentage) {
    this.hrdBufferInitialFillPercentage = hrdBufferInitialFillPercentage;
  }


  public H264Settings hrdBufferSize(Integer hrdBufferSize) {
    this.hrdBufferSize = hrdBufferSize;
    return this;
  }

  /**
   * Get hrdBufferSize
   * @return hrdBufferSize
   */
  @javax.annotation.Nullable
  public Integer getHrdBufferSize() {
    return hrdBufferSize;
  }

  public void setHrdBufferSize(Integer hrdBufferSize) {
    this.hrdBufferSize = hrdBufferSize;
  }


  public H264Settings interlaceMode(H264InterlaceMode interlaceMode) {
    this.interlaceMode = interlaceMode;
    return this;
  }

  /**
   * Get interlaceMode
   * @return interlaceMode
   */
  @javax.annotation.Nullable
  public H264InterlaceMode getInterlaceMode() {
    return interlaceMode;
  }

  public void setInterlaceMode(H264InterlaceMode interlaceMode) {
    this.interlaceMode = interlaceMode;
  }


  public H264Settings maxBitrate(Integer maxBitrate) {
    this.maxBitrate = maxBitrate;
    return this;
  }

  /**
   * Get maxBitrate
   * @return maxBitrate
   */
  @javax.annotation.Nullable
  public Integer getMaxBitrate() {
    return maxBitrate;
  }

  public void setMaxBitrate(Integer maxBitrate) {
    this.maxBitrate = maxBitrate;
  }


  public H264Settings minIInterval(Integer minIInterval) {
    this.minIInterval = minIInterval;
    return this;
  }

  /**
   * Get minIInterval
   * @return minIInterval
   */
  @javax.annotation.Nullable
  public Integer getMinIInterval() {
    return minIInterval;
  }

  public void setMinIInterval(Integer minIInterval) {
    this.minIInterval = minIInterval;
  }


  public H264Settings numberBFramesBetweenReferenceFrames(Integer numberBFramesBetweenReferenceFrames) {
    this.numberBFramesBetweenReferenceFrames = numberBFramesBetweenReferenceFrames;
    return this;
  }

  /**
   * Get numberBFramesBetweenReferenceFrames
   * @return numberBFramesBetweenReferenceFrames
   */
  @javax.annotation.Nullable
  public Integer getNumberBFramesBetweenReferenceFrames() {
    return numberBFramesBetweenReferenceFrames;
  }

  public void setNumberBFramesBetweenReferenceFrames(Integer numberBFramesBetweenReferenceFrames) {
    this.numberBFramesBetweenReferenceFrames = numberBFramesBetweenReferenceFrames;
  }


  public H264Settings numberReferenceFrames(Integer numberReferenceFrames) {
    this.numberReferenceFrames = numberReferenceFrames;
    return this;
  }

  /**
   * Get numberReferenceFrames
   * @return numberReferenceFrames
   */
  @javax.annotation.Nullable
  public Integer getNumberReferenceFrames() {
    return numberReferenceFrames;
  }

  public void setNumberReferenceFrames(Integer numberReferenceFrames) {
    this.numberReferenceFrames = numberReferenceFrames;
  }


  public H264Settings parControl(H264ParControl parControl) {
    this.parControl = parControl;
    return this;
  }

  /**
   * Get parControl
   * @return parControl
   */
  @javax.annotation.Nullable
  public H264ParControl getParControl() {
    return parControl;
  }

  public void setParControl(H264ParControl parControl) {
    this.parControl = parControl;
  }


  public H264Settings parDenominator(Integer parDenominator) {
    this.parDenominator = parDenominator;
    return this;
  }

  /**
   * Get parDenominator
   * @return parDenominator
   */
  @javax.annotation.Nullable
  public Integer getParDenominator() {
    return parDenominator;
  }

  public void setParDenominator(Integer parDenominator) {
    this.parDenominator = parDenominator;
  }


  public H264Settings parNumerator(Integer parNumerator) {
    this.parNumerator = parNumerator;
    return this;
  }

  /**
   * Get parNumerator
   * @return parNumerator
   */
  @javax.annotation.Nullable
  public Integer getParNumerator() {
    return parNumerator;
  }

  public void setParNumerator(Integer parNumerator) {
    this.parNumerator = parNumerator;
  }


  public H264Settings qualityTuningLevel(H264QualityTuningLevel qualityTuningLevel) {
    this.qualityTuningLevel = qualityTuningLevel;
    return this;
  }

  /**
   * Get qualityTuningLevel
   * @return qualityTuningLevel
   */
  @javax.annotation.Nullable
  public H264QualityTuningLevel getQualityTuningLevel() {
    return qualityTuningLevel;
  }

  public void setQualityTuningLevel(H264QualityTuningLevel qualityTuningLevel) {
    this.qualityTuningLevel = qualityTuningLevel;
  }


  public H264Settings qvbrSettings(H264SettingsQvbrSettings qvbrSettings) {
    this.qvbrSettings = qvbrSettings;
    return this;
  }

  /**
   * Get qvbrSettings
   * @return qvbrSettings
   */
  @javax.annotation.Nullable
  public H264SettingsQvbrSettings getQvbrSettings() {
    return qvbrSettings;
  }

  public void setQvbrSettings(H264SettingsQvbrSettings qvbrSettings) {
    this.qvbrSettings = qvbrSettings;
  }


  public H264Settings rateControlMode(H264RateControlMode rateControlMode) {
    this.rateControlMode = rateControlMode;
    return this;
  }

  /**
   * Get rateControlMode
   * @return rateControlMode
   */
  @javax.annotation.Nullable
  public H264RateControlMode getRateControlMode() {
    return rateControlMode;
  }

  public void setRateControlMode(H264RateControlMode rateControlMode) {
    this.rateControlMode = rateControlMode;
  }


  public H264Settings repeatPps(H264RepeatPps repeatPps) {
    this.repeatPps = repeatPps;
    return this;
  }

  /**
   * Get repeatPps
   * @return repeatPps
   */
  @javax.annotation.Nullable
  public H264RepeatPps getRepeatPps() {
    return repeatPps;
  }

  public void setRepeatPps(H264RepeatPps repeatPps) {
    this.repeatPps = repeatPps;
  }


  public H264Settings scanTypeConversionMode(H264ScanTypeConversionMode scanTypeConversionMode) {
    this.scanTypeConversionMode = scanTypeConversionMode;
    return this;
  }

  /**
   * Get scanTypeConversionMode
   * @return scanTypeConversionMode
   */
  @javax.annotation.Nullable
  public H264ScanTypeConversionMode getScanTypeConversionMode() {
    return scanTypeConversionMode;
  }

  public void setScanTypeConversionMode(H264ScanTypeConversionMode scanTypeConversionMode) {
    this.scanTypeConversionMode = scanTypeConversionMode;
  }


  public H264Settings sceneChangeDetect(H264SceneChangeDetect sceneChangeDetect) {
    this.sceneChangeDetect = sceneChangeDetect;
    return this;
  }

  /**
   * Get sceneChangeDetect
   * @return sceneChangeDetect
   */
  @javax.annotation.Nullable
  public H264SceneChangeDetect getSceneChangeDetect() {
    return sceneChangeDetect;
  }

  public void setSceneChangeDetect(H264SceneChangeDetect sceneChangeDetect) {
    this.sceneChangeDetect = sceneChangeDetect;
  }


  public H264Settings slices(Integer slices) {
    this.slices = slices;
    return this;
  }

  /**
   * Get slices
   * @return slices
   */
  @javax.annotation.Nullable
  public Integer getSlices() {
    return slices;
  }

  public void setSlices(Integer slices) {
    this.slices = slices;
  }


  public H264Settings slowPal(H264SlowPal slowPal) {
    this.slowPal = slowPal;
    return this;
  }

  /**
   * Get slowPal
   * @return slowPal
   */
  @javax.annotation.Nullable
  public H264SlowPal getSlowPal() {
    return slowPal;
  }

  public void setSlowPal(H264SlowPal slowPal) {
    this.slowPal = slowPal;
  }


  public H264Settings softness(Integer softness) {
    this.softness = softness;
    return this;
  }

  /**
   * Get softness
   * @return softness
   */
  @javax.annotation.Nullable
  public Integer getSoftness() {
    return softness;
  }

  public void setSoftness(Integer softness) {
    this.softness = softness;
  }


  public H264Settings spatialAdaptiveQuantization(H264SpatialAdaptiveQuantization spatialAdaptiveQuantization) {
    this.spatialAdaptiveQuantization = spatialAdaptiveQuantization;
    return this;
  }

  /**
   * Get spatialAdaptiveQuantization
   * @return spatialAdaptiveQuantization
   */
  @javax.annotation.Nullable
  public H264SpatialAdaptiveQuantization getSpatialAdaptiveQuantization() {
    return spatialAdaptiveQuantization;
  }

  public void setSpatialAdaptiveQuantization(H264SpatialAdaptiveQuantization spatialAdaptiveQuantization) {
    this.spatialAdaptiveQuantization = spatialAdaptiveQuantization;
  }


  public H264Settings syntax(H264Syntax syntax) {
    this.syntax = syntax;
    return this;
  }

  /**
   * Get syntax
   * @return syntax
   */
  @javax.annotation.Nullable
  public H264Syntax getSyntax() {
    return syntax;
  }

  public void setSyntax(H264Syntax syntax) {
    this.syntax = syntax;
  }


  public H264Settings telecine(H264Telecine telecine) {
    this.telecine = telecine;
    return this;
  }

  /**
   * Get telecine
   * @return telecine
   */
  @javax.annotation.Nullable
  public H264Telecine getTelecine() {
    return telecine;
  }

  public void setTelecine(H264Telecine telecine) {
    this.telecine = telecine;
  }


  public H264Settings temporalAdaptiveQuantization(H264TemporalAdaptiveQuantization temporalAdaptiveQuantization) {
    this.temporalAdaptiveQuantization = temporalAdaptiveQuantization;
    return this;
  }

  /**
   * Get temporalAdaptiveQuantization
   * @return temporalAdaptiveQuantization
   */
  @javax.annotation.Nullable
  public H264TemporalAdaptiveQuantization getTemporalAdaptiveQuantization() {
    return temporalAdaptiveQuantization;
  }

  public void setTemporalAdaptiveQuantization(H264TemporalAdaptiveQuantization temporalAdaptiveQuantization) {
    this.temporalAdaptiveQuantization = temporalAdaptiveQuantization;
  }


  public H264Settings unregisteredSeiTimecode(H264UnregisteredSeiTimecode unregisteredSeiTimecode) {
    this.unregisteredSeiTimecode = unregisteredSeiTimecode;
    return this;
  }

  /**
   * Get unregisteredSeiTimecode
   * @return unregisteredSeiTimecode
   */
  @javax.annotation.Nullable
  public H264UnregisteredSeiTimecode getUnregisteredSeiTimecode() {
    return unregisteredSeiTimecode;
  }

  public void setUnregisteredSeiTimecode(H264UnregisteredSeiTimecode unregisteredSeiTimecode) {
    this.unregisteredSeiTimecode = unregisteredSeiTimecode;
  }



  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    H264Settings h264Settings = (H264Settings) o;
    return Objects.equals(this.adaptiveQuantization, h264Settings.adaptiveQuantization) &&
        Objects.equals(this.bandwidthReductionFilter, h264Settings.bandwidthReductionFilter) &&
        Objects.equals(this.bitrate, h264Settings.bitrate) &&
        Objects.equals(this.codecLevel, h264Settings.codecLevel) &&
        Objects.equals(this.codecProfile, h264Settings.codecProfile) &&
        Objects.equals(this.dynamicSubGop, h264Settings.dynamicSubGop) &&
        Objects.equals(this.entropyEncoding, h264Settings.entropyEncoding) &&
        Objects.equals(this.fieldEncoding, h264Settings.fieldEncoding) &&
        Objects.equals(this.flickerAdaptiveQuantization, h264Settings.flickerAdaptiveQuantization) &&
        Objects.equals(this.framerateControl, h264Settings.framerateControl) &&
        Objects.equals(this.framerateConversionAlgorithm, h264Settings.framerateConversionAlgorithm) &&
        Objects.equals(this.framerateDenominator, h264Settings.framerateDenominator) &&
        Objects.equals(this.framerateNumerator, h264Settings.framerateNumerator) &&
        Objects.equals(this.gopBReference, h264Settings.gopBReference) &&
        Objects.equals(this.gopClosedCadence, h264Settings.gopClosedCadence) &&
        Objects.equals(this.gopSize, h264Settings.gopSize) &&
        Objects.equals(this.gopSizeUnits, h264Settings.gopSizeUnits) &&
        Objects.equals(this.hrdBufferFinalFillPercentage, h264Settings.hrdBufferFinalFillPercentage) &&
        Objects.equals(this.hrdBufferInitialFillPercentage, h264Settings.hrdBufferInitialFillPercentage) &&
        Objects.equals(this.hrdBufferSize, h264Settings.hrdBufferSize) &&
        Objects.equals(this.interlaceMode, h264Settings.interlaceMode) &&
        Objects.equals(this.maxBitrate, h264Settings.maxBitrate) &&
        Objects.equals(this.minIInterval, h264Settings.minIInterval) &&
        Objects.equals(this.numberBFramesBetweenReferenceFrames, h264Settings.numberBFramesBetweenReferenceFrames) &&
        Objects.equals(this.numberReferenceFrames, h264Settings.numberReferenceFrames) &&
        Objects.equals(this.parControl, h264Settings.parControl) &&
        Objects.equals(this.parDenominator, h264Settings.parDenominator) &&
        Objects.equals(this.parNumerator, h264Settings.parNumerator) &&
        Objects.equals(this.qualityTuningLevel, h264Settings.qualityTuningLevel) &&
        Objects.equals(this.qvbrSettings, h264Settings.qvbrSettings) &&
        Objects.equals(this.rateControlMode, h264Settings.rateControlMode) &&
        Objects.equals(this.repeatPps, h264Settings.repeatPps) &&
        Objects.equals(this.scanTypeConversionMode, h264Settings.scanTypeConversionMode) &&
        Objects.equals(this.sceneChangeDetect, h264Settings.sceneChangeDetect) &&
        Objects.equals(this.slices, h264Settings.slices) &&
        Objects.equals(this.slowPal, h264Settings.slowPal) &&
        Objects.equals(this.softness, h264Settings.softness) &&
        Objects.equals(this.spatialAdaptiveQuantization, h264Settings.spatialAdaptiveQuantization) &&
        Objects.equals(this.syntax, h264Settings.syntax) &&
        Objects.equals(this.telecine, h264Settings.telecine) &&
        Objects.equals(this.temporalAdaptiveQuantization, h264Settings.temporalAdaptiveQuantization) &&
        Objects.equals(this.unregisteredSeiTimecode, h264Settings.unregisteredSeiTimecode);
  }

  @Override
  public int hashCode() {
    return Objects.hash(adaptiveQuantization, bandwidthReductionFilter, bitrate, codecLevel, codecProfile, dynamicSubGop, entropyEncoding, fieldEncoding, flickerAdaptiveQuantization, framerateControl, framerateConversionAlgorithm, framerateDenominator, framerateNumerator, gopBReference, gopClosedCadence, gopSize, gopSizeUnits, hrdBufferFinalFillPercentage, hrdBufferInitialFillPercentage, hrdBufferSize, interlaceMode, maxBitrate, minIInterval, numberBFramesBetweenReferenceFrames, numberReferenceFrames, parControl, parDenominator, parNumerator, qualityTuningLevel, qvbrSettings, rateControlMode, repeatPps, scanTypeConversionMode, sceneChangeDetect, slices, slowPal, softness, spatialAdaptiveQuantization, syntax, telecine, temporalAdaptiveQuantization, unregisteredSeiTimecode);
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class H264Settings {\n");
    sb.append("    adaptiveQuantization: ").append(toIndentedString(adaptiveQuantization)).append("\n");
    sb.append("    bandwidthReductionFilter: ").append(toIndentedString(bandwidthReductionFilter)).append("\n");
    sb.append("    bitrate: ").append(toIndentedString(bitrate)).append("\n");
    sb.append("    codecLevel: ").append(toIndentedString(codecLevel)).append("\n");
    sb.append("    codecProfile: ").append(toIndentedString(codecProfile)).append("\n");
    sb.append("    dynamicSubGop: ").append(toIndentedString(dynamicSubGop)).append("\n");
    sb.append("    entropyEncoding: ").append(toIndentedString(entropyEncoding)).append("\n");
    sb.append("    fieldEncoding: ").append(toIndentedString(fieldEncoding)).append("\n");
    sb.append("    flickerAdaptiveQuantization: ").append(toIndentedString(flickerAdaptiveQuantization)).append("\n");
    sb.append("    framerateControl: ").append(toIndentedString(framerateControl)).append("\n");
    sb.append("    framerateConversionAlgorithm: ").append(toIndentedString(framerateConversionAlgorithm)).append("\n");
    sb.append("    framerateDenominator: ").append(toIndentedString(framerateDenominator)).append("\n");
    sb.append("    framerateNumerator: ").append(toIndentedString(framerateNumerator)).append("\n");
    sb.append("    gopBReference: ").append(toIndentedString(gopBReference)).append("\n");
    sb.append("    gopClosedCadence: ").append(toIndentedString(gopClosedCadence)).append("\n");
    sb.append("    gopSize: ").append(toIndentedString(gopSize)).append("\n");
    sb.append("    gopSizeUnits: ").append(toIndentedString(gopSizeUnits)).append("\n");
    sb.append("    hrdBufferFinalFillPercentage: ").append(toIndentedString(hrdBufferFinalFillPercentage)).append("\n");
    sb.append("    hrdBufferInitialFillPercentage: ").append(toIndentedString(hrdBufferInitialFillPercentage)).append("\n");
    sb.append("    hrdBufferSize: ").append(toIndentedString(hrdBufferSize)).append("\n");
    sb.append("    interlaceMode: ").append(toIndentedString(interlaceMode)).append("\n");
    sb.append("    maxBitrate: ").append(toIndentedString(maxBitrate)).append("\n");
    sb.append("    minIInterval: ").append(toIndentedString(minIInterval)).append("\n");
    sb.append("    numberBFramesBetweenReferenceFrames: ").append(toIndentedString(numberBFramesBetweenReferenceFrames)).append("\n");
    sb.append("    numberReferenceFrames: ").append(toIndentedString(numberReferenceFrames)).append("\n");
    sb.append("    parControl: ").append(toIndentedString(parControl)).append("\n");
    sb.append("    parDenominator: ").append(toIndentedString(parDenominator)).append("\n");
    sb.append("    parNumerator: ").append(toIndentedString(parNumerator)).append("\n");
    sb.append("    qualityTuningLevel: ").append(toIndentedString(qualityTuningLevel)).append("\n");
    sb.append("    qvbrSettings: ").append(toIndentedString(qvbrSettings)).append("\n");
    sb.append("    rateControlMode: ").append(toIndentedString(rateControlMode)).append("\n");
    sb.append("    repeatPps: ").append(toIndentedString(repeatPps)).append("\n");
    sb.append("    scanTypeConversionMode: ").append(toIndentedString(scanTypeConversionMode)).append("\n");
    sb.append("    sceneChangeDetect: ").append(toIndentedString(sceneChangeDetect)).append("\n");
    sb.append("    slices: ").append(toIndentedString(slices)).append("\n");
    sb.append("    slowPal: ").append(toIndentedString(slowPal)).append("\n");
    sb.append("    softness: ").append(toIndentedString(softness)).append("\n");
    sb.append("    spatialAdaptiveQuantization: ").append(toIndentedString(spatialAdaptiveQuantization)).append("\n");
    sb.append("    syntax: ").append(toIndentedString(syntax)).append("\n");
    sb.append("    telecine: ").append(toIndentedString(telecine)).append("\n");
    sb.append("    temporalAdaptiveQuantization: ").append(toIndentedString(temporalAdaptiveQuantization)).append("\n");
    sb.append("    unregisteredSeiTimecode: ").append(toIndentedString(unregisteredSeiTimecode)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }


  public static HashSet<String> openapiFields;
  public static HashSet<String> openapiRequiredFields;

  static {
    // a set of all properties/fields (JSON key names)
    openapiFields = new HashSet<String>();
    openapiFields.add("AdaptiveQuantization");
    openapiFields.add("BandwidthReductionFilter");
    openapiFields.add("Bitrate");
    openapiFields.add("CodecLevel");
    openapiFields.add("CodecProfile");
    openapiFields.add("DynamicSubGop");
    openapiFields.add("EntropyEncoding");
    openapiFields.add("FieldEncoding");
    openapiFields.add("FlickerAdaptiveQuantization");
    openapiFields.add("FramerateControl");
    openapiFields.add("FramerateConversionAlgorithm");
    openapiFields.add("FramerateDenominator");
    openapiFields.add("FramerateNumerator");
    openapiFields.add("GopBReference");
    openapiFields.add("GopClosedCadence");
    openapiFields.add("GopSize");
    openapiFields.add("GopSizeUnits");
    openapiFields.add("HrdBufferFinalFillPercentage");
    openapiFields.add("HrdBufferInitialFillPercentage");
    openapiFields.add("HrdBufferSize");
    openapiFields.add("InterlaceMode");
    openapiFields.add("MaxBitrate");
    openapiFields.add("MinIInterval");
    openapiFields.add("NumberBFramesBetweenReferenceFrames");
    openapiFields.add("NumberReferenceFrames");
    openapiFields.add("ParControl");
    openapiFields.add("ParDenominator");
    openapiFields.add("ParNumerator");
    openapiFields.add("QualityTuningLevel");
    openapiFields.add("QvbrSettings");
    openapiFields.add("RateControlMode");
    openapiFields.add("RepeatPps");
    openapiFields.add("ScanTypeConversionMode");
    openapiFields.add("SceneChangeDetect");
    openapiFields.add("Slices");
    openapiFields.add("SlowPal");
    openapiFields.add("Softness");
    openapiFields.add("SpatialAdaptiveQuantization");
    openapiFields.add("Syntax");
    openapiFields.add("Telecine");
    openapiFields.add("TemporalAdaptiveQuantization");
    openapiFields.add("UnregisteredSeiTimecode");

    // a set of required properties/fields (JSON key names)
    openapiRequiredFields = new HashSet<String>();
  }

  /**
   * Validates the JSON Element and throws an exception if issues found
   *
   * @param jsonElement JSON Element
   * @throws IOException if the JSON Element is invalid with respect to H264Settings
   */
  public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      if (jsonElement == null) {
        if (!H264Settings.openapiRequiredFields.isEmpty()) { // has required fields but JSON element is null
          throw new IllegalArgumentException(String.format("The required field(s) %s in H264Settings is not found in the empty JSON string", H264Settings.openapiRequiredFields.toString()));
        }
      }

      Set<Map.Entry<String, JsonElement>> entries = jsonElement.getAsJsonObject().entrySet();
      // check to see if the JSON string contains additional fields
      for (Map.Entry<String, JsonElement> entry : entries) {
        if (!H264Settings.openapiFields.contains(entry.getKey())) {
          throw new IllegalArgumentException(String.format("The field `%s` in the JSON string is not defined in the `H264Settings` properties. JSON: %s", entry.getKey(), jsonElement.toString()));
        }
      }
        JsonObject jsonObj = jsonElement.getAsJsonObject();
      // validate the optional field `AdaptiveQuantization`
      if (jsonObj.get("AdaptiveQuantization") != null && !jsonObj.get("AdaptiveQuantization").isJsonNull()) {
        H264AdaptiveQuantization.validateJsonElement(jsonObj.get("AdaptiveQuantization"));
      }
      // validate the optional field `BandwidthReductionFilter`
      if (jsonObj.get("BandwidthReductionFilter") != null && !jsonObj.get("BandwidthReductionFilter").isJsonNull()) {
        H264SettingsBandwidthReductionFilter.validateJsonElement(jsonObj.get("BandwidthReductionFilter"));
      }
      // validate the optional field `Bitrate`
      if (jsonObj.get("Bitrate") != null && !jsonObj.get("Bitrate").isJsonNull()) {
        Integer.validateJsonElement(jsonObj.get("Bitrate"));
      }
      // validate the optional field `CodecLevel`
      if (jsonObj.get("CodecLevel") != null && !jsonObj.get("CodecLevel").isJsonNull()) {
        H264CodecLevel.validateJsonElement(jsonObj.get("CodecLevel"));
      }
      // validate the optional field `CodecProfile`
      if (jsonObj.get("CodecProfile") != null && !jsonObj.get("CodecProfile").isJsonNull()) {
        H264CodecProfile.validateJsonElement(jsonObj.get("CodecProfile"));
      }
      // validate the optional field `DynamicSubGop`
      if (jsonObj.get("DynamicSubGop") != null && !jsonObj.get("DynamicSubGop").isJsonNull()) {
        H264DynamicSubGop.validateJsonElement(jsonObj.get("DynamicSubGop"));
      }
      // validate the optional field `EntropyEncoding`
      if (jsonObj.get("EntropyEncoding") != null && !jsonObj.get("EntropyEncoding").isJsonNull()) {
        H264EntropyEncoding.validateJsonElement(jsonObj.get("EntropyEncoding"));
      }
      // validate the optional field `FieldEncoding`
      if (jsonObj.get("FieldEncoding") != null && !jsonObj.get("FieldEncoding").isJsonNull()) {
        H264FieldEncoding.validateJsonElement(jsonObj.get("FieldEncoding"));
      }
      // validate the optional field `FlickerAdaptiveQuantization`
      if (jsonObj.get("FlickerAdaptiveQuantization") != null && !jsonObj.get("FlickerAdaptiveQuantization").isJsonNull()) {
        H264FlickerAdaptiveQuantization.validateJsonElement(jsonObj.get("FlickerAdaptiveQuantization"));
      }
      // validate the optional field `FramerateControl`
      if (jsonObj.get("FramerateControl") != null && !jsonObj.get("FramerateControl").isJsonNull()) {
        H264FramerateControl.validateJsonElement(jsonObj.get("FramerateControl"));
      }
      // validate the optional field `FramerateConversionAlgorithm`
      if (jsonObj.get("FramerateConversionAlgorithm") != null && !jsonObj.get("FramerateConversionAlgorithm").isJsonNull()) {
        H264FramerateConversionAlgorithm.validateJsonElement(jsonObj.get("FramerateConversionAlgorithm"));
      }
      // validate the optional field `FramerateDenominator`
      if (jsonObj.get("FramerateDenominator") != null && !jsonObj.get("FramerateDenominator").isJsonNull()) {
        Integer.validateJsonElement(jsonObj.get("FramerateDenominator"));
      }
      // validate the optional field `FramerateNumerator`
      if (jsonObj.get("FramerateNumerator") != null && !jsonObj.get("FramerateNumerator").isJsonNull()) {
        Integer.validateJsonElement(jsonObj.get("FramerateNumerator"));
      }
      // validate the optional field `GopBReference`
      if (jsonObj.get("GopBReference") != null && !jsonObj.get("GopBReference").isJsonNull()) {
        H264GopBReference.validateJsonElement(jsonObj.get("GopBReference"));
      }
      // validate the optional field `GopClosedCadence`
      if (jsonObj.get("GopClosedCadence") != null && !jsonObj.get("GopClosedCadence").isJsonNull()) {
        Integer.validateJsonElement(jsonObj.get("GopClosedCadence"));
      }
      // validate the optional field `GopSize`
      if (jsonObj.get("GopSize") != null && !jsonObj.get("GopSize").isJsonNull()) {
        Double.validateJsonElement(jsonObj.get("GopSize"));
      }
      // validate the optional field `GopSizeUnits`
      if (jsonObj.get("GopSizeUnits") != null && !jsonObj.get("GopSizeUnits").isJsonNull()) {
        H264GopSizeUnits.validateJsonElement(jsonObj.get("GopSizeUnits"));
      }
      // validate the optional field `HrdBufferFinalFillPercentage`
      if (jsonObj.get("HrdBufferFinalFillPercentage") != null && !jsonObj.get("HrdBufferFinalFillPercentage").isJsonNull()) {
        Integer.validateJsonElement(jsonObj.get("HrdBufferFinalFillPercentage"));
      }
      // validate the optional field `HrdBufferInitialFillPercentage`
      if (jsonObj.get("HrdBufferInitialFillPercentage") != null && !jsonObj.get("HrdBufferInitialFillPercentage").isJsonNull()) {
        Integer.validateJsonElement(jsonObj.get("HrdBufferInitialFillPercentage"));
      }
      // validate the optional field `HrdBufferSize`
      if (jsonObj.get("HrdBufferSize") != null && !jsonObj.get("HrdBufferSize").isJsonNull()) {
        Integer.validateJsonElement(jsonObj.get("HrdBufferSize"));
      }
      // validate the optional field `InterlaceMode`
      if (jsonObj.get("InterlaceMode") != null && !jsonObj.get("InterlaceMode").isJsonNull()) {
        H264InterlaceMode.validateJsonElement(jsonObj.get("InterlaceMode"));
      }
      // validate the optional field `MaxBitrate`
      if (jsonObj.get("MaxBitrate") != null && !jsonObj.get("MaxBitrate").isJsonNull()) {
        Integer.validateJsonElement(jsonObj.get("MaxBitrate"));
      }
      // validate the optional field `MinIInterval`
      if (jsonObj.get("MinIInterval") != null && !jsonObj.get("MinIInterval").isJsonNull()) {
        Integer.validateJsonElement(jsonObj.get("MinIInterval"));
      }
      // validate the optional field `NumberBFramesBetweenReferenceFrames`
      if (jsonObj.get("NumberBFramesBetweenReferenceFrames") != null && !jsonObj.get("NumberBFramesBetweenReferenceFrames").isJsonNull()) {
        Integer.validateJsonElement(jsonObj.get("NumberBFramesBetweenReferenceFrames"));
      }
      // validate the optional field `NumberReferenceFrames`
      if (jsonObj.get("NumberReferenceFrames") != null && !jsonObj.get("NumberReferenceFrames").isJsonNull()) {
        Integer.validateJsonElement(jsonObj.get("NumberReferenceFrames"));
      }
      // validate the optional field `ParControl`
      if (jsonObj.get("ParControl") != null && !jsonObj.get("ParControl").isJsonNull()) {
        H264ParControl.validateJsonElement(jsonObj.get("ParControl"));
      }
      // validate the optional field `ParDenominator`
      if (jsonObj.get("ParDenominator") != null && !jsonObj.get("ParDenominator").isJsonNull()) {
        Integer.validateJsonElement(jsonObj.get("ParDenominator"));
      }
      // validate the optional field `ParNumerator`
      if (jsonObj.get("ParNumerator") != null && !jsonObj.get("ParNumerator").isJsonNull()) {
        Integer.validateJsonElement(jsonObj.get("ParNumerator"));
      }
      // validate the optional field `QualityTuningLevel`
      if (jsonObj.get("QualityTuningLevel") != null && !jsonObj.get("QualityTuningLevel").isJsonNull()) {
        H264QualityTuningLevel.validateJsonElement(jsonObj.get("QualityTuningLevel"));
      }
      // validate the optional field `QvbrSettings`
      if (jsonObj.get("QvbrSettings") != null && !jsonObj.get("QvbrSettings").isJsonNull()) {
        H264SettingsQvbrSettings.validateJsonElement(jsonObj.get("QvbrSettings"));
      }
      // validate the optional field `RateControlMode`
      if (jsonObj.get("RateControlMode") != null && !jsonObj.get("RateControlMode").isJsonNull()) {
        H264RateControlMode.validateJsonElement(jsonObj.get("RateControlMode"));
      }
      // validate the optional field `RepeatPps`
      if (jsonObj.get("RepeatPps") != null && !jsonObj.get("RepeatPps").isJsonNull()) {
        H264RepeatPps.validateJsonElement(jsonObj.get("RepeatPps"));
      }
      // validate the optional field `ScanTypeConversionMode`
      if (jsonObj.get("ScanTypeConversionMode") != null && !jsonObj.get("ScanTypeConversionMode").isJsonNull()) {
        H264ScanTypeConversionMode.validateJsonElement(jsonObj.get("ScanTypeConversionMode"));
      }
      // validate the optional field `SceneChangeDetect`
      if (jsonObj.get("SceneChangeDetect") != null && !jsonObj.get("SceneChangeDetect").isJsonNull()) {
        H264SceneChangeDetect.validateJsonElement(jsonObj.get("SceneChangeDetect"));
      }
      // validate the optional field `Slices`
      if (jsonObj.get("Slices") != null && !jsonObj.get("Slices").isJsonNull()) {
        Integer.validateJsonElement(jsonObj.get("Slices"));
      }
      // validate the optional field `SlowPal`
      if (jsonObj.get("SlowPal") != null && !jsonObj.get("SlowPal").isJsonNull()) {
        H264SlowPal.validateJsonElement(jsonObj.get("SlowPal"));
      }
      // validate the optional field `Softness`
      if (jsonObj.get("Softness") != null && !jsonObj.get("Softness").isJsonNull()) {
        Integer.validateJsonElement(jsonObj.get("Softness"));
      }
      // validate the optional field `SpatialAdaptiveQuantization`
      if (jsonObj.get("SpatialAdaptiveQuantization") != null && !jsonObj.get("SpatialAdaptiveQuantization").isJsonNull()) {
        H264SpatialAdaptiveQuantization.validateJsonElement(jsonObj.get("SpatialAdaptiveQuantization"));
      }
      // validate the optional field `Syntax`
      if (jsonObj.get("Syntax") != null && !jsonObj.get("Syntax").isJsonNull()) {
        H264Syntax.validateJsonElement(jsonObj.get("Syntax"));
      }
      // validate the optional field `Telecine`
      if (jsonObj.get("Telecine") != null && !jsonObj.get("Telecine").isJsonNull()) {
        H264Telecine.validateJsonElement(jsonObj.get("Telecine"));
      }
      // validate the optional field `TemporalAdaptiveQuantization`
      if (jsonObj.get("TemporalAdaptiveQuantization") != null && !jsonObj.get("TemporalAdaptiveQuantization").isJsonNull()) {
        H264TemporalAdaptiveQuantization.validateJsonElement(jsonObj.get("TemporalAdaptiveQuantization"));
      }
      // validate the optional field `UnregisteredSeiTimecode`
      if (jsonObj.get("UnregisteredSeiTimecode") != null && !jsonObj.get("UnregisteredSeiTimecode").isJsonNull()) {
        H264UnregisteredSeiTimecode.validateJsonElement(jsonObj.get("UnregisteredSeiTimecode"));
      }
  }

  public static class CustomTypeAdapterFactory implements TypeAdapterFactory {
    @SuppressWarnings("unchecked")
    @Override
    public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
       if (!H264Settings.class.isAssignableFrom(type.getRawType())) {
         return null; // this class only serializes 'H264Settings' and its subtypes
       }
       final TypeAdapter<JsonElement> elementAdapter = gson.getAdapter(JsonElement.class);
       final TypeAdapter<H264Settings> thisAdapter
                        = gson.getDelegateAdapter(this, TypeToken.get(H264Settings.class));

       return (TypeAdapter<T>) new TypeAdapter<H264Settings>() {
           @Override
           public void write(JsonWriter out, H264Settings value) throws IOException {
             JsonObject obj = thisAdapter.toJsonTree(value).getAsJsonObject();
             elementAdapter.write(out, obj);
           }

           @Override
           public H264Settings read(JsonReader in) throws IOException {
             JsonElement jsonElement = elementAdapter.read(in);
             validateJsonElement(jsonElement);
             return thisAdapter.fromJsonTree(jsonElement);
           }

       }.nullSafe();
    }
  }

  /**
   * Create an instance of H264Settings given an JSON string
   *
   * @param jsonString JSON string
   * @return An instance of H264Settings
   * @throws IOException if the JSON string is invalid with respect to H264Settings
   */
  public static H264Settings fromJson(String jsonString) throws IOException {
    return JSON.getGson().fromJson(jsonString, H264Settings.class);
  }

  /**
   * Convert an instance of H264Settings to an JSON string
   *
   * @return JSON string
   */
  public String toJson() {
    return JSON.getGson().toJson(this);
  }
}

