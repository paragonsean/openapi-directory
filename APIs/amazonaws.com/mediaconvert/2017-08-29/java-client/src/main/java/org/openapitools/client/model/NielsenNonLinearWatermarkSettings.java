/*
 * AWS Elemental MediaConvert
 * AWS Elemental MediaConvert
 *
 * The version of the OpenAPI document: 2017-08-29
 * Contact: mike.ralphson@gmail.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package org.openapitools.client.model;

import java.util.Objects;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;
import java.util.Arrays;
import org.openapitools.client.model.NielsenActiveWatermarkProcessType;
import org.openapitools.client.model.NielsenSourceWatermarkStatusType;
import org.openapitools.client.model.NielsenUniqueTicPerAudioTrackType;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonArray;
import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;
import com.google.gson.TypeAdapterFactory;
import com.google.gson.reflect.TypeToken;
import com.google.gson.TypeAdapter;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;

import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import org.openapitools.client.JSON;

/**
 * Ignore these settings unless you are using Nielsen non-linear watermarking. Specify the values that MediaConvert uses to generate and place Nielsen watermarks in your output audio. In addition to specifying these values, you also need to set up your cloud TIC server. These settings apply to every output in your job. The MediaConvert implementation is currently with the following Nielsen versions: Nielsen Watermark SDK Version 5.2.1 Nielsen NLM Watermark Engine Version 1.2.7 Nielsen Watermark Authenticator [SID_TIC] Version [5.0.0]
 */
@javax.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen", date = "2024-10-12T12:24:13.098140-04:00[America/New_York]", comments = "Generator version: 7.9.0")
public class NielsenNonLinearWatermarkSettings {
  public static final String SERIALIZED_NAME_ACTIVE_WATERMARK_PROCESS = "ActiveWatermarkProcess";
  @SerializedName(SERIALIZED_NAME_ACTIVE_WATERMARK_PROCESS)
  private NielsenActiveWatermarkProcessType activeWatermarkProcess;

  public static final String SERIALIZED_NAME_ADI_FILENAME = "AdiFilename";
  @SerializedName(SERIALIZED_NAME_ADI_FILENAME)
  private String adiFilename;

  public static final String SERIALIZED_NAME_ASSET_ID = "AssetId";
  @SerializedName(SERIALIZED_NAME_ASSET_ID)
  private String assetId;

  public static final String SERIALIZED_NAME_ASSET_NAME = "AssetName";
  @SerializedName(SERIALIZED_NAME_ASSET_NAME)
  private String assetName;

  public static final String SERIALIZED_NAME_CBET_SOURCE_ID = "CbetSourceId";
  @SerializedName(SERIALIZED_NAME_CBET_SOURCE_ID)
  private String cbetSourceId;

  public static final String SERIALIZED_NAME_EPISODE_ID = "EpisodeId";
  @SerializedName(SERIALIZED_NAME_EPISODE_ID)
  private String episodeId;

  public static final String SERIALIZED_NAME_METADATA_DESTINATION = "MetadataDestination";
  @SerializedName(SERIALIZED_NAME_METADATA_DESTINATION)
  private String metadataDestination;

  public static final String SERIALIZED_NAME_SOURCE_ID = "SourceId";
  @SerializedName(SERIALIZED_NAME_SOURCE_ID)
  private Integer sourceId;

  public static final String SERIALIZED_NAME_SOURCE_WATERMARK_STATUS = "SourceWatermarkStatus";
  @SerializedName(SERIALIZED_NAME_SOURCE_WATERMARK_STATUS)
  private NielsenSourceWatermarkStatusType sourceWatermarkStatus;

  public static final String SERIALIZED_NAME_TIC_SERVER_URL = "TicServerUrl";
  @SerializedName(SERIALIZED_NAME_TIC_SERVER_URL)
  private String ticServerUrl;

  public static final String SERIALIZED_NAME_UNIQUE_TIC_PER_AUDIO_TRACK = "UniqueTicPerAudioTrack";
  @SerializedName(SERIALIZED_NAME_UNIQUE_TIC_PER_AUDIO_TRACK)
  private NielsenUniqueTicPerAudioTrackType uniqueTicPerAudioTrack;

  public NielsenNonLinearWatermarkSettings() {
  }

  public NielsenNonLinearWatermarkSettings activeWatermarkProcess(NielsenActiveWatermarkProcessType activeWatermarkProcess) {
    this.activeWatermarkProcess = activeWatermarkProcess;
    return this;
  }

  /**
   * Get activeWatermarkProcess
   * @return activeWatermarkProcess
   */
  @javax.annotation.Nullable
  public NielsenActiveWatermarkProcessType getActiveWatermarkProcess() {
    return activeWatermarkProcess;
  }

  public void setActiveWatermarkProcess(NielsenActiveWatermarkProcessType activeWatermarkProcess) {
    this.activeWatermarkProcess = activeWatermarkProcess;
  }


  public NielsenNonLinearWatermarkSettings adiFilename(String adiFilename) {
    this.adiFilename = adiFilename;
    return this;
  }

  /**
   * Get adiFilename
   * @return adiFilename
   */
  @javax.annotation.Nullable
  public String getAdiFilename() {
    return adiFilename;
  }

  public void setAdiFilename(String adiFilename) {
    this.adiFilename = adiFilename;
  }


  public NielsenNonLinearWatermarkSettings assetId(String assetId) {
    this.assetId = assetId;
    return this;
  }

  /**
   * Get assetId
   * @return assetId
   */
  @javax.annotation.Nullable
  public String getAssetId() {
    return assetId;
  }

  public void setAssetId(String assetId) {
    this.assetId = assetId;
  }


  public NielsenNonLinearWatermarkSettings assetName(String assetName) {
    this.assetName = assetName;
    return this;
  }

  /**
   * Get assetName
   * @return assetName
   */
  @javax.annotation.Nullable
  public String getAssetName() {
    return assetName;
  }

  public void setAssetName(String assetName) {
    this.assetName = assetName;
  }


  public NielsenNonLinearWatermarkSettings cbetSourceId(String cbetSourceId) {
    this.cbetSourceId = cbetSourceId;
    return this;
  }

  /**
   * Get cbetSourceId
   * @return cbetSourceId
   */
  @javax.annotation.Nullable
  public String getCbetSourceId() {
    return cbetSourceId;
  }

  public void setCbetSourceId(String cbetSourceId) {
    this.cbetSourceId = cbetSourceId;
  }


  public NielsenNonLinearWatermarkSettings episodeId(String episodeId) {
    this.episodeId = episodeId;
    return this;
  }

  /**
   * Get episodeId
   * @return episodeId
   */
  @javax.annotation.Nullable
  public String getEpisodeId() {
    return episodeId;
  }

  public void setEpisodeId(String episodeId) {
    this.episodeId = episodeId;
  }


  public NielsenNonLinearWatermarkSettings metadataDestination(String metadataDestination) {
    this.metadataDestination = metadataDestination;
    return this;
  }

  /**
   * Get metadataDestination
   * @return metadataDestination
   */
  @javax.annotation.Nullable
  public String getMetadataDestination() {
    return metadataDestination;
  }

  public void setMetadataDestination(String metadataDestination) {
    this.metadataDestination = metadataDestination;
  }


  public NielsenNonLinearWatermarkSettings sourceId(Integer sourceId) {
    this.sourceId = sourceId;
    return this;
  }

  /**
   * Get sourceId
   * @return sourceId
   */
  @javax.annotation.Nullable
  public Integer getSourceId() {
    return sourceId;
  }

  public void setSourceId(Integer sourceId) {
    this.sourceId = sourceId;
  }


  public NielsenNonLinearWatermarkSettings sourceWatermarkStatus(NielsenSourceWatermarkStatusType sourceWatermarkStatus) {
    this.sourceWatermarkStatus = sourceWatermarkStatus;
    return this;
  }

  /**
   * Get sourceWatermarkStatus
   * @return sourceWatermarkStatus
   */
  @javax.annotation.Nullable
  public NielsenSourceWatermarkStatusType getSourceWatermarkStatus() {
    return sourceWatermarkStatus;
  }

  public void setSourceWatermarkStatus(NielsenSourceWatermarkStatusType sourceWatermarkStatus) {
    this.sourceWatermarkStatus = sourceWatermarkStatus;
  }


  public NielsenNonLinearWatermarkSettings ticServerUrl(String ticServerUrl) {
    this.ticServerUrl = ticServerUrl;
    return this;
  }

  /**
   * Get ticServerUrl
   * @return ticServerUrl
   */
  @javax.annotation.Nullable
  public String getTicServerUrl() {
    return ticServerUrl;
  }

  public void setTicServerUrl(String ticServerUrl) {
    this.ticServerUrl = ticServerUrl;
  }


  public NielsenNonLinearWatermarkSettings uniqueTicPerAudioTrack(NielsenUniqueTicPerAudioTrackType uniqueTicPerAudioTrack) {
    this.uniqueTicPerAudioTrack = uniqueTicPerAudioTrack;
    return this;
  }

  /**
   * Get uniqueTicPerAudioTrack
   * @return uniqueTicPerAudioTrack
   */
  @javax.annotation.Nullable
  public NielsenUniqueTicPerAudioTrackType getUniqueTicPerAudioTrack() {
    return uniqueTicPerAudioTrack;
  }

  public void setUniqueTicPerAudioTrack(NielsenUniqueTicPerAudioTrackType uniqueTicPerAudioTrack) {
    this.uniqueTicPerAudioTrack = uniqueTicPerAudioTrack;
  }



  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    NielsenNonLinearWatermarkSettings nielsenNonLinearWatermarkSettings = (NielsenNonLinearWatermarkSettings) o;
    return Objects.equals(this.activeWatermarkProcess, nielsenNonLinearWatermarkSettings.activeWatermarkProcess) &&
        Objects.equals(this.adiFilename, nielsenNonLinearWatermarkSettings.adiFilename) &&
        Objects.equals(this.assetId, nielsenNonLinearWatermarkSettings.assetId) &&
        Objects.equals(this.assetName, nielsenNonLinearWatermarkSettings.assetName) &&
        Objects.equals(this.cbetSourceId, nielsenNonLinearWatermarkSettings.cbetSourceId) &&
        Objects.equals(this.episodeId, nielsenNonLinearWatermarkSettings.episodeId) &&
        Objects.equals(this.metadataDestination, nielsenNonLinearWatermarkSettings.metadataDestination) &&
        Objects.equals(this.sourceId, nielsenNonLinearWatermarkSettings.sourceId) &&
        Objects.equals(this.sourceWatermarkStatus, nielsenNonLinearWatermarkSettings.sourceWatermarkStatus) &&
        Objects.equals(this.ticServerUrl, nielsenNonLinearWatermarkSettings.ticServerUrl) &&
        Objects.equals(this.uniqueTicPerAudioTrack, nielsenNonLinearWatermarkSettings.uniqueTicPerAudioTrack);
  }

  @Override
  public int hashCode() {
    return Objects.hash(activeWatermarkProcess, adiFilename, assetId, assetName, cbetSourceId, episodeId, metadataDestination, sourceId, sourceWatermarkStatus, ticServerUrl, uniqueTicPerAudioTrack);
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class NielsenNonLinearWatermarkSettings {\n");
    sb.append("    activeWatermarkProcess: ").append(toIndentedString(activeWatermarkProcess)).append("\n");
    sb.append("    adiFilename: ").append(toIndentedString(adiFilename)).append("\n");
    sb.append("    assetId: ").append(toIndentedString(assetId)).append("\n");
    sb.append("    assetName: ").append(toIndentedString(assetName)).append("\n");
    sb.append("    cbetSourceId: ").append(toIndentedString(cbetSourceId)).append("\n");
    sb.append("    episodeId: ").append(toIndentedString(episodeId)).append("\n");
    sb.append("    metadataDestination: ").append(toIndentedString(metadataDestination)).append("\n");
    sb.append("    sourceId: ").append(toIndentedString(sourceId)).append("\n");
    sb.append("    sourceWatermarkStatus: ").append(toIndentedString(sourceWatermarkStatus)).append("\n");
    sb.append("    ticServerUrl: ").append(toIndentedString(ticServerUrl)).append("\n");
    sb.append("    uniqueTicPerAudioTrack: ").append(toIndentedString(uniqueTicPerAudioTrack)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }


  public static HashSet<String> openapiFields;
  public static HashSet<String> openapiRequiredFields;

  static {
    // a set of all properties/fields (JSON key names)
    openapiFields = new HashSet<String>();
    openapiFields.add("ActiveWatermarkProcess");
    openapiFields.add("AdiFilename");
    openapiFields.add("AssetId");
    openapiFields.add("AssetName");
    openapiFields.add("CbetSourceId");
    openapiFields.add("EpisodeId");
    openapiFields.add("MetadataDestination");
    openapiFields.add("SourceId");
    openapiFields.add("SourceWatermarkStatus");
    openapiFields.add("TicServerUrl");
    openapiFields.add("UniqueTicPerAudioTrack");

    // a set of required properties/fields (JSON key names)
    openapiRequiredFields = new HashSet<String>();
  }

  /**
   * Validates the JSON Element and throws an exception if issues found
   *
   * @param jsonElement JSON Element
   * @throws IOException if the JSON Element is invalid with respect to NielsenNonLinearWatermarkSettings
   */
  public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      if (jsonElement == null) {
        if (!NielsenNonLinearWatermarkSettings.openapiRequiredFields.isEmpty()) { // has required fields but JSON element is null
          throw new IllegalArgumentException(String.format("The required field(s) %s in NielsenNonLinearWatermarkSettings is not found in the empty JSON string", NielsenNonLinearWatermarkSettings.openapiRequiredFields.toString()));
        }
      }

      Set<Map.Entry<String, JsonElement>> entries = jsonElement.getAsJsonObject().entrySet();
      // check to see if the JSON string contains additional fields
      for (Map.Entry<String, JsonElement> entry : entries) {
        if (!NielsenNonLinearWatermarkSettings.openapiFields.contains(entry.getKey())) {
          throw new IllegalArgumentException(String.format("The field `%s` in the JSON string is not defined in the `NielsenNonLinearWatermarkSettings` properties. JSON: %s", entry.getKey(), jsonElement.toString()));
        }
      }
        JsonObject jsonObj = jsonElement.getAsJsonObject();
      // validate the optional field `ActiveWatermarkProcess`
      if (jsonObj.get("ActiveWatermarkProcess") != null && !jsonObj.get("ActiveWatermarkProcess").isJsonNull()) {
        NielsenActiveWatermarkProcessType.validateJsonElement(jsonObj.get("ActiveWatermarkProcess"));
      }
      // validate the optional field `AdiFilename`
      if (jsonObj.get("AdiFilename") != null && !jsonObj.get("AdiFilename").isJsonNull()) {
        String.validateJsonElement(jsonObj.get("AdiFilename"));
      }
      // validate the optional field `AssetId`
      if (jsonObj.get("AssetId") != null && !jsonObj.get("AssetId").isJsonNull()) {
        String.validateJsonElement(jsonObj.get("AssetId"));
      }
      // validate the optional field `AssetName`
      if (jsonObj.get("AssetName") != null && !jsonObj.get("AssetName").isJsonNull()) {
        String.validateJsonElement(jsonObj.get("AssetName"));
      }
      // validate the optional field `CbetSourceId`
      if (jsonObj.get("CbetSourceId") != null && !jsonObj.get("CbetSourceId").isJsonNull()) {
        String.validateJsonElement(jsonObj.get("CbetSourceId"));
      }
      // validate the optional field `EpisodeId`
      if (jsonObj.get("EpisodeId") != null && !jsonObj.get("EpisodeId").isJsonNull()) {
        String.validateJsonElement(jsonObj.get("EpisodeId"));
      }
      // validate the optional field `MetadataDestination`
      if (jsonObj.get("MetadataDestination") != null && !jsonObj.get("MetadataDestination").isJsonNull()) {
        String.validateJsonElement(jsonObj.get("MetadataDestination"));
      }
      // validate the optional field `SourceId`
      if (jsonObj.get("SourceId") != null && !jsonObj.get("SourceId").isJsonNull()) {
        Integer.validateJsonElement(jsonObj.get("SourceId"));
      }
      // validate the optional field `SourceWatermarkStatus`
      if (jsonObj.get("SourceWatermarkStatus") != null && !jsonObj.get("SourceWatermarkStatus").isJsonNull()) {
        NielsenSourceWatermarkStatusType.validateJsonElement(jsonObj.get("SourceWatermarkStatus"));
      }
      // validate the optional field `TicServerUrl`
      if (jsonObj.get("TicServerUrl") != null && !jsonObj.get("TicServerUrl").isJsonNull()) {
        String.validateJsonElement(jsonObj.get("TicServerUrl"));
      }
      // validate the optional field `UniqueTicPerAudioTrack`
      if (jsonObj.get("UniqueTicPerAudioTrack") != null && !jsonObj.get("UniqueTicPerAudioTrack").isJsonNull()) {
        NielsenUniqueTicPerAudioTrackType.validateJsonElement(jsonObj.get("UniqueTicPerAudioTrack"));
      }
  }

  public static class CustomTypeAdapterFactory implements TypeAdapterFactory {
    @SuppressWarnings("unchecked")
    @Override
    public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
       if (!NielsenNonLinearWatermarkSettings.class.isAssignableFrom(type.getRawType())) {
         return null; // this class only serializes 'NielsenNonLinearWatermarkSettings' and its subtypes
       }
       final TypeAdapter<JsonElement> elementAdapter = gson.getAdapter(JsonElement.class);
       final TypeAdapter<NielsenNonLinearWatermarkSettings> thisAdapter
                        = gson.getDelegateAdapter(this, TypeToken.get(NielsenNonLinearWatermarkSettings.class));

       return (TypeAdapter<T>) new TypeAdapter<NielsenNonLinearWatermarkSettings>() {
           @Override
           public void write(JsonWriter out, NielsenNonLinearWatermarkSettings value) throws IOException {
             JsonObject obj = thisAdapter.toJsonTree(value).getAsJsonObject();
             elementAdapter.write(out, obj);
           }

           @Override
           public NielsenNonLinearWatermarkSettings read(JsonReader in) throws IOException {
             JsonElement jsonElement = elementAdapter.read(in);
             validateJsonElement(jsonElement);
             return thisAdapter.fromJsonTree(jsonElement);
           }

       }.nullSafe();
    }
  }

  /**
   * Create an instance of NielsenNonLinearWatermarkSettings given an JSON string
   *
   * @param jsonString JSON string
   * @return An instance of NielsenNonLinearWatermarkSettings
   * @throws IOException if the JSON string is invalid with respect to NielsenNonLinearWatermarkSettings
   */
  public static NielsenNonLinearWatermarkSettings fromJson(String jsonString) throws IOException {
    return JSON.getGson().fromJson(jsonString, NielsenNonLinearWatermarkSettings.class);
  }

  /**
   * Convert an instance of NielsenNonLinearWatermarkSettings to an JSON string
   *
   * @return JSON string
   */
  public String toJson() {
    return JSON.getGson().toJson(this);
  }
}

