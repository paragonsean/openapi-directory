/*
 * AWS Elemental MediaConvert
 * AWS Elemental MediaConvert
 *
 * The version of the OpenAPI document: 2017-08-29
 * Contact: mike.ralphson@gmail.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package org.openapitools.client.model;

import java.util.Objects;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;
import java.util.Arrays;
import org.openapitools.client.model.AudioDescriptionAudioChannelTaggingSettings;
import org.openapitools.client.model.AudioDescriptionAudioNormalizationSettings;
import org.openapitools.client.model.AudioDescriptionCodecSettings;
import org.openapitools.client.model.AudioDescriptionRemixSettings;
import org.openapitools.client.model.AudioLanguageCodeControl;
import org.openapitools.client.model.AudioTypeControl;
import org.openapitools.client.model.LanguageCode;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonArray;
import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;
import com.google.gson.TypeAdapterFactory;
import com.google.gson.reflect.TypeToken;
import com.google.gson.TypeAdapter;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;

import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import org.openapitools.client.JSON;

/**
 * Settings related to one audio tab on the MediaConvert console. In your job JSON, an instance of AudioDescription is equivalent to one audio tab in the console. Usually, one audio tab corresponds to one output audio track. Depending on how you set up your input audio selectors and whether you use audio selector groups, one audio tab can correspond to a group of output audio tracks.
 */
@javax.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen", date = "2024-10-12T12:24:13.098140-04:00[America/New_York]", comments = "Generator version: 7.9.0")
public class AudioDescription {
  public static final String SERIALIZED_NAME_AUDIO_CHANNEL_TAGGING_SETTINGS = "AudioChannelTaggingSettings";
  @SerializedName(SERIALIZED_NAME_AUDIO_CHANNEL_TAGGING_SETTINGS)
  private AudioDescriptionAudioChannelTaggingSettings audioChannelTaggingSettings;

  public static final String SERIALIZED_NAME_AUDIO_NORMALIZATION_SETTINGS = "AudioNormalizationSettings";
  @SerializedName(SERIALIZED_NAME_AUDIO_NORMALIZATION_SETTINGS)
  private AudioDescriptionAudioNormalizationSettings audioNormalizationSettings;

  public static final String SERIALIZED_NAME_AUDIO_SOURCE_NAME = "AudioSourceName";
  @SerializedName(SERIALIZED_NAME_AUDIO_SOURCE_NAME)
  private String audioSourceName;

  public static final String SERIALIZED_NAME_AUDIO_TYPE = "AudioType";
  @SerializedName(SERIALIZED_NAME_AUDIO_TYPE)
  private Integer audioType;

  public static final String SERIALIZED_NAME_AUDIO_TYPE_CONTROL = "AudioTypeControl";
  @SerializedName(SERIALIZED_NAME_AUDIO_TYPE_CONTROL)
  private AudioTypeControl audioTypeControl;

  public static final String SERIALIZED_NAME_CODEC_SETTINGS = "CodecSettings";
  @SerializedName(SERIALIZED_NAME_CODEC_SETTINGS)
  private AudioDescriptionCodecSettings codecSettings;

  public static final String SERIALIZED_NAME_CUSTOM_LANGUAGE_CODE = "CustomLanguageCode";
  @SerializedName(SERIALIZED_NAME_CUSTOM_LANGUAGE_CODE)
  private String customLanguageCode;

  public static final String SERIALIZED_NAME_LANGUAGE_CODE = "LanguageCode";
  @SerializedName(SERIALIZED_NAME_LANGUAGE_CODE)
  private LanguageCode languageCode;

  public static final String SERIALIZED_NAME_LANGUAGE_CODE_CONTROL = "LanguageCodeControl";
  @SerializedName(SERIALIZED_NAME_LANGUAGE_CODE_CONTROL)
  private AudioLanguageCodeControl languageCodeControl;

  public static final String SERIALIZED_NAME_REMIX_SETTINGS = "RemixSettings";
  @SerializedName(SERIALIZED_NAME_REMIX_SETTINGS)
  private AudioDescriptionRemixSettings remixSettings;

  public static final String SERIALIZED_NAME_STREAM_NAME = "StreamName";
  @SerializedName(SERIALIZED_NAME_STREAM_NAME)
  private String streamName;

  public AudioDescription() {
  }

  public AudioDescription audioChannelTaggingSettings(AudioDescriptionAudioChannelTaggingSettings audioChannelTaggingSettings) {
    this.audioChannelTaggingSettings = audioChannelTaggingSettings;
    return this;
  }

  /**
   * Get audioChannelTaggingSettings
   * @return audioChannelTaggingSettings
   */
  @javax.annotation.Nullable
  public AudioDescriptionAudioChannelTaggingSettings getAudioChannelTaggingSettings() {
    return audioChannelTaggingSettings;
  }

  public void setAudioChannelTaggingSettings(AudioDescriptionAudioChannelTaggingSettings audioChannelTaggingSettings) {
    this.audioChannelTaggingSettings = audioChannelTaggingSettings;
  }


  public AudioDescription audioNormalizationSettings(AudioDescriptionAudioNormalizationSettings audioNormalizationSettings) {
    this.audioNormalizationSettings = audioNormalizationSettings;
    return this;
  }

  /**
   * Get audioNormalizationSettings
   * @return audioNormalizationSettings
   */
  @javax.annotation.Nullable
  public AudioDescriptionAudioNormalizationSettings getAudioNormalizationSettings() {
    return audioNormalizationSettings;
  }

  public void setAudioNormalizationSettings(AudioDescriptionAudioNormalizationSettings audioNormalizationSettings) {
    this.audioNormalizationSettings = audioNormalizationSettings;
  }


  public AudioDescription audioSourceName(String audioSourceName) {
    this.audioSourceName = audioSourceName;
    return this;
  }

  /**
   * Get audioSourceName
   * @return audioSourceName
   */
  @javax.annotation.Nullable
  public String getAudioSourceName() {
    return audioSourceName;
  }

  public void setAudioSourceName(String audioSourceName) {
    this.audioSourceName = audioSourceName;
  }


  public AudioDescription audioType(Integer audioType) {
    this.audioType = audioType;
    return this;
  }

  /**
   * Get audioType
   * @return audioType
   */
  @javax.annotation.Nullable
  public Integer getAudioType() {
    return audioType;
  }

  public void setAudioType(Integer audioType) {
    this.audioType = audioType;
  }


  public AudioDescription audioTypeControl(AudioTypeControl audioTypeControl) {
    this.audioTypeControl = audioTypeControl;
    return this;
  }

  /**
   * Get audioTypeControl
   * @return audioTypeControl
   */
  @javax.annotation.Nullable
  public AudioTypeControl getAudioTypeControl() {
    return audioTypeControl;
  }

  public void setAudioTypeControl(AudioTypeControl audioTypeControl) {
    this.audioTypeControl = audioTypeControl;
  }


  public AudioDescription codecSettings(AudioDescriptionCodecSettings codecSettings) {
    this.codecSettings = codecSettings;
    return this;
  }

  /**
   * Get codecSettings
   * @return codecSettings
   */
  @javax.annotation.Nullable
  public AudioDescriptionCodecSettings getCodecSettings() {
    return codecSettings;
  }

  public void setCodecSettings(AudioDescriptionCodecSettings codecSettings) {
    this.codecSettings = codecSettings;
  }


  public AudioDescription customLanguageCode(String customLanguageCode) {
    this.customLanguageCode = customLanguageCode;
    return this;
  }

  /**
   * Get customLanguageCode
   * @return customLanguageCode
   */
  @javax.annotation.Nullable
  public String getCustomLanguageCode() {
    return customLanguageCode;
  }

  public void setCustomLanguageCode(String customLanguageCode) {
    this.customLanguageCode = customLanguageCode;
  }


  public AudioDescription languageCode(LanguageCode languageCode) {
    this.languageCode = languageCode;
    return this;
  }

  /**
   * Get languageCode
   * @return languageCode
   */
  @javax.annotation.Nullable
  public LanguageCode getLanguageCode() {
    return languageCode;
  }

  public void setLanguageCode(LanguageCode languageCode) {
    this.languageCode = languageCode;
  }


  public AudioDescription languageCodeControl(AudioLanguageCodeControl languageCodeControl) {
    this.languageCodeControl = languageCodeControl;
    return this;
  }

  /**
   * Get languageCodeControl
   * @return languageCodeControl
   */
  @javax.annotation.Nullable
  public AudioLanguageCodeControl getLanguageCodeControl() {
    return languageCodeControl;
  }

  public void setLanguageCodeControl(AudioLanguageCodeControl languageCodeControl) {
    this.languageCodeControl = languageCodeControl;
  }


  public AudioDescription remixSettings(AudioDescriptionRemixSettings remixSettings) {
    this.remixSettings = remixSettings;
    return this;
  }

  /**
   * Get remixSettings
   * @return remixSettings
   */
  @javax.annotation.Nullable
  public AudioDescriptionRemixSettings getRemixSettings() {
    return remixSettings;
  }

  public void setRemixSettings(AudioDescriptionRemixSettings remixSettings) {
    this.remixSettings = remixSettings;
  }


  public AudioDescription streamName(String streamName) {
    this.streamName = streamName;
    return this;
  }

  /**
   * Get streamName
   * @return streamName
   */
  @javax.annotation.Nullable
  public String getStreamName() {
    return streamName;
  }

  public void setStreamName(String streamName) {
    this.streamName = streamName;
  }



  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    AudioDescription audioDescription = (AudioDescription) o;
    return Objects.equals(this.audioChannelTaggingSettings, audioDescription.audioChannelTaggingSettings) &&
        Objects.equals(this.audioNormalizationSettings, audioDescription.audioNormalizationSettings) &&
        Objects.equals(this.audioSourceName, audioDescription.audioSourceName) &&
        Objects.equals(this.audioType, audioDescription.audioType) &&
        Objects.equals(this.audioTypeControl, audioDescription.audioTypeControl) &&
        Objects.equals(this.codecSettings, audioDescription.codecSettings) &&
        Objects.equals(this.customLanguageCode, audioDescription.customLanguageCode) &&
        Objects.equals(this.languageCode, audioDescription.languageCode) &&
        Objects.equals(this.languageCodeControl, audioDescription.languageCodeControl) &&
        Objects.equals(this.remixSettings, audioDescription.remixSettings) &&
        Objects.equals(this.streamName, audioDescription.streamName);
  }

  @Override
  public int hashCode() {
    return Objects.hash(audioChannelTaggingSettings, audioNormalizationSettings, audioSourceName, audioType, audioTypeControl, codecSettings, customLanguageCode, languageCode, languageCodeControl, remixSettings, streamName);
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class AudioDescription {\n");
    sb.append("    audioChannelTaggingSettings: ").append(toIndentedString(audioChannelTaggingSettings)).append("\n");
    sb.append("    audioNormalizationSettings: ").append(toIndentedString(audioNormalizationSettings)).append("\n");
    sb.append("    audioSourceName: ").append(toIndentedString(audioSourceName)).append("\n");
    sb.append("    audioType: ").append(toIndentedString(audioType)).append("\n");
    sb.append("    audioTypeControl: ").append(toIndentedString(audioTypeControl)).append("\n");
    sb.append("    codecSettings: ").append(toIndentedString(codecSettings)).append("\n");
    sb.append("    customLanguageCode: ").append(toIndentedString(customLanguageCode)).append("\n");
    sb.append("    languageCode: ").append(toIndentedString(languageCode)).append("\n");
    sb.append("    languageCodeControl: ").append(toIndentedString(languageCodeControl)).append("\n");
    sb.append("    remixSettings: ").append(toIndentedString(remixSettings)).append("\n");
    sb.append("    streamName: ").append(toIndentedString(streamName)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }


  public static HashSet<String> openapiFields;
  public static HashSet<String> openapiRequiredFields;

  static {
    // a set of all properties/fields (JSON key names)
    openapiFields = new HashSet<String>();
    openapiFields.add("AudioChannelTaggingSettings");
    openapiFields.add("AudioNormalizationSettings");
    openapiFields.add("AudioSourceName");
    openapiFields.add("AudioType");
    openapiFields.add("AudioTypeControl");
    openapiFields.add("CodecSettings");
    openapiFields.add("CustomLanguageCode");
    openapiFields.add("LanguageCode");
    openapiFields.add("LanguageCodeControl");
    openapiFields.add("RemixSettings");
    openapiFields.add("StreamName");

    // a set of required properties/fields (JSON key names)
    openapiRequiredFields = new HashSet<String>();
  }

  /**
   * Validates the JSON Element and throws an exception if issues found
   *
   * @param jsonElement JSON Element
   * @throws IOException if the JSON Element is invalid with respect to AudioDescription
   */
  public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      if (jsonElement == null) {
        if (!AudioDescription.openapiRequiredFields.isEmpty()) { // has required fields but JSON element is null
          throw new IllegalArgumentException(String.format("The required field(s) %s in AudioDescription is not found in the empty JSON string", AudioDescription.openapiRequiredFields.toString()));
        }
      }

      Set<Map.Entry<String, JsonElement>> entries = jsonElement.getAsJsonObject().entrySet();
      // check to see if the JSON string contains additional fields
      for (Map.Entry<String, JsonElement> entry : entries) {
        if (!AudioDescription.openapiFields.contains(entry.getKey())) {
          throw new IllegalArgumentException(String.format("The field `%s` in the JSON string is not defined in the `AudioDescription` properties. JSON: %s", entry.getKey(), jsonElement.toString()));
        }
      }
        JsonObject jsonObj = jsonElement.getAsJsonObject();
      // validate the optional field `AudioChannelTaggingSettings`
      if (jsonObj.get("AudioChannelTaggingSettings") != null && !jsonObj.get("AudioChannelTaggingSettings").isJsonNull()) {
        AudioDescriptionAudioChannelTaggingSettings.validateJsonElement(jsonObj.get("AudioChannelTaggingSettings"));
      }
      // validate the optional field `AudioNormalizationSettings`
      if (jsonObj.get("AudioNormalizationSettings") != null && !jsonObj.get("AudioNormalizationSettings").isJsonNull()) {
        AudioDescriptionAudioNormalizationSettings.validateJsonElement(jsonObj.get("AudioNormalizationSettings"));
      }
      // validate the optional field `AudioSourceName`
      if (jsonObj.get("AudioSourceName") != null && !jsonObj.get("AudioSourceName").isJsonNull()) {
        String.validateJsonElement(jsonObj.get("AudioSourceName"));
      }
      // validate the optional field `AudioType`
      if (jsonObj.get("AudioType") != null && !jsonObj.get("AudioType").isJsonNull()) {
        Integer.validateJsonElement(jsonObj.get("AudioType"));
      }
      // validate the optional field `AudioTypeControl`
      if (jsonObj.get("AudioTypeControl") != null && !jsonObj.get("AudioTypeControl").isJsonNull()) {
        AudioTypeControl.validateJsonElement(jsonObj.get("AudioTypeControl"));
      }
      // validate the optional field `CodecSettings`
      if (jsonObj.get("CodecSettings") != null && !jsonObj.get("CodecSettings").isJsonNull()) {
        AudioDescriptionCodecSettings.validateJsonElement(jsonObj.get("CodecSettings"));
      }
      // validate the optional field `CustomLanguageCode`
      if (jsonObj.get("CustomLanguageCode") != null && !jsonObj.get("CustomLanguageCode").isJsonNull()) {
        String.validateJsonElement(jsonObj.get("CustomLanguageCode"));
      }
      // validate the optional field `LanguageCode`
      if (jsonObj.get("LanguageCode") != null && !jsonObj.get("LanguageCode").isJsonNull()) {
        LanguageCode.validateJsonElement(jsonObj.get("LanguageCode"));
      }
      // validate the optional field `LanguageCodeControl`
      if (jsonObj.get("LanguageCodeControl") != null && !jsonObj.get("LanguageCodeControl").isJsonNull()) {
        AudioLanguageCodeControl.validateJsonElement(jsonObj.get("LanguageCodeControl"));
      }
      // validate the optional field `RemixSettings`
      if (jsonObj.get("RemixSettings") != null && !jsonObj.get("RemixSettings").isJsonNull()) {
        AudioDescriptionRemixSettings.validateJsonElement(jsonObj.get("RemixSettings"));
      }
      // validate the optional field `StreamName`
      if (jsonObj.get("StreamName") != null && !jsonObj.get("StreamName").isJsonNull()) {
        String.validateJsonElement(jsonObj.get("StreamName"));
      }
  }

  public static class CustomTypeAdapterFactory implements TypeAdapterFactory {
    @SuppressWarnings("unchecked")
    @Override
    public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
       if (!AudioDescription.class.isAssignableFrom(type.getRawType())) {
         return null; // this class only serializes 'AudioDescription' and its subtypes
       }
       final TypeAdapter<JsonElement> elementAdapter = gson.getAdapter(JsonElement.class);
       final TypeAdapter<AudioDescription> thisAdapter
                        = gson.getDelegateAdapter(this, TypeToken.get(AudioDescription.class));

       return (TypeAdapter<T>) new TypeAdapter<AudioDescription>() {
           @Override
           public void write(JsonWriter out, AudioDescription value) throws IOException {
             JsonObject obj = thisAdapter.toJsonTree(value).getAsJsonObject();
             elementAdapter.write(out, obj);
           }

           @Override
           public AudioDescription read(JsonReader in) throws IOException {
             JsonElement jsonElement = elementAdapter.read(in);
             validateJsonElement(jsonElement);
             return thisAdapter.fromJsonTree(jsonElement);
           }

       }.nullSafe();
    }
  }

  /**
   * Create an instance of AudioDescription given an JSON string
   *
   * @param jsonString JSON string
   * @return An instance of AudioDescription
   * @throws IOException if the JSON string is invalid with respect to AudioDescription
   */
  public static AudioDescription fromJson(String jsonString) throws IOException {
    return JSON.getGson().fromJson(jsonString, AudioDescription.class);
  }

  /**
   * Convert an instance of AudioDescription to an JSON string
   *
   * @return JSON string
   */
  public String toJson() {
    return JSON.getGson().toJson(this);
  }
}

