/**
 * Amazon EC2 Container Service
 * <fullname>Amazon Elastic Container Service</fullname> <p>Amazon Elastic Container Service (Amazon ECS) is a highly scalable, fast, container management service. It makes it easy to run, stop, and manage Docker containers. You can host your cluster on a serverless infrastructure that's managed by Amazon ECS by launching your services or tasks on Fargate. For more control, you can host your tasks on a cluster of Amazon Elastic Compute Cloud (Amazon EC2) or External (on-premises) instances that you manage.</p> <p>Amazon ECS makes it easy to launch and stop container-based applications with simple API calls. This makes it easy to get the state of your cluster from a centralized service, and gives you access to many familiar Amazon EC2 features.</p> <p>You can use Amazon ECS to schedule the placement of containers across your cluster based on your resource needs, isolation policies, and availability requirements. With Amazon ECS, you don't need to operate your own cluster management and configuration management systems. You also don't need to worry about scaling your management infrastructure.</p>
 *
 * The version of the OpenAPI document: 2014-11-13
 * Contact: mike.ralphson@gmail.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

#include "OAIDeployment.h"

#include <QDebug>
#include <QJsonArray>
#include <QJsonDocument>
#include <QObject>

#include "OAIHelpers.h"

namespace OpenAPI {

OAIDeployment::OAIDeployment(QString json) {
    this->initializeModel();
    this->fromJson(json);
}

OAIDeployment::OAIDeployment() {
    this->initializeModel();
}

OAIDeployment::~OAIDeployment() {}

void OAIDeployment::initializeModel() {

    m_id_isSet = false;
    m_id_isValid = false;

    m_status_isSet = false;
    m_status_isValid = false;

    m_task_definition_isSet = false;
    m_task_definition_isValid = false;

    m_desired_count_isSet = false;
    m_desired_count_isValid = false;

    m_pending_count_isSet = false;
    m_pending_count_isValid = false;

    m_running_count_isSet = false;
    m_running_count_isValid = false;

    m_failed_tasks_isSet = false;
    m_failed_tasks_isValid = false;

    m_created_at_isSet = false;
    m_created_at_isValid = false;

    m_updated_at_isSet = false;
    m_updated_at_isValid = false;

    m_capacity_provider_strategy_isSet = false;
    m_capacity_provider_strategy_isValid = false;

    m_launch_type_isSet = false;
    m_launch_type_isValid = false;

    m_platform_version_isSet = false;
    m_platform_version_isValid = false;

    m_platform_family_isSet = false;
    m_platform_family_isValid = false;

    m_network_configuration_isSet = false;
    m_network_configuration_isValid = false;

    m_rollout_state_isSet = false;
    m_rollout_state_isValid = false;

    m_rollout_state_reason_isSet = false;
    m_rollout_state_reason_isValid = false;

    m_service_connect_configuration_isSet = false;
    m_service_connect_configuration_isValid = false;

    m_service_connect_resources_isSet = false;
    m_service_connect_resources_isValid = false;
}

void OAIDeployment::fromJson(QString jsonString) {
    QByteArray array(jsonString.toStdString().c_str());
    QJsonDocument doc = QJsonDocument::fromJson(array);
    QJsonObject jsonObject = doc.object();
    this->fromJsonObject(jsonObject);
}

void OAIDeployment::fromJsonObject(QJsonObject json) {

    m_id_isValid = ::OpenAPI::fromJsonValue(m_id, json[QString("id")]);
    m_id_isSet = !json[QString("id")].isNull() && m_id_isValid;

    m_status_isValid = ::OpenAPI::fromJsonValue(m_status, json[QString("status")]);
    m_status_isSet = !json[QString("status")].isNull() && m_status_isValid;

    m_task_definition_isValid = ::OpenAPI::fromJsonValue(m_task_definition, json[QString("taskDefinition")]);
    m_task_definition_isSet = !json[QString("taskDefinition")].isNull() && m_task_definition_isValid;

    m_desired_count_isValid = ::OpenAPI::fromJsonValue(m_desired_count, json[QString("desiredCount")]);
    m_desired_count_isSet = !json[QString("desiredCount")].isNull() && m_desired_count_isValid;

    m_pending_count_isValid = ::OpenAPI::fromJsonValue(m_pending_count, json[QString("pendingCount")]);
    m_pending_count_isSet = !json[QString("pendingCount")].isNull() && m_pending_count_isValid;

    m_running_count_isValid = ::OpenAPI::fromJsonValue(m_running_count, json[QString("runningCount")]);
    m_running_count_isSet = !json[QString("runningCount")].isNull() && m_running_count_isValid;

    m_failed_tasks_isValid = ::OpenAPI::fromJsonValue(m_failed_tasks, json[QString("failedTasks")]);
    m_failed_tasks_isSet = !json[QString("failedTasks")].isNull() && m_failed_tasks_isValid;

    m_created_at_isValid = ::OpenAPI::fromJsonValue(m_created_at, json[QString("createdAt")]);
    m_created_at_isSet = !json[QString("createdAt")].isNull() && m_created_at_isValid;

    m_updated_at_isValid = ::OpenAPI::fromJsonValue(m_updated_at, json[QString("updatedAt")]);
    m_updated_at_isSet = !json[QString("updatedAt")].isNull() && m_updated_at_isValid;

    m_capacity_provider_strategy_isValid = ::OpenAPI::fromJsonValue(m_capacity_provider_strategy, json[QString("capacityProviderStrategy")]);
    m_capacity_provider_strategy_isSet = !json[QString("capacityProviderStrategy")].isNull() && m_capacity_provider_strategy_isValid;

    m_launch_type_isValid = ::OpenAPI::fromJsonValue(m_launch_type, json[QString("launchType")]);
    m_launch_type_isSet = !json[QString("launchType")].isNull() && m_launch_type_isValid;

    m_platform_version_isValid = ::OpenAPI::fromJsonValue(m_platform_version, json[QString("platformVersion")]);
    m_platform_version_isSet = !json[QString("platformVersion")].isNull() && m_platform_version_isValid;

    m_platform_family_isValid = ::OpenAPI::fromJsonValue(m_platform_family, json[QString("platformFamily")]);
    m_platform_family_isSet = !json[QString("platformFamily")].isNull() && m_platform_family_isValid;

    m_network_configuration_isValid = ::OpenAPI::fromJsonValue(m_network_configuration, json[QString("networkConfiguration")]);
    m_network_configuration_isSet = !json[QString("networkConfiguration")].isNull() && m_network_configuration_isValid;

    m_rollout_state_isValid = ::OpenAPI::fromJsonValue(m_rollout_state, json[QString("rolloutState")]);
    m_rollout_state_isSet = !json[QString("rolloutState")].isNull() && m_rollout_state_isValid;

    m_rollout_state_reason_isValid = ::OpenAPI::fromJsonValue(m_rollout_state_reason, json[QString("rolloutStateReason")]);
    m_rollout_state_reason_isSet = !json[QString("rolloutStateReason")].isNull() && m_rollout_state_reason_isValid;

    m_service_connect_configuration_isValid = ::OpenAPI::fromJsonValue(m_service_connect_configuration, json[QString("serviceConnectConfiguration")]);
    m_service_connect_configuration_isSet = !json[QString("serviceConnectConfiguration")].isNull() && m_service_connect_configuration_isValid;

    m_service_connect_resources_isValid = ::OpenAPI::fromJsonValue(m_service_connect_resources, json[QString("serviceConnectResources")]);
    m_service_connect_resources_isSet = !json[QString("serviceConnectResources")].isNull() && m_service_connect_resources_isValid;
}

QString OAIDeployment::asJson() const {
    QJsonObject obj = this->asJsonObject();
    QJsonDocument doc(obj);
    QByteArray bytes = doc.toJson();
    return QString(bytes);
}

QJsonObject OAIDeployment::asJsonObject() const {
    QJsonObject obj;
    if (m_id_isSet) {
        obj.insert(QString("id"), ::OpenAPI::toJsonValue(m_id));
    }
    if (m_status_isSet) {
        obj.insert(QString("status"), ::OpenAPI::toJsonValue(m_status));
    }
    if (m_task_definition_isSet) {
        obj.insert(QString("taskDefinition"), ::OpenAPI::toJsonValue(m_task_definition));
    }
    if (m_desired_count_isSet) {
        obj.insert(QString("desiredCount"), ::OpenAPI::toJsonValue(m_desired_count));
    }
    if (m_pending_count_isSet) {
        obj.insert(QString("pendingCount"), ::OpenAPI::toJsonValue(m_pending_count));
    }
    if (m_running_count_isSet) {
        obj.insert(QString("runningCount"), ::OpenAPI::toJsonValue(m_running_count));
    }
    if (m_failed_tasks_isSet) {
        obj.insert(QString("failedTasks"), ::OpenAPI::toJsonValue(m_failed_tasks));
    }
    if (m_created_at_isSet) {
        obj.insert(QString("createdAt"), ::OpenAPI::toJsonValue(m_created_at));
    }
    if (m_updated_at_isSet) {
        obj.insert(QString("updatedAt"), ::OpenAPI::toJsonValue(m_updated_at));
    }
    if (m_capacity_provider_strategy.isSet()) {
        obj.insert(QString("capacityProviderStrategy"), ::OpenAPI::toJsonValue(m_capacity_provider_strategy));
    }
    if (m_launch_type.isSet()) {
        obj.insert(QString("launchType"), ::OpenAPI::toJsonValue(m_launch_type));
    }
    if (m_platform_version_isSet) {
        obj.insert(QString("platformVersion"), ::OpenAPI::toJsonValue(m_platform_version));
    }
    if (m_platform_family_isSet) {
        obj.insert(QString("platformFamily"), ::OpenAPI::toJsonValue(m_platform_family));
    }
    if (m_network_configuration.isSet()) {
        obj.insert(QString("networkConfiguration"), ::OpenAPI::toJsonValue(m_network_configuration));
    }
    if (m_rollout_state.isSet()) {
        obj.insert(QString("rolloutState"), ::OpenAPI::toJsonValue(m_rollout_state));
    }
    if (m_rollout_state_reason_isSet) {
        obj.insert(QString("rolloutStateReason"), ::OpenAPI::toJsonValue(m_rollout_state_reason));
    }
    if (m_service_connect_configuration.isSet()) {
        obj.insert(QString("serviceConnectConfiguration"), ::OpenAPI::toJsonValue(m_service_connect_configuration));
    }
    if (m_service_connect_resources.isSet()) {
        obj.insert(QString("serviceConnectResources"), ::OpenAPI::toJsonValue(m_service_connect_resources));
    }
    return obj;
}

QString OAIDeployment::getId() const {
    return m_id;
}
void OAIDeployment::setId(const QString &id) {
    m_id = id;
    m_id_isSet = true;
}

bool OAIDeployment::is_id_Set() const{
    return m_id_isSet;
}

bool OAIDeployment::is_id_Valid() const{
    return m_id_isValid;
}

QString OAIDeployment::getStatus() const {
    return m_status;
}
void OAIDeployment::setStatus(const QString &status) {
    m_status = status;
    m_status_isSet = true;
}

bool OAIDeployment::is_status_Set() const{
    return m_status_isSet;
}

bool OAIDeployment::is_status_Valid() const{
    return m_status_isValid;
}

QString OAIDeployment::getTaskDefinition() const {
    return m_task_definition;
}
void OAIDeployment::setTaskDefinition(const QString &task_definition) {
    m_task_definition = task_definition;
    m_task_definition_isSet = true;
}

bool OAIDeployment::is_task_definition_Set() const{
    return m_task_definition_isSet;
}

bool OAIDeployment::is_task_definition_Valid() const{
    return m_task_definition_isValid;
}

qint32 OAIDeployment::getDesiredCount() const {
    return m_desired_count;
}
void OAIDeployment::setDesiredCount(const qint32 &desired_count) {
    m_desired_count = desired_count;
    m_desired_count_isSet = true;
}

bool OAIDeployment::is_desired_count_Set() const{
    return m_desired_count_isSet;
}

bool OAIDeployment::is_desired_count_Valid() const{
    return m_desired_count_isValid;
}

qint32 OAIDeployment::getPendingCount() const {
    return m_pending_count;
}
void OAIDeployment::setPendingCount(const qint32 &pending_count) {
    m_pending_count = pending_count;
    m_pending_count_isSet = true;
}

bool OAIDeployment::is_pending_count_Set() const{
    return m_pending_count_isSet;
}

bool OAIDeployment::is_pending_count_Valid() const{
    return m_pending_count_isValid;
}

qint32 OAIDeployment::getRunningCount() const {
    return m_running_count;
}
void OAIDeployment::setRunningCount(const qint32 &running_count) {
    m_running_count = running_count;
    m_running_count_isSet = true;
}

bool OAIDeployment::is_running_count_Set() const{
    return m_running_count_isSet;
}

bool OAIDeployment::is_running_count_Valid() const{
    return m_running_count_isValid;
}

qint32 OAIDeployment::getFailedTasks() const {
    return m_failed_tasks;
}
void OAIDeployment::setFailedTasks(const qint32 &failed_tasks) {
    m_failed_tasks = failed_tasks;
    m_failed_tasks_isSet = true;
}

bool OAIDeployment::is_failed_tasks_Set() const{
    return m_failed_tasks_isSet;
}

bool OAIDeployment::is_failed_tasks_Valid() const{
    return m_failed_tasks_isValid;
}

QDateTime OAIDeployment::getCreatedAt() const {
    return m_created_at;
}
void OAIDeployment::setCreatedAt(const QDateTime &created_at) {
    m_created_at = created_at;
    m_created_at_isSet = true;
}

bool OAIDeployment::is_created_at_Set() const{
    return m_created_at_isSet;
}

bool OAIDeployment::is_created_at_Valid() const{
    return m_created_at_isValid;
}

QDateTime OAIDeployment::getUpdatedAt() const {
    return m_updated_at;
}
void OAIDeployment::setUpdatedAt(const QDateTime &updated_at) {
    m_updated_at = updated_at;
    m_updated_at_isSet = true;
}

bool OAIDeployment::is_updated_at_Set() const{
    return m_updated_at_isSet;
}

bool OAIDeployment::is_updated_at_Valid() const{
    return m_updated_at_isValid;
}

QList OAIDeployment::getCapacityProviderStrategy() const {
    return m_capacity_provider_strategy;
}
void OAIDeployment::setCapacityProviderStrategy(const QList &capacity_provider_strategy) {
    m_capacity_provider_strategy = capacity_provider_strategy;
    m_capacity_provider_strategy_isSet = true;
}

bool OAIDeployment::is_capacity_provider_strategy_Set() const{
    return m_capacity_provider_strategy_isSet;
}

bool OAIDeployment::is_capacity_provider_strategy_Valid() const{
    return m_capacity_provider_strategy_isValid;
}

OAILaunchType OAIDeployment::getLaunchType() const {
    return m_launch_type;
}
void OAIDeployment::setLaunchType(const OAILaunchType &launch_type) {
    m_launch_type = launch_type;
    m_launch_type_isSet = true;
}

bool OAIDeployment::is_launch_type_Set() const{
    return m_launch_type_isSet;
}

bool OAIDeployment::is_launch_type_Valid() const{
    return m_launch_type_isValid;
}

QString OAIDeployment::getPlatformVersion() const {
    return m_platform_version;
}
void OAIDeployment::setPlatformVersion(const QString &platform_version) {
    m_platform_version = platform_version;
    m_platform_version_isSet = true;
}

bool OAIDeployment::is_platform_version_Set() const{
    return m_platform_version_isSet;
}

bool OAIDeployment::is_platform_version_Valid() const{
    return m_platform_version_isValid;
}

QString OAIDeployment::getPlatformFamily() const {
    return m_platform_family;
}
void OAIDeployment::setPlatformFamily(const QString &platform_family) {
    m_platform_family = platform_family;
    m_platform_family_isSet = true;
}

bool OAIDeployment::is_platform_family_Set() const{
    return m_platform_family_isSet;
}

bool OAIDeployment::is_platform_family_Valid() const{
    return m_platform_family_isValid;
}

OAIStartTaskRequest_networkConfiguration OAIDeployment::getNetworkConfiguration() const {
    return m_network_configuration;
}
void OAIDeployment::setNetworkConfiguration(const OAIStartTaskRequest_networkConfiguration &network_configuration) {
    m_network_configuration = network_configuration;
    m_network_configuration_isSet = true;
}

bool OAIDeployment::is_network_configuration_Set() const{
    return m_network_configuration_isSet;
}

bool OAIDeployment::is_network_configuration_Valid() const{
    return m_network_configuration_isValid;
}

OAIDeploymentRolloutState OAIDeployment::getRolloutState() const {
    return m_rollout_state;
}
void OAIDeployment::setRolloutState(const OAIDeploymentRolloutState &rollout_state) {
    m_rollout_state = rollout_state;
    m_rollout_state_isSet = true;
}

bool OAIDeployment::is_rollout_state_Set() const{
    return m_rollout_state_isSet;
}

bool OAIDeployment::is_rollout_state_Valid() const{
    return m_rollout_state_isValid;
}

QString OAIDeployment::getRolloutStateReason() const {
    return m_rollout_state_reason;
}
void OAIDeployment::setRolloutStateReason(const QString &rollout_state_reason) {
    m_rollout_state_reason = rollout_state_reason;
    m_rollout_state_reason_isSet = true;
}

bool OAIDeployment::is_rollout_state_reason_Set() const{
    return m_rollout_state_reason_isSet;
}

bool OAIDeployment::is_rollout_state_reason_Valid() const{
    return m_rollout_state_reason_isValid;
}

OAIDeployment_serviceConnectConfiguration OAIDeployment::getServiceConnectConfiguration() const {
    return m_service_connect_configuration;
}
void OAIDeployment::setServiceConnectConfiguration(const OAIDeployment_serviceConnectConfiguration &service_connect_configuration) {
    m_service_connect_configuration = service_connect_configuration;
    m_service_connect_configuration_isSet = true;
}

bool OAIDeployment::is_service_connect_configuration_Set() const{
    return m_service_connect_configuration_isSet;
}

bool OAIDeployment::is_service_connect_configuration_Valid() const{
    return m_service_connect_configuration_isValid;
}

QList OAIDeployment::getServiceConnectResources() const {
    return m_service_connect_resources;
}
void OAIDeployment::setServiceConnectResources(const QList &service_connect_resources) {
    m_service_connect_resources = service_connect_resources;
    m_service_connect_resources_isSet = true;
}

bool OAIDeployment::is_service_connect_resources_Set() const{
    return m_service_connect_resources_isSet;
}

bool OAIDeployment::is_service_connect_resources_Valid() const{
    return m_service_connect_resources_isValid;
}

bool OAIDeployment::isSet() const {
    bool isObjectUpdated = false;
    do {
        if (m_id_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_status_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_task_definition_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_desired_count_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_pending_count_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_running_count_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_failed_tasks_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_created_at_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_updated_at_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_capacity_provider_strategy.isSet()) {
            isObjectUpdated = true;
            break;
        }

        if (m_launch_type.isSet()) {
            isObjectUpdated = true;
            break;
        }

        if (m_platform_version_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_platform_family_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_network_configuration.isSet()) {
            isObjectUpdated = true;
            break;
        }

        if (m_rollout_state.isSet()) {
            isObjectUpdated = true;
            break;
        }

        if (m_rollout_state_reason_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_service_connect_configuration.isSet()) {
            isObjectUpdated = true;
            break;
        }

        if (m_service_connect_resources.isSet()) {
            isObjectUpdated = true;
            break;
        }
    } while (false);
    return isObjectUpdated;
}

bool OAIDeployment::isValid() const {
    // only required properties are required for the object to be considered valid
    return true;
}

} // namespace OpenAPI
