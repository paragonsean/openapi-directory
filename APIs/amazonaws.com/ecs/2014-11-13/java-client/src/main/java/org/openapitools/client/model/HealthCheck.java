/*
 * Amazon EC2 Container Service
 * <fullname>Amazon Elastic Container Service</fullname> <p>Amazon Elastic Container Service (Amazon ECS) is a highly scalable, fast, container management service. It makes it easy to run, stop, and manage Docker containers. You can host your cluster on a serverless infrastructure that's managed by Amazon ECS by launching your services or tasks on Fargate. For more control, you can host your tasks on a cluster of Amazon Elastic Compute Cloud (Amazon EC2) or External (on-premises) instances that you manage.</p> <p>Amazon ECS makes it easy to launch and stop container-based applications with simple API calls. This makes it easy to get the state of your cluster from a centralized service, and gives you access to many familiar Amazon EC2 features.</p> <p>You can use Amazon ECS to schedule the placement of containers across your cluster based on your resource needs, isolation policies, and availability requirements. With Amazon ECS, you don't need to operate your own cluster management and configuration management systems. You also don't need to worry about scaling your management infrastructure.</p>
 *
 * The version of the OpenAPI document: 2014-11-13
 * Contact: mike.ralphson@gmail.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package org.openapitools.client.model;

import java.util.Objects;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;
import java.util.Arrays;
import java.util.List;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonArray;
import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;
import com.google.gson.TypeAdapterFactory;
import com.google.gson.reflect.TypeToken;
import com.google.gson.TypeAdapter;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;

import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import org.openapitools.client.JSON;

/**
 * &lt;p&gt;An object representing a container health check. Health check parameters that are specified in a container definition override any Docker health checks that exist in the container image (such as those specified in a parent image or from the image&#39;s Dockerfile). This configuration maps to the &lt;code&gt;HEALTHCHECK&lt;/code&gt; parameter of &lt;a href&#x3D;\&quot;https://docs.docker.com/engine/reference/run/\&quot;&gt;docker run&lt;/a&gt;.&lt;/p&gt; &lt;note&gt; &lt;p&gt;The Amazon ECS container agent only monitors and reports on the health checks specified in the task definition. Amazon ECS does not monitor Docker health checks that are embedded in a container image and not specified in the container definition. Health check parameters that are specified in a container definition override any Docker health checks that exist in the container image.&lt;/p&gt; &lt;/note&gt; &lt;p&gt;You can view the health status of both individual containers and a task with the DescribeTasks API operation or when viewing the task details in the console.&lt;/p&gt; &lt;p&gt;The health check is designed to make sure that your containers survive agent restarts, upgrades, or temporary unavailability.&lt;/p&gt; &lt;p&gt;The following describes the possible &lt;code&gt;healthStatus&lt;/code&gt; values for a container:&lt;/p&gt; &lt;ul&gt; &lt;li&gt; &lt;p&gt; &lt;code&gt;HEALTHY&lt;/code&gt;-The container health check has passed successfully.&lt;/p&gt; &lt;/li&gt; &lt;li&gt; &lt;p&gt; &lt;code&gt;UNHEALTHY&lt;/code&gt;-The container health check has failed.&lt;/p&gt; &lt;/li&gt; &lt;li&gt; &lt;p&gt; &lt;code&gt;UNKNOWN&lt;/code&gt;-The container health check is being evaluated or there&#39;s no container health check defined.&lt;/p&gt; &lt;/li&gt; &lt;/ul&gt; &lt;p&gt;The following describes the possible &lt;code&gt;healthStatus&lt;/code&gt; values for a task. The container health check status of non-essential containers don&#39;t have an effect on the health status of a task.&lt;/p&gt; &lt;ul&gt; &lt;li&gt; &lt;p&gt; &lt;code&gt;HEALTHY&lt;/code&gt;-All essential containers within the task have passed their health checks.&lt;/p&gt; &lt;/li&gt; &lt;li&gt; &lt;p&gt; &lt;code&gt;UNHEALTHY&lt;/code&gt;-One or more essential containers have failed their health check.&lt;/p&gt; &lt;/li&gt; &lt;li&gt; &lt;p&gt; &lt;code&gt;UNKNOWN&lt;/code&gt;-The essential containers within the task are still having their health checks evaluated, there are only nonessential containers with health checks defined, or there are no container health checks defined.&lt;/p&gt; &lt;/li&gt; &lt;/ul&gt; &lt;p&gt;If a task is run manually, and not as part of a service, the task will continue its lifecycle regardless of its health status. For tasks that are part of a service, if the task reports as unhealthy then the task will be stopped and the service scheduler will replace it.&lt;/p&gt; &lt;p&gt;The following are notes about container health check support:&lt;/p&gt; &lt;ul&gt; &lt;li&gt; &lt;p&gt;When the Amazon ECS agent cannot connect to the Amazon ECS service, the service reports the container as &lt;code&gt;UNHEALTHY&lt;/code&gt;. &lt;/p&gt; &lt;/li&gt; &lt;li&gt; &lt;p&gt;The health check statuses are the \&quot;last heard from\&quot; response from the Amazon ECS agent. There are no assumptions made about the status of the container health checks.&lt;/p&gt; &lt;/li&gt; &lt;li&gt; &lt;p&gt;Container health checks require version 1.17.0 or greater of the Amazon ECS container agent. For more information, see &lt;a href&#x3D;\&quot;https://docs.aws.amazon.com/AmazonECS/latest/developerguide/ecs-agent-update.html\&quot;&gt;Updating the Amazon ECS container agent&lt;/a&gt;.&lt;/p&gt; &lt;/li&gt; &lt;li&gt; &lt;p&gt;Container health checks are supported for Fargate tasks if you&#39;re using platform version &lt;code&gt;1.1.0&lt;/code&gt; or greater. For more information, see &lt;a href&#x3D;\&quot;https://docs.aws.amazon.com/AmazonECS/latest/developerguide/platform_versions.html\&quot;&gt;Fargate platform versions&lt;/a&gt;.&lt;/p&gt; &lt;/li&gt; &lt;li&gt; &lt;p&gt;Container health checks aren&#39;t supported for tasks that are part of a service that&#39;s configured to use a Classic Load Balancer.&lt;/p&gt; &lt;/li&gt; &lt;/ul&gt;
 */
@javax.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen", date = "2024-10-12T12:28:17.720344-04:00[America/New_York]", comments = "Generator version: 7.9.0")
public class HealthCheck {
  public static final String SERIALIZED_NAME_COMMAND = "command";
  @SerializedName(SERIALIZED_NAME_COMMAND)
  private List command;

  public static final String SERIALIZED_NAME_INTERVAL = "interval";
  @SerializedName(SERIALIZED_NAME_INTERVAL)
  private Integer interval;

  public static final String SERIALIZED_NAME_TIMEOUT = "timeout";
  @SerializedName(SERIALIZED_NAME_TIMEOUT)
  private Integer timeout;

  public static final String SERIALIZED_NAME_RETRIES = "retries";
  @SerializedName(SERIALIZED_NAME_RETRIES)
  private Integer retries;

  public static final String SERIALIZED_NAME_START_PERIOD = "startPeriod";
  @SerializedName(SERIALIZED_NAME_START_PERIOD)
  private Integer startPeriod;

  public HealthCheck() {
  }

  public HealthCheck command(List command) {
    this.command = command;
    return this;
  }

  /**
   * Get command
   * @return command
   */
  @javax.annotation.Nonnull
  public List getCommand() {
    return command;
  }

  public void setCommand(List command) {
    this.command = command;
  }


  public HealthCheck interval(Integer interval) {
    this.interval = interval;
    return this;
  }

  /**
   * Get interval
   * @return interval
   */
  @javax.annotation.Nullable
  public Integer getInterval() {
    return interval;
  }

  public void setInterval(Integer interval) {
    this.interval = interval;
  }


  public HealthCheck timeout(Integer timeout) {
    this.timeout = timeout;
    return this;
  }

  /**
   * Get timeout
   * @return timeout
   */
  @javax.annotation.Nullable
  public Integer getTimeout() {
    return timeout;
  }

  public void setTimeout(Integer timeout) {
    this.timeout = timeout;
  }


  public HealthCheck retries(Integer retries) {
    this.retries = retries;
    return this;
  }

  /**
   * Get retries
   * @return retries
   */
  @javax.annotation.Nullable
  public Integer getRetries() {
    return retries;
  }

  public void setRetries(Integer retries) {
    this.retries = retries;
  }


  public HealthCheck startPeriod(Integer startPeriod) {
    this.startPeriod = startPeriod;
    return this;
  }

  /**
   * Get startPeriod
   * @return startPeriod
   */
  @javax.annotation.Nullable
  public Integer getStartPeriod() {
    return startPeriod;
  }

  public void setStartPeriod(Integer startPeriod) {
    this.startPeriod = startPeriod;
  }



  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    HealthCheck healthCheck = (HealthCheck) o;
    return Objects.equals(this.command, healthCheck.command) &&
        Objects.equals(this.interval, healthCheck.interval) &&
        Objects.equals(this.timeout, healthCheck.timeout) &&
        Objects.equals(this.retries, healthCheck.retries) &&
        Objects.equals(this.startPeriod, healthCheck.startPeriod);
  }

  @Override
  public int hashCode() {
    return Objects.hash(command, interval, timeout, retries, startPeriod);
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class HealthCheck {\n");
    sb.append("    command: ").append(toIndentedString(command)).append("\n");
    sb.append("    interval: ").append(toIndentedString(interval)).append("\n");
    sb.append("    timeout: ").append(toIndentedString(timeout)).append("\n");
    sb.append("    retries: ").append(toIndentedString(retries)).append("\n");
    sb.append("    startPeriod: ").append(toIndentedString(startPeriod)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }


  public static HashSet<String> openapiFields;
  public static HashSet<String> openapiRequiredFields;

  static {
    // a set of all properties/fields (JSON key names)
    openapiFields = new HashSet<String>();
    openapiFields.add("command");
    openapiFields.add("interval");
    openapiFields.add("timeout");
    openapiFields.add("retries");
    openapiFields.add("startPeriod");

    // a set of required properties/fields (JSON key names)
    openapiRequiredFields = new HashSet<String>();
    openapiRequiredFields.add("command");
  }

  /**
   * Validates the JSON Element and throws an exception if issues found
   *
   * @param jsonElement JSON Element
   * @throws IOException if the JSON Element is invalid with respect to HealthCheck
   */
  public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      if (jsonElement == null) {
        if (!HealthCheck.openapiRequiredFields.isEmpty()) { // has required fields but JSON element is null
          throw new IllegalArgumentException(String.format("The required field(s) %s in HealthCheck is not found in the empty JSON string", HealthCheck.openapiRequiredFields.toString()));
        }
      }

      Set<Map.Entry<String, JsonElement>> entries = jsonElement.getAsJsonObject().entrySet();
      // check to see if the JSON string contains additional fields
      for (Map.Entry<String, JsonElement> entry : entries) {
        if (!HealthCheck.openapiFields.contains(entry.getKey())) {
          throw new IllegalArgumentException(String.format("The field `%s` in the JSON string is not defined in the `HealthCheck` properties. JSON: %s", entry.getKey(), jsonElement.toString()));
        }
      }

      // check to make sure all required properties/fields are present in the JSON string
      for (String requiredField : HealthCheck.openapiRequiredFields) {
        if (jsonElement.getAsJsonObject().get(requiredField) == null) {
          throw new IllegalArgumentException(String.format("The required field `%s` is not found in the JSON string: %s", requiredField, jsonElement.toString()));
        }
      }
        JsonObject jsonObj = jsonElement.getAsJsonObject();
      // validate the required field `command`
      List.validateJsonElement(jsonObj.get("command"));
      // validate the optional field `interval`
      if (jsonObj.get("interval") != null && !jsonObj.get("interval").isJsonNull()) {
        Integer.validateJsonElement(jsonObj.get("interval"));
      }
      // validate the optional field `timeout`
      if (jsonObj.get("timeout") != null && !jsonObj.get("timeout").isJsonNull()) {
        Integer.validateJsonElement(jsonObj.get("timeout"));
      }
      // validate the optional field `retries`
      if (jsonObj.get("retries") != null && !jsonObj.get("retries").isJsonNull()) {
        Integer.validateJsonElement(jsonObj.get("retries"));
      }
      // validate the optional field `startPeriod`
      if (jsonObj.get("startPeriod") != null && !jsonObj.get("startPeriod").isJsonNull()) {
        Integer.validateJsonElement(jsonObj.get("startPeriod"));
      }
  }

  public static class CustomTypeAdapterFactory implements TypeAdapterFactory {
    @SuppressWarnings("unchecked")
    @Override
    public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
       if (!HealthCheck.class.isAssignableFrom(type.getRawType())) {
         return null; // this class only serializes 'HealthCheck' and its subtypes
       }
       final TypeAdapter<JsonElement> elementAdapter = gson.getAdapter(JsonElement.class);
       final TypeAdapter<HealthCheck> thisAdapter
                        = gson.getDelegateAdapter(this, TypeToken.get(HealthCheck.class));

       return (TypeAdapter<T>) new TypeAdapter<HealthCheck>() {
           @Override
           public void write(JsonWriter out, HealthCheck value) throws IOException {
             JsonObject obj = thisAdapter.toJsonTree(value).getAsJsonObject();
             elementAdapter.write(out, obj);
           }

           @Override
           public HealthCheck read(JsonReader in) throws IOException {
             JsonElement jsonElement = elementAdapter.read(in);
             validateJsonElement(jsonElement);
             return thisAdapter.fromJsonTree(jsonElement);
           }

       }.nullSafe();
    }
  }

  /**
   * Create an instance of HealthCheck given an JSON string
   *
   * @param jsonString JSON string
   * @return An instance of HealthCheck
   * @throws IOException if the JSON string is invalid with respect to HealthCheck
   */
  public static HealthCheck fromJson(String jsonString) throws IOException {
    return JSON.getGson().fromJson(jsonString, HealthCheck.class);
  }

  /**
   * Convert an instance of HealthCheck to an JSON string
   *
   * @return JSON string
   */
  public String toJson() {
    return JSON.getGson().toJson(this);
  }
}

