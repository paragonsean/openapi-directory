/*
 * Amazon EC2 Container Service
 * <fullname>Amazon Elastic Container Service</fullname> <p>Amazon Elastic Container Service (Amazon ECS) is a highly scalable, fast, container management service. It makes it easy to run, stop, and manage Docker containers. You can host your cluster on a serverless infrastructure that's managed by Amazon ECS by launching your services or tasks on Fargate. For more control, you can host your tasks on a cluster of Amazon Elastic Compute Cloud (Amazon EC2) or External (on-premises) instances that you manage.</p> <p>Amazon ECS makes it easy to launch and stop container-based applications with simple API calls. This makes it easy to get the state of your cluster from a centralized service, and gives you access to many familiar Amazon EC2 features.</p> <p>You can use Amazon ECS to schedule the placement of containers across your cluster based on your resource needs, isolation policies, and availability requirements. With Amazon ECS, you don't need to operate your own cluster management and configuration management systems. You also don't need to worry about scaling your management infrastructure.</p>
 *
 * The version of the OpenAPI document: 2014-11-13
 * Contact: mike.ralphson@gmail.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package org.openapitools.client.model;

import java.util.Objects;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;
import java.time.OffsetDateTime;
import java.util.Arrays;
import java.util.List;
import org.openapitools.client.model.Connectivity;
import org.openapitools.client.model.HealthStatus;
import org.openapitools.client.model.LaunchType;
import org.openapitools.client.model.TaskEphemeralStorage;
import org.openapitools.client.model.TaskOverrides;
import org.openapitools.client.model.TaskStopCode;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonArray;
import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;
import com.google.gson.TypeAdapterFactory;
import com.google.gson.reflect.TypeToken;
import com.google.gson.TypeAdapter;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;

import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import org.openapitools.client.JSON;

/**
 * Details on a task in a cluster.
 */
@javax.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen", date = "2024-10-12T12:28:17.720344-04:00[America/New_York]", comments = "Generator version: 7.9.0")
public class Task {
  public static final String SERIALIZED_NAME_ATTACHMENTS = "attachments";
  @SerializedName(SERIALIZED_NAME_ATTACHMENTS)
  private List attachments;

  public static final String SERIALIZED_NAME_ATTRIBUTES = "attributes";
  @SerializedName(SERIALIZED_NAME_ATTRIBUTES)
  private List attributes;

  public static final String SERIALIZED_NAME_AVAILABILITY_ZONE = "availabilityZone";
  @SerializedName(SERIALIZED_NAME_AVAILABILITY_ZONE)
  private String availabilityZone;

  public static final String SERIALIZED_NAME_CAPACITY_PROVIDER_NAME = "capacityProviderName";
  @SerializedName(SERIALIZED_NAME_CAPACITY_PROVIDER_NAME)
  private String capacityProviderName;

  public static final String SERIALIZED_NAME_CLUSTER_ARN = "clusterArn";
  @SerializedName(SERIALIZED_NAME_CLUSTER_ARN)
  private String clusterArn;

  public static final String SERIALIZED_NAME_CONNECTIVITY = "connectivity";
  @SerializedName(SERIALIZED_NAME_CONNECTIVITY)
  private Connectivity connectivity;

  public static final String SERIALIZED_NAME_CONNECTIVITY_AT = "connectivityAt";
  @SerializedName(SERIALIZED_NAME_CONNECTIVITY_AT)
  private OffsetDateTime connectivityAt;

  public static final String SERIALIZED_NAME_CONTAINER_INSTANCE_ARN = "containerInstanceArn";
  @SerializedName(SERIALIZED_NAME_CONTAINER_INSTANCE_ARN)
  private String containerInstanceArn;

  public static final String SERIALIZED_NAME_CONTAINERS = "containers";
  @SerializedName(SERIALIZED_NAME_CONTAINERS)
  private List containers;

  public static final String SERIALIZED_NAME_CPU = "cpu";
  @SerializedName(SERIALIZED_NAME_CPU)
  private String cpu;

  public static final String SERIALIZED_NAME_CREATED_AT = "createdAt";
  @SerializedName(SERIALIZED_NAME_CREATED_AT)
  private OffsetDateTime createdAt;

  public static final String SERIALIZED_NAME_DESIRED_STATUS = "desiredStatus";
  @SerializedName(SERIALIZED_NAME_DESIRED_STATUS)
  private String desiredStatus;

  public static final String SERIALIZED_NAME_ENABLE_EXECUTE_COMMAND = "enableExecuteCommand";
  @SerializedName(SERIALIZED_NAME_ENABLE_EXECUTE_COMMAND)
  private Boolean enableExecuteCommand;

  public static final String SERIALIZED_NAME_EXECUTION_STOPPED_AT = "executionStoppedAt";
  @SerializedName(SERIALIZED_NAME_EXECUTION_STOPPED_AT)
  private OffsetDateTime executionStoppedAt;

  public static final String SERIALIZED_NAME_GROUP = "group";
  @SerializedName(SERIALIZED_NAME_GROUP)
  private String group;

  public static final String SERIALIZED_NAME_HEALTH_STATUS = "healthStatus";
  @SerializedName(SERIALIZED_NAME_HEALTH_STATUS)
  private HealthStatus healthStatus;

  public static final String SERIALIZED_NAME_INFERENCE_ACCELERATORS = "inferenceAccelerators";
  @SerializedName(SERIALIZED_NAME_INFERENCE_ACCELERATORS)
  private List inferenceAccelerators;

  public static final String SERIALIZED_NAME_LAST_STATUS = "lastStatus";
  @SerializedName(SERIALIZED_NAME_LAST_STATUS)
  private String lastStatus;

  public static final String SERIALIZED_NAME_LAUNCH_TYPE = "launchType";
  @SerializedName(SERIALIZED_NAME_LAUNCH_TYPE)
  private LaunchType launchType;

  public static final String SERIALIZED_NAME_MEMORY = "memory";
  @SerializedName(SERIALIZED_NAME_MEMORY)
  private String memory;

  public static final String SERIALIZED_NAME_OVERRIDES = "overrides";
  @SerializedName(SERIALIZED_NAME_OVERRIDES)
  private TaskOverrides overrides;

  public static final String SERIALIZED_NAME_PLATFORM_VERSION = "platformVersion";
  @SerializedName(SERIALIZED_NAME_PLATFORM_VERSION)
  private String platformVersion;

  public static final String SERIALIZED_NAME_PLATFORM_FAMILY = "platformFamily";
  @SerializedName(SERIALIZED_NAME_PLATFORM_FAMILY)
  private String platformFamily;

  public static final String SERIALIZED_NAME_PULL_STARTED_AT = "pullStartedAt";
  @SerializedName(SERIALIZED_NAME_PULL_STARTED_AT)
  private OffsetDateTime pullStartedAt;

  public static final String SERIALIZED_NAME_PULL_STOPPED_AT = "pullStoppedAt";
  @SerializedName(SERIALIZED_NAME_PULL_STOPPED_AT)
  private OffsetDateTime pullStoppedAt;

  public static final String SERIALIZED_NAME_STARTED_AT = "startedAt";
  @SerializedName(SERIALIZED_NAME_STARTED_AT)
  private OffsetDateTime startedAt;

  public static final String SERIALIZED_NAME_STARTED_BY = "startedBy";
  @SerializedName(SERIALIZED_NAME_STARTED_BY)
  private String startedBy;

  public static final String SERIALIZED_NAME_STOP_CODE = "stopCode";
  @SerializedName(SERIALIZED_NAME_STOP_CODE)
  private TaskStopCode stopCode;

  public static final String SERIALIZED_NAME_STOPPED_AT = "stoppedAt";
  @SerializedName(SERIALIZED_NAME_STOPPED_AT)
  private OffsetDateTime stoppedAt;

  public static final String SERIALIZED_NAME_STOPPED_REASON = "stoppedReason";
  @SerializedName(SERIALIZED_NAME_STOPPED_REASON)
  private String stoppedReason;

  public static final String SERIALIZED_NAME_STOPPING_AT = "stoppingAt";
  @SerializedName(SERIALIZED_NAME_STOPPING_AT)
  private OffsetDateTime stoppingAt;

  public static final String SERIALIZED_NAME_TAGS = "tags";
  @SerializedName(SERIALIZED_NAME_TAGS)
  private List tags;

  public static final String SERIALIZED_NAME_TASK_ARN = "taskArn";
  @SerializedName(SERIALIZED_NAME_TASK_ARN)
  private String taskArn;

  public static final String SERIALIZED_NAME_TASK_DEFINITION_ARN = "taskDefinitionArn";
  @SerializedName(SERIALIZED_NAME_TASK_DEFINITION_ARN)
  private String taskDefinitionArn;

  public static final String SERIALIZED_NAME_VERSION = "version";
  @SerializedName(SERIALIZED_NAME_VERSION)
  private Integer version;

  public static final String SERIALIZED_NAME_EPHEMERAL_STORAGE = "ephemeralStorage";
  @SerializedName(SERIALIZED_NAME_EPHEMERAL_STORAGE)
  private TaskEphemeralStorage ephemeralStorage;

  public Task() {
  }

  public Task attachments(List attachments) {
    this.attachments = attachments;
    return this;
  }

  /**
   * Get attachments
   * @return attachments
   */
  @javax.annotation.Nullable
  public List getAttachments() {
    return attachments;
  }

  public void setAttachments(List attachments) {
    this.attachments = attachments;
  }


  public Task attributes(List attributes) {
    this.attributes = attributes;
    return this;
  }

  /**
   * Get attributes
   * @return attributes
   */
  @javax.annotation.Nullable
  public List getAttributes() {
    return attributes;
  }

  public void setAttributes(List attributes) {
    this.attributes = attributes;
  }


  public Task availabilityZone(String availabilityZone) {
    this.availabilityZone = availabilityZone;
    return this;
  }

  /**
   * Get availabilityZone
   * @return availabilityZone
   */
  @javax.annotation.Nullable
  public String getAvailabilityZone() {
    return availabilityZone;
  }

  public void setAvailabilityZone(String availabilityZone) {
    this.availabilityZone = availabilityZone;
  }


  public Task capacityProviderName(String capacityProviderName) {
    this.capacityProviderName = capacityProviderName;
    return this;
  }

  /**
   * Get capacityProviderName
   * @return capacityProviderName
   */
  @javax.annotation.Nullable
  public String getCapacityProviderName() {
    return capacityProviderName;
  }

  public void setCapacityProviderName(String capacityProviderName) {
    this.capacityProviderName = capacityProviderName;
  }


  public Task clusterArn(String clusterArn) {
    this.clusterArn = clusterArn;
    return this;
  }

  /**
   * Get clusterArn
   * @return clusterArn
   */
  @javax.annotation.Nullable
  public String getClusterArn() {
    return clusterArn;
  }

  public void setClusterArn(String clusterArn) {
    this.clusterArn = clusterArn;
  }


  public Task connectivity(Connectivity connectivity) {
    this.connectivity = connectivity;
    return this;
  }

  /**
   * Get connectivity
   * @return connectivity
   */
  @javax.annotation.Nullable
  public Connectivity getConnectivity() {
    return connectivity;
  }

  public void setConnectivity(Connectivity connectivity) {
    this.connectivity = connectivity;
  }


  public Task connectivityAt(OffsetDateTime connectivityAt) {
    this.connectivityAt = connectivityAt;
    return this;
  }

  /**
   * Get connectivityAt
   * @return connectivityAt
   */
  @javax.annotation.Nullable
  public OffsetDateTime getConnectivityAt() {
    return connectivityAt;
  }

  public void setConnectivityAt(OffsetDateTime connectivityAt) {
    this.connectivityAt = connectivityAt;
  }


  public Task containerInstanceArn(String containerInstanceArn) {
    this.containerInstanceArn = containerInstanceArn;
    return this;
  }

  /**
   * Get containerInstanceArn
   * @return containerInstanceArn
   */
  @javax.annotation.Nullable
  public String getContainerInstanceArn() {
    return containerInstanceArn;
  }

  public void setContainerInstanceArn(String containerInstanceArn) {
    this.containerInstanceArn = containerInstanceArn;
  }


  public Task containers(List containers) {
    this.containers = containers;
    return this;
  }

  /**
   * Get containers
   * @return containers
   */
  @javax.annotation.Nullable
  public List getContainers() {
    return containers;
  }

  public void setContainers(List containers) {
    this.containers = containers;
  }


  public Task cpu(String cpu) {
    this.cpu = cpu;
    return this;
  }

  /**
   * Get cpu
   * @return cpu
   */
  @javax.annotation.Nullable
  public String getCpu() {
    return cpu;
  }

  public void setCpu(String cpu) {
    this.cpu = cpu;
  }


  public Task createdAt(OffsetDateTime createdAt) {
    this.createdAt = createdAt;
    return this;
  }

  /**
   * Get createdAt
   * @return createdAt
   */
  @javax.annotation.Nullable
  public OffsetDateTime getCreatedAt() {
    return createdAt;
  }

  public void setCreatedAt(OffsetDateTime createdAt) {
    this.createdAt = createdAt;
  }


  public Task desiredStatus(String desiredStatus) {
    this.desiredStatus = desiredStatus;
    return this;
  }

  /**
   * Get desiredStatus
   * @return desiredStatus
   */
  @javax.annotation.Nullable
  public String getDesiredStatus() {
    return desiredStatus;
  }

  public void setDesiredStatus(String desiredStatus) {
    this.desiredStatus = desiredStatus;
  }


  public Task enableExecuteCommand(Boolean enableExecuteCommand) {
    this.enableExecuteCommand = enableExecuteCommand;
    return this;
  }

  /**
   * Get enableExecuteCommand
   * @return enableExecuteCommand
   */
  @javax.annotation.Nullable
  public Boolean getEnableExecuteCommand() {
    return enableExecuteCommand;
  }

  public void setEnableExecuteCommand(Boolean enableExecuteCommand) {
    this.enableExecuteCommand = enableExecuteCommand;
  }


  public Task executionStoppedAt(OffsetDateTime executionStoppedAt) {
    this.executionStoppedAt = executionStoppedAt;
    return this;
  }

  /**
   * Get executionStoppedAt
   * @return executionStoppedAt
   */
  @javax.annotation.Nullable
  public OffsetDateTime getExecutionStoppedAt() {
    return executionStoppedAt;
  }

  public void setExecutionStoppedAt(OffsetDateTime executionStoppedAt) {
    this.executionStoppedAt = executionStoppedAt;
  }


  public Task group(String group) {
    this.group = group;
    return this;
  }

  /**
   * Get group
   * @return group
   */
  @javax.annotation.Nullable
  public String getGroup() {
    return group;
  }

  public void setGroup(String group) {
    this.group = group;
  }


  public Task healthStatus(HealthStatus healthStatus) {
    this.healthStatus = healthStatus;
    return this;
  }

  /**
   * Get healthStatus
   * @return healthStatus
   */
  @javax.annotation.Nullable
  public HealthStatus getHealthStatus() {
    return healthStatus;
  }

  public void setHealthStatus(HealthStatus healthStatus) {
    this.healthStatus = healthStatus;
  }


  public Task inferenceAccelerators(List inferenceAccelerators) {
    this.inferenceAccelerators = inferenceAccelerators;
    return this;
  }

  /**
   * Get inferenceAccelerators
   * @return inferenceAccelerators
   */
  @javax.annotation.Nullable
  public List getInferenceAccelerators() {
    return inferenceAccelerators;
  }

  public void setInferenceAccelerators(List inferenceAccelerators) {
    this.inferenceAccelerators = inferenceAccelerators;
  }


  public Task lastStatus(String lastStatus) {
    this.lastStatus = lastStatus;
    return this;
  }

  /**
   * Get lastStatus
   * @return lastStatus
   */
  @javax.annotation.Nullable
  public String getLastStatus() {
    return lastStatus;
  }

  public void setLastStatus(String lastStatus) {
    this.lastStatus = lastStatus;
  }


  public Task launchType(LaunchType launchType) {
    this.launchType = launchType;
    return this;
  }

  /**
   * Get launchType
   * @return launchType
   */
  @javax.annotation.Nullable
  public LaunchType getLaunchType() {
    return launchType;
  }

  public void setLaunchType(LaunchType launchType) {
    this.launchType = launchType;
  }


  public Task memory(String memory) {
    this.memory = memory;
    return this;
  }

  /**
   * Get memory
   * @return memory
   */
  @javax.annotation.Nullable
  public String getMemory() {
    return memory;
  }

  public void setMemory(String memory) {
    this.memory = memory;
  }


  public Task overrides(TaskOverrides overrides) {
    this.overrides = overrides;
    return this;
  }

  /**
   * Get overrides
   * @return overrides
   */
  @javax.annotation.Nullable
  public TaskOverrides getOverrides() {
    return overrides;
  }

  public void setOverrides(TaskOverrides overrides) {
    this.overrides = overrides;
  }


  public Task platformVersion(String platformVersion) {
    this.platformVersion = platformVersion;
    return this;
  }

  /**
   * Get platformVersion
   * @return platformVersion
   */
  @javax.annotation.Nullable
  public String getPlatformVersion() {
    return platformVersion;
  }

  public void setPlatformVersion(String platformVersion) {
    this.platformVersion = platformVersion;
  }


  public Task platformFamily(String platformFamily) {
    this.platformFamily = platformFamily;
    return this;
  }

  /**
   * Get platformFamily
   * @return platformFamily
   */
  @javax.annotation.Nullable
  public String getPlatformFamily() {
    return platformFamily;
  }

  public void setPlatformFamily(String platformFamily) {
    this.platformFamily = platformFamily;
  }


  public Task pullStartedAt(OffsetDateTime pullStartedAt) {
    this.pullStartedAt = pullStartedAt;
    return this;
  }

  /**
   * Get pullStartedAt
   * @return pullStartedAt
   */
  @javax.annotation.Nullable
  public OffsetDateTime getPullStartedAt() {
    return pullStartedAt;
  }

  public void setPullStartedAt(OffsetDateTime pullStartedAt) {
    this.pullStartedAt = pullStartedAt;
  }


  public Task pullStoppedAt(OffsetDateTime pullStoppedAt) {
    this.pullStoppedAt = pullStoppedAt;
    return this;
  }

  /**
   * Get pullStoppedAt
   * @return pullStoppedAt
   */
  @javax.annotation.Nullable
  public OffsetDateTime getPullStoppedAt() {
    return pullStoppedAt;
  }

  public void setPullStoppedAt(OffsetDateTime pullStoppedAt) {
    this.pullStoppedAt = pullStoppedAt;
  }


  public Task startedAt(OffsetDateTime startedAt) {
    this.startedAt = startedAt;
    return this;
  }

  /**
   * Get startedAt
   * @return startedAt
   */
  @javax.annotation.Nullable
  public OffsetDateTime getStartedAt() {
    return startedAt;
  }

  public void setStartedAt(OffsetDateTime startedAt) {
    this.startedAt = startedAt;
  }


  public Task startedBy(String startedBy) {
    this.startedBy = startedBy;
    return this;
  }

  /**
   * Get startedBy
   * @return startedBy
   */
  @javax.annotation.Nullable
  public String getStartedBy() {
    return startedBy;
  }

  public void setStartedBy(String startedBy) {
    this.startedBy = startedBy;
  }


  public Task stopCode(TaskStopCode stopCode) {
    this.stopCode = stopCode;
    return this;
  }

  /**
   * Get stopCode
   * @return stopCode
   */
  @javax.annotation.Nullable
  public TaskStopCode getStopCode() {
    return stopCode;
  }

  public void setStopCode(TaskStopCode stopCode) {
    this.stopCode = stopCode;
  }


  public Task stoppedAt(OffsetDateTime stoppedAt) {
    this.stoppedAt = stoppedAt;
    return this;
  }

  /**
   * Get stoppedAt
   * @return stoppedAt
   */
  @javax.annotation.Nullable
  public OffsetDateTime getStoppedAt() {
    return stoppedAt;
  }

  public void setStoppedAt(OffsetDateTime stoppedAt) {
    this.stoppedAt = stoppedAt;
  }


  public Task stoppedReason(String stoppedReason) {
    this.stoppedReason = stoppedReason;
    return this;
  }

  /**
   * Get stoppedReason
   * @return stoppedReason
   */
  @javax.annotation.Nullable
  public String getStoppedReason() {
    return stoppedReason;
  }

  public void setStoppedReason(String stoppedReason) {
    this.stoppedReason = stoppedReason;
  }


  public Task stoppingAt(OffsetDateTime stoppingAt) {
    this.stoppingAt = stoppingAt;
    return this;
  }

  /**
   * Get stoppingAt
   * @return stoppingAt
   */
  @javax.annotation.Nullable
  public OffsetDateTime getStoppingAt() {
    return stoppingAt;
  }

  public void setStoppingAt(OffsetDateTime stoppingAt) {
    this.stoppingAt = stoppingAt;
  }


  public Task tags(List tags) {
    this.tags = tags;
    return this;
  }

  /**
   * Get tags
   * @return tags
   */
  @javax.annotation.Nullable
  public List getTags() {
    return tags;
  }

  public void setTags(List tags) {
    this.tags = tags;
  }


  public Task taskArn(String taskArn) {
    this.taskArn = taskArn;
    return this;
  }

  /**
   * Get taskArn
   * @return taskArn
   */
  @javax.annotation.Nullable
  public String getTaskArn() {
    return taskArn;
  }

  public void setTaskArn(String taskArn) {
    this.taskArn = taskArn;
  }


  public Task taskDefinitionArn(String taskDefinitionArn) {
    this.taskDefinitionArn = taskDefinitionArn;
    return this;
  }

  /**
   * Get taskDefinitionArn
   * @return taskDefinitionArn
   */
  @javax.annotation.Nullable
  public String getTaskDefinitionArn() {
    return taskDefinitionArn;
  }

  public void setTaskDefinitionArn(String taskDefinitionArn) {
    this.taskDefinitionArn = taskDefinitionArn;
  }


  public Task version(Integer version) {
    this.version = version;
    return this;
  }

  /**
   * Get version
   * @return version
   */
  @javax.annotation.Nullable
  public Integer getVersion() {
    return version;
  }

  public void setVersion(Integer version) {
    this.version = version;
  }


  public Task ephemeralStorage(TaskEphemeralStorage ephemeralStorage) {
    this.ephemeralStorage = ephemeralStorage;
    return this;
  }

  /**
   * Get ephemeralStorage
   * @return ephemeralStorage
   */
  @javax.annotation.Nullable
  public TaskEphemeralStorage getEphemeralStorage() {
    return ephemeralStorage;
  }

  public void setEphemeralStorage(TaskEphemeralStorage ephemeralStorage) {
    this.ephemeralStorage = ephemeralStorage;
  }



  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    Task task = (Task) o;
    return Objects.equals(this.attachments, task.attachments) &&
        Objects.equals(this.attributes, task.attributes) &&
        Objects.equals(this.availabilityZone, task.availabilityZone) &&
        Objects.equals(this.capacityProviderName, task.capacityProviderName) &&
        Objects.equals(this.clusterArn, task.clusterArn) &&
        Objects.equals(this.connectivity, task.connectivity) &&
        Objects.equals(this.connectivityAt, task.connectivityAt) &&
        Objects.equals(this.containerInstanceArn, task.containerInstanceArn) &&
        Objects.equals(this.containers, task.containers) &&
        Objects.equals(this.cpu, task.cpu) &&
        Objects.equals(this.createdAt, task.createdAt) &&
        Objects.equals(this.desiredStatus, task.desiredStatus) &&
        Objects.equals(this.enableExecuteCommand, task.enableExecuteCommand) &&
        Objects.equals(this.executionStoppedAt, task.executionStoppedAt) &&
        Objects.equals(this.group, task.group) &&
        Objects.equals(this.healthStatus, task.healthStatus) &&
        Objects.equals(this.inferenceAccelerators, task.inferenceAccelerators) &&
        Objects.equals(this.lastStatus, task.lastStatus) &&
        Objects.equals(this.launchType, task.launchType) &&
        Objects.equals(this.memory, task.memory) &&
        Objects.equals(this.overrides, task.overrides) &&
        Objects.equals(this.platformVersion, task.platformVersion) &&
        Objects.equals(this.platformFamily, task.platformFamily) &&
        Objects.equals(this.pullStartedAt, task.pullStartedAt) &&
        Objects.equals(this.pullStoppedAt, task.pullStoppedAt) &&
        Objects.equals(this.startedAt, task.startedAt) &&
        Objects.equals(this.startedBy, task.startedBy) &&
        Objects.equals(this.stopCode, task.stopCode) &&
        Objects.equals(this.stoppedAt, task.stoppedAt) &&
        Objects.equals(this.stoppedReason, task.stoppedReason) &&
        Objects.equals(this.stoppingAt, task.stoppingAt) &&
        Objects.equals(this.tags, task.tags) &&
        Objects.equals(this.taskArn, task.taskArn) &&
        Objects.equals(this.taskDefinitionArn, task.taskDefinitionArn) &&
        Objects.equals(this.version, task.version) &&
        Objects.equals(this.ephemeralStorage, task.ephemeralStorage);
  }

  @Override
  public int hashCode() {
    return Objects.hash(attachments, attributes, availabilityZone, capacityProviderName, clusterArn, connectivity, connectivityAt, containerInstanceArn, containers, cpu, createdAt, desiredStatus, enableExecuteCommand, executionStoppedAt, group, healthStatus, inferenceAccelerators, lastStatus, launchType, memory, overrides, platformVersion, platformFamily, pullStartedAt, pullStoppedAt, startedAt, startedBy, stopCode, stoppedAt, stoppedReason, stoppingAt, tags, taskArn, taskDefinitionArn, version, ephemeralStorage);
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class Task {\n");
    sb.append("    attachments: ").append(toIndentedString(attachments)).append("\n");
    sb.append("    attributes: ").append(toIndentedString(attributes)).append("\n");
    sb.append("    availabilityZone: ").append(toIndentedString(availabilityZone)).append("\n");
    sb.append("    capacityProviderName: ").append(toIndentedString(capacityProviderName)).append("\n");
    sb.append("    clusterArn: ").append(toIndentedString(clusterArn)).append("\n");
    sb.append("    connectivity: ").append(toIndentedString(connectivity)).append("\n");
    sb.append("    connectivityAt: ").append(toIndentedString(connectivityAt)).append("\n");
    sb.append("    containerInstanceArn: ").append(toIndentedString(containerInstanceArn)).append("\n");
    sb.append("    containers: ").append(toIndentedString(containers)).append("\n");
    sb.append("    cpu: ").append(toIndentedString(cpu)).append("\n");
    sb.append("    createdAt: ").append(toIndentedString(createdAt)).append("\n");
    sb.append("    desiredStatus: ").append(toIndentedString(desiredStatus)).append("\n");
    sb.append("    enableExecuteCommand: ").append(toIndentedString(enableExecuteCommand)).append("\n");
    sb.append("    executionStoppedAt: ").append(toIndentedString(executionStoppedAt)).append("\n");
    sb.append("    group: ").append(toIndentedString(group)).append("\n");
    sb.append("    healthStatus: ").append(toIndentedString(healthStatus)).append("\n");
    sb.append("    inferenceAccelerators: ").append(toIndentedString(inferenceAccelerators)).append("\n");
    sb.append("    lastStatus: ").append(toIndentedString(lastStatus)).append("\n");
    sb.append("    launchType: ").append(toIndentedString(launchType)).append("\n");
    sb.append("    memory: ").append(toIndentedString(memory)).append("\n");
    sb.append("    overrides: ").append(toIndentedString(overrides)).append("\n");
    sb.append("    platformVersion: ").append(toIndentedString(platformVersion)).append("\n");
    sb.append("    platformFamily: ").append(toIndentedString(platformFamily)).append("\n");
    sb.append("    pullStartedAt: ").append(toIndentedString(pullStartedAt)).append("\n");
    sb.append("    pullStoppedAt: ").append(toIndentedString(pullStoppedAt)).append("\n");
    sb.append("    startedAt: ").append(toIndentedString(startedAt)).append("\n");
    sb.append("    startedBy: ").append(toIndentedString(startedBy)).append("\n");
    sb.append("    stopCode: ").append(toIndentedString(stopCode)).append("\n");
    sb.append("    stoppedAt: ").append(toIndentedString(stoppedAt)).append("\n");
    sb.append("    stoppedReason: ").append(toIndentedString(stoppedReason)).append("\n");
    sb.append("    stoppingAt: ").append(toIndentedString(stoppingAt)).append("\n");
    sb.append("    tags: ").append(toIndentedString(tags)).append("\n");
    sb.append("    taskArn: ").append(toIndentedString(taskArn)).append("\n");
    sb.append("    taskDefinitionArn: ").append(toIndentedString(taskDefinitionArn)).append("\n");
    sb.append("    version: ").append(toIndentedString(version)).append("\n");
    sb.append("    ephemeralStorage: ").append(toIndentedString(ephemeralStorage)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }


  public static HashSet<String> openapiFields;
  public static HashSet<String> openapiRequiredFields;

  static {
    // a set of all properties/fields (JSON key names)
    openapiFields = new HashSet<String>();
    openapiFields.add("attachments");
    openapiFields.add("attributes");
    openapiFields.add("availabilityZone");
    openapiFields.add("capacityProviderName");
    openapiFields.add("clusterArn");
    openapiFields.add("connectivity");
    openapiFields.add("connectivityAt");
    openapiFields.add("containerInstanceArn");
    openapiFields.add("containers");
    openapiFields.add("cpu");
    openapiFields.add("createdAt");
    openapiFields.add("desiredStatus");
    openapiFields.add("enableExecuteCommand");
    openapiFields.add("executionStoppedAt");
    openapiFields.add("group");
    openapiFields.add("healthStatus");
    openapiFields.add("inferenceAccelerators");
    openapiFields.add("lastStatus");
    openapiFields.add("launchType");
    openapiFields.add("memory");
    openapiFields.add("overrides");
    openapiFields.add("platformVersion");
    openapiFields.add("platformFamily");
    openapiFields.add("pullStartedAt");
    openapiFields.add("pullStoppedAt");
    openapiFields.add("startedAt");
    openapiFields.add("startedBy");
    openapiFields.add("stopCode");
    openapiFields.add("stoppedAt");
    openapiFields.add("stoppedReason");
    openapiFields.add("stoppingAt");
    openapiFields.add("tags");
    openapiFields.add("taskArn");
    openapiFields.add("taskDefinitionArn");
    openapiFields.add("version");
    openapiFields.add("ephemeralStorage");

    // a set of required properties/fields (JSON key names)
    openapiRequiredFields = new HashSet<String>();
  }

  /**
   * Validates the JSON Element and throws an exception if issues found
   *
   * @param jsonElement JSON Element
   * @throws IOException if the JSON Element is invalid with respect to Task
   */
  public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      if (jsonElement == null) {
        if (!Task.openapiRequiredFields.isEmpty()) { // has required fields but JSON element is null
          throw new IllegalArgumentException(String.format("The required field(s) %s in Task is not found in the empty JSON string", Task.openapiRequiredFields.toString()));
        }
      }

      Set<Map.Entry<String, JsonElement>> entries = jsonElement.getAsJsonObject().entrySet();
      // check to see if the JSON string contains additional fields
      for (Map.Entry<String, JsonElement> entry : entries) {
        if (!Task.openapiFields.contains(entry.getKey())) {
          throw new IllegalArgumentException(String.format("The field `%s` in the JSON string is not defined in the `Task` properties. JSON: %s", entry.getKey(), jsonElement.toString()));
        }
      }
        JsonObject jsonObj = jsonElement.getAsJsonObject();
      // validate the optional field `attachments`
      if (jsonObj.get("attachments") != null && !jsonObj.get("attachments").isJsonNull()) {
        List.validateJsonElement(jsonObj.get("attachments"));
      }
      // validate the optional field `attributes`
      if (jsonObj.get("attributes") != null && !jsonObj.get("attributes").isJsonNull()) {
        List.validateJsonElement(jsonObj.get("attributes"));
      }
      // validate the optional field `availabilityZone`
      if (jsonObj.get("availabilityZone") != null && !jsonObj.get("availabilityZone").isJsonNull()) {
        String.validateJsonElement(jsonObj.get("availabilityZone"));
      }
      // validate the optional field `capacityProviderName`
      if (jsonObj.get("capacityProviderName") != null && !jsonObj.get("capacityProviderName").isJsonNull()) {
        String.validateJsonElement(jsonObj.get("capacityProviderName"));
      }
      // validate the optional field `clusterArn`
      if (jsonObj.get("clusterArn") != null && !jsonObj.get("clusterArn").isJsonNull()) {
        String.validateJsonElement(jsonObj.get("clusterArn"));
      }
      // validate the optional field `connectivity`
      if (jsonObj.get("connectivity") != null && !jsonObj.get("connectivity").isJsonNull()) {
        Connectivity.validateJsonElement(jsonObj.get("connectivity"));
      }
      // validate the optional field `connectivityAt`
      if (jsonObj.get("connectivityAt") != null && !jsonObj.get("connectivityAt").isJsonNull()) {
        OffsetDateTime.validateJsonElement(jsonObj.get("connectivityAt"));
      }
      // validate the optional field `containerInstanceArn`
      if (jsonObj.get("containerInstanceArn") != null && !jsonObj.get("containerInstanceArn").isJsonNull()) {
        String.validateJsonElement(jsonObj.get("containerInstanceArn"));
      }
      // validate the optional field `containers`
      if (jsonObj.get("containers") != null && !jsonObj.get("containers").isJsonNull()) {
        List.validateJsonElement(jsonObj.get("containers"));
      }
      // validate the optional field `cpu`
      if (jsonObj.get("cpu") != null && !jsonObj.get("cpu").isJsonNull()) {
        String.validateJsonElement(jsonObj.get("cpu"));
      }
      // validate the optional field `createdAt`
      if (jsonObj.get("createdAt") != null && !jsonObj.get("createdAt").isJsonNull()) {
        OffsetDateTime.validateJsonElement(jsonObj.get("createdAt"));
      }
      // validate the optional field `desiredStatus`
      if (jsonObj.get("desiredStatus") != null && !jsonObj.get("desiredStatus").isJsonNull()) {
        String.validateJsonElement(jsonObj.get("desiredStatus"));
      }
      // validate the optional field `enableExecuteCommand`
      if (jsonObj.get("enableExecuteCommand") != null && !jsonObj.get("enableExecuteCommand").isJsonNull()) {
        Boolean.validateJsonElement(jsonObj.get("enableExecuteCommand"));
      }
      // validate the optional field `executionStoppedAt`
      if (jsonObj.get("executionStoppedAt") != null && !jsonObj.get("executionStoppedAt").isJsonNull()) {
        OffsetDateTime.validateJsonElement(jsonObj.get("executionStoppedAt"));
      }
      // validate the optional field `group`
      if (jsonObj.get("group") != null && !jsonObj.get("group").isJsonNull()) {
        String.validateJsonElement(jsonObj.get("group"));
      }
      // validate the optional field `healthStatus`
      if (jsonObj.get("healthStatus") != null && !jsonObj.get("healthStatus").isJsonNull()) {
        HealthStatus.validateJsonElement(jsonObj.get("healthStatus"));
      }
      // validate the optional field `inferenceAccelerators`
      if (jsonObj.get("inferenceAccelerators") != null && !jsonObj.get("inferenceAccelerators").isJsonNull()) {
        List.validateJsonElement(jsonObj.get("inferenceAccelerators"));
      }
      // validate the optional field `lastStatus`
      if (jsonObj.get("lastStatus") != null && !jsonObj.get("lastStatus").isJsonNull()) {
        String.validateJsonElement(jsonObj.get("lastStatus"));
      }
      // validate the optional field `launchType`
      if (jsonObj.get("launchType") != null && !jsonObj.get("launchType").isJsonNull()) {
        LaunchType.validateJsonElement(jsonObj.get("launchType"));
      }
      // validate the optional field `memory`
      if (jsonObj.get("memory") != null && !jsonObj.get("memory").isJsonNull()) {
        String.validateJsonElement(jsonObj.get("memory"));
      }
      // validate the optional field `overrides`
      if (jsonObj.get("overrides") != null && !jsonObj.get("overrides").isJsonNull()) {
        TaskOverrides.validateJsonElement(jsonObj.get("overrides"));
      }
      // validate the optional field `platformVersion`
      if (jsonObj.get("platformVersion") != null && !jsonObj.get("platformVersion").isJsonNull()) {
        String.validateJsonElement(jsonObj.get("platformVersion"));
      }
      // validate the optional field `platformFamily`
      if (jsonObj.get("platformFamily") != null && !jsonObj.get("platformFamily").isJsonNull()) {
        String.validateJsonElement(jsonObj.get("platformFamily"));
      }
      // validate the optional field `pullStartedAt`
      if (jsonObj.get("pullStartedAt") != null && !jsonObj.get("pullStartedAt").isJsonNull()) {
        OffsetDateTime.validateJsonElement(jsonObj.get("pullStartedAt"));
      }
      // validate the optional field `pullStoppedAt`
      if (jsonObj.get("pullStoppedAt") != null && !jsonObj.get("pullStoppedAt").isJsonNull()) {
        OffsetDateTime.validateJsonElement(jsonObj.get("pullStoppedAt"));
      }
      // validate the optional field `startedAt`
      if (jsonObj.get("startedAt") != null && !jsonObj.get("startedAt").isJsonNull()) {
        OffsetDateTime.validateJsonElement(jsonObj.get("startedAt"));
      }
      // validate the optional field `startedBy`
      if (jsonObj.get("startedBy") != null && !jsonObj.get("startedBy").isJsonNull()) {
        String.validateJsonElement(jsonObj.get("startedBy"));
      }
      // validate the optional field `stopCode`
      if (jsonObj.get("stopCode") != null && !jsonObj.get("stopCode").isJsonNull()) {
        TaskStopCode.validateJsonElement(jsonObj.get("stopCode"));
      }
      // validate the optional field `stoppedAt`
      if (jsonObj.get("stoppedAt") != null && !jsonObj.get("stoppedAt").isJsonNull()) {
        OffsetDateTime.validateJsonElement(jsonObj.get("stoppedAt"));
      }
      // validate the optional field `stoppedReason`
      if (jsonObj.get("stoppedReason") != null && !jsonObj.get("stoppedReason").isJsonNull()) {
        String.validateJsonElement(jsonObj.get("stoppedReason"));
      }
      // validate the optional field `stoppingAt`
      if (jsonObj.get("stoppingAt") != null && !jsonObj.get("stoppingAt").isJsonNull()) {
        OffsetDateTime.validateJsonElement(jsonObj.get("stoppingAt"));
      }
      // validate the optional field `tags`
      if (jsonObj.get("tags") != null && !jsonObj.get("tags").isJsonNull()) {
        List.validateJsonElement(jsonObj.get("tags"));
      }
      // validate the optional field `taskArn`
      if (jsonObj.get("taskArn") != null && !jsonObj.get("taskArn").isJsonNull()) {
        String.validateJsonElement(jsonObj.get("taskArn"));
      }
      // validate the optional field `taskDefinitionArn`
      if (jsonObj.get("taskDefinitionArn") != null && !jsonObj.get("taskDefinitionArn").isJsonNull()) {
        String.validateJsonElement(jsonObj.get("taskDefinitionArn"));
      }
      // validate the optional field `version`
      if (jsonObj.get("version") != null && !jsonObj.get("version").isJsonNull()) {
        Integer.validateJsonElement(jsonObj.get("version"));
      }
      // validate the optional field `ephemeralStorage`
      if (jsonObj.get("ephemeralStorage") != null && !jsonObj.get("ephemeralStorage").isJsonNull()) {
        TaskEphemeralStorage.validateJsonElement(jsonObj.get("ephemeralStorage"));
      }
  }

  public static class CustomTypeAdapterFactory implements TypeAdapterFactory {
    @SuppressWarnings("unchecked")
    @Override
    public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
       if (!Task.class.isAssignableFrom(type.getRawType())) {
         return null; // this class only serializes 'Task' and its subtypes
       }
       final TypeAdapter<JsonElement> elementAdapter = gson.getAdapter(JsonElement.class);
       final TypeAdapter<Task> thisAdapter
                        = gson.getDelegateAdapter(this, TypeToken.get(Task.class));

       return (TypeAdapter<T>) new TypeAdapter<Task>() {
           @Override
           public void write(JsonWriter out, Task value) throws IOException {
             JsonObject obj = thisAdapter.toJsonTree(value).getAsJsonObject();
             elementAdapter.write(out, obj);
           }

           @Override
           public Task read(JsonReader in) throws IOException {
             JsonElement jsonElement = elementAdapter.read(in);
             validateJsonElement(jsonElement);
             return thisAdapter.fromJsonTree(jsonElement);
           }

       }.nullSafe();
    }
  }

  /**
   * Create an instance of Task given an JSON string
   *
   * @param jsonString JSON string
   * @return An instance of Task
   * @throws IOException if the JSON string is invalid with respect to Task
   */
  public static Task fromJson(String jsonString) throws IOException {
    return JSON.getGson().fromJson(jsonString, Task.class);
  }

  /**
   * Convert an instance of Task to an JSON string
   *
   * @return JSON string
   */
  public String toJson() {
    return JSON.getGson().toJson(this);
  }
}

