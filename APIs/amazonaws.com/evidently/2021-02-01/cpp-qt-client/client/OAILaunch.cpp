/**
 * Amazon CloudWatch Evidently
 * <p>You can use Amazon CloudWatch Evidently to safely validate new features by serving them to a specified percentage of your users while you roll out the feature. You can monitor the performance of the new feature to help you decide when to ramp up traffic to your users. This helps you reduce risk and identify unintended consequences before you fully launch the feature.</p> <p>You can also conduct A/B experiments to make feature design decisions based on evidence and data. An experiment can test as many as five variations at once. Evidently collects experiment data and analyzes it using statistical methods. It also provides clear recommendations about which variations perform better. You can test both user-facing features and backend features.</p>
 *
 * The version of the OpenAPI document: 2021-02-01
 * Contact: mike.ralphson@gmail.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

#include "OAILaunch.h"

#include <QDebug>
#include <QJsonArray>
#include <QJsonDocument>
#include <QObject>

#include "OAIHelpers.h"

namespace OpenAPI {

OAILaunch::OAILaunch(QString json) {
    this->initializeModel();
    this->fromJson(json);
}

OAILaunch::OAILaunch() {
    this->initializeModel();
}

OAILaunch::~OAILaunch() {}

void OAILaunch::initializeModel() {

    m_arn_isSet = false;
    m_arn_isValid = false;

    m_created_time_isSet = false;
    m_created_time_isValid = false;

    m_description_isSet = false;
    m_description_isValid = false;

    m_execution_isSet = false;
    m_execution_isValid = false;

    m_groups_isSet = false;
    m_groups_isValid = false;

    m_last_updated_time_isSet = false;
    m_last_updated_time_isValid = false;

    m_metric_monitors_isSet = false;
    m_metric_monitors_isValid = false;

    m_name_isSet = false;
    m_name_isValid = false;

    m_project_isSet = false;
    m_project_isValid = false;

    m_randomization_salt_isSet = false;
    m_randomization_salt_isValid = false;

    m_scheduled_splits_definition_isSet = false;
    m_scheduled_splits_definition_isValid = false;

    m_status_isSet = false;
    m_status_isValid = false;

    m_status_reason_isSet = false;
    m_status_reason_isValid = false;

    m_tags_isSet = false;
    m_tags_isValid = false;

    m_type_isSet = false;
    m_type_isValid = false;
}

void OAILaunch::fromJson(QString jsonString) {
    QByteArray array(jsonString.toStdString().c_str());
    QJsonDocument doc = QJsonDocument::fromJson(array);
    QJsonObject jsonObject = doc.object();
    this->fromJsonObject(jsonObject);
}

void OAILaunch::fromJsonObject(QJsonObject json) {

    m_arn_isValid = ::OpenAPI::fromJsonValue(m_arn, json[QString("arn")]);
    m_arn_isSet = !json[QString("arn")].isNull() && m_arn_isValid;

    m_created_time_isValid = ::OpenAPI::fromJsonValue(m_created_time, json[QString("createdTime")]);
    m_created_time_isSet = !json[QString("createdTime")].isNull() && m_created_time_isValid;

    m_description_isValid = ::OpenAPI::fromJsonValue(m_description, json[QString("description")]);
    m_description_isSet = !json[QString("description")].isNull() && m_description_isValid;

    m_execution_isValid = ::OpenAPI::fromJsonValue(m_execution, json[QString("execution")]);
    m_execution_isSet = !json[QString("execution")].isNull() && m_execution_isValid;

    m_groups_isValid = ::OpenAPI::fromJsonValue(m_groups, json[QString("groups")]);
    m_groups_isSet = !json[QString("groups")].isNull() && m_groups_isValid;

    m_last_updated_time_isValid = ::OpenAPI::fromJsonValue(m_last_updated_time, json[QString("lastUpdatedTime")]);
    m_last_updated_time_isSet = !json[QString("lastUpdatedTime")].isNull() && m_last_updated_time_isValid;

    m_metric_monitors_isValid = ::OpenAPI::fromJsonValue(m_metric_monitors, json[QString("metricMonitors")]);
    m_metric_monitors_isSet = !json[QString("metricMonitors")].isNull() && m_metric_monitors_isValid;

    m_name_isValid = ::OpenAPI::fromJsonValue(m_name, json[QString("name")]);
    m_name_isSet = !json[QString("name")].isNull() && m_name_isValid;

    m_project_isValid = ::OpenAPI::fromJsonValue(m_project, json[QString("project")]);
    m_project_isSet = !json[QString("project")].isNull() && m_project_isValid;

    m_randomization_salt_isValid = ::OpenAPI::fromJsonValue(m_randomization_salt, json[QString("randomizationSalt")]);
    m_randomization_salt_isSet = !json[QString("randomizationSalt")].isNull() && m_randomization_salt_isValid;

    m_scheduled_splits_definition_isValid = ::OpenAPI::fromJsonValue(m_scheduled_splits_definition, json[QString("scheduledSplitsDefinition")]);
    m_scheduled_splits_definition_isSet = !json[QString("scheduledSplitsDefinition")].isNull() && m_scheduled_splits_definition_isValid;

    m_status_isValid = ::OpenAPI::fromJsonValue(m_status, json[QString("status")]);
    m_status_isSet = !json[QString("status")].isNull() && m_status_isValid;

    m_status_reason_isValid = ::OpenAPI::fromJsonValue(m_status_reason, json[QString("statusReason")]);
    m_status_reason_isSet = !json[QString("statusReason")].isNull() && m_status_reason_isValid;

    m_tags_isValid = ::OpenAPI::fromJsonValue(m_tags, json[QString("tags")]);
    m_tags_isSet = !json[QString("tags")].isNull() && m_tags_isValid;

    m_type_isValid = ::OpenAPI::fromJsonValue(m_type, json[QString("type")]);
    m_type_isSet = !json[QString("type")].isNull() && m_type_isValid;
}

QString OAILaunch::asJson() const {
    QJsonObject obj = this->asJsonObject();
    QJsonDocument doc(obj);
    QByteArray bytes = doc.toJson();
    return QString(bytes);
}

QJsonObject OAILaunch::asJsonObject() const {
    QJsonObject obj;
    if (m_arn_isSet) {
        obj.insert(QString("arn"), ::OpenAPI::toJsonValue(m_arn));
    }
    if (m_created_time_isSet) {
        obj.insert(QString("createdTime"), ::OpenAPI::toJsonValue(m_created_time));
    }
    if (m_description_isSet) {
        obj.insert(QString("description"), ::OpenAPI::toJsonValue(m_description));
    }
    if (m_execution.isSet()) {
        obj.insert(QString("execution"), ::OpenAPI::toJsonValue(m_execution));
    }
    if (m_groups.isSet()) {
        obj.insert(QString("groups"), ::OpenAPI::toJsonValue(m_groups));
    }
    if (m_last_updated_time_isSet) {
        obj.insert(QString("lastUpdatedTime"), ::OpenAPI::toJsonValue(m_last_updated_time));
    }
    if (m_metric_monitors.isSet()) {
        obj.insert(QString("metricMonitors"), ::OpenAPI::toJsonValue(m_metric_monitors));
    }
    if (m_name_isSet) {
        obj.insert(QString("name"), ::OpenAPI::toJsonValue(m_name));
    }
    if (m_project_isSet) {
        obj.insert(QString("project"), ::OpenAPI::toJsonValue(m_project));
    }
    if (m_randomization_salt_isSet) {
        obj.insert(QString("randomizationSalt"), ::OpenAPI::toJsonValue(m_randomization_salt));
    }
    if (m_scheduled_splits_definition.isSet()) {
        obj.insert(QString("scheduledSplitsDefinition"), ::OpenAPI::toJsonValue(m_scheduled_splits_definition));
    }
    if (m_status.isSet()) {
        obj.insert(QString("status"), ::OpenAPI::toJsonValue(m_status));
    }
    if (m_status_reason_isSet) {
        obj.insert(QString("statusReason"), ::OpenAPI::toJsonValue(m_status_reason));
    }
    if (m_tags.isSet()) {
        obj.insert(QString("tags"), ::OpenAPI::toJsonValue(m_tags));
    }
    if (m_type.isSet()) {
        obj.insert(QString("type"), ::OpenAPI::toJsonValue(m_type));
    }
    return obj;
}

QString OAILaunch::getArn() const {
    return m_arn;
}
void OAILaunch::setArn(const QString &arn) {
    m_arn = arn;
    m_arn_isSet = true;
}

bool OAILaunch::is_arn_Set() const{
    return m_arn_isSet;
}

bool OAILaunch::is_arn_Valid() const{
    return m_arn_isValid;
}

QDateTime OAILaunch::getCreatedTime() const {
    return m_created_time;
}
void OAILaunch::setCreatedTime(const QDateTime &created_time) {
    m_created_time = created_time;
    m_created_time_isSet = true;
}

bool OAILaunch::is_created_time_Set() const{
    return m_created_time_isSet;
}

bool OAILaunch::is_created_time_Valid() const{
    return m_created_time_isValid;
}

QString OAILaunch::getDescription() const {
    return m_description;
}
void OAILaunch::setDescription(const QString &description) {
    m_description = description;
    m_description_isSet = true;
}

bool OAILaunch::is_description_Set() const{
    return m_description_isSet;
}

bool OAILaunch::is_description_Valid() const{
    return m_description_isValid;
}

OAILaunch_execution OAILaunch::getExecution() const {
    return m_execution;
}
void OAILaunch::setExecution(const OAILaunch_execution &execution) {
    m_execution = execution;
    m_execution_isSet = true;
}

bool OAILaunch::is_execution_Set() const{
    return m_execution_isSet;
}

bool OAILaunch::is_execution_Valid() const{
    return m_execution_isValid;
}

QList OAILaunch::getGroups() const {
    return m_groups;
}
void OAILaunch::setGroups(const QList &groups) {
    m_groups = groups;
    m_groups_isSet = true;
}

bool OAILaunch::is_groups_Set() const{
    return m_groups_isSet;
}

bool OAILaunch::is_groups_Valid() const{
    return m_groups_isValid;
}

QDateTime OAILaunch::getLastUpdatedTime() const {
    return m_last_updated_time;
}
void OAILaunch::setLastUpdatedTime(const QDateTime &last_updated_time) {
    m_last_updated_time = last_updated_time;
    m_last_updated_time_isSet = true;
}

bool OAILaunch::is_last_updated_time_Set() const{
    return m_last_updated_time_isSet;
}

bool OAILaunch::is_last_updated_time_Valid() const{
    return m_last_updated_time_isValid;
}

QList OAILaunch::getMetricMonitors() const {
    return m_metric_monitors;
}
void OAILaunch::setMetricMonitors(const QList &metric_monitors) {
    m_metric_monitors = metric_monitors;
    m_metric_monitors_isSet = true;
}

bool OAILaunch::is_metric_monitors_Set() const{
    return m_metric_monitors_isSet;
}

bool OAILaunch::is_metric_monitors_Valid() const{
    return m_metric_monitors_isValid;
}

QString OAILaunch::getName() const {
    return m_name;
}
void OAILaunch::setName(const QString &name) {
    m_name = name;
    m_name_isSet = true;
}

bool OAILaunch::is_name_Set() const{
    return m_name_isSet;
}

bool OAILaunch::is_name_Valid() const{
    return m_name_isValid;
}

QString OAILaunch::getProject() const {
    return m_project;
}
void OAILaunch::setProject(const QString &project) {
    m_project = project;
    m_project_isSet = true;
}

bool OAILaunch::is_project_Set() const{
    return m_project_isSet;
}

bool OAILaunch::is_project_Valid() const{
    return m_project_isValid;
}

QString OAILaunch::getRandomizationSalt() const {
    return m_randomization_salt;
}
void OAILaunch::setRandomizationSalt(const QString &randomization_salt) {
    m_randomization_salt = randomization_salt;
    m_randomization_salt_isSet = true;
}

bool OAILaunch::is_randomization_salt_Set() const{
    return m_randomization_salt_isSet;
}

bool OAILaunch::is_randomization_salt_Valid() const{
    return m_randomization_salt_isValid;
}

OAILaunch_scheduledSplitsDefinition OAILaunch::getScheduledSplitsDefinition() const {
    return m_scheduled_splits_definition;
}
void OAILaunch::setScheduledSplitsDefinition(const OAILaunch_scheduledSplitsDefinition &scheduled_splits_definition) {
    m_scheduled_splits_definition = scheduled_splits_definition;
    m_scheduled_splits_definition_isSet = true;
}

bool OAILaunch::is_scheduled_splits_definition_Set() const{
    return m_scheduled_splits_definition_isSet;
}

bool OAILaunch::is_scheduled_splits_definition_Valid() const{
    return m_scheduled_splits_definition_isValid;
}

OAILaunchStatus OAILaunch::getStatus() const {
    return m_status;
}
void OAILaunch::setStatus(const OAILaunchStatus &status) {
    m_status = status;
    m_status_isSet = true;
}

bool OAILaunch::is_status_Set() const{
    return m_status_isSet;
}

bool OAILaunch::is_status_Valid() const{
    return m_status_isValid;
}

QString OAILaunch::getStatusReason() const {
    return m_status_reason;
}
void OAILaunch::setStatusReason(const QString &status_reason) {
    m_status_reason = status_reason;
    m_status_reason_isSet = true;
}

bool OAILaunch::is_status_reason_Set() const{
    return m_status_reason_isSet;
}

bool OAILaunch::is_status_reason_Valid() const{
    return m_status_reason_isValid;
}

QMap OAILaunch::getTags() const {
    return m_tags;
}
void OAILaunch::setTags(const QMap &tags) {
    m_tags = tags;
    m_tags_isSet = true;
}

bool OAILaunch::is_tags_Set() const{
    return m_tags_isSet;
}

bool OAILaunch::is_tags_Valid() const{
    return m_tags_isValid;
}

OAILaunchType OAILaunch::getType() const {
    return m_type;
}
void OAILaunch::setType(const OAILaunchType &type) {
    m_type = type;
    m_type_isSet = true;
}

bool OAILaunch::is_type_Set() const{
    return m_type_isSet;
}

bool OAILaunch::is_type_Valid() const{
    return m_type_isValid;
}

bool OAILaunch::isSet() const {
    bool isObjectUpdated = false;
    do {
        if (m_arn_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_created_time_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_description_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_execution.isSet()) {
            isObjectUpdated = true;
            break;
        }

        if (m_groups.isSet()) {
            isObjectUpdated = true;
            break;
        }

        if (m_last_updated_time_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_metric_monitors.isSet()) {
            isObjectUpdated = true;
            break;
        }

        if (m_name_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_project_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_randomization_salt_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_scheduled_splits_definition.isSet()) {
            isObjectUpdated = true;
            break;
        }

        if (m_status.isSet()) {
            isObjectUpdated = true;
            break;
        }

        if (m_status_reason_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_tags.isSet()) {
            isObjectUpdated = true;
            break;
        }

        if (m_type.isSet()) {
            isObjectUpdated = true;
            break;
        }
    } while (false);
    return isObjectUpdated;
}

bool OAILaunch::isValid() const {
    // only required properties are required for the object to be considered valid
    return m_arn_isValid && m_created_time_isValid && m_last_updated_time_isValid && m_name_isValid && m_status_isValid && m_type_isValid && true;
}

} // namespace OpenAPI
