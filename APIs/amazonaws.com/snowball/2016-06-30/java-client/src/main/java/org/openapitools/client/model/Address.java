/*
 * Amazon Import/Export Snowball
 * The Amazon Web Services Snow Family provides a petabyte-scale data transport solution that uses secure devices to transfer large amounts of data between your on-premises data centers and Amazon Simple Storage Service (Amazon S3). The Snow Family commands described here provide access to the same functionality that is available in the Amazon Web Services Snow Family Management Console, which enables you to create and manage jobs for a Snow Family device. To transfer data locally with a Snow Family device, you'll need to use the Snowball Edge client or the Amazon S3 API Interface for Snowball or OpsHub for Snow Family. For more information, see the <a href=\"https://docs.aws.amazon.com/AWSImportExport/latest/ug/api-reference.html\">User Guide</a>.
 *
 * The version of the OpenAPI document: 2016-06-30
 * Contact: mike.ralphson@gmail.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package org.openapitools.client.model;

import java.util.Objects;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;
import java.util.Arrays;
import org.openapitools.client.model.AddressType;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonArray;
import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;
import com.google.gson.TypeAdapterFactory;
import com.google.gson.reflect.TypeToken;
import com.google.gson.TypeAdapter;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;

import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import org.openapitools.client.JSON;

/**
 * The address that you want the Snow device(s) associated with a specific job to be shipped to. Addresses are validated at the time of creation. The address you provide must be located within the serviceable area of your region. Although no individual elements of the &lt;code&gt;Address&lt;/code&gt; are required, if the address is invalid or unsupported, then an exception is thrown.
 */
@javax.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen", date = "2024-10-12T12:27:55.026961-04:00[America/New_York]", comments = "Generator version: 7.9.0")
public class Address {
  public static final String SERIALIZED_NAME_ADDRESS_ID = "AddressId";
  @SerializedName(SERIALIZED_NAME_ADDRESS_ID)
  private String addressId;

  public static final String SERIALIZED_NAME_NAME = "Name";
  @SerializedName(SERIALIZED_NAME_NAME)
  private String name;

  public static final String SERIALIZED_NAME_COMPANY = "Company";
  @SerializedName(SERIALIZED_NAME_COMPANY)
  private String company;

  public static final String SERIALIZED_NAME_STREET1 = "Street1";
  @SerializedName(SERIALIZED_NAME_STREET1)
  private String street1;

  public static final String SERIALIZED_NAME_STREET2 = "Street2";
  @SerializedName(SERIALIZED_NAME_STREET2)
  private String street2;

  public static final String SERIALIZED_NAME_STREET3 = "Street3";
  @SerializedName(SERIALIZED_NAME_STREET3)
  private String street3;

  public static final String SERIALIZED_NAME_CITY = "City";
  @SerializedName(SERIALIZED_NAME_CITY)
  private String city;

  public static final String SERIALIZED_NAME_STATE_OR_PROVINCE = "StateOrProvince";
  @SerializedName(SERIALIZED_NAME_STATE_OR_PROVINCE)
  private String stateOrProvince;

  public static final String SERIALIZED_NAME_PREFECTURE_OR_DISTRICT = "PrefectureOrDistrict";
  @SerializedName(SERIALIZED_NAME_PREFECTURE_OR_DISTRICT)
  private String prefectureOrDistrict;

  public static final String SERIALIZED_NAME_LANDMARK = "Landmark";
  @SerializedName(SERIALIZED_NAME_LANDMARK)
  private String landmark;

  public static final String SERIALIZED_NAME_COUNTRY = "Country";
  @SerializedName(SERIALIZED_NAME_COUNTRY)
  private String country;

  public static final String SERIALIZED_NAME_POSTAL_CODE = "PostalCode";
  @SerializedName(SERIALIZED_NAME_POSTAL_CODE)
  private String postalCode;

  public static final String SERIALIZED_NAME_PHONE_NUMBER = "PhoneNumber";
  @SerializedName(SERIALIZED_NAME_PHONE_NUMBER)
  private String phoneNumber;

  public static final String SERIALIZED_NAME_IS_RESTRICTED = "IsRestricted";
  @SerializedName(SERIALIZED_NAME_IS_RESTRICTED)
  private Boolean isRestricted;

  public static final String SERIALIZED_NAME_TYPE = "Type";
  @SerializedName(SERIALIZED_NAME_TYPE)
  private AddressType type;

  public Address() {
  }

  public Address addressId(String addressId) {
    this.addressId = addressId;
    return this;
  }

  /**
   * Get addressId
   * @return addressId
   */
  @javax.annotation.Nullable
  public String getAddressId() {
    return addressId;
  }

  public void setAddressId(String addressId) {
    this.addressId = addressId;
  }


  public Address name(String name) {
    this.name = name;
    return this;
  }

  /**
   * Get name
   * @return name
   */
  @javax.annotation.Nullable
  public String getName() {
    return name;
  }

  public void setName(String name) {
    this.name = name;
  }


  public Address company(String company) {
    this.company = company;
    return this;
  }

  /**
   * Get company
   * @return company
   */
  @javax.annotation.Nullable
  public String getCompany() {
    return company;
  }

  public void setCompany(String company) {
    this.company = company;
  }


  public Address street1(String street1) {
    this.street1 = street1;
    return this;
  }

  /**
   * Get street1
   * @return street1
   */
  @javax.annotation.Nullable
  public String getStreet1() {
    return street1;
  }

  public void setStreet1(String street1) {
    this.street1 = street1;
  }


  public Address street2(String street2) {
    this.street2 = street2;
    return this;
  }

  /**
   * Get street2
   * @return street2
   */
  @javax.annotation.Nullable
  public String getStreet2() {
    return street2;
  }

  public void setStreet2(String street2) {
    this.street2 = street2;
  }


  public Address street3(String street3) {
    this.street3 = street3;
    return this;
  }

  /**
   * Get street3
   * @return street3
   */
  @javax.annotation.Nullable
  public String getStreet3() {
    return street3;
  }

  public void setStreet3(String street3) {
    this.street3 = street3;
  }


  public Address city(String city) {
    this.city = city;
    return this;
  }

  /**
   * Get city
   * @return city
   */
  @javax.annotation.Nullable
  public String getCity() {
    return city;
  }

  public void setCity(String city) {
    this.city = city;
  }


  public Address stateOrProvince(String stateOrProvince) {
    this.stateOrProvince = stateOrProvince;
    return this;
  }

  /**
   * Get stateOrProvince
   * @return stateOrProvince
   */
  @javax.annotation.Nullable
  public String getStateOrProvince() {
    return stateOrProvince;
  }

  public void setStateOrProvince(String stateOrProvince) {
    this.stateOrProvince = stateOrProvince;
  }


  public Address prefectureOrDistrict(String prefectureOrDistrict) {
    this.prefectureOrDistrict = prefectureOrDistrict;
    return this;
  }

  /**
   * Get prefectureOrDistrict
   * @return prefectureOrDistrict
   */
  @javax.annotation.Nullable
  public String getPrefectureOrDistrict() {
    return prefectureOrDistrict;
  }

  public void setPrefectureOrDistrict(String prefectureOrDistrict) {
    this.prefectureOrDistrict = prefectureOrDistrict;
  }


  public Address landmark(String landmark) {
    this.landmark = landmark;
    return this;
  }

  /**
   * Get landmark
   * @return landmark
   */
  @javax.annotation.Nullable
  public String getLandmark() {
    return landmark;
  }

  public void setLandmark(String landmark) {
    this.landmark = landmark;
  }


  public Address country(String country) {
    this.country = country;
    return this;
  }

  /**
   * Get country
   * @return country
   */
  @javax.annotation.Nullable
  public String getCountry() {
    return country;
  }

  public void setCountry(String country) {
    this.country = country;
  }


  public Address postalCode(String postalCode) {
    this.postalCode = postalCode;
    return this;
  }

  /**
   * Get postalCode
   * @return postalCode
   */
  @javax.annotation.Nullable
  public String getPostalCode() {
    return postalCode;
  }

  public void setPostalCode(String postalCode) {
    this.postalCode = postalCode;
  }


  public Address phoneNumber(String phoneNumber) {
    this.phoneNumber = phoneNumber;
    return this;
  }

  /**
   * Get phoneNumber
   * @return phoneNumber
   */
  @javax.annotation.Nullable
  public String getPhoneNumber() {
    return phoneNumber;
  }

  public void setPhoneNumber(String phoneNumber) {
    this.phoneNumber = phoneNumber;
  }


  public Address isRestricted(Boolean isRestricted) {
    this.isRestricted = isRestricted;
    return this;
  }

  /**
   * Get isRestricted
   * @return isRestricted
   */
  @javax.annotation.Nullable
  public Boolean getIsRestricted() {
    return isRestricted;
  }

  public void setIsRestricted(Boolean isRestricted) {
    this.isRestricted = isRestricted;
  }


  public Address type(AddressType type) {
    this.type = type;
    return this;
  }

  /**
   * Get type
   * @return type
   */
  @javax.annotation.Nullable
  public AddressType getType() {
    return type;
  }

  public void setType(AddressType type) {
    this.type = type;
  }



  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    Address address = (Address) o;
    return Objects.equals(this.addressId, address.addressId) &&
        Objects.equals(this.name, address.name) &&
        Objects.equals(this.company, address.company) &&
        Objects.equals(this.street1, address.street1) &&
        Objects.equals(this.street2, address.street2) &&
        Objects.equals(this.street3, address.street3) &&
        Objects.equals(this.city, address.city) &&
        Objects.equals(this.stateOrProvince, address.stateOrProvince) &&
        Objects.equals(this.prefectureOrDistrict, address.prefectureOrDistrict) &&
        Objects.equals(this.landmark, address.landmark) &&
        Objects.equals(this.country, address.country) &&
        Objects.equals(this.postalCode, address.postalCode) &&
        Objects.equals(this.phoneNumber, address.phoneNumber) &&
        Objects.equals(this.isRestricted, address.isRestricted) &&
        Objects.equals(this.type, address.type);
  }

  @Override
  public int hashCode() {
    return Objects.hash(addressId, name, company, street1, street2, street3, city, stateOrProvince, prefectureOrDistrict, landmark, country, postalCode, phoneNumber, isRestricted, type);
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class Address {\n");
    sb.append("    addressId: ").append(toIndentedString(addressId)).append("\n");
    sb.append("    name: ").append(toIndentedString(name)).append("\n");
    sb.append("    company: ").append(toIndentedString(company)).append("\n");
    sb.append("    street1: ").append(toIndentedString(street1)).append("\n");
    sb.append("    street2: ").append(toIndentedString(street2)).append("\n");
    sb.append("    street3: ").append(toIndentedString(street3)).append("\n");
    sb.append("    city: ").append(toIndentedString(city)).append("\n");
    sb.append("    stateOrProvince: ").append(toIndentedString(stateOrProvince)).append("\n");
    sb.append("    prefectureOrDistrict: ").append(toIndentedString(prefectureOrDistrict)).append("\n");
    sb.append("    landmark: ").append(toIndentedString(landmark)).append("\n");
    sb.append("    country: ").append(toIndentedString(country)).append("\n");
    sb.append("    postalCode: ").append(toIndentedString(postalCode)).append("\n");
    sb.append("    phoneNumber: ").append(toIndentedString(phoneNumber)).append("\n");
    sb.append("    isRestricted: ").append(toIndentedString(isRestricted)).append("\n");
    sb.append("    type: ").append(toIndentedString(type)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }


  public static HashSet<String> openapiFields;
  public static HashSet<String> openapiRequiredFields;

  static {
    // a set of all properties/fields (JSON key names)
    openapiFields = new HashSet<String>();
    openapiFields.add("AddressId");
    openapiFields.add("Name");
    openapiFields.add("Company");
    openapiFields.add("Street1");
    openapiFields.add("Street2");
    openapiFields.add("Street3");
    openapiFields.add("City");
    openapiFields.add("StateOrProvince");
    openapiFields.add("PrefectureOrDistrict");
    openapiFields.add("Landmark");
    openapiFields.add("Country");
    openapiFields.add("PostalCode");
    openapiFields.add("PhoneNumber");
    openapiFields.add("IsRestricted");
    openapiFields.add("Type");

    // a set of required properties/fields (JSON key names)
    openapiRequiredFields = new HashSet<String>();
  }

  /**
   * Validates the JSON Element and throws an exception if issues found
   *
   * @param jsonElement JSON Element
   * @throws IOException if the JSON Element is invalid with respect to Address
   */
  public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      if (jsonElement == null) {
        if (!Address.openapiRequiredFields.isEmpty()) { // has required fields but JSON element is null
          throw new IllegalArgumentException(String.format("The required field(s) %s in Address is not found in the empty JSON string", Address.openapiRequiredFields.toString()));
        }
      }

      Set<Map.Entry<String, JsonElement>> entries = jsonElement.getAsJsonObject().entrySet();
      // check to see if the JSON string contains additional fields
      for (Map.Entry<String, JsonElement> entry : entries) {
        if (!Address.openapiFields.contains(entry.getKey())) {
          throw new IllegalArgumentException(String.format("The field `%s` in the JSON string is not defined in the `Address` properties. JSON: %s", entry.getKey(), jsonElement.toString()));
        }
      }
        JsonObject jsonObj = jsonElement.getAsJsonObject();
      // validate the optional field `AddressId`
      if (jsonObj.get("AddressId") != null && !jsonObj.get("AddressId").isJsonNull()) {
        String.validateJsonElement(jsonObj.get("AddressId"));
      }
      // validate the optional field `Name`
      if (jsonObj.get("Name") != null && !jsonObj.get("Name").isJsonNull()) {
        String.validateJsonElement(jsonObj.get("Name"));
      }
      // validate the optional field `Company`
      if (jsonObj.get("Company") != null && !jsonObj.get("Company").isJsonNull()) {
        String.validateJsonElement(jsonObj.get("Company"));
      }
      // validate the optional field `Street1`
      if (jsonObj.get("Street1") != null && !jsonObj.get("Street1").isJsonNull()) {
        String.validateJsonElement(jsonObj.get("Street1"));
      }
      // validate the optional field `Street2`
      if (jsonObj.get("Street2") != null && !jsonObj.get("Street2").isJsonNull()) {
        String.validateJsonElement(jsonObj.get("Street2"));
      }
      // validate the optional field `Street3`
      if (jsonObj.get("Street3") != null && !jsonObj.get("Street3").isJsonNull()) {
        String.validateJsonElement(jsonObj.get("Street3"));
      }
      // validate the optional field `City`
      if (jsonObj.get("City") != null && !jsonObj.get("City").isJsonNull()) {
        String.validateJsonElement(jsonObj.get("City"));
      }
      // validate the optional field `StateOrProvince`
      if (jsonObj.get("StateOrProvince") != null && !jsonObj.get("StateOrProvince").isJsonNull()) {
        String.validateJsonElement(jsonObj.get("StateOrProvince"));
      }
      // validate the optional field `PrefectureOrDistrict`
      if (jsonObj.get("PrefectureOrDistrict") != null && !jsonObj.get("PrefectureOrDistrict").isJsonNull()) {
        String.validateJsonElement(jsonObj.get("PrefectureOrDistrict"));
      }
      // validate the optional field `Landmark`
      if (jsonObj.get("Landmark") != null && !jsonObj.get("Landmark").isJsonNull()) {
        String.validateJsonElement(jsonObj.get("Landmark"));
      }
      // validate the optional field `Country`
      if (jsonObj.get("Country") != null && !jsonObj.get("Country").isJsonNull()) {
        String.validateJsonElement(jsonObj.get("Country"));
      }
      // validate the optional field `PostalCode`
      if (jsonObj.get("PostalCode") != null && !jsonObj.get("PostalCode").isJsonNull()) {
        String.validateJsonElement(jsonObj.get("PostalCode"));
      }
      // validate the optional field `PhoneNumber`
      if (jsonObj.get("PhoneNumber") != null && !jsonObj.get("PhoneNumber").isJsonNull()) {
        String.validateJsonElement(jsonObj.get("PhoneNumber"));
      }
      // validate the optional field `IsRestricted`
      if (jsonObj.get("IsRestricted") != null && !jsonObj.get("IsRestricted").isJsonNull()) {
        Boolean.validateJsonElement(jsonObj.get("IsRestricted"));
      }
      // validate the optional field `Type`
      if (jsonObj.get("Type") != null && !jsonObj.get("Type").isJsonNull()) {
        AddressType.validateJsonElement(jsonObj.get("Type"));
      }
  }

  public static class CustomTypeAdapterFactory implements TypeAdapterFactory {
    @SuppressWarnings("unchecked")
    @Override
    public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
       if (!Address.class.isAssignableFrom(type.getRawType())) {
         return null; // this class only serializes 'Address' and its subtypes
       }
       final TypeAdapter<JsonElement> elementAdapter = gson.getAdapter(JsonElement.class);
       final TypeAdapter<Address> thisAdapter
                        = gson.getDelegateAdapter(this, TypeToken.get(Address.class));

       return (TypeAdapter<T>) new TypeAdapter<Address>() {
           @Override
           public void write(JsonWriter out, Address value) throws IOException {
             JsonObject obj = thisAdapter.toJsonTree(value).getAsJsonObject();
             elementAdapter.write(out, obj);
           }

           @Override
           public Address read(JsonReader in) throws IOException {
             JsonElement jsonElement = elementAdapter.read(in);
             validateJsonElement(jsonElement);
             return thisAdapter.fromJsonTree(jsonElement);
           }

       }.nullSafe();
    }
  }

  /**
   * Create an instance of Address given an JSON string
   *
   * @param jsonString JSON string
   * @return An instance of Address
   * @throws IOException if the JSON string is invalid with respect to Address
   */
  public static Address fromJson(String jsonString) throws IOException {
    return JSON.getGson().fromJson(jsonString, Address.class);
  }

  /**
   * Convert an instance of Address to an JSON string
   *
   * @return JSON string
   */
  public String toJson() {
    return JSON.getGson().toJson(this);
  }
}

