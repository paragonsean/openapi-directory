/**
 * Amazon EventBridge Scheduler
 *  Amazon EventBridge Scheduler is a serverless scheduler that allows you to create, run, and manage tasks from one central, managed service. EventBridge Scheduler delivers your tasks reliably, with built-in mechanisms that adjust your schedules based on the availability of downstream targets. The following reference lists the available API actions, and data types for EventBridge Scheduler. 
 *
 * The version of the OpenAPI document: 2021-06-30
 * Contact: mike.ralphson@gmail.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 *
 */

import ApiClient from '../ApiClient';
import UpdateScheduleRequestFlexibleTimeWindow from './UpdateScheduleRequestFlexibleTimeWindow';
import UpdateScheduleRequestTarget from './UpdateScheduleRequestTarget';

/**
 * The UpdateScheduleRequest model module.
 * @module model/UpdateScheduleRequest
 * @version 2021-06-30
 */
class UpdateScheduleRequest {
    /**
     * Constructs a new <code>UpdateScheduleRequest</code>.
     * @alias module:model/UpdateScheduleRequest
     * @param flexibleTimeWindow {module:model/UpdateScheduleRequestFlexibleTimeWindow} 
     * @param scheduleExpression {String} <p> The expression that defines when the schedule runs. The following formats are supported. </p> <ul> <li> <p> <code>at</code> expression - <code>at(yyyy-mm-ddThh:mm:ss)</code> </p> </li> <li> <p> <code>rate</code> expression - <code>rate(value unit)</code> </p> </li> <li> <p> <code>cron</code> expression - <code>cron(fields)</code> </p> </li> </ul> <p> You can use <code>at</code> expressions to create one-time schedules that invoke a target once, at the time and in the time zone, that you specify. You can use <code>rate</code> and <code>cron</code> expressions to create recurring schedules. Rate-based schedules are useful when you want to invoke a target at regular intervals, such as every 15 minutes or every five days. Cron-based schedules are useful when you want to invoke a target periodically at a specific time, such as at 8:00 am (UTC+0) every 1st day of the month. </p> <p> A <code>cron</code> expression consists of six fields separated by white spaces: <code>(minutes hours day_of_month month day_of_week year)</code>. </p> <p> A <code>rate</code> expression consists of a <i>value</i> as a positive integer, and a <i>unit</i> with the following options: <code>minute</code> | <code>minutes</code> | <code>hour</code> | <code>hours</code> | <code>day</code> | <code>days</code> </p> <p> For more information and examples, see <a href=\"https://docs.aws.amazon.com/scheduler/latest/UserGuide/schedule-types.html\">Schedule types on EventBridge Scheduler</a> in the <i>EventBridge Scheduler User Guide</i>. </p>
     * @param target {module:model/UpdateScheduleRequestTarget} 
     */
    constructor(flexibleTimeWindow, scheduleExpression, target) { 
        
        UpdateScheduleRequest.initialize(this, flexibleTimeWindow, scheduleExpression, target);
    }

    /**
     * Initializes the fields of this object.
     * This method is used by the constructors of any subclasses, in order to implement multiple inheritance (mix-ins).
     * Only for internal use.
     */
    static initialize(obj, flexibleTimeWindow, scheduleExpression, target) { 
        obj['FlexibleTimeWindow'] = flexibleTimeWindow;
        obj['ScheduleExpression'] = scheduleExpression;
        obj['Target'] = target;
    }

    /**
     * Constructs a <code>UpdateScheduleRequest</code> from a plain JavaScript object, optionally creating a new instance.
     * Copies all relevant properties from <code>data</code> to <code>obj</code> if supplied or a new instance if not.
     * @param {Object} data The plain JavaScript object bearing properties of interest.
     * @param {module:model/UpdateScheduleRequest} obj Optional instance to populate.
     * @return {module:model/UpdateScheduleRequest} The populated <code>UpdateScheduleRequest</code> instance.
     */
    static constructFromObject(data, obj) {
        if (data) {
            obj = obj || new UpdateScheduleRequest();

            if (data.hasOwnProperty('ActionAfterCompletion')) {
                obj['ActionAfterCompletion'] = ApiClient.convertToType(data['ActionAfterCompletion'], 'String');
            }
            if (data.hasOwnProperty('ClientToken')) {
                obj['ClientToken'] = ApiClient.convertToType(data['ClientToken'], 'String');
            }
            if (data.hasOwnProperty('Description')) {
                obj['Description'] = ApiClient.convertToType(data['Description'], 'String');
            }
            if (data.hasOwnProperty('EndDate')) {
                obj['EndDate'] = ApiClient.convertToType(data['EndDate'], 'Date');
            }
            if (data.hasOwnProperty('FlexibleTimeWindow')) {
                obj['FlexibleTimeWindow'] = UpdateScheduleRequestFlexibleTimeWindow.constructFromObject(data['FlexibleTimeWindow']);
            }
            if (data.hasOwnProperty('GroupName')) {
                obj['GroupName'] = ApiClient.convertToType(data['GroupName'], 'String');
            }
            if (data.hasOwnProperty('KmsKeyArn')) {
                obj['KmsKeyArn'] = ApiClient.convertToType(data['KmsKeyArn'], 'String');
            }
            if (data.hasOwnProperty('ScheduleExpression')) {
                obj['ScheduleExpression'] = ApiClient.convertToType(data['ScheduleExpression'], 'String');
            }
            if (data.hasOwnProperty('ScheduleExpressionTimezone')) {
                obj['ScheduleExpressionTimezone'] = ApiClient.convertToType(data['ScheduleExpressionTimezone'], 'String');
            }
            if (data.hasOwnProperty('StartDate')) {
                obj['StartDate'] = ApiClient.convertToType(data['StartDate'], 'Date');
            }
            if (data.hasOwnProperty('State')) {
                obj['State'] = ApiClient.convertToType(data['State'], 'String');
            }
            if (data.hasOwnProperty('Target')) {
                obj['Target'] = UpdateScheduleRequestTarget.constructFromObject(data['Target']);
            }
        }
        return obj;
    }

    /**
     * Validates the JSON data with respect to <code>UpdateScheduleRequest</code>.
     * @param {Object} data The plain JavaScript object bearing properties of interest.
     * @return {boolean} to indicate whether the JSON data is valid with respect to <code>UpdateScheduleRequest</code>.
     */
    static validateJSON(data) {
        // check to make sure all required properties are present in the JSON string
        for (const property of UpdateScheduleRequest.RequiredProperties) {
            if (!data.hasOwnProperty(property)) {
                throw new Error("The required field `" + property + "` is not found in the JSON data: " + JSON.stringify(data));
            }
        }
        // ensure the json data is a string
        if (data['ActionAfterCompletion'] && !(typeof data['ActionAfterCompletion'] === 'string' || data['ActionAfterCompletion'] instanceof String)) {
            throw new Error("Expected the field `ActionAfterCompletion` to be a primitive type in the JSON string but got " + data['ActionAfterCompletion']);
        }
        // ensure the json data is a string
        if (data['ClientToken'] && !(typeof data['ClientToken'] === 'string' || data['ClientToken'] instanceof String)) {
            throw new Error("Expected the field `ClientToken` to be a primitive type in the JSON string but got " + data['ClientToken']);
        }
        // ensure the json data is a string
        if (data['Description'] && !(typeof data['Description'] === 'string' || data['Description'] instanceof String)) {
            throw new Error("Expected the field `Description` to be a primitive type in the JSON string but got " + data['Description']);
        }
        // validate the optional field `FlexibleTimeWindow`
        if (data['FlexibleTimeWindow']) { // data not null
          UpdateScheduleRequestFlexibleTimeWindow.validateJSON(data['FlexibleTimeWindow']);
        }
        // ensure the json data is a string
        if (data['GroupName'] && !(typeof data['GroupName'] === 'string' || data['GroupName'] instanceof String)) {
            throw new Error("Expected the field `GroupName` to be a primitive type in the JSON string but got " + data['GroupName']);
        }
        // ensure the json data is a string
        if (data['KmsKeyArn'] && !(typeof data['KmsKeyArn'] === 'string' || data['KmsKeyArn'] instanceof String)) {
            throw new Error("Expected the field `KmsKeyArn` to be a primitive type in the JSON string but got " + data['KmsKeyArn']);
        }
        // ensure the json data is a string
        if (data['ScheduleExpression'] && !(typeof data['ScheduleExpression'] === 'string' || data['ScheduleExpression'] instanceof String)) {
            throw new Error("Expected the field `ScheduleExpression` to be a primitive type in the JSON string but got " + data['ScheduleExpression']);
        }
        // ensure the json data is a string
        if (data['ScheduleExpressionTimezone'] && !(typeof data['ScheduleExpressionTimezone'] === 'string' || data['ScheduleExpressionTimezone'] instanceof String)) {
            throw new Error("Expected the field `ScheduleExpressionTimezone` to be a primitive type in the JSON string but got " + data['ScheduleExpressionTimezone']);
        }
        // ensure the json data is a string
        if (data['State'] && !(typeof data['State'] === 'string' || data['State'] instanceof String)) {
            throw new Error("Expected the field `State` to be a primitive type in the JSON string but got " + data['State']);
        }
        // validate the optional field `Target`
        if (data['Target']) { // data not null
          UpdateScheduleRequestTarget.validateJSON(data['Target']);
        }

        return true;
    }


}

UpdateScheduleRequest.RequiredProperties = ["FlexibleTimeWindow", "ScheduleExpression", "Target"];

/**
 * Specifies the action that EventBridge Scheduler applies to the schedule after the schedule completes invoking the target.
 * @member {module:model/UpdateScheduleRequest.ActionAfterCompletionEnum} ActionAfterCompletion
 */
UpdateScheduleRequest.prototype['ActionAfterCompletion'] = undefined;

/**
 *  Unique, case-sensitive identifier you provide to ensure the idempotency of the request. If you do not specify a client token, EventBridge Scheduler uses a randomly generated token for the request to ensure idempotency. 
 * @member {String} ClientToken
 */
UpdateScheduleRequest.prototype['ClientToken'] = undefined;

/**
 * The description you specify for the schedule.
 * @member {String} Description
 */
UpdateScheduleRequest.prototype['Description'] = undefined;

/**
 * The date, in UTC, before which the schedule can invoke its target. Depending on the schedule's recurrence expression, invocations might stop on, or before, the <code>EndDate</code> you specify. EventBridge Scheduler ignores <code>EndDate</code> for one-time schedules.
 * @member {Date} EndDate
 */
UpdateScheduleRequest.prototype['EndDate'] = undefined;

/**
 * @member {module:model/UpdateScheduleRequestFlexibleTimeWindow} FlexibleTimeWindow
 */
UpdateScheduleRequest.prototype['FlexibleTimeWindow'] = undefined;

/**
 * The name of the schedule group with which the schedule is associated. You must provide this value in order for EventBridge Scheduler to find the schedule you want to update. If you omit this value, EventBridge Scheduler assumes the group is associated to the default group.
 * @member {String} GroupName
 */
UpdateScheduleRequest.prototype['GroupName'] = undefined;

/**
 * The ARN for the customer managed KMS key that that you want EventBridge Scheduler to use to encrypt and decrypt your data.
 * @member {String} KmsKeyArn
 */
UpdateScheduleRequest.prototype['KmsKeyArn'] = undefined;

/**
 * <p> The expression that defines when the schedule runs. The following formats are supported. </p> <ul> <li> <p> <code>at</code> expression - <code>at(yyyy-mm-ddThh:mm:ss)</code> </p> </li> <li> <p> <code>rate</code> expression - <code>rate(value unit)</code> </p> </li> <li> <p> <code>cron</code> expression - <code>cron(fields)</code> </p> </li> </ul> <p> You can use <code>at</code> expressions to create one-time schedules that invoke a target once, at the time and in the time zone, that you specify. You can use <code>rate</code> and <code>cron</code> expressions to create recurring schedules. Rate-based schedules are useful when you want to invoke a target at regular intervals, such as every 15 minutes or every five days. Cron-based schedules are useful when you want to invoke a target periodically at a specific time, such as at 8:00 am (UTC+0) every 1st day of the month. </p> <p> A <code>cron</code> expression consists of six fields separated by white spaces: <code>(minutes hours day_of_month month day_of_week year)</code>. </p> <p> A <code>rate</code> expression consists of a <i>value</i> as a positive integer, and a <i>unit</i> with the following options: <code>minute</code> | <code>minutes</code> | <code>hour</code> | <code>hours</code> | <code>day</code> | <code>days</code> </p> <p> For more information and examples, see <a href=\"https://docs.aws.amazon.com/scheduler/latest/UserGuide/schedule-types.html\">Schedule types on EventBridge Scheduler</a> in the <i>EventBridge Scheduler User Guide</i>. </p>
 * @member {String} ScheduleExpression
 */
UpdateScheduleRequest.prototype['ScheduleExpression'] = undefined;

/**
 * The timezone in which the scheduling expression is evaluated.
 * @member {String} ScheduleExpressionTimezone
 */
UpdateScheduleRequest.prototype['ScheduleExpressionTimezone'] = undefined;

/**
 * The date, in UTC, after which the schedule can begin invoking its target. Depending on the schedule's recurrence expression, invocations might occur on, or after, the <code>StartDate</code> you specify. EventBridge Scheduler ignores <code>StartDate</code> for one-time schedules.
 * @member {Date} StartDate
 */
UpdateScheduleRequest.prototype['StartDate'] = undefined;

/**
 * Specifies whether the schedule is enabled or disabled.
 * @member {module:model/UpdateScheduleRequest.StateEnum} State
 */
UpdateScheduleRequest.prototype['State'] = undefined;

/**
 * @member {module:model/UpdateScheduleRequestTarget} Target
 */
UpdateScheduleRequest.prototype['Target'] = undefined;





/**
 * Allowed values for the <code>ActionAfterCompletion</code> property.
 * @enum {String}
 * @readonly
 */
UpdateScheduleRequest['ActionAfterCompletionEnum'] = {

    /**
     * value: "NONE"
     * @const
     */
    "NONE": "NONE",

    /**
     * value: "DELETE"
     * @const
     */
    "DELETE": "DELETE"
};


/**
 * Allowed values for the <code>State</code> property.
 * @enum {String}
 * @readonly
 */
UpdateScheduleRequest['StateEnum'] = {

    /**
     * value: "ENABLED"
     * @const
     */
    "ENABLED": "ENABLED",

    /**
     * value: "DISABLED"
     * @const
     */
    "DISABLED": "DISABLED"
};



export default UpdateScheduleRequest;

