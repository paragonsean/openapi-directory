# coding: utf-8

from datetime import date, datetime

from typing import List, Dict, Type

from openapi_server.models.base_model import Model
import re
from openapi_server import util


class CreateChannelRequest(Model):
    """NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).

    Do not edit the class manually.
    """

    def __init__(self, authorized: bool=None, insecure_ingest: bool=None, latency_mode: str=None, name: str=None, preset: str=None, recording_configuration_arn: str=None, tags: Dict[str, str]=None, type: str=None):
        """CreateChannelRequest - a model defined in OpenAPI

        :param authorized: The authorized of this CreateChannelRequest.
        :param insecure_ingest: The insecure_ingest of this CreateChannelRequest.
        :param latency_mode: The latency_mode of this CreateChannelRequest.
        :param name: The name of this CreateChannelRequest.
        :param preset: The preset of this CreateChannelRequest.
        :param recording_configuration_arn: The recording_configuration_arn of this CreateChannelRequest.
        :param tags: The tags of this CreateChannelRequest.
        :param type: The type of this CreateChannelRequest.
        """
        self.openapi_types = {
            'authorized': bool,
            'insecure_ingest': bool,
            'latency_mode': str,
            'name': str,
            'preset': str,
            'recording_configuration_arn': str,
            'tags': Dict[str, str],
            'type': str
        }

        self.attribute_map = {
            'authorized': 'authorized',
            'insecure_ingest': 'insecureIngest',
            'latency_mode': 'latencyMode',
            'name': 'name',
            'preset': 'preset',
            'recording_configuration_arn': 'recordingConfigurationArn',
            'tags': 'tags',
            'type': 'type'
        }

        self._authorized = authorized
        self._insecure_ingest = insecure_ingest
        self._latency_mode = latency_mode
        self._name = name
        self._preset = preset
        self._recording_configuration_arn = recording_configuration_arn
        self._tags = tags
        self._type = type

    @classmethod
    def from_dict(cls, dikt: dict) -> 'CreateChannelRequest':
        """Returns the dict as a model

        :param dikt: A dict.
        :return: The CreateChannel_request of this CreateChannelRequest.
        """
        return util.deserialize_model(dikt, cls)

    @property
    def authorized(self):
        """Gets the authorized of this CreateChannelRequest.

        Whether the channel is private (enabled for playback authorization). Default: <code>false</code>.

        :return: The authorized of this CreateChannelRequest.
        :rtype: bool
        """
        return self._authorized

    @authorized.setter
    def authorized(self, authorized):
        """Sets the authorized of this CreateChannelRequest.

        Whether the channel is private (enabled for playback authorization). Default: <code>false</code>.

        :param authorized: The authorized of this CreateChannelRequest.
        :type authorized: bool
        """

        self._authorized = authorized

    @property
    def insecure_ingest(self):
        """Gets the insecure_ingest of this CreateChannelRequest.

        Whether the channel allows insecure RTMP ingest. Default: <code>false</code>.

        :return: The insecure_ingest of this CreateChannelRequest.
        :rtype: bool
        """
        return self._insecure_ingest

    @insecure_ingest.setter
    def insecure_ingest(self, insecure_ingest):
        """Sets the insecure_ingest of this CreateChannelRequest.

        Whether the channel allows insecure RTMP ingest. Default: <code>false</code>.

        :param insecure_ingest: The insecure_ingest of this CreateChannelRequest.
        :type insecure_ingest: bool
        """

        self._insecure_ingest = insecure_ingest

    @property
    def latency_mode(self):
        """Gets the latency_mode of this CreateChannelRequest.

        Channel latency mode. Use <code>NORMAL</code> to broadcast and deliver live video up to Full HD. Use <code>LOW</code> for near-real-time interaction with viewers. (Note: In the Amazon IVS console, <code>LOW</code> and <code>NORMAL</code> correspond to Ultra-low and Standard, respectively.) Default: <code>LOW</code>.

        :return: The latency_mode of this CreateChannelRequest.
        :rtype: str
        """
        return self._latency_mode

    @latency_mode.setter
    def latency_mode(self, latency_mode):
        """Sets the latency_mode of this CreateChannelRequest.

        Channel latency mode. Use <code>NORMAL</code> to broadcast and deliver live video up to Full HD. Use <code>LOW</code> for near-real-time interaction with viewers. (Note: In the Amazon IVS console, <code>LOW</code> and <code>NORMAL</code> correspond to Ultra-low and Standard, respectively.) Default: <code>LOW</code>.

        :param latency_mode: The latency_mode of this CreateChannelRequest.
        :type latency_mode: str
        """
        allowed_values = ["NORMAL", "LOW"]  # noqa: E501
        if latency_mode not in allowed_values:
            raise ValueError(
                "Invalid value for `latency_mode` ({0}), must be one of {1}"
                .format(latency_mode, allowed_values)
            )

        self._latency_mode = latency_mode

    @property
    def name(self):
        """Gets the name of this CreateChannelRequest.

        Channel name.

        :return: The name of this CreateChannelRequest.
        :rtype: str
        """
        return self._name

    @name.setter
    def name(self, name):
        """Sets the name of this CreateChannelRequest.

        Channel name.

        :param name: The name of this CreateChannelRequest.
        :type name: str
        """
        if name is not None and len(name) > 128:
            raise ValueError("Invalid value for `name`, length must be less than or equal to `128`")
        if name is not None and len(name) < 0:
            raise ValueError("Invalid value for `name`, length must be greater than or equal to `0`")
        if name is not None and not re.search(r'^[a-zA-Z0-9-_]*$', name):
            raise ValueError("Invalid value for `name`, must be a follow pattern or equal to `/^[a-zA-Z0-9-_]*$/`")

        self._name = name

    @property
    def preset(self):
        """Gets the preset of this CreateChannelRequest.

        Optional transcode preset for the channel. This is selectable only for <code>ADVANCED_HD</code> and <code>ADVANCED_SD</code> channel types. For those channel types, the default <code>preset</code> is <code>HIGHER_BANDWIDTH_DELIVERY</code>. For other channel types (<code>BASIC</code> and <code>STANDARD</code>), <code>preset</code> is the empty string (<code>\"\"</code>).

        :return: The preset of this CreateChannelRequest.
        :rtype: str
        """
        return self._preset

    @preset.setter
    def preset(self, preset):
        """Sets the preset of this CreateChannelRequest.

        Optional transcode preset for the channel. This is selectable only for <code>ADVANCED_HD</code> and <code>ADVANCED_SD</code> channel types. For those channel types, the default <code>preset</code> is <code>HIGHER_BANDWIDTH_DELIVERY</code>. For other channel types (<code>BASIC</code> and <code>STANDARD</code>), <code>preset</code> is the empty string (<code>\"\"</code>).

        :param preset: The preset of this CreateChannelRequest.
        :type preset: str
        """
        allowed_values = ["HIGHER_BANDWIDTH_DELIVERY", "CONSTRAINED_BANDWIDTH_DELIVERY"]  # noqa: E501
        if preset not in allowed_values:
            raise ValueError(
                "Invalid value for `preset` ({0}), must be one of {1}"
                .format(preset, allowed_values)
            )

        self._preset = preset

    @property
    def recording_configuration_arn(self):
        """Gets the recording_configuration_arn of this CreateChannelRequest.

        Recording-configuration ARN. Default: \"\" (empty string, recording is disabled).

        :return: The recording_configuration_arn of this CreateChannelRequest.
        :rtype: str
        """
        return self._recording_configuration_arn

    @recording_configuration_arn.setter
    def recording_configuration_arn(self, recording_configuration_arn):
        """Sets the recording_configuration_arn of this CreateChannelRequest.

        Recording-configuration ARN. Default: \"\" (empty string, recording is disabled).

        :param recording_configuration_arn: The recording_configuration_arn of this CreateChannelRequest.
        :type recording_configuration_arn: str
        """
        if recording_configuration_arn is not None and len(recording_configuration_arn) > 128:
            raise ValueError("Invalid value for `recording_configuration_arn`, length must be less than or equal to `128`")
        if recording_configuration_arn is not None and len(recording_configuration_arn) < 0:
            raise ValueError("Invalid value for `recording_configuration_arn`, length must be greater than or equal to `0`")
        if recording_configuration_arn is not None and not re.search(r'^$|^arn:aws:ivs:[a-z0-9-]+:[0-9]+:recording-configuration\/[a-zA-Z0-9-]+$', recording_configuration_arn):
            raise ValueError("Invalid value for `recording_configuration_arn`, must be a follow pattern or equal to `/^$|^arn:aws:ivs:[a-z0-9-]+:[0-9]+:recording-configuration\/[a-zA-Z0-9-]+$/`")

        self._recording_configuration_arn = recording_configuration_arn

    @property
    def tags(self):
        """Gets the tags of this CreateChannelRequest.

        Array of 1-50 maps, each of the form <code>string:string (key:value)</code>. See <a href=\"https://docs.aws.amazon.com/general/latest/gr/aws_tagging.html\">Tagging Amazon Web Services Resources</a> for more information, including restrictions that apply to tags and \"Tag naming limits and requirements\"; Amazon IVS has no service-specific constraints beyond what is documented there.

        :return: The tags of this CreateChannelRequest.
        :rtype: Dict[str, str]
        """
        return self._tags

    @tags.setter
    def tags(self, tags):
        """Sets the tags of this CreateChannelRequest.

        Array of 1-50 maps, each of the form <code>string:string (key:value)</code>. See <a href=\"https://docs.aws.amazon.com/general/latest/gr/aws_tagging.html\">Tagging Amazon Web Services Resources</a> for more information, including restrictions that apply to tags and \"Tag naming limits and requirements\"; Amazon IVS has no service-specific constraints beyond what is documented there.

        :param tags: The tags of this CreateChannelRequest.
        :type tags: Dict[str, str]
        """
        if tags is not None and len(tags) > 50:
            raise ValueError("Invalid value for `tags`, number of items must be less than or equal to `50`")
        if tags is not None and len(tags) < 0:
            raise ValueError("Invalid value for `tags`, number of items must be greater than or equal to `0`")

        self._tags = tags

    @property
    def type(self):
        """Gets the type of this CreateChannelRequest.

        <p>Channel type, which determines the allowable resolution and bitrate. <i>If you exceed the allowable input resolution or bitrate, the stream probably will disconnect immediately.</i> Some types generate multiple qualities (renditions) from the original input; this automatically gives viewers the best experience for their devices and network conditions. Some types provide transcoded video; transcoding allows higher playback quality across a range of download speeds. Default: <code>STANDARD</code>. Valid values:</p> <ul> <li> <p> <code>BASIC</code>: Video is transmuxed: Amazon IVS delivers the original input quality to viewers. The viewer’s video-quality choice is limited to the original input. Input resolution can be up to 1080p and bitrate can be up to 1.5 Mbps for 480p and up to 3.5 Mbps for resolutions between 480p and 1080p. Original audio is passed through.</p> </li> <li> <p> <code>STANDARD</code>: Video is transcoded: multiple qualities are generated from the original input, to automatically give viewers the best experience for their devices and network conditions. Transcoding allows higher playback quality across a range of download speeds. Resolution can be up to 1080p and bitrate can be up to 8.5 Mbps. Audio is transcoded only for renditions 360p and below; above that, audio is passed through. This is the default when you create a channel.</p> </li> <li> <p> <code>ADVANCED_SD</code>: Video is transcoded; multiple qualities are generated from the original input, to automatically give viewers the best experience for their devices and network conditions. Input resolution can be up to 1080p and bitrate can be up to 8.5 Mbps; output is capped at SD quality (480p). You can select an optional transcode preset (see below). Audio for all renditions is transcoded, and an audio-only rendition is available.</p> </li> <li> <p> <code>ADVANCED_HD</code>: Video is transcoded; multiple qualities are generated from the original input, to automatically give viewers the best experience for their devices and network conditions. Input resolution can be up to 1080p and bitrate can be up to 8.5 Mbps; output is capped at HD quality (720p). You can select an optional transcode preset (see below). Audio for all renditions is transcoded, and an audio-only rendition is available.</p> </li> </ul> <p>Optional <i>transcode presets</i> (available for the <code>ADVANCED</code> types) allow you to trade off available download bandwidth and video quality, to optimize the viewing experience. There are two presets:</p> <ul> <li> <p> <i>Constrained bandwidth delivery</i> uses a lower bitrate for each quality level. Use it if you have low download bandwidth and/or simple video content (e.g., talking heads)</p> </li> <li> <p> <i>Higher bandwidth delivery</i> uses a higher bitrate for each quality level. Use it if you have high download bandwidth and/or complex video content (e.g., flashes and quick scene changes).</p> </li> </ul>

        :return: The type of this CreateChannelRequest.
        :rtype: str
        """
        return self._type

    @type.setter
    def type(self, type):
        """Sets the type of this CreateChannelRequest.

        <p>Channel type, which determines the allowable resolution and bitrate. <i>If you exceed the allowable input resolution or bitrate, the stream probably will disconnect immediately.</i> Some types generate multiple qualities (renditions) from the original input; this automatically gives viewers the best experience for their devices and network conditions. Some types provide transcoded video; transcoding allows higher playback quality across a range of download speeds. Default: <code>STANDARD</code>. Valid values:</p> <ul> <li> <p> <code>BASIC</code>: Video is transmuxed: Amazon IVS delivers the original input quality to viewers. The viewer’s video-quality choice is limited to the original input. Input resolution can be up to 1080p and bitrate can be up to 1.5 Mbps for 480p and up to 3.5 Mbps for resolutions between 480p and 1080p. Original audio is passed through.</p> </li> <li> <p> <code>STANDARD</code>: Video is transcoded: multiple qualities are generated from the original input, to automatically give viewers the best experience for their devices and network conditions. Transcoding allows higher playback quality across a range of download speeds. Resolution can be up to 1080p and bitrate can be up to 8.5 Mbps. Audio is transcoded only for renditions 360p and below; above that, audio is passed through. This is the default when you create a channel.</p> </li> <li> <p> <code>ADVANCED_SD</code>: Video is transcoded; multiple qualities are generated from the original input, to automatically give viewers the best experience for their devices and network conditions. Input resolution can be up to 1080p and bitrate can be up to 8.5 Mbps; output is capped at SD quality (480p). You can select an optional transcode preset (see below). Audio for all renditions is transcoded, and an audio-only rendition is available.</p> </li> <li> <p> <code>ADVANCED_HD</code>: Video is transcoded; multiple qualities are generated from the original input, to automatically give viewers the best experience for their devices and network conditions. Input resolution can be up to 1080p and bitrate can be up to 8.5 Mbps; output is capped at HD quality (720p). You can select an optional transcode preset (see below). Audio for all renditions is transcoded, and an audio-only rendition is available.</p> </li> </ul> <p>Optional <i>transcode presets</i> (available for the <code>ADVANCED</code> types) allow you to trade off available download bandwidth and video quality, to optimize the viewing experience. There are two presets:</p> <ul> <li> <p> <i>Constrained bandwidth delivery</i> uses a lower bitrate for each quality level. Use it if you have low download bandwidth and/or simple video content (e.g., talking heads)</p> </li> <li> <p> <i>Higher bandwidth delivery</i> uses a higher bitrate for each quality level. Use it if you have high download bandwidth and/or complex video content (e.g., flashes and quick scene changes).</p> </li> </ul>

        :param type: The type of this CreateChannelRequest.
        :type type: str
        """
        allowed_values = ["BASIC", "STANDARD", "ADVANCED_SD", "ADVANCED_HD"]  # noqa: E501
        if type not in allowed_values:
            raise ValueError(
                "Invalid value for `type` ({0}), must be one of {1}"
                .format(type, allowed_values)
            )

        self._type = type
