# coding: utf-8

from datetime import date, datetime

from typing import List, Dict, Type

from openapi_server.models.base_model import Model
import re
from openapi_server import util


class UpdateChannelRequest(Model):
    """NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).

    Do not edit the class manually.
    """

    def __init__(self, arn: str=None, authorized: bool=None, insecure_ingest: bool=None, latency_mode: str=None, name: str=None, preset: str=None, recording_configuration_arn: str=None, type: str=None):
        """UpdateChannelRequest - a model defined in OpenAPI

        :param arn: The arn of this UpdateChannelRequest.
        :param authorized: The authorized of this UpdateChannelRequest.
        :param insecure_ingest: The insecure_ingest of this UpdateChannelRequest.
        :param latency_mode: The latency_mode of this UpdateChannelRequest.
        :param name: The name of this UpdateChannelRequest.
        :param preset: The preset of this UpdateChannelRequest.
        :param recording_configuration_arn: The recording_configuration_arn of this UpdateChannelRequest.
        :param type: The type of this UpdateChannelRequest.
        """
        self.openapi_types = {
            'arn': str,
            'authorized': bool,
            'insecure_ingest': bool,
            'latency_mode': str,
            'name': str,
            'preset': str,
            'recording_configuration_arn': str,
            'type': str
        }

        self.attribute_map = {
            'arn': 'arn',
            'authorized': 'authorized',
            'insecure_ingest': 'insecureIngest',
            'latency_mode': 'latencyMode',
            'name': 'name',
            'preset': 'preset',
            'recording_configuration_arn': 'recordingConfigurationArn',
            'type': 'type'
        }

        self._arn = arn
        self._authorized = authorized
        self._insecure_ingest = insecure_ingest
        self._latency_mode = latency_mode
        self._name = name
        self._preset = preset
        self._recording_configuration_arn = recording_configuration_arn
        self._type = type

    @classmethod
    def from_dict(cls, dikt: dict) -> 'UpdateChannelRequest':
        """Returns the dict as a model

        :param dikt: A dict.
        :return: The UpdateChannel_request of this UpdateChannelRequest.
        """
        return util.deserialize_model(dikt, cls)

    @property
    def arn(self):
        """Gets the arn of this UpdateChannelRequest.

        ARN of the channel to be updated.

        :return: The arn of this UpdateChannelRequest.
        :rtype: str
        """
        return self._arn

    @arn.setter
    def arn(self, arn):
        """Sets the arn of this UpdateChannelRequest.

        ARN of the channel to be updated.

        :param arn: The arn of this UpdateChannelRequest.
        :type arn: str
        """
        if arn is None:
            raise ValueError("Invalid value for `arn`, must not be `None`")
        if arn is not None and len(arn) > 128:
            raise ValueError("Invalid value for `arn`, length must be less than or equal to `128`")
        if arn is not None and len(arn) < 1:
            raise ValueError("Invalid value for `arn`, length must be greater than or equal to `1`")
        if arn is not None and not re.search(r'^arn:aws:[is]vs:[a-z0-9-]+:[0-9]+:channel\/[a-zA-Z0-9-]+$', arn):
            raise ValueError("Invalid value for `arn`, must be a follow pattern or equal to `/^arn:aws:[is]vs:[a-z0-9-]+:[0-9]+:channel\/[a-zA-Z0-9-]+$/`")

        self._arn = arn

    @property
    def authorized(self):
        """Gets the authorized of this UpdateChannelRequest.

        Whether the channel is private (enabled for playback authorization).

        :return: The authorized of this UpdateChannelRequest.
        :rtype: bool
        """
        return self._authorized

    @authorized.setter
    def authorized(self, authorized):
        """Sets the authorized of this UpdateChannelRequest.

        Whether the channel is private (enabled for playback authorization).

        :param authorized: The authorized of this UpdateChannelRequest.
        :type authorized: bool
        """

        self._authorized = authorized

    @property
    def insecure_ingest(self):
        """Gets the insecure_ingest of this UpdateChannelRequest.

        Whether the channel allows insecure RTMP ingest. Default: <code>false</code>.

        :return: The insecure_ingest of this UpdateChannelRequest.
        :rtype: bool
        """
        return self._insecure_ingest

    @insecure_ingest.setter
    def insecure_ingest(self, insecure_ingest):
        """Sets the insecure_ingest of this UpdateChannelRequest.

        Whether the channel allows insecure RTMP ingest. Default: <code>false</code>.

        :param insecure_ingest: The insecure_ingest of this UpdateChannelRequest.
        :type insecure_ingest: bool
        """

        self._insecure_ingest = insecure_ingest

    @property
    def latency_mode(self):
        """Gets the latency_mode of this UpdateChannelRequest.

        Channel latency mode. Use <code>NORMAL</code> to broadcast and deliver live video up to Full HD. Use <code>LOW</code> for near-real-time interaction with viewers. (Note: In the Amazon IVS console, <code>LOW</code> and <code>NORMAL</code> correspond to Ultra-low and Standard, respectively.)

        :return: The latency_mode of this UpdateChannelRequest.
        :rtype: str
        """
        return self._latency_mode

    @latency_mode.setter
    def latency_mode(self, latency_mode):
        """Sets the latency_mode of this UpdateChannelRequest.

        Channel latency mode. Use <code>NORMAL</code> to broadcast and deliver live video up to Full HD. Use <code>LOW</code> for near-real-time interaction with viewers. (Note: In the Amazon IVS console, <code>LOW</code> and <code>NORMAL</code> correspond to Ultra-low and Standard, respectively.)

        :param latency_mode: The latency_mode of this UpdateChannelRequest.
        :type latency_mode: str
        """
        allowed_values = ["NORMAL", "LOW"]  # noqa: E501
        if latency_mode not in allowed_values:
            raise ValueError(
                "Invalid value for `latency_mode` ({0}), must be one of {1}"
                .format(latency_mode, allowed_values)
            )

        self._latency_mode = latency_mode

    @property
    def name(self):
        """Gets the name of this UpdateChannelRequest.

        Channel name.

        :return: The name of this UpdateChannelRequest.
        :rtype: str
        """
        return self._name

    @name.setter
    def name(self, name):
        """Sets the name of this UpdateChannelRequest.

        Channel name.

        :param name: The name of this UpdateChannelRequest.
        :type name: str
        """
        if name is not None and len(name) > 128:
            raise ValueError("Invalid value for `name`, length must be less than or equal to `128`")
        if name is not None and len(name) < 0:
            raise ValueError("Invalid value for `name`, length must be greater than or equal to `0`")
        if name is not None and not re.search(r'^[a-zA-Z0-9-_]*$', name):
            raise ValueError("Invalid value for `name`, must be a follow pattern or equal to `/^[a-zA-Z0-9-_]*$/`")

        self._name = name

    @property
    def preset(self):
        """Gets the preset of this UpdateChannelRequest.

        Optional transcode preset for the channel. This is selectable only for <code>ADVANCED_HD</code> and <code>ADVANCED_SD</code> channel types. For those channel types, the default <code>preset</code> is <code>HIGHER_BANDWIDTH_DELIVERY</code>. For other channel types (<code>BASIC</code> and <code>STANDARD</code>), <code>preset</code> is the empty string (<code>\"\"</code>).

        :return: The preset of this UpdateChannelRequest.
        :rtype: str
        """
        return self._preset

    @preset.setter
    def preset(self, preset):
        """Sets the preset of this UpdateChannelRequest.

        Optional transcode preset for the channel. This is selectable only for <code>ADVANCED_HD</code> and <code>ADVANCED_SD</code> channel types. For those channel types, the default <code>preset</code> is <code>HIGHER_BANDWIDTH_DELIVERY</code>. For other channel types (<code>BASIC</code> and <code>STANDARD</code>), <code>preset</code> is the empty string (<code>\"\"</code>).

        :param preset: The preset of this UpdateChannelRequest.
        :type preset: str
        """
        allowed_values = ["HIGHER_BANDWIDTH_DELIVERY", "CONSTRAINED_BANDWIDTH_DELIVERY"]  # noqa: E501
        if preset not in allowed_values:
            raise ValueError(
                "Invalid value for `preset` ({0}), must be one of {1}"
                .format(preset, allowed_values)
            )

        self._preset = preset

    @property
    def recording_configuration_arn(self):
        """Gets the recording_configuration_arn of this UpdateChannelRequest.

        Recording-configuration ARN. If this is set to an empty string, recording is disabled. A value other than an empty string indicates that recording is enabled

        :return: The recording_configuration_arn of this UpdateChannelRequest.
        :rtype: str
        """
        return self._recording_configuration_arn

    @recording_configuration_arn.setter
    def recording_configuration_arn(self, recording_configuration_arn):
        """Sets the recording_configuration_arn of this UpdateChannelRequest.

        Recording-configuration ARN. If this is set to an empty string, recording is disabled. A value other than an empty string indicates that recording is enabled

        :param recording_configuration_arn: The recording_configuration_arn of this UpdateChannelRequest.
        :type recording_configuration_arn: str
        """
        if recording_configuration_arn is not None and len(recording_configuration_arn) > 128:
            raise ValueError("Invalid value for `recording_configuration_arn`, length must be less than or equal to `128`")
        if recording_configuration_arn is not None and len(recording_configuration_arn) < 0:
            raise ValueError("Invalid value for `recording_configuration_arn`, length must be greater than or equal to `0`")
        if recording_configuration_arn is not None and not re.search(r'^$|^arn:aws:ivs:[a-z0-9-]+:[0-9]+:recording-configuration\/[a-zA-Z0-9-]+$', recording_configuration_arn):
            raise ValueError("Invalid value for `recording_configuration_arn`, must be a follow pattern or equal to `/^$|^arn:aws:ivs:[a-z0-9-]+:[0-9]+:recording-configuration\/[a-zA-Z0-9-]+$/`")

        self._recording_configuration_arn = recording_configuration_arn

    @property
    def type(self):
        """Gets the type of this UpdateChannelRequest.

        <p>Channel type, which determines the allowable resolution and bitrate. <i>If you exceed the allowable input resolution or bitrate, the stream probably will disconnect immediately.</i> Some types generate multiple qualities (renditions) from the original input; this automatically gives viewers the best experience for their devices and network conditions. Some types provide transcoded video; transcoding allows higher playback quality across a range of download speeds. Default: <code>STANDARD</code>. Valid values:</p> <ul> <li> <p> <code>BASIC</code>: Video is transmuxed: Amazon IVS delivers the original input quality to viewers. The viewer’s video-quality choice is limited to the original input. Input resolution can be up to 1080p and bitrate can be up to 1.5 Mbps for 480p and up to 3.5 Mbps for resolutions between 480p and 1080p. Original audio is passed through.</p> </li> <li> <p> <code>STANDARD</code>: Video is transcoded: multiple qualities are generated from the original input, to automatically give viewers the best experience for their devices and network conditions. Transcoding allows higher playback quality across a range of download speeds. Resolution can be up to 1080p and bitrate can be up to 8.5 Mbps. Audio is transcoded only for renditions 360p and below; above that, audio is passed through. This is the default when you create a channel.</p> </li> <li> <p> <code>ADVANCED_SD</code>: Video is transcoded; multiple qualities are generated from the original input, to automatically give viewers the best experience for their devices and network conditions. Input resolution can be up to 1080p and bitrate can be up to 8.5 Mbps; output is capped at SD quality (480p). You can select an optional transcode preset (see below). Audio for all renditions is transcoded, and an audio-only rendition is available.</p> </li> <li> <p> <code>ADVANCED_HD</code>: Video is transcoded; multiple qualities are generated from the original input, to automatically give viewers the best experience for their devices and network conditions. Input resolution can be up to 1080p and bitrate can be up to 8.5 Mbps; output is capped at HD quality (720p). You can select an optional transcode preset (see below). Audio for all renditions is transcoded, and an audio-only rendition is available.</p> </li> </ul> <p>Optional <i>transcode presets</i> (available for the <code>ADVANCED</code> types) allow you to trade off available download bandwidth and video quality, to optimize the viewing experience. There are two presets:</p> <ul> <li> <p> <i>Constrained bandwidth delivery</i> uses a lower bitrate for each quality level. Use it if you have low download bandwidth and/or simple video content (e.g., talking heads)</p> </li> <li> <p> <i>Higher bandwidth delivery</i> uses a higher bitrate for each quality level. Use it if you have high download bandwidth and/or complex video content (e.g., flashes and quick scene changes).</p> </li> </ul>

        :return: The type of this UpdateChannelRequest.
        :rtype: str
        """
        return self._type

    @type.setter
    def type(self, type):
        """Sets the type of this UpdateChannelRequest.

        <p>Channel type, which determines the allowable resolution and bitrate. <i>If you exceed the allowable input resolution or bitrate, the stream probably will disconnect immediately.</i> Some types generate multiple qualities (renditions) from the original input; this automatically gives viewers the best experience for their devices and network conditions. Some types provide transcoded video; transcoding allows higher playback quality across a range of download speeds. Default: <code>STANDARD</code>. Valid values:</p> <ul> <li> <p> <code>BASIC</code>: Video is transmuxed: Amazon IVS delivers the original input quality to viewers. The viewer’s video-quality choice is limited to the original input. Input resolution can be up to 1080p and bitrate can be up to 1.5 Mbps for 480p and up to 3.5 Mbps for resolutions between 480p and 1080p. Original audio is passed through.</p> </li> <li> <p> <code>STANDARD</code>: Video is transcoded: multiple qualities are generated from the original input, to automatically give viewers the best experience for their devices and network conditions. Transcoding allows higher playback quality across a range of download speeds. Resolution can be up to 1080p and bitrate can be up to 8.5 Mbps. Audio is transcoded only for renditions 360p and below; above that, audio is passed through. This is the default when you create a channel.</p> </li> <li> <p> <code>ADVANCED_SD</code>: Video is transcoded; multiple qualities are generated from the original input, to automatically give viewers the best experience for their devices and network conditions. Input resolution can be up to 1080p and bitrate can be up to 8.5 Mbps; output is capped at SD quality (480p). You can select an optional transcode preset (see below). Audio for all renditions is transcoded, and an audio-only rendition is available.</p> </li> <li> <p> <code>ADVANCED_HD</code>: Video is transcoded; multiple qualities are generated from the original input, to automatically give viewers the best experience for their devices and network conditions. Input resolution can be up to 1080p and bitrate can be up to 8.5 Mbps; output is capped at HD quality (720p). You can select an optional transcode preset (see below). Audio for all renditions is transcoded, and an audio-only rendition is available.</p> </li> </ul> <p>Optional <i>transcode presets</i> (available for the <code>ADVANCED</code> types) allow you to trade off available download bandwidth and video quality, to optimize the viewing experience. There are two presets:</p> <ul> <li> <p> <i>Constrained bandwidth delivery</i> uses a lower bitrate for each quality level. Use it if you have low download bandwidth and/or simple video content (e.g., talking heads)</p> </li> <li> <p> <i>Higher bandwidth delivery</i> uses a higher bitrate for each quality level. Use it if you have high download bandwidth and/or complex video content (e.g., flashes and quick scene changes).</p> </li> </ul>

        :param type: The type of this UpdateChannelRequest.
        :type type: str
        """
        allowed_values = ["BASIC", "STANDARD", "ADVANCED_SD", "ADVANCED_HD"]  # noqa: E501
        if type not in allowed_values:
            raise ValueError(
                "Invalid value for `type` ({0}), must be one of {1}"
                .format(type, allowed_values)
            )

        self._type = type
