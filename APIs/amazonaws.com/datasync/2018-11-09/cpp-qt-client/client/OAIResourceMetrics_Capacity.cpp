/**
 * AWS DataSync
 * <fullname>DataSync</fullname> <p>DataSync is an online data movement and discovery service that simplifies data migration and helps you quickly, easily, and securely transfer your file or object data to, from, and between Amazon Web Services storage services.</p> <p>This API interface reference includes documentation for using DataSync programmatically. For complete information, see the <i> <a href=\"https://docs.aws.amazon.com/datasync/latest/userguide/what-is-datasync.html\">DataSync User Guide</a> </i>.</p>
 *
 * The version of the OpenAPI document: 2018-11-09
 * Contact: mike.ralphson@gmail.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

#include "OAIResourceMetrics_Capacity.h"

#include <QDebug>
#include <QJsonArray>
#include <QJsonDocument>
#include <QObject>

#include "OAIHelpers.h"

namespace OpenAPI {

OAIResourceMetrics_Capacity::OAIResourceMetrics_Capacity(QString json) {
    this->initializeModel();
    this->fromJson(json);
}

OAIResourceMetrics_Capacity::OAIResourceMetrics_Capacity() {
    this->initializeModel();
}

OAIResourceMetrics_Capacity::~OAIResourceMetrics_Capacity() {}

void OAIResourceMetrics_Capacity::initializeModel() {

    m_used_isSet = false;
    m_used_isValid = false;

    m_provisioned_isSet = false;
    m_provisioned_isValid = false;

    m_logical_used_isSet = false;
    m_logical_used_isValid = false;

    m_cluster_cloud_storage_used_isSet = false;
    m_cluster_cloud_storage_used_isValid = false;
}

void OAIResourceMetrics_Capacity::fromJson(QString jsonString) {
    QByteArray array(jsonString.toStdString().c_str());
    QJsonDocument doc = QJsonDocument::fromJson(array);
    QJsonObject jsonObject = doc.object();
    this->fromJsonObject(jsonObject);
}

void OAIResourceMetrics_Capacity::fromJsonObject(QJsonObject json) {

    m_used_isValid = ::OpenAPI::fromJsonValue(m_used, json[QString("Used")]);
    m_used_isSet = !json[QString("Used")].isNull() && m_used_isValid;

    m_provisioned_isValid = ::OpenAPI::fromJsonValue(m_provisioned, json[QString("Provisioned")]);
    m_provisioned_isSet = !json[QString("Provisioned")].isNull() && m_provisioned_isValid;

    m_logical_used_isValid = ::OpenAPI::fromJsonValue(m_logical_used, json[QString("LogicalUsed")]);
    m_logical_used_isSet = !json[QString("LogicalUsed")].isNull() && m_logical_used_isValid;

    m_cluster_cloud_storage_used_isValid = ::OpenAPI::fromJsonValue(m_cluster_cloud_storage_used, json[QString("ClusterCloudStorageUsed")]);
    m_cluster_cloud_storage_used_isSet = !json[QString("ClusterCloudStorageUsed")].isNull() && m_cluster_cloud_storage_used_isValid;
}

QString OAIResourceMetrics_Capacity::asJson() const {
    QJsonObject obj = this->asJsonObject();
    QJsonDocument doc(obj);
    QByteArray bytes = doc.toJson();
    return QString(bytes);
}

QJsonObject OAIResourceMetrics_Capacity::asJsonObject() const {
    QJsonObject obj;
    if (m_used_isSet) {
        obj.insert(QString("Used"), ::OpenAPI::toJsonValue(m_used));
    }
    if (m_provisioned_isSet) {
        obj.insert(QString("Provisioned"), ::OpenAPI::toJsonValue(m_provisioned));
    }
    if (m_logical_used_isSet) {
        obj.insert(QString("LogicalUsed"), ::OpenAPI::toJsonValue(m_logical_used));
    }
    if (m_cluster_cloud_storage_used_isSet) {
        obj.insert(QString("ClusterCloudStorageUsed"), ::OpenAPI::toJsonValue(m_cluster_cloud_storage_used));
    }
    return obj;
}

qint32 OAIResourceMetrics_Capacity::getUsed() const {
    return m_used;
}
void OAIResourceMetrics_Capacity::setUsed(const qint32 &used) {
    m_used = used;
    m_used_isSet = true;
}

bool OAIResourceMetrics_Capacity::is_used_Set() const{
    return m_used_isSet;
}

bool OAIResourceMetrics_Capacity::is_used_Valid() const{
    return m_used_isValid;
}

qint32 OAIResourceMetrics_Capacity::getProvisioned() const {
    return m_provisioned;
}
void OAIResourceMetrics_Capacity::setProvisioned(const qint32 &provisioned) {
    m_provisioned = provisioned;
    m_provisioned_isSet = true;
}

bool OAIResourceMetrics_Capacity::is_provisioned_Set() const{
    return m_provisioned_isSet;
}

bool OAIResourceMetrics_Capacity::is_provisioned_Valid() const{
    return m_provisioned_isValid;
}

qint32 OAIResourceMetrics_Capacity::getLogicalUsed() const {
    return m_logical_used;
}
void OAIResourceMetrics_Capacity::setLogicalUsed(const qint32 &logical_used) {
    m_logical_used = logical_used;
    m_logical_used_isSet = true;
}

bool OAIResourceMetrics_Capacity::is_logical_used_Set() const{
    return m_logical_used_isSet;
}

bool OAIResourceMetrics_Capacity::is_logical_used_Valid() const{
    return m_logical_used_isValid;
}

qint32 OAIResourceMetrics_Capacity::getClusterCloudStorageUsed() const {
    return m_cluster_cloud_storage_used;
}
void OAIResourceMetrics_Capacity::setClusterCloudStorageUsed(const qint32 &cluster_cloud_storage_used) {
    m_cluster_cloud_storage_used = cluster_cloud_storage_used;
    m_cluster_cloud_storage_used_isSet = true;
}

bool OAIResourceMetrics_Capacity::is_cluster_cloud_storage_used_Set() const{
    return m_cluster_cloud_storage_used_isSet;
}

bool OAIResourceMetrics_Capacity::is_cluster_cloud_storage_used_Valid() const{
    return m_cluster_cloud_storage_used_isValid;
}

bool OAIResourceMetrics_Capacity::isSet() const {
    bool isObjectUpdated = false;
    do {
        if (m_used_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_provisioned_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_logical_used_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_cluster_cloud_storage_used_isSet) {
            isObjectUpdated = true;
            break;
        }
    } while (false);
    return isObjectUpdated;
}

bool OAIResourceMetrics_Capacity::isValid() const {
    // only required properties are required for the object to be considered valid
    return true;
}

} // namespace OpenAPI
