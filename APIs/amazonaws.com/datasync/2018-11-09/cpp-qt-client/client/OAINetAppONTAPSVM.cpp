/**
 * AWS DataSync
 * <fullname>DataSync</fullname> <p>DataSync is an online data movement and discovery service that simplifies data migration and helps you quickly, easily, and securely transfer your file or object data to, from, and between Amazon Web Services storage services.</p> <p>This API interface reference includes documentation for using DataSync programmatically. For complete information, see the <i> <a href=\"https://docs.aws.amazon.com/datasync/latest/userguide/what-is-datasync.html\">DataSync User Guide</a> </i>.</p>
 *
 * The version of the OpenAPI document: 2018-11-09
 * Contact: mike.ralphson@gmail.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

#include "OAINetAppONTAPSVM.h"

#include <QDebug>
#include <QJsonArray>
#include <QJsonDocument>
#include <QObject>

#include "OAIHelpers.h"

namespace OpenAPI {

OAINetAppONTAPSVM::OAINetAppONTAPSVM(QString json) {
    this->initializeModel();
    this->fromJson(json);
}

OAINetAppONTAPSVM::OAINetAppONTAPSVM() {
    this->initializeModel();
}

OAINetAppONTAPSVM::~OAINetAppONTAPSVM() {}

void OAINetAppONTAPSVM::initializeModel() {

    m_cluster_uuid_isSet = false;
    m_cluster_uuid_isValid = false;

    m_resource_id_isSet = false;
    m_resource_id_isValid = false;

    m_svm_name_isSet = false;
    m_svm_name_isValid = false;

    m_cifs_share_count_isSet = false;
    m_cifs_share_count_isValid = false;

    m_enabled_protocols_isSet = false;
    m_enabled_protocols_isValid = false;

    m_total_capacity_used_isSet = false;
    m_total_capacity_used_isValid = false;

    m_total_capacity_provisioned_isSet = false;
    m_total_capacity_provisioned_isValid = false;

    m_total_logical_capacity_used_isSet = false;
    m_total_logical_capacity_used_isValid = false;

    m_max_p95_performance_isSet = false;
    m_max_p95_performance_isValid = false;

    m_recommendations_isSet = false;
    m_recommendations_isValid = false;

    m_nfs_exported_volumes_isSet = false;
    m_nfs_exported_volumes_isValid = false;

    m_recommendation_status_isSet = false;
    m_recommendation_status_isValid = false;

    m_total_snapshot_capacity_used_isSet = false;
    m_total_snapshot_capacity_used_isValid = false;

    m_lun_count_isSet = false;
    m_lun_count_isValid = false;
}

void OAINetAppONTAPSVM::fromJson(QString jsonString) {
    QByteArray array(jsonString.toStdString().c_str());
    QJsonDocument doc = QJsonDocument::fromJson(array);
    QJsonObject jsonObject = doc.object();
    this->fromJsonObject(jsonObject);
}

void OAINetAppONTAPSVM::fromJsonObject(QJsonObject json) {

    m_cluster_uuid_isValid = ::OpenAPI::fromJsonValue(m_cluster_uuid, json[QString("ClusterUuid")]);
    m_cluster_uuid_isSet = !json[QString("ClusterUuid")].isNull() && m_cluster_uuid_isValid;

    m_resource_id_isValid = ::OpenAPI::fromJsonValue(m_resource_id, json[QString("ResourceId")]);
    m_resource_id_isSet = !json[QString("ResourceId")].isNull() && m_resource_id_isValid;

    m_svm_name_isValid = ::OpenAPI::fromJsonValue(m_svm_name, json[QString("SvmName")]);
    m_svm_name_isSet = !json[QString("SvmName")].isNull() && m_svm_name_isValid;

    m_cifs_share_count_isValid = ::OpenAPI::fromJsonValue(m_cifs_share_count, json[QString("CifsShareCount")]);
    m_cifs_share_count_isSet = !json[QString("CifsShareCount")].isNull() && m_cifs_share_count_isValid;

    m_enabled_protocols_isValid = ::OpenAPI::fromJsonValue(m_enabled_protocols, json[QString("EnabledProtocols")]);
    m_enabled_protocols_isSet = !json[QString("EnabledProtocols")].isNull() && m_enabled_protocols_isValid;

    m_total_capacity_used_isValid = ::OpenAPI::fromJsonValue(m_total_capacity_used, json[QString("TotalCapacityUsed")]);
    m_total_capacity_used_isSet = !json[QString("TotalCapacityUsed")].isNull() && m_total_capacity_used_isValid;

    m_total_capacity_provisioned_isValid = ::OpenAPI::fromJsonValue(m_total_capacity_provisioned, json[QString("TotalCapacityProvisioned")]);
    m_total_capacity_provisioned_isSet = !json[QString("TotalCapacityProvisioned")].isNull() && m_total_capacity_provisioned_isValid;

    m_total_logical_capacity_used_isValid = ::OpenAPI::fromJsonValue(m_total_logical_capacity_used, json[QString("TotalLogicalCapacityUsed")]);
    m_total_logical_capacity_used_isSet = !json[QString("TotalLogicalCapacityUsed")].isNull() && m_total_logical_capacity_used_isValid;

    m_max_p95_performance_isValid = ::OpenAPI::fromJsonValue(m_max_p95_performance, json[QString("MaxP95Performance")]);
    m_max_p95_performance_isSet = !json[QString("MaxP95Performance")].isNull() && m_max_p95_performance_isValid;

    m_recommendations_isValid = ::OpenAPI::fromJsonValue(m_recommendations, json[QString("Recommendations")]);
    m_recommendations_isSet = !json[QString("Recommendations")].isNull() && m_recommendations_isValid;

    m_nfs_exported_volumes_isValid = ::OpenAPI::fromJsonValue(m_nfs_exported_volumes, json[QString("NfsExportedVolumes")]);
    m_nfs_exported_volumes_isSet = !json[QString("NfsExportedVolumes")].isNull() && m_nfs_exported_volumes_isValid;

    m_recommendation_status_isValid = ::OpenAPI::fromJsonValue(m_recommendation_status, json[QString("RecommendationStatus")]);
    m_recommendation_status_isSet = !json[QString("RecommendationStatus")].isNull() && m_recommendation_status_isValid;

    m_total_snapshot_capacity_used_isValid = ::OpenAPI::fromJsonValue(m_total_snapshot_capacity_used, json[QString("TotalSnapshotCapacityUsed")]);
    m_total_snapshot_capacity_used_isSet = !json[QString("TotalSnapshotCapacityUsed")].isNull() && m_total_snapshot_capacity_used_isValid;

    m_lun_count_isValid = ::OpenAPI::fromJsonValue(m_lun_count, json[QString("LunCount")]);
    m_lun_count_isSet = !json[QString("LunCount")].isNull() && m_lun_count_isValid;
}

QString OAINetAppONTAPSVM::asJson() const {
    QJsonObject obj = this->asJsonObject();
    QJsonDocument doc(obj);
    QByteArray bytes = doc.toJson();
    return QString(bytes);
}

QJsonObject OAINetAppONTAPSVM::asJsonObject() const {
    QJsonObject obj;
    if (m_cluster_uuid_isSet) {
        obj.insert(QString("ClusterUuid"), ::OpenAPI::toJsonValue(m_cluster_uuid));
    }
    if (m_resource_id_isSet) {
        obj.insert(QString("ResourceId"), ::OpenAPI::toJsonValue(m_resource_id));
    }
    if (m_svm_name_isSet) {
        obj.insert(QString("SvmName"), ::OpenAPI::toJsonValue(m_svm_name));
    }
    if (m_cifs_share_count_isSet) {
        obj.insert(QString("CifsShareCount"), ::OpenAPI::toJsonValue(m_cifs_share_count));
    }
    if (m_enabled_protocols.isSet()) {
        obj.insert(QString("EnabledProtocols"), ::OpenAPI::toJsonValue(m_enabled_protocols));
    }
    if (m_total_capacity_used_isSet) {
        obj.insert(QString("TotalCapacityUsed"), ::OpenAPI::toJsonValue(m_total_capacity_used));
    }
    if (m_total_capacity_provisioned_isSet) {
        obj.insert(QString("TotalCapacityProvisioned"), ::OpenAPI::toJsonValue(m_total_capacity_provisioned));
    }
    if (m_total_logical_capacity_used_isSet) {
        obj.insert(QString("TotalLogicalCapacityUsed"), ::OpenAPI::toJsonValue(m_total_logical_capacity_used));
    }
    if (m_max_p95_performance.isSet()) {
        obj.insert(QString("MaxP95Performance"), ::OpenAPI::toJsonValue(m_max_p95_performance));
    }
    if (m_recommendations.isSet()) {
        obj.insert(QString("Recommendations"), ::OpenAPI::toJsonValue(m_recommendations));
    }
    if (m_nfs_exported_volumes_isSet) {
        obj.insert(QString("NfsExportedVolumes"), ::OpenAPI::toJsonValue(m_nfs_exported_volumes));
    }
    if (m_recommendation_status.isSet()) {
        obj.insert(QString("RecommendationStatus"), ::OpenAPI::toJsonValue(m_recommendation_status));
    }
    if (m_total_snapshot_capacity_used_isSet) {
        obj.insert(QString("TotalSnapshotCapacityUsed"), ::OpenAPI::toJsonValue(m_total_snapshot_capacity_used));
    }
    if (m_lun_count_isSet) {
        obj.insert(QString("LunCount"), ::OpenAPI::toJsonValue(m_lun_count));
    }
    return obj;
}

QString OAINetAppONTAPSVM::getClusterUuid() const {
    return m_cluster_uuid;
}
void OAINetAppONTAPSVM::setClusterUuid(const QString &cluster_uuid) {
    m_cluster_uuid = cluster_uuid;
    m_cluster_uuid_isSet = true;
}

bool OAINetAppONTAPSVM::is_cluster_uuid_Set() const{
    return m_cluster_uuid_isSet;
}

bool OAINetAppONTAPSVM::is_cluster_uuid_Valid() const{
    return m_cluster_uuid_isValid;
}

QString OAINetAppONTAPSVM::getResourceId() const {
    return m_resource_id;
}
void OAINetAppONTAPSVM::setResourceId(const QString &resource_id) {
    m_resource_id = resource_id;
    m_resource_id_isSet = true;
}

bool OAINetAppONTAPSVM::is_resource_id_Set() const{
    return m_resource_id_isSet;
}

bool OAINetAppONTAPSVM::is_resource_id_Valid() const{
    return m_resource_id_isValid;
}

QString OAINetAppONTAPSVM::getSvmName() const {
    return m_svm_name;
}
void OAINetAppONTAPSVM::setSvmName(const QString &svm_name) {
    m_svm_name = svm_name;
    m_svm_name_isSet = true;
}

bool OAINetAppONTAPSVM::is_svm_name_Set() const{
    return m_svm_name_isSet;
}

bool OAINetAppONTAPSVM::is_svm_name_Valid() const{
    return m_svm_name_isValid;
}

qint32 OAINetAppONTAPSVM::getCifsShareCount() const {
    return m_cifs_share_count;
}
void OAINetAppONTAPSVM::setCifsShareCount(const qint32 &cifs_share_count) {
    m_cifs_share_count = cifs_share_count;
    m_cifs_share_count_isSet = true;
}

bool OAINetAppONTAPSVM::is_cifs_share_count_Set() const{
    return m_cifs_share_count_isSet;
}

bool OAINetAppONTAPSVM::is_cifs_share_count_Valid() const{
    return m_cifs_share_count_isValid;
}

QList OAINetAppONTAPSVM::getEnabledProtocols() const {
    return m_enabled_protocols;
}
void OAINetAppONTAPSVM::setEnabledProtocols(const QList &enabled_protocols) {
    m_enabled_protocols = enabled_protocols;
    m_enabled_protocols_isSet = true;
}

bool OAINetAppONTAPSVM::is_enabled_protocols_Set() const{
    return m_enabled_protocols_isSet;
}

bool OAINetAppONTAPSVM::is_enabled_protocols_Valid() const{
    return m_enabled_protocols_isValid;
}

qint32 OAINetAppONTAPSVM::getTotalCapacityUsed() const {
    return m_total_capacity_used;
}
void OAINetAppONTAPSVM::setTotalCapacityUsed(const qint32 &total_capacity_used) {
    m_total_capacity_used = total_capacity_used;
    m_total_capacity_used_isSet = true;
}

bool OAINetAppONTAPSVM::is_total_capacity_used_Set() const{
    return m_total_capacity_used_isSet;
}

bool OAINetAppONTAPSVM::is_total_capacity_used_Valid() const{
    return m_total_capacity_used_isValid;
}

qint32 OAINetAppONTAPSVM::getTotalCapacityProvisioned() const {
    return m_total_capacity_provisioned;
}
void OAINetAppONTAPSVM::setTotalCapacityProvisioned(const qint32 &total_capacity_provisioned) {
    m_total_capacity_provisioned = total_capacity_provisioned;
    m_total_capacity_provisioned_isSet = true;
}

bool OAINetAppONTAPSVM::is_total_capacity_provisioned_Set() const{
    return m_total_capacity_provisioned_isSet;
}

bool OAINetAppONTAPSVM::is_total_capacity_provisioned_Valid() const{
    return m_total_capacity_provisioned_isValid;
}

qint32 OAINetAppONTAPSVM::getTotalLogicalCapacityUsed() const {
    return m_total_logical_capacity_used;
}
void OAINetAppONTAPSVM::setTotalLogicalCapacityUsed(const qint32 &total_logical_capacity_used) {
    m_total_logical_capacity_used = total_logical_capacity_used;
    m_total_logical_capacity_used_isSet = true;
}

bool OAINetAppONTAPSVM::is_total_logical_capacity_used_Set() const{
    return m_total_logical_capacity_used_isSet;
}

bool OAINetAppONTAPSVM::is_total_logical_capacity_used_Valid() const{
    return m_total_logical_capacity_used_isValid;
}

OAINetAppONTAPSVM_MaxP95Performance OAINetAppONTAPSVM::getMaxP95Performance() const {
    return m_max_p95_performance;
}
void OAINetAppONTAPSVM::setMaxP95Performance(const OAINetAppONTAPSVM_MaxP95Performance &max_p95_performance) {
    m_max_p95_performance = max_p95_performance;
    m_max_p95_performance_isSet = true;
}

bool OAINetAppONTAPSVM::is_max_p95_performance_Set() const{
    return m_max_p95_performance_isSet;
}

bool OAINetAppONTAPSVM::is_max_p95_performance_Valid() const{
    return m_max_p95_performance_isValid;
}

QList OAINetAppONTAPSVM::getRecommendations() const {
    return m_recommendations;
}
void OAINetAppONTAPSVM::setRecommendations(const QList &recommendations) {
    m_recommendations = recommendations;
    m_recommendations_isSet = true;
}

bool OAINetAppONTAPSVM::is_recommendations_Set() const{
    return m_recommendations_isSet;
}

bool OAINetAppONTAPSVM::is_recommendations_Valid() const{
    return m_recommendations_isValid;
}

qint32 OAINetAppONTAPSVM::getNfsExportedVolumes() const {
    return m_nfs_exported_volumes;
}
void OAINetAppONTAPSVM::setNfsExportedVolumes(const qint32 &nfs_exported_volumes) {
    m_nfs_exported_volumes = nfs_exported_volumes;
    m_nfs_exported_volumes_isSet = true;
}

bool OAINetAppONTAPSVM::is_nfs_exported_volumes_Set() const{
    return m_nfs_exported_volumes_isSet;
}

bool OAINetAppONTAPSVM::is_nfs_exported_volumes_Valid() const{
    return m_nfs_exported_volumes_isValid;
}

OAIRecommendationStatus OAINetAppONTAPSVM::getRecommendationStatus() const {
    return m_recommendation_status;
}
void OAINetAppONTAPSVM::setRecommendationStatus(const OAIRecommendationStatus &recommendation_status) {
    m_recommendation_status = recommendation_status;
    m_recommendation_status_isSet = true;
}

bool OAINetAppONTAPSVM::is_recommendation_status_Set() const{
    return m_recommendation_status_isSet;
}

bool OAINetAppONTAPSVM::is_recommendation_status_Valid() const{
    return m_recommendation_status_isValid;
}

qint32 OAINetAppONTAPSVM::getTotalSnapshotCapacityUsed() const {
    return m_total_snapshot_capacity_used;
}
void OAINetAppONTAPSVM::setTotalSnapshotCapacityUsed(const qint32 &total_snapshot_capacity_used) {
    m_total_snapshot_capacity_used = total_snapshot_capacity_used;
    m_total_snapshot_capacity_used_isSet = true;
}

bool OAINetAppONTAPSVM::is_total_snapshot_capacity_used_Set() const{
    return m_total_snapshot_capacity_used_isSet;
}

bool OAINetAppONTAPSVM::is_total_snapshot_capacity_used_Valid() const{
    return m_total_snapshot_capacity_used_isValid;
}

qint32 OAINetAppONTAPSVM::getLunCount() const {
    return m_lun_count;
}
void OAINetAppONTAPSVM::setLunCount(const qint32 &lun_count) {
    m_lun_count = lun_count;
    m_lun_count_isSet = true;
}

bool OAINetAppONTAPSVM::is_lun_count_Set() const{
    return m_lun_count_isSet;
}

bool OAINetAppONTAPSVM::is_lun_count_Valid() const{
    return m_lun_count_isValid;
}

bool OAINetAppONTAPSVM::isSet() const {
    bool isObjectUpdated = false;
    do {
        if (m_cluster_uuid_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_resource_id_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_svm_name_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_cifs_share_count_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_enabled_protocols.isSet()) {
            isObjectUpdated = true;
            break;
        }

        if (m_total_capacity_used_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_total_capacity_provisioned_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_total_logical_capacity_used_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_max_p95_performance.isSet()) {
            isObjectUpdated = true;
            break;
        }

        if (m_recommendations.isSet()) {
            isObjectUpdated = true;
            break;
        }

        if (m_nfs_exported_volumes_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_recommendation_status.isSet()) {
            isObjectUpdated = true;
            break;
        }

        if (m_total_snapshot_capacity_used_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_lun_count_isSet) {
            isObjectUpdated = true;
            break;
        }
    } while (false);
    return isObjectUpdated;
}

bool OAINetAppONTAPSVM::isValid() const {
    // only required properties are required for the object to be considered valid
    return true;
}

} // namespace OpenAPI
