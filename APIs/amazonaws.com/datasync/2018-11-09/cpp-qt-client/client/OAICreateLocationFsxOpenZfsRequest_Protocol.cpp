/**
 * AWS DataSync
 * <fullname>DataSync</fullname> <p>DataSync is an online data movement and discovery service that simplifies data migration and helps you quickly, easily, and securely transfer your file or object data to, from, and between Amazon Web Services storage services.</p> <p>This API interface reference includes documentation for using DataSync programmatically. For complete information, see the <i> <a href=\"https://docs.aws.amazon.com/datasync/latest/userguide/what-is-datasync.html\">DataSync User Guide</a> </i>.</p>
 *
 * The version of the OpenAPI document: 2018-11-09
 * Contact: mike.ralphson@gmail.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

#include "OAICreateLocationFsxOpenZfsRequest_Protocol.h"

#include <QDebug>
#include <QJsonArray>
#include <QJsonDocument>
#include <QObject>

#include "OAIHelpers.h"

namespace OpenAPI {

OAICreateLocationFsxOpenZfsRequest_Protocol::OAICreateLocationFsxOpenZfsRequest_Protocol(QString json) {
    this->initializeModel();
    this->fromJson(json);
}

OAICreateLocationFsxOpenZfsRequest_Protocol::OAICreateLocationFsxOpenZfsRequest_Protocol() {
    this->initializeModel();
}

OAICreateLocationFsxOpenZfsRequest_Protocol::~OAICreateLocationFsxOpenZfsRequest_Protocol() {}

void OAICreateLocationFsxOpenZfsRequest_Protocol::initializeModel() {

    m_nfs_isSet = false;
    m_nfs_isValid = false;

    m_smb_isSet = false;
    m_smb_isValid = false;
}

void OAICreateLocationFsxOpenZfsRequest_Protocol::fromJson(QString jsonString) {
    QByteArray array(jsonString.toStdString().c_str());
    QJsonDocument doc = QJsonDocument::fromJson(array);
    QJsonObject jsonObject = doc.object();
    this->fromJsonObject(jsonObject);
}

void OAICreateLocationFsxOpenZfsRequest_Protocol::fromJsonObject(QJsonObject json) {

    m_nfs_isValid = ::OpenAPI::fromJsonValue(m_nfs, json[QString("NFS")]);
    m_nfs_isSet = !json[QString("NFS")].isNull() && m_nfs_isValid;

    m_smb_isValid = ::OpenAPI::fromJsonValue(m_smb, json[QString("SMB")]);
    m_smb_isSet = !json[QString("SMB")].isNull() && m_smb_isValid;
}

QString OAICreateLocationFsxOpenZfsRequest_Protocol::asJson() const {
    QJsonObject obj = this->asJsonObject();
    QJsonDocument doc(obj);
    QByteArray bytes = doc.toJson();
    return QString(bytes);
}

QJsonObject OAICreateLocationFsxOpenZfsRequest_Protocol::asJsonObject() const {
    QJsonObject obj;
    if (m_nfs.isSet()) {
        obj.insert(QString("NFS"), ::OpenAPI::toJsonValue(m_nfs));
    }
    if (m_smb.isSet()) {
        obj.insert(QString("SMB"), ::OpenAPI::toJsonValue(m_smb));
    }
    return obj;
}

OAIFsxProtocol_NFS OAICreateLocationFsxOpenZfsRequest_Protocol::getNfs() const {
    return m_nfs;
}
void OAICreateLocationFsxOpenZfsRequest_Protocol::setNfs(const OAIFsxProtocol_NFS &nfs) {
    m_nfs = nfs;
    m_nfs_isSet = true;
}

bool OAICreateLocationFsxOpenZfsRequest_Protocol::is_nfs_Set() const{
    return m_nfs_isSet;
}

bool OAICreateLocationFsxOpenZfsRequest_Protocol::is_nfs_Valid() const{
    return m_nfs_isValid;
}

OAIFsxProtocol_SMB OAICreateLocationFsxOpenZfsRequest_Protocol::getSmb() const {
    return m_smb;
}
void OAICreateLocationFsxOpenZfsRequest_Protocol::setSmb(const OAIFsxProtocol_SMB &smb) {
    m_smb = smb;
    m_smb_isSet = true;
}

bool OAICreateLocationFsxOpenZfsRequest_Protocol::is_smb_Set() const{
    return m_smb_isSet;
}

bool OAICreateLocationFsxOpenZfsRequest_Protocol::is_smb_Valid() const{
    return m_smb_isValid;
}

bool OAICreateLocationFsxOpenZfsRequest_Protocol::isSet() const {
    bool isObjectUpdated = false;
    do {
        if (m_nfs.isSet()) {
            isObjectUpdated = true;
            break;
        }

        if (m_smb.isSet()) {
            isObjectUpdated = true;
            break;
        }
    } while (false);
    return isObjectUpdated;
}

bool OAICreateLocationFsxOpenZfsRequest_Protocol::isValid() const {
    // only required properties are required for the object to be considered valid
    return true;
}

} // namespace OpenAPI
