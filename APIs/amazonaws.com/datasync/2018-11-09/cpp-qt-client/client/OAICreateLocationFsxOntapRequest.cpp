/**
 * AWS DataSync
 * <fullname>DataSync</fullname> <p>DataSync is an online data movement and discovery service that simplifies data migration and helps you quickly, easily, and securely transfer your file or object data to, from, and between Amazon Web Services storage services.</p> <p>This API interface reference includes documentation for using DataSync programmatically. For complete information, see the <i> <a href=\"https://docs.aws.amazon.com/datasync/latest/userguide/what-is-datasync.html\">DataSync User Guide</a> </i>.</p>
 *
 * The version of the OpenAPI document: 2018-11-09
 * Contact: mike.ralphson@gmail.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

#include "OAICreateLocationFsxOntapRequest.h"

#include <QDebug>
#include <QJsonArray>
#include <QJsonDocument>
#include <QObject>

#include "OAIHelpers.h"

namespace OpenAPI {

OAICreateLocationFsxOntapRequest::OAICreateLocationFsxOntapRequest(QString json) {
    this->initializeModel();
    this->fromJson(json);
}

OAICreateLocationFsxOntapRequest::OAICreateLocationFsxOntapRequest() {
    this->initializeModel();
}

OAICreateLocationFsxOntapRequest::~OAICreateLocationFsxOntapRequest() {}

void OAICreateLocationFsxOntapRequest::initializeModel() {

    m_protocol_isSet = false;
    m_protocol_isValid = false;

    m_security_group_arns_isSet = false;
    m_security_group_arns_isValid = false;

    m_storage_virtual_machine_arn_isSet = false;
    m_storage_virtual_machine_arn_isValid = false;

    m_subdirectory_isSet = false;
    m_subdirectory_isValid = false;

    m_tags_isSet = false;
    m_tags_isValid = false;
}

void OAICreateLocationFsxOntapRequest::fromJson(QString jsonString) {
    QByteArray array(jsonString.toStdString().c_str());
    QJsonDocument doc = QJsonDocument::fromJson(array);
    QJsonObject jsonObject = doc.object();
    this->fromJsonObject(jsonObject);
}

void OAICreateLocationFsxOntapRequest::fromJsonObject(QJsonObject json) {

    m_protocol_isValid = ::OpenAPI::fromJsonValue(m_protocol, json[QString("Protocol")]);
    m_protocol_isSet = !json[QString("Protocol")].isNull() && m_protocol_isValid;

    m_security_group_arns_isValid = ::OpenAPI::fromJsonValue(m_security_group_arns, json[QString("SecurityGroupArns")]);
    m_security_group_arns_isSet = !json[QString("SecurityGroupArns")].isNull() && m_security_group_arns_isValid;

    m_storage_virtual_machine_arn_isValid = ::OpenAPI::fromJsonValue(m_storage_virtual_machine_arn, json[QString("StorageVirtualMachineArn")]);
    m_storage_virtual_machine_arn_isSet = !json[QString("StorageVirtualMachineArn")].isNull() && m_storage_virtual_machine_arn_isValid;

    m_subdirectory_isValid = ::OpenAPI::fromJsonValue(m_subdirectory, json[QString("Subdirectory")]);
    m_subdirectory_isSet = !json[QString("Subdirectory")].isNull() && m_subdirectory_isValid;

    m_tags_isValid = ::OpenAPI::fromJsonValue(m_tags, json[QString("Tags")]);
    m_tags_isSet = !json[QString("Tags")].isNull() && m_tags_isValid;
}

QString OAICreateLocationFsxOntapRequest::asJson() const {
    QJsonObject obj = this->asJsonObject();
    QJsonDocument doc(obj);
    QByteArray bytes = doc.toJson();
    return QString(bytes);
}

QJsonObject OAICreateLocationFsxOntapRequest::asJsonObject() const {
    QJsonObject obj;
    if (m_protocol.isSet()) {
        obj.insert(QString("Protocol"), ::OpenAPI::toJsonValue(m_protocol));
    }
    if (m_security_group_arns.isSet()) {
        obj.insert(QString("SecurityGroupArns"), ::OpenAPI::toJsonValue(m_security_group_arns));
    }
    if (m_storage_virtual_machine_arn_isSet) {
        obj.insert(QString("StorageVirtualMachineArn"), ::OpenAPI::toJsonValue(m_storage_virtual_machine_arn));
    }
    if (m_subdirectory_isSet) {
        obj.insert(QString("Subdirectory"), ::OpenAPI::toJsonValue(m_subdirectory));
    }
    if (m_tags.isSet()) {
        obj.insert(QString("Tags"), ::OpenAPI::toJsonValue(m_tags));
    }
    return obj;
}

OAIFsxProtocol OAICreateLocationFsxOntapRequest::getProtocol() const {
    return m_protocol;
}
void OAICreateLocationFsxOntapRequest::setProtocol(const OAIFsxProtocol &protocol) {
    m_protocol = protocol;
    m_protocol_isSet = true;
}

bool OAICreateLocationFsxOntapRequest::is_protocol_Set() const{
    return m_protocol_isSet;
}

bool OAICreateLocationFsxOntapRequest::is_protocol_Valid() const{
    return m_protocol_isValid;
}

QList OAICreateLocationFsxOntapRequest::getSecurityGroupArns() const {
    return m_security_group_arns;
}
void OAICreateLocationFsxOntapRequest::setSecurityGroupArns(const QList &security_group_arns) {
    m_security_group_arns = security_group_arns;
    m_security_group_arns_isSet = true;
}

bool OAICreateLocationFsxOntapRequest::is_security_group_arns_Set() const{
    return m_security_group_arns_isSet;
}

bool OAICreateLocationFsxOntapRequest::is_security_group_arns_Valid() const{
    return m_security_group_arns_isValid;
}

QString OAICreateLocationFsxOntapRequest::getStorageVirtualMachineArn() const {
    return m_storage_virtual_machine_arn;
}
void OAICreateLocationFsxOntapRequest::setStorageVirtualMachineArn(const QString &storage_virtual_machine_arn) {
    m_storage_virtual_machine_arn = storage_virtual_machine_arn;
    m_storage_virtual_machine_arn_isSet = true;
}

bool OAICreateLocationFsxOntapRequest::is_storage_virtual_machine_arn_Set() const{
    return m_storage_virtual_machine_arn_isSet;
}

bool OAICreateLocationFsxOntapRequest::is_storage_virtual_machine_arn_Valid() const{
    return m_storage_virtual_machine_arn_isValid;
}

QString OAICreateLocationFsxOntapRequest::getSubdirectory() const {
    return m_subdirectory;
}
void OAICreateLocationFsxOntapRequest::setSubdirectory(const QString &subdirectory) {
    m_subdirectory = subdirectory;
    m_subdirectory_isSet = true;
}

bool OAICreateLocationFsxOntapRequest::is_subdirectory_Set() const{
    return m_subdirectory_isSet;
}

bool OAICreateLocationFsxOntapRequest::is_subdirectory_Valid() const{
    return m_subdirectory_isValid;
}

QList OAICreateLocationFsxOntapRequest::getTags() const {
    return m_tags;
}
void OAICreateLocationFsxOntapRequest::setTags(const QList &tags) {
    m_tags = tags;
    m_tags_isSet = true;
}

bool OAICreateLocationFsxOntapRequest::is_tags_Set() const{
    return m_tags_isSet;
}

bool OAICreateLocationFsxOntapRequest::is_tags_Valid() const{
    return m_tags_isValid;
}

bool OAICreateLocationFsxOntapRequest::isSet() const {
    bool isObjectUpdated = false;
    do {
        if (m_protocol.isSet()) {
            isObjectUpdated = true;
            break;
        }

        if (m_security_group_arns.isSet()) {
            isObjectUpdated = true;
            break;
        }

        if (m_storage_virtual_machine_arn_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_subdirectory_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_tags.isSet()) {
            isObjectUpdated = true;
            break;
        }
    } while (false);
    return isObjectUpdated;
}

bool OAICreateLocationFsxOntapRequest::isValid() const {
    // only required properties are required for the object to be considered valid
    return m_protocol_isValid && m_security_group_arns_isValid && m_storage_virtual_machine_arn_isValid && true;
}

} // namespace OpenAPI
