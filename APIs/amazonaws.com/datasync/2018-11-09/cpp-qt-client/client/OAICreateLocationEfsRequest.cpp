/**
 * AWS DataSync
 * <fullname>DataSync</fullname> <p>DataSync is an online data movement and discovery service that simplifies data migration and helps you quickly, easily, and securely transfer your file or object data to, from, and between Amazon Web Services storage services.</p> <p>This API interface reference includes documentation for using DataSync programmatically. For complete information, see the <i> <a href=\"https://docs.aws.amazon.com/datasync/latest/userguide/what-is-datasync.html\">DataSync User Guide</a> </i>.</p>
 *
 * The version of the OpenAPI document: 2018-11-09
 * Contact: mike.ralphson@gmail.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

#include "OAICreateLocationEfsRequest.h"

#include <QDebug>
#include <QJsonArray>
#include <QJsonDocument>
#include <QObject>

#include "OAIHelpers.h"

namespace OpenAPI {

OAICreateLocationEfsRequest::OAICreateLocationEfsRequest(QString json) {
    this->initializeModel();
    this->fromJson(json);
}

OAICreateLocationEfsRequest::OAICreateLocationEfsRequest() {
    this->initializeModel();
}

OAICreateLocationEfsRequest::~OAICreateLocationEfsRequest() {}

void OAICreateLocationEfsRequest::initializeModel() {

    m_subdirectory_isSet = false;
    m_subdirectory_isValid = false;

    m_efs_filesystem_arn_isSet = false;
    m_efs_filesystem_arn_isValid = false;

    m_ec2_config_isSet = false;
    m_ec2_config_isValid = false;

    m_tags_isSet = false;
    m_tags_isValid = false;

    m_access_point_arn_isSet = false;
    m_access_point_arn_isValid = false;

    m_file_system_access_role_arn_isSet = false;
    m_file_system_access_role_arn_isValid = false;

    m_in_transit_encryption_isSet = false;
    m_in_transit_encryption_isValid = false;
}

void OAICreateLocationEfsRequest::fromJson(QString jsonString) {
    QByteArray array(jsonString.toStdString().c_str());
    QJsonDocument doc = QJsonDocument::fromJson(array);
    QJsonObject jsonObject = doc.object();
    this->fromJsonObject(jsonObject);
}

void OAICreateLocationEfsRequest::fromJsonObject(QJsonObject json) {

    m_subdirectory_isValid = ::OpenAPI::fromJsonValue(m_subdirectory, json[QString("Subdirectory")]);
    m_subdirectory_isSet = !json[QString("Subdirectory")].isNull() && m_subdirectory_isValid;

    m_efs_filesystem_arn_isValid = ::OpenAPI::fromJsonValue(m_efs_filesystem_arn, json[QString("EfsFilesystemArn")]);
    m_efs_filesystem_arn_isSet = !json[QString("EfsFilesystemArn")].isNull() && m_efs_filesystem_arn_isValid;

    m_ec2_config_isValid = ::OpenAPI::fromJsonValue(m_ec2_config, json[QString("Ec2Config")]);
    m_ec2_config_isSet = !json[QString("Ec2Config")].isNull() && m_ec2_config_isValid;

    m_tags_isValid = ::OpenAPI::fromJsonValue(m_tags, json[QString("Tags")]);
    m_tags_isSet = !json[QString("Tags")].isNull() && m_tags_isValid;

    m_access_point_arn_isValid = ::OpenAPI::fromJsonValue(m_access_point_arn, json[QString("AccessPointArn")]);
    m_access_point_arn_isSet = !json[QString("AccessPointArn")].isNull() && m_access_point_arn_isValid;

    m_file_system_access_role_arn_isValid = ::OpenAPI::fromJsonValue(m_file_system_access_role_arn, json[QString("FileSystemAccessRoleArn")]);
    m_file_system_access_role_arn_isSet = !json[QString("FileSystemAccessRoleArn")].isNull() && m_file_system_access_role_arn_isValid;

    m_in_transit_encryption_isValid = ::OpenAPI::fromJsonValue(m_in_transit_encryption, json[QString("InTransitEncryption")]);
    m_in_transit_encryption_isSet = !json[QString("InTransitEncryption")].isNull() && m_in_transit_encryption_isValid;
}

QString OAICreateLocationEfsRequest::asJson() const {
    QJsonObject obj = this->asJsonObject();
    QJsonDocument doc(obj);
    QByteArray bytes = doc.toJson();
    return QString(bytes);
}

QJsonObject OAICreateLocationEfsRequest::asJsonObject() const {
    QJsonObject obj;
    if (m_subdirectory_isSet) {
        obj.insert(QString("Subdirectory"), ::OpenAPI::toJsonValue(m_subdirectory));
    }
    if (m_efs_filesystem_arn_isSet) {
        obj.insert(QString("EfsFilesystemArn"), ::OpenAPI::toJsonValue(m_efs_filesystem_arn));
    }
    if (m_ec2_config.isSet()) {
        obj.insert(QString("Ec2Config"), ::OpenAPI::toJsonValue(m_ec2_config));
    }
    if (m_tags.isSet()) {
        obj.insert(QString("Tags"), ::OpenAPI::toJsonValue(m_tags));
    }
    if (m_access_point_arn_isSet) {
        obj.insert(QString("AccessPointArn"), ::OpenAPI::toJsonValue(m_access_point_arn));
    }
    if (m_file_system_access_role_arn_isSet) {
        obj.insert(QString("FileSystemAccessRoleArn"), ::OpenAPI::toJsonValue(m_file_system_access_role_arn));
    }
    if (m_in_transit_encryption.isSet()) {
        obj.insert(QString("InTransitEncryption"), ::OpenAPI::toJsonValue(m_in_transit_encryption));
    }
    return obj;
}

QString OAICreateLocationEfsRequest::getSubdirectory() const {
    return m_subdirectory;
}
void OAICreateLocationEfsRequest::setSubdirectory(const QString &subdirectory) {
    m_subdirectory = subdirectory;
    m_subdirectory_isSet = true;
}

bool OAICreateLocationEfsRequest::is_subdirectory_Set() const{
    return m_subdirectory_isSet;
}

bool OAICreateLocationEfsRequest::is_subdirectory_Valid() const{
    return m_subdirectory_isValid;
}

QString OAICreateLocationEfsRequest::getEfsFilesystemArn() const {
    return m_efs_filesystem_arn;
}
void OAICreateLocationEfsRequest::setEfsFilesystemArn(const QString &efs_filesystem_arn) {
    m_efs_filesystem_arn = efs_filesystem_arn;
    m_efs_filesystem_arn_isSet = true;
}

bool OAICreateLocationEfsRequest::is_efs_filesystem_arn_Set() const{
    return m_efs_filesystem_arn_isSet;
}

bool OAICreateLocationEfsRequest::is_efs_filesystem_arn_Valid() const{
    return m_efs_filesystem_arn_isValid;
}

OAICreateLocationEfsRequest_Ec2Config OAICreateLocationEfsRequest::getEc2Config() const {
    return m_ec2_config;
}
void OAICreateLocationEfsRequest::setEc2Config(const OAICreateLocationEfsRequest_Ec2Config &ec2_config) {
    m_ec2_config = ec2_config;
    m_ec2_config_isSet = true;
}

bool OAICreateLocationEfsRequest::is_ec2_config_Set() const{
    return m_ec2_config_isSet;
}

bool OAICreateLocationEfsRequest::is_ec2_config_Valid() const{
    return m_ec2_config_isValid;
}

QList OAICreateLocationEfsRequest::getTags() const {
    return m_tags;
}
void OAICreateLocationEfsRequest::setTags(const QList &tags) {
    m_tags = tags;
    m_tags_isSet = true;
}

bool OAICreateLocationEfsRequest::is_tags_Set() const{
    return m_tags_isSet;
}

bool OAICreateLocationEfsRequest::is_tags_Valid() const{
    return m_tags_isValid;
}

QString OAICreateLocationEfsRequest::getAccessPointArn() const {
    return m_access_point_arn;
}
void OAICreateLocationEfsRequest::setAccessPointArn(const QString &access_point_arn) {
    m_access_point_arn = access_point_arn;
    m_access_point_arn_isSet = true;
}

bool OAICreateLocationEfsRequest::is_access_point_arn_Set() const{
    return m_access_point_arn_isSet;
}

bool OAICreateLocationEfsRequest::is_access_point_arn_Valid() const{
    return m_access_point_arn_isValid;
}

QString OAICreateLocationEfsRequest::getFileSystemAccessRoleArn() const {
    return m_file_system_access_role_arn;
}
void OAICreateLocationEfsRequest::setFileSystemAccessRoleArn(const QString &file_system_access_role_arn) {
    m_file_system_access_role_arn = file_system_access_role_arn;
    m_file_system_access_role_arn_isSet = true;
}

bool OAICreateLocationEfsRequest::is_file_system_access_role_arn_Set() const{
    return m_file_system_access_role_arn_isSet;
}

bool OAICreateLocationEfsRequest::is_file_system_access_role_arn_Valid() const{
    return m_file_system_access_role_arn_isValid;
}

OAIEfsInTransitEncryption OAICreateLocationEfsRequest::getInTransitEncryption() const {
    return m_in_transit_encryption;
}
void OAICreateLocationEfsRequest::setInTransitEncryption(const OAIEfsInTransitEncryption &in_transit_encryption) {
    m_in_transit_encryption = in_transit_encryption;
    m_in_transit_encryption_isSet = true;
}

bool OAICreateLocationEfsRequest::is_in_transit_encryption_Set() const{
    return m_in_transit_encryption_isSet;
}

bool OAICreateLocationEfsRequest::is_in_transit_encryption_Valid() const{
    return m_in_transit_encryption_isValid;
}

bool OAICreateLocationEfsRequest::isSet() const {
    bool isObjectUpdated = false;
    do {
        if (m_subdirectory_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_efs_filesystem_arn_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_ec2_config.isSet()) {
            isObjectUpdated = true;
            break;
        }

        if (m_tags.isSet()) {
            isObjectUpdated = true;
            break;
        }

        if (m_access_point_arn_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_file_system_access_role_arn_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_in_transit_encryption.isSet()) {
            isObjectUpdated = true;
            break;
        }
    } while (false);
    return isObjectUpdated;
}

bool OAICreateLocationEfsRequest::isValid() const {
    // only required properties are required for the object to be considered valid
    return m_efs_filesystem_arn_isValid && m_ec2_config_isValid && true;
}

} // namespace OpenAPI
