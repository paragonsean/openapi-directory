/**
 * AWS DataSync
 * <fullname>DataSync</fullname> <p>DataSync is an online data movement and discovery service that simplifies data migration and helps you quickly, easily, and securely transfer your file or object data to, from, and between Amazon Web Services storage services.</p> <p>This API interface reference includes documentation for using DataSync programmatically. For complete information, see the <i> <a href=\"https://docs.aws.amazon.com/datasync/latest/userguide/what-is-datasync.html\">DataSync User Guide</a> </i>.</p>
 *
 * The version of the OpenAPI document: 2018-11-09
 * Contact: mike.ralphson@gmail.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

#include "OAINetAppONTAPVolume.h"

#include <QDebug>
#include <QJsonArray>
#include <QJsonDocument>
#include <QObject>

#include "OAIHelpers.h"

namespace OpenAPI {

OAINetAppONTAPVolume::OAINetAppONTAPVolume(QString json) {
    this->initializeModel();
    this->fromJson(json);
}

OAINetAppONTAPVolume::OAINetAppONTAPVolume() {
    this->initializeModel();
}

OAINetAppONTAPVolume::~OAINetAppONTAPVolume() {}

void OAINetAppONTAPVolume::initializeModel() {

    m_volume_name_isSet = false;
    m_volume_name_isValid = false;

    m_resource_id_isSet = false;
    m_resource_id_isValid = false;

    m_cifs_share_count_isSet = false;
    m_cifs_share_count_isValid = false;

    m_security_style_isSet = false;
    m_security_style_isValid = false;

    m_svm_uuid_isSet = false;
    m_svm_uuid_isValid = false;

    m_svm_name_isSet = false;
    m_svm_name_isValid = false;

    m_capacity_used_isSet = false;
    m_capacity_used_isValid = false;

    m_capacity_provisioned_isSet = false;
    m_capacity_provisioned_isValid = false;

    m_logical_capacity_used_isSet = false;
    m_logical_capacity_used_isValid = false;

    m_nfs_exported_isSet = false;
    m_nfs_exported_isValid = false;

    m_snapshot_capacity_used_isSet = false;
    m_snapshot_capacity_used_isValid = false;

    m_max_p95_performance_isSet = false;
    m_max_p95_performance_isValid = false;

    m_recommendations_isSet = false;
    m_recommendations_isValid = false;

    m_recommendation_status_isSet = false;
    m_recommendation_status_isValid = false;

    m_lun_count_isSet = false;
    m_lun_count_isValid = false;
}

void OAINetAppONTAPVolume::fromJson(QString jsonString) {
    QByteArray array(jsonString.toStdString().c_str());
    QJsonDocument doc = QJsonDocument::fromJson(array);
    QJsonObject jsonObject = doc.object();
    this->fromJsonObject(jsonObject);
}

void OAINetAppONTAPVolume::fromJsonObject(QJsonObject json) {

    m_volume_name_isValid = ::OpenAPI::fromJsonValue(m_volume_name, json[QString("VolumeName")]);
    m_volume_name_isSet = !json[QString("VolumeName")].isNull() && m_volume_name_isValid;

    m_resource_id_isValid = ::OpenAPI::fromJsonValue(m_resource_id, json[QString("ResourceId")]);
    m_resource_id_isSet = !json[QString("ResourceId")].isNull() && m_resource_id_isValid;

    m_cifs_share_count_isValid = ::OpenAPI::fromJsonValue(m_cifs_share_count, json[QString("CifsShareCount")]);
    m_cifs_share_count_isSet = !json[QString("CifsShareCount")].isNull() && m_cifs_share_count_isValid;

    m_security_style_isValid = ::OpenAPI::fromJsonValue(m_security_style, json[QString("SecurityStyle")]);
    m_security_style_isSet = !json[QString("SecurityStyle")].isNull() && m_security_style_isValid;

    m_svm_uuid_isValid = ::OpenAPI::fromJsonValue(m_svm_uuid, json[QString("SvmUuid")]);
    m_svm_uuid_isSet = !json[QString("SvmUuid")].isNull() && m_svm_uuid_isValid;

    m_svm_name_isValid = ::OpenAPI::fromJsonValue(m_svm_name, json[QString("SvmName")]);
    m_svm_name_isSet = !json[QString("SvmName")].isNull() && m_svm_name_isValid;

    m_capacity_used_isValid = ::OpenAPI::fromJsonValue(m_capacity_used, json[QString("CapacityUsed")]);
    m_capacity_used_isSet = !json[QString("CapacityUsed")].isNull() && m_capacity_used_isValid;

    m_capacity_provisioned_isValid = ::OpenAPI::fromJsonValue(m_capacity_provisioned, json[QString("CapacityProvisioned")]);
    m_capacity_provisioned_isSet = !json[QString("CapacityProvisioned")].isNull() && m_capacity_provisioned_isValid;

    m_logical_capacity_used_isValid = ::OpenAPI::fromJsonValue(m_logical_capacity_used, json[QString("LogicalCapacityUsed")]);
    m_logical_capacity_used_isSet = !json[QString("LogicalCapacityUsed")].isNull() && m_logical_capacity_used_isValid;

    m_nfs_exported_isValid = ::OpenAPI::fromJsonValue(m_nfs_exported, json[QString("NfsExported")]);
    m_nfs_exported_isSet = !json[QString("NfsExported")].isNull() && m_nfs_exported_isValid;

    m_snapshot_capacity_used_isValid = ::OpenAPI::fromJsonValue(m_snapshot_capacity_used, json[QString("SnapshotCapacityUsed")]);
    m_snapshot_capacity_used_isSet = !json[QString("SnapshotCapacityUsed")].isNull() && m_snapshot_capacity_used_isValid;

    m_max_p95_performance_isValid = ::OpenAPI::fromJsonValue(m_max_p95_performance, json[QString("MaxP95Performance")]);
    m_max_p95_performance_isSet = !json[QString("MaxP95Performance")].isNull() && m_max_p95_performance_isValid;

    m_recommendations_isValid = ::OpenAPI::fromJsonValue(m_recommendations, json[QString("Recommendations")]);
    m_recommendations_isSet = !json[QString("Recommendations")].isNull() && m_recommendations_isValid;

    m_recommendation_status_isValid = ::OpenAPI::fromJsonValue(m_recommendation_status, json[QString("RecommendationStatus")]);
    m_recommendation_status_isSet = !json[QString("RecommendationStatus")].isNull() && m_recommendation_status_isValid;

    m_lun_count_isValid = ::OpenAPI::fromJsonValue(m_lun_count, json[QString("LunCount")]);
    m_lun_count_isSet = !json[QString("LunCount")].isNull() && m_lun_count_isValid;
}

QString OAINetAppONTAPVolume::asJson() const {
    QJsonObject obj = this->asJsonObject();
    QJsonDocument doc(obj);
    QByteArray bytes = doc.toJson();
    return QString(bytes);
}

QJsonObject OAINetAppONTAPVolume::asJsonObject() const {
    QJsonObject obj;
    if (m_volume_name_isSet) {
        obj.insert(QString("VolumeName"), ::OpenAPI::toJsonValue(m_volume_name));
    }
    if (m_resource_id_isSet) {
        obj.insert(QString("ResourceId"), ::OpenAPI::toJsonValue(m_resource_id));
    }
    if (m_cifs_share_count_isSet) {
        obj.insert(QString("CifsShareCount"), ::OpenAPI::toJsonValue(m_cifs_share_count));
    }
    if (m_security_style_isSet) {
        obj.insert(QString("SecurityStyle"), ::OpenAPI::toJsonValue(m_security_style));
    }
    if (m_svm_uuid_isSet) {
        obj.insert(QString("SvmUuid"), ::OpenAPI::toJsonValue(m_svm_uuid));
    }
    if (m_svm_name_isSet) {
        obj.insert(QString("SvmName"), ::OpenAPI::toJsonValue(m_svm_name));
    }
    if (m_capacity_used_isSet) {
        obj.insert(QString("CapacityUsed"), ::OpenAPI::toJsonValue(m_capacity_used));
    }
    if (m_capacity_provisioned_isSet) {
        obj.insert(QString("CapacityProvisioned"), ::OpenAPI::toJsonValue(m_capacity_provisioned));
    }
    if (m_logical_capacity_used_isSet) {
        obj.insert(QString("LogicalCapacityUsed"), ::OpenAPI::toJsonValue(m_logical_capacity_used));
    }
    if (m_nfs_exported_isSet) {
        obj.insert(QString("NfsExported"), ::OpenAPI::toJsonValue(m_nfs_exported));
    }
    if (m_snapshot_capacity_used_isSet) {
        obj.insert(QString("SnapshotCapacityUsed"), ::OpenAPI::toJsonValue(m_snapshot_capacity_used));
    }
    if (m_max_p95_performance.isSet()) {
        obj.insert(QString("MaxP95Performance"), ::OpenAPI::toJsonValue(m_max_p95_performance));
    }
    if (m_recommendations.isSet()) {
        obj.insert(QString("Recommendations"), ::OpenAPI::toJsonValue(m_recommendations));
    }
    if (m_recommendation_status.isSet()) {
        obj.insert(QString("RecommendationStatus"), ::OpenAPI::toJsonValue(m_recommendation_status));
    }
    if (m_lun_count_isSet) {
        obj.insert(QString("LunCount"), ::OpenAPI::toJsonValue(m_lun_count));
    }
    return obj;
}

QString OAINetAppONTAPVolume::getVolumeName() const {
    return m_volume_name;
}
void OAINetAppONTAPVolume::setVolumeName(const QString &volume_name) {
    m_volume_name = volume_name;
    m_volume_name_isSet = true;
}

bool OAINetAppONTAPVolume::is_volume_name_Set() const{
    return m_volume_name_isSet;
}

bool OAINetAppONTAPVolume::is_volume_name_Valid() const{
    return m_volume_name_isValid;
}

QString OAINetAppONTAPVolume::getResourceId() const {
    return m_resource_id;
}
void OAINetAppONTAPVolume::setResourceId(const QString &resource_id) {
    m_resource_id = resource_id;
    m_resource_id_isSet = true;
}

bool OAINetAppONTAPVolume::is_resource_id_Set() const{
    return m_resource_id_isSet;
}

bool OAINetAppONTAPVolume::is_resource_id_Valid() const{
    return m_resource_id_isValid;
}

qint32 OAINetAppONTAPVolume::getCifsShareCount() const {
    return m_cifs_share_count;
}
void OAINetAppONTAPVolume::setCifsShareCount(const qint32 &cifs_share_count) {
    m_cifs_share_count = cifs_share_count;
    m_cifs_share_count_isSet = true;
}

bool OAINetAppONTAPVolume::is_cifs_share_count_Set() const{
    return m_cifs_share_count_isSet;
}

bool OAINetAppONTAPVolume::is_cifs_share_count_Valid() const{
    return m_cifs_share_count_isValid;
}

QString OAINetAppONTAPVolume::getSecurityStyle() const {
    return m_security_style;
}
void OAINetAppONTAPVolume::setSecurityStyle(const QString &security_style) {
    m_security_style = security_style;
    m_security_style_isSet = true;
}

bool OAINetAppONTAPVolume::is_security_style_Set() const{
    return m_security_style_isSet;
}

bool OAINetAppONTAPVolume::is_security_style_Valid() const{
    return m_security_style_isValid;
}

QString OAINetAppONTAPVolume::getSvmUuid() const {
    return m_svm_uuid;
}
void OAINetAppONTAPVolume::setSvmUuid(const QString &svm_uuid) {
    m_svm_uuid = svm_uuid;
    m_svm_uuid_isSet = true;
}

bool OAINetAppONTAPVolume::is_svm_uuid_Set() const{
    return m_svm_uuid_isSet;
}

bool OAINetAppONTAPVolume::is_svm_uuid_Valid() const{
    return m_svm_uuid_isValid;
}

QString OAINetAppONTAPVolume::getSvmName() const {
    return m_svm_name;
}
void OAINetAppONTAPVolume::setSvmName(const QString &svm_name) {
    m_svm_name = svm_name;
    m_svm_name_isSet = true;
}

bool OAINetAppONTAPVolume::is_svm_name_Set() const{
    return m_svm_name_isSet;
}

bool OAINetAppONTAPVolume::is_svm_name_Valid() const{
    return m_svm_name_isValid;
}

qint32 OAINetAppONTAPVolume::getCapacityUsed() const {
    return m_capacity_used;
}
void OAINetAppONTAPVolume::setCapacityUsed(const qint32 &capacity_used) {
    m_capacity_used = capacity_used;
    m_capacity_used_isSet = true;
}

bool OAINetAppONTAPVolume::is_capacity_used_Set() const{
    return m_capacity_used_isSet;
}

bool OAINetAppONTAPVolume::is_capacity_used_Valid() const{
    return m_capacity_used_isValid;
}

qint32 OAINetAppONTAPVolume::getCapacityProvisioned() const {
    return m_capacity_provisioned;
}
void OAINetAppONTAPVolume::setCapacityProvisioned(const qint32 &capacity_provisioned) {
    m_capacity_provisioned = capacity_provisioned;
    m_capacity_provisioned_isSet = true;
}

bool OAINetAppONTAPVolume::is_capacity_provisioned_Set() const{
    return m_capacity_provisioned_isSet;
}

bool OAINetAppONTAPVolume::is_capacity_provisioned_Valid() const{
    return m_capacity_provisioned_isValid;
}

qint32 OAINetAppONTAPVolume::getLogicalCapacityUsed() const {
    return m_logical_capacity_used;
}
void OAINetAppONTAPVolume::setLogicalCapacityUsed(const qint32 &logical_capacity_used) {
    m_logical_capacity_used = logical_capacity_used;
    m_logical_capacity_used_isSet = true;
}

bool OAINetAppONTAPVolume::is_logical_capacity_used_Set() const{
    return m_logical_capacity_used_isSet;
}

bool OAINetAppONTAPVolume::is_logical_capacity_used_Valid() const{
    return m_logical_capacity_used_isValid;
}

bool OAINetAppONTAPVolume::getNfsExported() const {
    return m_nfs_exported;
}
void OAINetAppONTAPVolume::setNfsExported(const bool &nfs_exported) {
    m_nfs_exported = nfs_exported;
    m_nfs_exported_isSet = true;
}

bool OAINetAppONTAPVolume::is_nfs_exported_Set() const{
    return m_nfs_exported_isSet;
}

bool OAINetAppONTAPVolume::is_nfs_exported_Valid() const{
    return m_nfs_exported_isValid;
}

qint32 OAINetAppONTAPVolume::getSnapshotCapacityUsed() const {
    return m_snapshot_capacity_used;
}
void OAINetAppONTAPVolume::setSnapshotCapacityUsed(const qint32 &snapshot_capacity_used) {
    m_snapshot_capacity_used = snapshot_capacity_used;
    m_snapshot_capacity_used_isSet = true;
}

bool OAINetAppONTAPVolume::is_snapshot_capacity_used_Set() const{
    return m_snapshot_capacity_used_isSet;
}

bool OAINetAppONTAPVolume::is_snapshot_capacity_used_Valid() const{
    return m_snapshot_capacity_used_isValid;
}

OAINetAppONTAPVolume_MaxP95Performance OAINetAppONTAPVolume::getMaxP95Performance() const {
    return m_max_p95_performance;
}
void OAINetAppONTAPVolume::setMaxP95Performance(const OAINetAppONTAPVolume_MaxP95Performance &max_p95_performance) {
    m_max_p95_performance = max_p95_performance;
    m_max_p95_performance_isSet = true;
}

bool OAINetAppONTAPVolume::is_max_p95_performance_Set() const{
    return m_max_p95_performance_isSet;
}

bool OAINetAppONTAPVolume::is_max_p95_performance_Valid() const{
    return m_max_p95_performance_isValid;
}

QList OAINetAppONTAPVolume::getRecommendations() const {
    return m_recommendations;
}
void OAINetAppONTAPVolume::setRecommendations(const QList &recommendations) {
    m_recommendations = recommendations;
    m_recommendations_isSet = true;
}

bool OAINetAppONTAPVolume::is_recommendations_Set() const{
    return m_recommendations_isSet;
}

bool OAINetAppONTAPVolume::is_recommendations_Valid() const{
    return m_recommendations_isValid;
}

OAIRecommendationStatus OAINetAppONTAPVolume::getRecommendationStatus() const {
    return m_recommendation_status;
}
void OAINetAppONTAPVolume::setRecommendationStatus(const OAIRecommendationStatus &recommendation_status) {
    m_recommendation_status = recommendation_status;
    m_recommendation_status_isSet = true;
}

bool OAINetAppONTAPVolume::is_recommendation_status_Set() const{
    return m_recommendation_status_isSet;
}

bool OAINetAppONTAPVolume::is_recommendation_status_Valid() const{
    return m_recommendation_status_isValid;
}

qint32 OAINetAppONTAPVolume::getLunCount() const {
    return m_lun_count;
}
void OAINetAppONTAPVolume::setLunCount(const qint32 &lun_count) {
    m_lun_count = lun_count;
    m_lun_count_isSet = true;
}

bool OAINetAppONTAPVolume::is_lun_count_Set() const{
    return m_lun_count_isSet;
}

bool OAINetAppONTAPVolume::is_lun_count_Valid() const{
    return m_lun_count_isValid;
}

bool OAINetAppONTAPVolume::isSet() const {
    bool isObjectUpdated = false;
    do {
        if (m_volume_name_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_resource_id_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_cifs_share_count_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_security_style_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_svm_uuid_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_svm_name_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_capacity_used_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_capacity_provisioned_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_logical_capacity_used_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_nfs_exported_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_snapshot_capacity_used_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_max_p95_performance.isSet()) {
            isObjectUpdated = true;
            break;
        }

        if (m_recommendations.isSet()) {
            isObjectUpdated = true;
            break;
        }

        if (m_recommendation_status.isSet()) {
            isObjectUpdated = true;
            break;
        }

        if (m_lun_count_isSet) {
            isObjectUpdated = true;
            break;
        }
    } while (false);
    return isObjectUpdated;
}

bool OAINetAppONTAPVolume::isValid() const {
    // only required properties are required for the object to be considered valid
    return true;
}

} // namespace OpenAPI
