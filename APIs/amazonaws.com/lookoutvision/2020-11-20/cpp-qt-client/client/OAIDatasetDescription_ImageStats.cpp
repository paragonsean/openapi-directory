/**
 * Amazon Lookout for Vision
 * <p>This is the Amazon Lookout for Vision API Reference. It provides descriptions of actions, data types, common parameters, and common errors.</p> <p>Amazon Lookout for Vision enables you to find visual defects in industrial products, accurately and at scale. It uses computer vision to identify missing components in an industrial product, damage to vehicles or structures, irregularities in production lines, and even minuscule defects in silicon wafers â€” or any other physical item where quality is important such as a missing capacitor on printed circuit boards.</p>
 *
 * The version of the OpenAPI document: 2020-11-20
 * Contact: mike.ralphson@gmail.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

#include "OAIDatasetDescription_ImageStats.h"

#include <QDebug>
#include <QJsonArray>
#include <QJsonDocument>
#include <QObject>

#include "OAIHelpers.h"

namespace OpenAPI {

OAIDatasetDescription_ImageStats::OAIDatasetDescription_ImageStats(QString json) {
    this->initializeModel();
    this->fromJson(json);
}

OAIDatasetDescription_ImageStats::OAIDatasetDescription_ImageStats() {
    this->initializeModel();
}

OAIDatasetDescription_ImageStats::~OAIDatasetDescription_ImageStats() {}

void OAIDatasetDescription_ImageStats::initializeModel() {

    m_total_isSet = false;
    m_total_isValid = false;

    m_labeled_isSet = false;
    m_labeled_isValid = false;

    m_normal_isSet = false;
    m_normal_isValid = false;

    m_anomaly_isSet = false;
    m_anomaly_isValid = false;
}

void OAIDatasetDescription_ImageStats::fromJson(QString jsonString) {
    QByteArray array(jsonString.toStdString().c_str());
    QJsonDocument doc = QJsonDocument::fromJson(array);
    QJsonObject jsonObject = doc.object();
    this->fromJsonObject(jsonObject);
}

void OAIDatasetDescription_ImageStats::fromJsonObject(QJsonObject json) {

    m_total_isValid = ::OpenAPI::fromJsonValue(m_total, json[QString("Total")]);
    m_total_isSet = !json[QString("Total")].isNull() && m_total_isValid;

    m_labeled_isValid = ::OpenAPI::fromJsonValue(m_labeled, json[QString("Labeled")]);
    m_labeled_isSet = !json[QString("Labeled")].isNull() && m_labeled_isValid;

    m_normal_isValid = ::OpenAPI::fromJsonValue(m_normal, json[QString("Normal")]);
    m_normal_isSet = !json[QString("Normal")].isNull() && m_normal_isValid;

    m_anomaly_isValid = ::OpenAPI::fromJsonValue(m_anomaly, json[QString("Anomaly")]);
    m_anomaly_isSet = !json[QString("Anomaly")].isNull() && m_anomaly_isValid;
}

QString OAIDatasetDescription_ImageStats::asJson() const {
    QJsonObject obj = this->asJsonObject();
    QJsonDocument doc(obj);
    QByteArray bytes = doc.toJson();
    return QString(bytes);
}

QJsonObject OAIDatasetDescription_ImageStats::asJsonObject() const {
    QJsonObject obj;
    if (m_total_isSet) {
        obj.insert(QString("Total"), ::OpenAPI::toJsonValue(m_total));
    }
    if (m_labeled_isSet) {
        obj.insert(QString("Labeled"), ::OpenAPI::toJsonValue(m_labeled));
    }
    if (m_normal_isSet) {
        obj.insert(QString("Normal"), ::OpenAPI::toJsonValue(m_normal));
    }
    if (m_anomaly_isSet) {
        obj.insert(QString("Anomaly"), ::OpenAPI::toJsonValue(m_anomaly));
    }
    return obj;
}

qint32 OAIDatasetDescription_ImageStats::getTotal() const {
    return m_total;
}
void OAIDatasetDescription_ImageStats::setTotal(const qint32 &total) {
    m_total = total;
    m_total_isSet = true;
}

bool OAIDatasetDescription_ImageStats::is_total_Set() const{
    return m_total_isSet;
}

bool OAIDatasetDescription_ImageStats::is_total_Valid() const{
    return m_total_isValid;
}

qint32 OAIDatasetDescription_ImageStats::getLabeled() const {
    return m_labeled;
}
void OAIDatasetDescription_ImageStats::setLabeled(const qint32 &labeled) {
    m_labeled = labeled;
    m_labeled_isSet = true;
}

bool OAIDatasetDescription_ImageStats::is_labeled_Set() const{
    return m_labeled_isSet;
}

bool OAIDatasetDescription_ImageStats::is_labeled_Valid() const{
    return m_labeled_isValid;
}

qint32 OAIDatasetDescription_ImageStats::getNormal() const {
    return m_normal;
}
void OAIDatasetDescription_ImageStats::setNormal(const qint32 &normal) {
    m_normal = normal;
    m_normal_isSet = true;
}

bool OAIDatasetDescription_ImageStats::is_normal_Set() const{
    return m_normal_isSet;
}

bool OAIDatasetDescription_ImageStats::is_normal_Valid() const{
    return m_normal_isValid;
}

qint32 OAIDatasetDescription_ImageStats::getAnomaly() const {
    return m_anomaly;
}
void OAIDatasetDescription_ImageStats::setAnomaly(const qint32 &anomaly) {
    m_anomaly = anomaly;
    m_anomaly_isSet = true;
}

bool OAIDatasetDescription_ImageStats::is_anomaly_Set() const{
    return m_anomaly_isSet;
}

bool OAIDatasetDescription_ImageStats::is_anomaly_Valid() const{
    return m_anomaly_isValid;
}

bool OAIDatasetDescription_ImageStats::isSet() const {
    bool isObjectUpdated = false;
    do {
        if (m_total_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_labeled_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_normal_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_anomaly_isSet) {
            isObjectUpdated = true;
            break;
        }
    } while (false);
    return isObjectUpdated;
}

bool OAIDatasetDescription_ImageStats::isValid() const {
    // only required properties are required for the object to be considered valid
    return true;
}

} // namespace OpenAPI
