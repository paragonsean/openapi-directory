/*
 * Amazon Lookout for Equipment
 * Amazon Lookout for Equipment is a machine learning service that uses advanced analytics to identify anomalies in machines from sensor data for use in predictive maintenance. 
 *
 * The version of the OpenAPI document: 2020-12-15
 * Contact: mike.ralphson@gmail.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package org.openapitools.client.model;

import java.util.Objects;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;
import java.time.OffsetDateTime;
import java.util.Arrays;
import org.openapitools.client.model.SensorStatisticsSummaryCategoricalValues;
import org.openapitools.client.model.SensorStatisticsSummaryDuplicateTimestamps;
import org.openapitools.client.model.SensorStatisticsSummaryInvalidDateEntries;
import org.openapitools.client.model.SensorStatisticsSummaryInvalidValues;
import org.openapitools.client.model.SensorStatisticsSummaryLargeTimestampGaps;
import org.openapitools.client.model.SensorStatisticsSummaryMissingValues;
import org.openapitools.client.model.SensorStatisticsSummaryMonotonicValues;
import org.openapitools.client.model.SensorStatisticsSummaryMultipleOperatingModes;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonArray;
import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;
import com.google.gson.TypeAdapterFactory;
import com.google.gson.reflect.TypeToken;
import com.google.gson.TypeAdapter;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;

import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import org.openapitools.client.JSON;

/**
 *  Summary of ingestion statistics like whether data exists, number of missing values, number of invalid values and so on related to the particular sensor. 
 */
@javax.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen", date = "2024-10-12T12:27:18.043707-04:00[America/New_York]", comments = "Generator version: 7.9.0")
public class SensorStatisticsSummary {
  public static final String SERIALIZED_NAME_COMPONENT_NAME = "ComponentName";
  @SerializedName(SERIALIZED_NAME_COMPONENT_NAME)
  private String componentName;

  public static final String SERIALIZED_NAME_SENSOR_NAME = "SensorName";
  @SerializedName(SERIALIZED_NAME_SENSOR_NAME)
  private String sensorName;

  public static final String SERIALIZED_NAME_DATA_EXISTS = "DataExists";
  @SerializedName(SERIALIZED_NAME_DATA_EXISTS)
  private Boolean dataExists;

  public static final String SERIALIZED_NAME_MISSING_VALUES = "MissingValues";
  @SerializedName(SERIALIZED_NAME_MISSING_VALUES)
  private SensorStatisticsSummaryMissingValues missingValues;

  public static final String SERIALIZED_NAME_INVALID_VALUES = "InvalidValues";
  @SerializedName(SERIALIZED_NAME_INVALID_VALUES)
  private SensorStatisticsSummaryInvalidValues invalidValues;

  public static final String SERIALIZED_NAME_INVALID_DATE_ENTRIES = "InvalidDateEntries";
  @SerializedName(SERIALIZED_NAME_INVALID_DATE_ENTRIES)
  private SensorStatisticsSummaryInvalidDateEntries invalidDateEntries;

  public static final String SERIALIZED_NAME_DUPLICATE_TIMESTAMPS = "DuplicateTimestamps";
  @SerializedName(SERIALIZED_NAME_DUPLICATE_TIMESTAMPS)
  private SensorStatisticsSummaryDuplicateTimestamps duplicateTimestamps;

  public static final String SERIALIZED_NAME_CATEGORICAL_VALUES = "CategoricalValues";
  @SerializedName(SERIALIZED_NAME_CATEGORICAL_VALUES)
  private SensorStatisticsSummaryCategoricalValues categoricalValues;

  public static final String SERIALIZED_NAME_MULTIPLE_OPERATING_MODES = "MultipleOperatingModes";
  @SerializedName(SERIALIZED_NAME_MULTIPLE_OPERATING_MODES)
  private SensorStatisticsSummaryMultipleOperatingModes multipleOperatingModes;

  public static final String SERIALIZED_NAME_LARGE_TIMESTAMP_GAPS = "LargeTimestampGaps";
  @SerializedName(SERIALIZED_NAME_LARGE_TIMESTAMP_GAPS)
  private SensorStatisticsSummaryLargeTimestampGaps largeTimestampGaps;

  public static final String SERIALIZED_NAME_MONOTONIC_VALUES = "MonotonicValues";
  @SerializedName(SERIALIZED_NAME_MONOTONIC_VALUES)
  private SensorStatisticsSummaryMonotonicValues monotonicValues;

  public static final String SERIALIZED_NAME_DATA_START_TIME = "DataStartTime";
  @SerializedName(SERIALIZED_NAME_DATA_START_TIME)
  private OffsetDateTime dataStartTime;

  public static final String SERIALIZED_NAME_DATA_END_TIME = "DataEndTime";
  @SerializedName(SERIALIZED_NAME_DATA_END_TIME)
  private OffsetDateTime dataEndTime;

  public SensorStatisticsSummary() {
  }

  public SensorStatisticsSummary componentName(String componentName) {
    this.componentName = componentName;
    return this;
  }

  /**
   * Get componentName
   * @return componentName
   */
  @javax.annotation.Nullable
  public String getComponentName() {
    return componentName;
  }

  public void setComponentName(String componentName) {
    this.componentName = componentName;
  }


  public SensorStatisticsSummary sensorName(String sensorName) {
    this.sensorName = sensorName;
    return this;
  }

  /**
   * Get sensorName
   * @return sensorName
   */
  @javax.annotation.Nullable
  public String getSensorName() {
    return sensorName;
  }

  public void setSensorName(String sensorName) {
    this.sensorName = sensorName;
  }


  public SensorStatisticsSummary dataExists(Boolean dataExists) {
    this.dataExists = dataExists;
    return this;
  }

  /**
   * Get dataExists
   * @return dataExists
   */
  @javax.annotation.Nullable
  public Boolean getDataExists() {
    return dataExists;
  }

  public void setDataExists(Boolean dataExists) {
    this.dataExists = dataExists;
  }


  public SensorStatisticsSummary missingValues(SensorStatisticsSummaryMissingValues missingValues) {
    this.missingValues = missingValues;
    return this;
  }

  /**
   * Get missingValues
   * @return missingValues
   */
  @javax.annotation.Nullable
  public SensorStatisticsSummaryMissingValues getMissingValues() {
    return missingValues;
  }

  public void setMissingValues(SensorStatisticsSummaryMissingValues missingValues) {
    this.missingValues = missingValues;
  }


  public SensorStatisticsSummary invalidValues(SensorStatisticsSummaryInvalidValues invalidValues) {
    this.invalidValues = invalidValues;
    return this;
  }

  /**
   * Get invalidValues
   * @return invalidValues
   */
  @javax.annotation.Nullable
  public SensorStatisticsSummaryInvalidValues getInvalidValues() {
    return invalidValues;
  }

  public void setInvalidValues(SensorStatisticsSummaryInvalidValues invalidValues) {
    this.invalidValues = invalidValues;
  }


  public SensorStatisticsSummary invalidDateEntries(SensorStatisticsSummaryInvalidDateEntries invalidDateEntries) {
    this.invalidDateEntries = invalidDateEntries;
    return this;
  }

  /**
   * Get invalidDateEntries
   * @return invalidDateEntries
   */
  @javax.annotation.Nullable
  public SensorStatisticsSummaryInvalidDateEntries getInvalidDateEntries() {
    return invalidDateEntries;
  }

  public void setInvalidDateEntries(SensorStatisticsSummaryInvalidDateEntries invalidDateEntries) {
    this.invalidDateEntries = invalidDateEntries;
  }


  public SensorStatisticsSummary duplicateTimestamps(SensorStatisticsSummaryDuplicateTimestamps duplicateTimestamps) {
    this.duplicateTimestamps = duplicateTimestamps;
    return this;
  }

  /**
   * Get duplicateTimestamps
   * @return duplicateTimestamps
   */
  @javax.annotation.Nullable
  public SensorStatisticsSummaryDuplicateTimestamps getDuplicateTimestamps() {
    return duplicateTimestamps;
  }

  public void setDuplicateTimestamps(SensorStatisticsSummaryDuplicateTimestamps duplicateTimestamps) {
    this.duplicateTimestamps = duplicateTimestamps;
  }


  public SensorStatisticsSummary categoricalValues(SensorStatisticsSummaryCategoricalValues categoricalValues) {
    this.categoricalValues = categoricalValues;
    return this;
  }

  /**
   * Get categoricalValues
   * @return categoricalValues
   */
  @javax.annotation.Nullable
  public SensorStatisticsSummaryCategoricalValues getCategoricalValues() {
    return categoricalValues;
  }

  public void setCategoricalValues(SensorStatisticsSummaryCategoricalValues categoricalValues) {
    this.categoricalValues = categoricalValues;
  }


  public SensorStatisticsSummary multipleOperatingModes(SensorStatisticsSummaryMultipleOperatingModes multipleOperatingModes) {
    this.multipleOperatingModes = multipleOperatingModes;
    return this;
  }

  /**
   * Get multipleOperatingModes
   * @return multipleOperatingModes
   */
  @javax.annotation.Nullable
  public SensorStatisticsSummaryMultipleOperatingModes getMultipleOperatingModes() {
    return multipleOperatingModes;
  }

  public void setMultipleOperatingModes(SensorStatisticsSummaryMultipleOperatingModes multipleOperatingModes) {
    this.multipleOperatingModes = multipleOperatingModes;
  }


  public SensorStatisticsSummary largeTimestampGaps(SensorStatisticsSummaryLargeTimestampGaps largeTimestampGaps) {
    this.largeTimestampGaps = largeTimestampGaps;
    return this;
  }

  /**
   * Get largeTimestampGaps
   * @return largeTimestampGaps
   */
  @javax.annotation.Nullable
  public SensorStatisticsSummaryLargeTimestampGaps getLargeTimestampGaps() {
    return largeTimestampGaps;
  }

  public void setLargeTimestampGaps(SensorStatisticsSummaryLargeTimestampGaps largeTimestampGaps) {
    this.largeTimestampGaps = largeTimestampGaps;
  }


  public SensorStatisticsSummary monotonicValues(SensorStatisticsSummaryMonotonicValues monotonicValues) {
    this.monotonicValues = monotonicValues;
    return this;
  }

  /**
   * Get monotonicValues
   * @return monotonicValues
   */
  @javax.annotation.Nullable
  public SensorStatisticsSummaryMonotonicValues getMonotonicValues() {
    return monotonicValues;
  }

  public void setMonotonicValues(SensorStatisticsSummaryMonotonicValues monotonicValues) {
    this.monotonicValues = monotonicValues;
  }


  public SensorStatisticsSummary dataStartTime(OffsetDateTime dataStartTime) {
    this.dataStartTime = dataStartTime;
    return this;
  }

  /**
   * Get dataStartTime
   * @return dataStartTime
   */
  @javax.annotation.Nullable
  public OffsetDateTime getDataStartTime() {
    return dataStartTime;
  }

  public void setDataStartTime(OffsetDateTime dataStartTime) {
    this.dataStartTime = dataStartTime;
  }


  public SensorStatisticsSummary dataEndTime(OffsetDateTime dataEndTime) {
    this.dataEndTime = dataEndTime;
    return this;
  }

  /**
   * Get dataEndTime
   * @return dataEndTime
   */
  @javax.annotation.Nullable
  public OffsetDateTime getDataEndTime() {
    return dataEndTime;
  }

  public void setDataEndTime(OffsetDateTime dataEndTime) {
    this.dataEndTime = dataEndTime;
  }



  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    SensorStatisticsSummary sensorStatisticsSummary = (SensorStatisticsSummary) o;
    return Objects.equals(this.componentName, sensorStatisticsSummary.componentName) &&
        Objects.equals(this.sensorName, sensorStatisticsSummary.sensorName) &&
        Objects.equals(this.dataExists, sensorStatisticsSummary.dataExists) &&
        Objects.equals(this.missingValues, sensorStatisticsSummary.missingValues) &&
        Objects.equals(this.invalidValues, sensorStatisticsSummary.invalidValues) &&
        Objects.equals(this.invalidDateEntries, sensorStatisticsSummary.invalidDateEntries) &&
        Objects.equals(this.duplicateTimestamps, sensorStatisticsSummary.duplicateTimestamps) &&
        Objects.equals(this.categoricalValues, sensorStatisticsSummary.categoricalValues) &&
        Objects.equals(this.multipleOperatingModes, sensorStatisticsSummary.multipleOperatingModes) &&
        Objects.equals(this.largeTimestampGaps, sensorStatisticsSummary.largeTimestampGaps) &&
        Objects.equals(this.monotonicValues, sensorStatisticsSummary.monotonicValues) &&
        Objects.equals(this.dataStartTime, sensorStatisticsSummary.dataStartTime) &&
        Objects.equals(this.dataEndTime, sensorStatisticsSummary.dataEndTime);
  }

  @Override
  public int hashCode() {
    return Objects.hash(componentName, sensorName, dataExists, missingValues, invalidValues, invalidDateEntries, duplicateTimestamps, categoricalValues, multipleOperatingModes, largeTimestampGaps, monotonicValues, dataStartTime, dataEndTime);
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class SensorStatisticsSummary {\n");
    sb.append("    componentName: ").append(toIndentedString(componentName)).append("\n");
    sb.append("    sensorName: ").append(toIndentedString(sensorName)).append("\n");
    sb.append("    dataExists: ").append(toIndentedString(dataExists)).append("\n");
    sb.append("    missingValues: ").append(toIndentedString(missingValues)).append("\n");
    sb.append("    invalidValues: ").append(toIndentedString(invalidValues)).append("\n");
    sb.append("    invalidDateEntries: ").append(toIndentedString(invalidDateEntries)).append("\n");
    sb.append("    duplicateTimestamps: ").append(toIndentedString(duplicateTimestamps)).append("\n");
    sb.append("    categoricalValues: ").append(toIndentedString(categoricalValues)).append("\n");
    sb.append("    multipleOperatingModes: ").append(toIndentedString(multipleOperatingModes)).append("\n");
    sb.append("    largeTimestampGaps: ").append(toIndentedString(largeTimestampGaps)).append("\n");
    sb.append("    monotonicValues: ").append(toIndentedString(monotonicValues)).append("\n");
    sb.append("    dataStartTime: ").append(toIndentedString(dataStartTime)).append("\n");
    sb.append("    dataEndTime: ").append(toIndentedString(dataEndTime)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }


  public static HashSet<String> openapiFields;
  public static HashSet<String> openapiRequiredFields;

  static {
    // a set of all properties/fields (JSON key names)
    openapiFields = new HashSet<String>();
    openapiFields.add("ComponentName");
    openapiFields.add("SensorName");
    openapiFields.add("DataExists");
    openapiFields.add("MissingValues");
    openapiFields.add("InvalidValues");
    openapiFields.add("InvalidDateEntries");
    openapiFields.add("DuplicateTimestamps");
    openapiFields.add("CategoricalValues");
    openapiFields.add("MultipleOperatingModes");
    openapiFields.add("LargeTimestampGaps");
    openapiFields.add("MonotonicValues");
    openapiFields.add("DataStartTime");
    openapiFields.add("DataEndTime");

    // a set of required properties/fields (JSON key names)
    openapiRequiredFields = new HashSet<String>();
  }

  /**
   * Validates the JSON Element and throws an exception if issues found
   *
   * @param jsonElement JSON Element
   * @throws IOException if the JSON Element is invalid with respect to SensorStatisticsSummary
   */
  public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      if (jsonElement == null) {
        if (!SensorStatisticsSummary.openapiRequiredFields.isEmpty()) { // has required fields but JSON element is null
          throw new IllegalArgumentException(String.format("The required field(s) %s in SensorStatisticsSummary is not found in the empty JSON string", SensorStatisticsSummary.openapiRequiredFields.toString()));
        }
      }

      Set<Map.Entry<String, JsonElement>> entries = jsonElement.getAsJsonObject().entrySet();
      // check to see if the JSON string contains additional fields
      for (Map.Entry<String, JsonElement> entry : entries) {
        if (!SensorStatisticsSummary.openapiFields.contains(entry.getKey())) {
          throw new IllegalArgumentException(String.format("The field `%s` in the JSON string is not defined in the `SensorStatisticsSummary` properties. JSON: %s", entry.getKey(), jsonElement.toString()));
        }
      }
        JsonObject jsonObj = jsonElement.getAsJsonObject();
      // validate the optional field `ComponentName`
      if (jsonObj.get("ComponentName") != null && !jsonObj.get("ComponentName").isJsonNull()) {
        String.validateJsonElement(jsonObj.get("ComponentName"));
      }
      // validate the optional field `SensorName`
      if (jsonObj.get("SensorName") != null && !jsonObj.get("SensorName").isJsonNull()) {
        String.validateJsonElement(jsonObj.get("SensorName"));
      }
      // validate the optional field `DataExists`
      if (jsonObj.get("DataExists") != null && !jsonObj.get("DataExists").isJsonNull()) {
        Boolean.validateJsonElement(jsonObj.get("DataExists"));
      }
      // validate the optional field `MissingValues`
      if (jsonObj.get("MissingValues") != null && !jsonObj.get("MissingValues").isJsonNull()) {
        SensorStatisticsSummaryMissingValues.validateJsonElement(jsonObj.get("MissingValues"));
      }
      // validate the optional field `InvalidValues`
      if (jsonObj.get("InvalidValues") != null && !jsonObj.get("InvalidValues").isJsonNull()) {
        SensorStatisticsSummaryInvalidValues.validateJsonElement(jsonObj.get("InvalidValues"));
      }
      // validate the optional field `InvalidDateEntries`
      if (jsonObj.get("InvalidDateEntries") != null && !jsonObj.get("InvalidDateEntries").isJsonNull()) {
        SensorStatisticsSummaryInvalidDateEntries.validateJsonElement(jsonObj.get("InvalidDateEntries"));
      }
      // validate the optional field `DuplicateTimestamps`
      if (jsonObj.get("DuplicateTimestamps") != null && !jsonObj.get("DuplicateTimestamps").isJsonNull()) {
        SensorStatisticsSummaryDuplicateTimestamps.validateJsonElement(jsonObj.get("DuplicateTimestamps"));
      }
      // validate the optional field `CategoricalValues`
      if (jsonObj.get("CategoricalValues") != null && !jsonObj.get("CategoricalValues").isJsonNull()) {
        SensorStatisticsSummaryCategoricalValues.validateJsonElement(jsonObj.get("CategoricalValues"));
      }
      // validate the optional field `MultipleOperatingModes`
      if (jsonObj.get("MultipleOperatingModes") != null && !jsonObj.get("MultipleOperatingModes").isJsonNull()) {
        SensorStatisticsSummaryMultipleOperatingModes.validateJsonElement(jsonObj.get("MultipleOperatingModes"));
      }
      // validate the optional field `LargeTimestampGaps`
      if (jsonObj.get("LargeTimestampGaps") != null && !jsonObj.get("LargeTimestampGaps").isJsonNull()) {
        SensorStatisticsSummaryLargeTimestampGaps.validateJsonElement(jsonObj.get("LargeTimestampGaps"));
      }
      // validate the optional field `MonotonicValues`
      if (jsonObj.get("MonotonicValues") != null && !jsonObj.get("MonotonicValues").isJsonNull()) {
        SensorStatisticsSummaryMonotonicValues.validateJsonElement(jsonObj.get("MonotonicValues"));
      }
      // validate the optional field `DataStartTime`
      if (jsonObj.get("DataStartTime") != null && !jsonObj.get("DataStartTime").isJsonNull()) {
        OffsetDateTime.validateJsonElement(jsonObj.get("DataStartTime"));
      }
      // validate the optional field `DataEndTime`
      if (jsonObj.get("DataEndTime") != null && !jsonObj.get("DataEndTime").isJsonNull()) {
        OffsetDateTime.validateJsonElement(jsonObj.get("DataEndTime"));
      }
  }

  public static class CustomTypeAdapterFactory implements TypeAdapterFactory {
    @SuppressWarnings("unchecked")
    @Override
    public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
       if (!SensorStatisticsSummary.class.isAssignableFrom(type.getRawType())) {
         return null; // this class only serializes 'SensorStatisticsSummary' and its subtypes
       }
       final TypeAdapter<JsonElement> elementAdapter = gson.getAdapter(JsonElement.class);
       final TypeAdapter<SensorStatisticsSummary> thisAdapter
                        = gson.getDelegateAdapter(this, TypeToken.get(SensorStatisticsSummary.class));

       return (TypeAdapter<T>) new TypeAdapter<SensorStatisticsSummary>() {
           @Override
           public void write(JsonWriter out, SensorStatisticsSummary value) throws IOException {
             JsonObject obj = thisAdapter.toJsonTree(value).getAsJsonObject();
             elementAdapter.write(out, obj);
           }

           @Override
           public SensorStatisticsSummary read(JsonReader in) throws IOException {
             JsonElement jsonElement = elementAdapter.read(in);
             validateJsonElement(jsonElement);
             return thisAdapter.fromJsonTree(jsonElement);
           }

       }.nullSafe();
    }
  }

  /**
   * Create an instance of SensorStatisticsSummary given an JSON string
   *
   * @param jsonString JSON string
   * @return An instance of SensorStatisticsSummary
   * @throws IOException if the JSON string is invalid with respect to SensorStatisticsSummary
   */
  public static SensorStatisticsSummary fromJson(String jsonString) throws IOException {
    return JSON.getGson().fromJson(jsonString, SensorStatisticsSummary.class);
  }

  /**
   * Convert an instance of SensorStatisticsSummary to an JSON string
   *
   * @return JSON string
   */
  public String toJson() {
    return JSON.getGson().toJson(this);
  }
}

