/**
 * Amazon VPC Lattice
 * Amazon VPC Lattice is a fully managed application networking service that you use to connect, secure, and monitor all of your services across multiple accounts and virtual private clouds (VPCs). Amazon VPC Lattice interconnects your microservices and legacy services within a logical boundary, so that you can discover and manage them more efficiently. For more information, see the <a href=\"https://docs.aws.amazon.com/vpc-lattice/latest/ug/\">Amazon VPC Lattice User Guide</a> 
 *
 * The version of the OpenAPI document: 2022-11-30
 * Contact: mike.ralphson@gmail.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

#include "OAICreateTargetGroupResponse_config.h"

#include <QDebug>
#include <QJsonArray>
#include <QJsonDocument>
#include <QObject>

#include "OAIHelpers.h"

namespace OpenAPI {

OAICreateTargetGroupResponse_config::OAICreateTargetGroupResponse_config(QString json) {
    this->initializeModel();
    this->fromJson(json);
}

OAICreateTargetGroupResponse_config::OAICreateTargetGroupResponse_config() {
    this->initializeModel();
}

OAICreateTargetGroupResponse_config::~OAICreateTargetGroupResponse_config() {}

void OAICreateTargetGroupResponse_config::initializeModel() {

    m_health_check_isSet = false;
    m_health_check_isValid = false;

    m_ip_address_type_isSet = false;
    m_ip_address_type_isValid = false;

    m_port_isSet = false;
    m_port_isValid = false;

    m_protocol_isSet = false;
    m_protocol_isValid = false;

    m_protocol_version_isSet = false;
    m_protocol_version_isValid = false;

    m_vpc_identifier_isSet = false;
    m_vpc_identifier_isValid = false;
}

void OAICreateTargetGroupResponse_config::fromJson(QString jsonString) {
    QByteArray array(jsonString.toStdString().c_str());
    QJsonDocument doc = QJsonDocument::fromJson(array);
    QJsonObject jsonObject = doc.object();
    this->fromJsonObject(jsonObject);
}

void OAICreateTargetGroupResponse_config::fromJsonObject(QJsonObject json) {

    m_health_check_isValid = ::OpenAPI::fromJsonValue(m_health_check, json[QString("healthCheck")]);
    m_health_check_isSet = !json[QString("healthCheck")].isNull() && m_health_check_isValid;

    m_ip_address_type_isValid = ::OpenAPI::fromJsonValue(m_ip_address_type, json[QString("ipAddressType")]);
    m_ip_address_type_isSet = !json[QString("ipAddressType")].isNull() && m_ip_address_type_isValid;

    m_port_isValid = ::OpenAPI::fromJsonValue(m_port, json[QString("port")]);
    m_port_isSet = !json[QString("port")].isNull() && m_port_isValid;

    m_protocol_isValid = ::OpenAPI::fromJsonValue(m_protocol, json[QString("protocol")]);
    m_protocol_isSet = !json[QString("protocol")].isNull() && m_protocol_isValid;

    m_protocol_version_isValid = ::OpenAPI::fromJsonValue(m_protocol_version, json[QString("protocolVersion")]);
    m_protocol_version_isSet = !json[QString("protocolVersion")].isNull() && m_protocol_version_isValid;

    m_vpc_identifier_isValid = ::OpenAPI::fromJsonValue(m_vpc_identifier, json[QString("vpcIdentifier")]);
    m_vpc_identifier_isSet = !json[QString("vpcIdentifier")].isNull() && m_vpc_identifier_isValid;
}

QString OAICreateTargetGroupResponse_config::asJson() const {
    QJsonObject obj = this->asJsonObject();
    QJsonDocument doc(obj);
    QByteArray bytes = doc.toJson();
    return QString(bytes);
}

QJsonObject OAICreateTargetGroupResponse_config::asJsonObject() const {
    QJsonObject obj;
    if (m_health_check.isSet()) {
        obj.insert(QString("healthCheck"), ::OpenAPI::toJsonValue(m_health_check));
    }
    if (m_ip_address_type.isSet()) {
        obj.insert(QString("ipAddressType"), ::OpenAPI::toJsonValue(m_ip_address_type));
    }
    if (m_port_isSet) {
        obj.insert(QString("port"), ::OpenAPI::toJsonValue(m_port));
    }
    if (m_protocol.isSet()) {
        obj.insert(QString("protocol"), ::OpenAPI::toJsonValue(m_protocol));
    }
    if (m_protocol_version.isSet()) {
        obj.insert(QString("protocolVersion"), ::OpenAPI::toJsonValue(m_protocol_version));
    }
    if (m_vpc_identifier_isSet) {
        obj.insert(QString("vpcIdentifier"), ::OpenAPI::toJsonValue(m_vpc_identifier));
    }
    return obj;
}

OAICreateTargetGroup_request_config_healthCheck OAICreateTargetGroupResponse_config::getHealthCheck() const {
    return m_health_check;
}
void OAICreateTargetGroupResponse_config::setHealthCheck(const OAICreateTargetGroup_request_config_healthCheck &health_check) {
    m_health_check = health_check;
    m_health_check_isSet = true;
}

bool OAICreateTargetGroupResponse_config::is_health_check_Set() const{
    return m_health_check_isSet;
}

bool OAICreateTargetGroupResponse_config::is_health_check_Valid() const{
    return m_health_check_isValid;
}

OAIIpAddressType OAICreateTargetGroupResponse_config::getIpAddressType() const {
    return m_ip_address_type;
}
void OAICreateTargetGroupResponse_config::setIpAddressType(const OAIIpAddressType &ip_address_type) {
    m_ip_address_type = ip_address_type;
    m_ip_address_type_isSet = true;
}

bool OAICreateTargetGroupResponse_config::is_ip_address_type_Set() const{
    return m_ip_address_type_isSet;
}

bool OAICreateTargetGroupResponse_config::is_ip_address_type_Valid() const{
    return m_ip_address_type_isValid;
}

qint32 OAICreateTargetGroupResponse_config::getPort() const {
    return m_port;
}
void OAICreateTargetGroupResponse_config::setPort(const qint32 &port) {
    m_port = port;
    m_port_isSet = true;
}

bool OAICreateTargetGroupResponse_config::is_port_Set() const{
    return m_port_isSet;
}

bool OAICreateTargetGroupResponse_config::is_port_Valid() const{
    return m_port_isValid;
}

OAITargetGroupProtocol OAICreateTargetGroupResponse_config::getProtocol() const {
    return m_protocol;
}
void OAICreateTargetGroupResponse_config::setProtocol(const OAITargetGroupProtocol &protocol) {
    m_protocol = protocol;
    m_protocol_isSet = true;
}

bool OAICreateTargetGroupResponse_config::is_protocol_Set() const{
    return m_protocol_isSet;
}

bool OAICreateTargetGroupResponse_config::is_protocol_Valid() const{
    return m_protocol_isValid;
}

OAITargetGroupProtocolVersion OAICreateTargetGroupResponse_config::getProtocolVersion() const {
    return m_protocol_version;
}
void OAICreateTargetGroupResponse_config::setProtocolVersion(const OAITargetGroupProtocolVersion &protocol_version) {
    m_protocol_version = protocol_version;
    m_protocol_version_isSet = true;
}

bool OAICreateTargetGroupResponse_config::is_protocol_version_Set() const{
    return m_protocol_version_isSet;
}

bool OAICreateTargetGroupResponse_config::is_protocol_version_Valid() const{
    return m_protocol_version_isValid;
}

QString OAICreateTargetGroupResponse_config::getVpcIdentifier() const {
    return m_vpc_identifier;
}
void OAICreateTargetGroupResponse_config::setVpcIdentifier(const QString &vpc_identifier) {
    m_vpc_identifier = vpc_identifier;
    m_vpc_identifier_isSet = true;
}

bool OAICreateTargetGroupResponse_config::is_vpc_identifier_Set() const{
    return m_vpc_identifier_isSet;
}

bool OAICreateTargetGroupResponse_config::is_vpc_identifier_Valid() const{
    return m_vpc_identifier_isValid;
}

bool OAICreateTargetGroupResponse_config::isSet() const {
    bool isObjectUpdated = false;
    do {
        if (m_health_check.isSet()) {
            isObjectUpdated = true;
            break;
        }

        if (m_ip_address_type.isSet()) {
            isObjectUpdated = true;
            break;
        }

        if (m_port_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_protocol.isSet()) {
            isObjectUpdated = true;
            break;
        }

        if (m_protocol_version.isSet()) {
            isObjectUpdated = true;
            break;
        }

        if (m_vpc_identifier_isSet) {
            isObjectUpdated = true;
            break;
        }
    } while (false);
    return isObjectUpdated;
}

bool OAICreateTargetGroupResponse_config::isValid() const {
    // only required properties are required for the object to be considered valid
    return m_port_isValid && m_protocol_isValid && m_vpc_identifier_isValid && true;
}

} // namespace OpenAPI
