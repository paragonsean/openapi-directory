/**
 * Amazon VPC Lattice
 * Amazon VPC Lattice is a fully managed application networking service that you use to connect, secure, and monitor all of your services across multiple accounts and virtual private clouds (VPCs). Amazon VPC Lattice interconnects your microservices and legacy services within a logical boundary, so that you can discover and manage them more efficiently. For more information, see the <a href=\"https://docs.aws.amazon.com/vpc-lattice/latest/ug/\">Amazon VPC Lattice User Guide</a> 
 *
 * The version of the OpenAPI document: 2022-11-30
 * Contact: mike.ralphson@gmail.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

#include "OAICreateRule_request_match_httpMatch.h"

#include <QDebug>
#include <QJsonArray>
#include <QJsonDocument>
#include <QObject>

#include "OAIHelpers.h"

namespace OpenAPI {

OAICreateRule_request_match_httpMatch::OAICreateRule_request_match_httpMatch(QString json) {
    this->initializeModel();
    this->fromJson(json);
}

OAICreateRule_request_match_httpMatch::OAICreateRule_request_match_httpMatch() {
    this->initializeModel();
}

OAICreateRule_request_match_httpMatch::~OAICreateRule_request_match_httpMatch() {}

void OAICreateRule_request_match_httpMatch::initializeModel() {

    m_header_matches_isSet = false;
    m_header_matches_isValid = false;

    m_method_isSet = false;
    m_method_isValid = false;

    m_path_match_isSet = false;
    m_path_match_isValid = false;
}

void OAICreateRule_request_match_httpMatch::fromJson(QString jsonString) {
    QByteArray array(jsonString.toStdString().c_str());
    QJsonDocument doc = QJsonDocument::fromJson(array);
    QJsonObject jsonObject = doc.object();
    this->fromJsonObject(jsonObject);
}

void OAICreateRule_request_match_httpMatch::fromJsonObject(QJsonObject json) {

    m_header_matches_isValid = ::OpenAPI::fromJsonValue(m_header_matches, json[QString("headerMatches")]);
    m_header_matches_isSet = !json[QString("headerMatches")].isNull() && m_header_matches_isValid;

    m_method_isValid = ::OpenAPI::fromJsonValue(m_method, json[QString("method")]);
    m_method_isSet = !json[QString("method")].isNull() && m_method_isValid;

    m_path_match_isValid = ::OpenAPI::fromJsonValue(m_path_match, json[QString("pathMatch")]);
    m_path_match_isSet = !json[QString("pathMatch")].isNull() && m_path_match_isValid;
}

QString OAICreateRule_request_match_httpMatch::asJson() const {
    QJsonObject obj = this->asJsonObject();
    QJsonDocument doc(obj);
    QByteArray bytes = doc.toJson();
    return QString(bytes);
}

QJsonObject OAICreateRule_request_match_httpMatch::asJsonObject() const {
    QJsonObject obj;
    if (m_header_matches.isSet()) {
        obj.insert(QString("headerMatches"), ::OpenAPI::toJsonValue(m_header_matches));
    }
    if (m_method_isSet) {
        obj.insert(QString("method"), ::OpenAPI::toJsonValue(m_method));
    }
    if (m_path_match.isSet()) {
        obj.insert(QString("pathMatch"), ::OpenAPI::toJsonValue(m_path_match));
    }
    return obj;
}

QList OAICreateRule_request_match_httpMatch::getHeaderMatches() const {
    return m_header_matches;
}
void OAICreateRule_request_match_httpMatch::setHeaderMatches(const QList &header_matches) {
    m_header_matches = header_matches;
    m_header_matches_isSet = true;
}

bool OAICreateRule_request_match_httpMatch::is_header_matches_Set() const{
    return m_header_matches_isSet;
}

bool OAICreateRule_request_match_httpMatch::is_header_matches_Valid() const{
    return m_header_matches_isValid;
}

QString OAICreateRule_request_match_httpMatch::getMethod() const {
    return m_method;
}
void OAICreateRule_request_match_httpMatch::setMethod(const QString &method) {
    m_method = method;
    m_method_isSet = true;
}

bool OAICreateRule_request_match_httpMatch::is_method_Set() const{
    return m_method_isSet;
}

bool OAICreateRule_request_match_httpMatch::is_method_Valid() const{
    return m_method_isValid;
}

OAIHttpMatch_pathMatch OAICreateRule_request_match_httpMatch::getPathMatch() const {
    return m_path_match;
}
void OAICreateRule_request_match_httpMatch::setPathMatch(const OAIHttpMatch_pathMatch &path_match) {
    m_path_match = path_match;
    m_path_match_isSet = true;
}

bool OAICreateRule_request_match_httpMatch::is_path_match_Set() const{
    return m_path_match_isSet;
}

bool OAICreateRule_request_match_httpMatch::is_path_match_Valid() const{
    return m_path_match_isValid;
}

bool OAICreateRule_request_match_httpMatch::isSet() const {
    bool isObjectUpdated = false;
    do {
        if (m_header_matches.isSet()) {
            isObjectUpdated = true;
            break;
        }

        if (m_method_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_path_match.isSet()) {
            isObjectUpdated = true;
            break;
        }
    } while (false);
    return isObjectUpdated;
}

bool OAICreateRule_request_match_httpMatch::isValid() const {
    // only required properties are required for the object to be considered valid
    return true;
}

} // namespace OpenAPI
