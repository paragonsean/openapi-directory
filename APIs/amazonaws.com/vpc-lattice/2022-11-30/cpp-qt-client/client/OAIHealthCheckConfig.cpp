/**
 * Amazon VPC Lattice
 * Amazon VPC Lattice is a fully managed application networking service that you use to connect, secure, and monitor all of your services across multiple accounts and virtual private clouds (VPCs). Amazon VPC Lattice interconnects your microservices and legacy services within a logical boundary, so that you can discover and manage them more efficiently. For more information, see the <a href=\"https://docs.aws.amazon.com/vpc-lattice/latest/ug/\">Amazon VPC Lattice User Guide</a> 
 *
 * The version of the OpenAPI document: 2022-11-30
 * Contact: mike.ralphson@gmail.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

#include "OAIHealthCheckConfig.h"

#include <QDebug>
#include <QJsonArray>
#include <QJsonDocument>
#include <QObject>

#include "OAIHelpers.h"

namespace OpenAPI {

OAIHealthCheckConfig::OAIHealthCheckConfig(QString json) {
    this->initializeModel();
    this->fromJson(json);
}

OAIHealthCheckConfig::OAIHealthCheckConfig() {
    this->initializeModel();
}

OAIHealthCheckConfig::~OAIHealthCheckConfig() {}

void OAIHealthCheckConfig::initializeModel() {

    m_enabled_isSet = false;
    m_enabled_isValid = false;

    m_health_check_interval_seconds_isSet = false;
    m_health_check_interval_seconds_isValid = false;

    m_health_check_timeout_seconds_isSet = false;
    m_health_check_timeout_seconds_isValid = false;

    m_healthy_threshold_count_isSet = false;
    m_healthy_threshold_count_isValid = false;

    m_matcher_isSet = false;
    m_matcher_isValid = false;

    m_path_isSet = false;
    m_path_isValid = false;

    m_port_isSet = false;
    m_port_isValid = false;

    m_protocol_isSet = false;
    m_protocol_isValid = false;

    m_protocol_version_isSet = false;
    m_protocol_version_isValid = false;

    m_unhealthy_threshold_count_isSet = false;
    m_unhealthy_threshold_count_isValid = false;
}

void OAIHealthCheckConfig::fromJson(QString jsonString) {
    QByteArray array(jsonString.toStdString().c_str());
    QJsonDocument doc = QJsonDocument::fromJson(array);
    QJsonObject jsonObject = doc.object();
    this->fromJsonObject(jsonObject);
}

void OAIHealthCheckConfig::fromJsonObject(QJsonObject json) {

    m_enabled_isValid = ::OpenAPI::fromJsonValue(m_enabled, json[QString("enabled")]);
    m_enabled_isSet = !json[QString("enabled")].isNull() && m_enabled_isValid;

    m_health_check_interval_seconds_isValid = ::OpenAPI::fromJsonValue(m_health_check_interval_seconds, json[QString("healthCheckIntervalSeconds")]);
    m_health_check_interval_seconds_isSet = !json[QString("healthCheckIntervalSeconds")].isNull() && m_health_check_interval_seconds_isValid;

    m_health_check_timeout_seconds_isValid = ::OpenAPI::fromJsonValue(m_health_check_timeout_seconds, json[QString("healthCheckTimeoutSeconds")]);
    m_health_check_timeout_seconds_isSet = !json[QString("healthCheckTimeoutSeconds")].isNull() && m_health_check_timeout_seconds_isValid;

    m_healthy_threshold_count_isValid = ::OpenAPI::fromJsonValue(m_healthy_threshold_count, json[QString("healthyThresholdCount")]);
    m_healthy_threshold_count_isSet = !json[QString("healthyThresholdCount")].isNull() && m_healthy_threshold_count_isValid;

    m_matcher_isValid = ::OpenAPI::fromJsonValue(m_matcher, json[QString("matcher")]);
    m_matcher_isSet = !json[QString("matcher")].isNull() && m_matcher_isValid;

    m_path_isValid = ::OpenAPI::fromJsonValue(m_path, json[QString("path")]);
    m_path_isSet = !json[QString("path")].isNull() && m_path_isValid;

    m_port_isValid = ::OpenAPI::fromJsonValue(m_port, json[QString("port")]);
    m_port_isSet = !json[QString("port")].isNull() && m_port_isValid;

    m_protocol_isValid = ::OpenAPI::fromJsonValue(m_protocol, json[QString("protocol")]);
    m_protocol_isSet = !json[QString("protocol")].isNull() && m_protocol_isValid;

    m_protocol_version_isValid = ::OpenAPI::fromJsonValue(m_protocol_version, json[QString("protocolVersion")]);
    m_protocol_version_isSet = !json[QString("protocolVersion")].isNull() && m_protocol_version_isValid;

    m_unhealthy_threshold_count_isValid = ::OpenAPI::fromJsonValue(m_unhealthy_threshold_count, json[QString("unhealthyThresholdCount")]);
    m_unhealthy_threshold_count_isSet = !json[QString("unhealthyThresholdCount")].isNull() && m_unhealthy_threshold_count_isValid;
}

QString OAIHealthCheckConfig::asJson() const {
    QJsonObject obj = this->asJsonObject();
    QJsonDocument doc(obj);
    QByteArray bytes = doc.toJson();
    return QString(bytes);
}

QJsonObject OAIHealthCheckConfig::asJsonObject() const {
    QJsonObject obj;
    if (m_enabled_isSet) {
        obj.insert(QString("enabled"), ::OpenAPI::toJsonValue(m_enabled));
    }
    if (m_health_check_interval_seconds_isSet) {
        obj.insert(QString("healthCheckIntervalSeconds"), ::OpenAPI::toJsonValue(m_health_check_interval_seconds));
    }
    if (m_health_check_timeout_seconds_isSet) {
        obj.insert(QString("healthCheckTimeoutSeconds"), ::OpenAPI::toJsonValue(m_health_check_timeout_seconds));
    }
    if (m_healthy_threshold_count_isSet) {
        obj.insert(QString("healthyThresholdCount"), ::OpenAPI::toJsonValue(m_healthy_threshold_count));
    }
    if (m_matcher.isSet()) {
        obj.insert(QString("matcher"), ::OpenAPI::toJsonValue(m_matcher));
    }
    if (m_path_isSet) {
        obj.insert(QString("path"), ::OpenAPI::toJsonValue(m_path));
    }
    if (m_port_isSet) {
        obj.insert(QString("port"), ::OpenAPI::toJsonValue(m_port));
    }
    if (m_protocol.isSet()) {
        obj.insert(QString("protocol"), ::OpenAPI::toJsonValue(m_protocol));
    }
    if (m_protocol_version.isSet()) {
        obj.insert(QString("protocolVersion"), ::OpenAPI::toJsonValue(m_protocol_version));
    }
    if (m_unhealthy_threshold_count_isSet) {
        obj.insert(QString("unhealthyThresholdCount"), ::OpenAPI::toJsonValue(m_unhealthy_threshold_count));
    }
    return obj;
}

bool OAIHealthCheckConfig::getEnabled() const {
    return m_enabled;
}
void OAIHealthCheckConfig::setEnabled(const bool &enabled) {
    m_enabled = enabled;
    m_enabled_isSet = true;
}

bool OAIHealthCheckConfig::is_enabled_Set() const{
    return m_enabled_isSet;
}

bool OAIHealthCheckConfig::is_enabled_Valid() const{
    return m_enabled_isValid;
}

qint32 OAIHealthCheckConfig::getHealthCheckIntervalSeconds() const {
    return m_health_check_interval_seconds;
}
void OAIHealthCheckConfig::setHealthCheckIntervalSeconds(const qint32 &health_check_interval_seconds) {
    m_health_check_interval_seconds = health_check_interval_seconds;
    m_health_check_interval_seconds_isSet = true;
}

bool OAIHealthCheckConfig::is_health_check_interval_seconds_Set() const{
    return m_health_check_interval_seconds_isSet;
}

bool OAIHealthCheckConfig::is_health_check_interval_seconds_Valid() const{
    return m_health_check_interval_seconds_isValid;
}

qint32 OAIHealthCheckConfig::getHealthCheckTimeoutSeconds() const {
    return m_health_check_timeout_seconds;
}
void OAIHealthCheckConfig::setHealthCheckTimeoutSeconds(const qint32 &health_check_timeout_seconds) {
    m_health_check_timeout_seconds = health_check_timeout_seconds;
    m_health_check_timeout_seconds_isSet = true;
}

bool OAIHealthCheckConfig::is_health_check_timeout_seconds_Set() const{
    return m_health_check_timeout_seconds_isSet;
}

bool OAIHealthCheckConfig::is_health_check_timeout_seconds_Valid() const{
    return m_health_check_timeout_seconds_isValid;
}

qint32 OAIHealthCheckConfig::getHealthyThresholdCount() const {
    return m_healthy_threshold_count;
}
void OAIHealthCheckConfig::setHealthyThresholdCount(const qint32 &healthy_threshold_count) {
    m_healthy_threshold_count = healthy_threshold_count;
    m_healthy_threshold_count_isSet = true;
}

bool OAIHealthCheckConfig::is_healthy_threshold_count_Set() const{
    return m_healthy_threshold_count_isSet;
}

bool OAIHealthCheckConfig::is_healthy_threshold_count_Valid() const{
    return m_healthy_threshold_count_isValid;
}

OAIUpdateTargetGroup_request_healthCheck_matcher OAIHealthCheckConfig::getMatcher() const {
    return m_matcher;
}
void OAIHealthCheckConfig::setMatcher(const OAIUpdateTargetGroup_request_healthCheck_matcher &matcher) {
    m_matcher = matcher;
    m_matcher_isSet = true;
}

bool OAIHealthCheckConfig::is_matcher_Set() const{
    return m_matcher_isSet;
}

bool OAIHealthCheckConfig::is_matcher_Valid() const{
    return m_matcher_isValid;
}

QString OAIHealthCheckConfig::getPath() const {
    return m_path;
}
void OAIHealthCheckConfig::setPath(const QString &path) {
    m_path = path;
    m_path_isSet = true;
}

bool OAIHealthCheckConfig::is_path_Set() const{
    return m_path_isSet;
}

bool OAIHealthCheckConfig::is_path_Valid() const{
    return m_path_isValid;
}

qint32 OAIHealthCheckConfig::getPort() const {
    return m_port;
}
void OAIHealthCheckConfig::setPort(const qint32 &port) {
    m_port = port;
    m_port_isSet = true;
}

bool OAIHealthCheckConfig::is_port_Set() const{
    return m_port_isSet;
}

bool OAIHealthCheckConfig::is_port_Valid() const{
    return m_port_isValid;
}

OAITargetGroupProtocol OAIHealthCheckConfig::getProtocol() const {
    return m_protocol;
}
void OAIHealthCheckConfig::setProtocol(const OAITargetGroupProtocol &protocol) {
    m_protocol = protocol;
    m_protocol_isSet = true;
}

bool OAIHealthCheckConfig::is_protocol_Set() const{
    return m_protocol_isSet;
}

bool OAIHealthCheckConfig::is_protocol_Valid() const{
    return m_protocol_isValid;
}

OAIHealthCheckProtocolVersion OAIHealthCheckConfig::getProtocolVersion() const {
    return m_protocol_version;
}
void OAIHealthCheckConfig::setProtocolVersion(const OAIHealthCheckProtocolVersion &protocol_version) {
    m_protocol_version = protocol_version;
    m_protocol_version_isSet = true;
}

bool OAIHealthCheckConfig::is_protocol_version_Set() const{
    return m_protocol_version_isSet;
}

bool OAIHealthCheckConfig::is_protocol_version_Valid() const{
    return m_protocol_version_isValid;
}

qint32 OAIHealthCheckConfig::getUnhealthyThresholdCount() const {
    return m_unhealthy_threshold_count;
}
void OAIHealthCheckConfig::setUnhealthyThresholdCount(const qint32 &unhealthy_threshold_count) {
    m_unhealthy_threshold_count = unhealthy_threshold_count;
    m_unhealthy_threshold_count_isSet = true;
}

bool OAIHealthCheckConfig::is_unhealthy_threshold_count_Set() const{
    return m_unhealthy_threshold_count_isSet;
}

bool OAIHealthCheckConfig::is_unhealthy_threshold_count_Valid() const{
    return m_unhealthy_threshold_count_isValid;
}

bool OAIHealthCheckConfig::isSet() const {
    bool isObjectUpdated = false;
    do {
        if (m_enabled_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_health_check_interval_seconds_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_health_check_timeout_seconds_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_healthy_threshold_count_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_matcher.isSet()) {
            isObjectUpdated = true;
            break;
        }

        if (m_path_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_port_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_protocol.isSet()) {
            isObjectUpdated = true;
            break;
        }

        if (m_protocol_version.isSet()) {
            isObjectUpdated = true;
            break;
        }

        if (m_unhealthy_threshold_count_isSet) {
            isObjectUpdated = true;
            break;
        }
    } while (false);
    return isObjectUpdated;
}

bool OAIHealthCheckConfig::isValid() const {
    // only required properties are required for the object to be considered valid
    return true;
}

} // namespace OpenAPI
