/**
 * Amazon VPC Lattice
 * Amazon VPC Lattice is a fully managed application networking service that you use to connect, secure, and monitor all of your services across multiple accounts and virtual private clouds (VPCs). Amazon VPC Lattice interconnects your microservices and legacy services within a logical boundary, so that you can discover and manage them more efficiently. For more information, see the <a href=\"https://docs.aws.amazon.com/vpc-lattice/latest/ug/\">Amazon VPC Lattice User Guide</a> 
 *
 * The version of the OpenAPI document: 2022-11-30
 * Contact: mike.ralphson@gmail.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

#include "OAICreateTargetGroup_request_config_healthCheck.h"

#include <QDebug>
#include <QJsonArray>
#include <QJsonDocument>
#include <QObject>

#include "OAIHelpers.h"

namespace OpenAPI {

OAICreateTargetGroup_request_config_healthCheck::OAICreateTargetGroup_request_config_healthCheck(QString json) {
    this->initializeModel();
    this->fromJson(json);
}

OAICreateTargetGroup_request_config_healthCheck::OAICreateTargetGroup_request_config_healthCheck() {
    this->initializeModel();
}

OAICreateTargetGroup_request_config_healthCheck::~OAICreateTargetGroup_request_config_healthCheck() {}

void OAICreateTargetGroup_request_config_healthCheck::initializeModel() {

    m_enabled_isSet = false;
    m_enabled_isValid = false;

    m_health_check_interval_seconds_isSet = false;
    m_health_check_interval_seconds_isValid = false;

    m_health_check_timeout_seconds_isSet = false;
    m_health_check_timeout_seconds_isValid = false;

    m_healthy_threshold_count_isSet = false;
    m_healthy_threshold_count_isValid = false;

    m_matcher_isSet = false;
    m_matcher_isValid = false;

    m_path_isSet = false;
    m_path_isValid = false;

    m_port_isSet = false;
    m_port_isValid = false;

    m_protocol_isSet = false;
    m_protocol_isValid = false;

    m_protocol_version_isSet = false;
    m_protocol_version_isValid = false;

    m_unhealthy_threshold_count_isSet = false;
    m_unhealthy_threshold_count_isValid = false;
}

void OAICreateTargetGroup_request_config_healthCheck::fromJson(QString jsonString) {
    QByteArray array(jsonString.toStdString().c_str());
    QJsonDocument doc = QJsonDocument::fromJson(array);
    QJsonObject jsonObject = doc.object();
    this->fromJsonObject(jsonObject);
}

void OAICreateTargetGroup_request_config_healthCheck::fromJsonObject(QJsonObject json) {

    m_enabled_isValid = ::OpenAPI::fromJsonValue(m_enabled, json[QString("enabled")]);
    m_enabled_isSet = !json[QString("enabled")].isNull() && m_enabled_isValid;

    m_health_check_interval_seconds_isValid = ::OpenAPI::fromJsonValue(m_health_check_interval_seconds, json[QString("healthCheckIntervalSeconds")]);
    m_health_check_interval_seconds_isSet = !json[QString("healthCheckIntervalSeconds")].isNull() && m_health_check_interval_seconds_isValid;

    m_health_check_timeout_seconds_isValid = ::OpenAPI::fromJsonValue(m_health_check_timeout_seconds, json[QString("healthCheckTimeoutSeconds")]);
    m_health_check_timeout_seconds_isSet = !json[QString("healthCheckTimeoutSeconds")].isNull() && m_health_check_timeout_seconds_isValid;

    m_healthy_threshold_count_isValid = ::OpenAPI::fromJsonValue(m_healthy_threshold_count, json[QString("healthyThresholdCount")]);
    m_healthy_threshold_count_isSet = !json[QString("healthyThresholdCount")].isNull() && m_healthy_threshold_count_isValid;

    m_matcher_isValid = ::OpenAPI::fromJsonValue(m_matcher, json[QString("matcher")]);
    m_matcher_isSet = !json[QString("matcher")].isNull() && m_matcher_isValid;

    m_path_isValid = ::OpenAPI::fromJsonValue(m_path, json[QString("path")]);
    m_path_isSet = !json[QString("path")].isNull() && m_path_isValid;

    m_port_isValid = ::OpenAPI::fromJsonValue(m_port, json[QString("port")]);
    m_port_isSet = !json[QString("port")].isNull() && m_port_isValid;

    m_protocol_isValid = ::OpenAPI::fromJsonValue(m_protocol, json[QString("protocol")]);
    m_protocol_isSet = !json[QString("protocol")].isNull() && m_protocol_isValid;

    m_protocol_version_isValid = ::OpenAPI::fromJsonValue(m_protocol_version, json[QString("protocolVersion")]);
    m_protocol_version_isSet = !json[QString("protocolVersion")].isNull() && m_protocol_version_isValid;

    m_unhealthy_threshold_count_isValid = ::OpenAPI::fromJsonValue(m_unhealthy_threshold_count, json[QString("unhealthyThresholdCount")]);
    m_unhealthy_threshold_count_isSet = !json[QString("unhealthyThresholdCount")].isNull() && m_unhealthy_threshold_count_isValid;
}

QString OAICreateTargetGroup_request_config_healthCheck::asJson() const {
    QJsonObject obj = this->asJsonObject();
    QJsonDocument doc(obj);
    QByteArray bytes = doc.toJson();
    return QString(bytes);
}

QJsonObject OAICreateTargetGroup_request_config_healthCheck::asJsonObject() const {
    QJsonObject obj;
    if (m_enabled_isSet) {
        obj.insert(QString("enabled"), ::OpenAPI::toJsonValue(m_enabled));
    }
    if (m_health_check_interval_seconds_isSet) {
        obj.insert(QString("healthCheckIntervalSeconds"), ::OpenAPI::toJsonValue(m_health_check_interval_seconds));
    }
    if (m_health_check_timeout_seconds_isSet) {
        obj.insert(QString("healthCheckTimeoutSeconds"), ::OpenAPI::toJsonValue(m_health_check_timeout_seconds));
    }
    if (m_healthy_threshold_count_isSet) {
        obj.insert(QString("healthyThresholdCount"), ::OpenAPI::toJsonValue(m_healthy_threshold_count));
    }
    if (m_matcher.isSet()) {
        obj.insert(QString("matcher"), ::OpenAPI::toJsonValue(m_matcher));
    }
    if (m_path_isSet) {
        obj.insert(QString("path"), ::OpenAPI::toJsonValue(m_path));
    }
    if (m_port_isSet) {
        obj.insert(QString("port"), ::OpenAPI::toJsonValue(m_port));
    }
    if (m_protocol.isSet()) {
        obj.insert(QString("protocol"), ::OpenAPI::toJsonValue(m_protocol));
    }
    if (m_protocol_version.isSet()) {
        obj.insert(QString("protocolVersion"), ::OpenAPI::toJsonValue(m_protocol_version));
    }
    if (m_unhealthy_threshold_count_isSet) {
        obj.insert(QString("unhealthyThresholdCount"), ::OpenAPI::toJsonValue(m_unhealthy_threshold_count));
    }
    return obj;
}

bool OAICreateTargetGroup_request_config_healthCheck::getEnabled() const {
    return m_enabled;
}
void OAICreateTargetGroup_request_config_healthCheck::setEnabled(const bool &enabled) {
    m_enabled = enabled;
    m_enabled_isSet = true;
}

bool OAICreateTargetGroup_request_config_healthCheck::is_enabled_Set() const{
    return m_enabled_isSet;
}

bool OAICreateTargetGroup_request_config_healthCheck::is_enabled_Valid() const{
    return m_enabled_isValid;
}

qint32 OAICreateTargetGroup_request_config_healthCheck::getHealthCheckIntervalSeconds() const {
    return m_health_check_interval_seconds;
}
void OAICreateTargetGroup_request_config_healthCheck::setHealthCheckIntervalSeconds(const qint32 &health_check_interval_seconds) {
    m_health_check_interval_seconds = health_check_interval_seconds;
    m_health_check_interval_seconds_isSet = true;
}

bool OAICreateTargetGroup_request_config_healthCheck::is_health_check_interval_seconds_Set() const{
    return m_health_check_interval_seconds_isSet;
}

bool OAICreateTargetGroup_request_config_healthCheck::is_health_check_interval_seconds_Valid() const{
    return m_health_check_interval_seconds_isValid;
}

qint32 OAICreateTargetGroup_request_config_healthCheck::getHealthCheckTimeoutSeconds() const {
    return m_health_check_timeout_seconds;
}
void OAICreateTargetGroup_request_config_healthCheck::setHealthCheckTimeoutSeconds(const qint32 &health_check_timeout_seconds) {
    m_health_check_timeout_seconds = health_check_timeout_seconds;
    m_health_check_timeout_seconds_isSet = true;
}

bool OAICreateTargetGroup_request_config_healthCheck::is_health_check_timeout_seconds_Set() const{
    return m_health_check_timeout_seconds_isSet;
}

bool OAICreateTargetGroup_request_config_healthCheck::is_health_check_timeout_seconds_Valid() const{
    return m_health_check_timeout_seconds_isValid;
}

qint32 OAICreateTargetGroup_request_config_healthCheck::getHealthyThresholdCount() const {
    return m_healthy_threshold_count;
}
void OAICreateTargetGroup_request_config_healthCheck::setHealthyThresholdCount(const qint32 &healthy_threshold_count) {
    m_healthy_threshold_count = healthy_threshold_count;
    m_healthy_threshold_count_isSet = true;
}

bool OAICreateTargetGroup_request_config_healthCheck::is_healthy_threshold_count_Set() const{
    return m_healthy_threshold_count_isSet;
}

bool OAICreateTargetGroup_request_config_healthCheck::is_healthy_threshold_count_Valid() const{
    return m_healthy_threshold_count_isValid;
}

OAIUpdateTargetGroup_request_healthCheck_matcher OAICreateTargetGroup_request_config_healthCheck::getMatcher() const {
    return m_matcher;
}
void OAICreateTargetGroup_request_config_healthCheck::setMatcher(const OAIUpdateTargetGroup_request_healthCheck_matcher &matcher) {
    m_matcher = matcher;
    m_matcher_isSet = true;
}

bool OAICreateTargetGroup_request_config_healthCheck::is_matcher_Set() const{
    return m_matcher_isSet;
}

bool OAICreateTargetGroup_request_config_healthCheck::is_matcher_Valid() const{
    return m_matcher_isValid;
}

QString OAICreateTargetGroup_request_config_healthCheck::getPath() const {
    return m_path;
}
void OAICreateTargetGroup_request_config_healthCheck::setPath(const QString &path) {
    m_path = path;
    m_path_isSet = true;
}

bool OAICreateTargetGroup_request_config_healthCheck::is_path_Set() const{
    return m_path_isSet;
}

bool OAICreateTargetGroup_request_config_healthCheck::is_path_Valid() const{
    return m_path_isValid;
}

qint32 OAICreateTargetGroup_request_config_healthCheck::getPort() const {
    return m_port;
}
void OAICreateTargetGroup_request_config_healthCheck::setPort(const qint32 &port) {
    m_port = port;
    m_port_isSet = true;
}

bool OAICreateTargetGroup_request_config_healthCheck::is_port_Set() const{
    return m_port_isSet;
}

bool OAICreateTargetGroup_request_config_healthCheck::is_port_Valid() const{
    return m_port_isValid;
}

OAITargetGroupProtocol OAICreateTargetGroup_request_config_healthCheck::getProtocol() const {
    return m_protocol;
}
void OAICreateTargetGroup_request_config_healthCheck::setProtocol(const OAITargetGroupProtocol &protocol) {
    m_protocol = protocol;
    m_protocol_isSet = true;
}

bool OAICreateTargetGroup_request_config_healthCheck::is_protocol_Set() const{
    return m_protocol_isSet;
}

bool OAICreateTargetGroup_request_config_healthCheck::is_protocol_Valid() const{
    return m_protocol_isValid;
}

OAIHealthCheckProtocolVersion OAICreateTargetGroup_request_config_healthCheck::getProtocolVersion() const {
    return m_protocol_version;
}
void OAICreateTargetGroup_request_config_healthCheck::setProtocolVersion(const OAIHealthCheckProtocolVersion &protocol_version) {
    m_protocol_version = protocol_version;
    m_protocol_version_isSet = true;
}

bool OAICreateTargetGroup_request_config_healthCheck::is_protocol_version_Set() const{
    return m_protocol_version_isSet;
}

bool OAICreateTargetGroup_request_config_healthCheck::is_protocol_version_Valid() const{
    return m_protocol_version_isValid;
}

qint32 OAICreateTargetGroup_request_config_healthCheck::getUnhealthyThresholdCount() const {
    return m_unhealthy_threshold_count;
}
void OAICreateTargetGroup_request_config_healthCheck::setUnhealthyThresholdCount(const qint32 &unhealthy_threshold_count) {
    m_unhealthy_threshold_count = unhealthy_threshold_count;
    m_unhealthy_threshold_count_isSet = true;
}

bool OAICreateTargetGroup_request_config_healthCheck::is_unhealthy_threshold_count_Set() const{
    return m_unhealthy_threshold_count_isSet;
}

bool OAICreateTargetGroup_request_config_healthCheck::is_unhealthy_threshold_count_Valid() const{
    return m_unhealthy_threshold_count_isValid;
}

bool OAICreateTargetGroup_request_config_healthCheck::isSet() const {
    bool isObjectUpdated = false;
    do {
        if (m_enabled_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_health_check_interval_seconds_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_health_check_timeout_seconds_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_healthy_threshold_count_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_matcher.isSet()) {
            isObjectUpdated = true;
            break;
        }

        if (m_path_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_port_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_protocol.isSet()) {
            isObjectUpdated = true;
            break;
        }

        if (m_protocol_version.isSet()) {
            isObjectUpdated = true;
            break;
        }

        if (m_unhealthy_threshold_count_isSet) {
            isObjectUpdated = true;
            break;
        }
    } while (false);
    return isObjectUpdated;
}

bool OAICreateTargetGroup_request_config_healthCheck::isValid() const {
    // only required properties are required for the object to be considered valid
    return true;
}

} // namespace OpenAPI
