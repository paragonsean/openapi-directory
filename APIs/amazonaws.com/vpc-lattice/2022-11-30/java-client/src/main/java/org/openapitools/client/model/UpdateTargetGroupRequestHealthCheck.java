/*
 * Amazon VPC Lattice
 * Amazon VPC Lattice is a fully managed application networking service that you use to connect, secure, and monitor all of your services across multiple accounts and virtual private clouds (VPCs). Amazon VPC Lattice interconnects your microservices and legacy services within a logical boundary, so that you can discover and manage them more efficiently. For more information, see the <a href=\"https://docs.aws.amazon.com/vpc-lattice/latest/ug/\">Amazon VPC Lattice User Guide</a> 
 *
 * The version of the OpenAPI document: 2022-11-30
 * Contact: mike.ralphson@gmail.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package org.openapitools.client.model;

import java.util.Objects;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;
import java.util.Arrays;
import org.openapitools.client.model.HealthCheckProtocolVersion;
import org.openapitools.client.model.TargetGroupProtocol;
import org.openapitools.client.model.UpdateTargetGroupRequestHealthCheckMatcher;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonArray;
import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;
import com.google.gson.TypeAdapterFactory;
import com.google.gson.reflect.TypeToken;
import com.google.gson.TypeAdapter;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;

import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import org.openapitools.client.JSON;

/**
 * The health check configuration of a target group. Health check configurations aren&#39;t used for &lt;code&gt;LAMBDA&lt;/code&gt; and &lt;code&gt;ALB&lt;/code&gt; target groups.
 */
@javax.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen", date = "2024-10-12T12:11:37.168630-04:00[America/New_York]", comments = "Generator version: 7.9.0")
public class UpdateTargetGroupRequestHealthCheck {
  public static final String SERIALIZED_NAME_ENABLED = "enabled";
  @SerializedName(SERIALIZED_NAME_ENABLED)
  private Boolean enabled;

  public static final String SERIALIZED_NAME_HEALTH_CHECK_INTERVAL_SECONDS = "healthCheckIntervalSeconds";
  @SerializedName(SERIALIZED_NAME_HEALTH_CHECK_INTERVAL_SECONDS)
  private Integer healthCheckIntervalSeconds;

  public static final String SERIALIZED_NAME_HEALTH_CHECK_TIMEOUT_SECONDS = "healthCheckTimeoutSeconds";
  @SerializedName(SERIALIZED_NAME_HEALTH_CHECK_TIMEOUT_SECONDS)
  private Integer healthCheckTimeoutSeconds;

  public static final String SERIALIZED_NAME_HEALTHY_THRESHOLD_COUNT = "healthyThresholdCount";
  @SerializedName(SERIALIZED_NAME_HEALTHY_THRESHOLD_COUNT)
  private Integer healthyThresholdCount;

  public static final String SERIALIZED_NAME_MATCHER = "matcher";
  @SerializedName(SERIALIZED_NAME_MATCHER)
  private UpdateTargetGroupRequestHealthCheckMatcher matcher;

  public static final String SERIALIZED_NAME_PATH = "path";
  @SerializedName(SERIALIZED_NAME_PATH)
  private String path;

  public static final String SERIALIZED_NAME_PORT = "port";
  @SerializedName(SERIALIZED_NAME_PORT)
  private Integer port;

  public static final String SERIALIZED_NAME_PROTOCOL = "protocol";
  @SerializedName(SERIALIZED_NAME_PROTOCOL)
  private TargetGroupProtocol protocol;

  public static final String SERIALIZED_NAME_PROTOCOL_VERSION = "protocolVersion";
  @SerializedName(SERIALIZED_NAME_PROTOCOL_VERSION)
  private HealthCheckProtocolVersion protocolVersion;

  public static final String SERIALIZED_NAME_UNHEALTHY_THRESHOLD_COUNT = "unhealthyThresholdCount";
  @SerializedName(SERIALIZED_NAME_UNHEALTHY_THRESHOLD_COUNT)
  private Integer unhealthyThresholdCount;

  public UpdateTargetGroupRequestHealthCheck() {
  }

  public UpdateTargetGroupRequestHealthCheck enabled(Boolean enabled) {
    this.enabled = enabled;
    return this;
  }

  /**
   * Get enabled
   * @return enabled
   */
  @javax.annotation.Nullable
  public Boolean getEnabled() {
    return enabled;
  }

  public void setEnabled(Boolean enabled) {
    this.enabled = enabled;
  }


  public UpdateTargetGroupRequestHealthCheck healthCheckIntervalSeconds(Integer healthCheckIntervalSeconds) {
    this.healthCheckIntervalSeconds = healthCheckIntervalSeconds;
    return this;
  }

  /**
   * Get healthCheckIntervalSeconds
   * @return healthCheckIntervalSeconds
   */
  @javax.annotation.Nullable
  public Integer getHealthCheckIntervalSeconds() {
    return healthCheckIntervalSeconds;
  }

  public void setHealthCheckIntervalSeconds(Integer healthCheckIntervalSeconds) {
    this.healthCheckIntervalSeconds = healthCheckIntervalSeconds;
  }


  public UpdateTargetGroupRequestHealthCheck healthCheckTimeoutSeconds(Integer healthCheckTimeoutSeconds) {
    this.healthCheckTimeoutSeconds = healthCheckTimeoutSeconds;
    return this;
  }

  /**
   * Get healthCheckTimeoutSeconds
   * @return healthCheckTimeoutSeconds
   */
  @javax.annotation.Nullable
  public Integer getHealthCheckTimeoutSeconds() {
    return healthCheckTimeoutSeconds;
  }

  public void setHealthCheckTimeoutSeconds(Integer healthCheckTimeoutSeconds) {
    this.healthCheckTimeoutSeconds = healthCheckTimeoutSeconds;
  }


  public UpdateTargetGroupRequestHealthCheck healthyThresholdCount(Integer healthyThresholdCount) {
    this.healthyThresholdCount = healthyThresholdCount;
    return this;
  }

  /**
   * Get healthyThresholdCount
   * @return healthyThresholdCount
   */
  @javax.annotation.Nullable
  public Integer getHealthyThresholdCount() {
    return healthyThresholdCount;
  }

  public void setHealthyThresholdCount(Integer healthyThresholdCount) {
    this.healthyThresholdCount = healthyThresholdCount;
  }


  public UpdateTargetGroupRequestHealthCheck matcher(UpdateTargetGroupRequestHealthCheckMatcher matcher) {
    this.matcher = matcher;
    return this;
  }

  /**
   * Get matcher
   * @return matcher
   */
  @javax.annotation.Nullable
  public UpdateTargetGroupRequestHealthCheckMatcher getMatcher() {
    return matcher;
  }

  public void setMatcher(UpdateTargetGroupRequestHealthCheckMatcher matcher) {
    this.matcher = matcher;
  }


  public UpdateTargetGroupRequestHealthCheck path(String path) {
    this.path = path;
    return this;
  }

  /**
   * Get path
   * @return path
   */
  @javax.annotation.Nullable
  public String getPath() {
    return path;
  }

  public void setPath(String path) {
    this.path = path;
  }


  public UpdateTargetGroupRequestHealthCheck port(Integer port) {
    this.port = port;
    return this;
  }

  /**
   * Get port
   * @return port
   */
  @javax.annotation.Nullable
  public Integer getPort() {
    return port;
  }

  public void setPort(Integer port) {
    this.port = port;
  }


  public UpdateTargetGroupRequestHealthCheck protocol(TargetGroupProtocol protocol) {
    this.protocol = protocol;
    return this;
  }

  /**
   * Get protocol
   * @return protocol
   */
  @javax.annotation.Nullable
  public TargetGroupProtocol getProtocol() {
    return protocol;
  }

  public void setProtocol(TargetGroupProtocol protocol) {
    this.protocol = protocol;
  }


  public UpdateTargetGroupRequestHealthCheck protocolVersion(HealthCheckProtocolVersion protocolVersion) {
    this.protocolVersion = protocolVersion;
    return this;
  }

  /**
   * Get protocolVersion
   * @return protocolVersion
   */
  @javax.annotation.Nullable
  public HealthCheckProtocolVersion getProtocolVersion() {
    return protocolVersion;
  }

  public void setProtocolVersion(HealthCheckProtocolVersion protocolVersion) {
    this.protocolVersion = protocolVersion;
  }


  public UpdateTargetGroupRequestHealthCheck unhealthyThresholdCount(Integer unhealthyThresholdCount) {
    this.unhealthyThresholdCount = unhealthyThresholdCount;
    return this;
  }

  /**
   * Get unhealthyThresholdCount
   * @return unhealthyThresholdCount
   */
  @javax.annotation.Nullable
  public Integer getUnhealthyThresholdCount() {
    return unhealthyThresholdCount;
  }

  public void setUnhealthyThresholdCount(Integer unhealthyThresholdCount) {
    this.unhealthyThresholdCount = unhealthyThresholdCount;
  }



  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    UpdateTargetGroupRequestHealthCheck updateTargetGroupRequestHealthCheck = (UpdateTargetGroupRequestHealthCheck) o;
    return Objects.equals(this.enabled, updateTargetGroupRequestHealthCheck.enabled) &&
        Objects.equals(this.healthCheckIntervalSeconds, updateTargetGroupRequestHealthCheck.healthCheckIntervalSeconds) &&
        Objects.equals(this.healthCheckTimeoutSeconds, updateTargetGroupRequestHealthCheck.healthCheckTimeoutSeconds) &&
        Objects.equals(this.healthyThresholdCount, updateTargetGroupRequestHealthCheck.healthyThresholdCount) &&
        Objects.equals(this.matcher, updateTargetGroupRequestHealthCheck.matcher) &&
        Objects.equals(this.path, updateTargetGroupRequestHealthCheck.path) &&
        Objects.equals(this.port, updateTargetGroupRequestHealthCheck.port) &&
        Objects.equals(this.protocol, updateTargetGroupRequestHealthCheck.protocol) &&
        Objects.equals(this.protocolVersion, updateTargetGroupRequestHealthCheck.protocolVersion) &&
        Objects.equals(this.unhealthyThresholdCount, updateTargetGroupRequestHealthCheck.unhealthyThresholdCount);
  }

  @Override
  public int hashCode() {
    return Objects.hash(enabled, healthCheckIntervalSeconds, healthCheckTimeoutSeconds, healthyThresholdCount, matcher, path, port, protocol, protocolVersion, unhealthyThresholdCount);
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class UpdateTargetGroupRequestHealthCheck {\n");
    sb.append("    enabled: ").append(toIndentedString(enabled)).append("\n");
    sb.append("    healthCheckIntervalSeconds: ").append(toIndentedString(healthCheckIntervalSeconds)).append("\n");
    sb.append("    healthCheckTimeoutSeconds: ").append(toIndentedString(healthCheckTimeoutSeconds)).append("\n");
    sb.append("    healthyThresholdCount: ").append(toIndentedString(healthyThresholdCount)).append("\n");
    sb.append("    matcher: ").append(toIndentedString(matcher)).append("\n");
    sb.append("    path: ").append(toIndentedString(path)).append("\n");
    sb.append("    port: ").append(toIndentedString(port)).append("\n");
    sb.append("    protocol: ").append(toIndentedString(protocol)).append("\n");
    sb.append("    protocolVersion: ").append(toIndentedString(protocolVersion)).append("\n");
    sb.append("    unhealthyThresholdCount: ").append(toIndentedString(unhealthyThresholdCount)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }


  public static HashSet<String> openapiFields;
  public static HashSet<String> openapiRequiredFields;

  static {
    // a set of all properties/fields (JSON key names)
    openapiFields = new HashSet<String>();
    openapiFields.add("enabled");
    openapiFields.add("healthCheckIntervalSeconds");
    openapiFields.add("healthCheckTimeoutSeconds");
    openapiFields.add("healthyThresholdCount");
    openapiFields.add("matcher");
    openapiFields.add("path");
    openapiFields.add("port");
    openapiFields.add("protocol");
    openapiFields.add("protocolVersion");
    openapiFields.add("unhealthyThresholdCount");

    // a set of required properties/fields (JSON key names)
    openapiRequiredFields = new HashSet<String>();
  }

  /**
   * Validates the JSON Element and throws an exception if issues found
   *
   * @param jsonElement JSON Element
   * @throws IOException if the JSON Element is invalid with respect to UpdateTargetGroupRequestHealthCheck
   */
  public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      if (jsonElement == null) {
        if (!UpdateTargetGroupRequestHealthCheck.openapiRequiredFields.isEmpty()) { // has required fields but JSON element is null
          throw new IllegalArgumentException(String.format("The required field(s) %s in UpdateTargetGroupRequestHealthCheck is not found in the empty JSON string", UpdateTargetGroupRequestHealthCheck.openapiRequiredFields.toString()));
        }
      }

      Set<Map.Entry<String, JsonElement>> entries = jsonElement.getAsJsonObject().entrySet();
      // check to see if the JSON string contains additional fields
      for (Map.Entry<String, JsonElement> entry : entries) {
        if (!UpdateTargetGroupRequestHealthCheck.openapiFields.contains(entry.getKey())) {
          throw new IllegalArgumentException(String.format("The field `%s` in the JSON string is not defined in the `UpdateTargetGroupRequestHealthCheck` properties. JSON: %s", entry.getKey(), jsonElement.toString()));
        }
      }
        JsonObject jsonObj = jsonElement.getAsJsonObject();
      // validate the optional field `enabled`
      if (jsonObj.get("enabled") != null && !jsonObj.get("enabled").isJsonNull()) {
        Boolean.validateJsonElement(jsonObj.get("enabled"));
      }
      // validate the optional field `healthCheckIntervalSeconds`
      if (jsonObj.get("healthCheckIntervalSeconds") != null && !jsonObj.get("healthCheckIntervalSeconds").isJsonNull()) {
        Integer.validateJsonElement(jsonObj.get("healthCheckIntervalSeconds"));
      }
      // validate the optional field `healthCheckTimeoutSeconds`
      if (jsonObj.get("healthCheckTimeoutSeconds") != null && !jsonObj.get("healthCheckTimeoutSeconds").isJsonNull()) {
        Integer.validateJsonElement(jsonObj.get("healthCheckTimeoutSeconds"));
      }
      // validate the optional field `healthyThresholdCount`
      if (jsonObj.get("healthyThresholdCount") != null && !jsonObj.get("healthyThresholdCount").isJsonNull()) {
        Integer.validateJsonElement(jsonObj.get("healthyThresholdCount"));
      }
      // validate the optional field `matcher`
      if (jsonObj.get("matcher") != null && !jsonObj.get("matcher").isJsonNull()) {
        UpdateTargetGroupRequestHealthCheckMatcher.validateJsonElement(jsonObj.get("matcher"));
      }
      // validate the optional field `path`
      if (jsonObj.get("path") != null && !jsonObj.get("path").isJsonNull()) {
        String.validateJsonElement(jsonObj.get("path"));
      }
      // validate the optional field `port`
      if (jsonObj.get("port") != null && !jsonObj.get("port").isJsonNull()) {
        Integer.validateJsonElement(jsonObj.get("port"));
      }
      // validate the optional field `protocol`
      if (jsonObj.get("protocol") != null && !jsonObj.get("protocol").isJsonNull()) {
        TargetGroupProtocol.validateJsonElement(jsonObj.get("protocol"));
      }
      // validate the optional field `protocolVersion`
      if (jsonObj.get("protocolVersion") != null && !jsonObj.get("protocolVersion").isJsonNull()) {
        HealthCheckProtocolVersion.validateJsonElement(jsonObj.get("protocolVersion"));
      }
      // validate the optional field `unhealthyThresholdCount`
      if (jsonObj.get("unhealthyThresholdCount") != null && !jsonObj.get("unhealthyThresholdCount").isJsonNull()) {
        Integer.validateJsonElement(jsonObj.get("unhealthyThresholdCount"));
      }
  }

  public static class CustomTypeAdapterFactory implements TypeAdapterFactory {
    @SuppressWarnings("unchecked")
    @Override
    public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
       if (!UpdateTargetGroupRequestHealthCheck.class.isAssignableFrom(type.getRawType())) {
         return null; // this class only serializes 'UpdateTargetGroupRequestHealthCheck' and its subtypes
       }
       final TypeAdapter<JsonElement> elementAdapter = gson.getAdapter(JsonElement.class);
       final TypeAdapter<UpdateTargetGroupRequestHealthCheck> thisAdapter
                        = gson.getDelegateAdapter(this, TypeToken.get(UpdateTargetGroupRequestHealthCheck.class));

       return (TypeAdapter<T>) new TypeAdapter<UpdateTargetGroupRequestHealthCheck>() {
           @Override
           public void write(JsonWriter out, UpdateTargetGroupRequestHealthCheck value) throws IOException {
             JsonObject obj = thisAdapter.toJsonTree(value).getAsJsonObject();
             elementAdapter.write(out, obj);
           }

           @Override
           public UpdateTargetGroupRequestHealthCheck read(JsonReader in) throws IOException {
             JsonElement jsonElement = elementAdapter.read(in);
             validateJsonElement(jsonElement);
             return thisAdapter.fromJsonTree(jsonElement);
           }

       }.nullSafe();
    }
  }

  /**
   * Create an instance of UpdateTargetGroupRequestHealthCheck given an JSON string
   *
   * @param jsonString JSON string
   * @return An instance of UpdateTargetGroupRequestHealthCheck
   * @throws IOException if the JSON string is invalid with respect to UpdateTargetGroupRequestHealthCheck
   */
  public static UpdateTargetGroupRequestHealthCheck fromJson(String jsonString) throws IOException {
    return JSON.getGson().fromJson(jsonString, UpdateTargetGroupRequestHealthCheck.class);
  }

  /**
   * Convert an instance of UpdateTargetGroupRequestHealthCheck to an JSON string
   *
   * @return JSON string
   */
  public String toJson() {
    return JSON.getGson().toJson(this);
  }
}

