/*
 * Amazon Simple Systems Manager (SSM)
 * <p>Amazon Web Services Systems Manager is the operations hub for your Amazon Web Services applications and resources and a secure end-to-end management solution for hybrid cloud environments that enables safe and secure operations at scale.</p> <p>This reference is intended to be used with the <a href=\"https://docs.aws.amazon.com/systems-manager/latest/userguide/\">Amazon Web Services Systems Manager User Guide</a>. To get started, see <a href=\"https://docs.aws.amazon.com/systems-manager/latest/userguide/systems-manager-setting-up.html\">Setting up Amazon Web Services Systems Manager</a>.</p> <p class=\"title\"> <b>Related resources</b> </p> <ul> <li> <p>For information about each of the capabilities that comprise Systems Manager, see <a href=\"https://docs.aws.amazon.com/systems-manager-automation-runbooks/latest/userguide/systems-manager-capabilities.html\">Systems Manager capabilities</a> in the <i>Amazon Web Services Systems Manager User Guide</i>.</p> </li> <li> <p>For details about predefined runbooks for Automation, a capability of Amazon Web Services Systems Manager, see the <i> <a href=\"https://docs.aws.amazon.com/systems-manager-automation-runbooks/latest/userguide/automation-runbook-reference.html\">Systems Manager Automation runbook reference</a> </i>.</p> </li> <li> <p>For information about AppConfig, a capability of Systems Manager, see the <i> <a href=\"https://docs.aws.amazon.com/appconfig/latest/userguide/\">AppConfig User Guide</a> </i> and the <i> <a href=\"https://docs.aws.amazon.com/appconfig/2019-10-09/APIReference/\">AppConfig API Reference</a> </i>.</p> </li> <li> <p>For information about Incident Manager, a capability of Systems Manager, see the <i> <a href=\"https://docs.aws.amazon.com/incident-manager/latest/userguide/\">Systems Manager Incident Manager User Guide</a> </i> and the <i> <a href=\"https://docs.aws.amazon.com/incident-manager/latest/APIReference/\">Systems Manager Incident Manager API Reference</a> </i>.</p> </li> </ul>
 *
 * The version of the OpenAPI document: 2014-11-06
 * Contact: mike.ralphson@gmail.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package org.openapitools.client.model;

import java.util.Objects;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;
import java.time.OffsetDateTime;
import java.util.Arrays;
import java.util.List;
import org.openapitools.client.model.DocumentFormat;
import org.openapitools.client.model.DocumentHashType;
import org.openapitools.client.model.DocumentStatus;
import org.openapitools.client.model.DocumentType;
import org.openapitools.client.model.ReviewStatus;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonArray;
import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;
import com.google.gson.TypeAdapterFactory;
import com.google.gson.reflect.TypeToken;
import com.google.gson.TypeAdapter;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;

import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import org.openapitools.client.JSON;

/**
 * Describes an Amazon Web Services Systems Manager document (SSM document). 
 */
@javax.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen", date = "2024-10-12T12:14:21.701211-04:00[America/New_York]", comments = "Generator version: 7.9.0")
public class DocumentDescription {
  public static final String SERIALIZED_NAME_SHA1 = "Sha1";
  @SerializedName(SERIALIZED_NAME_SHA1)
  private String sha1;

  public static final String SERIALIZED_NAME_HASH = "Hash";
  @SerializedName(SERIALIZED_NAME_HASH)
  private String hash;

  public static final String SERIALIZED_NAME_HASH_TYPE = "HashType";
  @SerializedName(SERIALIZED_NAME_HASH_TYPE)
  private DocumentHashType hashType;

  public static final String SERIALIZED_NAME_NAME = "Name";
  @SerializedName(SERIALIZED_NAME_NAME)
  private String name;

  public static final String SERIALIZED_NAME_DISPLAY_NAME = "DisplayName";
  @SerializedName(SERIALIZED_NAME_DISPLAY_NAME)
  private String displayName;

  public static final String SERIALIZED_NAME_VERSION_NAME = "VersionName";
  @SerializedName(SERIALIZED_NAME_VERSION_NAME)
  private String versionName;

  public static final String SERIALIZED_NAME_OWNER = "Owner";
  @SerializedName(SERIALIZED_NAME_OWNER)
  private String owner;

  public static final String SERIALIZED_NAME_CREATED_DATE = "CreatedDate";
  @SerializedName(SERIALIZED_NAME_CREATED_DATE)
  private OffsetDateTime createdDate;

  public static final String SERIALIZED_NAME_STATUS = "Status";
  @SerializedName(SERIALIZED_NAME_STATUS)
  private DocumentStatus status;

  public static final String SERIALIZED_NAME_STATUS_INFORMATION = "StatusInformation";
  @SerializedName(SERIALIZED_NAME_STATUS_INFORMATION)
  private String statusInformation;

  public static final String SERIALIZED_NAME_DOCUMENT_VERSION = "DocumentVersion";
  @SerializedName(SERIALIZED_NAME_DOCUMENT_VERSION)
  private String documentVersion;

  public static final String SERIALIZED_NAME_DESCRIPTION = "Description";
  @SerializedName(SERIALIZED_NAME_DESCRIPTION)
  private String description;

  public static final String SERIALIZED_NAME_PARAMETERS = "Parameters";
  @SerializedName(SERIALIZED_NAME_PARAMETERS)
  private List parameters;

  public static final String SERIALIZED_NAME_PLATFORM_TYPES = "PlatformTypes";
  @SerializedName(SERIALIZED_NAME_PLATFORM_TYPES)
  private List platformTypes;

  public static final String SERIALIZED_NAME_DOCUMENT_TYPE = "DocumentType";
  @SerializedName(SERIALIZED_NAME_DOCUMENT_TYPE)
  private DocumentType documentType;

  public static final String SERIALIZED_NAME_SCHEMA_VERSION = "SchemaVersion";
  @SerializedName(SERIALIZED_NAME_SCHEMA_VERSION)
  private String schemaVersion;

  public static final String SERIALIZED_NAME_LATEST_VERSION = "LatestVersion";
  @SerializedName(SERIALIZED_NAME_LATEST_VERSION)
  private String latestVersion;

  public static final String SERIALIZED_NAME_DEFAULT_VERSION = "DefaultVersion";
  @SerializedName(SERIALIZED_NAME_DEFAULT_VERSION)
  private String defaultVersion;

  public static final String SERIALIZED_NAME_DOCUMENT_FORMAT = "DocumentFormat";
  @SerializedName(SERIALIZED_NAME_DOCUMENT_FORMAT)
  private DocumentFormat documentFormat;

  public static final String SERIALIZED_NAME_TARGET_TYPE = "TargetType";
  @SerializedName(SERIALIZED_NAME_TARGET_TYPE)
  private String targetType;

  public static final String SERIALIZED_NAME_TAGS = "Tags";
  @SerializedName(SERIALIZED_NAME_TAGS)
  private List tags;

  public static final String SERIALIZED_NAME_ATTACHMENTS_INFORMATION = "AttachmentsInformation";
  @SerializedName(SERIALIZED_NAME_ATTACHMENTS_INFORMATION)
  private List attachmentsInformation;

  public static final String SERIALIZED_NAME_REQUIRES = "Requires";
  @SerializedName(SERIALIZED_NAME_REQUIRES)
  private List requires;

  public static final String SERIALIZED_NAME_AUTHOR = "Author";
  @SerializedName(SERIALIZED_NAME_AUTHOR)
  private String author;

  public static final String SERIALIZED_NAME_REVIEW_INFORMATION = "ReviewInformation";
  @SerializedName(SERIALIZED_NAME_REVIEW_INFORMATION)
  private List reviewInformation;

  public static final String SERIALIZED_NAME_APPROVED_VERSION = "ApprovedVersion";
  @SerializedName(SERIALIZED_NAME_APPROVED_VERSION)
  private String approvedVersion;

  public static final String SERIALIZED_NAME_PENDING_REVIEW_VERSION = "PendingReviewVersion";
  @SerializedName(SERIALIZED_NAME_PENDING_REVIEW_VERSION)
  private String pendingReviewVersion;

  public static final String SERIALIZED_NAME_REVIEW_STATUS = "ReviewStatus";
  @SerializedName(SERIALIZED_NAME_REVIEW_STATUS)
  private ReviewStatus reviewStatus;

  public static final String SERIALIZED_NAME_CATEGORY = "Category";
  @SerializedName(SERIALIZED_NAME_CATEGORY)
  private List category;

  public static final String SERIALIZED_NAME_CATEGORY_ENUM = "CategoryEnum";
  @SerializedName(SERIALIZED_NAME_CATEGORY_ENUM)
  private List categoryEnum;

  public DocumentDescription() {
  }

  public DocumentDescription sha1(String sha1) {
    this.sha1 = sha1;
    return this;
  }

  /**
   * Get sha1
   * @return sha1
   */
  @javax.annotation.Nullable
  public String getSha1() {
    return sha1;
  }

  public void setSha1(String sha1) {
    this.sha1 = sha1;
  }


  public DocumentDescription hash(String hash) {
    this.hash = hash;
    return this;
  }

  /**
   * Get hash
   * @return hash
   */
  @javax.annotation.Nullable
  public String getHash() {
    return hash;
  }

  public void setHash(String hash) {
    this.hash = hash;
  }


  public DocumentDescription hashType(DocumentHashType hashType) {
    this.hashType = hashType;
    return this;
  }

  /**
   * Get hashType
   * @return hashType
   */
  @javax.annotation.Nullable
  public DocumentHashType getHashType() {
    return hashType;
  }

  public void setHashType(DocumentHashType hashType) {
    this.hashType = hashType;
  }


  public DocumentDescription name(String name) {
    this.name = name;
    return this;
  }

  /**
   * Get name
   * @return name
   */
  @javax.annotation.Nullable
  public String getName() {
    return name;
  }

  public void setName(String name) {
    this.name = name;
  }


  public DocumentDescription displayName(String displayName) {
    this.displayName = displayName;
    return this;
  }

  /**
   * Get displayName
   * @return displayName
   */
  @javax.annotation.Nullable
  public String getDisplayName() {
    return displayName;
  }

  public void setDisplayName(String displayName) {
    this.displayName = displayName;
  }


  public DocumentDescription versionName(String versionName) {
    this.versionName = versionName;
    return this;
  }

  /**
   * Get versionName
   * @return versionName
   */
  @javax.annotation.Nullable
  public String getVersionName() {
    return versionName;
  }

  public void setVersionName(String versionName) {
    this.versionName = versionName;
  }


  public DocumentDescription owner(String owner) {
    this.owner = owner;
    return this;
  }

  /**
   * Get owner
   * @return owner
   */
  @javax.annotation.Nullable
  public String getOwner() {
    return owner;
  }

  public void setOwner(String owner) {
    this.owner = owner;
  }


  public DocumentDescription createdDate(OffsetDateTime createdDate) {
    this.createdDate = createdDate;
    return this;
  }

  /**
   * Get createdDate
   * @return createdDate
   */
  @javax.annotation.Nullable
  public OffsetDateTime getCreatedDate() {
    return createdDate;
  }

  public void setCreatedDate(OffsetDateTime createdDate) {
    this.createdDate = createdDate;
  }


  public DocumentDescription status(DocumentStatus status) {
    this.status = status;
    return this;
  }

  /**
   * Get status
   * @return status
   */
  @javax.annotation.Nullable
  public DocumentStatus getStatus() {
    return status;
  }

  public void setStatus(DocumentStatus status) {
    this.status = status;
  }


  public DocumentDescription statusInformation(String statusInformation) {
    this.statusInformation = statusInformation;
    return this;
  }

  /**
   * Get statusInformation
   * @return statusInformation
   */
  @javax.annotation.Nullable
  public String getStatusInformation() {
    return statusInformation;
  }

  public void setStatusInformation(String statusInformation) {
    this.statusInformation = statusInformation;
  }


  public DocumentDescription documentVersion(String documentVersion) {
    this.documentVersion = documentVersion;
    return this;
  }

  /**
   * Get documentVersion
   * @return documentVersion
   */
  @javax.annotation.Nullable
  public String getDocumentVersion() {
    return documentVersion;
  }

  public void setDocumentVersion(String documentVersion) {
    this.documentVersion = documentVersion;
  }


  public DocumentDescription description(String description) {
    this.description = description;
    return this;
  }

  /**
   * Get description
   * @return description
   */
  @javax.annotation.Nullable
  public String getDescription() {
    return description;
  }

  public void setDescription(String description) {
    this.description = description;
  }


  public DocumentDescription parameters(List parameters) {
    this.parameters = parameters;
    return this;
  }

  /**
   * Get parameters
   * @return parameters
   */
  @javax.annotation.Nullable
  public List getParameters() {
    return parameters;
  }

  public void setParameters(List parameters) {
    this.parameters = parameters;
  }


  public DocumentDescription platformTypes(List platformTypes) {
    this.platformTypes = platformTypes;
    return this;
  }

  /**
   * Get platformTypes
   * @return platformTypes
   */
  @javax.annotation.Nullable
  public List getPlatformTypes() {
    return platformTypes;
  }

  public void setPlatformTypes(List platformTypes) {
    this.platformTypes = platformTypes;
  }


  public DocumentDescription documentType(DocumentType documentType) {
    this.documentType = documentType;
    return this;
  }

  /**
   * Get documentType
   * @return documentType
   */
  @javax.annotation.Nullable
  public DocumentType getDocumentType() {
    return documentType;
  }

  public void setDocumentType(DocumentType documentType) {
    this.documentType = documentType;
  }


  public DocumentDescription schemaVersion(String schemaVersion) {
    this.schemaVersion = schemaVersion;
    return this;
  }

  /**
   * Get schemaVersion
   * @return schemaVersion
   */
  @javax.annotation.Nullable
  public String getSchemaVersion() {
    return schemaVersion;
  }

  public void setSchemaVersion(String schemaVersion) {
    this.schemaVersion = schemaVersion;
  }


  public DocumentDescription latestVersion(String latestVersion) {
    this.latestVersion = latestVersion;
    return this;
  }

  /**
   * Get latestVersion
   * @return latestVersion
   */
  @javax.annotation.Nullable
  public String getLatestVersion() {
    return latestVersion;
  }

  public void setLatestVersion(String latestVersion) {
    this.latestVersion = latestVersion;
  }


  public DocumentDescription defaultVersion(String defaultVersion) {
    this.defaultVersion = defaultVersion;
    return this;
  }

  /**
   * Get defaultVersion
   * @return defaultVersion
   */
  @javax.annotation.Nullable
  public String getDefaultVersion() {
    return defaultVersion;
  }

  public void setDefaultVersion(String defaultVersion) {
    this.defaultVersion = defaultVersion;
  }


  public DocumentDescription documentFormat(DocumentFormat documentFormat) {
    this.documentFormat = documentFormat;
    return this;
  }

  /**
   * Get documentFormat
   * @return documentFormat
   */
  @javax.annotation.Nullable
  public DocumentFormat getDocumentFormat() {
    return documentFormat;
  }

  public void setDocumentFormat(DocumentFormat documentFormat) {
    this.documentFormat = documentFormat;
  }


  public DocumentDescription targetType(String targetType) {
    this.targetType = targetType;
    return this;
  }

  /**
   * Get targetType
   * @return targetType
   */
  @javax.annotation.Nullable
  public String getTargetType() {
    return targetType;
  }

  public void setTargetType(String targetType) {
    this.targetType = targetType;
  }


  public DocumentDescription tags(List tags) {
    this.tags = tags;
    return this;
  }

  /**
   * Get tags
   * @return tags
   */
  @javax.annotation.Nullable
  public List getTags() {
    return tags;
  }

  public void setTags(List tags) {
    this.tags = tags;
  }


  public DocumentDescription attachmentsInformation(List attachmentsInformation) {
    this.attachmentsInformation = attachmentsInformation;
    return this;
  }

  /**
   * Get attachmentsInformation
   * @return attachmentsInformation
   */
  @javax.annotation.Nullable
  public List getAttachmentsInformation() {
    return attachmentsInformation;
  }

  public void setAttachmentsInformation(List attachmentsInformation) {
    this.attachmentsInformation = attachmentsInformation;
  }


  public DocumentDescription requires(List requires) {
    this.requires = requires;
    return this;
  }

  /**
   * Get requires
   * @return requires
   */
  @javax.annotation.Nullable
  public List getRequires() {
    return requires;
  }

  public void setRequires(List requires) {
    this.requires = requires;
  }


  public DocumentDescription author(String author) {
    this.author = author;
    return this;
  }

  /**
   * Get author
   * @return author
   */
  @javax.annotation.Nullable
  public String getAuthor() {
    return author;
  }

  public void setAuthor(String author) {
    this.author = author;
  }


  public DocumentDescription reviewInformation(List reviewInformation) {
    this.reviewInformation = reviewInformation;
    return this;
  }

  /**
   * Get reviewInformation
   * @return reviewInformation
   */
  @javax.annotation.Nullable
  public List getReviewInformation() {
    return reviewInformation;
  }

  public void setReviewInformation(List reviewInformation) {
    this.reviewInformation = reviewInformation;
  }


  public DocumentDescription approvedVersion(String approvedVersion) {
    this.approvedVersion = approvedVersion;
    return this;
  }

  /**
   * Get approvedVersion
   * @return approvedVersion
   */
  @javax.annotation.Nullable
  public String getApprovedVersion() {
    return approvedVersion;
  }

  public void setApprovedVersion(String approvedVersion) {
    this.approvedVersion = approvedVersion;
  }


  public DocumentDescription pendingReviewVersion(String pendingReviewVersion) {
    this.pendingReviewVersion = pendingReviewVersion;
    return this;
  }

  /**
   * Get pendingReviewVersion
   * @return pendingReviewVersion
   */
  @javax.annotation.Nullable
  public String getPendingReviewVersion() {
    return pendingReviewVersion;
  }

  public void setPendingReviewVersion(String pendingReviewVersion) {
    this.pendingReviewVersion = pendingReviewVersion;
  }


  public DocumentDescription reviewStatus(ReviewStatus reviewStatus) {
    this.reviewStatus = reviewStatus;
    return this;
  }

  /**
   * Get reviewStatus
   * @return reviewStatus
   */
  @javax.annotation.Nullable
  public ReviewStatus getReviewStatus() {
    return reviewStatus;
  }

  public void setReviewStatus(ReviewStatus reviewStatus) {
    this.reviewStatus = reviewStatus;
  }


  public DocumentDescription category(List category) {
    this.category = category;
    return this;
  }

  /**
   * Get category
   * @return category
   */
  @javax.annotation.Nullable
  public List getCategory() {
    return category;
  }

  public void setCategory(List category) {
    this.category = category;
  }


  public DocumentDescription categoryEnum(List categoryEnum) {
    this.categoryEnum = categoryEnum;
    return this;
  }

  /**
   * Get categoryEnum
   * @return categoryEnum
   */
  @javax.annotation.Nullable
  public List getCategoryEnum() {
    return categoryEnum;
  }

  public void setCategoryEnum(List categoryEnum) {
    this.categoryEnum = categoryEnum;
  }



  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    DocumentDescription documentDescription = (DocumentDescription) o;
    return Objects.equals(this.sha1, documentDescription.sha1) &&
        Objects.equals(this.hash, documentDescription.hash) &&
        Objects.equals(this.hashType, documentDescription.hashType) &&
        Objects.equals(this.name, documentDescription.name) &&
        Objects.equals(this.displayName, documentDescription.displayName) &&
        Objects.equals(this.versionName, documentDescription.versionName) &&
        Objects.equals(this.owner, documentDescription.owner) &&
        Objects.equals(this.createdDate, documentDescription.createdDate) &&
        Objects.equals(this.status, documentDescription.status) &&
        Objects.equals(this.statusInformation, documentDescription.statusInformation) &&
        Objects.equals(this.documentVersion, documentDescription.documentVersion) &&
        Objects.equals(this.description, documentDescription.description) &&
        Objects.equals(this.parameters, documentDescription.parameters) &&
        Objects.equals(this.platformTypes, documentDescription.platformTypes) &&
        Objects.equals(this.documentType, documentDescription.documentType) &&
        Objects.equals(this.schemaVersion, documentDescription.schemaVersion) &&
        Objects.equals(this.latestVersion, documentDescription.latestVersion) &&
        Objects.equals(this.defaultVersion, documentDescription.defaultVersion) &&
        Objects.equals(this.documentFormat, documentDescription.documentFormat) &&
        Objects.equals(this.targetType, documentDescription.targetType) &&
        Objects.equals(this.tags, documentDescription.tags) &&
        Objects.equals(this.attachmentsInformation, documentDescription.attachmentsInformation) &&
        Objects.equals(this.requires, documentDescription.requires) &&
        Objects.equals(this.author, documentDescription.author) &&
        Objects.equals(this.reviewInformation, documentDescription.reviewInformation) &&
        Objects.equals(this.approvedVersion, documentDescription.approvedVersion) &&
        Objects.equals(this.pendingReviewVersion, documentDescription.pendingReviewVersion) &&
        Objects.equals(this.reviewStatus, documentDescription.reviewStatus) &&
        Objects.equals(this.category, documentDescription.category) &&
        Objects.equals(this.categoryEnum, documentDescription.categoryEnum);
  }

  @Override
  public int hashCode() {
    return Objects.hash(sha1, hash, hashType, name, displayName, versionName, owner, createdDate, status, statusInformation, documentVersion, description, parameters, platformTypes, documentType, schemaVersion, latestVersion, defaultVersion, documentFormat, targetType, tags, attachmentsInformation, requires, author, reviewInformation, approvedVersion, pendingReviewVersion, reviewStatus, category, categoryEnum);
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class DocumentDescription {\n");
    sb.append("    sha1: ").append(toIndentedString(sha1)).append("\n");
    sb.append("    hash: ").append(toIndentedString(hash)).append("\n");
    sb.append("    hashType: ").append(toIndentedString(hashType)).append("\n");
    sb.append("    name: ").append(toIndentedString(name)).append("\n");
    sb.append("    displayName: ").append(toIndentedString(displayName)).append("\n");
    sb.append("    versionName: ").append(toIndentedString(versionName)).append("\n");
    sb.append("    owner: ").append(toIndentedString(owner)).append("\n");
    sb.append("    createdDate: ").append(toIndentedString(createdDate)).append("\n");
    sb.append("    status: ").append(toIndentedString(status)).append("\n");
    sb.append("    statusInformation: ").append(toIndentedString(statusInformation)).append("\n");
    sb.append("    documentVersion: ").append(toIndentedString(documentVersion)).append("\n");
    sb.append("    description: ").append(toIndentedString(description)).append("\n");
    sb.append("    parameters: ").append(toIndentedString(parameters)).append("\n");
    sb.append("    platformTypes: ").append(toIndentedString(platformTypes)).append("\n");
    sb.append("    documentType: ").append(toIndentedString(documentType)).append("\n");
    sb.append("    schemaVersion: ").append(toIndentedString(schemaVersion)).append("\n");
    sb.append("    latestVersion: ").append(toIndentedString(latestVersion)).append("\n");
    sb.append("    defaultVersion: ").append(toIndentedString(defaultVersion)).append("\n");
    sb.append("    documentFormat: ").append(toIndentedString(documentFormat)).append("\n");
    sb.append("    targetType: ").append(toIndentedString(targetType)).append("\n");
    sb.append("    tags: ").append(toIndentedString(tags)).append("\n");
    sb.append("    attachmentsInformation: ").append(toIndentedString(attachmentsInformation)).append("\n");
    sb.append("    requires: ").append(toIndentedString(requires)).append("\n");
    sb.append("    author: ").append(toIndentedString(author)).append("\n");
    sb.append("    reviewInformation: ").append(toIndentedString(reviewInformation)).append("\n");
    sb.append("    approvedVersion: ").append(toIndentedString(approvedVersion)).append("\n");
    sb.append("    pendingReviewVersion: ").append(toIndentedString(pendingReviewVersion)).append("\n");
    sb.append("    reviewStatus: ").append(toIndentedString(reviewStatus)).append("\n");
    sb.append("    category: ").append(toIndentedString(category)).append("\n");
    sb.append("    categoryEnum: ").append(toIndentedString(categoryEnum)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }


  public static HashSet<String> openapiFields;
  public static HashSet<String> openapiRequiredFields;

  static {
    // a set of all properties/fields (JSON key names)
    openapiFields = new HashSet<String>();
    openapiFields.add("Sha1");
    openapiFields.add("Hash");
    openapiFields.add("HashType");
    openapiFields.add("Name");
    openapiFields.add("DisplayName");
    openapiFields.add("VersionName");
    openapiFields.add("Owner");
    openapiFields.add("CreatedDate");
    openapiFields.add("Status");
    openapiFields.add("StatusInformation");
    openapiFields.add("DocumentVersion");
    openapiFields.add("Description");
    openapiFields.add("Parameters");
    openapiFields.add("PlatformTypes");
    openapiFields.add("DocumentType");
    openapiFields.add("SchemaVersion");
    openapiFields.add("LatestVersion");
    openapiFields.add("DefaultVersion");
    openapiFields.add("DocumentFormat");
    openapiFields.add("TargetType");
    openapiFields.add("Tags");
    openapiFields.add("AttachmentsInformation");
    openapiFields.add("Requires");
    openapiFields.add("Author");
    openapiFields.add("ReviewInformation");
    openapiFields.add("ApprovedVersion");
    openapiFields.add("PendingReviewVersion");
    openapiFields.add("ReviewStatus");
    openapiFields.add("Category");
    openapiFields.add("CategoryEnum");

    // a set of required properties/fields (JSON key names)
    openapiRequiredFields = new HashSet<String>();
  }

  /**
   * Validates the JSON Element and throws an exception if issues found
   *
   * @param jsonElement JSON Element
   * @throws IOException if the JSON Element is invalid with respect to DocumentDescription
   */
  public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      if (jsonElement == null) {
        if (!DocumentDescription.openapiRequiredFields.isEmpty()) { // has required fields but JSON element is null
          throw new IllegalArgumentException(String.format("The required field(s) %s in DocumentDescription is not found in the empty JSON string", DocumentDescription.openapiRequiredFields.toString()));
        }
      }

      Set<Map.Entry<String, JsonElement>> entries = jsonElement.getAsJsonObject().entrySet();
      // check to see if the JSON string contains additional fields
      for (Map.Entry<String, JsonElement> entry : entries) {
        if (!DocumentDescription.openapiFields.contains(entry.getKey())) {
          throw new IllegalArgumentException(String.format("The field `%s` in the JSON string is not defined in the `DocumentDescription` properties. JSON: %s", entry.getKey(), jsonElement.toString()));
        }
      }
        JsonObject jsonObj = jsonElement.getAsJsonObject();
      // validate the optional field `Sha1`
      if (jsonObj.get("Sha1") != null && !jsonObj.get("Sha1").isJsonNull()) {
        String.validateJsonElement(jsonObj.get("Sha1"));
      }
      // validate the optional field `Hash`
      if (jsonObj.get("Hash") != null && !jsonObj.get("Hash").isJsonNull()) {
        String.validateJsonElement(jsonObj.get("Hash"));
      }
      // validate the optional field `HashType`
      if (jsonObj.get("HashType") != null && !jsonObj.get("HashType").isJsonNull()) {
        DocumentHashType.validateJsonElement(jsonObj.get("HashType"));
      }
      // validate the optional field `Name`
      if (jsonObj.get("Name") != null && !jsonObj.get("Name").isJsonNull()) {
        String.validateJsonElement(jsonObj.get("Name"));
      }
      // validate the optional field `DisplayName`
      if (jsonObj.get("DisplayName") != null && !jsonObj.get("DisplayName").isJsonNull()) {
        String.validateJsonElement(jsonObj.get("DisplayName"));
      }
      // validate the optional field `VersionName`
      if (jsonObj.get("VersionName") != null && !jsonObj.get("VersionName").isJsonNull()) {
        String.validateJsonElement(jsonObj.get("VersionName"));
      }
      // validate the optional field `Owner`
      if (jsonObj.get("Owner") != null && !jsonObj.get("Owner").isJsonNull()) {
        String.validateJsonElement(jsonObj.get("Owner"));
      }
      // validate the optional field `CreatedDate`
      if (jsonObj.get("CreatedDate") != null && !jsonObj.get("CreatedDate").isJsonNull()) {
        OffsetDateTime.validateJsonElement(jsonObj.get("CreatedDate"));
      }
      // validate the optional field `Status`
      if (jsonObj.get("Status") != null && !jsonObj.get("Status").isJsonNull()) {
        DocumentStatus.validateJsonElement(jsonObj.get("Status"));
      }
      // validate the optional field `StatusInformation`
      if (jsonObj.get("StatusInformation") != null && !jsonObj.get("StatusInformation").isJsonNull()) {
        String.validateJsonElement(jsonObj.get("StatusInformation"));
      }
      // validate the optional field `DocumentVersion`
      if (jsonObj.get("DocumentVersion") != null && !jsonObj.get("DocumentVersion").isJsonNull()) {
        String.validateJsonElement(jsonObj.get("DocumentVersion"));
      }
      // validate the optional field `Description`
      if (jsonObj.get("Description") != null && !jsonObj.get("Description").isJsonNull()) {
        String.validateJsonElement(jsonObj.get("Description"));
      }
      // validate the optional field `Parameters`
      if (jsonObj.get("Parameters") != null && !jsonObj.get("Parameters").isJsonNull()) {
        List.validateJsonElement(jsonObj.get("Parameters"));
      }
      // validate the optional field `PlatformTypes`
      if (jsonObj.get("PlatformTypes") != null && !jsonObj.get("PlatformTypes").isJsonNull()) {
        List.validateJsonElement(jsonObj.get("PlatformTypes"));
      }
      // validate the optional field `DocumentType`
      if (jsonObj.get("DocumentType") != null && !jsonObj.get("DocumentType").isJsonNull()) {
        DocumentType.validateJsonElement(jsonObj.get("DocumentType"));
      }
      // validate the optional field `SchemaVersion`
      if (jsonObj.get("SchemaVersion") != null && !jsonObj.get("SchemaVersion").isJsonNull()) {
        String.validateJsonElement(jsonObj.get("SchemaVersion"));
      }
      // validate the optional field `LatestVersion`
      if (jsonObj.get("LatestVersion") != null && !jsonObj.get("LatestVersion").isJsonNull()) {
        String.validateJsonElement(jsonObj.get("LatestVersion"));
      }
      // validate the optional field `DefaultVersion`
      if (jsonObj.get("DefaultVersion") != null && !jsonObj.get("DefaultVersion").isJsonNull()) {
        String.validateJsonElement(jsonObj.get("DefaultVersion"));
      }
      // validate the optional field `DocumentFormat`
      if (jsonObj.get("DocumentFormat") != null && !jsonObj.get("DocumentFormat").isJsonNull()) {
        DocumentFormat.validateJsonElement(jsonObj.get("DocumentFormat"));
      }
      // validate the optional field `TargetType`
      if (jsonObj.get("TargetType") != null && !jsonObj.get("TargetType").isJsonNull()) {
        String.validateJsonElement(jsonObj.get("TargetType"));
      }
      // validate the optional field `Tags`
      if (jsonObj.get("Tags") != null && !jsonObj.get("Tags").isJsonNull()) {
        List.validateJsonElement(jsonObj.get("Tags"));
      }
      // validate the optional field `AttachmentsInformation`
      if (jsonObj.get("AttachmentsInformation") != null && !jsonObj.get("AttachmentsInformation").isJsonNull()) {
        List.validateJsonElement(jsonObj.get("AttachmentsInformation"));
      }
      // validate the optional field `Requires`
      if (jsonObj.get("Requires") != null && !jsonObj.get("Requires").isJsonNull()) {
        List.validateJsonElement(jsonObj.get("Requires"));
      }
      // validate the optional field `Author`
      if (jsonObj.get("Author") != null && !jsonObj.get("Author").isJsonNull()) {
        String.validateJsonElement(jsonObj.get("Author"));
      }
      // validate the optional field `ReviewInformation`
      if (jsonObj.get("ReviewInformation") != null && !jsonObj.get("ReviewInformation").isJsonNull()) {
        List.validateJsonElement(jsonObj.get("ReviewInformation"));
      }
      // validate the optional field `ApprovedVersion`
      if (jsonObj.get("ApprovedVersion") != null && !jsonObj.get("ApprovedVersion").isJsonNull()) {
        String.validateJsonElement(jsonObj.get("ApprovedVersion"));
      }
      // validate the optional field `PendingReviewVersion`
      if (jsonObj.get("PendingReviewVersion") != null && !jsonObj.get("PendingReviewVersion").isJsonNull()) {
        String.validateJsonElement(jsonObj.get("PendingReviewVersion"));
      }
      // validate the optional field `ReviewStatus`
      if (jsonObj.get("ReviewStatus") != null && !jsonObj.get("ReviewStatus").isJsonNull()) {
        ReviewStatus.validateJsonElement(jsonObj.get("ReviewStatus"));
      }
      // validate the optional field `Category`
      if (jsonObj.get("Category") != null && !jsonObj.get("Category").isJsonNull()) {
        List.validateJsonElement(jsonObj.get("Category"));
      }
      // validate the optional field `CategoryEnum`
      if (jsonObj.get("CategoryEnum") != null && !jsonObj.get("CategoryEnum").isJsonNull()) {
        List.validateJsonElement(jsonObj.get("CategoryEnum"));
      }
  }

  public static class CustomTypeAdapterFactory implements TypeAdapterFactory {
    @SuppressWarnings("unchecked")
    @Override
    public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
       if (!DocumentDescription.class.isAssignableFrom(type.getRawType())) {
         return null; // this class only serializes 'DocumentDescription' and its subtypes
       }
       final TypeAdapter<JsonElement> elementAdapter = gson.getAdapter(JsonElement.class);
       final TypeAdapter<DocumentDescription> thisAdapter
                        = gson.getDelegateAdapter(this, TypeToken.get(DocumentDescription.class));

       return (TypeAdapter<T>) new TypeAdapter<DocumentDescription>() {
           @Override
           public void write(JsonWriter out, DocumentDescription value) throws IOException {
             JsonObject obj = thisAdapter.toJsonTree(value).getAsJsonObject();
             elementAdapter.write(out, obj);
           }

           @Override
           public DocumentDescription read(JsonReader in) throws IOException {
             JsonElement jsonElement = elementAdapter.read(in);
             validateJsonElement(jsonElement);
             return thisAdapter.fromJsonTree(jsonElement);
           }

       }.nullSafe();
    }
  }

  /**
   * Create an instance of DocumentDescription given an JSON string
   *
   * @param jsonString JSON string
   * @return An instance of DocumentDescription
   * @throws IOException if the JSON string is invalid with respect to DocumentDescription
   */
  public static DocumentDescription fromJson(String jsonString) throws IOException {
    return JSON.getGson().fromJson(jsonString, DocumentDescription.class);
  }

  /**
   * Convert an instance of DocumentDescription to an JSON string
   *
   * @return JSON string
   */
  public String toJson() {
    return JSON.getGson().toJson(this);
  }
}

