/**
 * Amazon Machine Learning
 * Definition of the public APIs exposed by Amazon Machine Learning
 *
 * The version of the OpenAPI document: 2014-12-12
 * Contact: mike.ralphson@gmail.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

#include "OAIDescribeBatchPredictionsInput.h"

#include <QDebug>
#include <QJsonArray>
#include <QJsonDocument>
#include <QObject>

#include "OAIHelpers.h"

namespace OpenAPI {

OAIDescribeBatchPredictionsInput::OAIDescribeBatchPredictionsInput(QString json) {
    this->initializeModel();
    this->fromJson(json);
}

OAIDescribeBatchPredictionsInput::OAIDescribeBatchPredictionsInput() {
    this->initializeModel();
}

OAIDescribeBatchPredictionsInput::~OAIDescribeBatchPredictionsInput() {}

void OAIDescribeBatchPredictionsInput::initializeModel() {

    m_filter_variable_isSet = false;
    m_filter_variable_isValid = false;

    m_eq_isSet = false;
    m_eq_isValid = false;

    m_gt_isSet = false;
    m_gt_isValid = false;

    m_lt_isSet = false;
    m_lt_isValid = false;

    m_ge_isSet = false;
    m_ge_isValid = false;

    m_le_isSet = false;
    m_le_isValid = false;

    m_ne_isSet = false;
    m_ne_isValid = false;

    m_prefix_isSet = false;
    m_prefix_isValid = false;

    m_sort_order_isSet = false;
    m_sort_order_isValid = false;

    m_next_token_isSet = false;
    m_next_token_isValid = false;

    m_limit_isSet = false;
    m_limit_isValid = false;
}

void OAIDescribeBatchPredictionsInput::fromJson(QString jsonString) {
    QByteArray array(jsonString.toStdString().c_str());
    QJsonDocument doc = QJsonDocument::fromJson(array);
    QJsonObject jsonObject = doc.object();
    this->fromJsonObject(jsonObject);
}

void OAIDescribeBatchPredictionsInput::fromJsonObject(QJsonObject json) {

    m_filter_variable_isValid = ::OpenAPI::fromJsonValue(m_filter_variable, json[QString("FilterVariable")]);
    m_filter_variable_isSet = !json[QString("FilterVariable")].isNull() && m_filter_variable_isValid;

    m_eq_isValid = ::OpenAPI::fromJsonValue(m_eq, json[QString("EQ")]);
    m_eq_isSet = !json[QString("EQ")].isNull() && m_eq_isValid;

    m_gt_isValid = ::OpenAPI::fromJsonValue(m_gt, json[QString("GT")]);
    m_gt_isSet = !json[QString("GT")].isNull() && m_gt_isValid;

    m_lt_isValid = ::OpenAPI::fromJsonValue(m_lt, json[QString("LT")]);
    m_lt_isSet = !json[QString("LT")].isNull() && m_lt_isValid;

    m_ge_isValid = ::OpenAPI::fromJsonValue(m_ge, json[QString("GE")]);
    m_ge_isSet = !json[QString("GE")].isNull() && m_ge_isValid;

    m_le_isValid = ::OpenAPI::fromJsonValue(m_le, json[QString("LE")]);
    m_le_isSet = !json[QString("LE")].isNull() && m_le_isValid;

    m_ne_isValid = ::OpenAPI::fromJsonValue(m_ne, json[QString("NE")]);
    m_ne_isSet = !json[QString("NE")].isNull() && m_ne_isValid;

    m_prefix_isValid = ::OpenAPI::fromJsonValue(m_prefix, json[QString("Prefix")]);
    m_prefix_isSet = !json[QString("Prefix")].isNull() && m_prefix_isValid;

    m_sort_order_isValid = ::OpenAPI::fromJsonValue(m_sort_order, json[QString("SortOrder")]);
    m_sort_order_isSet = !json[QString("SortOrder")].isNull() && m_sort_order_isValid;

    m_next_token_isValid = ::OpenAPI::fromJsonValue(m_next_token, json[QString("NextToken")]);
    m_next_token_isSet = !json[QString("NextToken")].isNull() && m_next_token_isValid;

    m_limit_isValid = ::OpenAPI::fromJsonValue(m_limit, json[QString("Limit")]);
    m_limit_isSet = !json[QString("Limit")].isNull() && m_limit_isValid;
}

QString OAIDescribeBatchPredictionsInput::asJson() const {
    QJsonObject obj = this->asJsonObject();
    QJsonDocument doc(obj);
    QByteArray bytes = doc.toJson();
    return QString(bytes);
}

QJsonObject OAIDescribeBatchPredictionsInput::asJsonObject() const {
    QJsonObject obj;
    if (m_filter_variable.isSet()) {
        obj.insert(QString("FilterVariable"), ::OpenAPI::toJsonValue(m_filter_variable));
    }
    if (m_eq_isSet) {
        obj.insert(QString("EQ"), ::OpenAPI::toJsonValue(m_eq));
    }
    if (m_gt_isSet) {
        obj.insert(QString("GT"), ::OpenAPI::toJsonValue(m_gt));
    }
    if (m_lt_isSet) {
        obj.insert(QString("LT"), ::OpenAPI::toJsonValue(m_lt));
    }
    if (m_ge_isSet) {
        obj.insert(QString("GE"), ::OpenAPI::toJsonValue(m_ge));
    }
    if (m_le_isSet) {
        obj.insert(QString("LE"), ::OpenAPI::toJsonValue(m_le));
    }
    if (m_ne_isSet) {
        obj.insert(QString("NE"), ::OpenAPI::toJsonValue(m_ne));
    }
    if (m_prefix_isSet) {
        obj.insert(QString("Prefix"), ::OpenAPI::toJsonValue(m_prefix));
    }
    if (m_sort_order.isSet()) {
        obj.insert(QString("SortOrder"), ::OpenAPI::toJsonValue(m_sort_order));
    }
    if (m_next_token_isSet) {
        obj.insert(QString("NextToken"), ::OpenAPI::toJsonValue(m_next_token));
    }
    if (m_limit_isSet) {
        obj.insert(QString("Limit"), ::OpenAPI::toJsonValue(m_limit));
    }
    return obj;
}

OAIBatchPredictionFilterVariable OAIDescribeBatchPredictionsInput::getFilterVariable() const {
    return m_filter_variable;
}
void OAIDescribeBatchPredictionsInput::setFilterVariable(const OAIBatchPredictionFilterVariable &filter_variable) {
    m_filter_variable = filter_variable;
    m_filter_variable_isSet = true;
}

bool OAIDescribeBatchPredictionsInput::is_filter_variable_Set() const{
    return m_filter_variable_isSet;
}

bool OAIDescribeBatchPredictionsInput::is_filter_variable_Valid() const{
    return m_filter_variable_isValid;
}

QString OAIDescribeBatchPredictionsInput::getEq() const {
    return m_eq;
}
void OAIDescribeBatchPredictionsInput::setEq(const QString &eq) {
    m_eq = eq;
    m_eq_isSet = true;
}

bool OAIDescribeBatchPredictionsInput::is_eq_Set() const{
    return m_eq_isSet;
}

bool OAIDescribeBatchPredictionsInput::is_eq_Valid() const{
    return m_eq_isValid;
}

QString OAIDescribeBatchPredictionsInput::getGt() const {
    return m_gt;
}
void OAIDescribeBatchPredictionsInput::setGt(const QString &gt) {
    m_gt = gt;
    m_gt_isSet = true;
}

bool OAIDescribeBatchPredictionsInput::is_gt_Set() const{
    return m_gt_isSet;
}

bool OAIDescribeBatchPredictionsInput::is_gt_Valid() const{
    return m_gt_isValid;
}

QString OAIDescribeBatchPredictionsInput::getLt() const {
    return m_lt;
}
void OAIDescribeBatchPredictionsInput::setLt(const QString &lt) {
    m_lt = lt;
    m_lt_isSet = true;
}

bool OAIDescribeBatchPredictionsInput::is_lt_Set() const{
    return m_lt_isSet;
}

bool OAIDescribeBatchPredictionsInput::is_lt_Valid() const{
    return m_lt_isValid;
}

QString OAIDescribeBatchPredictionsInput::getGe() const {
    return m_ge;
}
void OAIDescribeBatchPredictionsInput::setGe(const QString &ge) {
    m_ge = ge;
    m_ge_isSet = true;
}

bool OAIDescribeBatchPredictionsInput::is_ge_Set() const{
    return m_ge_isSet;
}

bool OAIDescribeBatchPredictionsInput::is_ge_Valid() const{
    return m_ge_isValid;
}

QString OAIDescribeBatchPredictionsInput::getLe() const {
    return m_le;
}
void OAIDescribeBatchPredictionsInput::setLe(const QString &le) {
    m_le = le;
    m_le_isSet = true;
}

bool OAIDescribeBatchPredictionsInput::is_le_Set() const{
    return m_le_isSet;
}

bool OAIDescribeBatchPredictionsInput::is_le_Valid() const{
    return m_le_isValid;
}

QString OAIDescribeBatchPredictionsInput::getNe() const {
    return m_ne;
}
void OAIDescribeBatchPredictionsInput::setNe(const QString &ne) {
    m_ne = ne;
    m_ne_isSet = true;
}

bool OAIDescribeBatchPredictionsInput::is_ne_Set() const{
    return m_ne_isSet;
}

bool OAIDescribeBatchPredictionsInput::is_ne_Valid() const{
    return m_ne_isValid;
}

QString OAIDescribeBatchPredictionsInput::getPrefix() const {
    return m_prefix;
}
void OAIDescribeBatchPredictionsInput::setPrefix(const QString &prefix) {
    m_prefix = prefix;
    m_prefix_isSet = true;
}

bool OAIDescribeBatchPredictionsInput::is_prefix_Set() const{
    return m_prefix_isSet;
}

bool OAIDescribeBatchPredictionsInput::is_prefix_Valid() const{
    return m_prefix_isValid;
}

OAISortOrder OAIDescribeBatchPredictionsInput::getSortOrder() const {
    return m_sort_order;
}
void OAIDescribeBatchPredictionsInput::setSortOrder(const OAISortOrder &sort_order) {
    m_sort_order = sort_order;
    m_sort_order_isSet = true;
}

bool OAIDescribeBatchPredictionsInput::is_sort_order_Set() const{
    return m_sort_order_isSet;
}

bool OAIDescribeBatchPredictionsInput::is_sort_order_Valid() const{
    return m_sort_order_isValid;
}

QString OAIDescribeBatchPredictionsInput::getNextToken() const {
    return m_next_token;
}
void OAIDescribeBatchPredictionsInput::setNextToken(const QString &next_token) {
    m_next_token = next_token;
    m_next_token_isSet = true;
}

bool OAIDescribeBatchPredictionsInput::is_next_token_Set() const{
    return m_next_token_isSet;
}

bool OAIDescribeBatchPredictionsInput::is_next_token_Valid() const{
    return m_next_token_isValid;
}

qint32 OAIDescribeBatchPredictionsInput::getLimit() const {
    return m_limit;
}
void OAIDescribeBatchPredictionsInput::setLimit(const qint32 &limit) {
    m_limit = limit;
    m_limit_isSet = true;
}

bool OAIDescribeBatchPredictionsInput::is_limit_Set() const{
    return m_limit_isSet;
}

bool OAIDescribeBatchPredictionsInput::is_limit_Valid() const{
    return m_limit_isValid;
}

bool OAIDescribeBatchPredictionsInput::isSet() const {
    bool isObjectUpdated = false;
    do {
        if (m_filter_variable.isSet()) {
            isObjectUpdated = true;
            break;
        }

        if (m_eq_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_gt_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_lt_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_ge_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_le_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_ne_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_prefix_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_sort_order.isSet()) {
            isObjectUpdated = true;
            break;
        }

        if (m_next_token_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_limit_isSet) {
            isObjectUpdated = true;
            break;
        }
    } while (false);
    return isObjectUpdated;
}

bool OAIDescribeBatchPredictionsInput::isValid() const {
    // only required properties are required for the object to be considered valid
    return true;
}

} // namespace OpenAPI
