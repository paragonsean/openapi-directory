/*
 * Wealth Reader API
 * Las APIs regulatorias basadas en PSD2 proporcionan acceso a cierta información financiera como saldos de cuentas bancarias y transacciones. Sin embargo, hay otras fuentes de información patrimonial que no son accesibles por estas APIs. La API de Wealth Reader amplía la información ofrecida por las APIs regulatorias proporcionando acceso en tiempo real a las fuentes patrimoniales adicionales en cualquier entidad del mundo. Existen otros dos documentos relacionados que te ayudarán a integrar la API de Wealth Reader. Uno es la guía de integración del widget Javascript: https://docs-es.wealthreader.com/, y el  otro una colección Postman basada en esta documentación.
 *
 * The version of the OpenAPI document: 1.0.0
 * Contact: info@wealthreader.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package org.openapitools.client.api;

import org.openapitools.client.ApiCallback;
import org.openapitools.client.ApiClient;
import org.openapitools.client.ApiException;
import org.openapitools.client.ApiResponse;
import org.openapitools.client.Configuration;
import org.openapitools.client.Pair;
import org.openapitools.client.ProgressRequestBody;
import org.openapitools.client.ProgressResponseBody;

import com.google.gson.reflect.TypeToken;

import java.io.IOException;


import org.openapitools.client.model.EntityData;
import org.openapitools.client.model.Error;

import java.lang.reflect.Type;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

public class EntityDataApi {
    private ApiClient localVarApiClient;
    private int localHostIndex;
    private String localCustomBaseUrl;

    public EntityDataApi() {
        this(Configuration.getDefaultApiClient());
    }

    public EntityDataApi(ApiClient apiClient) {
        this.localVarApiClient = apiClient;
    }

    public ApiClient getApiClient() {
        return localVarApiClient;
    }

    public void setApiClient(ApiClient apiClient) {
        this.localVarApiClient = apiClient;
    }

    public int getHostIndex() {
        return localHostIndex;
    }

    public void setHostIndex(int hostIndex) {
        this.localHostIndex = hostIndex;
    }

    public String getCustomBaseUrl() {
        return localCustomBaseUrl;
    }

    public void setCustomBaseUrl(String customBaseUrl) {
        this.localCustomBaseUrl = customBaseUrl;
    }

    /**
     * Build call for entitiesGet
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> listado de entidades </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> error </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call entitiesGetCall(final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/entities";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] {  };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call entitiesGetValidateBeforeCall(final ApiCallback _callback) throws ApiException {
        return entitiesGetCall(_callback);

    }

    /**
     * Obtiene el listado de entidades soportadas
     * Obtiene el listado de entidades soportadas y la información necesaria para dibujar el formulario de login de la entidad. 
     * @return List&lt;List&lt;Object&gt;&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> listado de entidades </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> error </td><td>  -  </td></tr>
     </table>
     */
    public List<List<Object>> entitiesGet() throws ApiException {
        ApiResponse<List<List<Object>>> localVarResp = entitiesGetWithHttpInfo();
        return localVarResp.getData();
    }

    /**
     * Obtiene el listado de entidades soportadas
     * Obtiene el listado de entidades soportadas y la información necesaria para dibujar el formulario de login de la entidad. 
     * @return ApiResponse&lt;List&lt;List&lt;Object&gt;&gt;&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> listado de entidades </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> error </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<List<List<Object>>> entitiesGetWithHttpInfo() throws ApiException {
        okhttp3.Call localVarCall = entitiesGetValidateBeforeCall(null);
        Type localVarReturnType = new TypeToken<List<List<Object>>>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Obtiene el listado de entidades soportadas (asynchronously)
     * Obtiene el listado de entidades soportadas y la información necesaria para dibujar el formulario de login de la entidad. 
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> listado de entidades </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> error </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call entitiesGetAsync(final ApiCallback<List<List<Object>>> _callback) throws ApiException {

        okhttp3.Call localVarCall = entitiesGetValidateBeforeCall(_callback);
        Type localVarReturnType = new TypeToken<List<List<Object>>>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for entitiesPost
     * @param OTP Solo necesario cuando se esté completando la seguda petición de un login con 2 factores de autenticación, si el tipo de desafío es OTP. Requiere la clave que la entidad le ha enviado al usario final (optional)
     * @param SESSION Solo necesario cuando se esté completando la seguda petición de un login con 2 factores de autenticación. Requiere el valor de SESSION obtenido en la primera petición (optional)
     * @param apiKey Identifica al cliente en el servicio (optional)
     * @param code Nombre de la entidad. El listado completo está disponible con GET (optional)
     * @param contractCode Solo necesario cuando el usuario puede acceder a más de un contrato. El listado de contratos disponibles se obtiene al realizar una conexión con un usuario con opción a trabajar con varios contratos en su entidad (que al hacer login en su banca online ve como primera opción una pantalla de selección de contratos) y cuya llamada a la API no se le ha especificado un valor a contract_code (optional)
     * @param documentType Tipo de documento, requerido según la entidad. Si es requerido o no, está indicado en el listado de entidades. Ver definición. (optional)
     * @param password Contraseña (optional)
     * @param secondPassword Segunda contraseña, requerida según la entidad. (optional)
     * @param token Valor para credenciales custodiadas, tokenizadas previamente mediante una llamada a este método con el valor de tokenize&#x3D;true. Están disponibles los siguientes usuarios Mock: MOCKDATA, respuesta OK; MOCKOTP, respuesta con desafío OTP; MOCKLOGINKO, respuesta con error de login (optional)
     * @param tokenize Indica si Wealth Reader debe custodiar los credenciales, de tal manera que incluído en el body de respuesta estará un token que permite conectar con la entidad sin necesidad de conocer los credenciales: document_type, user, password, second_password, contract_code (optional, default to false)
     * @param user Usuario. Están disponibles los siguientes usuarios Mock: MOCKDATA, respuesta OK; MOCKOTP, respuesta con desafío OTP; MOCKLOGINKO, respuesta con error de login (optional)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> datos obtenidos de la entidad </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> error </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call entitiesPostCall(String OTP, String SESSION, String apiKey, String code, String contractCode, String documentType, String password, String secondPassword, String token, Boolean tokenize, String user, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/entities";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (OTP != null) {
            localVarFormParams.put("OTP", OTP);
        }

        if (SESSION != null) {
            localVarFormParams.put("SESSION", SESSION);
        }

        if (apiKey != null) {
            localVarFormParams.put("api_key", apiKey);
        }

        if (code != null) {
            localVarFormParams.put("code", code);
        }

        if (contractCode != null) {
            localVarFormParams.put("contract_code", contractCode);
        }

        if (documentType != null) {
            localVarFormParams.put("document_type", documentType);
        }

        if (password != null) {
            localVarFormParams.put("password", password);
        }

        if (secondPassword != null) {
            localVarFormParams.put("second_password", secondPassword);
        }

        if (token != null) {
            localVarFormParams.put("token", token);
        }

        if (tokenize != null) {
            localVarFormParams.put("tokenize", tokenize);
        }

        if (user != null) {
            localVarFormParams.put("user", user);
        }

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            "application/x-www-form-urlencoded"
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] {  };
        return localVarApiClient.buildCall(basePath, localVarPath, "POST", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call entitiesPostValidateBeforeCall(String OTP, String SESSION, String apiKey, String code, String contractCode, String documentType, String password, String secondPassword, String token, Boolean tokenize, String user, final ApiCallback _callback) throws ApiException {
        return entitiesPostCall(OTP, SESSION, apiKey, code, contractCode, documentType, password, secondPassword, token, tokenize, user, _callback);

    }

    /**
     * Obtiene los activos financieros y el detalle de su composición
     * Obtiene los activos financieros y el detalle de su composición de carteras de inversión compuestas por acciones o fondos, tarjetas de crédito, seguros y préstamos. Incluye información de titularidad de cada uno de los activos así como identificadores únicos que facilitan el tratamiento del dato. Es posible obtener datos Mock. Consulte con el equipo técnico cómo hacerlo. 
     * @param OTP Solo necesario cuando se esté completando la seguda petición de un login con 2 factores de autenticación, si el tipo de desafío es OTP. Requiere la clave que la entidad le ha enviado al usario final (optional)
     * @param SESSION Solo necesario cuando se esté completando la seguda petición de un login con 2 factores de autenticación. Requiere el valor de SESSION obtenido en la primera petición (optional)
     * @param apiKey Identifica al cliente en el servicio (optional)
     * @param code Nombre de la entidad. El listado completo está disponible con GET (optional)
     * @param contractCode Solo necesario cuando el usuario puede acceder a más de un contrato. El listado de contratos disponibles se obtiene al realizar una conexión con un usuario con opción a trabajar con varios contratos en su entidad (que al hacer login en su banca online ve como primera opción una pantalla de selección de contratos) y cuya llamada a la API no se le ha especificado un valor a contract_code (optional)
     * @param documentType Tipo de documento, requerido según la entidad. Si es requerido o no, está indicado en el listado de entidades. Ver definición. (optional)
     * @param password Contraseña (optional)
     * @param secondPassword Segunda contraseña, requerida según la entidad. (optional)
     * @param token Valor para credenciales custodiadas, tokenizadas previamente mediante una llamada a este método con el valor de tokenize&#x3D;true. Están disponibles los siguientes usuarios Mock: MOCKDATA, respuesta OK; MOCKOTP, respuesta con desafío OTP; MOCKLOGINKO, respuesta con error de login (optional)
     * @param tokenize Indica si Wealth Reader debe custodiar los credenciales, de tal manera que incluído en el body de respuesta estará un token que permite conectar con la entidad sin necesidad de conocer los credenciales: document_type, user, password, second_password, contract_code (optional, default to false)
     * @param user Usuario. Están disponibles los siguientes usuarios Mock: MOCKDATA, respuesta OK; MOCKOTP, respuesta con desafío OTP; MOCKLOGINKO, respuesta con error de login (optional)
     * @return List&lt;EntityData&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> datos obtenidos de la entidad </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> error </td><td>  -  </td></tr>
     </table>
     */
    public List<EntityData> entitiesPost(String OTP, String SESSION, String apiKey, String code, String contractCode, String documentType, String password, String secondPassword, String token, Boolean tokenize, String user) throws ApiException {
        ApiResponse<List<EntityData>> localVarResp = entitiesPostWithHttpInfo(OTP, SESSION, apiKey, code, contractCode, documentType, password, secondPassword, token, tokenize, user);
        return localVarResp.getData();
    }

    /**
     * Obtiene los activos financieros y el detalle de su composición
     * Obtiene los activos financieros y el detalle de su composición de carteras de inversión compuestas por acciones o fondos, tarjetas de crédito, seguros y préstamos. Incluye información de titularidad de cada uno de los activos así como identificadores únicos que facilitan el tratamiento del dato. Es posible obtener datos Mock. Consulte con el equipo técnico cómo hacerlo. 
     * @param OTP Solo necesario cuando se esté completando la seguda petición de un login con 2 factores de autenticación, si el tipo de desafío es OTP. Requiere la clave que la entidad le ha enviado al usario final (optional)
     * @param SESSION Solo necesario cuando se esté completando la seguda petición de un login con 2 factores de autenticación. Requiere el valor de SESSION obtenido en la primera petición (optional)
     * @param apiKey Identifica al cliente en el servicio (optional)
     * @param code Nombre de la entidad. El listado completo está disponible con GET (optional)
     * @param contractCode Solo necesario cuando el usuario puede acceder a más de un contrato. El listado de contratos disponibles se obtiene al realizar una conexión con un usuario con opción a trabajar con varios contratos en su entidad (que al hacer login en su banca online ve como primera opción una pantalla de selección de contratos) y cuya llamada a la API no se le ha especificado un valor a contract_code (optional)
     * @param documentType Tipo de documento, requerido según la entidad. Si es requerido o no, está indicado en el listado de entidades. Ver definición. (optional)
     * @param password Contraseña (optional)
     * @param secondPassword Segunda contraseña, requerida según la entidad. (optional)
     * @param token Valor para credenciales custodiadas, tokenizadas previamente mediante una llamada a este método con el valor de tokenize&#x3D;true. Están disponibles los siguientes usuarios Mock: MOCKDATA, respuesta OK; MOCKOTP, respuesta con desafío OTP; MOCKLOGINKO, respuesta con error de login (optional)
     * @param tokenize Indica si Wealth Reader debe custodiar los credenciales, de tal manera que incluído en el body de respuesta estará un token que permite conectar con la entidad sin necesidad de conocer los credenciales: document_type, user, password, second_password, contract_code (optional, default to false)
     * @param user Usuario. Están disponibles los siguientes usuarios Mock: MOCKDATA, respuesta OK; MOCKOTP, respuesta con desafío OTP; MOCKLOGINKO, respuesta con error de login (optional)
     * @return ApiResponse&lt;List&lt;EntityData&gt;&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> datos obtenidos de la entidad </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> error </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<List<EntityData>> entitiesPostWithHttpInfo(String OTP, String SESSION, String apiKey, String code, String contractCode, String documentType, String password, String secondPassword, String token, Boolean tokenize, String user) throws ApiException {
        okhttp3.Call localVarCall = entitiesPostValidateBeforeCall(OTP, SESSION, apiKey, code, contractCode, documentType, password, secondPassword, token, tokenize, user, null);
        Type localVarReturnType = new TypeToken<List<EntityData>>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Obtiene los activos financieros y el detalle de su composición (asynchronously)
     * Obtiene los activos financieros y el detalle de su composición de carteras de inversión compuestas por acciones o fondos, tarjetas de crédito, seguros y préstamos. Incluye información de titularidad de cada uno de los activos así como identificadores únicos que facilitan el tratamiento del dato. Es posible obtener datos Mock. Consulte con el equipo técnico cómo hacerlo. 
     * @param OTP Solo necesario cuando se esté completando la seguda petición de un login con 2 factores de autenticación, si el tipo de desafío es OTP. Requiere la clave que la entidad le ha enviado al usario final (optional)
     * @param SESSION Solo necesario cuando se esté completando la seguda petición de un login con 2 factores de autenticación. Requiere el valor de SESSION obtenido en la primera petición (optional)
     * @param apiKey Identifica al cliente en el servicio (optional)
     * @param code Nombre de la entidad. El listado completo está disponible con GET (optional)
     * @param contractCode Solo necesario cuando el usuario puede acceder a más de un contrato. El listado de contratos disponibles se obtiene al realizar una conexión con un usuario con opción a trabajar con varios contratos en su entidad (que al hacer login en su banca online ve como primera opción una pantalla de selección de contratos) y cuya llamada a la API no se le ha especificado un valor a contract_code (optional)
     * @param documentType Tipo de documento, requerido según la entidad. Si es requerido o no, está indicado en el listado de entidades. Ver definición. (optional)
     * @param password Contraseña (optional)
     * @param secondPassword Segunda contraseña, requerida según la entidad. (optional)
     * @param token Valor para credenciales custodiadas, tokenizadas previamente mediante una llamada a este método con el valor de tokenize&#x3D;true. Están disponibles los siguientes usuarios Mock: MOCKDATA, respuesta OK; MOCKOTP, respuesta con desafío OTP; MOCKLOGINKO, respuesta con error de login (optional)
     * @param tokenize Indica si Wealth Reader debe custodiar los credenciales, de tal manera que incluído en el body de respuesta estará un token que permite conectar con la entidad sin necesidad de conocer los credenciales: document_type, user, password, second_password, contract_code (optional, default to false)
     * @param user Usuario. Están disponibles los siguientes usuarios Mock: MOCKDATA, respuesta OK; MOCKOTP, respuesta con desafío OTP; MOCKLOGINKO, respuesta con error de login (optional)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> datos obtenidos de la entidad </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> error </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call entitiesPostAsync(String OTP, String SESSION, String apiKey, String code, String contractCode, String documentType, String password, String secondPassword, String token, Boolean tokenize, String user, final ApiCallback<List<EntityData>> _callback) throws ApiException {

        okhttp3.Call localVarCall = entitiesPostValidateBeforeCall(OTP, SESSION, apiKey, code, contractCode, documentType, password, secondPassword, token, tokenize, user, _callback);
        Type localVarReturnType = new TypeToken<List<EntityData>>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for errorCodesGet
     * @param lang Idioma de la respuesta (optional, default to es)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Códigos de error junto con su descripción, posible motivo y cómo proceder </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> error </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call errorCodesGetCall(String lang, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/error-codes";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (lang != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("lang", lang));
        }

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] {  };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call errorCodesGetValidateBeforeCall(String lang, final ApiCallback _callback) throws ApiException {
        return errorCodesGetCall(lang, _callback);

    }

    /**
     * Listado de códigos de error
     * Listado de códigos de error. Presta especial atención a que no todos los códigos de error deben recibir el mismo tratamiento por parte de tu aplicación. Ante un error de password incorrecto no debes reintentar la llamada con los mismos parámetros, pero ante un error que te indique que la entidad está en mantenimiento sí puedes reintentarlo. Pide una sesión técnica con nuestro equipo para resolver cualquier duda sobre la gestión de errores. 
     * @param lang Idioma de la respuesta (optional, default to es)
     * @return List&lt;List&lt;List&lt;Object&gt;&gt;&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Códigos de error junto con su descripción, posible motivo y cómo proceder </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> error </td><td>  -  </td></tr>
     </table>
     */
    public List<List<List<Object>>> errorCodesGet(String lang) throws ApiException {
        ApiResponse<List<List<List<Object>>>> localVarResp = errorCodesGetWithHttpInfo(lang);
        return localVarResp.getData();
    }

    /**
     * Listado de códigos de error
     * Listado de códigos de error. Presta especial atención a que no todos los códigos de error deben recibir el mismo tratamiento por parte de tu aplicación. Ante un error de password incorrecto no debes reintentar la llamada con los mismos parámetros, pero ante un error que te indique que la entidad está en mantenimiento sí puedes reintentarlo. Pide una sesión técnica con nuestro equipo para resolver cualquier duda sobre la gestión de errores. 
     * @param lang Idioma de la respuesta (optional, default to es)
     * @return ApiResponse&lt;List&lt;List&lt;List&lt;Object&gt;&gt;&gt;&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Códigos de error junto con su descripción, posible motivo y cómo proceder </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> error </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<List<List<List<Object>>>> errorCodesGetWithHttpInfo(String lang) throws ApiException {
        okhttp3.Call localVarCall = errorCodesGetValidateBeforeCall(lang, null);
        Type localVarReturnType = new TypeToken<List<List<List<Object>>>>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Listado de códigos de error (asynchronously)
     * Listado de códigos de error. Presta especial atención a que no todos los códigos de error deben recibir el mismo tratamiento por parte de tu aplicación. Ante un error de password incorrecto no debes reintentar la llamada con los mismos parámetros, pero ante un error que te indique que la entidad está en mantenimiento sí puedes reintentarlo. Pide una sesión técnica con nuestro equipo para resolver cualquier duda sobre la gestión de errores. 
     * @param lang Idioma de la respuesta (optional, default to es)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Códigos de error junto con su descripción, posible motivo y cómo proceder </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> error </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call errorCodesGetAsync(String lang, final ApiCallback<List<List<List<Object>>>> _callback) throws ApiException {

        okhttp3.Call localVarCall = errorCodesGetValidateBeforeCall(lang, _callback);
        Type localVarReturnType = new TypeToken<List<List<List<Object>>>>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
}
