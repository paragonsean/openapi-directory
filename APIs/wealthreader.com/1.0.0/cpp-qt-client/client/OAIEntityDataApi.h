/**
 * Wealth Reader API
 * Las APIs regulatorias basadas en PSD2 proporcionan acceso a cierta información financiera como saldos de cuentas bancarias y transacciones. Sin embargo, hay otras fuentes de información patrimonial que no son accesibles por estas APIs. La API de Wealth Reader amplía la información ofrecida por las APIs regulatorias proporcionando acceso en tiempo real a las fuentes patrimoniales adicionales en cualquier entidad del mundo. Existen otros dos documentos relacionados que te ayudarán a integrar la API de Wealth Reader. Uno es la guía de integración del widget Javascript: https://docs-es.wealthreader.com/, y el  otro una colección Postman basada en esta documentación.
 *
 * The version of the OpenAPI document: 1.0.0
 * Contact: info@wealthreader.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

#ifndef OAI_OAIEntityDataApi_H
#define OAI_OAIEntityDataApi_H

#include "OAIHelpers.h"
#include "OAIHttpRequest.h"
#include "OAIServerConfiguration.h"
#include "OAIOauth.h"

#include "OAIEntity_data.h"
#include "OAIError.h"
#include "OAIObject.h"
#include <QJsonValue>
#include <QString>

#include <QObject>
#include <QByteArray>
#include <QStringList>
#include <QList>
#include <QNetworkAccessManager>

namespace OpenAPI {

class OAIEntityDataApi : public QObject {
    Q_OBJECT

public:
    OAIEntityDataApi(const int timeOut = 0);
    ~OAIEntityDataApi();

    void initializeServerConfigs();
    int setDefaultServerValue(int serverIndex,const QString &operation, const QString &variable,const QString &val);
    void setServerIndex(const QString &operation, int serverIndex);
    void setApiKey(const QString &apiKeyName, const QString &apiKey);
    void setBearerToken(const QString &token);
    void setUsername(const QString &username);
    void setPassword(const QString &password);
    void setTimeOut(const int timeOut);
    void setWorkingDirectory(const QString &path);
    void setNetworkAccessManager(QNetworkAccessManager* manager);
    int addServerConfiguration(const QString &operation, const QUrl &url, const QString &description = "", const QMap<QString, OAIServerVariable> &variables = QMap<QString, OAIServerVariable>());
    void setNewServerForAllOperations(const QUrl &url, const QString &description = "", const QMap<QString, OAIServerVariable> &variables =  QMap<QString, OAIServerVariable>());
    void setNewServer(const QString &operation, const QUrl &url, const QString &description = "", const QMap<QString, OAIServerVariable> &variables =  QMap<QString, OAIServerVariable>());
    void addHeaders(const QString &key, const QString &value);
    void enableRequestCompression();
    void enableResponseCompression();
    void abortRequests();
    QString getParamStylePrefix(const QString &style);
    QString getParamStyleSuffix(const QString &style);
    QString getParamStyleDelimiter(const QString &style, const QString &name, bool isExplode);


    virtual void entitiesGet();

    /**
    * @param[in]  otp QString [optional]
    * @param[in]  session QString [optional]
    * @param[in]  api_key QString [optional]
    * @param[in]  code QString [optional]
    * @param[in]  contract_code QString [optional]
    * @param[in]  document_type QString [optional]
    * @param[in]  password QString [optional]
    * @param[in]  second_password QString [optional]
    * @param[in]  token QString [optional]
    * @param[in]  tokenize bool [optional]
    * @param[in]  user QString [optional]
    */
    virtual void entitiesPost(const ::OpenAPI::OptionalParam<QString> &otp = ::OpenAPI::OptionalParam<QString>(), const ::OpenAPI::OptionalParam<QString> &session = ::OpenAPI::OptionalParam<QString>(), const ::OpenAPI::OptionalParam<QString> &api_key = ::OpenAPI::OptionalParam<QString>(), const ::OpenAPI::OptionalParam<QString> &code = ::OpenAPI::OptionalParam<QString>(), const ::OpenAPI::OptionalParam<QString> &contract_code = ::OpenAPI::OptionalParam<QString>(), const ::OpenAPI::OptionalParam<QString> &document_type = ::OpenAPI::OptionalParam<QString>(), const ::OpenAPI::OptionalParam<QString> &password = ::OpenAPI::OptionalParam<QString>(), const ::OpenAPI::OptionalParam<QString> &second_password = ::OpenAPI::OptionalParam<QString>(), const ::OpenAPI::OptionalParam<QString> &token = ::OpenAPI::OptionalParam<QString>(), const ::OpenAPI::OptionalParam<bool> &tokenize = ::OpenAPI::OptionalParam<bool>(), const ::OpenAPI::OptionalParam<QString> &user = ::OpenAPI::OptionalParam<QString>());

    /**
    * @param[in]  lang QString [optional]
    */
    virtual void errorCodesGet(const ::OpenAPI::OptionalParam<QString> &lang = ::OpenAPI::OptionalParam<QString>());


private:
    QMap<QString,int> _serverIndices;
    QMap<QString,QList<OAIServerConfiguration>> _serverConfigs;
    QMap<QString, QString> _apiKeys;
    QString _bearerToken;
    QString _username;
    QString _password;
    int _timeOut;
    QString _workingDirectory;
    QNetworkAccessManager* _manager;
    QMap<QString, QString> _defaultHeaders;
    bool _isResponseCompressionEnabled;
    bool _isRequestCompressionEnabled;
    OAIHttpRequestInput _latestInput;
    OAIHttpRequestWorker *_latestWorker;
    QStringList _latestScope;
    OauthCode _authFlow;
    OauthImplicit _implicitFlow;
    OauthCredentials _credentialFlow;
    OauthPassword _passwordFlow;
    int _OauthMethod = 0;

    void entitiesGetCallback(OAIHttpRequestWorker *worker);
    void entitiesPostCallback(OAIHttpRequestWorker *worker);
    void errorCodesGetCallback(OAIHttpRequestWorker *worker);

Q_SIGNALS:

    void entitiesGetSignal(QList<QList> summary);
    void entitiesPostSignal(QList<OAIEntity_data> summary);
    void errorCodesGetSignal(QList<QList> summary);


    void entitiesGetSignalFull(OAIHttpRequestWorker *worker, QList<QList> summary);
    void entitiesPostSignalFull(OAIHttpRequestWorker *worker, QList<OAIEntity_data> summary);
    void errorCodesGetSignalFull(OAIHttpRequestWorker *worker, QList<QList> summary);

    Q_DECL_DEPRECATED_X("Use entitiesGetSignalError() instead")
    void entitiesGetSignalE(QList<QList> summary, QNetworkReply::NetworkError error_type, QString error_str);
    void entitiesGetSignalError(QList<QList> summary, QNetworkReply::NetworkError error_type, const QString &error_str);
    Q_DECL_DEPRECATED_X("Use entitiesPostSignalError() instead")
    void entitiesPostSignalE(QList<OAIEntity_data> summary, QNetworkReply::NetworkError error_type, QString error_str);
    void entitiesPostSignalError(QList<OAIEntity_data> summary, QNetworkReply::NetworkError error_type, const QString &error_str);
    Q_DECL_DEPRECATED_X("Use errorCodesGetSignalError() instead")
    void errorCodesGetSignalE(QList<QList> summary, QNetworkReply::NetworkError error_type, QString error_str);
    void errorCodesGetSignalError(QList<QList> summary, QNetworkReply::NetworkError error_type, const QString &error_str);

    Q_DECL_DEPRECATED_X("Use entitiesGetSignalErrorFull() instead")
    void entitiesGetSignalEFull(OAIHttpRequestWorker *worker, QNetworkReply::NetworkError error_type, QString error_str);
    void entitiesGetSignalErrorFull(OAIHttpRequestWorker *worker, QNetworkReply::NetworkError error_type, const QString &error_str);
    Q_DECL_DEPRECATED_X("Use entitiesPostSignalErrorFull() instead")
    void entitiesPostSignalEFull(OAIHttpRequestWorker *worker, QNetworkReply::NetworkError error_type, QString error_str);
    void entitiesPostSignalErrorFull(OAIHttpRequestWorker *worker, QNetworkReply::NetworkError error_type, const QString &error_str);
    Q_DECL_DEPRECATED_X("Use errorCodesGetSignalErrorFull() instead")
    void errorCodesGetSignalEFull(OAIHttpRequestWorker *worker, QNetworkReply::NetworkError error_type, QString error_str);
    void errorCodesGetSignalErrorFull(OAIHttpRequestWorker *worker, QNetworkReply::NetworkError error_type, const QString &error_str);

    void abortRequestsSignal();
    void allPendingRequestsCompleted();

public Q_SLOTS:
    void tokenAvailable();
};

} // namespace OpenAPI
#endif
