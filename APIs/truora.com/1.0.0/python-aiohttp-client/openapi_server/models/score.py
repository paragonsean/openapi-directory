# coding: utf-8

from datetime import date, datetime

from typing import List, Dict, Type

from openapi_server.models.base_model import Model
from openapi_server.models.score_detail import ScoreDetail
from openapi_server import util


class Score(Model):
    """NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).

    Do not edit the class manually.
    """

    def __init__(self, by_id: ScoreDetail=None, by_name: ScoreDetail=None, data_set: str=None, result: str=None, score: float=None, severity: str=None):
        """Score - a model defined in OpenAPI

        :param by_id: The by_id of this Score.
        :param by_name: The by_name of this Score.
        :param data_set: The data_set of this Score.
        :param result: The result of this Score.
        :param score: The score of this Score.
        :param severity: The severity of this Score.
        """
        self.openapi_types = {
            'by_id': ScoreDetail,
            'by_name': ScoreDetail,
            'data_set': str,
            'result': str,
            'score': float,
            'severity': str
        }

        self.attribute_map = {
            'by_id': 'by_id',
            'by_name': 'by_name',
            'data_set': 'data_set',
            'result': 'result',
            'score': 'score',
            'severity': 'severity'
        }

        self._by_id = by_id
        self._by_name = by_name
        self._data_set = data_set
        self._result = result
        self._score = score
        self._severity = severity

    @classmethod
    def from_dict(cls, dikt: dict) -> 'Score':
        """Returns the dict as a model

        :param dikt: A dict.
        :return: The Score of this Score.
        """
        return util.deserialize_model(dikt, cls)

    @property
    def by_id(self):
        """Gets the by_id of this Score.


        :return: The by_id of this Score.
        :rtype: ScoreDetail
        """
        return self._by_id

    @by_id.setter
    def by_id(self, by_id):
        """Sets the by_id of this Score.


        :param by_id: The by_id of this Score.
        :type by_id: ScoreDetail
        """
        if by_id is None:
            raise ValueError("Invalid value for `by_id`, must not be `None`")

        self._by_id = by_id

    @property
    def by_name(self):
        """Gets the by_name of this Score.


        :return: The by_name of this Score.
        :rtype: ScoreDetail
        """
        return self._by_name

    @by_name.setter
    def by_name(self, by_name):
        """Sets the by_name of this Score.


        :param by_name: The by_name of this Score.
        :type by_name: ScoreDetail
        """
        if by_name is None:
            raise ValueError("Invalid value for `by_name`, must not be `None`")

        self._by_name = by_name

    @property
    def data_set(self):
        """Gets the data_set of this Score.

        Dataset summed up to create the score

        :return: The data_set of this Score.
        :rtype: str
        """
        return self._data_set

    @data_set.setter
    def data_set(self, data_set):
        """Sets the data_set of this Score.

        Dataset summed up to create the score

        :param data_set: The data_set of this Score.
        :type data_set: str
        """
        allowed_values = ["affiliations_and_insurances", "alert_in_media", "behavior", "business_background", "criminal_record", "driving_licenses", "international_background", "legal_background", "personal_identity", "professional_background", "traffic_fines", "vehicle_information", "vehicle_permits", "taxes_and_finances"]  # noqa: E501
        if data_set not in allowed_values:
            raise ValueError(
                "Invalid value for `data_set` ({0}), must be one of {1}"
                .format(data_set, allowed_values)
            )

        self._data_set = data_set

    @property
    def result(self):
        """Gets the result of this Score.

        Overall result of the data collected. If at least one collected data status is found, the result will be found, otherwise, it will be the most frecuent status

        :return: The result of this Score.
        :rtype: str
        """
        return self._result

    @result.setter
    def result(self, result):
        """Sets the result of this Score.

        Overall result of the data collected. If at least one collected data status is found, the result will be found, otherwise, it will be the most frecuent status

        :param result: The result of this Score.
        :type result: str
        """
        allowed_values = ["pending", "found", "not_found", "error", "delayed", "ignored"]  # noqa: E501
        if result not in allowed_values:
            raise ValueError(
                "Invalid value for `result` ({0}), must be one of {1}"
                .format(result, allowed_values)
            )

        self._result = result

    @property
    def score(self):
        """Gets the score of this Score.

        Dataset score. Number between 0 and 1 where 1 is the best score.

        :return: The score of this Score.
        :rtype: float
        """
        return self._score

    @score.setter
    def score(self, score):
        """Sets the score of this Score.

        Dataset score. Number between 0 and 1 where 1 is the best score.

        :param score: The score of this Score.
        :type score: float
        """
        if score is None:
            raise ValueError("Invalid value for `score`, must not be `None`")
        if score is not None and score > 1:
            raise ValueError("Invalid value for `score`, must be a value less than or equal to `1`")
        if score is not None and score < 0:
            raise ValueError("Invalid value for `score`, must be a value greater than or equal to `0`")

        self._score = score

    @property
    def severity(self):
        """Gets the severity of this Score.

        Risk asociated with each category for the search according to the information found. None is returned when the person, vehicle or company is in the clear. Unknown is returned when the score is none due to a problem with one of the searches

        :return: The severity of this Score.
        :rtype: str
        """
        return self._severity

    @severity.setter
    def severity(self, severity):
        """Sets the severity of this Score.

        Risk asociated with each category for the search according to the information found. None is returned when the person, vehicle or company is in the clear. Unknown is returned when the score is none due to a problem with one of the searches

        :param severity: The severity of this Score.
        :type severity: str
        """
        allowed_values = ["unknown", "none", "very_low", "low", "medium", "high", "very_high"]  # noqa: E501
        if severity not in allowed_values:
            raise ValueError(
                "Invalid value for `severity` ({0}), must be one of {1}"
                .format(severity, allowed_values)
            )

        self._severity = severity
