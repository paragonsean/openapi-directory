/*
 * Stream Chat API
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: v80.2.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package org.openapitools.client.model;

import java.util.Objects;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;
import java.time.OffsetDateTime;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import org.openapitools.client.model.Attachment;
import org.openapitools.client.model.Reaction;
import org.openapitools.client.model.UserObject;
import org.openapitools.jackson.nullable.JsonNullable;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonArray;
import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;
import com.google.gson.TypeAdapterFactory;
import com.google.gson.reflect.TypeToken;
import com.google.gson.TypeAdapter;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;

import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import org.openapitools.client.JSON;

/**
 * Represents any chat message
 */
@javax.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen", date = "2024-10-12T12:41:11.429997-04:00[America/New_York]", comments = "Generator version: 7.9.0")
public class Message {
  public static final String SERIALIZED_NAME_ATTACHMENTS = "attachments";
  @SerializedName(SERIALIZED_NAME_ATTACHMENTS)
  private List<Attachment> attachments = new ArrayList<>();

  public static final String SERIALIZED_NAME_BEFORE_MESSAGE_SEND_FAILED = "before_message_send_failed";
  @SerializedName(SERIALIZED_NAME_BEFORE_MESSAGE_SEND_FAILED)
  private Boolean beforeMessageSendFailed;

  public static final String SERIALIZED_NAME_CID = "cid";
  @SerializedName(SERIALIZED_NAME_CID)
  private String cid;

  public static final String SERIALIZED_NAME_COMMAND = "command";
  @SerializedName(SERIALIZED_NAME_COMMAND)
  private String command;

  public static final String SERIALIZED_NAME_CREATED_AT = "created_at";
  @SerializedName(SERIALIZED_NAME_CREATED_AT)
  private OffsetDateTime createdAt;

  public static final String SERIALIZED_NAME_DELETED_AT = "deleted_at";
  @SerializedName(SERIALIZED_NAME_DELETED_AT)
  private OffsetDateTime deletedAt;

  public static final String SERIALIZED_NAME_HTML = "html";
  @SerializedName(SERIALIZED_NAME_HTML)
  private String html;

  public static final String SERIALIZED_NAME_I18N = "i18n";
  @SerializedName(SERIALIZED_NAME_I18N)
  private Map<String, String> i18n = new HashMap<>();

  public static final String SERIALIZED_NAME_ID = "id";
  @SerializedName(SERIALIZED_NAME_ID)
  private String id;

  public static final String SERIALIZED_NAME_IMAGE_LABELS = "image_labels";
  @SerializedName(SERIALIZED_NAME_IMAGE_LABELS)
  private Map<String, List<String>> imageLabels = new HashMap<>();

  public static final String SERIALIZED_NAME_LATEST_REACTIONS = "latest_reactions";
  @SerializedName(SERIALIZED_NAME_LATEST_REACTIONS)
  private List<Reaction> latestReactions = new ArrayList<>();

  public static final String SERIALIZED_NAME_MENTIONED_USERS = "mentioned_users";
  @SerializedName(SERIALIZED_NAME_MENTIONED_USERS)
  private List<UserObject> mentionedUsers = new ArrayList<>();

  public static final String SERIALIZED_NAME_MML = "mml";
  @SerializedName(SERIALIZED_NAME_MML)
  private String mml;

  public static final String SERIALIZED_NAME_OWN_REACTIONS = "own_reactions";
  @SerializedName(SERIALIZED_NAME_OWN_REACTIONS)
  private List<Reaction> ownReactions = new ArrayList<>();

  public static final String SERIALIZED_NAME_PARENT_ID = "parent_id";
  @SerializedName(SERIALIZED_NAME_PARENT_ID)
  private String parentId;

  public static final String SERIALIZED_NAME_PIN_EXPIRES = "pin_expires";
  @SerializedName(SERIALIZED_NAME_PIN_EXPIRES)
  private OffsetDateTime pinExpires;

  public static final String SERIALIZED_NAME_PINNED = "pinned";
  @SerializedName(SERIALIZED_NAME_PINNED)
  private Boolean pinned;

  public static final String SERIALIZED_NAME_PINNED_AT = "pinned_at";
  @SerializedName(SERIALIZED_NAME_PINNED_AT)
  private OffsetDateTime pinnedAt;

  public static final String SERIALIZED_NAME_PINNED_BY = "pinned_by";
  @SerializedName(SERIALIZED_NAME_PINNED_BY)
  private UserObject pinnedBy;

  public static final String SERIALIZED_NAME_QUOTED_MESSAGE = "quoted_message";
  @SerializedName(SERIALIZED_NAME_QUOTED_MESSAGE)
  private Message quotedMessage;

  public static final String SERIALIZED_NAME_QUOTED_MESSAGE_ID = "quoted_message_id";
  @SerializedName(SERIALIZED_NAME_QUOTED_MESSAGE_ID)
  private String quotedMessageId;

  public static final String SERIALIZED_NAME_REACTION_COUNTS = "reaction_counts";
  @SerializedName(SERIALIZED_NAME_REACTION_COUNTS)
  private Map<String, Integer> reactionCounts = new HashMap<>();

  public static final String SERIALIZED_NAME_REACTION_SCORES = "reaction_scores";
  @SerializedName(SERIALIZED_NAME_REACTION_SCORES)
  private Map<String, Integer> reactionScores = new HashMap<>();

  public static final String SERIALIZED_NAME_REPLY_COUNT = "reply_count";
  @SerializedName(SERIALIZED_NAME_REPLY_COUNT)
  private Integer replyCount;

  public static final String SERIALIZED_NAME_SHADOWED = "shadowed";
  @SerializedName(SERIALIZED_NAME_SHADOWED)
  private Boolean shadowed;

  public static final String SERIALIZED_NAME_SHOW_IN_CHANNEL = "show_in_channel";
  @SerializedName(SERIALIZED_NAME_SHOW_IN_CHANNEL)
  private Boolean showInChannel;

  public static final String SERIALIZED_NAME_SILENT = "silent";
  @SerializedName(SERIALIZED_NAME_SILENT)
  private Boolean silent;

  public static final String SERIALIZED_NAME_TEXT = "text";
  @SerializedName(SERIALIZED_NAME_TEXT)
  private String text;

  public static final String SERIALIZED_NAME_THREAD_PARTICIPANTS = "thread_participants";
  @SerializedName(SERIALIZED_NAME_THREAD_PARTICIPANTS)
  private List<UserObject> threadParticipants = new ArrayList<>();

  /**
   * Contains type of the message
   */
  @JsonAdapter(TypeEnum.Adapter.class)
  public enum TypeEnum {
    REGULAR("regular"),
    
    EPHEMERAL("ephemeral"),
    
    ERROR("error"),
    
    REPLY("reply"),
    
    SYSTEM("system"),
    
    DELETED("deleted");

    private String value;

    TypeEnum(String value) {
      this.value = value;
    }

    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }

    public static TypeEnum fromValue(String value) {
      for (TypeEnum b : TypeEnum.values()) {
        if (b.value.equals(value)) {
          return b;
        }
      }
      throw new IllegalArgumentException("Unexpected value '" + value + "'");
    }

    public static class Adapter extends TypeAdapter<TypeEnum> {
      @Override
      public void write(final JsonWriter jsonWriter, final TypeEnum enumeration) throws IOException {
        jsonWriter.value(enumeration.getValue());
      }

      @Override
      public TypeEnum read(final JsonReader jsonReader) throws IOException {
        String value =  jsonReader.nextString();
        return TypeEnum.fromValue(value);
      }
    }

    public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      String value = jsonElement.getAsString();
      TypeEnum.fromValue(value);
    }
  }

  public static final String SERIALIZED_NAME_TYPE = "type";
  @SerializedName(SERIALIZED_NAME_TYPE)
  private TypeEnum type;

  public static final String SERIALIZED_NAME_UPDATED_AT = "updated_at";
  @SerializedName(SERIALIZED_NAME_UPDATED_AT)
  private OffsetDateTime updatedAt;

  public static final String SERIALIZED_NAME_USER = "user";
  @SerializedName(SERIALIZED_NAME_USER)
  private UserObject user;

  public Message() {
  }

  public Message attachments(List<Attachment> attachments) {
    this.attachments = attachments;
    return this;
  }

  public Message addAttachmentsItem(Attachment attachmentsItem) {
    if (this.attachments == null) {
      this.attachments = new ArrayList<>();
    }
    this.attachments.add(attachmentsItem);
    return this;
  }

  /**
   * Array of message attachments
   * @return attachments
   */
  @javax.annotation.Nonnull
  public List<Attachment> getAttachments() {
    return attachments;
  }

  public void setAttachments(List<Attachment> attachments) {
    this.attachments = attachments;
  }


  public Message beforeMessageSendFailed(Boolean beforeMessageSendFailed) {
    this.beforeMessageSendFailed = beforeMessageSendFailed;
    return this;
  }

  /**
   * Whether &#x60;before_message_send webhook&#x60; failed or not. Field is only accessible in push webhook
   * @return beforeMessageSendFailed
   */
  @javax.annotation.Nullable
  public Boolean getBeforeMessageSendFailed() {
    return beforeMessageSendFailed;
  }

  public void setBeforeMessageSendFailed(Boolean beforeMessageSendFailed) {
    this.beforeMessageSendFailed = beforeMessageSendFailed;
  }


  public Message cid(String cid) {
    this.cid = cid;
    return this;
  }

  /**
   * Channel unique identifier in &lt;type&gt;:&lt;id&gt; format
   * @return cid
   */
  @javax.annotation.Nonnull
  public String getCid() {
    return cid;
  }

  public void setCid(String cid) {
    this.cid = cid;
  }


  public Message command(String command) {
    this.command = command;
    return this;
  }

  /**
   * Contains provided slash command
   * @return command
   */
  @javax.annotation.Nullable
  public String getCommand() {
    return command;
  }

  public void setCommand(String command) {
    this.command = command;
  }


  public Message createdAt(OffsetDateTime createdAt) {
    this.createdAt = createdAt;
    return this;
  }

  /**
   * Date/time of creation
   * @return createdAt
   */
  @javax.annotation.Nonnull
  public OffsetDateTime getCreatedAt() {
    return createdAt;
  }

  public void setCreatedAt(OffsetDateTime createdAt) {
    this.createdAt = createdAt;
  }


  public Message deletedAt(OffsetDateTime deletedAt) {
    this.deletedAt = deletedAt;
    return this;
  }

  /**
   * Date/time of deletion
   * @return deletedAt
   */
  @javax.annotation.Nullable
  public OffsetDateTime getDeletedAt() {
    return deletedAt;
  }

  public void setDeletedAt(OffsetDateTime deletedAt) {
    this.deletedAt = deletedAt;
  }


  public Message html(String html) {
    this.html = html;
    return this;
  }

  /**
   * Contains HTML markup of the message. Can only be set when using server-side API
   * @return html
   */
  @javax.annotation.Nonnull
  public String getHtml() {
    return html;
  }

  public void setHtml(String html) {
    this.html = html;
  }


  public Message i18n(Map<String, String> i18n) {
    this.i18n = i18n;
    return this;
  }

  public Message putI18nItem(String key, String i18nItem) {
    if (this.i18n == null) {
      this.i18n = new HashMap<>();
    }
    this.i18n.put(key, i18nItem);
    return this;
  }

  /**
   * Object with translations. Key &#x60;language&#x60; contains the original language key. Other keys contain translations
   * @return i18n
   */
  @javax.annotation.Nullable
  public Map<String, String> getI18n() {
    return i18n;
  }

  public void setI18n(Map<String, String> i18n) {
    this.i18n = i18n;
  }


  public Message id(String id) {
    this.id = id;
    return this;
  }

  /**
   * Message ID is unique string identifier of the message
   * @return id
   */
  @javax.annotation.Nonnull
  public String getId() {
    return id;
  }

  public void setId(String id) {
    this.id = id;
  }


  public Message imageLabels(Map<String, List<String>> imageLabels) {
    this.imageLabels = imageLabels;
    return this;
  }

  public Message putImageLabelsItem(String key, List<String> imageLabelsItem) {
    if (this.imageLabels == null) {
      this.imageLabels = new HashMap<>();
    }
    this.imageLabels.put(key, imageLabelsItem);
    return this;
  }

  /**
   * Contains image moderation information
   * @return imageLabels
   */
  @javax.annotation.Nullable
  public Map<String, List<String>> getImageLabels() {
    return imageLabels;
  }

  public void setImageLabels(Map<String, List<String>> imageLabels) {
    this.imageLabels = imageLabels;
  }


  public Message latestReactions(List<Reaction> latestReactions) {
    this.latestReactions = latestReactions;
    return this;
  }

  public Message addLatestReactionsItem(Reaction latestReactionsItem) {
    if (this.latestReactions == null) {
      this.latestReactions = new ArrayList<>();
    }
    this.latestReactions.add(latestReactionsItem);
    return this;
  }

  /**
   * List of 10 latest reactions to this message
   * @return latestReactions
   */
  @javax.annotation.Nonnull
  public List<Reaction> getLatestReactions() {
    return latestReactions;
  }

  public void setLatestReactions(List<Reaction> latestReactions) {
    this.latestReactions = latestReactions;
  }


  public Message mentionedUsers(List<UserObject> mentionedUsers) {
    this.mentionedUsers = mentionedUsers;
    return this;
  }

  public Message addMentionedUsersItem(UserObject mentionedUsersItem) {
    if (this.mentionedUsers == null) {
      this.mentionedUsers = new ArrayList<>();
    }
    this.mentionedUsers.add(mentionedUsersItem);
    return this;
  }

  /**
   * List of mentioned users
   * @return mentionedUsers
   */
  @javax.annotation.Nonnull
  public List<UserObject> getMentionedUsers() {
    return mentionedUsers;
  }

  public void setMentionedUsers(List<UserObject> mentionedUsers) {
    this.mentionedUsers = mentionedUsers;
  }


  public Message mml(String mml) {
    this.mml = mml;
    return this;
  }

  /**
   * Should be empty if &#x60;text&#x60; is provided. Can only be set when using server-side API
   * @return mml
   */
  @javax.annotation.Nullable
  public String getMml() {
    return mml;
  }

  public void setMml(String mml) {
    this.mml = mml;
  }


  public Message ownReactions(List<Reaction> ownReactions) {
    this.ownReactions = ownReactions;
    return this;
  }

  public Message addOwnReactionsItem(Reaction ownReactionsItem) {
    if (this.ownReactions == null) {
      this.ownReactions = new ArrayList<>();
    }
    this.ownReactions.add(ownReactionsItem);
    return this;
  }

  /**
   * List of 10 latest reactions of authenticated user to this message
   * @return ownReactions
   */
  @javax.annotation.Nonnull
  public List<Reaction> getOwnReactions() {
    return ownReactions;
  }

  public void setOwnReactions(List<Reaction> ownReactions) {
    this.ownReactions = ownReactions;
  }


  public Message parentId(String parentId) {
    this.parentId = parentId;
    return this;
  }

  /**
   * ID of parent message (thread)
   * @return parentId
   */
  @javax.annotation.Nullable
  public String getParentId() {
    return parentId;
  }

  public void setParentId(String parentId) {
    this.parentId = parentId;
  }


  public Message pinExpires(OffsetDateTime pinExpires) {
    this.pinExpires = pinExpires;
    return this;
  }

  /**
   * Date when pinned message expires
   * @return pinExpires
   */
  @javax.annotation.Nullable
  public OffsetDateTime getPinExpires() {
    return pinExpires;
  }

  public void setPinExpires(OffsetDateTime pinExpires) {
    this.pinExpires = pinExpires;
  }


  public Message pinned(Boolean pinned) {
    this.pinned = pinned;
    return this;
  }

  /**
   * Whether message is pinned or not
   * @return pinned
   */
  @javax.annotation.Nonnull
  public Boolean getPinned() {
    return pinned;
  }

  public void setPinned(Boolean pinned) {
    this.pinned = pinned;
  }


  public Message pinnedAt(OffsetDateTime pinnedAt) {
    this.pinnedAt = pinnedAt;
    return this;
  }

  /**
   * Date when message got pinned
   * @return pinnedAt
   */
  @javax.annotation.Nullable
  public OffsetDateTime getPinnedAt() {
    return pinnedAt;
  }

  public void setPinnedAt(OffsetDateTime pinnedAt) {
    this.pinnedAt = pinnedAt;
  }


  public Message pinnedBy(UserObject pinnedBy) {
    this.pinnedBy = pinnedBy;
    return this;
  }

  /**
   * Get pinnedBy
   * @return pinnedBy
   */
  @javax.annotation.Nullable
  public UserObject getPinnedBy() {
    return pinnedBy;
  }

  public void setPinnedBy(UserObject pinnedBy) {
    this.pinnedBy = pinnedBy;
  }


  public Message quotedMessage(Message quotedMessage) {
    this.quotedMessage = quotedMessage;
    return this;
  }

  /**
   * Get quotedMessage
   * @return quotedMessage
   */
  @javax.annotation.Nullable
  public Message getQuotedMessage() {
    return quotedMessage;
  }

  public void setQuotedMessage(Message quotedMessage) {
    this.quotedMessage = quotedMessage;
  }


  public Message quotedMessageId(String quotedMessageId) {
    this.quotedMessageId = quotedMessageId;
    return this;
  }

  /**
   * Get quotedMessageId
   * @return quotedMessageId
   */
  @javax.annotation.Nullable
  public String getQuotedMessageId() {
    return quotedMessageId;
  }

  public void setQuotedMessageId(String quotedMessageId) {
    this.quotedMessageId = quotedMessageId;
  }


  public Message reactionCounts(Map<String, Integer> reactionCounts) {
    this.reactionCounts = reactionCounts;
    return this;
  }

  public Message putReactionCountsItem(String key, Integer reactionCountsItem) {
    if (this.reactionCounts == null) {
      this.reactionCounts = new HashMap<>();
    }
    this.reactionCounts.put(key, reactionCountsItem);
    return this;
  }

  /**
   * An object containing number of reactions of each type. Key: reaction type (string), value: number of reactions (int)
   * @return reactionCounts
   */
  @javax.annotation.Nonnull
  public Map<String, Integer> getReactionCounts() {
    return reactionCounts;
  }

  public void setReactionCounts(Map<String, Integer> reactionCounts) {
    this.reactionCounts = reactionCounts;
  }


  public Message reactionScores(Map<String, Integer> reactionScores) {
    this.reactionScores = reactionScores;
    return this;
  }

  public Message putReactionScoresItem(String key, Integer reactionScoresItem) {
    if (this.reactionScores == null) {
      this.reactionScores = new HashMap<>();
    }
    this.reactionScores.put(key, reactionScoresItem);
    return this;
  }

  /**
   * An object containing scores of reactions of each type. Key: reaction type (string), value: total score of reactions (int)
   * @return reactionScores
   */
  @javax.annotation.Nonnull
  public Map<String, Integer> getReactionScores() {
    return reactionScores;
  }

  public void setReactionScores(Map<String, Integer> reactionScores) {
    this.reactionScores = reactionScores;
  }


  public Message replyCount(Integer replyCount) {
    this.replyCount = replyCount;
    return this;
  }

  /**
   * Number of replies to this message
   * @return replyCount
   */
  @javax.annotation.Nonnull
  public Integer getReplyCount() {
    return replyCount;
  }

  public void setReplyCount(Integer replyCount) {
    this.replyCount = replyCount;
  }


  public Message shadowed(Boolean shadowed) {
    this.shadowed = shadowed;
    return this;
  }

  /**
   * Whether the message was shadowed or not
   * @return shadowed
   */
  @javax.annotation.Nonnull
  public Boolean getShadowed() {
    return shadowed;
  }

  public void setShadowed(Boolean shadowed) {
    this.shadowed = shadowed;
  }


  public Message showInChannel(Boolean showInChannel) {
    this.showInChannel = showInChannel;
    return this;
  }

  /**
   * Whether thread reply should be shown in the channel as well
   * @return showInChannel
   */
  @javax.annotation.Nullable
  public Boolean getShowInChannel() {
    return showInChannel;
  }

  public void setShowInChannel(Boolean showInChannel) {
    this.showInChannel = showInChannel;
  }


  public Message silent(Boolean silent) {
    this.silent = silent;
    return this;
  }

  /**
   * Whether message is silent or not
   * @return silent
   */
  @javax.annotation.Nonnull
  public Boolean getSilent() {
    return silent;
  }

  public void setSilent(Boolean silent) {
    this.silent = silent;
  }


  public Message text(String text) {
    this.text = text;
    return this;
  }

  /**
   * Text of the message. Should be empty if &#x60;mml&#x60; is provided
   * @return text
   */
  @javax.annotation.Nonnull
  public String getText() {
    return text;
  }

  public void setText(String text) {
    this.text = text;
  }


  public Message threadParticipants(List<UserObject> threadParticipants) {
    this.threadParticipants = threadParticipants;
    return this;
  }

  public Message addThreadParticipantsItem(UserObject threadParticipantsItem) {
    if (this.threadParticipants == null) {
      this.threadParticipants = new ArrayList<>();
    }
    this.threadParticipants.add(threadParticipantsItem);
    return this;
  }

  /**
   * List of users who participate in thread
   * @return threadParticipants
   */
  @javax.annotation.Nullable
  public List<UserObject> getThreadParticipants() {
    return threadParticipants;
  }

  public void setThreadParticipants(List<UserObject> threadParticipants) {
    this.threadParticipants = threadParticipants;
  }


  public Message type(TypeEnum type) {
    this.type = type;
    return this;
  }

  /**
   * Contains type of the message
   * @return type
   */
  @javax.annotation.Nonnull
  public TypeEnum getType() {
    return type;
  }

  public void setType(TypeEnum type) {
    this.type = type;
  }


  public Message updatedAt(OffsetDateTime updatedAt) {
    this.updatedAt = updatedAt;
    return this;
  }

  /**
   * Date/time of the last update
   * @return updatedAt
   */
  @javax.annotation.Nonnull
  public OffsetDateTime getUpdatedAt() {
    return updatedAt;
  }

  public void setUpdatedAt(OffsetDateTime updatedAt) {
    this.updatedAt = updatedAt;
  }


  public Message user(UserObject user) {
    this.user = user;
    return this;
  }

  /**
   * Get user
   * @return user
   */
  @javax.annotation.Nullable
  public UserObject getUser() {
    return user;
  }

  public void setUser(UserObject user) {
    this.user = user;
  }

  /**
   * A container for additional, undeclared properties.
   * This is a holder for any undeclared properties as specified with
   * the 'additionalProperties' keyword in the OAS document.
   */
  private Map<String, Object> additionalProperties;

  /**
   * Set the additional (undeclared) property with the specified name and value.
   * If the property does not already exist, create it otherwise replace it.
   *
   * @param key name of the property
   * @param value value of the property
   * @return the Message instance itself
   */
  public Message putAdditionalProperty(String key, Object value) {
    if (this.additionalProperties == null) {
        this.additionalProperties = new HashMap<String, Object>();
    }
    this.additionalProperties.put(key, value);
    return this;
  }

  /**
   * Return the additional (undeclared) property.
   *
   * @return a map of objects
   */
  public Map<String, Object> getAdditionalProperties() {
    return additionalProperties;
  }

  /**
   * Return the additional (undeclared) property with the specified name.
   *
   * @param key name of the property
   * @return an object
   */
  public Object getAdditionalProperty(String key) {
    if (this.additionalProperties == null) {
        return null;
    }
    return this.additionalProperties.get(key);
  }


  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    Message message = (Message) o;
    return Objects.equals(this.attachments, message.attachments) &&
        Objects.equals(this.beforeMessageSendFailed, message.beforeMessageSendFailed) &&
        Objects.equals(this.cid, message.cid) &&
        Objects.equals(this.command, message.command) &&
        Objects.equals(this.createdAt, message.createdAt) &&
        Objects.equals(this.deletedAt, message.deletedAt) &&
        Objects.equals(this.html, message.html) &&
        Objects.equals(this.i18n, message.i18n) &&
        Objects.equals(this.id, message.id) &&
        Objects.equals(this.imageLabels, message.imageLabels) &&
        Objects.equals(this.latestReactions, message.latestReactions) &&
        Objects.equals(this.mentionedUsers, message.mentionedUsers) &&
        Objects.equals(this.mml, message.mml) &&
        Objects.equals(this.ownReactions, message.ownReactions) &&
        Objects.equals(this.parentId, message.parentId) &&
        Objects.equals(this.pinExpires, message.pinExpires) &&
        Objects.equals(this.pinned, message.pinned) &&
        Objects.equals(this.pinnedAt, message.pinnedAt) &&
        Objects.equals(this.pinnedBy, message.pinnedBy) &&
        Objects.equals(this.quotedMessage, message.quotedMessage) &&
        Objects.equals(this.quotedMessageId, message.quotedMessageId) &&
        Objects.equals(this.reactionCounts, message.reactionCounts) &&
        Objects.equals(this.reactionScores, message.reactionScores) &&
        Objects.equals(this.replyCount, message.replyCount) &&
        Objects.equals(this.shadowed, message.shadowed) &&
        Objects.equals(this.showInChannel, message.showInChannel) &&
        Objects.equals(this.silent, message.silent) &&
        Objects.equals(this.text, message.text) &&
        Objects.equals(this.threadParticipants, message.threadParticipants) &&
        Objects.equals(this.type, message.type) &&
        Objects.equals(this.updatedAt, message.updatedAt) &&
        Objects.equals(this.user, message.user)&&
        Objects.equals(this.additionalProperties, message.additionalProperties);
  }

  private static <T> boolean equalsNullable(JsonNullable<T> a, JsonNullable<T> b) {
    return a == b || (a != null && b != null && a.isPresent() && b.isPresent() && Objects.deepEquals(a.get(), b.get()));
  }

  @Override
  public int hashCode() {
    return Objects.hash(attachments, beforeMessageSendFailed, cid, command, createdAt, deletedAt, html, i18n, id, imageLabels, latestReactions, mentionedUsers, mml, ownReactions, parentId, pinExpires, pinned, pinnedAt, pinnedBy, quotedMessage, quotedMessageId, reactionCounts, reactionScores, replyCount, shadowed, showInChannel, silent, text, threadParticipants, type, updatedAt, user, additionalProperties);
  }

  private static <T> int hashCodeNullable(JsonNullable<T> a) {
    if (a == null) {
      return 1;
    }
    return a.isPresent() ? Arrays.deepHashCode(new Object[]{a.get()}) : 31;
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class Message {\n");
    sb.append("    attachments: ").append(toIndentedString(attachments)).append("\n");
    sb.append("    beforeMessageSendFailed: ").append(toIndentedString(beforeMessageSendFailed)).append("\n");
    sb.append("    cid: ").append(toIndentedString(cid)).append("\n");
    sb.append("    command: ").append(toIndentedString(command)).append("\n");
    sb.append("    createdAt: ").append(toIndentedString(createdAt)).append("\n");
    sb.append("    deletedAt: ").append(toIndentedString(deletedAt)).append("\n");
    sb.append("    html: ").append(toIndentedString(html)).append("\n");
    sb.append("    i18n: ").append(toIndentedString(i18n)).append("\n");
    sb.append("    id: ").append(toIndentedString(id)).append("\n");
    sb.append("    imageLabels: ").append(toIndentedString(imageLabels)).append("\n");
    sb.append("    latestReactions: ").append(toIndentedString(latestReactions)).append("\n");
    sb.append("    mentionedUsers: ").append(toIndentedString(mentionedUsers)).append("\n");
    sb.append("    mml: ").append(toIndentedString(mml)).append("\n");
    sb.append("    ownReactions: ").append(toIndentedString(ownReactions)).append("\n");
    sb.append("    parentId: ").append(toIndentedString(parentId)).append("\n");
    sb.append("    pinExpires: ").append(toIndentedString(pinExpires)).append("\n");
    sb.append("    pinned: ").append(toIndentedString(pinned)).append("\n");
    sb.append("    pinnedAt: ").append(toIndentedString(pinnedAt)).append("\n");
    sb.append("    pinnedBy: ").append(toIndentedString(pinnedBy)).append("\n");
    sb.append("    quotedMessage: ").append(toIndentedString(quotedMessage)).append("\n");
    sb.append("    quotedMessageId: ").append(toIndentedString(quotedMessageId)).append("\n");
    sb.append("    reactionCounts: ").append(toIndentedString(reactionCounts)).append("\n");
    sb.append("    reactionScores: ").append(toIndentedString(reactionScores)).append("\n");
    sb.append("    replyCount: ").append(toIndentedString(replyCount)).append("\n");
    sb.append("    shadowed: ").append(toIndentedString(shadowed)).append("\n");
    sb.append("    showInChannel: ").append(toIndentedString(showInChannel)).append("\n");
    sb.append("    silent: ").append(toIndentedString(silent)).append("\n");
    sb.append("    text: ").append(toIndentedString(text)).append("\n");
    sb.append("    threadParticipants: ").append(toIndentedString(threadParticipants)).append("\n");
    sb.append("    type: ").append(toIndentedString(type)).append("\n");
    sb.append("    updatedAt: ").append(toIndentedString(updatedAt)).append("\n");
    sb.append("    user: ").append(toIndentedString(user)).append("\n");
    sb.append("    additionalProperties: ").append(toIndentedString(additionalProperties)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }


  public static HashSet<String> openapiFields;
  public static HashSet<String> openapiRequiredFields;

  static {
    // a set of all properties/fields (JSON key names)
    openapiFields = new HashSet<String>();
    openapiFields.add("attachments");
    openapiFields.add("before_message_send_failed");
    openapiFields.add("cid");
    openapiFields.add("command");
    openapiFields.add("created_at");
    openapiFields.add("deleted_at");
    openapiFields.add("html");
    openapiFields.add("i18n");
    openapiFields.add("id");
    openapiFields.add("image_labels");
    openapiFields.add("latest_reactions");
    openapiFields.add("mentioned_users");
    openapiFields.add("mml");
    openapiFields.add("own_reactions");
    openapiFields.add("parent_id");
    openapiFields.add("pin_expires");
    openapiFields.add("pinned");
    openapiFields.add("pinned_at");
    openapiFields.add("pinned_by");
    openapiFields.add("quoted_message");
    openapiFields.add("quoted_message_id");
    openapiFields.add("reaction_counts");
    openapiFields.add("reaction_scores");
    openapiFields.add("reply_count");
    openapiFields.add("shadowed");
    openapiFields.add("show_in_channel");
    openapiFields.add("silent");
    openapiFields.add("text");
    openapiFields.add("thread_participants");
    openapiFields.add("type");
    openapiFields.add("updated_at");
    openapiFields.add("user");

    // a set of required properties/fields (JSON key names)
    openapiRequiredFields = new HashSet<String>();
    openapiRequiredFields.add("attachments");
    openapiRequiredFields.add("cid");
    openapiRequiredFields.add("created_at");
    openapiRequiredFields.add("html");
    openapiRequiredFields.add("id");
    openapiRequiredFields.add("latest_reactions");
    openapiRequiredFields.add("mentioned_users");
    openapiRequiredFields.add("own_reactions");
    openapiRequiredFields.add("pinned");
    openapiRequiredFields.add("reaction_counts");
    openapiRequiredFields.add("reaction_scores");
    openapiRequiredFields.add("reply_count");
    openapiRequiredFields.add("shadowed");
    openapiRequiredFields.add("silent");
    openapiRequiredFields.add("text");
    openapiRequiredFields.add("type");
    openapiRequiredFields.add("updated_at");
  }

  /**
   * Validates the JSON Element and throws an exception if issues found
   *
   * @param jsonElement JSON Element
   * @throws IOException if the JSON Element is invalid with respect to Message
   */
  public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      if (jsonElement == null) {
        if (!Message.openapiRequiredFields.isEmpty()) { // has required fields but JSON element is null
          throw new IllegalArgumentException(String.format("The required field(s) %s in Message is not found in the empty JSON string", Message.openapiRequiredFields.toString()));
        }
      }

      // check to make sure all required properties/fields are present in the JSON string
      for (String requiredField : Message.openapiRequiredFields) {
        if (jsonElement.getAsJsonObject().get(requiredField) == null) {
          throw new IllegalArgumentException(String.format("The required field `%s` is not found in the JSON string: %s", requiredField, jsonElement.toString()));
        }
      }
        JsonObject jsonObj = jsonElement.getAsJsonObject();
      // ensure the required json array is present
      if (jsonObj.get("attachments") == null) {
        throw new IllegalArgumentException("Expected the field `linkedContent` to be an array in the JSON string but got `null`");
      } else if (!jsonObj.get("attachments").isJsonArray()) {
        throw new IllegalArgumentException(String.format("Expected the field `attachments` to be an array in the JSON string but got `%s`", jsonObj.get("attachments").toString()));
      }
      if (!jsonObj.get("cid").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `cid` to be a primitive type in the JSON string but got `%s`", jsonObj.get("cid").toString()));
      }
      if ((jsonObj.get("command") != null && !jsonObj.get("command").isJsonNull()) && !jsonObj.get("command").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `command` to be a primitive type in the JSON string but got `%s`", jsonObj.get("command").toString()));
      }
      if (!jsonObj.get("html").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `html` to be a primitive type in the JSON string but got `%s`", jsonObj.get("html").toString()));
      }
      if (!jsonObj.get("id").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `id` to be a primitive type in the JSON string but got `%s`", jsonObj.get("id").toString()));
      }
      // ensure the required json array is present
      if (jsonObj.get("latest_reactions") == null) {
        throw new IllegalArgumentException("Expected the field `linkedContent` to be an array in the JSON string but got `null`");
      } else if (!jsonObj.get("latest_reactions").isJsonArray()) {
        throw new IllegalArgumentException(String.format("Expected the field `latest_reactions` to be an array in the JSON string but got `%s`", jsonObj.get("latest_reactions").toString()));
      }
      // ensure the required json array is present
      if (jsonObj.get("mentioned_users") == null) {
        throw new IllegalArgumentException("Expected the field `linkedContent` to be an array in the JSON string but got `null`");
      } else if (!jsonObj.get("mentioned_users").isJsonArray()) {
        throw new IllegalArgumentException(String.format("Expected the field `mentioned_users` to be an array in the JSON string but got `%s`", jsonObj.get("mentioned_users").toString()));
      }
      if ((jsonObj.get("mml") != null && !jsonObj.get("mml").isJsonNull()) && !jsonObj.get("mml").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `mml` to be a primitive type in the JSON string but got `%s`", jsonObj.get("mml").toString()));
      }
      // ensure the required json array is present
      if (jsonObj.get("own_reactions") == null) {
        throw new IllegalArgumentException("Expected the field `linkedContent` to be an array in the JSON string but got `null`");
      } else if (!jsonObj.get("own_reactions").isJsonArray()) {
        throw new IllegalArgumentException(String.format("Expected the field `own_reactions` to be an array in the JSON string but got `%s`", jsonObj.get("own_reactions").toString()));
      }
      if ((jsonObj.get("parent_id") != null && !jsonObj.get("parent_id").isJsonNull()) && !jsonObj.get("parent_id").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `parent_id` to be a primitive type in the JSON string but got `%s`", jsonObj.get("parent_id").toString()));
      }
      if ((jsonObj.get("quoted_message_id") != null && !jsonObj.get("quoted_message_id").isJsonNull()) && !jsonObj.get("quoted_message_id").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `quoted_message_id` to be a primitive type in the JSON string but got `%s`", jsonObj.get("quoted_message_id").toString()));
      }
      if (!jsonObj.get("text").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `text` to be a primitive type in the JSON string but got `%s`", jsonObj.get("text").toString()));
      }
      // ensure the optional json data is an array if present
      if (jsonObj.get("thread_participants") != null && !jsonObj.get("thread_participants").isJsonNull() && !jsonObj.get("thread_participants").isJsonArray()) {
        throw new IllegalArgumentException(String.format("Expected the field `thread_participants` to be an array in the JSON string but got `%s`", jsonObj.get("thread_participants").toString()));
      }
      if (!jsonObj.get("type").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `type` to be a primitive type in the JSON string but got `%s`", jsonObj.get("type").toString()));
      }
      // validate the required field `type`
      TypeEnum.validateJsonElement(jsonObj.get("type"));
  }

  public static class CustomTypeAdapterFactory implements TypeAdapterFactory {
    @SuppressWarnings("unchecked")
    @Override
    public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
       if (!Message.class.isAssignableFrom(type.getRawType())) {
         return null; // this class only serializes 'Message' and its subtypes
       }
       final TypeAdapter<JsonElement> elementAdapter = gson.getAdapter(JsonElement.class);
       final TypeAdapter<Message> thisAdapter
                        = gson.getDelegateAdapter(this, TypeToken.get(Message.class));

       return (TypeAdapter<T>) new TypeAdapter<Message>() {
           @Override
           public void write(JsonWriter out, Message value) throws IOException {
             JsonObject obj = thisAdapter.toJsonTree(value).getAsJsonObject();
             obj.remove("additionalProperties");
             // serialize additional properties
             if (value.getAdditionalProperties() != null) {
               for (Map.Entry<String, Object> entry : value.getAdditionalProperties().entrySet()) {
                 if (entry.getValue() instanceof String)
                   obj.addProperty(entry.getKey(), (String) entry.getValue());
                 else if (entry.getValue() instanceof Number)
                   obj.addProperty(entry.getKey(), (Number) entry.getValue());
                 else if (entry.getValue() instanceof Boolean)
                   obj.addProperty(entry.getKey(), (Boolean) entry.getValue());
                 else if (entry.getValue() instanceof Character)
                   obj.addProperty(entry.getKey(), (Character) entry.getValue());
                 else {
                   JsonElement jsonElement = gson.toJsonTree(entry.getValue());
                   if (jsonElement.isJsonArray()) {
                     obj.add(entry.getKey(), jsonElement.getAsJsonArray());
                   } else {
                     obj.add(entry.getKey(), jsonElement.getAsJsonObject());
                   }
                 }
               }
             }
             elementAdapter.write(out, obj);
           }

           @Override
           public Message read(JsonReader in) throws IOException {
             JsonElement jsonElement = elementAdapter.read(in);
             validateJsonElement(jsonElement);
             JsonObject jsonObj = jsonElement.getAsJsonObject();
             // store additional fields in the deserialized instance
             Message instance = thisAdapter.fromJsonTree(jsonObj);
             for (Map.Entry<String, JsonElement> entry : jsonObj.entrySet()) {
               if (!openapiFields.contains(entry.getKey())) {
                 if (entry.getValue().isJsonPrimitive()) { // primitive type
                   if (entry.getValue().getAsJsonPrimitive().isString())
                     instance.putAdditionalProperty(entry.getKey(), entry.getValue().getAsString());
                   else if (entry.getValue().getAsJsonPrimitive().isNumber())
                     instance.putAdditionalProperty(entry.getKey(), entry.getValue().getAsNumber());
                   else if (entry.getValue().getAsJsonPrimitive().isBoolean())
                     instance.putAdditionalProperty(entry.getKey(), entry.getValue().getAsBoolean());
                   else
                     throw new IllegalArgumentException(String.format("The field `%s` has unknown primitive type. Value: %s", entry.getKey(), entry.getValue().toString()));
                 } else if (entry.getValue().isJsonArray()) {
                     instance.putAdditionalProperty(entry.getKey(), gson.fromJson(entry.getValue(), List.class));
                 } else { // JSON object
                     instance.putAdditionalProperty(entry.getKey(), gson.fromJson(entry.getValue(), HashMap.class));
                 }
               }
             }
             return instance;
           }

       }.nullSafe();
    }
  }

  /**
   * Create an instance of Message given an JSON string
   *
   * @param jsonString JSON string
   * @return An instance of Message
   * @throws IOException if the JSON string is invalid with respect to Message
   */
  public static Message fromJson(String jsonString) throws IOException {
    return JSON.getGson().fromJson(jsonString, Message.class);
  }

  /**
   * Convert an instance of Message to an JSON string
   *
   * @return JSON string
   */
  public String toJson() {
    return JSON.getGson().toJson(this);
  }
}

