/*
 * Stream Chat API
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: v80.2.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package org.openapitools.client.model;

import java.util.Objects;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;
import java.util.Arrays;
import org.openapitools.client.model.AudioSettings;
import org.openapitools.client.model.BackstageSettings;
import org.openapitools.client.model.BroadcastSettings;
import org.openapitools.client.model.GeofenceSettings;
import org.openapitools.client.model.RecordSettings;
import org.openapitools.client.model.RingSettings;
import org.openapitools.client.model.ScreensharingSettings;
import org.openapitools.client.model.TranscriptionSettings;
import org.openapitools.client.model.VideoSettings;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonArray;
import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;
import com.google.gson.TypeAdapterFactory;
import com.google.gson.reflect.TypeToken;
import com.google.gson.TypeAdapter;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;

import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import org.openapitools.client.JSON;

/**
 * CallSettings
 */
@javax.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen", date = "2024-10-12T12:41:11.429997-04:00[America/New_York]", comments = "Generator version: 7.9.0")
public class CallSettings {
  public static final String SERIALIZED_NAME_AUDIO = "audio";
  @SerializedName(SERIALIZED_NAME_AUDIO)
  private AudioSettings audio;

  public static final String SERIALIZED_NAME_BACKSTAGE = "backstage";
  @SerializedName(SERIALIZED_NAME_BACKSTAGE)
  private BackstageSettings backstage;

  public static final String SERIALIZED_NAME_BROADCASTING = "broadcasting";
  @SerializedName(SERIALIZED_NAME_BROADCASTING)
  private BroadcastSettings broadcasting;

  public static final String SERIALIZED_NAME_GEOFENCING = "geofencing";
  @SerializedName(SERIALIZED_NAME_GEOFENCING)
  private GeofenceSettings geofencing;

  public static final String SERIALIZED_NAME_RECORDING = "recording";
  @SerializedName(SERIALIZED_NAME_RECORDING)
  private RecordSettings recording;

  public static final String SERIALIZED_NAME_RING = "ring";
  @SerializedName(SERIALIZED_NAME_RING)
  private RingSettings ring;

  public static final String SERIALIZED_NAME_SCREENSHARING = "screensharing";
  @SerializedName(SERIALIZED_NAME_SCREENSHARING)
  private ScreensharingSettings screensharing;

  public static final String SERIALIZED_NAME_TRANSCRIPTION = "transcription";
  @SerializedName(SERIALIZED_NAME_TRANSCRIPTION)
  private TranscriptionSettings transcription;

  public static final String SERIALIZED_NAME_VIDEO = "video";
  @SerializedName(SERIALIZED_NAME_VIDEO)
  private VideoSettings video;

  public CallSettings() {
  }

  public CallSettings audio(AudioSettings audio) {
    this.audio = audio;
    return this;
  }

  /**
   * Get audio
   * @return audio
   */
  @javax.annotation.Nullable
  public AudioSettings getAudio() {
    return audio;
  }

  public void setAudio(AudioSettings audio) {
    this.audio = audio;
  }


  public CallSettings backstage(BackstageSettings backstage) {
    this.backstage = backstage;
    return this;
  }

  /**
   * Get backstage
   * @return backstage
   */
  @javax.annotation.Nullable
  public BackstageSettings getBackstage() {
    return backstage;
  }

  public void setBackstage(BackstageSettings backstage) {
    this.backstage = backstage;
  }


  public CallSettings broadcasting(BroadcastSettings broadcasting) {
    this.broadcasting = broadcasting;
    return this;
  }

  /**
   * Get broadcasting
   * @return broadcasting
   */
  @javax.annotation.Nullable
  public BroadcastSettings getBroadcasting() {
    return broadcasting;
  }

  public void setBroadcasting(BroadcastSettings broadcasting) {
    this.broadcasting = broadcasting;
  }


  public CallSettings geofencing(GeofenceSettings geofencing) {
    this.geofencing = geofencing;
    return this;
  }

  /**
   * Get geofencing
   * @return geofencing
   */
  @javax.annotation.Nullable
  public GeofenceSettings getGeofencing() {
    return geofencing;
  }

  public void setGeofencing(GeofenceSettings geofencing) {
    this.geofencing = geofencing;
  }


  public CallSettings recording(RecordSettings recording) {
    this.recording = recording;
    return this;
  }

  /**
   * Get recording
   * @return recording
   */
  @javax.annotation.Nullable
  public RecordSettings getRecording() {
    return recording;
  }

  public void setRecording(RecordSettings recording) {
    this.recording = recording;
  }


  public CallSettings ring(RingSettings ring) {
    this.ring = ring;
    return this;
  }

  /**
   * Get ring
   * @return ring
   */
  @javax.annotation.Nullable
  public RingSettings getRing() {
    return ring;
  }

  public void setRing(RingSettings ring) {
    this.ring = ring;
  }


  public CallSettings screensharing(ScreensharingSettings screensharing) {
    this.screensharing = screensharing;
    return this;
  }

  /**
   * Get screensharing
   * @return screensharing
   */
  @javax.annotation.Nullable
  public ScreensharingSettings getScreensharing() {
    return screensharing;
  }

  public void setScreensharing(ScreensharingSettings screensharing) {
    this.screensharing = screensharing;
  }


  public CallSettings transcription(TranscriptionSettings transcription) {
    this.transcription = transcription;
    return this;
  }

  /**
   * Get transcription
   * @return transcription
   */
  @javax.annotation.Nullable
  public TranscriptionSettings getTranscription() {
    return transcription;
  }

  public void setTranscription(TranscriptionSettings transcription) {
    this.transcription = transcription;
  }


  public CallSettings video(VideoSettings video) {
    this.video = video;
    return this;
  }

  /**
   * Get video
   * @return video
   */
  @javax.annotation.Nullable
  public VideoSettings getVideo() {
    return video;
  }

  public void setVideo(VideoSettings video) {
    this.video = video;
  }



  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    CallSettings callSettings = (CallSettings) o;
    return Objects.equals(this.audio, callSettings.audio) &&
        Objects.equals(this.backstage, callSettings.backstage) &&
        Objects.equals(this.broadcasting, callSettings.broadcasting) &&
        Objects.equals(this.geofencing, callSettings.geofencing) &&
        Objects.equals(this.recording, callSettings.recording) &&
        Objects.equals(this.ring, callSettings.ring) &&
        Objects.equals(this.screensharing, callSettings.screensharing) &&
        Objects.equals(this.transcription, callSettings.transcription) &&
        Objects.equals(this.video, callSettings.video);
  }

  @Override
  public int hashCode() {
    return Objects.hash(audio, backstage, broadcasting, geofencing, recording, ring, screensharing, transcription, video);
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class CallSettings {\n");
    sb.append("    audio: ").append(toIndentedString(audio)).append("\n");
    sb.append("    backstage: ").append(toIndentedString(backstage)).append("\n");
    sb.append("    broadcasting: ").append(toIndentedString(broadcasting)).append("\n");
    sb.append("    geofencing: ").append(toIndentedString(geofencing)).append("\n");
    sb.append("    recording: ").append(toIndentedString(recording)).append("\n");
    sb.append("    ring: ").append(toIndentedString(ring)).append("\n");
    sb.append("    screensharing: ").append(toIndentedString(screensharing)).append("\n");
    sb.append("    transcription: ").append(toIndentedString(transcription)).append("\n");
    sb.append("    video: ").append(toIndentedString(video)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }


  public static HashSet<String> openapiFields;
  public static HashSet<String> openapiRequiredFields;

  static {
    // a set of all properties/fields (JSON key names)
    openapiFields = new HashSet<String>();
    openapiFields.add("audio");
    openapiFields.add("backstage");
    openapiFields.add("broadcasting");
    openapiFields.add("geofencing");
    openapiFields.add("recording");
    openapiFields.add("ring");
    openapiFields.add("screensharing");
    openapiFields.add("transcription");
    openapiFields.add("video");

    // a set of required properties/fields (JSON key names)
    openapiRequiredFields = new HashSet<String>();
  }

  /**
   * Validates the JSON Element and throws an exception if issues found
   *
   * @param jsonElement JSON Element
   * @throws IOException if the JSON Element is invalid with respect to CallSettings
   */
  public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      if (jsonElement == null) {
        if (!CallSettings.openapiRequiredFields.isEmpty()) { // has required fields but JSON element is null
          throw new IllegalArgumentException(String.format("The required field(s) %s in CallSettings is not found in the empty JSON string", CallSettings.openapiRequiredFields.toString()));
        }
      }

      Set<Map.Entry<String, JsonElement>> entries = jsonElement.getAsJsonObject().entrySet();
      // check to see if the JSON string contains additional fields
      for (Map.Entry<String, JsonElement> entry : entries) {
        if (!CallSettings.openapiFields.contains(entry.getKey())) {
          throw new IllegalArgumentException(String.format("The field `%s` in the JSON string is not defined in the `CallSettings` properties. JSON: %s", entry.getKey(), jsonElement.toString()));
        }
      }
        JsonObject jsonObj = jsonElement.getAsJsonObject();
      // validate the optional field `audio`
      if (jsonObj.get("audio") != null && !jsonObj.get("audio").isJsonNull()) {
        AudioSettings.validateJsonElement(jsonObj.get("audio"));
      }
      // validate the optional field `backstage`
      if (jsonObj.get("backstage") != null && !jsonObj.get("backstage").isJsonNull()) {
        BackstageSettings.validateJsonElement(jsonObj.get("backstage"));
      }
      // validate the optional field `broadcasting`
      if (jsonObj.get("broadcasting") != null && !jsonObj.get("broadcasting").isJsonNull()) {
        BroadcastSettings.validateJsonElement(jsonObj.get("broadcasting"));
      }
      // validate the optional field `geofencing`
      if (jsonObj.get("geofencing") != null && !jsonObj.get("geofencing").isJsonNull()) {
        GeofenceSettings.validateJsonElement(jsonObj.get("geofencing"));
      }
      // validate the optional field `recording`
      if (jsonObj.get("recording") != null && !jsonObj.get("recording").isJsonNull()) {
        RecordSettings.validateJsonElement(jsonObj.get("recording"));
      }
      // validate the optional field `ring`
      if (jsonObj.get("ring") != null && !jsonObj.get("ring").isJsonNull()) {
        RingSettings.validateJsonElement(jsonObj.get("ring"));
      }
      // validate the optional field `screensharing`
      if (jsonObj.get("screensharing") != null && !jsonObj.get("screensharing").isJsonNull()) {
        ScreensharingSettings.validateJsonElement(jsonObj.get("screensharing"));
      }
      // validate the optional field `transcription`
      if (jsonObj.get("transcription") != null && !jsonObj.get("transcription").isJsonNull()) {
        TranscriptionSettings.validateJsonElement(jsonObj.get("transcription"));
      }
      // validate the optional field `video`
      if (jsonObj.get("video") != null && !jsonObj.get("video").isJsonNull()) {
        VideoSettings.validateJsonElement(jsonObj.get("video"));
      }
  }

  public static class CustomTypeAdapterFactory implements TypeAdapterFactory {
    @SuppressWarnings("unchecked")
    @Override
    public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
       if (!CallSettings.class.isAssignableFrom(type.getRawType())) {
         return null; // this class only serializes 'CallSettings' and its subtypes
       }
       final TypeAdapter<JsonElement> elementAdapter = gson.getAdapter(JsonElement.class);
       final TypeAdapter<CallSettings> thisAdapter
                        = gson.getDelegateAdapter(this, TypeToken.get(CallSettings.class));

       return (TypeAdapter<T>) new TypeAdapter<CallSettings>() {
           @Override
           public void write(JsonWriter out, CallSettings value) throws IOException {
             JsonObject obj = thisAdapter.toJsonTree(value).getAsJsonObject();
             elementAdapter.write(out, obj);
           }

           @Override
           public CallSettings read(JsonReader in) throws IOException {
             JsonElement jsonElement = elementAdapter.read(in);
             validateJsonElement(jsonElement);
             return thisAdapter.fromJsonTree(jsonElement);
           }

       }.nullSafe();
    }
  }

  /**
   * Create an instance of CallSettings given an JSON string
   *
   * @param jsonString JSON string
   * @return An instance of CallSettings
   * @throws IOException if the JSON string is invalid with respect to CallSettings
   */
  public static CallSettings fromJson(String jsonString) throws IOException {
    return JSON.getGson().fromJson(jsonString, CallSettings.class);
  }

  /**
   * Convert an instance of CallSettings to an JSON string
   *
   * @return JSON string
   */
  public String toJson() {
    return JSON.getGson().toJson(this);
  }
}

