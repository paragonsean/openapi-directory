/*
 * Frankie Financial API
 * ------   This API allows developers to integrate the Frankie Financial Compliance Utility into their applications. The API allows:   - Checking name, address, date of birth against national databases   - Validating Australian driver's licences, passports, medicare, visas and other Australian national ID documents   - Validating Australian electricity bills   - Validating NZ driver's licences   - Validating Chinese bank cards and national ID card   - Validating International passports and national ID documents   - PEP, Sanctions, Watchlist and adverse media checking   - Australian visa checks    - Fraud list and fraud background checks   - ID validation and selfie check comparisons.    ------     Industry specific services    - Comparing Australian electricity retailers for a better deal.  ------     KYB specific services    - Query organisation ownership   - Perform KYC & AML checks on shareholders, beneficial owners and office bearers.   - Query credit score and credit reports   - International company searches   - International company profiles    ------   The full version of this documentation along with supplemental articles can be found here:   - https://apidocs.frankiefinancial.com/  The traditional Swagger view of this documentation can be found here:   - https://app.swaggerhub.com/apis-docs/FrankieFinancial/kycutility  ------   Sandbox base URL is:   - https://api.demo.frankiefinancial.io/compliance/v1.2      - We do have an old sandbox at https://sandbox.frankiefinancial.com/compliance/v1.2 but this has been retired.    - All calls are the same as production, only with canned data.     - Full Swagger definition, along with test data for playing in the sandbox can be obtained once initial commercial discussions have commenced.    - Production and optional UAT access will be opened up only to those with a signed commercial contract.    ------   Contact us at hello@frankiefinancial.com to speak with a sales rep about issuing a Customer ID and Sandbox api key. 
 *
 * The version of the OpenAPI document: 1.5.3
 * Contact: dev-support@frankiefinancial.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package org.openapitools.client.api;

import org.openapitools.client.ApiException;
import org.openapitools.client.model.AcceptedEntityResultObject;
import org.openapitools.client.model.BasicStatusResultObject;
import org.openapitools.client.model.CheckEntityCheckResultObject;
import org.openapitools.client.model.CheckResultUpdateObject;
import org.openapitools.client.model.EntityCheckDetailsObject;
import org.openapitools.client.model.EntityIDVDetailsObject;
import org.openapitools.client.model.EntityIDVResultObject;
import org.openapitools.client.model.EntityObject;
import org.openapitools.client.model.EntityResultObject;
import org.openapitools.client.model.EntitySearchResultObject;
import org.openapitools.client.model.ErrorObject;
import java.util.UUID;
import org.junit.jupiter.api.Disabled;
import org.junit.jupiter.api.Test;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

/**
 * API tests for EntityApi
 */
@Disabled
public class EntityApiTest {

    private final EntityApi api = new EntityApi();

    /**
     * Create and Verify Entity
     *
     * Create an entity object. An entity object can be used to simply store data around a given identity. You can attach ID documents, scans, PDFs, photos, videos, etc to the entity if you wish and these may be processed later (using the /scan function) to extract useful information. Or you can manually supply the  information if you choose.  If the entity is successfully created, take the details and documents provided, and set about verifying them all. So for example, you might extract:  * The name from the entity.name object * The address from the entity.address object * The DoB..  All documents that are attached to the entity will also be verified (if possible).  You can also specify the level of detail returned using the resultLevel parameter. You can choose \&quot;summary\&quot; or \&quot;full\&quot;. For the \&quot;profile\&quot; check type you can also select \&quot;simple\&quot; to only get the entity profile result.  SPECIAL NOTE: A \&quot;Full\&quot; response includes details of all checks and how they map against each element, along with all the details of pep/sanctions/etc checks too.  Your account also needs to be configured to support a full response too (talk to your account manager for more information). If you&#39;re not configured for full responses, we&#39;ll only return summary level data regardless. 
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void createCheckEntityTest() throws ApiException {
        UUID xFrankieCustomerID = null;
        String checkType = null;
        String resultLevel = null;
        EntityCheckDetailsObject entityDetails = null;
        UUID xFrankieCustomerChildID = null;
        Integer xFrankieBackground = null;
        CheckEntityCheckResultObject response = api.createCheckEntity(xFrankieCustomerID, checkType, resultLevel, entityDetails, xFrankieCustomerChildID, xFrankieBackground);
        // TODO: test validations
    }

    /**
     * Create Entity and Push Self-Verification Link
     *
     * Create an entity object and begin the process of verification after pushing a message to a mobile number.  The entity will receive a link on their mobile and will then be guided through a series of steps to capture and OCR scan their ID, and perform a selfie comparison. We&#39;ll then attempt to verify the data received and push a notification back to the calling customer.  At a minimum, you will need to supply the name and a MOBILE_PHONE document type.   SPECIAL NOTE: This will only ever return a 202 response if successfully accepted. You will need to ensure your account is configured for push notifications. Contact developer supprt to arrange this. 
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void createCheckEntityPushToMobileTest() throws ApiException {
        UUID xFrankieCustomerID = null;
        EntityCheckDetailsObject entityDetails = null;
        UUID xFrankieCustomerChildID = null;
        Integer xFrankieBackground = null;
        Boolean nopush = null;
        AcceptedEntityResultObject response = api.createCheckEntityPushToMobile(xFrankieCustomerID, entityDetails, xFrankieCustomerChildID, xFrankieBackground, nopush);
        // TODO: test validations
    }

    /**
     * Create New Entity.
     *
     * Create an entity object. An entity object can be used to simply store data around a given identity. You can attach ID documents, scans, PDFs, photos, videos, etc to the entity if you wish and these may be processed later (using the /scan function) to extract useful information. Or you can manually supply the  information if you choose.  Entity objects can be used to run a check, using the data held in the records. 
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void createEntityTest() throws ApiException {
        UUID xFrankieCustomerID = null;
        UUID xFrankieCustomerChildID = null;
        EntityObject entity = null;
        EntityResultObject response = api.createEntity(xFrankieCustomerID, xFrankieCustomerChildID, entity);
        // TODO: test validations
    }

    /**
     * Create Entity and Get IDV Token
     *
     * Create an entity object and if successful, obtain a token for use in an ID Validation service SDK (web or native app)   At a minimum, you will need to supply:  - the entity familyName.   - the entity givenName    For best results, you should gather the DoB, address, ID document details as well before  calling the initProcess function.  SPECIAL NOTE 1: Tokens have a limited lifespan, typically only 1 hour. Make sure you&#39;ve used it or you will need to create another using update version of this function.   SPECIAL NOTE 2: This function will need to be followed up with a call to /entity/{id}/idvalidate/initProcess once you&#39;ve collected all your data in your app/web capture process. 
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void createEntityGetIDVTokenTest() throws ApiException {
        UUID xFrankieCustomerID = null;
        EntityIDVDetailsObject entityIDVDetails = null;
        UUID xFrankieCustomerChildID = null;
        EntityIDVResultObject response = api.createEntityGetIDVToken(xFrankieCustomerID, entityIDVDetails, xFrankieCustomerChildID);
        // TODO: test validations
    }

    /**
     * Delete Entity
     *
     * Marks the entity as deleted in the system, and no further operations or general queries may be executed against it by the Customer. If another customer is presently relying on this data, it will still be available to them (but only in the partially anonymised form they originally had.  An entity and its related data is only completely deleted from the database when either:    - a) There are no more references to it (i.e. it has been DELETEd by all Customers relying on the data), and 12 months have passed.      - b) The actual consumer who owns the data makes a direct request. If this occurs, then all subscribing Customers will be notified that this entity has been removed and they will need to contact them if needed in order to update their own records again. 
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void deleteEntityTest() throws ApiException {
        UUID xFrankieCustomerID = null;
        UUID entityId = null;
        UUID xFrankieCustomerChildID = null;
        Integer xFrankieBackground = null;
        BasicStatusResultObject response = api.deleteEntity(xFrankieCustomerID, entityId, xFrankieCustomerChildID, xFrankieBackground);
        // TODO: test validations
    }

    /**
     * Retrieve Entity Details
     *
     * Query the current status and details of a given entityId. 
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void queryEntityTest() throws ApiException {
        UUID xFrankieCustomerID = null;
        UUID entityId = null;
        UUID xFrankieCustomerChildID = null;
        EntityResultObject response = api.queryEntity(xFrankieCustomerID, entityId, xFrankieCustomerChildID);
        // TODO: test validations
    }

    /**
     * Retrieve Entity Verication Check Details 
     *
     * Get the complete list of all checks that have been performed upon a given entity and its documents, including the checks that have been performed by others (in those cases you just get the id, status and date run, none of the details). 
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void queryEntityChecksTest() throws ApiException {
        UUID xFrankieCustomerID = null;
        UUID entityId = null;
        UUID xFrankieCustomerChildID = null;
        Boolean alldata = null;
        CheckEntityCheckResultObject response = api.queryEntityChecks(xFrankieCustomerID, entityId, xFrankieCustomerChildID, alldata);
        // TODO: test validations
    }

    /**
     * Retrieve Entity Details and Document Scan Data 
     *
     * Query the current status and details of a given entityId. Also returns all attached document file data, not just the metadata. Equivalent to a get /document/{documentId}/full) 
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void queryEntityFullTest() throws ApiException {
        UUID xFrankieCustomerID = null;
        UUID entityId = null;
        UUID xFrankieCustomerChildID = null;
        EntityResultObject response = api.queryEntityFull(xFrankieCustomerID, entityId, xFrankieCustomerChildID);
        // TODO: test validations
    }

    /**
     * Search for Entity
     *
     *  Search for an existing entity that matches the criteria supplied  Criteria are supplied in the form of a populated entity object, with the name/address/DoB details supplied. You can also include documents that can be used to further refine your search (see the /document/search function for minimum requirements for a document search)  At an absolute minimum, you must supply one of the following combinations:    * name.familyName +   * name.givenNames      or      * name.familyName +   * one identityDocument object (that meets minimum criteria)    Obviously, the more data you provide, the better search results we can provide.  The service will return a list of matching entities with confidence levels.  If you are the \&quot;owner\&quot; of the entity - i.e. the same CustomerID and CustomerChildID (if relevant) - then the full details of the entity and any owned documents will be returned, except for the contents of any attached scans.  If you are not the owner of the entity (or linked documents), then just the ID and confidence level is returned. You can still use this ID to retrieve any check results (see GET  /entity/{entityId}/checks and GET /document/{documentId}/checks)  Note: This functionality must be enabled by Frankie administrators. Please contact your sales representative if you wish to discuss this. 
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void searchEntityTest() throws ApiException {
        UUID xFrankieCustomerID = null;
        EntityObject searchEntity = null;
        UUID xFrankieCustomerChildID = null;
        EntitySearchResultObject response = api.searchEntity(xFrankieCustomerID, searchEntity, xFrankieCustomerChildID);
        // TODO: test validations
    }

    /**
     * Update Check Result State
     *
     * Internal only  Update a given KYC or AML check result status in order to force a re-evaluation of the overall check result. 
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void updateCheckClassResultTest() throws ApiException {
        UUID xFrankieCustomerID = null;
        UUID entityId = null;
        UUID checkId = null;
        String checkClass = null;
        String checkClassId = null;
        String status = null;
        UUID xFrankieCustomerChildID = null;
        Boolean undo = null;
        CheckEntityCheckResultObject response = api.updateCheckClassResult(xFrankieCustomerID, entityId, checkId, checkClass, checkClassId, status, xFrankieCustomerChildID, undo);
        // TODO: test validations
    }

    /**
     * Update Check Result States (Batch)
     *
     * Internal only  Update a given set of KYC and/or AML check result statuses in order to force a re-evaluation of the overall check result. 
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void updateCheckClassResultsTest() throws ApiException {
        UUID xFrankieCustomerID = null;
        UUID entityId = null;
        UUID checkId = null;
        String checkClass = null;
        CheckResultUpdateObject checkResultUpdate = null;
        UUID xFrankieCustomerChildID = null;
        CheckEntityCheckResultObject response = api.updateCheckClassResults(xFrankieCustomerID, entityId, checkId, checkClass, checkResultUpdate, xFrankieCustomerChildID);
        // TODO: test validations
    }

    /**
     * Update Entity and Verify Details
     *
     * Take the details and documents provided in the entity, and set about verifying them all. So for example, you might extract:  * The name from the entity.name object * The address from the entity.address object * The DoB..  All documents that are presently attached to the entity will also be verified (if requested)  You can also specify the level of detail returned using the resultLevel parameter. You can choose \&quot;summary\&quot; or \&quot;full\&quot;. For the \&quot;profile\&quot; check type you can also select \&quot;simple\&quot; to only get the entity profile result.  SPECIAL NOTE: A \&quot;Full\&quot; response includes details of all checks and how they map against each element, along with all the details of pep/sanctions/etc checks too.  Your account also needs to be configured to support a full response too (talk to your account manager for more information). If you&#39;re not configured for full responses, we&#39;ll only return summary level data regardless. 
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void updateCheckEntityTest() throws ApiException {
        UUID xFrankieCustomerID = null;
        UUID entityId = null;
        String checkType = null;
        String resultLevel = null;
        EntityCheckDetailsObject entityDetails = null;
        UUID xFrankieCustomerChildID = null;
        Integer xFrankieBackground = null;
        Boolean force = null;
        Boolean noInvalidate = null;
        CheckEntityCheckResultObject response = api.updateCheckEntity(xFrankieCustomerID, entityId, checkType, resultLevel, entityDetails, xFrankieCustomerChildID, xFrankieBackground, force, noInvalidate);
        // TODO: test validations
    }

    /**
     * Update Entity and Push Self-Verification Link
     *
     * Update an existing entity object and begin the process of verification after pushing a message to a mobile number.  The entity will receive a link on their mobile and will then be guided through a series of steps to capture and OCR scan their ID, and perform a selfie comparison. We&#39;ll then attempt to verify the data received and push a notification back to the calling customer.  At a minimum, you will need to supply the name and a MOBILE_PHONE document type.         If you wish to skip the detail capture and jump straight to the ID and selfie capture, the append the call with the ?phase&#x3D;2 parameter.   SPECIAL NOTE: This will only ever return a 202 response if successfully accepted. You will need to ensure your account is configured for push notifications. Contact developer supprt to arrange this. 
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void updateCheckEntityPushToMobileTest() throws ApiException {
        UUID xFrankieCustomerID = null;
        UUID entityId = null;
        EntityCheckDetailsObject entityDetails = null;
        UUID xFrankieCustomerChildID = null;
        Integer xFrankieBackground = null;
        Boolean nopush = null;
        Integer phase = null;
        AcceptedEntityResultObject response = api.updateCheckEntityPushToMobile(xFrankieCustomerID, entityId, entityDetails, xFrankieCustomerChildID, xFrankieBackground, nopush, phase);
        // TODO: test validations
    }

    /**
     * Update Existing Entity.
     *
     * Using a previously uploaded but incomplete Entity, you can optionally supply updated details (such as corrections on a previous address), along with one or more additional ID docs/scans (e.g. new documents to parse, etc). 
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void updateEntityTest() throws ApiException {
        UUID xFrankieCustomerID = null;
        UUID entityId = null;
        EntityObject entity = null;
        UUID xFrankieCustomerChildID = null;
        Integer xFrankieBackground = null;
        Boolean noInvalidate = null;
        EntityResultObject response = api.updateEntity(xFrankieCustomerID, entityId, entity, xFrankieCustomerChildID, xFrankieBackground, noInvalidate);
        // TODO: test validations
    }

    /**
     * Update Entity and Get IDV Token
     *
     * Update an entity object and if successful, obtain a token for use in an ID Validation service SDK (web or native app)   At a minimum, the entity will need to have a name. For best results, you should gather the DoB, address, ID document details as well before calling the initProcess function.  SPECIAL NOTE 1: Tokens have a limited lifespan, typically only 1 hour. Make sure you&#39;ve used it or you will need to create another using update version of this function.   SPECIAL NOTE 2: This function will need to be followed up with a call to /entity/{id}/idvalidate/initProcess once you&#39;ve collected all your data in your app/web capture process. 
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void updateEntityGetIDVTokenTest() throws ApiException {
        UUID xFrankieCustomerID = null;
        UUID entityId = null;
        EntityIDVDetailsObject entityIDVDetails = null;
        UUID xFrankieCustomerChildID = null;
        EntityIDVResultObject response = api.updateEntityGetIDVToken(xFrankieCustomerID, entityId, entityIDVDetails, xFrankieCustomerChildID);
        // TODO: test validations
    }

    /**
     * Update Entity and Initiate IDV Process
     *
     * Update an entity object and if successful, start the process of downloading the captured data and processing the reports and results of the ID validation process.   At a minimum, the entity will need to have a name. For best results, you should gather the DoB, address, ID document details as well before calling this initProcess function, or supply the details as part of this update. 
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void updateEntityInitIDVProcessTest() throws ApiException {
        UUID xFrankieCustomerID = null;
        UUID entityId = null;
        EntityCheckDetailsObject entityDetails = null;
        UUID xFrankieCustomerChildID = null;
        EntityIDVResultObject response = api.updateEntityInitIDVProcess(xFrankieCustomerID, entityId, entityDetails, xFrankieCustomerChildID);
        // TODO: test validations
    }

    /**
     * Update Entity States
     *
     * Internal only  Add a special internal &#39;entity result&#39; to superceed any previous real checks until the next one. 
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void updateEntityStateTest() throws ApiException {
        UUID xFrankieCustomerID = null;
        UUID entityId = null;
        UUID xFrankieCustomerChildID = null;
        String set = null;
        String risk = null;
        String comment = null;
        CheckEntityCheckResultObject response = api.updateEntityState(xFrankieCustomerID, entityId, xFrankieCustomerChildID, set, risk, comment);
        // TODO: test validations
    }

}
