/*
 * Frankie Financial API
 * ------   This API allows developers to integrate the Frankie Financial Compliance Utility into their applications. The API allows:   - Checking name, address, date of birth against national databases   - Validating Australian driver's licences, passports, medicare, visas and other Australian national ID documents   - Validating Australian electricity bills   - Validating NZ driver's licences   - Validating Chinese bank cards and national ID card   - Validating International passports and national ID documents   - PEP, Sanctions, Watchlist and adverse media checking   - Australian visa checks    - Fraud list and fraud background checks   - ID validation and selfie check comparisons.    ------     Industry specific services    - Comparing Australian electricity retailers for a better deal.  ------     KYB specific services    - Query organisation ownership   - Perform KYC & AML checks on shareholders, beneficial owners and office bearers.   - Query credit score and credit reports   - International company searches   - International company profiles    ------   The full version of this documentation along with supplemental articles can be found here:   - https://apidocs.frankiefinancial.com/  The traditional Swagger view of this documentation can be found here:   - https://app.swaggerhub.com/apis-docs/FrankieFinancial/kycutility  ------   Sandbox base URL is:   - https://api.demo.frankiefinancial.io/compliance/v1.2      - We do have an old sandbox at https://sandbox.frankiefinancial.com/compliance/v1.2 but this has been retired.    - All calls are the same as production, only with canned data.     - Full Swagger definition, along with test data for playing in the sandbox can be obtained once initial commercial discussions have commenced.    - Production and optional UAT access will be opened up only to those with a signed commercial contract.    ------   Contact us at hello@frankiefinancial.com to speak with a sales rep about issuing a Customer ID and Sandbox api key. 
 *
 * The version of the OpenAPI document: 1.5.3
 * Contact: dev-support@frankiefinancial.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package org.openapitools.client.api;

import org.openapitools.client.ApiCallback;
import org.openapitools.client.ApiClient;
import org.openapitools.client.ApiException;
import org.openapitools.client.ApiResponse;
import org.openapitools.client.Configuration;
import org.openapitools.client.Pair;
import org.openapitools.client.ProgressRequestBody;
import org.openapitools.client.ProgressResponseBody;

import com.google.gson.reflect.TypeToken;

import java.io.IOException;


import org.openapitools.client.model.AcceptedEntityResultObject;
import org.openapitools.client.model.BasicStatusResultObject;
import org.openapitools.client.model.CheckEntityCheckResultObject;
import org.openapitools.client.model.CheckResultUpdateObject;
import org.openapitools.client.model.EntityCheckDetailsObject;
import org.openapitools.client.model.EntityIDVDetailsObject;
import org.openapitools.client.model.EntityIDVResultObject;
import org.openapitools.client.model.EntityObject;
import org.openapitools.client.model.EntityResultObject;
import org.openapitools.client.model.EntitySearchResultObject;
import org.openapitools.client.model.ErrorObject;
import java.util.UUID;

import java.lang.reflect.Type;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

public class EntityApi {
    private ApiClient localVarApiClient;
    private int localHostIndex;
    private String localCustomBaseUrl;

    public EntityApi() {
        this(Configuration.getDefaultApiClient());
    }

    public EntityApi(ApiClient apiClient) {
        this.localVarApiClient = apiClient;
    }

    public ApiClient getApiClient() {
        return localVarApiClient;
    }

    public void setApiClient(ApiClient apiClient) {
        this.localVarApiClient = apiClient;
    }

    public int getHostIndex() {
        return localHostIndex;
    }

    public void setHostIndex(int hostIndex) {
        this.localHostIndex = hostIndex;
    }

    public String getCustomBaseUrl() {
        return localCustomBaseUrl;
    }

    public void setCustomBaseUrl(String customBaseUrl) {
        this.localCustomBaseUrl = customBaseUrl;
    }

    /**
     * Build call for createCheckEntity
     * @param xFrankieCustomerID Customer ID issued by Frankie Financial. This will never change. Your API key, which is mapped to this identity, will change over time.  (required)
     * @param checkType When creating a new check, you need to define the checks you wish to run.    The checkType is make up of a comma separated list of the types of check you wish to run. The order of the requested checks is not important, they will be re-ordered by the service and in some cases, depending on your account configuration, may be skipped.    The validation that is performed on the requested checks is to:   - ensure the check type is known   - is suitable for the type of entity (no KYC for organisations)   - disallow manual (mKYC) check with any other kind of KYC   - disallow mixing the \&quot;profile\&quot; check with any other kind of check.  The supported check types are:  Profile:   - \&quot;profile\&quot;: By arrangement with Frankie we will create a \&quot;profile\&quot; check type that applies checks according to a recipe that you assign to the entity from a predefined set of profiles.      The profile to use will be taken from the entity.entityProfile field if set, or be run through a set of configurable rules to determine which one to use.      Profiles provide a pre-defined combination of individual checkTypes (see the list below). But they offer a lot more besides, including rules for determining default settings, inbuilt data aging and other configurable features.   They also allow for a new result set top be returned that provides a more detailed and useful breakdown of the check/verification process.      Entity Profiles are a recent feature (since v1.4.0) but are now the default checkType to use with Frankie Financial.  **Individual Check Types**  Whilst we strongly recommend the use of the \&quot;profile\&quot; checktype, it does map of any combination of the types below. If you wish to use these individually, please contact developer support for more details on how to use these effectively.  Entity Checks - One of:   - \&quot;one_plus\&quot;: Checks name, address and DoB against a minimum of 1 data source. (also known as a 1+1)   - \&quot;two_plus\&quot;: Checks name, address and DoB against a minimum of 2 independent data sources (also known as a 2+2)  ID Checks - One of:   - \&quot;id\&quot;: Checks all of the identity documents, but not necessarily the entity itself independently. Use this in conjunction with a one_plus or two_plus for more.   - \&quot;visa\&quot;:    ID Validate - One of:   - \&quot;idvalidate\&quot;: Checks to see if photo ID has had OCR scanning, ID document validation and photo comparison run against it. Can be used in conjunction with any of the KYC/ID/AML checks.    Manual Check:   - \&quot;manual\&quot;: (mKYC) Checks user has a sufficient amount of operator verified ID and will then \&quot;pass\&quot; all Entity and ID related checks.    Fraud Checks - One or more of:   - \&quot;fraudlist\&quot;: Checks to see if the identity appears on any known fraud lists. Should be run after KYC/ID checks have passed.   - \&quot;fraudcheck\&quot;: Checks external ID services to see if details appear in fraud detection services (e.g. EmailAge or FraudNet)    PEP Checks - One of:   - \&quot;pep\&quot;: Will only run PEP/Sanctions checks (no identity verification)   - \&quot;pep_media\&quot;: Will run PEP/Sanctions checks, as well as watchlist and adverse media checks. (no identity verification)      * NOTE: These checks will ONLY run if either the KYC/ID checks have been run prior, or it is the only check requested.    Custom:   - By arrangement with Frankie you can define your own KYC check type.      This will allow you to set the minimum number of matches for:     - name      - date of birth     - address     - government id      This allows for alternatives to the \&quot;standard\&quot; two_plus or one_plus (note, these can be overridden too).  (required)
     * @param resultLevel How much detail we return.   Acceptable values are:   * simple - Only available with \&quot;profile\&quot; check type. Returns just an EntityProfileResultObject (which is also included for \&quot;profile\&quot; checks at the other result levels), and a CheckEntityCheckResultObjectEntityResult with just the entity details but no separate results.   * summary   * full - You need to have your account configured for this.  (required)
     * @param entityDetails The entity and any associated / additional information to be checked (required)
     * @param xFrankieCustomerChildID If, as a Frankie Customer, you are acting on behalf of your own customers, then you can populate this field with a Frankie-assigned ID.  Note: If using a CustomerChildID, you will also need a separate api_key for each child.  Any documents, checks, entities that are created when this field has been populated will now be tied to this CustomerID + CustomerChildID combination. Just as Customers cannot see data created by other Customers, so too a Customer&#39;s Children will not be able to see each other&#39;s data.  A Customer can see the documents/entities and checks of all their Children.  (optional)
     * @param xFrankieBackground If this header parameter is supplied and set to 1, then the request will not wait for the process to finish, and will return a 202 if there are no obvious errors in the input. The request will then run in the background and send a notification back to the customer. See out callback API for details on this.  See more details here:   https://apidocs.frankiefinancial.com/docs/asynchronous-calls-backgrounding-processes  (optional)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> The request was valid and able to be processed in some fashion. Results may or may not be successful, but it was completed as far as practical with no actual errors. Returns the entity object as it stands now. No docScan file data from any attached ID documents will be returned unless the /full variant is requested. </td><td>  -  </td></tr>
        <tr><td> 202 </td><td> The request was valid and can potentially be fulfilled. The Frankie service has now accepted responsibility for processing and we will either push the results to you, or send you a notification, depending on the request and your configuration. </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad request. One or more request fields is either missing or incorrect. Details are in the error response. </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> The request has failed an authorisation check. This can happen for a variety of reasons, such as an invalid or expired API key, or invalid Customer/CustomerChildIDs.  * NOTE: This does not include attempts to read/write data you don&#39;t have access to - that&#39;s a 404 error (as we don&#39;t want to leak information through guessing)  </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Cannot return response. In the case of a query, or reference to a specific entity/check/etc, it means that the requested item was not found, or you don&#39;t have access to it. Please check your query before trying again. </td><td>  -  </td></tr>
        <tr><td> 405 </td><td> A request to POST an update to an object was not allowed due to it&#39;s state. This may indicate an already completed check, or a document that has been processed. You need to create a new document/check if you wish to update the object in question. </td><td>  -  </td></tr>
        <tr><td> 415 </td><td> For requests with payloads, an unsupported Content-Type was specified. The Frankie Financial API only supports a content type of application/json. </td><td>  -  </td></tr>
        <tr><td> 422 </td><td> Unprocessable request. This can be triggered in a number of ways. * An attempt to force a check or scan to run, but there is insufficient data to be able to do so. * An attempt to run a utility comparison, or similar industry/document/entity specific scan or process on an unsupported document type (e.g. electricity comparison on a passport) Details of what is required will be in the issues list of the error response.  </td><td>  -  </td></tr>
        <tr><td> 429 </td><td> The API client is making too many concurrent requests, and some are being throttled. Throttled requests can be retried after a short delay. </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Unexpected error. Something went wrong during the checking process. </td><td>  -  </td></tr>
        <tr><td> 503 </td><td> All of the ID sources configured by the customer are unavailable, or there is no available document processor. </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call createCheckEntityCall(UUID xFrankieCustomerID, String checkType, String resultLevel, EntityCheckDetailsObject entityDetails, UUID xFrankieCustomerChildID, Integer xFrankieBackground, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = entityDetails;

        // create path and map variables
        String localVarPath = "/entity/new/verify/{checkType}/{resultLevel}"
            .replace("{" + "checkType" + "}", localVarApiClient.escapeString(checkType.toString()))
            .replace("{" + "resultLevel" + "}", localVarApiClient.escapeString(resultLevel.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (xFrankieCustomerID != null) {
            localVarHeaderParams.put("X-Frankie-CustomerID", localVarApiClient.parameterToString(xFrankieCustomerID));
        }

        if (xFrankieCustomerChildID != null) {
            localVarHeaderParams.put("X-Frankie-CustomerChildID", localVarApiClient.parameterToString(xFrankieCustomerChildID));
        }

        if (xFrankieBackground != null) {
            localVarHeaderParams.put("X-Frankie-Background", localVarApiClient.parameterToString(xFrankieBackground));
        }

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            "application/json"
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "api_key" };
        return localVarApiClient.buildCall(basePath, localVarPath, "POST", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call createCheckEntityValidateBeforeCall(UUID xFrankieCustomerID, String checkType, String resultLevel, EntityCheckDetailsObject entityDetails, UUID xFrankieCustomerChildID, Integer xFrankieBackground, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'xFrankieCustomerID' is set
        if (xFrankieCustomerID == null) {
            throw new ApiException("Missing the required parameter 'xFrankieCustomerID' when calling createCheckEntity(Async)");
        }

        // verify the required parameter 'checkType' is set
        if (checkType == null) {
            throw new ApiException("Missing the required parameter 'checkType' when calling createCheckEntity(Async)");
        }

        // verify the required parameter 'resultLevel' is set
        if (resultLevel == null) {
            throw new ApiException("Missing the required parameter 'resultLevel' when calling createCheckEntity(Async)");
        }

        // verify the required parameter 'entityDetails' is set
        if (entityDetails == null) {
            throw new ApiException("Missing the required parameter 'entityDetails' when calling createCheckEntity(Async)");
        }

        return createCheckEntityCall(xFrankieCustomerID, checkType, resultLevel, entityDetails, xFrankieCustomerChildID, xFrankieBackground, _callback);

    }

    /**
     * Create and Verify Entity
     * Create an entity object. An entity object can be used to simply store data around a given identity. You can attach ID documents, scans, PDFs, photos, videos, etc to the entity if you wish and these may be processed later (using the /scan function) to extract useful information. Or you can manually supply the  information if you choose.  If the entity is successfully created, take the details and documents provided, and set about verifying them all. So for example, you might extract:  * The name from the entity.name object * The address from the entity.address object * The DoB..  All documents that are attached to the entity will also be verified (if possible).  You can also specify the level of detail returned using the resultLevel parameter. You can choose \&quot;summary\&quot; or \&quot;full\&quot;. For the \&quot;profile\&quot; check type you can also select \&quot;simple\&quot; to only get the entity profile result.  SPECIAL NOTE: A \&quot;Full\&quot; response includes details of all checks and how they map against each element, along with all the details of pep/sanctions/etc checks too.  Your account also needs to be configured to support a full response too (talk to your account manager for more information). If you&#39;re not configured for full responses, we&#39;ll only return summary level data regardless. 
     * @param xFrankieCustomerID Customer ID issued by Frankie Financial. This will never change. Your API key, which is mapped to this identity, will change over time.  (required)
     * @param checkType When creating a new check, you need to define the checks you wish to run.    The checkType is make up of a comma separated list of the types of check you wish to run. The order of the requested checks is not important, they will be re-ordered by the service and in some cases, depending on your account configuration, may be skipped.    The validation that is performed on the requested checks is to:   - ensure the check type is known   - is suitable for the type of entity (no KYC for organisations)   - disallow manual (mKYC) check with any other kind of KYC   - disallow mixing the \&quot;profile\&quot; check with any other kind of check.  The supported check types are:  Profile:   - \&quot;profile\&quot;: By arrangement with Frankie we will create a \&quot;profile\&quot; check type that applies checks according to a recipe that you assign to the entity from a predefined set of profiles.      The profile to use will be taken from the entity.entityProfile field if set, or be run through a set of configurable rules to determine which one to use.      Profiles provide a pre-defined combination of individual checkTypes (see the list below). But they offer a lot more besides, including rules for determining default settings, inbuilt data aging and other configurable features.   They also allow for a new result set top be returned that provides a more detailed and useful breakdown of the check/verification process.      Entity Profiles are a recent feature (since v1.4.0) but are now the default checkType to use with Frankie Financial.  **Individual Check Types**  Whilst we strongly recommend the use of the \&quot;profile\&quot; checktype, it does map of any combination of the types below. If you wish to use these individually, please contact developer support for more details on how to use these effectively.  Entity Checks - One of:   - \&quot;one_plus\&quot;: Checks name, address and DoB against a minimum of 1 data source. (also known as a 1+1)   - \&quot;two_plus\&quot;: Checks name, address and DoB against a minimum of 2 independent data sources (also known as a 2+2)  ID Checks - One of:   - \&quot;id\&quot;: Checks all of the identity documents, but not necessarily the entity itself independently. Use this in conjunction with a one_plus or two_plus for more.   - \&quot;visa\&quot;:    ID Validate - One of:   - \&quot;idvalidate\&quot;: Checks to see if photo ID has had OCR scanning, ID document validation and photo comparison run against it. Can be used in conjunction with any of the KYC/ID/AML checks.    Manual Check:   - \&quot;manual\&quot;: (mKYC) Checks user has a sufficient amount of operator verified ID and will then \&quot;pass\&quot; all Entity and ID related checks.    Fraud Checks - One or more of:   - \&quot;fraudlist\&quot;: Checks to see if the identity appears on any known fraud lists. Should be run after KYC/ID checks have passed.   - \&quot;fraudcheck\&quot;: Checks external ID services to see if details appear in fraud detection services (e.g. EmailAge or FraudNet)    PEP Checks - One of:   - \&quot;pep\&quot;: Will only run PEP/Sanctions checks (no identity verification)   - \&quot;pep_media\&quot;: Will run PEP/Sanctions checks, as well as watchlist and adverse media checks. (no identity verification)      * NOTE: These checks will ONLY run if either the KYC/ID checks have been run prior, or it is the only check requested.    Custom:   - By arrangement with Frankie you can define your own KYC check type.      This will allow you to set the minimum number of matches for:     - name      - date of birth     - address     - government id      This allows for alternatives to the \&quot;standard\&quot; two_plus or one_plus (note, these can be overridden too).  (required)
     * @param resultLevel How much detail we return.   Acceptable values are:   * simple - Only available with \&quot;profile\&quot; check type. Returns just an EntityProfileResultObject (which is also included for \&quot;profile\&quot; checks at the other result levels), and a CheckEntityCheckResultObjectEntityResult with just the entity details but no separate results.   * summary   * full - You need to have your account configured for this.  (required)
     * @param entityDetails The entity and any associated / additional information to be checked (required)
     * @param xFrankieCustomerChildID If, as a Frankie Customer, you are acting on behalf of your own customers, then you can populate this field with a Frankie-assigned ID.  Note: If using a CustomerChildID, you will also need a separate api_key for each child.  Any documents, checks, entities that are created when this field has been populated will now be tied to this CustomerID + CustomerChildID combination. Just as Customers cannot see data created by other Customers, so too a Customer&#39;s Children will not be able to see each other&#39;s data.  A Customer can see the documents/entities and checks of all their Children.  (optional)
     * @param xFrankieBackground If this header parameter is supplied and set to 1, then the request will not wait for the process to finish, and will return a 202 if there are no obvious errors in the input. The request will then run in the background and send a notification back to the customer. See out callback API for details on this.  See more details here:   https://apidocs.frankiefinancial.com/docs/asynchronous-calls-backgrounding-processes  (optional)
     * @return CheckEntityCheckResultObject
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> The request was valid and able to be processed in some fashion. Results may or may not be successful, but it was completed as far as practical with no actual errors. Returns the entity object as it stands now. No docScan file data from any attached ID documents will be returned unless the /full variant is requested. </td><td>  -  </td></tr>
        <tr><td> 202 </td><td> The request was valid and can potentially be fulfilled. The Frankie service has now accepted responsibility for processing and we will either push the results to you, or send you a notification, depending on the request and your configuration. </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad request. One or more request fields is either missing or incorrect. Details are in the error response. </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> The request has failed an authorisation check. This can happen for a variety of reasons, such as an invalid or expired API key, or invalid Customer/CustomerChildIDs.  * NOTE: This does not include attempts to read/write data you don&#39;t have access to - that&#39;s a 404 error (as we don&#39;t want to leak information through guessing)  </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Cannot return response. In the case of a query, or reference to a specific entity/check/etc, it means that the requested item was not found, or you don&#39;t have access to it. Please check your query before trying again. </td><td>  -  </td></tr>
        <tr><td> 405 </td><td> A request to POST an update to an object was not allowed due to it&#39;s state. This may indicate an already completed check, or a document that has been processed. You need to create a new document/check if you wish to update the object in question. </td><td>  -  </td></tr>
        <tr><td> 415 </td><td> For requests with payloads, an unsupported Content-Type was specified. The Frankie Financial API only supports a content type of application/json. </td><td>  -  </td></tr>
        <tr><td> 422 </td><td> Unprocessable request. This can be triggered in a number of ways. * An attempt to force a check or scan to run, but there is insufficient data to be able to do so. * An attempt to run a utility comparison, or similar industry/document/entity specific scan or process on an unsupported document type (e.g. electricity comparison on a passport) Details of what is required will be in the issues list of the error response.  </td><td>  -  </td></tr>
        <tr><td> 429 </td><td> The API client is making too many concurrent requests, and some are being throttled. Throttled requests can be retried after a short delay. </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Unexpected error. Something went wrong during the checking process. </td><td>  -  </td></tr>
        <tr><td> 503 </td><td> All of the ID sources configured by the customer are unavailable, or there is no available document processor. </td><td>  -  </td></tr>
     </table>
     */
    public CheckEntityCheckResultObject createCheckEntity(UUID xFrankieCustomerID, String checkType, String resultLevel, EntityCheckDetailsObject entityDetails, UUID xFrankieCustomerChildID, Integer xFrankieBackground) throws ApiException {
        ApiResponse<CheckEntityCheckResultObject> localVarResp = createCheckEntityWithHttpInfo(xFrankieCustomerID, checkType, resultLevel, entityDetails, xFrankieCustomerChildID, xFrankieBackground);
        return localVarResp.getData();
    }

    /**
     * Create and Verify Entity
     * Create an entity object. An entity object can be used to simply store data around a given identity. You can attach ID documents, scans, PDFs, photos, videos, etc to the entity if you wish and these may be processed later (using the /scan function) to extract useful information. Or you can manually supply the  information if you choose.  If the entity is successfully created, take the details and documents provided, and set about verifying them all. So for example, you might extract:  * The name from the entity.name object * The address from the entity.address object * The DoB..  All documents that are attached to the entity will also be verified (if possible).  You can also specify the level of detail returned using the resultLevel parameter. You can choose \&quot;summary\&quot; or \&quot;full\&quot;. For the \&quot;profile\&quot; check type you can also select \&quot;simple\&quot; to only get the entity profile result.  SPECIAL NOTE: A \&quot;Full\&quot; response includes details of all checks and how they map against each element, along with all the details of pep/sanctions/etc checks too.  Your account also needs to be configured to support a full response too (talk to your account manager for more information). If you&#39;re not configured for full responses, we&#39;ll only return summary level data regardless. 
     * @param xFrankieCustomerID Customer ID issued by Frankie Financial. This will never change. Your API key, which is mapped to this identity, will change over time.  (required)
     * @param checkType When creating a new check, you need to define the checks you wish to run.    The checkType is make up of a comma separated list of the types of check you wish to run. The order of the requested checks is not important, they will be re-ordered by the service and in some cases, depending on your account configuration, may be skipped.    The validation that is performed on the requested checks is to:   - ensure the check type is known   - is suitable for the type of entity (no KYC for organisations)   - disallow manual (mKYC) check with any other kind of KYC   - disallow mixing the \&quot;profile\&quot; check with any other kind of check.  The supported check types are:  Profile:   - \&quot;profile\&quot;: By arrangement with Frankie we will create a \&quot;profile\&quot; check type that applies checks according to a recipe that you assign to the entity from a predefined set of profiles.      The profile to use will be taken from the entity.entityProfile field if set, or be run through a set of configurable rules to determine which one to use.      Profiles provide a pre-defined combination of individual checkTypes (see the list below). But they offer a lot more besides, including rules for determining default settings, inbuilt data aging and other configurable features.   They also allow for a new result set top be returned that provides a more detailed and useful breakdown of the check/verification process.      Entity Profiles are a recent feature (since v1.4.0) but are now the default checkType to use with Frankie Financial.  **Individual Check Types**  Whilst we strongly recommend the use of the \&quot;profile\&quot; checktype, it does map of any combination of the types below. If you wish to use these individually, please contact developer support for more details on how to use these effectively.  Entity Checks - One of:   - \&quot;one_plus\&quot;: Checks name, address and DoB against a minimum of 1 data source. (also known as a 1+1)   - \&quot;two_plus\&quot;: Checks name, address and DoB against a minimum of 2 independent data sources (also known as a 2+2)  ID Checks - One of:   - \&quot;id\&quot;: Checks all of the identity documents, but not necessarily the entity itself independently. Use this in conjunction with a one_plus or two_plus for more.   - \&quot;visa\&quot;:    ID Validate - One of:   - \&quot;idvalidate\&quot;: Checks to see if photo ID has had OCR scanning, ID document validation and photo comparison run against it. Can be used in conjunction with any of the KYC/ID/AML checks.    Manual Check:   - \&quot;manual\&quot;: (mKYC) Checks user has a sufficient amount of operator verified ID and will then \&quot;pass\&quot; all Entity and ID related checks.    Fraud Checks - One or more of:   - \&quot;fraudlist\&quot;: Checks to see if the identity appears on any known fraud lists. Should be run after KYC/ID checks have passed.   - \&quot;fraudcheck\&quot;: Checks external ID services to see if details appear in fraud detection services (e.g. EmailAge or FraudNet)    PEP Checks - One of:   - \&quot;pep\&quot;: Will only run PEP/Sanctions checks (no identity verification)   - \&quot;pep_media\&quot;: Will run PEP/Sanctions checks, as well as watchlist and adverse media checks. (no identity verification)      * NOTE: These checks will ONLY run if either the KYC/ID checks have been run prior, or it is the only check requested.    Custom:   - By arrangement with Frankie you can define your own KYC check type.      This will allow you to set the minimum number of matches for:     - name      - date of birth     - address     - government id      This allows for alternatives to the \&quot;standard\&quot; two_plus or one_plus (note, these can be overridden too).  (required)
     * @param resultLevel How much detail we return.   Acceptable values are:   * simple - Only available with \&quot;profile\&quot; check type. Returns just an EntityProfileResultObject (which is also included for \&quot;profile\&quot; checks at the other result levels), and a CheckEntityCheckResultObjectEntityResult with just the entity details but no separate results.   * summary   * full - You need to have your account configured for this.  (required)
     * @param entityDetails The entity and any associated / additional information to be checked (required)
     * @param xFrankieCustomerChildID If, as a Frankie Customer, you are acting on behalf of your own customers, then you can populate this field with a Frankie-assigned ID.  Note: If using a CustomerChildID, you will also need a separate api_key for each child.  Any documents, checks, entities that are created when this field has been populated will now be tied to this CustomerID + CustomerChildID combination. Just as Customers cannot see data created by other Customers, so too a Customer&#39;s Children will not be able to see each other&#39;s data.  A Customer can see the documents/entities and checks of all their Children.  (optional)
     * @param xFrankieBackground If this header parameter is supplied and set to 1, then the request will not wait for the process to finish, and will return a 202 if there are no obvious errors in the input. The request will then run in the background and send a notification back to the customer. See out callback API for details on this.  See more details here:   https://apidocs.frankiefinancial.com/docs/asynchronous-calls-backgrounding-processes  (optional)
     * @return ApiResponse&lt;CheckEntityCheckResultObject&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> The request was valid and able to be processed in some fashion. Results may or may not be successful, but it was completed as far as practical with no actual errors. Returns the entity object as it stands now. No docScan file data from any attached ID documents will be returned unless the /full variant is requested. </td><td>  -  </td></tr>
        <tr><td> 202 </td><td> The request was valid and can potentially be fulfilled. The Frankie service has now accepted responsibility for processing and we will either push the results to you, or send you a notification, depending on the request and your configuration. </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad request. One or more request fields is either missing or incorrect. Details are in the error response. </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> The request has failed an authorisation check. This can happen for a variety of reasons, such as an invalid or expired API key, or invalid Customer/CustomerChildIDs.  * NOTE: This does not include attempts to read/write data you don&#39;t have access to - that&#39;s a 404 error (as we don&#39;t want to leak information through guessing)  </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Cannot return response. In the case of a query, or reference to a specific entity/check/etc, it means that the requested item was not found, or you don&#39;t have access to it. Please check your query before trying again. </td><td>  -  </td></tr>
        <tr><td> 405 </td><td> A request to POST an update to an object was not allowed due to it&#39;s state. This may indicate an already completed check, or a document that has been processed. You need to create a new document/check if you wish to update the object in question. </td><td>  -  </td></tr>
        <tr><td> 415 </td><td> For requests with payloads, an unsupported Content-Type was specified. The Frankie Financial API only supports a content type of application/json. </td><td>  -  </td></tr>
        <tr><td> 422 </td><td> Unprocessable request. This can be triggered in a number of ways. * An attempt to force a check or scan to run, but there is insufficient data to be able to do so. * An attempt to run a utility comparison, or similar industry/document/entity specific scan or process on an unsupported document type (e.g. electricity comparison on a passport) Details of what is required will be in the issues list of the error response.  </td><td>  -  </td></tr>
        <tr><td> 429 </td><td> The API client is making too many concurrent requests, and some are being throttled. Throttled requests can be retried after a short delay. </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Unexpected error. Something went wrong during the checking process. </td><td>  -  </td></tr>
        <tr><td> 503 </td><td> All of the ID sources configured by the customer are unavailable, or there is no available document processor. </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<CheckEntityCheckResultObject> createCheckEntityWithHttpInfo(UUID xFrankieCustomerID, String checkType, String resultLevel, EntityCheckDetailsObject entityDetails, UUID xFrankieCustomerChildID, Integer xFrankieBackground) throws ApiException {
        okhttp3.Call localVarCall = createCheckEntityValidateBeforeCall(xFrankieCustomerID, checkType, resultLevel, entityDetails, xFrankieCustomerChildID, xFrankieBackground, null);
        Type localVarReturnType = new TypeToken<CheckEntityCheckResultObject>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Create and Verify Entity (asynchronously)
     * Create an entity object. An entity object can be used to simply store data around a given identity. You can attach ID documents, scans, PDFs, photos, videos, etc to the entity if you wish and these may be processed later (using the /scan function) to extract useful information. Or you can manually supply the  information if you choose.  If the entity is successfully created, take the details and documents provided, and set about verifying them all. So for example, you might extract:  * The name from the entity.name object * The address from the entity.address object * The DoB..  All documents that are attached to the entity will also be verified (if possible).  You can also specify the level of detail returned using the resultLevel parameter. You can choose \&quot;summary\&quot; or \&quot;full\&quot;. For the \&quot;profile\&quot; check type you can also select \&quot;simple\&quot; to only get the entity profile result.  SPECIAL NOTE: A \&quot;Full\&quot; response includes details of all checks and how they map against each element, along with all the details of pep/sanctions/etc checks too.  Your account also needs to be configured to support a full response too (talk to your account manager for more information). If you&#39;re not configured for full responses, we&#39;ll only return summary level data regardless. 
     * @param xFrankieCustomerID Customer ID issued by Frankie Financial. This will never change. Your API key, which is mapped to this identity, will change over time.  (required)
     * @param checkType When creating a new check, you need to define the checks you wish to run.    The checkType is make up of a comma separated list of the types of check you wish to run. The order of the requested checks is not important, they will be re-ordered by the service and in some cases, depending on your account configuration, may be skipped.    The validation that is performed on the requested checks is to:   - ensure the check type is known   - is suitable for the type of entity (no KYC for organisations)   - disallow manual (mKYC) check with any other kind of KYC   - disallow mixing the \&quot;profile\&quot; check with any other kind of check.  The supported check types are:  Profile:   - \&quot;profile\&quot;: By arrangement with Frankie we will create a \&quot;profile\&quot; check type that applies checks according to a recipe that you assign to the entity from a predefined set of profiles.      The profile to use will be taken from the entity.entityProfile field if set, or be run through a set of configurable rules to determine which one to use.      Profiles provide a pre-defined combination of individual checkTypes (see the list below). But they offer a lot more besides, including rules for determining default settings, inbuilt data aging and other configurable features.   They also allow for a new result set top be returned that provides a more detailed and useful breakdown of the check/verification process.      Entity Profiles are a recent feature (since v1.4.0) but are now the default checkType to use with Frankie Financial.  **Individual Check Types**  Whilst we strongly recommend the use of the \&quot;profile\&quot; checktype, it does map of any combination of the types below. If you wish to use these individually, please contact developer support for more details on how to use these effectively.  Entity Checks - One of:   - \&quot;one_plus\&quot;: Checks name, address and DoB against a minimum of 1 data source. (also known as a 1+1)   - \&quot;two_plus\&quot;: Checks name, address and DoB against a minimum of 2 independent data sources (also known as a 2+2)  ID Checks - One of:   - \&quot;id\&quot;: Checks all of the identity documents, but not necessarily the entity itself independently. Use this in conjunction with a one_plus or two_plus for more.   - \&quot;visa\&quot;:    ID Validate - One of:   - \&quot;idvalidate\&quot;: Checks to see if photo ID has had OCR scanning, ID document validation and photo comparison run against it. Can be used in conjunction with any of the KYC/ID/AML checks.    Manual Check:   - \&quot;manual\&quot;: (mKYC) Checks user has a sufficient amount of operator verified ID and will then \&quot;pass\&quot; all Entity and ID related checks.    Fraud Checks - One or more of:   - \&quot;fraudlist\&quot;: Checks to see if the identity appears on any known fraud lists. Should be run after KYC/ID checks have passed.   - \&quot;fraudcheck\&quot;: Checks external ID services to see if details appear in fraud detection services (e.g. EmailAge or FraudNet)    PEP Checks - One of:   - \&quot;pep\&quot;: Will only run PEP/Sanctions checks (no identity verification)   - \&quot;pep_media\&quot;: Will run PEP/Sanctions checks, as well as watchlist and adverse media checks. (no identity verification)      * NOTE: These checks will ONLY run if either the KYC/ID checks have been run prior, or it is the only check requested.    Custom:   - By arrangement with Frankie you can define your own KYC check type.      This will allow you to set the minimum number of matches for:     - name      - date of birth     - address     - government id      This allows for alternatives to the \&quot;standard\&quot; two_plus or one_plus (note, these can be overridden too).  (required)
     * @param resultLevel How much detail we return.   Acceptable values are:   * simple - Only available with \&quot;profile\&quot; check type. Returns just an EntityProfileResultObject (which is also included for \&quot;profile\&quot; checks at the other result levels), and a CheckEntityCheckResultObjectEntityResult with just the entity details but no separate results.   * summary   * full - You need to have your account configured for this.  (required)
     * @param entityDetails The entity and any associated / additional information to be checked (required)
     * @param xFrankieCustomerChildID If, as a Frankie Customer, you are acting on behalf of your own customers, then you can populate this field with a Frankie-assigned ID.  Note: If using a CustomerChildID, you will also need a separate api_key for each child.  Any documents, checks, entities that are created when this field has been populated will now be tied to this CustomerID + CustomerChildID combination. Just as Customers cannot see data created by other Customers, so too a Customer&#39;s Children will not be able to see each other&#39;s data.  A Customer can see the documents/entities and checks of all their Children.  (optional)
     * @param xFrankieBackground If this header parameter is supplied and set to 1, then the request will not wait for the process to finish, and will return a 202 if there are no obvious errors in the input. The request will then run in the background and send a notification back to the customer. See out callback API for details on this.  See more details here:   https://apidocs.frankiefinancial.com/docs/asynchronous-calls-backgrounding-processes  (optional)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> The request was valid and able to be processed in some fashion. Results may or may not be successful, but it was completed as far as practical with no actual errors. Returns the entity object as it stands now. No docScan file data from any attached ID documents will be returned unless the /full variant is requested. </td><td>  -  </td></tr>
        <tr><td> 202 </td><td> The request was valid and can potentially be fulfilled. The Frankie service has now accepted responsibility for processing and we will either push the results to you, or send you a notification, depending on the request and your configuration. </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad request. One or more request fields is either missing or incorrect. Details are in the error response. </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> The request has failed an authorisation check. This can happen for a variety of reasons, such as an invalid or expired API key, or invalid Customer/CustomerChildIDs.  * NOTE: This does not include attempts to read/write data you don&#39;t have access to - that&#39;s a 404 error (as we don&#39;t want to leak information through guessing)  </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Cannot return response. In the case of a query, or reference to a specific entity/check/etc, it means that the requested item was not found, or you don&#39;t have access to it. Please check your query before trying again. </td><td>  -  </td></tr>
        <tr><td> 405 </td><td> A request to POST an update to an object was not allowed due to it&#39;s state. This may indicate an already completed check, or a document that has been processed. You need to create a new document/check if you wish to update the object in question. </td><td>  -  </td></tr>
        <tr><td> 415 </td><td> For requests with payloads, an unsupported Content-Type was specified. The Frankie Financial API only supports a content type of application/json. </td><td>  -  </td></tr>
        <tr><td> 422 </td><td> Unprocessable request. This can be triggered in a number of ways. * An attempt to force a check or scan to run, but there is insufficient data to be able to do so. * An attempt to run a utility comparison, or similar industry/document/entity specific scan or process on an unsupported document type (e.g. electricity comparison on a passport) Details of what is required will be in the issues list of the error response.  </td><td>  -  </td></tr>
        <tr><td> 429 </td><td> The API client is making too many concurrent requests, and some are being throttled. Throttled requests can be retried after a short delay. </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Unexpected error. Something went wrong during the checking process. </td><td>  -  </td></tr>
        <tr><td> 503 </td><td> All of the ID sources configured by the customer are unavailable, or there is no available document processor. </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call createCheckEntityAsync(UUID xFrankieCustomerID, String checkType, String resultLevel, EntityCheckDetailsObject entityDetails, UUID xFrankieCustomerChildID, Integer xFrankieBackground, final ApiCallback<CheckEntityCheckResultObject> _callback) throws ApiException {

        okhttp3.Call localVarCall = createCheckEntityValidateBeforeCall(xFrankieCustomerID, checkType, resultLevel, entityDetails, xFrankieCustomerChildID, xFrankieBackground, _callback);
        Type localVarReturnType = new TypeToken<CheckEntityCheckResultObject>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for createCheckEntityPushToMobile
     * @param xFrankieCustomerID Customer ID issued by Frankie Financial. This will never change. Your API key, which is mapped to this identity, will change over time.  (required)
     * @param entityDetails The entity and any associated / additional information to be checked (required)
     * @param xFrankieCustomerChildID If, as a Frankie Customer, you are acting on behalf of your own customers, then you can populate this field with a Frankie-assigned ID.  Note: If using a CustomerChildID, you will also need a separate api_key for each child.  Any documents, checks, entities that are created when this field has been populated will now be tied to this CustomerID + CustomerChildID combination. Just as Customers cannot see data created by other Customers, so too a Customer&#39;s Children will not be able to see each other&#39;s data.  A Customer can see the documents/entities and checks of all their Children.  (optional)
     * @param xFrankieBackground If this header parameter is supplied and set to 1, then the request will not wait for the process to finish, and will return a 202 if there are no obvious errors in the input. The request will then run in the background and send a notification back to the customer. See out callback API for details on this.  See more details here:   https://apidocs.frankiefinancial.com/docs/asynchronous-calls-backgrounding-processes  (optional)
     * @param nopush If set to true, then no SMS/email will be pushed. It will be up to the API caller to manage the delivery of the link.  (optional)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 202 </td><td> The request was valid and can potentially be fulfilled. The Frankie service has now accepted responsibility for processing and we will either push the results to you, or send you a notification, depending on the request and your configuration. </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad request. One or more request fields is either missing or incorrect. Details are in the error response. </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> The request has failed an authorisation check. This can happen for a variety of reasons, such as an invalid or expired API key, or invalid Customer/CustomerChildIDs.  * NOTE: This does not include attempts to read/write data you don&#39;t have access to - that&#39;s a 404 error (as we don&#39;t want to leak information through guessing)  </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Cannot return response. In the case of a query, or reference to a specific entity/check/etc, it means that the requested item was not found, or you don&#39;t have access to it. Please check your query before trying again. </td><td>  -  </td></tr>
        <tr><td> 405 </td><td> A request to POST an update to an object was not allowed due to it&#39;s state. This may indicate an already completed check, or a document that has been processed. You need to create a new document/check if you wish to update the object in question. </td><td>  -  </td></tr>
        <tr><td> 415 </td><td> For requests with payloads, an unsupported Content-Type was specified. The Frankie Financial API only supports a content type of application/json. </td><td>  -  </td></tr>
        <tr><td> 422 </td><td> Unprocessable request. This can be triggered in a number of ways. * An attempt to force a check or scan to run, but there is insufficient data to be able to do so. * An attempt to run a utility comparison, or similar industry/document/entity specific scan or process on an unsupported document type (e.g. electricity comparison on a passport) Details of what is required will be in the issues list of the error response.  </td><td>  -  </td></tr>
        <tr><td> 429 </td><td> The API client is making too many concurrent requests, and some are being throttled. Throttled requests can be retried after a short delay. </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Unexpected error. Something went wrong during the checking process. </td><td>  -  </td></tr>
        <tr><td> 503 </td><td> All of the ID sources configured by the customer are unavailable, or there is no available document processor. </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call createCheckEntityPushToMobileCall(UUID xFrankieCustomerID, EntityCheckDetailsObject entityDetails, UUID xFrankieCustomerChildID, Integer xFrankieBackground, Boolean nopush, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = entityDetails;

        // create path and map variables
        String localVarPath = "/entity/new/verify/pushToMobile";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (nopush != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("nopush", nopush));
        }

        if (xFrankieCustomerID != null) {
            localVarHeaderParams.put("X-Frankie-CustomerID", localVarApiClient.parameterToString(xFrankieCustomerID));
        }

        if (xFrankieCustomerChildID != null) {
            localVarHeaderParams.put("X-Frankie-CustomerChildID", localVarApiClient.parameterToString(xFrankieCustomerChildID));
        }

        if (xFrankieBackground != null) {
            localVarHeaderParams.put("X-Frankie-Background", localVarApiClient.parameterToString(xFrankieBackground));
        }

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            "application/json"
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "api_key" };
        return localVarApiClient.buildCall(basePath, localVarPath, "POST", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call createCheckEntityPushToMobileValidateBeforeCall(UUID xFrankieCustomerID, EntityCheckDetailsObject entityDetails, UUID xFrankieCustomerChildID, Integer xFrankieBackground, Boolean nopush, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'xFrankieCustomerID' is set
        if (xFrankieCustomerID == null) {
            throw new ApiException("Missing the required parameter 'xFrankieCustomerID' when calling createCheckEntityPushToMobile(Async)");
        }

        // verify the required parameter 'entityDetails' is set
        if (entityDetails == null) {
            throw new ApiException("Missing the required parameter 'entityDetails' when calling createCheckEntityPushToMobile(Async)");
        }

        return createCheckEntityPushToMobileCall(xFrankieCustomerID, entityDetails, xFrankieCustomerChildID, xFrankieBackground, nopush, _callback);

    }

    /**
     * Create Entity and Push Self-Verification Link
     * Create an entity object and begin the process of verification after pushing a message to a mobile number.  The entity will receive a link on their mobile and will then be guided through a series of steps to capture and OCR scan their ID, and perform a selfie comparison. We&#39;ll then attempt to verify the data received and push a notification back to the calling customer.  At a minimum, you will need to supply the name and a MOBILE_PHONE document type.   SPECIAL NOTE: This will only ever return a 202 response if successfully accepted. You will need to ensure your account is configured for push notifications. Contact developer supprt to arrange this. 
     * @param xFrankieCustomerID Customer ID issued by Frankie Financial. This will never change. Your API key, which is mapped to this identity, will change over time.  (required)
     * @param entityDetails The entity and any associated / additional information to be checked (required)
     * @param xFrankieCustomerChildID If, as a Frankie Customer, you are acting on behalf of your own customers, then you can populate this field with a Frankie-assigned ID.  Note: If using a CustomerChildID, you will also need a separate api_key for each child.  Any documents, checks, entities that are created when this field has been populated will now be tied to this CustomerID + CustomerChildID combination. Just as Customers cannot see data created by other Customers, so too a Customer&#39;s Children will not be able to see each other&#39;s data.  A Customer can see the documents/entities and checks of all their Children.  (optional)
     * @param xFrankieBackground If this header parameter is supplied and set to 1, then the request will not wait for the process to finish, and will return a 202 if there are no obvious errors in the input. The request will then run in the background and send a notification back to the customer. See out callback API for details on this.  See more details here:   https://apidocs.frankiefinancial.com/docs/asynchronous-calls-backgrounding-processes  (optional)
     * @param nopush If set to true, then no SMS/email will be pushed. It will be up to the API caller to manage the delivery of the link.  (optional)
     * @return AcceptedEntityResultObject
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 202 </td><td> The request was valid and can potentially be fulfilled. The Frankie service has now accepted responsibility for processing and we will either push the results to you, or send you a notification, depending on the request and your configuration. </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad request. One or more request fields is either missing or incorrect. Details are in the error response. </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> The request has failed an authorisation check. This can happen for a variety of reasons, such as an invalid or expired API key, or invalid Customer/CustomerChildIDs.  * NOTE: This does not include attempts to read/write data you don&#39;t have access to - that&#39;s a 404 error (as we don&#39;t want to leak information through guessing)  </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Cannot return response. In the case of a query, or reference to a specific entity/check/etc, it means that the requested item was not found, or you don&#39;t have access to it. Please check your query before trying again. </td><td>  -  </td></tr>
        <tr><td> 405 </td><td> A request to POST an update to an object was not allowed due to it&#39;s state. This may indicate an already completed check, or a document that has been processed. You need to create a new document/check if you wish to update the object in question. </td><td>  -  </td></tr>
        <tr><td> 415 </td><td> For requests with payloads, an unsupported Content-Type was specified. The Frankie Financial API only supports a content type of application/json. </td><td>  -  </td></tr>
        <tr><td> 422 </td><td> Unprocessable request. This can be triggered in a number of ways. * An attempt to force a check or scan to run, but there is insufficient data to be able to do so. * An attempt to run a utility comparison, or similar industry/document/entity specific scan or process on an unsupported document type (e.g. electricity comparison on a passport) Details of what is required will be in the issues list of the error response.  </td><td>  -  </td></tr>
        <tr><td> 429 </td><td> The API client is making too many concurrent requests, and some are being throttled. Throttled requests can be retried after a short delay. </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Unexpected error. Something went wrong during the checking process. </td><td>  -  </td></tr>
        <tr><td> 503 </td><td> All of the ID sources configured by the customer are unavailable, or there is no available document processor. </td><td>  -  </td></tr>
     </table>
     */
    public AcceptedEntityResultObject createCheckEntityPushToMobile(UUID xFrankieCustomerID, EntityCheckDetailsObject entityDetails, UUID xFrankieCustomerChildID, Integer xFrankieBackground, Boolean nopush) throws ApiException {
        ApiResponse<AcceptedEntityResultObject> localVarResp = createCheckEntityPushToMobileWithHttpInfo(xFrankieCustomerID, entityDetails, xFrankieCustomerChildID, xFrankieBackground, nopush);
        return localVarResp.getData();
    }

    /**
     * Create Entity and Push Self-Verification Link
     * Create an entity object and begin the process of verification after pushing a message to a mobile number.  The entity will receive a link on their mobile and will then be guided through a series of steps to capture and OCR scan their ID, and perform a selfie comparison. We&#39;ll then attempt to verify the data received and push a notification back to the calling customer.  At a minimum, you will need to supply the name and a MOBILE_PHONE document type.   SPECIAL NOTE: This will only ever return a 202 response if successfully accepted. You will need to ensure your account is configured for push notifications. Contact developer supprt to arrange this. 
     * @param xFrankieCustomerID Customer ID issued by Frankie Financial. This will never change. Your API key, which is mapped to this identity, will change over time.  (required)
     * @param entityDetails The entity and any associated / additional information to be checked (required)
     * @param xFrankieCustomerChildID If, as a Frankie Customer, you are acting on behalf of your own customers, then you can populate this field with a Frankie-assigned ID.  Note: If using a CustomerChildID, you will also need a separate api_key for each child.  Any documents, checks, entities that are created when this field has been populated will now be tied to this CustomerID + CustomerChildID combination. Just as Customers cannot see data created by other Customers, so too a Customer&#39;s Children will not be able to see each other&#39;s data.  A Customer can see the documents/entities and checks of all their Children.  (optional)
     * @param xFrankieBackground If this header parameter is supplied and set to 1, then the request will not wait for the process to finish, and will return a 202 if there are no obvious errors in the input. The request will then run in the background and send a notification back to the customer. See out callback API for details on this.  See more details here:   https://apidocs.frankiefinancial.com/docs/asynchronous-calls-backgrounding-processes  (optional)
     * @param nopush If set to true, then no SMS/email will be pushed. It will be up to the API caller to manage the delivery of the link.  (optional)
     * @return ApiResponse&lt;AcceptedEntityResultObject&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 202 </td><td> The request was valid and can potentially be fulfilled. The Frankie service has now accepted responsibility for processing and we will either push the results to you, or send you a notification, depending on the request and your configuration. </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad request. One or more request fields is either missing or incorrect. Details are in the error response. </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> The request has failed an authorisation check. This can happen for a variety of reasons, such as an invalid or expired API key, or invalid Customer/CustomerChildIDs.  * NOTE: This does not include attempts to read/write data you don&#39;t have access to - that&#39;s a 404 error (as we don&#39;t want to leak information through guessing)  </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Cannot return response. In the case of a query, or reference to a specific entity/check/etc, it means that the requested item was not found, or you don&#39;t have access to it. Please check your query before trying again. </td><td>  -  </td></tr>
        <tr><td> 405 </td><td> A request to POST an update to an object was not allowed due to it&#39;s state. This may indicate an already completed check, or a document that has been processed. You need to create a new document/check if you wish to update the object in question. </td><td>  -  </td></tr>
        <tr><td> 415 </td><td> For requests with payloads, an unsupported Content-Type was specified. The Frankie Financial API only supports a content type of application/json. </td><td>  -  </td></tr>
        <tr><td> 422 </td><td> Unprocessable request. This can be triggered in a number of ways. * An attempt to force a check or scan to run, but there is insufficient data to be able to do so. * An attempt to run a utility comparison, or similar industry/document/entity specific scan or process on an unsupported document type (e.g. electricity comparison on a passport) Details of what is required will be in the issues list of the error response.  </td><td>  -  </td></tr>
        <tr><td> 429 </td><td> The API client is making too many concurrent requests, and some are being throttled. Throttled requests can be retried after a short delay. </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Unexpected error. Something went wrong during the checking process. </td><td>  -  </td></tr>
        <tr><td> 503 </td><td> All of the ID sources configured by the customer are unavailable, or there is no available document processor. </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<AcceptedEntityResultObject> createCheckEntityPushToMobileWithHttpInfo(UUID xFrankieCustomerID, EntityCheckDetailsObject entityDetails, UUID xFrankieCustomerChildID, Integer xFrankieBackground, Boolean nopush) throws ApiException {
        okhttp3.Call localVarCall = createCheckEntityPushToMobileValidateBeforeCall(xFrankieCustomerID, entityDetails, xFrankieCustomerChildID, xFrankieBackground, nopush, null);
        Type localVarReturnType = new TypeToken<AcceptedEntityResultObject>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Create Entity and Push Self-Verification Link (asynchronously)
     * Create an entity object and begin the process of verification after pushing a message to a mobile number.  The entity will receive a link on their mobile and will then be guided through a series of steps to capture and OCR scan their ID, and perform a selfie comparison. We&#39;ll then attempt to verify the data received and push a notification back to the calling customer.  At a minimum, you will need to supply the name and a MOBILE_PHONE document type.   SPECIAL NOTE: This will only ever return a 202 response if successfully accepted. You will need to ensure your account is configured for push notifications. Contact developer supprt to arrange this. 
     * @param xFrankieCustomerID Customer ID issued by Frankie Financial. This will never change. Your API key, which is mapped to this identity, will change over time.  (required)
     * @param entityDetails The entity and any associated / additional information to be checked (required)
     * @param xFrankieCustomerChildID If, as a Frankie Customer, you are acting on behalf of your own customers, then you can populate this field with a Frankie-assigned ID.  Note: If using a CustomerChildID, you will also need a separate api_key for each child.  Any documents, checks, entities that are created when this field has been populated will now be tied to this CustomerID + CustomerChildID combination. Just as Customers cannot see data created by other Customers, so too a Customer&#39;s Children will not be able to see each other&#39;s data.  A Customer can see the documents/entities and checks of all their Children.  (optional)
     * @param xFrankieBackground If this header parameter is supplied and set to 1, then the request will not wait for the process to finish, and will return a 202 if there are no obvious errors in the input. The request will then run in the background and send a notification back to the customer. See out callback API for details on this.  See more details here:   https://apidocs.frankiefinancial.com/docs/asynchronous-calls-backgrounding-processes  (optional)
     * @param nopush If set to true, then no SMS/email will be pushed. It will be up to the API caller to manage the delivery of the link.  (optional)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 202 </td><td> The request was valid and can potentially be fulfilled. The Frankie service has now accepted responsibility for processing and we will either push the results to you, or send you a notification, depending on the request and your configuration. </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad request. One or more request fields is either missing or incorrect. Details are in the error response. </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> The request has failed an authorisation check. This can happen for a variety of reasons, such as an invalid or expired API key, or invalid Customer/CustomerChildIDs.  * NOTE: This does not include attempts to read/write data you don&#39;t have access to - that&#39;s a 404 error (as we don&#39;t want to leak information through guessing)  </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Cannot return response. In the case of a query, or reference to a specific entity/check/etc, it means that the requested item was not found, or you don&#39;t have access to it. Please check your query before trying again. </td><td>  -  </td></tr>
        <tr><td> 405 </td><td> A request to POST an update to an object was not allowed due to it&#39;s state. This may indicate an already completed check, or a document that has been processed. You need to create a new document/check if you wish to update the object in question. </td><td>  -  </td></tr>
        <tr><td> 415 </td><td> For requests with payloads, an unsupported Content-Type was specified. The Frankie Financial API only supports a content type of application/json. </td><td>  -  </td></tr>
        <tr><td> 422 </td><td> Unprocessable request. This can be triggered in a number of ways. * An attempt to force a check or scan to run, but there is insufficient data to be able to do so. * An attempt to run a utility comparison, or similar industry/document/entity specific scan or process on an unsupported document type (e.g. electricity comparison on a passport) Details of what is required will be in the issues list of the error response.  </td><td>  -  </td></tr>
        <tr><td> 429 </td><td> The API client is making too many concurrent requests, and some are being throttled. Throttled requests can be retried after a short delay. </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Unexpected error. Something went wrong during the checking process. </td><td>  -  </td></tr>
        <tr><td> 503 </td><td> All of the ID sources configured by the customer are unavailable, or there is no available document processor. </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call createCheckEntityPushToMobileAsync(UUID xFrankieCustomerID, EntityCheckDetailsObject entityDetails, UUID xFrankieCustomerChildID, Integer xFrankieBackground, Boolean nopush, final ApiCallback<AcceptedEntityResultObject> _callback) throws ApiException {

        okhttp3.Call localVarCall = createCheckEntityPushToMobileValidateBeforeCall(xFrankieCustomerID, entityDetails, xFrankieCustomerChildID, xFrankieBackground, nopush, _callback);
        Type localVarReturnType = new TypeToken<AcceptedEntityResultObject>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for createEntity
     * @param xFrankieCustomerID Customer ID issued by Frankie Financial. This will never change. Your API key, which is mapped to this identity, will change over time.  (required)
     * @param xFrankieCustomerChildID If, as a Frankie Customer, you are acting on behalf of your own customers, then you can populate this field with a Frankie-assigned ID.  Note: If using a CustomerChildID, you will also need a separate api_key for each child.  Any documents, checks, entities that are created when this field has been populated will now be tied to this CustomerID + CustomerChildID combination. Just as Customers cannot see data created by other Customers, so too a Customer&#39;s Children will not be able to see each other&#39;s data.  A Customer can see the documents/entities and checks of all their Children.  (optional)
     * @param entity  (optional)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> The request was valid and able to be processed in some fashion. Results may or may not be successful, but it was completed as far as practical with no actual errors. Returns the entity object as it stands now. No docScan file data from any attached ID documents will be returned unless the /full variant is requested. </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad request. One or more request fields is either missing or incorrect. Details are in the error response. </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> The request has failed an authorisation check. This can happen for a variety of reasons, such as an invalid or expired API key, or invalid Customer/CustomerChildIDs.  * NOTE: This does not include attempts to read/write data you don&#39;t have access to - that&#39;s a 404 error (as we don&#39;t want to leak information through guessing)  </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Cannot return response. In the case of a query, or reference to a specific entity/check/etc, it means that the requested item was not found, or you don&#39;t have access to it. Please check your query before trying again. </td><td>  -  </td></tr>
        <tr><td> 415 </td><td> For requests with payloads, an unsupported Content-Type was specified. The Frankie Financial API only supports a content type of application/json. </td><td>  -  </td></tr>
        <tr><td> 429 </td><td> The API client is making too many concurrent requests, and some are being throttled. Throttled requests can be retried after a short delay. </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Unexpected error. Something went wrong during the checking process. </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call createEntityCall(UUID xFrankieCustomerID, UUID xFrankieCustomerChildID, EntityObject entity, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = entity;

        // create path and map variables
        String localVarPath = "/entity";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (xFrankieCustomerID != null) {
            localVarHeaderParams.put("X-Frankie-CustomerID", localVarApiClient.parameterToString(xFrankieCustomerID));
        }

        if (xFrankieCustomerChildID != null) {
            localVarHeaderParams.put("X-Frankie-CustomerChildID", localVarApiClient.parameterToString(xFrankieCustomerChildID));
        }

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            "application/json"
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "api_key" };
        return localVarApiClient.buildCall(basePath, localVarPath, "POST", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call createEntityValidateBeforeCall(UUID xFrankieCustomerID, UUID xFrankieCustomerChildID, EntityObject entity, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'xFrankieCustomerID' is set
        if (xFrankieCustomerID == null) {
            throw new ApiException("Missing the required parameter 'xFrankieCustomerID' when calling createEntity(Async)");
        }

        return createEntityCall(xFrankieCustomerID, xFrankieCustomerChildID, entity, _callback);

    }

    /**
     * Create New Entity.
     * Create an entity object. An entity object can be used to simply store data around a given identity. You can attach ID documents, scans, PDFs, photos, videos, etc to the entity if you wish and these may be processed later (using the /scan function) to extract useful information. Or you can manually supply the  information if you choose.  Entity objects can be used to run a check, using the data held in the records. 
     * @param xFrankieCustomerID Customer ID issued by Frankie Financial. This will never change. Your API key, which is mapped to this identity, will change over time.  (required)
     * @param xFrankieCustomerChildID If, as a Frankie Customer, you are acting on behalf of your own customers, then you can populate this field with a Frankie-assigned ID.  Note: If using a CustomerChildID, you will also need a separate api_key for each child.  Any documents, checks, entities that are created when this field has been populated will now be tied to this CustomerID + CustomerChildID combination. Just as Customers cannot see data created by other Customers, so too a Customer&#39;s Children will not be able to see each other&#39;s data.  A Customer can see the documents/entities and checks of all their Children.  (optional)
     * @param entity  (optional)
     * @return EntityResultObject
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> The request was valid and able to be processed in some fashion. Results may or may not be successful, but it was completed as far as practical with no actual errors. Returns the entity object as it stands now. No docScan file data from any attached ID documents will be returned unless the /full variant is requested. </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad request. One or more request fields is either missing or incorrect. Details are in the error response. </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> The request has failed an authorisation check. This can happen for a variety of reasons, such as an invalid or expired API key, or invalid Customer/CustomerChildIDs.  * NOTE: This does not include attempts to read/write data you don&#39;t have access to - that&#39;s a 404 error (as we don&#39;t want to leak information through guessing)  </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Cannot return response. In the case of a query, or reference to a specific entity/check/etc, it means that the requested item was not found, or you don&#39;t have access to it. Please check your query before trying again. </td><td>  -  </td></tr>
        <tr><td> 415 </td><td> For requests with payloads, an unsupported Content-Type was specified. The Frankie Financial API only supports a content type of application/json. </td><td>  -  </td></tr>
        <tr><td> 429 </td><td> The API client is making too many concurrent requests, and some are being throttled. Throttled requests can be retried after a short delay. </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Unexpected error. Something went wrong during the checking process. </td><td>  -  </td></tr>
     </table>
     */
    public EntityResultObject createEntity(UUID xFrankieCustomerID, UUID xFrankieCustomerChildID, EntityObject entity) throws ApiException {
        ApiResponse<EntityResultObject> localVarResp = createEntityWithHttpInfo(xFrankieCustomerID, xFrankieCustomerChildID, entity);
        return localVarResp.getData();
    }

    /**
     * Create New Entity.
     * Create an entity object. An entity object can be used to simply store data around a given identity. You can attach ID documents, scans, PDFs, photos, videos, etc to the entity if you wish and these may be processed later (using the /scan function) to extract useful information. Or you can manually supply the  information if you choose.  Entity objects can be used to run a check, using the data held in the records. 
     * @param xFrankieCustomerID Customer ID issued by Frankie Financial. This will never change. Your API key, which is mapped to this identity, will change over time.  (required)
     * @param xFrankieCustomerChildID If, as a Frankie Customer, you are acting on behalf of your own customers, then you can populate this field with a Frankie-assigned ID.  Note: If using a CustomerChildID, you will also need a separate api_key for each child.  Any documents, checks, entities that are created when this field has been populated will now be tied to this CustomerID + CustomerChildID combination. Just as Customers cannot see data created by other Customers, so too a Customer&#39;s Children will not be able to see each other&#39;s data.  A Customer can see the documents/entities and checks of all their Children.  (optional)
     * @param entity  (optional)
     * @return ApiResponse&lt;EntityResultObject&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> The request was valid and able to be processed in some fashion. Results may or may not be successful, but it was completed as far as practical with no actual errors. Returns the entity object as it stands now. No docScan file data from any attached ID documents will be returned unless the /full variant is requested. </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad request. One or more request fields is either missing or incorrect. Details are in the error response. </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> The request has failed an authorisation check. This can happen for a variety of reasons, such as an invalid or expired API key, or invalid Customer/CustomerChildIDs.  * NOTE: This does not include attempts to read/write data you don&#39;t have access to - that&#39;s a 404 error (as we don&#39;t want to leak information through guessing)  </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Cannot return response. In the case of a query, or reference to a specific entity/check/etc, it means that the requested item was not found, or you don&#39;t have access to it. Please check your query before trying again. </td><td>  -  </td></tr>
        <tr><td> 415 </td><td> For requests with payloads, an unsupported Content-Type was specified. The Frankie Financial API only supports a content type of application/json. </td><td>  -  </td></tr>
        <tr><td> 429 </td><td> The API client is making too many concurrent requests, and some are being throttled. Throttled requests can be retried after a short delay. </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Unexpected error. Something went wrong during the checking process. </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<EntityResultObject> createEntityWithHttpInfo(UUID xFrankieCustomerID, UUID xFrankieCustomerChildID, EntityObject entity) throws ApiException {
        okhttp3.Call localVarCall = createEntityValidateBeforeCall(xFrankieCustomerID, xFrankieCustomerChildID, entity, null);
        Type localVarReturnType = new TypeToken<EntityResultObject>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Create New Entity. (asynchronously)
     * Create an entity object. An entity object can be used to simply store data around a given identity. You can attach ID documents, scans, PDFs, photos, videos, etc to the entity if you wish and these may be processed later (using the /scan function) to extract useful information. Or you can manually supply the  information if you choose.  Entity objects can be used to run a check, using the data held in the records. 
     * @param xFrankieCustomerID Customer ID issued by Frankie Financial. This will never change. Your API key, which is mapped to this identity, will change over time.  (required)
     * @param xFrankieCustomerChildID If, as a Frankie Customer, you are acting on behalf of your own customers, then you can populate this field with a Frankie-assigned ID.  Note: If using a CustomerChildID, you will also need a separate api_key for each child.  Any documents, checks, entities that are created when this field has been populated will now be tied to this CustomerID + CustomerChildID combination. Just as Customers cannot see data created by other Customers, so too a Customer&#39;s Children will not be able to see each other&#39;s data.  A Customer can see the documents/entities and checks of all their Children.  (optional)
     * @param entity  (optional)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> The request was valid and able to be processed in some fashion. Results may or may not be successful, but it was completed as far as practical with no actual errors. Returns the entity object as it stands now. No docScan file data from any attached ID documents will be returned unless the /full variant is requested. </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad request. One or more request fields is either missing or incorrect. Details are in the error response. </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> The request has failed an authorisation check. This can happen for a variety of reasons, such as an invalid or expired API key, or invalid Customer/CustomerChildIDs.  * NOTE: This does not include attempts to read/write data you don&#39;t have access to - that&#39;s a 404 error (as we don&#39;t want to leak information through guessing)  </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Cannot return response. In the case of a query, or reference to a specific entity/check/etc, it means that the requested item was not found, or you don&#39;t have access to it. Please check your query before trying again. </td><td>  -  </td></tr>
        <tr><td> 415 </td><td> For requests with payloads, an unsupported Content-Type was specified. The Frankie Financial API only supports a content type of application/json. </td><td>  -  </td></tr>
        <tr><td> 429 </td><td> The API client is making too many concurrent requests, and some are being throttled. Throttled requests can be retried after a short delay. </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Unexpected error. Something went wrong during the checking process. </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call createEntityAsync(UUID xFrankieCustomerID, UUID xFrankieCustomerChildID, EntityObject entity, final ApiCallback<EntityResultObject> _callback) throws ApiException {

        okhttp3.Call localVarCall = createEntityValidateBeforeCall(xFrankieCustomerID, xFrankieCustomerChildID, entity, _callback);
        Type localVarReturnType = new TypeToken<EntityResultObject>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for createEntityGetIDVToken
     * @param xFrankieCustomerID Customer ID issued by Frankie Financial. This will never change. Your API key, which is mapped to this identity, will change over time.  (required)
     * @param entityIDVDetails The entity and required data to generate an IDV token (required)
     * @param xFrankieCustomerChildID If, as a Frankie Customer, you are acting on behalf of your own customers, then you can populate this field with a Frankie-assigned ID.  Note: If using a CustomerChildID, you will also need a separate api_key for each child.  Any documents, checks, entities that are created when this field has been populated will now be tied to this CustomerID + CustomerChildID combination. Just as Customers cannot see data created by other Customers, so too a Customer&#39;s Children will not be able to see each other&#39;s data.  A Customer can see the documents/entities and checks of all their Children.  (optional)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> The request was valid and able to be processed in some fashion. Results may or may not be successful, but it was completed as far as practical with no actual errors. Returns the entity object as it stands now. No docScan file data from any attached ID documents will be returned unless the /full variant is requested.  Also returned is the applicantId and token to be in the IDV process.  </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad request. One or more request fields is either missing or incorrect. Details are in the error response. </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> The request has failed an authorisation check. This can happen for a variety of reasons, such as an invalid or expired API key, or invalid Customer/CustomerChildIDs.  * NOTE: This does not include attempts to read/write data you don&#39;t have access to - that&#39;s a 404 error (as we don&#39;t want to leak information through guessing)  </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Cannot return response. In the case of a query, or reference to a specific entity/check/etc, it means that the requested item was not found, or you don&#39;t have access to it. Please check your query before trying again. </td><td>  -  </td></tr>
        <tr><td> 405 </td><td> A request to POST an update to an object was not allowed due to it&#39;s state. This may indicate an already completed check, or a document that has been processed. You need to create a new document/check if you wish to update the object in question. </td><td>  -  </td></tr>
        <tr><td> 415 </td><td> For requests with payloads, an unsupported Content-Type was specified. The Frankie Financial API only supports a content type of application/json. </td><td>  -  </td></tr>
        <tr><td> 422 </td><td> Unprocessable request. This can be triggered in a number of ways. * An attempt to force a check or scan to run, but there is insufficient data to be able to do so. * An attempt to run a utility comparison, or similar industry/document/entity specific scan or process on an unsupported document type (e.g. electricity comparison on a passport) Details of what is required will be in the issues list of the error response.  </td><td>  -  </td></tr>
        <tr><td> 429 </td><td> The API client is making too many concurrent requests, and some are being throttled. Throttled requests can be retried after a short delay. </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Unexpected error. Something went wrong during the checking process. </td><td>  -  </td></tr>
        <tr><td> 503 </td><td> All of the ID sources configured by the customer are unavailable, or there is no available document processor. </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call createEntityGetIDVTokenCall(UUID xFrankieCustomerID, EntityIDVDetailsObject entityIDVDetails, UUID xFrankieCustomerChildID, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = entityIDVDetails;

        // create path and map variables
        String localVarPath = "/entity/new/idvalidate/getToken";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (xFrankieCustomerID != null) {
            localVarHeaderParams.put("X-Frankie-CustomerID", localVarApiClient.parameterToString(xFrankieCustomerID));
        }

        if (xFrankieCustomerChildID != null) {
            localVarHeaderParams.put("X-Frankie-CustomerChildID", localVarApiClient.parameterToString(xFrankieCustomerChildID));
        }

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            "application/json"
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "api_key" };
        return localVarApiClient.buildCall(basePath, localVarPath, "POST", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call createEntityGetIDVTokenValidateBeforeCall(UUID xFrankieCustomerID, EntityIDVDetailsObject entityIDVDetails, UUID xFrankieCustomerChildID, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'xFrankieCustomerID' is set
        if (xFrankieCustomerID == null) {
            throw new ApiException("Missing the required parameter 'xFrankieCustomerID' when calling createEntityGetIDVToken(Async)");
        }

        // verify the required parameter 'entityIDVDetails' is set
        if (entityIDVDetails == null) {
            throw new ApiException("Missing the required parameter 'entityIDVDetails' when calling createEntityGetIDVToken(Async)");
        }

        return createEntityGetIDVTokenCall(xFrankieCustomerID, entityIDVDetails, xFrankieCustomerChildID, _callback);

    }

    /**
     * Create Entity and Get IDV Token
     * Create an entity object and if successful, obtain a token for use in an ID Validation service SDK (web or native app)   At a minimum, you will need to supply:  - the entity familyName.   - the entity givenName    For best results, you should gather the DoB, address, ID document details as well before  calling the initProcess function.  SPECIAL NOTE 1: Tokens have a limited lifespan, typically only 1 hour. Make sure you&#39;ve used it or you will need to create another using update version of this function.   SPECIAL NOTE 2: This function will need to be followed up with a call to /entity/{id}/idvalidate/initProcess once you&#39;ve collected all your data in your app/web capture process. 
     * @param xFrankieCustomerID Customer ID issued by Frankie Financial. This will never change. Your API key, which is mapped to this identity, will change over time.  (required)
     * @param entityIDVDetails The entity and required data to generate an IDV token (required)
     * @param xFrankieCustomerChildID If, as a Frankie Customer, you are acting on behalf of your own customers, then you can populate this field with a Frankie-assigned ID.  Note: If using a CustomerChildID, you will also need a separate api_key for each child.  Any documents, checks, entities that are created when this field has been populated will now be tied to this CustomerID + CustomerChildID combination. Just as Customers cannot see data created by other Customers, so too a Customer&#39;s Children will not be able to see each other&#39;s data.  A Customer can see the documents/entities and checks of all their Children.  (optional)
     * @return EntityIDVResultObject
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> The request was valid and able to be processed in some fashion. Results may or may not be successful, but it was completed as far as practical with no actual errors. Returns the entity object as it stands now. No docScan file data from any attached ID documents will be returned unless the /full variant is requested.  Also returned is the applicantId and token to be in the IDV process.  </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad request. One or more request fields is either missing or incorrect. Details are in the error response. </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> The request has failed an authorisation check. This can happen for a variety of reasons, such as an invalid or expired API key, or invalid Customer/CustomerChildIDs.  * NOTE: This does not include attempts to read/write data you don&#39;t have access to - that&#39;s a 404 error (as we don&#39;t want to leak information through guessing)  </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Cannot return response. In the case of a query, or reference to a specific entity/check/etc, it means that the requested item was not found, or you don&#39;t have access to it. Please check your query before trying again. </td><td>  -  </td></tr>
        <tr><td> 405 </td><td> A request to POST an update to an object was not allowed due to it&#39;s state. This may indicate an already completed check, or a document that has been processed. You need to create a new document/check if you wish to update the object in question. </td><td>  -  </td></tr>
        <tr><td> 415 </td><td> For requests with payloads, an unsupported Content-Type was specified. The Frankie Financial API only supports a content type of application/json. </td><td>  -  </td></tr>
        <tr><td> 422 </td><td> Unprocessable request. This can be triggered in a number of ways. * An attempt to force a check or scan to run, but there is insufficient data to be able to do so. * An attempt to run a utility comparison, or similar industry/document/entity specific scan or process on an unsupported document type (e.g. electricity comparison on a passport) Details of what is required will be in the issues list of the error response.  </td><td>  -  </td></tr>
        <tr><td> 429 </td><td> The API client is making too many concurrent requests, and some are being throttled. Throttled requests can be retried after a short delay. </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Unexpected error. Something went wrong during the checking process. </td><td>  -  </td></tr>
        <tr><td> 503 </td><td> All of the ID sources configured by the customer are unavailable, or there is no available document processor. </td><td>  -  </td></tr>
     </table>
     */
    public EntityIDVResultObject createEntityGetIDVToken(UUID xFrankieCustomerID, EntityIDVDetailsObject entityIDVDetails, UUID xFrankieCustomerChildID) throws ApiException {
        ApiResponse<EntityIDVResultObject> localVarResp = createEntityGetIDVTokenWithHttpInfo(xFrankieCustomerID, entityIDVDetails, xFrankieCustomerChildID);
        return localVarResp.getData();
    }

    /**
     * Create Entity and Get IDV Token
     * Create an entity object and if successful, obtain a token for use in an ID Validation service SDK (web or native app)   At a minimum, you will need to supply:  - the entity familyName.   - the entity givenName    For best results, you should gather the DoB, address, ID document details as well before  calling the initProcess function.  SPECIAL NOTE 1: Tokens have a limited lifespan, typically only 1 hour. Make sure you&#39;ve used it or you will need to create another using update version of this function.   SPECIAL NOTE 2: This function will need to be followed up with a call to /entity/{id}/idvalidate/initProcess once you&#39;ve collected all your data in your app/web capture process. 
     * @param xFrankieCustomerID Customer ID issued by Frankie Financial. This will never change. Your API key, which is mapped to this identity, will change over time.  (required)
     * @param entityIDVDetails The entity and required data to generate an IDV token (required)
     * @param xFrankieCustomerChildID If, as a Frankie Customer, you are acting on behalf of your own customers, then you can populate this field with a Frankie-assigned ID.  Note: If using a CustomerChildID, you will also need a separate api_key for each child.  Any documents, checks, entities that are created when this field has been populated will now be tied to this CustomerID + CustomerChildID combination. Just as Customers cannot see data created by other Customers, so too a Customer&#39;s Children will not be able to see each other&#39;s data.  A Customer can see the documents/entities and checks of all their Children.  (optional)
     * @return ApiResponse&lt;EntityIDVResultObject&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> The request was valid and able to be processed in some fashion. Results may or may not be successful, but it was completed as far as practical with no actual errors. Returns the entity object as it stands now. No docScan file data from any attached ID documents will be returned unless the /full variant is requested.  Also returned is the applicantId and token to be in the IDV process.  </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad request. One or more request fields is either missing or incorrect. Details are in the error response. </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> The request has failed an authorisation check. This can happen for a variety of reasons, such as an invalid or expired API key, or invalid Customer/CustomerChildIDs.  * NOTE: This does not include attempts to read/write data you don&#39;t have access to - that&#39;s a 404 error (as we don&#39;t want to leak information through guessing)  </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Cannot return response. In the case of a query, or reference to a specific entity/check/etc, it means that the requested item was not found, or you don&#39;t have access to it. Please check your query before trying again. </td><td>  -  </td></tr>
        <tr><td> 405 </td><td> A request to POST an update to an object was not allowed due to it&#39;s state. This may indicate an already completed check, or a document that has been processed. You need to create a new document/check if you wish to update the object in question. </td><td>  -  </td></tr>
        <tr><td> 415 </td><td> For requests with payloads, an unsupported Content-Type was specified. The Frankie Financial API only supports a content type of application/json. </td><td>  -  </td></tr>
        <tr><td> 422 </td><td> Unprocessable request. This can be triggered in a number of ways. * An attempt to force a check or scan to run, but there is insufficient data to be able to do so. * An attempt to run a utility comparison, or similar industry/document/entity specific scan or process on an unsupported document type (e.g. electricity comparison on a passport) Details of what is required will be in the issues list of the error response.  </td><td>  -  </td></tr>
        <tr><td> 429 </td><td> The API client is making too many concurrent requests, and some are being throttled. Throttled requests can be retried after a short delay. </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Unexpected error. Something went wrong during the checking process. </td><td>  -  </td></tr>
        <tr><td> 503 </td><td> All of the ID sources configured by the customer are unavailable, or there is no available document processor. </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<EntityIDVResultObject> createEntityGetIDVTokenWithHttpInfo(UUID xFrankieCustomerID, EntityIDVDetailsObject entityIDVDetails, UUID xFrankieCustomerChildID) throws ApiException {
        okhttp3.Call localVarCall = createEntityGetIDVTokenValidateBeforeCall(xFrankieCustomerID, entityIDVDetails, xFrankieCustomerChildID, null);
        Type localVarReturnType = new TypeToken<EntityIDVResultObject>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Create Entity and Get IDV Token (asynchronously)
     * Create an entity object and if successful, obtain a token for use in an ID Validation service SDK (web or native app)   At a minimum, you will need to supply:  - the entity familyName.   - the entity givenName    For best results, you should gather the DoB, address, ID document details as well before  calling the initProcess function.  SPECIAL NOTE 1: Tokens have a limited lifespan, typically only 1 hour. Make sure you&#39;ve used it or you will need to create another using update version of this function.   SPECIAL NOTE 2: This function will need to be followed up with a call to /entity/{id}/idvalidate/initProcess once you&#39;ve collected all your data in your app/web capture process. 
     * @param xFrankieCustomerID Customer ID issued by Frankie Financial. This will never change. Your API key, which is mapped to this identity, will change over time.  (required)
     * @param entityIDVDetails The entity and required data to generate an IDV token (required)
     * @param xFrankieCustomerChildID If, as a Frankie Customer, you are acting on behalf of your own customers, then you can populate this field with a Frankie-assigned ID.  Note: If using a CustomerChildID, you will also need a separate api_key for each child.  Any documents, checks, entities that are created when this field has been populated will now be tied to this CustomerID + CustomerChildID combination. Just as Customers cannot see data created by other Customers, so too a Customer&#39;s Children will not be able to see each other&#39;s data.  A Customer can see the documents/entities and checks of all their Children.  (optional)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> The request was valid and able to be processed in some fashion. Results may or may not be successful, but it was completed as far as practical with no actual errors. Returns the entity object as it stands now. No docScan file data from any attached ID documents will be returned unless the /full variant is requested.  Also returned is the applicantId and token to be in the IDV process.  </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad request. One or more request fields is either missing or incorrect. Details are in the error response. </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> The request has failed an authorisation check. This can happen for a variety of reasons, such as an invalid or expired API key, or invalid Customer/CustomerChildIDs.  * NOTE: This does not include attempts to read/write data you don&#39;t have access to - that&#39;s a 404 error (as we don&#39;t want to leak information through guessing)  </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Cannot return response. In the case of a query, or reference to a specific entity/check/etc, it means that the requested item was not found, or you don&#39;t have access to it. Please check your query before trying again. </td><td>  -  </td></tr>
        <tr><td> 405 </td><td> A request to POST an update to an object was not allowed due to it&#39;s state. This may indicate an already completed check, or a document that has been processed. You need to create a new document/check if you wish to update the object in question. </td><td>  -  </td></tr>
        <tr><td> 415 </td><td> For requests with payloads, an unsupported Content-Type was specified. The Frankie Financial API only supports a content type of application/json. </td><td>  -  </td></tr>
        <tr><td> 422 </td><td> Unprocessable request. This can be triggered in a number of ways. * An attempt to force a check or scan to run, but there is insufficient data to be able to do so. * An attempt to run a utility comparison, or similar industry/document/entity specific scan or process on an unsupported document type (e.g. electricity comparison on a passport) Details of what is required will be in the issues list of the error response.  </td><td>  -  </td></tr>
        <tr><td> 429 </td><td> The API client is making too many concurrent requests, and some are being throttled. Throttled requests can be retried after a short delay. </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Unexpected error. Something went wrong during the checking process. </td><td>  -  </td></tr>
        <tr><td> 503 </td><td> All of the ID sources configured by the customer are unavailable, or there is no available document processor. </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call createEntityGetIDVTokenAsync(UUID xFrankieCustomerID, EntityIDVDetailsObject entityIDVDetails, UUID xFrankieCustomerChildID, final ApiCallback<EntityIDVResultObject> _callback) throws ApiException {

        okhttp3.Call localVarCall = createEntityGetIDVTokenValidateBeforeCall(xFrankieCustomerID, entityIDVDetails, xFrankieCustomerChildID, _callback);
        Type localVarReturnType = new TypeToken<EntityIDVResultObject>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for deleteEntity
     * @param xFrankieCustomerID Customer ID issued by Frankie Financial. This will never change. Your API key, which is mapped to this identity, will change over time.  (required)
     * @param entityId The entityId returned previously from an earlier call to /check or /entity (required)
     * @param xFrankieCustomerChildID If, as a Frankie Customer, you are acting on behalf of your own customers, then you can populate this field with a Frankie-assigned ID.  Note: If using a CustomerChildID, you will also need a separate api_key for each child.  Any documents, checks, entities that are created when this field has been populated will now be tied to this CustomerID + CustomerChildID combination. Just as Customers cannot see data created by other Customers, so too a Customer&#39;s Children will not be able to see each other&#39;s data.  A Customer can see the documents/entities and checks of all their Children.  (optional)
     * @param xFrankieBackground If this header parameter is supplied and set to 1, then the request will not wait for the process to finish, and will return a 202 if there are no obvious errors in the input. The request will then run in the background and send a notification back to the customer. See out callback API for details on this.  See more details here:   https://apidocs.frankiefinancial.com/docs/asynchronous-calls-backgrounding-processes  (optional)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> The request was valid and able to be processed in some fashion. Returns a simple status to indicate that the deletion has taken place.  </td><td>  -  </td></tr>
        <tr><td> 202 </td><td> The request was valid and can potentially be fulfilled. The Frankie service has now accepted responsibility for processing and we will either push the results to you, or send you a notification, depending on the request and your configuration. </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad request. One or more request fields is either missing or incorrect. Details are in the error response. </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> The request has failed an authorisation check. This can happen for a variety of reasons, such as an invalid or expired API key, or invalid Customer/CustomerChildIDs.  * NOTE: This does not include attempts to read/write data you don&#39;t have access to - that&#39;s a 404 error (as we don&#39;t want to leak information through guessing)  </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Cannot return response. In the case of a query, or reference to a specific entity/check/etc, it means that the requested item was not found, or you don&#39;t have access to it. Please check your query before trying again. </td><td>  -  </td></tr>
        <tr><td> 429 </td><td> The API client is making too many concurrent requests, and some are being throttled. Throttled requests can be retried after a short delay. </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Unexpected error. Something went wrong during the checking process. </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call deleteEntityCall(UUID xFrankieCustomerID, UUID entityId, UUID xFrankieCustomerChildID, Integer xFrankieBackground, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/entity/{entityId}"
            .replace("{" + "entityId" + "}", localVarApiClient.escapeString(entityId.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (xFrankieCustomerID != null) {
            localVarHeaderParams.put("X-Frankie-CustomerID", localVarApiClient.parameterToString(xFrankieCustomerID));
        }

        if (xFrankieCustomerChildID != null) {
            localVarHeaderParams.put("X-Frankie-CustomerChildID", localVarApiClient.parameterToString(xFrankieCustomerChildID));
        }

        if (xFrankieBackground != null) {
            localVarHeaderParams.put("X-Frankie-Background", localVarApiClient.parameterToString(xFrankieBackground));
        }

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "api_key" };
        return localVarApiClient.buildCall(basePath, localVarPath, "DELETE", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call deleteEntityValidateBeforeCall(UUID xFrankieCustomerID, UUID entityId, UUID xFrankieCustomerChildID, Integer xFrankieBackground, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'xFrankieCustomerID' is set
        if (xFrankieCustomerID == null) {
            throw new ApiException("Missing the required parameter 'xFrankieCustomerID' when calling deleteEntity(Async)");
        }

        // verify the required parameter 'entityId' is set
        if (entityId == null) {
            throw new ApiException("Missing the required parameter 'entityId' when calling deleteEntity(Async)");
        }

        return deleteEntityCall(xFrankieCustomerID, entityId, xFrankieCustomerChildID, xFrankieBackground, _callback);

    }

    /**
     * Delete Entity
     * Marks the entity as deleted in the system, and no further operations or general queries may be executed against it by the Customer. If another customer is presently relying on this data, it will still be available to them (but only in the partially anonymised form they originally had.  An entity and its related data is only completely deleted from the database when either:    - a) There are no more references to it (i.e. it has been DELETEd by all Customers relying on the data), and 12 months have passed.      - b) The actual consumer who owns the data makes a direct request. If this occurs, then all subscribing Customers will be notified that this entity has been removed and they will need to contact them if needed in order to update their own records again. 
     * @param xFrankieCustomerID Customer ID issued by Frankie Financial. This will never change. Your API key, which is mapped to this identity, will change over time.  (required)
     * @param entityId The entityId returned previously from an earlier call to /check or /entity (required)
     * @param xFrankieCustomerChildID If, as a Frankie Customer, you are acting on behalf of your own customers, then you can populate this field with a Frankie-assigned ID.  Note: If using a CustomerChildID, you will also need a separate api_key for each child.  Any documents, checks, entities that are created when this field has been populated will now be tied to this CustomerID + CustomerChildID combination. Just as Customers cannot see data created by other Customers, so too a Customer&#39;s Children will not be able to see each other&#39;s data.  A Customer can see the documents/entities and checks of all their Children.  (optional)
     * @param xFrankieBackground If this header parameter is supplied and set to 1, then the request will not wait for the process to finish, and will return a 202 if there are no obvious errors in the input. The request will then run in the background and send a notification back to the customer. See out callback API for details on this.  See more details here:   https://apidocs.frankiefinancial.com/docs/asynchronous-calls-backgrounding-processes  (optional)
     * @return BasicStatusResultObject
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> The request was valid and able to be processed in some fashion. Returns a simple status to indicate that the deletion has taken place.  </td><td>  -  </td></tr>
        <tr><td> 202 </td><td> The request was valid and can potentially be fulfilled. The Frankie service has now accepted responsibility for processing and we will either push the results to you, or send you a notification, depending on the request and your configuration. </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad request. One or more request fields is either missing or incorrect. Details are in the error response. </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> The request has failed an authorisation check. This can happen for a variety of reasons, such as an invalid or expired API key, or invalid Customer/CustomerChildIDs.  * NOTE: This does not include attempts to read/write data you don&#39;t have access to - that&#39;s a 404 error (as we don&#39;t want to leak information through guessing)  </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Cannot return response. In the case of a query, or reference to a specific entity/check/etc, it means that the requested item was not found, or you don&#39;t have access to it. Please check your query before trying again. </td><td>  -  </td></tr>
        <tr><td> 429 </td><td> The API client is making too many concurrent requests, and some are being throttled. Throttled requests can be retried after a short delay. </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Unexpected error. Something went wrong during the checking process. </td><td>  -  </td></tr>
     </table>
     */
    public BasicStatusResultObject deleteEntity(UUID xFrankieCustomerID, UUID entityId, UUID xFrankieCustomerChildID, Integer xFrankieBackground) throws ApiException {
        ApiResponse<BasicStatusResultObject> localVarResp = deleteEntityWithHttpInfo(xFrankieCustomerID, entityId, xFrankieCustomerChildID, xFrankieBackground);
        return localVarResp.getData();
    }

    /**
     * Delete Entity
     * Marks the entity as deleted in the system, and no further operations or general queries may be executed against it by the Customer. If another customer is presently relying on this data, it will still be available to them (but only in the partially anonymised form they originally had.  An entity and its related data is only completely deleted from the database when either:    - a) There are no more references to it (i.e. it has been DELETEd by all Customers relying on the data), and 12 months have passed.      - b) The actual consumer who owns the data makes a direct request. If this occurs, then all subscribing Customers will be notified that this entity has been removed and they will need to contact them if needed in order to update their own records again. 
     * @param xFrankieCustomerID Customer ID issued by Frankie Financial. This will never change. Your API key, which is mapped to this identity, will change over time.  (required)
     * @param entityId The entityId returned previously from an earlier call to /check or /entity (required)
     * @param xFrankieCustomerChildID If, as a Frankie Customer, you are acting on behalf of your own customers, then you can populate this field with a Frankie-assigned ID.  Note: If using a CustomerChildID, you will also need a separate api_key for each child.  Any documents, checks, entities that are created when this field has been populated will now be tied to this CustomerID + CustomerChildID combination. Just as Customers cannot see data created by other Customers, so too a Customer&#39;s Children will not be able to see each other&#39;s data.  A Customer can see the documents/entities and checks of all their Children.  (optional)
     * @param xFrankieBackground If this header parameter is supplied and set to 1, then the request will not wait for the process to finish, and will return a 202 if there are no obvious errors in the input. The request will then run in the background and send a notification back to the customer. See out callback API for details on this.  See more details here:   https://apidocs.frankiefinancial.com/docs/asynchronous-calls-backgrounding-processes  (optional)
     * @return ApiResponse&lt;BasicStatusResultObject&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> The request was valid and able to be processed in some fashion. Returns a simple status to indicate that the deletion has taken place.  </td><td>  -  </td></tr>
        <tr><td> 202 </td><td> The request was valid and can potentially be fulfilled. The Frankie service has now accepted responsibility for processing and we will either push the results to you, or send you a notification, depending on the request and your configuration. </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad request. One or more request fields is either missing or incorrect. Details are in the error response. </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> The request has failed an authorisation check. This can happen for a variety of reasons, such as an invalid or expired API key, or invalid Customer/CustomerChildIDs.  * NOTE: This does not include attempts to read/write data you don&#39;t have access to - that&#39;s a 404 error (as we don&#39;t want to leak information through guessing)  </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Cannot return response. In the case of a query, or reference to a specific entity/check/etc, it means that the requested item was not found, or you don&#39;t have access to it. Please check your query before trying again. </td><td>  -  </td></tr>
        <tr><td> 429 </td><td> The API client is making too many concurrent requests, and some are being throttled. Throttled requests can be retried after a short delay. </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Unexpected error. Something went wrong during the checking process. </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<BasicStatusResultObject> deleteEntityWithHttpInfo(UUID xFrankieCustomerID, UUID entityId, UUID xFrankieCustomerChildID, Integer xFrankieBackground) throws ApiException {
        okhttp3.Call localVarCall = deleteEntityValidateBeforeCall(xFrankieCustomerID, entityId, xFrankieCustomerChildID, xFrankieBackground, null);
        Type localVarReturnType = new TypeToken<BasicStatusResultObject>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Delete Entity (asynchronously)
     * Marks the entity as deleted in the system, and no further operations or general queries may be executed against it by the Customer. If another customer is presently relying on this data, it will still be available to them (but only in the partially anonymised form they originally had.  An entity and its related data is only completely deleted from the database when either:    - a) There are no more references to it (i.e. it has been DELETEd by all Customers relying on the data), and 12 months have passed.      - b) The actual consumer who owns the data makes a direct request. If this occurs, then all subscribing Customers will be notified that this entity has been removed and they will need to contact them if needed in order to update their own records again. 
     * @param xFrankieCustomerID Customer ID issued by Frankie Financial. This will never change. Your API key, which is mapped to this identity, will change over time.  (required)
     * @param entityId The entityId returned previously from an earlier call to /check or /entity (required)
     * @param xFrankieCustomerChildID If, as a Frankie Customer, you are acting on behalf of your own customers, then you can populate this field with a Frankie-assigned ID.  Note: If using a CustomerChildID, you will also need a separate api_key for each child.  Any documents, checks, entities that are created when this field has been populated will now be tied to this CustomerID + CustomerChildID combination. Just as Customers cannot see data created by other Customers, so too a Customer&#39;s Children will not be able to see each other&#39;s data.  A Customer can see the documents/entities and checks of all their Children.  (optional)
     * @param xFrankieBackground If this header parameter is supplied and set to 1, then the request will not wait for the process to finish, and will return a 202 if there are no obvious errors in the input. The request will then run in the background and send a notification back to the customer. See out callback API for details on this.  See more details here:   https://apidocs.frankiefinancial.com/docs/asynchronous-calls-backgrounding-processes  (optional)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> The request was valid and able to be processed in some fashion. Returns a simple status to indicate that the deletion has taken place.  </td><td>  -  </td></tr>
        <tr><td> 202 </td><td> The request was valid and can potentially be fulfilled. The Frankie service has now accepted responsibility for processing and we will either push the results to you, or send you a notification, depending on the request and your configuration. </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad request. One or more request fields is either missing or incorrect. Details are in the error response. </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> The request has failed an authorisation check. This can happen for a variety of reasons, such as an invalid or expired API key, or invalid Customer/CustomerChildIDs.  * NOTE: This does not include attempts to read/write data you don&#39;t have access to - that&#39;s a 404 error (as we don&#39;t want to leak information through guessing)  </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Cannot return response. In the case of a query, or reference to a specific entity/check/etc, it means that the requested item was not found, or you don&#39;t have access to it. Please check your query before trying again. </td><td>  -  </td></tr>
        <tr><td> 429 </td><td> The API client is making too many concurrent requests, and some are being throttled. Throttled requests can be retried after a short delay. </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Unexpected error. Something went wrong during the checking process. </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call deleteEntityAsync(UUID xFrankieCustomerID, UUID entityId, UUID xFrankieCustomerChildID, Integer xFrankieBackground, final ApiCallback<BasicStatusResultObject> _callback) throws ApiException {

        okhttp3.Call localVarCall = deleteEntityValidateBeforeCall(xFrankieCustomerID, entityId, xFrankieCustomerChildID, xFrankieBackground, _callback);
        Type localVarReturnType = new TypeToken<BasicStatusResultObject>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for queryEntity
     * @param xFrankieCustomerID Customer ID issued by Frankie Financial. This will never change. Your API key, which is mapped to this identity, will change over time.  (required)
     * @param entityId The entityId returned previously from an earlier call to /check or /entity (required)
     * @param xFrankieCustomerChildID If, as a Frankie Customer, you are acting on behalf of your own customers, then you can populate this field with a Frankie-assigned ID.  Note: If using a CustomerChildID, you will also need a separate api_key for each child.  Any documents, checks, entities that are created when this field has been populated will now be tied to this CustomerID + CustomerChildID combination. Just as Customers cannot see data created by other Customers, so too a Customer&#39;s Children will not be able to see each other&#39;s data.  A Customer can see the documents/entities and checks of all their Children.  (optional)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> The request was valid and able to be processed in some fashion. Results may or may not be successful, but it was completed as far as practical with no actual errors. Returns the entity object as it stands now. No docScan file data from any attached ID documents will be returned unless the /full variant is requested. </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad request. One or more request fields is either missing or incorrect. Details are in the error response. </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> The request has failed an authorisation check. This can happen for a variety of reasons, such as an invalid or expired API key, or invalid Customer/CustomerChildIDs.  * NOTE: This does not include attempts to read/write data you don&#39;t have access to - that&#39;s a 404 error (as we don&#39;t want to leak information through guessing)  </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Cannot return response. In the case of a query, or reference to a specific entity/check/etc, it means that the requested item was not found, or you don&#39;t have access to it. Please check your query before trying again. </td><td>  -  </td></tr>
        <tr><td> 429 </td><td> The API client is making too many concurrent requests, and some are being throttled. Throttled requests can be retried after a short delay. </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Unexpected error. Something went wrong during the checking process. </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call queryEntityCall(UUID xFrankieCustomerID, UUID entityId, UUID xFrankieCustomerChildID, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/entity/{entityId}"
            .replace("{" + "entityId" + "}", localVarApiClient.escapeString(entityId.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (xFrankieCustomerID != null) {
            localVarHeaderParams.put("X-Frankie-CustomerID", localVarApiClient.parameterToString(xFrankieCustomerID));
        }

        if (xFrankieCustomerChildID != null) {
            localVarHeaderParams.put("X-Frankie-CustomerChildID", localVarApiClient.parameterToString(xFrankieCustomerChildID));
        }

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "api_key" };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call queryEntityValidateBeforeCall(UUID xFrankieCustomerID, UUID entityId, UUID xFrankieCustomerChildID, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'xFrankieCustomerID' is set
        if (xFrankieCustomerID == null) {
            throw new ApiException("Missing the required parameter 'xFrankieCustomerID' when calling queryEntity(Async)");
        }

        // verify the required parameter 'entityId' is set
        if (entityId == null) {
            throw new ApiException("Missing the required parameter 'entityId' when calling queryEntity(Async)");
        }

        return queryEntityCall(xFrankieCustomerID, entityId, xFrankieCustomerChildID, _callback);

    }

    /**
     * Retrieve Entity Details
     * Query the current status and details of a given entityId. 
     * @param xFrankieCustomerID Customer ID issued by Frankie Financial. This will never change. Your API key, which is mapped to this identity, will change over time.  (required)
     * @param entityId The entityId returned previously from an earlier call to /check or /entity (required)
     * @param xFrankieCustomerChildID If, as a Frankie Customer, you are acting on behalf of your own customers, then you can populate this field with a Frankie-assigned ID.  Note: If using a CustomerChildID, you will also need a separate api_key for each child.  Any documents, checks, entities that are created when this field has been populated will now be tied to this CustomerID + CustomerChildID combination. Just as Customers cannot see data created by other Customers, so too a Customer&#39;s Children will not be able to see each other&#39;s data.  A Customer can see the documents/entities and checks of all their Children.  (optional)
     * @return EntityResultObject
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> The request was valid and able to be processed in some fashion. Results may or may not be successful, but it was completed as far as practical with no actual errors. Returns the entity object as it stands now. No docScan file data from any attached ID documents will be returned unless the /full variant is requested. </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad request. One or more request fields is either missing or incorrect. Details are in the error response. </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> The request has failed an authorisation check. This can happen for a variety of reasons, such as an invalid or expired API key, or invalid Customer/CustomerChildIDs.  * NOTE: This does not include attempts to read/write data you don&#39;t have access to - that&#39;s a 404 error (as we don&#39;t want to leak information through guessing)  </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Cannot return response. In the case of a query, or reference to a specific entity/check/etc, it means that the requested item was not found, or you don&#39;t have access to it. Please check your query before trying again. </td><td>  -  </td></tr>
        <tr><td> 429 </td><td> The API client is making too many concurrent requests, and some are being throttled. Throttled requests can be retried after a short delay. </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Unexpected error. Something went wrong during the checking process. </td><td>  -  </td></tr>
     </table>
     */
    public EntityResultObject queryEntity(UUID xFrankieCustomerID, UUID entityId, UUID xFrankieCustomerChildID) throws ApiException {
        ApiResponse<EntityResultObject> localVarResp = queryEntityWithHttpInfo(xFrankieCustomerID, entityId, xFrankieCustomerChildID);
        return localVarResp.getData();
    }

    /**
     * Retrieve Entity Details
     * Query the current status and details of a given entityId. 
     * @param xFrankieCustomerID Customer ID issued by Frankie Financial. This will never change. Your API key, which is mapped to this identity, will change over time.  (required)
     * @param entityId The entityId returned previously from an earlier call to /check or /entity (required)
     * @param xFrankieCustomerChildID If, as a Frankie Customer, you are acting on behalf of your own customers, then you can populate this field with a Frankie-assigned ID.  Note: If using a CustomerChildID, you will also need a separate api_key for each child.  Any documents, checks, entities that are created when this field has been populated will now be tied to this CustomerID + CustomerChildID combination. Just as Customers cannot see data created by other Customers, so too a Customer&#39;s Children will not be able to see each other&#39;s data.  A Customer can see the documents/entities and checks of all their Children.  (optional)
     * @return ApiResponse&lt;EntityResultObject&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> The request was valid and able to be processed in some fashion. Results may or may not be successful, but it was completed as far as practical with no actual errors. Returns the entity object as it stands now. No docScan file data from any attached ID documents will be returned unless the /full variant is requested. </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad request. One or more request fields is either missing or incorrect. Details are in the error response. </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> The request has failed an authorisation check. This can happen for a variety of reasons, such as an invalid or expired API key, or invalid Customer/CustomerChildIDs.  * NOTE: This does not include attempts to read/write data you don&#39;t have access to - that&#39;s a 404 error (as we don&#39;t want to leak information through guessing)  </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Cannot return response. In the case of a query, or reference to a specific entity/check/etc, it means that the requested item was not found, or you don&#39;t have access to it. Please check your query before trying again. </td><td>  -  </td></tr>
        <tr><td> 429 </td><td> The API client is making too many concurrent requests, and some are being throttled. Throttled requests can be retried after a short delay. </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Unexpected error. Something went wrong during the checking process. </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<EntityResultObject> queryEntityWithHttpInfo(UUID xFrankieCustomerID, UUID entityId, UUID xFrankieCustomerChildID) throws ApiException {
        okhttp3.Call localVarCall = queryEntityValidateBeforeCall(xFrankieCustomerID, entityId, xFrankieCustomerChildID, null);
        Type localVarReturnType = new TypeToken<EntityResultObject>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Retrieve Entity Details (asynchronously)
     * Query the current status and details of a given entityId. 
     * @param xFrankieCustomerID Customer ID issued by Frankie Financial. This will never change. Your API key, which is mapped to this identity, will change over time.  (required)
     * @param entityId The entityId returned previously from an earlier call to /check or /entity (required)
     * @param xFrankieCustomerChildID If, as a Frankie Customer, you are acting on behalf of your own customers, then you can populate this field with a Frankie-assigned ID.  Note: If using a CustomerChildID, you will also need a separate api_key for each child.  Any documents, checks, entities that are created when this field has been populated will now be tied to this CustomerID + CustomerChildID combination. Just as Customers cannot see data created by other Customers, so too a Customer&#39;s Children will not be able to see each other&#39;s data.  A Customer can see the documents/entities and checks of all their Children.  (optional)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> The request was valid and able to be processed in some fashion. Results may or may not be successful, but it was completed as far as practical with no actual errors. Returns the entity object as it stands now. No docScan file data from any attached ID documents will be returned unless the /full variant is requested. </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad request. One or more request fields is either missing or incorrect. Details are in the error response. </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> The request has failed an authorisation check. This can happen for a variety of reasons, such as an invalid or expired API key, or invalid Customer/CustomerChildIDs.  * NOTE: This does not include attempts to read/write data you don&#39;t have access to - that&#39;s a 404 error (as we don&#39;t want to leak information through guessing)  </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Cannot return response. In the case of a query, or reference to a specific entity/check/etc, it means that the requested item was not found, or you don&#39;t have access to it. Please check your query before trying again. </td><td>  -  </td></tr>
        <tr><td> 429 </td><td> The API client is making too many concurrent requests, and some are being throttled. Throttled requests can be retried after a short delay. </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Unexpected error. Something went wrong during the checking process. </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call queryEntityAsync(UUID xFrankieCustomerID, UUID entityId, UUID xFrankieCustomerChildID, final ApiCallback<EntityResultObject> _callback) throws ApiException {

        okhttp3.Call localVarCall = queryEntityValidateBeforeCall(xFrankieCustomerID, entityId, xFrankieCustomerChildID, _callback);
        Type localVarReturnType = new TypeToken<EntityResultObject>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for queryEntityChecks
     * @param xFrankieCustomerID Customer ID issued by Frankie Financial. This will never change. Your API key, which is mapped to this identity, will change over time.  (required)
     * @param entityId The entityId returned previously from an earlier call to /check or /entity (required)
     * @param xFrankieCustomerChildID If, as a Frankie Customer, you are acting on behalf of your own customers, then you can populate this field with a Frankie-assigned ID.  Note: If using a CustomerChildID, you will also need a separate api_key for each child.  Any documents, checks, entities that are created when this field has been populated will now be tied to this CustomerID + CustomerChildID combination. Just as Customers cannot see data created by other Customers, so too a Customer&#39;s Children will not be able to see each other&#39;s data.  A Customer can see the documents/entities and checks of all their Children.  (optional)
     * @param alldata Requests that literally all data should be included in the response to a \&quot;get checks\&quot; request. This is as opposed to a filtered view where expired results are by default not included for entities that have an assigned profile.  (optional)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> The request was valid and able to be processed in some fashion. Results may or may not be successful, but it was completed as far as practical with no actual errors. Returns the entity object as it stands now. No docScan file data from any attached ID documents will be returned unless the /full variant is requested. </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad request. One or more request fields is either missing or incorrect. Details are in the error response. </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> The request has failed an authorisation check. This can happen for a variety of reasons, such as an invalid or expired API key, or invalid Customer/CustomerChildIDs.  * NOTE: This does not include attempts to read/write data you don&#39;t have access to - that&#39;s a 404 error (as we don&#39;t want to leak information through guessing)  </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Cannot return response. In the case of a query, or reference to a specific entity/check/etc, it means that the requested item was not found, or you don&#39;t have access to it. Please check your query before trying again. </td><td>  -  </td></tr>
        <tr><td> 429 </td><td> The API client is making too many concurrent requests, and some are being throttled. Throttled requests can be retried after a short delay. </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Unexpected error. Something went wrong during the checking process. </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call queryEntityChecksCall(UUID xFrankieCustomerID, UUID entityId, UUID xFrankieCustomerChildID, Boolean alldata, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/entity/{entityId}/checks"
            .replace("{" + "entityId" + "}", localVarApiClient.escapeString(entityId.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (alldata != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("alldata", alldata));
        }

        if (xFrankieCustomerID != null) {
            localVarHeaderParams.put("X-Frankie-CustomerID", localVarApiClient.parameterToString(xFrankieCustomerID));
        }

        if (xFrankieCustomerChildID != null) {
            localVarHeaderParams.put("X-Frankie-CustomerChildID", localVarApiClient.parameterToString(xFrankieCustomerChildID));
        }

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "api_key" };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call queryEntityChecksValidateBeforeCall(UUID xFrankieCustomerID, UUID entityId, UUID xFrankieCustomerChildID, Boolean alldata, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'xFrankieCustomerID' is set
        if (xFrankieCustomerID == null) {
            throw new ApiException("Missing the required parameter 'xFrankieCustomerID' when calling queryEntityChecks(Async)");
        }

        // verify the required parameter 'entityId' is set
        if (entityId == null) {
            throw new ApiException("Missing the required parameter 'entityId' when calling queryEntityChecks(Async)");
        }

        return queryEntityChecksCall(xFrankieCustomerID, entityId, xFrankieCustomerChildID, alldata, _callback);

    }

    /**
     * Retrieve Entity Verication Check Details 
     * Get the complete list of all checks that have been performed upon a given entity and its documents, including the checks that have been performed by others (in those cases you just get the id, status and date run, none of the details). 
     * @param xFrankieCustomerID Customer ID issued by Frankie Financial. This will never change. Your API key, which is mapped to this identity, will change over time.  (required)
     * @param entityId The entityId returned previously from an earlier call to /check or /entity (required)
     * @param xFrankieCustomerChildID If, as a Frankie Customer, you are acting on behalf of your own customers, then you can populate this field with a Frankie-assigned ID.  Note: If using a CustomerChildID, you will also need a separate api_key for each child.  Any documents, checks, entities that are created when this field has been populated will now be tied to this CustomerID + CustomerChildID combination. Just as Customers cannot see data created by other Customers, so too a Customer&#39;s Children will not be able to see each other&#39;s data.  A Customer can see the documents/entities and checks of all their Children.  (optional)
     * @param alldata Requests that literally all data should be included in the response to a \&quot;get checks\&quot; request. This is as opposed to a filtered view where expired results are by default not included for entities that have an assigned profile.  (optional)
     * @return CheckEntityCheckResultObject
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> The request was valid and able to be processed in some fashion. Results may or may not be successful, but it was completed as far as practical with no actual errors. Returns the entity object as it stands now. No docScan file data from any attached ID documents will be returned unless the /full variant is requested. </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad request. One or more request fields is either missing or incorrect. Details are in the error response. </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> The request has failed an authorisation check. This can happen for a variety of reasons, such as an invalid or expired API key, or invalid Customer/CustomerChildIDs.  * NOTE: This does not include attempts to read/write data you don&#39;t have access to - that&#39;s a 404 error (as we don&#39;t want to leak information through guessing)  </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Cannot return response. In the case of a query, or reference to a specific entity/check/etc, it means that the requested item was not found, or you don&#39;t have access to it. Please check your query before trying again. </td><td>  -  </td></tr>
        <tr><td> 429 </td><td> The API client is making too many concurrent requests, and some are being throttled. Throttled requests can be retried after a short delay. </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Unexpected error. Something went wrong during the checking process. </td><td>  -  </td></tr>
     </table>
     */
    public CheckEntityCheckResultObject queryEntityChecks(UUID xFrankieCustomerID, UUID entityId, UUID xFrankieCustomerChildID, Boolean alldata) throws ApiException {
        ApiResponse<CheckEntityCheckResultObject> localVarResp = queryEntityChecksWithHttpInfo(xFrankieCustomerID, entityId, xFrankieCustomerChildID, alldata);
        return localVarResp.getData();
    }

    /**
     * Retrieve Entity Verication Check Details 
     * Get the complete list of all checks that have been performed upon a given entity and its documents, including the checks that have been performed by others (in those cases you just get the id, status and date run, none of the details). 
     * @param xFrankieCustomerID Customer ID issued by Frankie Financial. This will never change. Your API key, which is mapped to this identity, will change over time.  (required)
     * @param entityId The entityId returned previously from an earlier call to /check or /entity (required)
     * @param xFrankieCustomerChildID If, as a Frankie Customer, you are acting on behalf of your own customers, then you can populate this field with a Frankie-assigned ID.  Note: If using a CustomerChildID, you will also need a separate api_key for each child.  Any documents, checks, entities that are created when this field has been populated will now be tied to this CustomerID + CustomerChildID combination. Just as Customers cannot see data created by other Customers, so too a Customer&#39;s Children will not be able to see each other&#39;s data.  A Customer can see the documents/entities and checks of all their Children.  (optional)
     * @param alldata Requests that literally all data should be included in the response to a \&quot;get checks\&quot; request. This is as opposed to a filtered view where expired results are by default not included for entities that have an assigned profile.  (optional)
     * @return ApiResponse&lt;CheckEntityCheckResultObject&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> The request was valid and able to be processed in some fashion. Results may or may not be successful, but it was completed as far as practical with no actual errors. Returns the entity object as it stands now. No docScan file data from any attached ID documents will be returned unless the /full variant is requested. </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad request. One or more request fields is either missing or incorrect. Details are in the error response. </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> The request has failed an authorisation check. This can happen for a variety of reasons, such as an invalid or expired API key, or invalid Customer/CustomerChildIDs.  * NOTE: This does not include attempts to read/write data you don&#39;t have access to - that&#39;s a 404 error (as we don&#39;t want to leak information through guessing)  </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Cannot return response. In the case of a query, or reference to a specific entity/check/etc, it means that the requested item was not found, or you don&#39;t have access to it. Please check your query before trying again. </td><td>  -  </td></tr>
        <tr><td> 429 </td><td> The API client is making too many concurrent requests, and some are being throttled. Throttled requests can be retried after a short delay. </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Unexpected error. Something went wrong during the checking process. </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<CheckEntityCheckResultObject> queryEntityChecksWithHttpInfo(UUID xFrankieCustomerID, UUID entityId, UUID xFrankieCustomerChildID, Boolean alldata) throws ApiException {
        okhttp3.Call localVarCall = queryEntityChecksValidateBeforeCall(xFrankieCustomerID, entityId, xFrankieCustomerChildID, alldata, null);
        Type localVarReturnType = new TypeToken<CheckEntityCheckResultObject>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Retrieve Entity Verication Check Details  (asynchronously)
     * Get the complete list of all checks that have been performed upon a given entity and its documents, including the checks that have been performed by others (in those cases you just get the id, status and date run, none of the details). 
     * @param xFrankieCustomerID Customer ID issued by Frankie Financial. This will never change. Your API key, which is mapped to this identity, will change over time.  (required)
     * @param entityId The entityId returned previously from an earlier call to /check or /entity (required)
     * @param xFrankieCustomerChildID If, as a Frankie Customer, you are acting on behalf of your own customers, then you can populate this field with a Frankie-assigned ID.  Note: If using a CustomerChildID, you will also need a separate api_key for each child.  Any documents, checks, entities that are created when this field has been populated will now be tied to this CustomerID + CustomerChildID combination. Just as Customers cannot see data created by other Customers, so too a Customer&#39;s Children will not be able to see each other&#39;s data.  A Customer can see the documents/entities and checks of all their Children.  (optional)
     * @param alldata Requests that literally all data should be included in the response to a \&quot;get checks\&quot; request. This is as opposed to a filtered view where expired results are by default not included for entities that have an assigned profile.  (optional)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> The request was valid and able to be processed in some fashion. Results may or may not be successful, but it was completed as far as practical with no actual errors. Returns the entity object as it stands now. No docScan file data from any attached ID documents will be returned unless the /full variant is requested. </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad request. One or more request fields is either missing or incorrect. Details are in the error response. </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> The request has failed an authorisation check. This can happen for a variety of reasons, such as an invalid or expired API key, or invalid Customer/CustomerChildIDs.  * NOTE: This does not include attempts to read/write data you don&#39;t have access to - that&#39;s a 404 error (as we don&#39;t want to leak information through guessing)  </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Cannot return response. In the case of a query, or reference to a specific entity/check/etc, it means that the requested item was not found, or you don&#39;t have access to it. Please check your query before trying again. </td><td>  -  </td></tr>
        <tr><td> 429 </td><td> The API client is making too many concurrent requests, and some are being throttled. Throttled requests can be retried after a short delay. </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Unexpected error. Something went wrong during the checking process. </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call queryEntityChecksAsync(UUID xFrankieCustomerID, UUID entityId, UUID xFrankieCustomerChildID, Boolean alldata, final ApiCallback<CheckEntityCheckResultObject> _callback) throws ApiException {

        okhttp3.Call localVarCall = queryEntityChecksValidateBeforeCall(xFrankieCustomerID, entityId, xFrankieCustomerChildID, alldata, _callback);
        Type localVarReturnType = new TypeToken<CheckEntityCheckResultObject>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for queryEntityFull
     * @param xFrankieCustomerID Customer ID issued by Frankie Financial. This will never change. Your API key, which is mapped to this identity, will change over time.  (required)
     * @param entityId The entityId returned previously from an earlier call to /check or /entity (required)
     * @param xFrankieCustomerChildID If, as a Frankie Customer, you are acting on behalf of your own customers, then you can populate this field with a Frankie-assigned ID.  Note: If using a CustomerChildID, you will also need a separate api_key for each child.  Any documents, checks, entities that are created when this field has been populated will now be tied to this CustomerID + CustomerChildID combination. Just as Customers cannot see data created by other Customers, so too a Customer&#39;s Children will not be able to see each other&#39;s data.  A Customer can see the documents/entities and checks of all their Children.  (optional)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> The request was valid and able to be processed in some fashion. Results may or may not be successful, but it was completed as far as practical with no actual errors. Returns the entity object as it stands now. No docScan file data from any attached ID documents will be returned unless the /full variant is requested. </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad request. One or more request fields is either missing or incorrect. Details are in the error response. </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> The request has failed an authorisation check. This can happen for a variety of reasons, such as an invalid or expired API key, or invalid Customer/CustomerChildIDs.  * NOTE: This does not include attempts to read/write data you don&#39;t have access to - that&#39;s a 404 error (as we don&#39;t want to leak information through guessing)  </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Cannot return response. In the case of a query, or reference to a specific entity/check/etc, it means that the requested item was not found, or you don&#39;t have access to it. Please check your query before trying again. </td><td>  -  </td></tr>
        <tr><td> 429 </td><td> The API client is making too many concurrent requests, and some are being throttled. Throttled requests can be retried after a short delay. </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Unexpected error. Something went wrong during the checking process. </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call queryEntityFullCall(UUID xFrankieCustomerID, UUID entityId, UUID xFrankieCustomerChildID, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/entity/{entityId}/full"
            .replace("{" + "entityId" + "}", localVarApiClient.escapeString(entityId.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (xFrankieCustomerID != null) {
            localVarHeaderParams.put("X-Frankie-CustomerID", localVarApiClient.parameterToString(xFrankieCustomerID));
        }

        if (xFrankieCustomerChildID != null) {
            localVarHeaderParams.put("X-Frankie-CustomerChildID", localVarApiClient.parameterToString(xFrankieCustomerChildID));
        }

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "api_key" };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call queryEntityFullValidateBeforeCall(UUID xFrankieCustomerID, UUID entityId, UUID xFrankieCustomerChildID, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'xFrankieCustomerID' is set
        if (xFrankieCustomerID == null) {
            throw new ApiException("Missing the required parameter 'xFrankieCustomerID' when calling queryEntityFull(Async)");
        }

        // verify the required parameter 'entityId' is set
        if (entityId == null) {
            throw new ApiException("Missing the required parameter 'entityId' when calling queryEntityFull(Async)");
        }

        return queryEntityFullCall(xFrankieCustomerID, entityId, xFrankieCustomerChildID, _callback);

    }

    /**
     * Retrieve Entity Details and Document Scan Data 
     * Query the current status and details of a given entityId. Also returns all attached document file data, not just the metadata. Equivalent to a get /document/{documentId}/full) 
     * @param xFrankieCustomerID Customer ID issued by Frankie Financial. This will never change. Your API key, which is mapped to this identity, will change over time.  (required)
     * @param entityId The entityId returned previously from an earlier call to /check or /entity (required)
     * @param xFrankieCustomerChildID If, as a Frankie Customer, you are acting on behalf of your own customers, then you can populate this field with a Frankie-assigned ID.  Note: If using a CustomerChildID, you will also need a separate api_key for each child.  Any documents, checks, entities that are created when this field has been populated will now be tied to this CustomerID + CustomerChildID combination. Just as Customers cannot see data created by other Customers, so too a Customer&#39;s Children will not be able to see each other&#39;s data.  A Customer can see the documents/entities and checks of all their Children.  (optional)
     * @return EntityResultObject
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> The request was valid and able to be processed in some fashion. Results may or may not be successful, but it was completed as far as practical with no actual errors. Returns the entity object as it stands now. No docScan file data from any attached ID documents will be returned unless the /full variant is requested. </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad request. One or more request fields is either missing or incorrect. Details are in the error response. </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> The request has failed an authorisation check. This can happen for a variety of reasons, such as an invalid or expired API key, or invalid Customer/CustomerChildIDs.  * NOTE: This does not include attempts to read/write data you don&#39;t have access to - that&#39;s a 404 error (as we don&#39;t want to leak information through guessing)  </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Cannot return response. In the case of a query, or reference to a specific entity/check/etc, it means that the requested item was not found, or you don&#39;t have access to it. Please check your query before trying again. </td><td>  -  </td></tr>
        <tr><td> 429 </td><td> The API client is making too many concurrent requests, and some are being throttled. Throttled requests can be retried after a short delay. </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Unexpected error. Something went wrong during the checking process. </td><td>  -  </td></tr>
     </table>
     */
    public EntityResultObject queryEntityFull(UUID xFrankieCustomerID, UUID entityId, UUID xFrankieCustomerChildID) throws ApiException {
        ApiResponse<EntityResultObject> localVarResp = queryEntityFullWithHttpInfo(xFrankieCustomerID, entityId, xFrankieCustomerChildID);
        return localVarResp.getData();
    }

    /**
     * Retrieve Entity Details and Document Scan Data 
     * Query the current status and details of a given entityId. Also returns all attached document file data, not just the metadata. Equivalent to a get /document/{documentId}/full) 
     * @param xFrankieCustomerID Customer ID issued by Frankie Financial. This will never change. Your API key, which is mapped to this identity, will change over time.  (required)
     * @param entityId The entityId returned previously from an earlier call to /check or /entity (required)
     * @param xFrankieCustomerChildID If, as a Frankie Customer, you are acting on behalf of your own customers, then you can populate this field with a Frankie-assigned ID.  Note: If using a CustomerChildID, you will also need a separate api_key for each child.  Any documents, checks, entities that are created when this field has been populated will now be tied to this CustomerID + CustomerChildID combination. Just as Customers cannot see data created by other Customers, so too a Customer&#39;s Children will not be able to see each other&#39;s data.  A Customer can see the documents/entities and checks of all their Children.  (optional)
     * @return ApiResponse&lt;EntityResultObject&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> The request was valid and able to be processed in some fashion. Results may or may not be successful, but it was completed as far as practical with no actual errors. Returns the entity object as it stands now. No docScan file data from any attached ID documents will be returned unless the /full variant is requested. </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad request. One or more request fields is either missing or incorrect. Details are in the error response. </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> The request has failed an authorisation check. This can happen for a variety of reasons, such as an invalid or expired API key, or invalid Customer/CustomerChildIDs.  * NOTE: This does not include attempts to read/write data you don&#39;t have access to - that&#39;s a 404 error (as we don&#39;t want to leak information through guessing)  </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Cannot return response. In the case of a query, or reference to a specific entity/check/etc, it means that the requested item was not found, or you don&#39;t have access to it. Please check your query before trying again. </td><td>  -  </td></tr>
        <tr><td> 429 </td><td> The API client is making too many concurrent requests, and some are being throttled. Throttled requests can be retried after a short delay. </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Unexpected error. Something went wrong during the checking process. </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<EntityResultObject> queryEntityFullWithHttpInfo(UUID xFrankieCustomerID, UUID entityId, UUID xFrankieCustomerChildID) throws ApiException {
        okhttp3.Call localVarCall = queryEntityFullValidateBeforeCall(xFrankieCustomerID, entityId, xFrankieCustomerChildID, null);
        Type localVarReturnType = new TypeToken<EntityResultObject>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Retrieve Entity Details and Document Scan Data  (asynchronously)
     * Query the current status and details of a given entityId. Also returns all attached document file data, not just the metadata. Equivalent to a get /document/{documentId}/full) 
     * @param xFrankieCustomerID Customer ID issued by Frankie Financial. This will never change. Your API key, which is mapped to this identity, will change over time.  (required)
     * @param entityId The entityId returned previously from an earlier call to /check or /entity (required)
     * @param xFrankieCustomerChildID If, as a Frankie Customer, you are acting on behalf of your own customers, then you can populate this field with a Frankie-assigned ID.  Note: If using a CustomerChildID, you will also need a separate api_key for each child.  Any documents, checks, entities that are created when this field has been populated will now be tied to this CustomerID + CustomerChildID combination. Just as Customers cannot see data created by other Customers, so too a Customer&#39;s Children will not be able to see each other&#39;s data.  A Customer can see the documents/entities and checks of all their Children.  (optional)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> The request was valid and able to be processed in some fashion. Results may or may not be successful, but it was completed as far as practical with no actual errors. Returns the entity object as it stands now. No docScan file data from any attached ID documents will be returned unless the /full variant is requested. </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad request. One or more request fields is either missing or incorrect. Details are in the error response. </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> The request has failed an authorisation check. This can happen for a variety of reasons, such as an invalid or expired API key, or invalid Customer/CustomerChildIDs.  * NOTE: This does not include attempts to read/write data you don&#39;t have access to - that&#39;s a 404 error (as we don&#39;t want to leak information through guessing)  </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Cannot return response. In the case of a query, or reference to a specific entity/check/etc, it means that the requested item was not found, or you don&#39;t have access to it. Please check your query before trying again. </td><td>  -  </td></tr>
        <tr><td> 429 </td><td> The API client is making too many concurrent requests, and some are being throttled. Throttled requests can be retried after a short delay. </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Unexpected error. Something went wrong during the checking process. </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call queryEntityFullAsync(UUID xFrankieCustomerID, UUID entityId, UUID xFrankieCustomerChildID, final ApiCallback<EntityResultObject> _callback) throws ApiException {

        okhttp3.Call localVarCall = queryEntityFullValidateBeforeCall(xFrankieCustomerID, entityId, xFrankieCustomerChildID, _callback);
        Type localVarReturnType = new TypeToken<EntityResultObject>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for searchEntity
     * @param xFrankieCustomerID Customer ID issued by Frankie Financial. This will never change. Your API key, which is mapped to this identity, will change over time.  (required)
     * @param searchEntity An entity object with the parameters you wish to search on.  (required)
     * @param xFrankieCustomerChildID If, as a Frankie Customer, you are acting on behalf of your own customers, then you can populate this field with a Frankie-assigned ID.  Note: If using a CustomerChildID, you will also need a separate api_key for each child.  Any documents, checks, entities that are created when this field has been populated will now be tied to this CustomerID + CustomerChildID combination. Just as Customers cannot see data created by other Customers, so too a Customer&#39;s Children will not be able to see each other&#39;s data.  A Customer can see the documents/entities and checks of all their Children.  (optional)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> The request was valid and able to be processed in some fashion. Returns a list of potentially matching entity or entity references, along with a confidence level in the match.  </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad request. One or more request fields is either missing or incorrect. Details are in the error response. </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> The request has failed an authorisation check. This can happen for a variety of reasons, such as an invalid or expired API key, or invalid Customer/CustomerChildIDs.  * NOTE: This does not include attempts to read/write data you don&#39;t have access to - that&#39;s a 404 error (as we don&#39;t want to leak information through guessing)  </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Cannot return response. In the case of a query, or reference to a specific entity/check/etc, it means that the requested item was not found, or you don&#39;t have access to it. Please check your query before trying again. </td><td>  -  </td></tr>
        <tr><td> 405 </td><td> A request to POST an update to an object was not allowed due to it&#39;s state. This may indicate an already completed check, or a document that has been processed. You need to create a new document/check if you wish to update the object in question. </td><td>  -  </td></tr>
        <tr><td> 422 </td><td> Unprocessable request. This can be triggered in a number of ways. * An attempt to force a check or scan to run, but there is insufficient data to be able to do so. * An attempt to run a utility comparison, or similar industry/document/entity specific scan or process on an unsupported document type (e.g. electricity comparison on a passport) Details of what is required will be in the issues list of the error response.  </td><td>  -  </td></tr>
        <tr><td> 429 </td><td> The API client is making too many concurrent requests, and some are being throttled. Throttled requests can be retried after a short delay. </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Unexpected error. Something went wrong during the checking process. </td><td>  -  </td></tr>
        <tr><td> 503 </td><td> All of the ID sources configured by the customer are unavailable, or there is no available document processor. </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call searchEntityCall(UUID xFrankieCustomerID, EntityObject searchEntity, UUID xFrankieCustomerChildID, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = searchEntity;

        // create path and map variables
        String localVarPath = "/entity/search";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (xFrankieCustomerID != null) {
            localVarHeaderParams.put("X-Frankie-CustomerID", localVarApiClient.parameterToString(xFrankieCustomerID));
        }

        if (xFrankieCustomerChildID != null) {
            localVarHeaderParams.put("X-Frankie-CustomerChildID", localVarApiClient.parameterToString(xFrankieCustomerChildID));
        }

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            "application/json"
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "api_key" };
        return localVarApiClient.buildCall(basePath, localVarPath, "POST", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call searchEntityValidateBeforeCall(UUID xFrankieCustomerID, EntityObject searchEntity, UUID xFrankieCustomerChildID, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'xFrankieCustomerID' is set
        if (xFrankieCustomerID == null) {
            throw new ApiException("Missing the required parameter 'xFrankieCustomerID' when calling searchEntity(Async)");
        }

        // verify the required parameter 'searchEntity' is set
        if (searchEntity == null) {
            throw new ApiException("Missing the required parameter 'searchEntity' when calling searchEntity(Async)");
        }

        return searchEntityCall(xFrankieCustomerID, searchEntity, xFrankieCustomerChildID, _callback);

    }

    /**
     * Search for Entity
     *  Search for an existing entity that matches the criteria supplied  Criteria are supplied in the form of a populated entity object, with the name/address/DoB details supplied. You can also include documents that can be used to further refine your search (see the /document/search function for minimum requirements for a document search)  At an absolute minimum, you must supply one of the following combinations:    * name.familyName +   * name.givenNames      or      * name.familyName +   * one identityDocument object (that meets minimum criteria)    Obviously, the more data you provide, the better search results we can provide.  The service will return a list of matching entities with confidence levels.  If you are the \&quot;owner\&quot; of the entity - i.e. the same CustomerID and CustomerChildID (if relevant) - then the full details of the entity and any owned documents will be returned, except for the contents of any attached scans.  If you are not the owner of the entity (or linked documents), then just the ID and confidence level is returned. You can still use this ID to retrieve any check results (see GET  /entity/{entityId}/checks and GET /document/{documentId}/checks)  Note: This functionality must be enabled by Frankie administrators. Please contact your sales representative if you wish to discuss this. 
     * @param xFrankieCustomerID Customer ID issued by Frankie Financial. This will never change. Your API key, which is mapped to this identity, will change over time.  (required)
     * @param searchEntity An entity object with the parameters you wish to search on.  (required)
     * @param xFrankieCustomerChildID If, as a Frankie Customer, you are acting on behalf of your own customers, then you can populate this field with a Frankie-assigned ID.  Note: If using a CustomerChildID, you will also need a separate api_key for each child.  Any documents, checks, entities that are created when this field has been populated will now be tied to this CustomerID + CustomerChildID combination. Just as Customers cannot see data created by other Customers, so too a Customer&#39;s Children will not be able to see each other&#39;s data.  A Customer can see the documents/entities and checks of all their Children.  (optional)
     * @return EntitySearchResultObject
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> The request was valid and able to be processed in some fashion. Returns a list of potentially matching entity or entity references, along with a confidence level in the match.  </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad request. One or more request fields is either missing or incorrect. Details are in the error response. </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> The request has failed an authorisation check. This can happen for a variety of reasons, such as an invalid or expired API key, or invalid Customer/CustomerChildIDs.  * NOTE: This does not include attempts to read/write data you don&#39;t have access to - that&#39;s a 404 error (as we don&#39;t want to leak information through guessing)  </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Cannot return response. In the case of a query, or reference to a specific entity/check/etc, it means that the requested item was not found, or you don&#39;t have access to it. Please check your query before trying again. </td><td>  -  </td></tr>
        <tr><td> 405 </td><td> A request to POST an update to an object was not allowed due to it&#39;s state. This may indicate an already completed check, or a document that has been processed. You need to create a new document/check if you wish to update the object in question. </td><td>  -  </td></tr>
        <tr><td> 422 </td><td> Unprocessable request. This can be triggered in a number of ways. * An attempt to force a check or scan to run, but there is insufficient data to be able to do so. * An attempt to run a utility comparison, or similar industry/document/entity specific scan or process on an unsupported document type (e.g. electricity comparison on a passport) Details of what is required will be in the issues list of the error response.  </td><td>  -  </td></tr>
        <tr><td> 429 </td><td> The API client is making too many concurrent requests, and some are being throttled. Throttled requests can be retried after a short delay. </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Unexpected error. Something went wrong during the checking process. </td><td>  -  </td></tr>
        <tr><td> 503 </td><td> All of the ID sources configured by the customer are unavailable, or there is no available document processor. </td><td>  -  </td></tr>
     </table>
     */
    public EntitySearchResultObject searchEntity(UUID xFrankieCustomerID, EntityObject searchEntity, UUID xFrankieCustomerChildID) throws ApiException {
        ApiResponse<EntitySearchResultObject> localVarResp = searchEntityWithHttpInfo(xFrankieCustomerID, searchEntity, xFrankieCustomerChildID);
        return localVarResp.getData();
    }

    /**
     * Search for Entity
     *  Search for an existing entity that matches the criteria supplied  Criteria are supplied in the form of a populated entity object, with the name/address/DoB details supplied. You can also include documents that can be used to further refine your search (see the /document/search function for minimum requirements for a document search)  At an absolute minimum, you must supply one of the following combinations:    * name.familyName +   * name.givenNames      or      * name.familyName +   * one identityDocument object (that meets minimum criteria)    Obviously, the more data you provide, the better search results we can provide.  The service will return a list of matching entities with confidence levels.  If you are the \&quot;owner\&quot; of the entity - i.e. the same CustomerID and CustomerChildID (if relevant) - then the full details of the entity and any owned documents will be returned, except for the contents of any attached scans.  If you are not the owner of the entity (or linked documents), then just the ID and confidence level is returned. You can still use this ID to retrieve any check results (see GET  /entity/{entityId}/checks and GET /document/{documentId}/checks)  Note: This functionality must be enabled by Frankie administrators. Please contact your sales representative if you wish to discuss this. 
     * @param xFrankieCustomerID Customer ID issued by Frankie Financial. This will never change. Your API key, which is mapped to this identity, will change over time.  (required)
     * @param searchEntity An entity object with the parameters you wish to search on.  (required)
     * @param xFrankieCustomerChildID If, as a Frankie Customer, you are acting on behalf of your own customers, then you can populate this field with a Frankie-assigned ID.  Note: If using a CustomerChildID, you will also need a separate api_key for each child.  Any documents, checks, entities that are created when this field has been populated will now be tied to this CustomerID + CustomerChildID combination. Just as Customers cannot see data created by other Customers, so too a Customer&#39;s Children will not be able to see each other&#39;s data.  A Customer can see the documents/entities and checks of all their Children.  (optional)
     * @return ApiResponse&lt;EntitySearchResultObject&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> The request was valid and able to be processed in some fashion. Returns a list of potentially matching entity or entity references, along with a confidence level in the match.  </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad request. One or more request fields is either missing or incorrect. Details are in the error response. </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> The request has failed an authorisation check. This can happen for a variety of reasons, such as an invalid or expired API key, or invalid Customer/CustomerChildIDs.  * NOTE: This does not include attempts to read/write data you don&#39;t have access to - that&#39;s a 404 error (as we don&#39;t want to leak information through guessing)  </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Cannot return response. In the case of a query, or reference to a specific entity/check/etc, it means that the requested item was not found, or you don&#39;t have access to it. Please check your query before trying again. </td><td>  -  </td></tr>
        <tr><td> 405 </td><td> A request to POST an update to an object was not allowed due to it&#39;s state. This may indicate an already completed check, or a document that has been processed. You need to create a new document/check if you wish to update the object in question. </td><td>  -  </td></tr>
        <tr><td> 422 </td><td> Unprocessable request. This can be triggered in a number of ways. * An attempt to force a check or scan to run, but there is insufficient data to be able to do so. * An attempt to run a utility comparison, or similar industry/document/entity specific scan or process on an unsupported document type (e.g. electricity comparison on a passport) Details of what is required will be in the issues list of the error response.  </td><td>  -  </td></tr>
        <tr><td> 429 </td><td> The API client is making too many concurrent requests, and some are being throttled. Throttled requests can be retried after a short delay. </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Unexpected error. Something went wrong during the checking process. </td><td>  -  </td></tr>
        <tr><td> 503 </td><td> All of the ID sources configured by the customer are unavailable, or there is no available document processor. </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<EntitySearchResultObject> searchEntityWithHttpInfo(UUID xFrankieCustomerID, EntityObject searchEntity, UUID xFrankieCustomerChildID) throws ApiException {
        okhttp3.Call localVarCall = searchEntityValidateBeforeCall(xFrankieCustomerID, searchEntity, xFrankieCustomerChildID, null);
        Type localVarReturnType = new TypeToken<EntitySearchResultObject>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Search for Entity (asynchronously)
     *  Search for an existing entity that matches the criteria supplied  Criteria are supplied in the form of a populated entity object, with the name/address/DoB details supplied. You can also include documents that can be used to further refine your search (see the /document/search function for minimum requirements for a document search)  At an absolute minimum, you must supply one of the following combinations:    * name.familyName +   * name.givenNames      or      * name.familyName +   * one identityDocument object (that meets minimum criteria)    Obviously, the more data you provide, the better search results we can provide.  The service will return a list of matching entities with confidence levels.  If you are the \&quot;owner\&quot; of the entity - i.e. the same CustomerID and CustomerChildID (if relevant) - then the full details of the entity and any owned documents will be returned, except for the contents of any attached scans.  If you are not the owner of the entity (or linked documents), then just the ID and confidence level is returned. You can still use this ID to retrieve any check results (see GET  /entity/{entityId}/checks and GET /document/{documentId}/checks)  Note: This functionality must be enabled by Frankie administrators. Please contact your sales representative if you wish to discuss this. 
     * @param xFrankieCustomerID Customer ID issued by Frankie Financial. This will never change. Your API key, which is mapped to this identity, will change over time.  (required)
     * @param searchEntity An entity object with the parameters you wish to search on.  (required)
     * @param xFrankieCustomerChildID If, as a Frankie Customer, you are acting on behalf of your own customers, then you can populate this field with a Frankie-assigned ID.  Note: If using a CustomerChildID, you will also need a separate api_key for each child.  Any documents, checks, entities that are created when this field has been populated will now be tied to this CustomerID + CustomerChildID combination. Just as Customers cannot see data created by other Customers, so too a Customer&#39;s Children will not be able to see each other&#39;s data.  A Customer can see the documents/entities and checks of all their Children.  (optional)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> The request was valid and able to be processed in some fashion. Returns a list of potentially matching entity or entity references, along with a confidence level in the match.  </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad request. One or more request fields is either missing or incorrect. Details are in the error response. </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> The request has failed an authorisation check. This can happen for a variety of reasons, such as an invalid or expired API key, or invalid Customer/CustomerChildIDs.  * NOTE: This does not include attempts to read/write data you don&#39;t have access to - that&#39;s a 404 error (as we don&#39;t want to leak information through guessing)  </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Cannot return response. In the case of a query, or reference to a specific entity/check/etc, it means that the requested item was not found, or you don&#39;t have access to it. Please check your query before trying again. </td><td>  -  </td></tr>
        <tr><td> 405 </td><td> A request to POST an update to an object was not allowed due to it&#39;s state. This may indicate an already completed check, or a document that has been processed. You need to create a new document/check if you wish to update the object in question. </td><td>  -  </td></tr>
        <tr><td> 422 </td><td> Unprocessable request. This can be triggered in a number of ways. * An attempt to force a check or scan to run, but there is insufficient data to be able to do so. * An attempt to run a utility comparison, or similar industry/document/entity specific scan or process on an unsupported document type (e.g. electricity comparison on a passport) Details of what is required will be in the issues list of the error response.  </td><td>  -  </td></tr>
        <tr><td> 429 </td><td> The API client is making too many concurrent requests, and some are being throttled. Throttled requests can be retried after a short delay. </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Unexpected error. Something went wrong during the checking process. </td><td>  -  </td></tr>
        <tr><td> 503 </td><td> All of the ID sources configured by the customer are unavailable, or there is no available document processor. </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call searchEntityAsync(UUID xFrankieCustomerID, EntityObject searchEntity, UUID xFrankieCustomerChildID, final ApiCallback<EntitySearchResultObject> _callback) throws ApiException {

        okhttp3.Call localVarCall = searchEntityValidateBeforeCall(xFrankieCustomerID, searchEntity, xFrankieCustomerChildID, _callback);
        Type localVarReturnType = new TypeToken<EntitySearchResultObject>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for updateCheckClassResult
     * @param xFrankieCustomerID Customer ID issued by Frankie Financial. This will never change. Your API key, which is mapped to this identity, will change over time.  (required)
     * @param entityId The entityId returned previously from an earlier call to /check or /entity (required)
     * @param checkId The checkId returned previously from an earlier call to *_/verify (required)
     * @param checkClass Specify which check Class this action will apply to (PRO, BCRO etc.). Valid values are:   - \&quot;pro\&quot;: Update a Process Result Object   - \&quot;bcro\&quot;: Update a Background Check Result Object. The class IDs in the request must be the IDs from Background Check Result Object Containers.   - \&quot;fraudlist\&quot;: Update a fraud list Process Result Object. The class IDs in the request must be check sources from fraudlist Process Result Objects.  (required)
     * @param checkClassId A PRO/BCRO ID  (required)
     * @param status Set the new status of the Check Class (PRO/BCRO). Valid values are:   - \&quot;unknown\&quot;   - \&quot;true_positive\&quot;   - \&quot;true_positive_accept\&quot;   - \&quot;true_positive_reject\&quot;   - \&quot;false_positive\&quot;   - \&quot;stale\&quot;  (required)
     * @param xFrankieCustomerChildID If, as a Frankie Customer, you are acting on behalf of your own customers, then you can populate this field with a Frankie-assigned ID.  Note: If using a CustomerChildID, you will also need a separate api_key for each child.  Any documents, checks, entities that are created when this field has been populated will now be tied to this CustomerID + CustomerChildID combination. Just as Customers cannot see data created by other Customers, so too a Customer&#39;s Children will not be able to see each other&#39;s data.  A Customer can see the documents/entities and checks of all their Children.  (optional)
     * @param undo Undo a prior operation.  (optional)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> The request was valid and able to be processed in some fashion. Results may or may not be successful, but it was completed as far as practical with no actual errors. Returns the entity object as it stands now. No docScan file data from any attached ID documents will be returned unless the /full variant is requested. </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad request. One or more request fields is either missing or incorrect. Details are in the error response. </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> The request has failed an authorisation check. This can happen for a variety of reasons, such as an invalid or expired API key, or invalid Customer/CustomerChildIDs.  * NOTE: This does not include attempts to read/write data you don&#39;t have access to - that&#39;s a 404 error (as we don&#39;t want to leak information through guessing)  </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Cannot return response. In the case of a query, or reference to a specific entity/check/etc, it means that the requested item was not found, or you don&#39;t have access to it. Please check your query before trying again. </td><td>  -  </td></tr>
        <tr><td> 405 </td><td> A request to POST an update to an object was not allowed due to it&#39;s state. This may indicate an already completed check, or a document that has been processed. You need to create a new document/check if you wish to update the object in question. </td><td>  -  </td></tr>
        <tr><td> 422 </td><td> Unprocessable request. This can be triggered in a number of ways. * An attempt to force a check or scan to run, but there is insufficient data to be able to do so. * An attempt to run a utility comparison, or similar industry/document/entity specific scan or process on an unsupported document type (e.g. electricity comparison on a passport) Details of what is required will be in the issues list of the error response.  </td><td>  -  </td></tr>
        <tr><td> 429 </td><td> The API client is making too many concurrent requests, and some are being throttled. Throttled requests can be retried after a short delay. </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Unexpected error. Something went wrong during the checking process. </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call updateCheckClassResultCall(UUID xFrankieCustomerID, UUID entityId, UUID checkId, String checkClass, String checkClassId, String status, UUID xFrankieCustomerChildID, Boolean undo, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/entity/{entityId}/check/{checkId}/{checkClass}/{checkClassId}"
            .replace("{" + "entityId" + "}", localVarApiClient.escapeString(entityId.toString()))
            .replace("{" + "checkId" + "}", localVarApiClient.escapeString(checkId.toString()))
            .replace("{" + "checkClass" + "}", localVarApiClient.escapeString(checkClass.toString()))
            .replace("{" + "checkClassId" + "}", localVarApiClient.escapeString(checkClassId.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (status != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("status", status));
        }

        if (undo != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("undo", undo));
        }

        if (xFrankieCustomerID != null) {
            localVarHeaderParams.put("X-Frankie-CustomerID", localVarApiClient.parameterToString(xFrankieCustomerID));
        }

        if (xFrankieCustomerChildID != null) {
            localVarHeaderParams.put("X-Frankie-CustomerChildID", localVarApiClient.parameterToString(xFrankieCustomerChildID));
        }

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "api_key" };
        return localVarApiClient.buildCall(basePath, localVarPath, "POST", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call updateCheckClassResultValidateBeforeCall(UUID xFrankieCustomerID, UUID entityId, UUID checkId, String checkClass, String checkClassId, String status, UUID xFrankieCustomerChildID, Boolean undo, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'xFrankieCustomerID' is set
        if (xFrankieCustomerID == null) {
            throw new ApiException("Missing the required parameter 'xFrankieCustomerID' when calling updateCheckClassResult(Async)");
        }

        // verify the required parameter 'entityId' is set
        if (entityId == null) {
            throw new ApiException("Missing the required parameter 'entityId' when calling updateCheckClassResult(Async)");
        }

        // verify the required parameter 'checkId' is set
        if (checkId == null) {
            throw new ApiException("Missing the required parameter 'checkId' when calling updateCheckClassResult(Async)");
        }

        // verify the required parameter 'checkClass' is set
        if (checkClass == null) {
            throw new ApiException("Missing the required parameter 'checkClass' when calling updateCheckClassResult(Async)");
        }

        // verify the required parameter 'checkClassId' is set
        if (checkClassId == null) {
            throw new ApiException("Missing the required parameter 'checkClassId' when calling updateCheckClassResult(Async)");
        }

        // verify the required parameter 'status' is set
        if (status == null) {
            throw new ApiException("Missing the required parameter 'status' when calling updateCheckClassResult(Async)");
        }

        return updateCheckClassResultCall(xFrankieCustomerID, entityId, checkId, checkClass, checkClassId, status, xFrankieCustomerChildID, undo, _callback);

    }

    /**
     * Update Check Result State
     * Internal only  Update a given KYC or AML check result status in order to force a re-evaluation of the overall check result. 
     * @param xFrankieCustomerID Customer ID issued by Frankie Financial. This will never change. Your API key, which is mapped to this identity, will change over time.  (required)
     * @param entityId The entityId returned previously from an earlier call to /check or /entity (required)
     * @param checkId The checkId returned previously from an earlier call to *_/verify (required)
     * @param checkClass Specify which check Class this action will apply to (PRO, BCRO etc.). Valid values are:   - \&quot;pro\&quot;: Update a Process Result Object   - \&quot;bcro\&quot;: Update a Background Check Result Object. The class IDs in the request must be the IDs from Background Check Result Object Containers.   - \&quot;fraudlist\&quot;: Update a fraud list Process Result Object. The class IDs in the request must be check sources from fraudlist Process Result Objects.  (required)
     * @param checkClassId A PRO/BCRO ID  (required)
     * @param status Set the new status of the Check Class (PRO/BCRO). Valid values are:   - \&quot;unknown\&quot;   - \&quot;true_positive\&quot;   - \&quot;true_positive_accept\&quot;   - \&quot;true_positive_reject\&quot;   - \&quot;false_positive\&quot;   - \&quot;stale\&quot;  (required)
     * @param xFrankieCustomerChildID If, as a Frankie Customer, you are acting on behalf of your own customers, then you can populate this field with a Frankie-assigned ID.  Note: If using a CustomerChildID, you will also need a separate api_key for each child.  Any documents, checks, entities that are created when this field has been populated will now be tied to this CustomerID + CustomerChildID combination. Just as Customers cannot see data created by other Customers, so too a Customer&#39;s Children will not be able to see each other&#39;s data.  A Customer can see the documents/entities and checks of all their Children.  (optional)
     * @param undo Undo a prior operation.  (optional)
     * @return CheckEntityCheckResultObject
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> The request was valid and able to be processed in some fashion. Results may or may not be successful, but it was completed as far as practical with no actual errors. Returns the entity object as it stands now. No docScan file data from any attached ID documents will be returned unless the /full variant is requested. </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad request. One or more request fields is either missing or incorrect. Details are in the error response. </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> The request has failed an authorisation check. This can happen for a variety of reasons, such as an invalid or expired API key, or invalid Customer/CustomerChildIDs.  * NOTE: This does not include attempts to read/write data you don&#39;t have access to - that&#39;s a 404 error (as we don&#39;t want to leak information through guessing)  </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Cannot return response. In the case of a query, or reference to a specific entity/check/etc, it means that the requested item was not found, or you don&#39;t have access to it. Please check your query before trying again. </td><td>  -  </td></tr>
        <tr><td> 405 </td><td> A request to POST an update to an object was not allowed due to it&#39;s state. This may indicate an already completed check, or a document that has been processed. You need to create a new document/check if you wish to update the object in question. </td><td>  -  </td></tr>
        <tr><td> 422 </td><td> Unprocessable request. This can be triggered in a number of ways. * An attempt to force a check or scan to run, but there is insufficient data to be able to do so. * An attempt to run a utility comparison, or similar industry/document/entity specific scan or process on an unsupported document type (e.g. electricity comparison on a passport) Details of what is required will be in the issues list of the error response.  </td><td>  -  </td></tr>
        <tr><td> 429 </td><td> The API client is making too many concurrent requests, and some are being throttled. Throttled requests can be retried after a short delay. </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Unexpected error. Something went wrong during the checking process. </td><td>  -  </td></tr>
     </table>
     */
    public CheckEntityCheckResultObject updateCheckClassResult(UUID xFrankieCustomerID, UUID entityId, UUID checkId, String checkClass, String checkClassId, String status, UUID xFrankieCustomerChildID, Boolean undo) throws ApiException {
        ApiResponse<CheckEntityCheckResultObject> localVarResp = updateCheckClassResultWithHttpInfo(xFrankieCustomerID, entityId, checkId, checkClass, checkClassId, status, xFrankieCustomerChildID, undo);
        return localVarResp.getData();
    }

    /**
     * Update Check Result State
     * Internal only  Update a given KYC or AML check result status in order to force a re-evaluation of the overall check result. 
     * @param xFrankieCustomerID Customer ID issued by Frankie Financial. This will never change. Your API key, which is mapped to this identity, will change over time.  (required)
     * @param entityId The entityId returned previously from an earlier call to /check or /entity (required)
     * @param checkId The checkId returned previously from an earlier call to *_/verify (required)
     * @param checkClass Specify which check Class this action will apply to (PRO, BCRO etc.). Valid values are:   - \&quot;pro\&quot;: Update a Process Result Object   - \&quot;bcro\&quot;: Update a Background Check Result Object. The class IDs in the request must be the IDs from Background Check Result Object Containers.   - \&quot;fraudlist\&quot;: Update a fraud list Process Result Object. The class IDs in the request must be check sources from fraudlist Process Result Objects.  (required)
     * @param checkClassId A PRO/BCRO ID  (required)
     * @param status Set the new status of the Check Class (PRO/BCRO). Valid values are:   - \&quot;unknown\&quot;   - \&quot;true_positive\&quot;   - \&quot;true_positive_accept\&quot;   - \&quot;true_positive_reject\&quot;   - \&quot;false_positive\&quot;   - \&quot;stale\&quot;  (required)
     * @param xFrankieCustomerChildID If, as a Frankie Customer, you are acting on behalf of your own customers, then you can populate this field with a Frankie-assigned ID.  Note: If using a CustomerChildID, you will also need a separate api_key for each child.  Any documents, checks, entities that are created when this field has been populated will now be tied to this CustomerID + CustomerChildID combination. Just as Customers cannot see data created by other Customers, so too a Customer&#39;s Children will not be able to see each other&#39;s data.  A Customer can see the documents/entities and checks of all their Children.  (optional)
     * @param undo Undo a prior operation.  (optional)
     * @return ApiResponse&lt;CheckEntityCheckResultObject&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> The request was valid and able to be processed in some fashion. Results may or may not be successful, but it was completed as far as practical with no actual errors. Returns the entity object as it stands now. No docScan file data from any attached ID documents will be returned unless the /full variant is requested. </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad request. One or more request fields is either missing or incorrect. Details are in the error response. </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> The request has failed an authorisation check. This can happen for a variety of reasons, such as an invalid or expired API key, or invalid Customer/CustomerChildIDs.  * NOTE: This does not include attempts to read/write data you don&#39;t have access to - that&#39;s a 404 error (as we don&#39;t want to leak information through guessing)  </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Cannot return response. In the case of a query, or reference to a specific entity/check/etc, it means that the requested item was not found, or you don&#39;t have access to it. Please check your query before trying again. </td><td>  -  </td></tr>
        <tr><td> 405 </td><td> A request to POST an update to an object was not allowed due to it&#39;s state. This may indicate an already completed check, or a document that has been processed. You need to create a new document/check if you wish to update the object in question. </td><td>  -  </td></tr>
        <tr><td> 422 </td><td> Unprocessable request. This can be triggered in a number of ways. * An attempt to force a check or scan to run, but there is insufficient data to be able to do so. * An attempt to run a utility comparison, or similar industry/document/entity specific scan or process on an unsupported document type (e.g. electricity comparison on a passport) Details of what is required will be in the issues list of the error response.  </td><td>  -  </td></tr>
        <tr><td> 429 </td><td> The API client is making too many concurrent requests, and some are being throttled. Throttled requests can be retried after a short delay. </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Unexpected error. Something went wrong during the checking process. </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<CheckEntityCheckResultObject> updateCheckClassResultWithHttpInfo(UUID xFrankieCustomerID, UUID entityId, UUID checkId, String checkClass, String checkClassId, String status, UUID xFrankieCustomerChildID, Boolean undo) throws ApiException {
        okhttp3.Call localVarCall = updateCheckClassResultValidateBeforeCall(xFrankieCustomerID, entityId, checkId, checkClass, checkClassId, status, xFrankieCustomerChildID, undo, null);
        Type localVarReturnType = new TypeToken<CheckEntityCheckResultObject>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Update Check Result State (asynchronously)
     * Internal only  Update a given KYC or AML check result status in order to force a re-evaluation of the overall check result. 
     * @param xFrankieCustomerID Customer ID issued by Frankie Financial. This will never change. Your API key, which is mapped to this identity, will change over time.  (required)
     * @param entityId The entityId returned previously from an earlier call to /check or /entity (required)
     * @param checkId The checkId returned previously from an earlier call to *_/verify (required)
     * @param checkClass Specify which check Class this action will apply to (PRO, BCRO etc.). Valid values are:   - \&quot;pro\&quot;: Update a Process Result Object   - \&quot;bcro\&quot;: Update a Background Check Result Object. The class IDs in the request must be the IDs from Background Check Result Object Containers.   - \&quot;fraudlist\&quot;: Update a fraud list Process Result Object. The class IDs in the request must be check sources from fraudlist Process Result Objects.  (required)
     * @param checkClassId A PRO/BCRO ID  (required)
     * @param status Set the new status of the Check Class (PRO/BCRO). Valid values are:   - \&quot;unknown\&quot;   - \&quot;true_positive\&quot;   - \&quot;true_positive_accept\&quot;   - \&quot;true_positive_reject\&quot;   - \&quot;false_positive\&quot;   - \&quot;stale\&quot;  (required)
     * @param xFrankieCustomerChildID If, as a Frankie Customer, you are acting on behalf of your own customers, then you can populate this field with a Frankie-assigned ID.  Note: If using a CustomerChildID, you will also need a separate api_key for each child.  Any documents, checks, entities that are created when this field has been populated will now be tied to this CustomerID + CustomerChildID combination. Just as Customers cannot see data created by other Customers, so too a Customer&#39;s Children will not be able to see each other&#39;s data.  A Customer can see the documents/entities and checks of all their Children.  (optional)
     * @param undo Undo a prior operation.  (optional)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> The request was valid and able to be processed in some fashion. Results may or may not be successful, but it was completed as far as practical with no actual errors. Returns the entity object as it stands now. No docScan file data from any attached ID documents will be returned unless the /full variant is requested. </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad request. One or more request fields is either missing or incorrect. Details are in the error response. </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> The request has failed an authorisation check. This can happen for a variety of reasons, such as an invalid or expired API key, or invalid Customer/CustomerChildIDs.  * NOTE: This does not include attempts to read/write data you don&#39;t have access to - that&#39;s a 404 error (as we don&#39;t want to leak information through guessing)  </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Cannot return response. In the case of a query, or reference to a specific entity/check/etc, it means that the requested item was not found, or you don&#39;t have access to it. Please check your query before trying again. </td><td>  -  </td></tr>
        <tr><td> 405 </td><td> A request to POST an update to an object was not allowed due to it&#39;s state. This may indicate an already completed check, or a document that has been processed. You need to create a new document/check if you wish to update the object in question. </td><td>  -  </td></tr>
        <tr><td> 422 </td><td> Unprocessable request. This can be triggered in a number of ways. * An attempt to force a check or scan to run, but there is insufficient data to be able to do so. * An attempt to run a utility comparison, or similar industry/document/entity specific scan or process on an unsupported document type (e.g. electricity comparison on a passport) Details of what is required will be in the issues list of the error response.  </td><td>  -  </td></tr>
        <tr><td> 429 </td><td> The API client is making too many concurrent requests, and some are being throttled. Throttled requests can be retried after a short delay. </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Unexpected error. Something went wrong during the checking process. </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call updateCheckClassResultAsync(UUID xFrankieCustomerID, UUID entityId, UUID checkId, String checkClass, String checkClassId, String status, UUID xFrankieCustomerChildID, Boolean undo, final ApiCallback<CheckEntityCheckResultObject> _callback) throws ApiException {

        okhttp3.Call localVarCall = updateCheckClassResultValidateBeforeCall(xFrankieCustomerID, entityId, checkId, checkClass, checkClassId, status, xFrankieCustomerChildID, undo, _callback);
        Type localVarReturnType = new TypeToken<CheckEntityCheckResultObject>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for updateCheckClassResults
     * @param xFrankieCustomerID Customer ID issued by Frankie Financial. This will never change. Your API key, which is mapped to this identity, will change over time.  (required)
     * @param entityId The entityId returned previously from an earlier call to /check or /entity (required)
     * @param checkId The checkId returned previously from an earlier call to *_/verify (required)
     * @param checkClass Specify which check Class this action will apply to (PRO, BCRO etc.). Valid values are:   - \&quot;pro\&quot;: Update a Process Result Object   - \&quot;bcro\&quot;: Update a Background Check Result Object. The class IDs in the request must be the IDs from Background Check Result Object Containers.   - \&quot;fraudlist\&quot;: Update a fraud list Process Result Object. The class IDs in the request must be check sources from fraudlist Process Result Objects.  (required)
     * @param checkResultUpdate The check result status change details to apply (required)
     * @param xFrankieCustomerChildID If, as a Frankie Customer, you are acting on behalf of your own customers, then you can populate this field with a Frankie-assigned ID.  Note: If using a CustomerChildID, you will also need a separate api_key for each child.  Any documents, checks, entities that are created when this field has been populated will now be tied to this CustomerID + CustomerChildID combination. Just as Customers cannot see data created by other Customers, so too a Customer&#39;s Children will not be able to see each other&#39;s data.  A Customer can see the documents/entities and checks of all their Children.  (optional)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> The request was valid and able to be processed in some fashion. Results may or may not be successful, but it was completed as far as practical with no actual errors. Returns the entity object as it stands now. No docScan file data from any attached ID documents will be returned unless the /full variant is requested. </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad request. One or more request fields is either missing or incorrect. Details are in the error response. </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> The request has failed an authorisation check. This can happen for a variety of reasons, such as an invalid or expired API key, or invalid Customer/CustomerChildIDs.  * NOTE: This does not include attempts to read/write data you don&#39;t have access to - that&#39;s a 404 error (as we don&#39;t want to leak information through guessing)  </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Cannot return response. In the case of a query, or reference to a specific entity/check/etc, it means that the requested item was not found, or you don&#39;t have access to it. Please check your query before trying again. </td><td>  -  </td></tr>
        <tr><td> 405 </td><td> A request to POST an update to an object was not allowed due to it&#39;s state. This may indicate an already completed check, or a document that has been processed. You need to create a new document/check if you wish to update the object in question. </td><td>  -  </td></tr>
        <tr><td> 422 </td><td> Unprocessable request. This can be triggered in a number of ways. * An attempt to force a check or scan to run, but there is insufficient data to be able to do so. * An attempt to run a utility comparison, or similar industry/document/entity specific scan or process on an unsupported document type (e.g. electricity comparison on a passport) Details of what is required will be in the issues list of the error response.  </td><td>  -  </td></tr>
        <tr><td> 429 </td><td> The API client is making too many concurrent requests, and some are being throttled. Throttled requests can be retried after a short delay. </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Unexpected error. Something went wrong during the checking process. </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call updateCheckClassResultsCall(UUID xFrankieCustomerID, UUID entityId, UUID checkId, String checkClass, CheckResultUpdateObject checkResultUpdate, UUID xFrankieCustomerChildID, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = checkResultUpdate;

        // create path and map variables
        String localVarPath = "/entity/{entityId}/check/{checkId}/{checkClass}"
            .replace("{" + "entityId" + "}", localVarApiClient.escapeString(entityId.toString()))
            .replace("{" + "checkId" + "}", localVarApiClient.escapeString(checkId.toString()))
            .replace("{" + "checkClass" + "}", localVarApiClient.escapeString(checkClass.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (xFrankieCustomerID != null) {
            localVarHeaderParams.put("X-Frankie-CustomerID", localVarApiClient.parameterToString(xFrankieCustomerID));
        }

        if (xFrankieCustomerChildID != null) {
            localVarHeaderParams.put("X-Frankie-CustomerChildID", localVarApiClient.parameterToString(xFrankieCustomerChildID));
        }

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            "application/json"
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "api_key" };
        return localVarApiClient.buildCall(basePath, localVarPath, "POST", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call updateCheckClassResultsValidateBeforeCall(UUID xFrankieCustomerID, UUID entityId, UUID checkId, String checkClass, CheckResultUpdateObject checkResultUpdate, UUID xFrankieCustomerChildID, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'xFrankieCustomerID' is set
        if (xFrankieCustomerID == null) {
            throw new ApiException("Missing the required parameter 'xFrankieCustomerID' when calling updateCheckClassResults(Async)");
        }

        // verify the required parameter 'entityId' is set
        if (entityId == null) {
            throw new ApiException("Missing the required parameter 'entityId' when calling updateCheckClassResults(Async)");
        }

        // verify the required parameter 'checkId' is set
        if (checkId == null) {
            throw new ApiException("Missing the required parameter 'checkId' when calling updateCheckClassResults(Async)");
        }

        // verify the required parameter 'checkClass' is set
        if (checkClass == null) {
            throw new ApiException("Missing the required parameter 'checkClass' when calling updateCheckClassResults(Async)");
        }

        // verify the required parameter 'checkResultUpdate' is set
        if (checkResultUpdate == null) {
            throw new ApiException("Missing the required parameter 'checkResultUpdate' when calling updateCheckClassResults(Async)");
        }

        return updateCheckClassResultsCall(xFrankieCustomerID, entityId, checkId, checkClass, checkResultUpdate, xFrankieCustomerChildID, _callback);

    }

    /**
     * Update Check Result States (Batch)
     * Internal only  Update a given set of KYC and/or AML check result statuses in order to force a re-evaluation of the overall check result. 
     * @param xFrankieCustomerID Customer ID issued by Frankie Financial. This will never change. Your API key, which is mapped to this identity, will change over time.  (required)
     * @param entityId The entityId returned previously from an earlier call to /check or /entity (required)
     * @param checkId The checkId returned previously from an earlier call to *_/verify (required)
     * @param checkClass Specify which check Class this action will apply to (PRO, BCRO etc.). Valid values are:   - \&quot;pro\&quot;: Update a Process Result Object   - \&quot;bcro\&quot;: Update a Background Check Result Object. The class IDs in the request must be the IDs from Background Check Result Object Containers.   - \&quot;fraudlist\&quot;: Update a fraud list Process Result Object. The class IDs in the request must be check sources from fraudlist Process Result Objects.  (required)
     * @param checkResultUpdate The check result status change details to apply (required)
     * @param xFrankieCustomerChildID If, as a Frankie Customer, you are acting on behalf of your own customers, then you can populate this field with a Frankie-assigned ID.  Note: If using a CustomerChildID, you will also need a separate api_key for each child.  Any documents, checks, entities that are created when this field has been populated will now be tied to this CustomerID + CustomerChildID combination. Just as Customers cannot see data created by other Customers, so too a Customer&#39;s Children will not be able to see each other&#39;s data.  A Customer can see the documents/entities and checks of all their Children.  (optional)
     * @return CheckEntityCheckResultObject
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> The request was valid and able to be processed in some fashion. Results may or may not be successful, but it was completed as far as practical with no actual errors. Returns the entity object as it stands now. No docScan file data from any attached ID documents will be returned unless the /full variant is requested. </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad request. One or more request fields is either missing or incorrect. Details are in the error response. </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> The request has failed an authorisation check. This can happen for a variety of reasons, such as an invalid or expired API key, or invalid Customer/CustomerChildIDs.  * NOTE: This does not include attempts to read/write data you don&#39;t have access to - that&#39;s a 404 error (as we don&#39;t want to leak information through guessing)  </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Cannot return response. In the case of a query, or reference to a specific entity/check/etc, it means that the requested item was not found, or you don&#39;t have access to it. Please check your query before trying again. </td><td>  -  </td></tr>
        <tr><td> 405 </td><td> A request to POST an update to an object was not allowed due to it&#39;s state. This may indicate an already completed check, or a document that has been processed. You need to create a new document/check if you wish to update the object in question. </td><td>  -  </td></tr>
        <tr><td> 422 </td><td> Unprocessable request. This can be triggered in a number of ways. * An attempt to force a check or scan to run, but there is insufficient data to be able to do so. * An attempt to run a utility comparison, or similar industry/document/entity specific scan or process on an unsupported document type (e.g. electricity comparison on a passport) Details of what is required will be in the issues list of the error response.  </td><td>  -  </td></tr>
        <tr><td> 429 </td><td> The API client is making too many concurrent requests, and some are being throttled. Throttled requests can be retried after a short delay. </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Unexpected error. Something went wrong during the checking process. </td><td>  -  </td></tr>
     </table>
     */
    public CheckEntityCheckResultObject updateCheckClassResults(UUID xFrankieCustomerID, UUID entityId, UUID checkId, String checkClass, CheckResultUpdateObject checkResultUpdate, UUID xFrankieCustomerChildID) throws ApiException {
        ApiResponse<CheckEntityCheckResultObject> localVarResp = updateCheckClassResultsWithHttpInfo(xFrankieCustomerID, entityId, checkId, checkClass, checkResultUpdate, xFrankieCustomerChildID);
        return localVarResp.getData();
    }

    /**
     * Update Check Result States (Batch)
     * Internal only  Update a given set of KYC and/or AML check result statuses in order to force a re-evaluation of the overall check result. 
     * @param xFrankieCustomerID Customer ID issued by Frankie Financial. This will never change. Your API key, which is mapped to this identity, will change over time.  (required)
     * @param entityId The entityId returned previously from an earlier call to /check or /entity (required)
     * @param checkId The checkId returned previously from an earlier call to *_/verify (required)
     * @param checkClass Specify which check Class this action will apply to (PRO, BCRO etc.). Valid values are:   - \&quot;pro\&quot;: Update a Process Result Object   - \&quot;bcro\&quot;: Update a Background Check Result Object. The class IDs in the request must be the IDs from Background Check Result Object Containers.   - \&quot;fraudlist\&quot;: Update a fraud list Process Result Object. The class IDs in the request must be check sources from fraudlist Process Result Objects.  (required)
     * @param checkResultUpdate The check result status change details to apply (required)
     * @param xFrankieCustomerChildID If, as a Frankie Customer, you are acting on behalf of your own customers, then you can populate this field with a Frankie-assigned ID.  Note: If using a CustomerChildID, you will also need a separate api_key for each child.  Any documents, checks, entities that are created when this field has been populated will now be tied to this CustomerID + CustomerChildID combination. Just as Customers cannot see data created by other Customers, so too a Customer&#39;s Children will not be able to see each other&#39;s data.  A Customer can see the documents/entities and checks of all their Children.  (optional)
     * @return ApiResponse&lt;CheckEntityCheckResultObject&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> The request was valid and able to be processed in some fashion. Results may or may not be successful, but it was completed as far as practical with no actual errors. Returns the entity object as it stands now. No docScan file data from any attached ID documents will be returned unless the /full variant is requested. </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad request. One or more request fields is either missing or incorrect. Details are in the error response. </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> The request has failed an authorisation check. This can happen for a variety of reasons, such as an invalid or expired API key, or invalid Customer/CustomerChildIDs.  * NOTE: This does not include attempts to read/write data you don&#39;t have access to - that&#39;s a 404 error (as we don&#39;t want to leak information through guessing)  </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Cannot return response. In the case of a query, or reference to a specific entity/check/etc, it means that the requested item was not found, or you don&#39;t have access to it. Please check your query before trying again. </td><td>  -  </td></tr>
        <tr><td> 405 </td><td> A request to POST an update to an object was not allowed due to it&#39;s state. This may indicate an already completed check, or a document that has been processed. You need to create a new document/check if you wish to update the object in question. </td><td>  -  </td></tr>
        <tr><td> 422 </td><td> Unprocessable request. This can be triggered in a number of ways. * An attempt to force a check or scan to run, but there is insufficient data to be able to do so. * An attempt to run a utility comparison, or similar industry/document/entity specific scan or process on an unsupported document type (e.g. electricity comparison on a passport) Details of what is required will be in the issues list of the error response.  </td><td>  -  </td></tr>
        <tr><td> 429 </td><td> The API client is making too many concurrent requests, and some are being throttled. Throttled requests can be retried after a short delay. </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Unexpected error. Something went wrong during the checking process. </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<CheckEntityCheckResultObject> updateCheckClassResultsWithHttpInfo(UUID xFrankieCustomerID, UUID entityId, UUID checkId, String checkClass, CheckResultUpdateObject checkResultUpdate, UUID xFrankieCustomerChildID) throws ApiException {
        okhttp3.Call localVarCall = updateCheckClassResultsValidateBeforeCall(xFrankieCustomerID, entityId, checkId, checkClass, checkResultUpdate, xFrankieCustomerChildID, null);
        Type localVarReturnType = new TypeToken<CheckEntityCheckResultObject>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Update Check Result States (Batch) (asynchronously)
     * Internal only  Update a given set of KYC and/or AML check result statuses in order to force a re-evaluation of the overall check result. 
     * @param xFrankieCustomerID Customer ID issued by Frankie Financial. This will never change. Your API key, which is mapped to this identity, will change over time.  (required)
     * @param entityId The entityId returned previously from an earlier call to /check or /entity (required)
     * @param checkId The checkId returned previously from an earlier call to *_/verify (required)
     * @param checkClass Specify which check Class this action will apply to (PRO, BCRO etc.). Valid values are:   - \&quot;pro\&quot;: Update a Process Result Object   - \&quot;bcro\&quot;: Update a Background Check Result Object. The class IDs in the request must be the IDs from Background Check Result Object Containers.   - \&quot;fraudlist\&quot;: Update a fraud list Process Result Object. The class IDs in the request must be check sources from fraudlist Process Result Objects.  (required)
     * @param checkResultUpdate The check result status change details to apply (required)
     * @param xFrankieCustomerChildID If, as a Frankie Customer, you are acting on behalf of your own customers, then you can populate this field with a Frankie-assigned ID.  Note: If using a CustomerChildID, you will also need a separate api_key for each child.  Any documents, checks, entities that are created when this field has been populated will now be tied to this CustomerID + CustomerChildID combination. Just as Customers cannot see data created by other Customers, so too a Customer&#39;s Children will not be able to see each other&#39;s data.  A Customer can see the documents/entities and checks of all their Children.  (optional)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> The request was valid and able to be processed in some fashion. Results may or may not be successful, but it was completed as far as practical with no actual errors. Returns the entity object as it stands now. No docScan file data from any attached ID documents will be returned unless the /full variant is requested. </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad request. One or more request fields is either missing or incorrect. Details are in the error response. </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> The request has failed an authorisation check. This can happen for a variety of reasons, such as an invalid or expired API key, or invalid Customer/CustomerChildIDs.  * NOTE: This does not include attempts to read/write data you don&#39;t have access to - that&#39;s a 404 error (as we don&#39;t want to leak information through guessing)  </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Cannot return response. In the case of a query, or reference to a specific entity/check/etc, it means that the requested item was not found, or you don&#39;t have access to it. Please check your query before trying again. </td><td>  -  </td></tr>
        <tr><td> 405 </td><td> A request to POST an update to an object was not allowed due to it&#39;s state. This may indicate an already completed check, or a document that has been processed. You need to create a new document/check if you wish to update the object in question. </td><td>  -  </td></tr>
        <tr><td> 422 </td><td> Unprocessable request. This can be triggered in a number of ways. * An attempt to force a check or scan to run, but there is insufficient data to be able to do so. * An attempt to run a utility comparison, or similar industry/document/entity specific scan or process on an unsupported document type (e.g. electricity comparison on a passport) Details of what is required will be in the issues list of the error response.  </td><td>  -  </td></tr>
        <tr><td> 429 </td><td> The API client is making too many concurrent requests, and some are being throttled. Throttled requests can be retried after a short delay. </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Unexpected error. Something went wrong during the checking process. </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call updateCheckClassResultsAsync(UUID xFrankieCustomerID, UUID entityId, UUID checkId, String checkClass, CheckResultUpdateObject checkResultUpdate, UUID xFrankieCustomerChildID, final ApiCallback<CheckEntityCheckResultObject> _callback) throws ApiException {

        okhttp3.Call localVarCall = updateCheckClassResultsValidateBeforeCall(xFrankieCustomerID, entityId, checkId, checkClass, checkResultUpdate, xFrankieCustomerChildID, _callback);
        Type localVarReturnType = new TypeToken<CheckEntityCheckResultObject>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for updateCheckEntity
     * @param xFrankieCustomerID Customer ID issued by Frankie Financial. This will never change. Your API key, which is mapped to this identity, will change over time.  (required)
     * @param entityId The entityId returned previously from an earlier call to /check or /entity (required)
     * @param checkType When creating a new check, you need to define the checks you wish to run.    The checkType is make up of a comma separated list of the types of check you wish to run. The order of the requested checks is not important, they will be re-ordered by the service and in some cases, depending on your account configuration, may be skipped.    The validation that is performed on the requested checks is to:   - ensure the check type is known   - is suitable for the type of entity (no KYC for organisations)   - disallow manual (mKYC) check with any other kind of KYC   - disallow mixing the \&quot;profile\&quot; check with any other kind of check.  The supported check types are:  Profile:   - \&quot;profile\&quot;: By arrangement with Frankie we will create a \&quot;profile\&quot; check type that applies checks according to a recipe that you assign to the entity from a predefined set of profiles.      The profile to use will be taken from the entity.entityProfile field if set, or be run through a set of configurable rules to determine which one to use.      Profiles provide a pre-defined combination of individual checkTypes (see the list below). But they offer a lot more besides, including rules for determining default settings, inbuilt data aging and other configurable features.   They also allow for a new result set top be returned that provides a more detailed and useful breakdown of the check/verification process.      Entity Profiles are a recent feature (since v1.4.0) but are now the default checkType to use with Frankie Financial.  **Individual Check Types**  Whilst we strongly recommend the use of the \&quot;profile\&quot; checktype, it does map of any combination of the types below. If you wish to use these individually, please contact developer support for more details on how to use these effectively.  Entity Checks - One of:   - \&quot;one_plus\&quot;: Checks name, address and DoB against a minimum of 1 data source. (also known as a 1+1)   - \&quot;two_plus\&quot;: Checks name, address and DoB against a minimum of 2 independent data sources (also known as a 2+2)  ID Checks - One of:   - \&quot;id\&quot;: Checks all of the identity documents, but not necessarily the entity itself independently. Use this in conjunction with a one_plus or two_plus for more.   - \&quot;visa\&quot;:    ID Validate - One of:   - \&quot;idvalidate\&quot;: Checks to see if photo ID has had OCR scanning, ID document validation and photo comparison run against it. Can be used in conjunction with any of the KYC/ID/AML checks.    Manual Check:   - \&quot;manual\&quot;: (mKYC) Checks user has a sufficient amount of operator verified ID and will then \&quot;pass\&quot; all Entity and ID related checks.    Fraud Checks - One or more of:   - \&quot;fraudlist\&quot;: Checks to see if the identity appears on any known fraud lists. Should be run after KYC/ID checks have passed.   - \&quot;fraudcheck\&quot;: Checks external ID services to see if details appear in fraud detection services (e.g. EmailAge or FraudNet)    PEP Checks - One of:   - \&quot;pep\&quot;: Will only run PEP/Sanctions checks (no identity verification)   - \&quot;pep_media\&quot;: Will run PEP/Sanctions checks, as well as watchlist and adverse media checks. (no identity verification)      * NOTE: These checks will ONLY run if either the KYC/ID checks have been run prior, or it is the only check requested.    Custom:   - By arrangement with Frankie you can define your own KYC check type.      This will allow you to set the minimum number of matches for:     - name      - date of birth     - address     - government id      This allows for alternatives to the \&quot;standard\&quot; two_plus or one_plus (note, these can be overridden too).  (required)
     * @param resultLevel How much detail we return.   Acceptable values are:   * simple - Only available with \&quot;profile\&quot; check type. Returns just an EntityProfileResultObject (which is also included for \&quot;profile\&quot; checks at the other result levels), and a CheckEntityCheckResultObjectEntityResult with just the entity details but no separate results.   * summary   * full - You need to have your account configured for this.  (required)
     * @param entityDetails The entity to be checked (required)
     * @param xFrankieCustomerChildID If, as a Frankie Customer, you are acting on behalf of your own customers, then you can populate this field with a Frankie-assigned ID.  Note: If using a CustomerChildID, you will also need a separate api_key for each child.  Any documents, checks, entities that are created when this field has been populated will now be tied to this CustomerID + CustomerChildID combination. Just as Customers cannot see data created by other Customers, so too a Customer&#39;s Children will not be able to see each other&#39;s data.  A Customer can see the documents/entities and checks of all their Children.  (optional)
     * @param xFrankieBackground If this header parameter is supplied and set to 1, then the request will not wait for the process to finish, and will return a 202 if there are no obvious errors in the input. The request will then run in the background and send a notification back to the customer. See out callback API for details on this.  See more details here:   https://apidocs.frankiefinancial.com/docs/asynchronous-calls-backgrounding-processes  (optional)
     * @param force Force the verification to run, overriding any data aging or past check  (optional)
     * @param noInvalidate Disable check result invalidation for this update request.  (optional)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> The request was valid and able to be processed in some fashion. Results may or may not be successful, but it was completed as far as practical with no actual errors. Returns the entity object as it stands now. No docScan file data from any attached ID documents will be returned unless the /full variant is requested. </td><td>  -  </td></tr>
        <tr><td> 202 </td><td> The request was valid and can potentially be fulfilled. The Frankie service has now accepted responsibility for processing and we will either push the results to you, or send you a notification, depending on the request and your configuration. </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad request. One or more request fields is either missing or incorrect. Details are in the error response. </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> The request has failed an authorisation check. This can happen for a variety of reasons, such as an invalid or expired API key, or invalid Customer/CustomerChildIDs.  * NOTE: This does not include attempts to read/write data you don&#39;t have access to - that&#39;s a 404 error (as we don&#39;t want to leak information through guessing)  </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Cannot return response. In the case of a query, or reference to a specific entity/check/etc, it means that the requested item was not found, or you don&#39;t have access to it. Please check your query before trying again. </td><td>  -  </td></tr>
        <tr><td> 405 </td><td> A request to POST an update to an object was not allowed due to it&#39;s state. This may indicate an already completed check, or a document that has been processed. You need to create a new document/check if you wish to update the object in question. </td><td>  -  </td></tr>
        <tr><td> 415 </td><td> For requests with payloads, an unsupported Content-Type was specified. The Frankie Financial API only supports a content type of application/json. </td><td>  -  </td></tr>
        <tr><td> 422 </td><td> Unprocessable request. This can be triggered in a number of ways. * An attempt to force a check or scan to run, but there is insufficient data to be able to do so. * An attempt to run a utility comparison, or similar industry/document/entity specific scan or process on an unsupported document type (e.g. electricity comparison on a passport) Details of what is required will be in the issues list of the error response.  </td><td>  -  </td></tr>
        <tr><td> 429 </td><td> The API client is making too many concurrent requests, and some are being throttled. Throttled requests can be retried after a short delay. </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Unexpected error. Something went wrong during the checking process. </td><td>  -  </td></tr>
        <tr><td> 503 </td><td> All of the ID sources configured by the customer are unavailable, or there is no available document processor. </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call updateCheckEntityCall(UUID xFrankieCustomerID, UUID entityId, String checkType, String resultLevel, EntityCheckDetailsObject entityDetails, UUID xFrankieCustomerChildID, Integer xFrankieBackground, Boolean force, Boolean noInvalidate, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = entityDetails;

        // create path and map variables
        String localVarPath = "/entity/{entityId}/verify/{checkType}/{resultLevel}"
            .replace("{" + "entityId" + "}", localVarApiClient.escapeString(entityId.toString()))
            .replace("{" + "checkType" + "}", localVarApiClient.escapeString(checkType.toString()))
            .replace("{" + "resultLevel" + "}", localVarApiClient.escapeString(resultLevel.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (force != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("force", force));
        }

        if (noInvalidate != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("noInvalidate", noInvalidate));
        }

        if (xFrankieCustomerID != null) {
            localVarHeaderParams.put("X-Frankie-CustomerID", localVarApiClient.parameterToString(xFrankieCustomerID));
        }

        if (xFrankieCustomerChildID != null) {
            localVarHeaderParams.put("X-Frankie-CustomerChildID", localVarApiClient.parameterToString(xFrankieCustomerChildID));
        }

        if (xFrankieBackground != null) {
            localVarHeaderParams.put("X-Frankie-Background", localVarApiClient.parameterToString(xFrankieBackground));
        }

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            "application/json"
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "api_key" };
        return localVarApiClient.buildCall(basePath, localVarPath, "POST", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call updateCheckEntityValidateBeforeCall(UUID xFrankieCustomerID, UUID entityId, String checkType, String resultLevel, EntityCheckDetailsObject entityDetails, UUID xFrankieCustomerChildID, Integer xFrankieBackground, Boolean force, Boolean noInvalidate, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'xFrankieCustomerID' is set
        if (xFrankieCustomerID == null) {
            throw new ApiException("Missing the required parameter 'xFrankieCustomerID' when calling updateCheckEntity(Async)");
        }

        // verify the required parameter 'entityId' is set
        if (entityId == null) {
            throw new ApiException("Missing the required parameter 'entityId' when calling updateCheckEntity(Async)");
        }

        // verify the required parameter 'checkType' is set
        if (checkType == null) {
            throw new ApiException("Missing the required parameter 'checkType' when calling updateCheckEntity(Async)");
        }

        // verify the required parameter 'resultLevel' is set
        if (resultLevel == null) {
            throw new ApiException("Missing the required parameter 'resultLevel' when calling updateCheckEntity(Async)");
        }

        // verify the required parameter 'entityDetails' is set
        if (entityDetails == null) {
            throw new ApiException("Missing the required parameter 'entityDetails' when calling updateCheckEntity(Async)");
        }

        return updateCheckEntityCall(xFrankieCustomerID, entityId, checkType, resultLevel, entityDetails, xFrankieCustomerChildID, xFrankieBackground, force, noInvalidate, _callback);

    }

    /**
     * Update Entity and Verify Details
     * Take the details and documents provided in the entity, and set about verifying them all. So for example, you might extract:  * The name from the entity.name object * The address from the entity.address object * The DoB..  All documents that are presently attached to the entity will also be verified (if requested)  You can also specify the level of detail returned using the resultLevel parameter. You can choose \&quot;summary\&quot; or \&quot;full\&quot;. For the \&quot;profile\&quot; check type you can also select \&quot;simple\&quot; to only get the entity profile result.  SPECIAL NOTE: A \&quot;Full\&quot; response includes details of all checks and how they map against each element, along with all the details of pep/sanctions/etc checks too.  Your account also needs to be configured to support a full response too (talk to your account manager for more information). If you&#39;re not configured for full responses, we&#39;ll only return summary level data regardless. 
     * @param xFrankieCustomerID Customer ID issued by Frankie Financial. This will never change. Your API key, which is mapped to this identity, will change over time.  (required)
     * @param entityId The entityId returned previously from an earlier call to /check or /entity (required)
     * @param checkType When creating a new check, you need to define the checks you wish to run.    The checkType is make up of a comma separated list of the types of check you wish to run. The order of the requested checks is not important, they will be re-ordered by the service and in some cases, depending on your account configuration, may be skipped.    The validation that is performed on the requested checks is to:   - ensure the check type is known   - is suitable for the type of entity (no KYC for organisations)   - disallow manual (mKYC) check with any other kind of KYC   - disallow mixing the \&quot;profile\&quot; check with any other kind of check.  The supported check types are:  Profile:   - \&quot;profile\&quot;: By arrangement with Frankie we will create a \&quot;profile\&quot; check type that applies checks according to a recipe that you assign to the entity from a predefined set of profiles.      The profile to use will be taken from the entity.entityProfile field if set, or be run through a set of configurable rules to determine which one to use.      Profiles provide a pre-defined combination of individual checkTypes (see the list below). But they offer a lot more besides, including rules for determining default settings, inbuilt data aging and other configurable features.   They also allow for a new result set top be returned that provides a more detailed and useful breakdown of the check/verification process.      Entity Profiles are a recent feature (since v1.4.0) but are now the default checkType to use with Frankie Financial.  **Individual Check Types**  Whilst we strongly recommend the use of the \&quot;profile\&quot; checktype, it does map of any combination of the types below. If you wish to use these individually, please contact developer support for more details on how to use these effectively.  Entity Checks - One of:   - \&quot;one_plus\&quot;: Checks name, address and DoB against a minimum of 1 data source. (also known as a 1+1)   - \&quot;two_plus\&quot;: Checks name, address and DoB against a minimum of 2 independent data sources (also known as a 2+2)  ID Checks - One of:   - \&quot;id\&quot;: Checks all of the identity documents, but not necessarily the entity itself independently. Use this in conjunction with a one_plus or two_plus for more.   - \&quot;visa\&quot;:    ID Validate - One of:   - \&quot;idvalidate\&quot;: Checks to see if photo ID has had OCR scanning, ID document validation and photo comparison run against it. Can be used in conjunction with any of the KYC/ID/AML checks.    Manual Check:   - \&quot;manual\&quot;: (mKYC) Checks user has a sufficient amount of operator verified ID and will then \&quot;pass\&quot; all Entity and ID related checks.    Fraud Checks - One or more of:   - \&quot;fraudlist\&quot;: Checks to see if the identity appears on any known fraud lists. Should be run after KYC/ID checks have passed.   - \&quot;fraudcheck\&quot;: Checks external ID services to see if details appear in fraud detection services (e.g. EmailAge or FraudNet)    PEP Checks - One of:   - \&quot;pep\&quot;: Will only run PEP/Sanctions checks (no identity verification)   - \&quot;pep_media\&quot;: Will run PEP/Sanctions checks, as well as watchlist and adverse media checks. (no identity verification)      * NOTE: These checks will ONLY run if either the KYC/ID checks have been run prior, or it is the only check requested.    Custom:   - By arrangement with Frankie you can define your own KYC check type.      This will allow you to set the minimum number of matches for:     - name      - date of birth     - address     - government id      This allows for alternatives to the \&quot;standard\&quot; two_plus or one_plus (note, these can be overridden too).  (required)
     * @param resultLevel How much detail we return.   Acceptable values are:   * simple - Only available with \&quot;profile\&quot; check type. Returns just an EntityProfileResultObject (which is also included for \&quot;profile\&quot; checks at the other result levels), and a CheckEntityCheckResultObjectEntityResult with just the entity details but no separate results.   * summary   * full - You need to have your account configured for this.  (required)
     * @param entityDetails The entity to be checked (required)
     * @param xFrankieCustomerChildID If, as a Frankie Customer, you are acting on behalf of your own customers, then you can populate this field with a Frankie-assigned ID.  Note: If using a CustomerChildID, you will also need a separate api_key for each child.  Any documents, checks, entities that are created when this field has been populated will now be tied to this CustomerID + CustomerChildID combination. Just as Customers cannot see data created by other Customers, so too a Customer&#39;s Children will not be able to see each other&#39;s data.  A Customer can see the documents/entities and checks of all their Children.  (optional)
     * @param xFrankieBackground If this header parameter is supplied and set to 1, then the request will not wait for the process to finish, and will return a 202 if there are no obvious errors in the input. The request will then run in the background and send a notification back to the customer. See out callback API for details on this.  See more details here:   https://apidocs.frankiefinancial.com/docs/asynchronous-calls-backgrounding-processes  (optional)
     * @param force Force the verification to run, overriding any data aging or past check  (optional)
     * @param noInvalidate Disable check result invalidation for this update request.  (optional)
     * @return CheckEntityCheckResultObject
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> The request was valid and able to be processed in some fashion. Results may or may not be successful, but it was completed as far as practical with no actual errors. Returns the entity object as it stands now. No docScan file data from any attached ID documents will be returned unless the /full variant is requested. </td><td>  -  </td></tr>
        <tr><td> 202 </td><td> The request was valid and can potentially be fulfilled. The Frankie service has now accepted responsibility for processing and we will either push the results to you, or send you a notification, depending on the request and your configuration. </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad request. One or more request fields is either missing or incorrect. Details are in the error response. </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> The request has failed an authorisation check. This can happen for a variety of reasons, such as an invalid or expired API key, or invalid Customer/CustomerChildIDs.  * NOTE: This does not include attempts to read/write data you don&#39;t have access to - that&#39;s a 404 error (as we don&#39;t want to leak information through guessing)  </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Cannot return response. In the case of a query, or reference to a specific entity/check/etc, it means that the requested item was not found, or you don&#39;t have access to it. Please check your query before trying again. </td><td>  -  </td></tr>
        <tr><td> 405 </td><td> A request to POST an update to an object was not allowed due to it&#39;s state. This may indicate an already completed check, or a document that has been processed. You need to create a new document/check if you wish to update the object in question. </td><td>  -  </td></tr>
        <tr><td> 415 </td><td> For requests with payloads, an unsupported Content-Type was specified. The Frankie Financial API only supports a content type of application/json. </td><td>  -  </td></tr>
        <tr><td> 422 </td><td> Unprocessable request. This can be triggered in a number of ways. * An attempt to force a check or scan to run, but there is insufficient data to be able to do so. * An attempt to run a utility comparison, or similar industry/document/entity specific scan or process on an unsupported document type (e.g. electricity comparison on a passport) Details of what is required will be in the issues list of the error response.  </td><td>  -  </td></tr>
        <tr><td> 429 </td><td> The API client is making too many concurrent requests, and some are being throttled. Throttled requests can be retried after a short delay. </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Unexpected error. Something went wrong during the checking process. </td><td>  -  </td></tr>
        <tr><td> 503 </td><td> All of the ID sources configured by the customer are unavailable, or there is no available document processor. </td><td>  -  </td></tr>
     </table>
     */
    public CheckEntityCheckResultObject updateCheckEntity(UUID xFrankieCustomerID, UUID entityId, String checkType, String resultLevel, EntityCheckDetailsObject entityDetails, UUID xFrankieCustomerChildID, Integer xFrankieBackground, Boolean force, Boolean noInvalidate) throws ApiException {
        ApiResponse<CheckEntityCheckResultObject> localVarResp = updateCheckEntityWithHttpInfo(xFrankieCustomerID, entityId, checkType, resultLevel, entityDetails, xFrankieCustomerChildID, xFrankieBackground, force, noInvalidate);
        return localVarResp.getData();
    }

    /**
     * Update Entity and Verify Details
     * Take the details and documents provided in the entity, and set about verifying them all. So for example, you might extract:  * The name from the entity.name object * The address from the entity.address object * The DoB..  All documents that are presently attached to the entity will also be verified (if requested)  You can also specify the level of detail returned using the resultLevel parameter. You can choose \&quot;summary\&quot; or \&quot;full\&quot;. For the \&quot;profile\&quot; check type you can also select \&quot;simple\&quot; to only get the entity profile result.  SPECIAL NOTE: A \&quot;Full\&quot; response includes details of all checks and how they map against each element, along with all the details of pep/sanctions/etc checks too.  Your account also needs to be configured to support a full response too (talk to your account manager for more information). If you&#39;re not configured for full responses, we&#39;ll only return summary level data regardless. 
     * @param xFrankieCustomerID Customer ID issued by Frankie Financial. This will never change. Your API key, which is mapped to this identity, will change over time.  (required)
     * @param entityId The entityId returned previously from an earlier call to /check or /entity (required)
     * @param checkType When creating a new check, you need to define the checks you wish to run.    The checkType is make up of a comma separated list of the types of check you wish to run. The order of the requested checks is not important, they will be re-ordered by the service and in some cases, depending on your account configuration, may be skipped.    The validation that is performed on the requested checks is to:   - ensure the check type is known   - is suitable for the type of entity (no KYC for organisations)   - disallow manual (mKYC) check with any other kind of KYC   - disallow mixing the \&quot;profile\&quot; check with any other kind of check.  The supported check types are:  Profile:   - \&quot;profile\&quot;: By arrangement with Frankie we will create a \&quot;profile\&quot; check type that applies checks according to a recipe that you assign to the entity from a predefined set of profiles.      The profile to use will be taken from the entity.entityProfile field if set, or be run through a set of configurable rules to determine which one to use.      Profiles provide a pre-defined combination of individual checkTypes (see the list below). But they offer a lot more besides, including rules for determining default settings, inbuilt data aging and other configurable features.   They also allow for a new result set top be returned that provides a more detailed and useful breakdown of the check/verification process.      Entity Profiles are a recent feature (since v1.4.0) but are now the default checkType to use with Frankie Financial.  **Individual Check Types**  Whilst we strongly recommend the use of the \&quot;profile\&quot; checktype, it does map of any combination of the types below. If you wish to use these individually, please contact developer support for more details on how to use these effectively.  Entity Checks - One of:   - \&quot;one_plus\&quot;: Checks name, address and DoB against a minimum of 1 data source. (also known as a 1+1)   - \&quot;two_plus\&quot;: Checks name, address and DoB against a minimum of 2 independent data sources (also known as a 2+2)  ID Checks - One of:   - \&quot;id\&quot;: Checks all of the identity documents, but not necessarily the entity itself independently. Use this in conjunction with a one_plus or two_plus for more.   - \&quot;visa\&quot;:    ID Validate - One of:   - \&quot;idvalidate\&quot;: Checks to see if photo ID has had OCR scanning, ID document validation and photo comparison run against it. Can be used in conjunction with any of the KYC/ID/AML checks.    Manual Check:   - \&quot;manual\&quot;: (mKYC) Checks user has a sufficient amount of operator verified ID and will then \&quot;pass\&quot; all Entity and ID related checks.    Fraud Checks - One or more of:   - \&quot;fraudlist\&quot;: Checks to see if the identity appears on any known fraud lists. Should be run after KYC/ID checks have passed.   - \&quot;fraudcheck\&quot;: Checks external ID services to see if details appear in fraud detection services (e.g. EmailAge or FraudNet)    PEP Checks - One of:   - \&quot;pep\&quot;: Will only run PEP/Sanctions checks (no identity verification)   - \&quot;pep_media\&quot;: Will run PEP/Sanctions checks, as well as watchlist and adverse media checks. (no identity verification)      * NOTE: These checks will ONLY run if either the KYC/ID checks have been run prior, or it is the only check requested.    Custom:   - By arrangement with Frankie you can define your own KYC check type.      This will allow you to set the minimum number of matches for:     - name      - date of birth     - address     - government id      This allows for alternatives to the \&quot;standard\&quot; two_plus or one_plus (note, these can be overridden too).  (required)
     * @param resultLevel How much detail we return.   Acceptable values are:   * simple - Only available with \&quot;profile\&quot; check type. Returns just an EntityProfileResultObject (which is also included for \&quot;profile\&quot; checks at the other result levels), and a CheckEntityCheckResultObjectEntityResult with just the entity details but no separate results.   * summary   * full - You need to have your account configured for this.  (required)
     * @param entityDetails The entity to be checked (required)
     * @param xFrankieCustomerChildID If, as a Frankie Customer, you are acting on behalf of your own customers, then you can populate this field with a Frankie-assigned ID.  Note: If using a CustomerChildID, you will also need a separate api_key for each child.  Any documents, checks, entities that are created when this field has been populated will now be tied to this CustomerID + CustomerChildID combination. Just as Customers cannot see data created by other Customers, so too a Customer&#39;s Children will not be able to see each other&#39;s data.  A Customer can see the documents/entities and checks of all their Children.  (optional)
     * @param xFrankieBackground If this header parameter is supplied and set to 1, then the request will not wait for the process to finish, and will return a 202 if there are no obvious errors in the input. The request will then run in the background and send a notification back to the customer. See out callback API for details on this.  See more details here:   https://apidocs.frankiefinancial.com/docs/asynchronous-calls-backgrounding-processes  (optional)
     * @param force Force the verification to run, overriding any data aging or past check  (optional)
     * @param noInvalidate Disable check result invalidation for this update request.  (optional)
     * @return ApiResponse&lt;CheckEntityCheckResultObject&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> The request was valid and able to be processed in some fashion. Results may or may not be successful, but it was completed as far as practical with no actual errors. Returns the entity object as it stands now. No docScan file data from any attached ID documents will be returned unless the /full variant is requested. </td><td>  -  </td></tr>
        <tr><td> 202 </td><td> The request was valid and can potentially be fulfilled. The Frankie service has now accepted responsibility for processing and we will either push the results to you, or send you a notification, depending on the request and your configuration. </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad request. One or more request fields is either missing or incorrect. Details are in the error response. </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> The request has failed an authorisation check. This can happen for a variety of reasons, such as an invalid or expired API key, or invalid Customer/CustomerChildIDs.  * NOTE: This does not include attempts to read/write data you don&#39;t have access to - that&#39;s a 404 error (as we don&#39;t want to leak information through guessing)  </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Cannot return response. In the case of a query, or reference to a specific entity/check/etc, it means that the requested item was not found, or you don&#39;t have access to it. Please check your query before trying again. </td><td>  -  </td></tr>
        <tr><td> 405 </td><td> A request to POST an update to an object was not allowed due to it&#39;s state. This may indicate an already completed check, or a document that has been processed. You need to create a new document/check if you wish to update the object in question. </td><td>  -  </td></tr>
        <tr><td> 415 </td><td> For requests with payloads, an unsupported Content-Type was specified. The Frankie Financial API only supports a content type of application/json. </td><td>  -  </td></tr>
        <tr><td> 422 </td><td> Unprocessable request. This can be triggered in a number of ways. * An attempt to force a check or scan to run, but there is insufficient data to be able to do so. * An attempt to run a utility comparison, or similar industry/document/entity specific scan or process on an unsupported document type (e.g. electricity comparison on a passport) Details of what is required will be in the issues list of the error response.  </td><td>  -  </td></tr>
        <tr><td> 429 </td><td> The API client is making too many concurrent requests, and some are being throttled. Throttled requests can be retried after a short delay. </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Unexpected error. Something went wrong during the checking process. </td><td>  -  </td></tr>
        <tr><td> 503 </td><td> All of the ID sources configured by the customer are unavailable, or there is no available document processor. </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<CheckEntityCheckResultObject> updateCheckEntityWithHttpInfo(UUID xFrankieCustomerID, UUID entityId, String checkType, String resultLevel, EntityCheckDetailsObject entityDetails, UUID xFrankieCustomerChildID, Integer xFrankieBackground, Boolean force, Boolean noInvalidate) throws ApiException {
        okhttp3.Call localVarCall = updateCheckEntityValidateBeforeCall(xFrankieCustomerID, entityId, checkType, resultLevel, entityDetails, xFrankieCustomerChildID, xFrankieBackground, force, noInvalidate, null);
        Type localVarReturnType = new TypeToken<CheckEntityCheckResultObject>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Update Entity and Verify Details (asynchronously)
     * Take the details and documents provided in the entity, and set about verifying them all. So for example, you might extract:  * The name from the entity.name object * The address from the entity.address object * The DoB..  All documents that are presently attached to the entity will also be verified (if requested)  You can also specify the level of detail returned using the resultLevel parameter. You can choose \&quot;summary\&quot; or \&quot;full\&quot;. For the \&quot;profile\&quot; check type you can also select \&quot;simple\&quot; to only get the entity profile result.  SPECIAL NOTE: A \&quot;Full\&quot; response includes details of all checks and how they map against each element, along with all the details of pep/sanctions/etc checks too.  Your account also needs to be configured to support a full response too (talk to your account manager for more information). If you&#39;re not configured for full responses, we&#39;ll only return summary level data regardless. 
     * @param xFrankieCustomerID Customer ID issued by Frankie Financial. This will never change. Your API key, which is mapped to this identity, will change over time.  (required)
     * @param entityId The entityId returned previously from an earlier call to /check or /entity (required)
     * @param checkType When creating a new check, you need to define the checks you wish to run.    The checkType is make up of a comma separated list of the types of check you wish to run. The order of the requested checks is not important, they will be re-ordered by the service and in some cases, depending on your account configuration, may be skipped.    The validation that is performed on the requested checks is to:   - ensure the check type is known   - is suitable for the type of entity (no KYC for organisations)   - disallow manual (mKYC) check with any other kind of KYC   - disallow mixing the \&quot;profile\&quot; check with any other kind of check.  The supported check types are:  Profile:   - \&quot;profile\&quot;: By arrangement with Frankie we will create a \&quot;profile\&quot; check type that applies checks according to a recipe that you assign to the entity from a predefined set of profiles.      The profile to use will be taken from the entity.entityProfile field if set, or be run through a set of configurable rules to determine which one to use.      Profiles provide a pre-defined combination of individual checkTypes (see the list below). But they offer a lot more besides, including rules for determining default settings, inbuilt data aging and other configurable features.   They also allow for a new result set top be returned that provides a more detailed and useful breakdown of the check/verification process.      Entity Profiles are a recent feature (since v1.4.0) but are now the default checkType to use with Frankie Financial.  **Individual Check Types**  Whilst we strongly recommend the use of the \&quot;profile\&quot; checktype, it does map of any combination of the types below. If you wish to use these individually, please contact developer support for more details on how to use these effectively.  Entity Checks - One of:   - \&quot;one_plus\&quot;: Checks name, address and DoB against a minimum of 1 data source. (also known as a 1+1)   - \&quot;two_plus\&quot;: Checks name, address and DoB against a minimum of 2 independent data sources (also known as a 2+2)  ID Checks - One of:   - \&quot;id\&quot;: Checks all of the identity documents, but not necessarily the entity itself independently. Use this in conjunction with a one_plus or two_plus for more.   - \&quot;visa\&quot;:    ID Validate - One of:   - \&quot;idvalidate\&quot;: Checks to see if photo ID has had OCR scanning, ID document validation and photo comparison run against it. Can be used in conjunction with any of the KYC/ID/AML checks.    Manual Check:   - \&quot;manual\&quot;: (mKYC) Checks user has a sufficient amount of operator verified ID and will then \&quot;pass\&quot; all Entity and ID related checks.    Fraud Checks - One or more of:   - \&quot;fraudlist\&quot;: Checks to see if the identity appears on any known fraud lists. Should be run after KYC/ID checks have passed.   - \&quot;fraudcheck\&quot;: Checks external ID services to see if details appear in fraud detection services (e.g. EmailAge or FraudNet)    PEP Checks - One of:   - \&quot;pep\&quot;: Will only run PEP/Sanctions checks (no identity verification)   - \&quot;pep_media\&quot;: Will run PEP/Sanctions checks, as well as watchlist and adverse media checks. (no identity verification)      * NOTE: These checks will ONLY run if either the KYC/ID checks have been run prior, or it is the only check requested.    Custom:   - By arrangement with Frankie you can define your own KYC check type.      This will allow you to set the minimum number of matches for:     - name      - date of birth     - address     - government id      This allows for alternatives to the \&quot;standard\&quot; two_plus or one_plus (note, these can be overridden too).  (required)
     * @param resultLevel How much detail we return.   Acceptable values are:   * simple - Only available with \&quot;profile\&quot; check type. Returns just an EntityProfileResultObject (which is also included for \&quot;profile\&quot; checks at the other result levels), and a CheckEntityCheckResultObjectEntityResult with just the entity details but no separate results.   * summary   * full - You need to have your account configured for this.  (required)
     * @param entityDetails The entity to be checked (required)
     * @param xFrankieCustomerChildID If, as a Frankie Customer, you are acting on behalf of your own customers, then you can populate this field with a Frankie-assigned ID.  Note: If using a CustomerChildID, you will also need a separate api_key for each child.  Any documents, checks, entities that are created when this field has been populated will now be tied to this CustomerID + CustomerChildID combination. Just as Customers cannot see data created by other Customers, so too a Customer&#39;s Children will not be able to see each other&#39;s data.  A Customer can see the documents/entities and checks of all their Children.  (optional)
     * @param xFrankieBackground If this header parameter is supplied and set to 1, then the request will not wait for the process to finish, and will return a 202 if there are no obvious errors in the input. The request will then run in the background and send a notification back to the customer. See out callback API for details on this.  See more details here:   https://apidocs.frankiefinancial.com/docs/asynchronous-calls-backgrounding-processes  (optional)
     * @param force Force the verification to run, overriding any data aging or past check  (optional)
     * @param noInvalidate Disable check result invalidation for this update request.  (optional)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> The request was valid and able to be processed in some fashion. Results may or may not be successful, but it was completed as far as practical with no actual errors. Returns the entity object as it stands now. No docScan file data from any attached ID documents will be returned unless the /full variant is requested. </td><td>  -  </td></tr>
        <tr><td> 202 </td><td> The request was valid and can potentially be fulfilled. The Frankie service has now accepted responsibility for processing and we will either push the results to you, or send you a notification, depending on the request and your configuration. </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad request. One or more request fields is either missing or incorrect. Details are in the error response. </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> The request has failed an authorisation check. This can happen for a variety of reasons, such as an invalid or expired API key, or invalid Customer/CustomerChildIDs.  * NOTE: This does not include attempts to read/write data you don&#39;t have access to - that&#39;s a 404 error (as we don&#39;t want to leak information through guessing)  </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Cannot return response. In the case of a query, or reference to a specific entity/check/etc, it means that the requested item was not found, or you don&#39;t have access to it. Please check your query before trying again. </td><td>  -  </td></tr>
        <tr><td> 405 </td><td> A request to POST an update to an object was not allowed due to it&#39;s state. This may indicate an already completed check, or a document that has been processed. You need to create a new document/check if you wish to update the object in question. </td><td>  -  </td></tr>
        <tr><td> 415 </td><td> For requests with payloads, an unsupported Content-Type was specified. The Frankie Financial API only supports a content type of application/json. </td><td>  -  </td></tr>
        <tr><td> 422 </td><td> Unprocessable request. This can be triggered in a number of ways. * An attempt to force a check or scan to run, but there is insufficient data to be able to do so. * An attempt to run a utility comparison, or similar industry/document/entity specific scan or process on an unsupported document type (e.g. electricity comparison on a passport) Details of what is required will be in the issues list of the error response.  </td><td>  -  </td></tr>
        <tr><td> 429 </td><td> The API client is making too many concurrent requests, and some are being throttled. Throttled requests can be retried after a short delay. </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Unexpected error. Something went wrong during the checking process. </td><td>  -  </td></tr>
        <tr><td> 503 </td><td> All of the ID sources configured by the customer are unavailable, or there is no available document processor. </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call updateCheckEntityAsync(UUID xFrankieCustomerID, UUID entityId, String checkType, String resultLevel, EntityCheckDetailsObject entityDetails, UUID xFrankieCustomerChildID, Integer xFrankieBackground, Boolean force, Boolean noInvalidate, final ApiCallback<CheckEntityCheckResultObject> _callback) throws ApiException {

        okhttp3.Call localVarCall = updateCheckEntityValidateBeforeCall(xFrankieCustomerID, entityId, checkType, resultLevel, entityDetails, xFrankieCustomerChildID, xFrankieBackground, force, noInvalidate, _callback);
        Type localVarReturnType = new TypeToken<CheckEntityCheckResultObject>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for updateCheckEntityPushToMobile
     * @param xFrankieCustomerID Customer ID issued by Frankie Financial. This will never change. Your API key, which is mapped to this identity, will change over time.  (required)
     * @param entityId The entityId returned previously from an earlier call to /check or /entity (required)
     * @param entityDetails The entity and any associated / additional information to be checked (required)
     * @param xFrankieCustomerChildID If, as a Frankie Customer, you are acting on behalf of your own customers, then you can populate this field with a Frankie-assigned ID.  Note: If using a CustomerChildID, you will also need a separate api_key for each child.  Any documents, checks, entities that are created when this field has been populated will now be tied to this CustomerID + CustomerChildID combination. Just as Customers cannot see data created by other Customers, so too a Customer&#39;s Children will not be able to see each other&#39;s data.  A Customer can see the documents/entities and checks of all their Children.  (optional)
     * @param xFrankieBackground If this header parameter is supplied and set to 1, then the request will not wait for the process to finish, and will return a 202 if there are no obvious errors in the input. The request will then run in the background and send a notification back to the customer. See out callback API for details on this.  See more details here:   https://apidocs.frankiefinancial.com/docs/asynchronous-calls-backgrounding-processes  (optional)
     * @param nopush If set to true, then no SMS/email will be pushed. It will be up to the API caller to manage the delivery of the link.  (optional)
     * @param phase Set the Push To Mobile phase.  Currently supported values: - 2  (optional)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 202 </td><td> The request was valid and can potentially be fulfilled. The Frankie service has now accepted responsibility for processing and we will either push the results to you, or send you a notification, depending on the request and your configuration. </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad request. One or more request fields is either missing or incorrect. Details are in the error response. </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> The request has failed an authorisation check. This can happen for a variety of reasons, such as an invalid or expired API key, or invalid Customer/CustomerChildIDs.  * NOTE: This does not include attempts to read/write data you don&#39;t have access to - that&#39;s a 404 error (as we don&#39;t want to leak information through guessing)  </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Cannot return response. In the case of a query, or reference to a specific entity/check/etc, it means that the requested item was not found, or you don&#39;t have access to it. Please check your query before trying again. </td><td>  -  </td></tr>
        <tr><td> 405 </td><td> A request to POST an update to an object was not allowed due to it&#39;s state. This may indicate an already completed check, or a document that has been processed. You need to create a new document/check if you wish to update the object in question. </td><td>  -  </td></tr>
        <tr><td> 415 </td><td> For requests with payloads, an unsupported Content-Type was specified. The Frankie Financial API only supports a content type of application/json. </td><td>  -  </td></tr>
        <tr><td> 422 </td><td> Unprocessable request. This can be triggered in a number of ways. * An attempt to force a check or scan to run, but there is insufficient data to be able to do so. * An attempt to run a utility comparison, or similar industry/document/entity specific scan or process on an unsupported document type (e.g. electricity comparison on a passport) Details of what is required will be in the issues list of the error response.  </td><td>  -  </td></tr>
        <tr><td> 429 </td><td> The API client is making too many concurrent requests, and some are being throttled. Throttled requests can be retried after a short delay. </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Unexpected error. Something went wrong during the checking process. </td><td>  -  </td></tr>
        <tr><td> 503 </td><td> All of the ID sources configured by the customer are unavailable, or there is no available document processor. </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call updateCheckEntityPushToMobileCall(UUID xFrankieCustomerID, UUID entityId, EntityCheckDetailsObject entityDetails, UUID xFrankieCustomerChildID, Integer xFrankieBackground, Boolean nopush, Integer phase, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = entityDetails;

        // create path and map variables
        String localVarPath = "/entity/{entityId}/verify/pushToMobile"
            .replace("{" + "entityId" + "}", localVarApiClient.escapeString(entityId.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (nopush != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("nopush", nopush));
        }

        if (phase != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("phase", phase));
        }

        if (xFrankieCustomerID != null) {
            localVarHeaderParams.put("X-Frankie-CustomerID", localVarApiClient.parameterToString(xFrankieCustomerID));
        }

        if (xFrankieCustomerChildID != null) {
            localVarHeaderParams.put("X-Frankie-CustomerChildID", localVarApiClient.parameterToString(xFrankieCustomerChildID));
        }

        if (xFrankieBackground != null) {
            localVarHeaderParams.put("X-Frankie-Background", localVarApiClient.parameterToString(xFrankieBackground));
        }

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            "application/json"
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "api_key" };
        return localVarApiClient.buildCall(basePath, localVarPath, "POST", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call updateCheckEntityPushToMobileValidateBeforeCall(UUID xFrankieCustomerID, UUID entityId, EntityCheckDetailsObject entityDetails, UUID xFrankieCustomerChildID, Integer xFrankieBackground, Boolean nopush, Integer phase, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'xFrankieCustomerID' is set
        if (xFrankieCustomerID == null) {
            throw new ApiException("Missing the required parameter 'xFrankieCustomerID' when calling updateCheckEntityPushToMobile(Async)");
        }

        // verify the required parameter 'entityId' is set
        if (entityId == null) {
            throw new ApiException("Missing the required parameter 'entityId' when calling updateCheckEntityPushToMobile(Async)");
        }

        // verify the required parameter 'entityDetails' is set
        if (entityDetails == null) {
            throw new ApiException("Missing the required parameter 'entityDetails' when calling updateCheckEntityPushToMobile(Async)");
        }

        return updateCheckEntityPushToMobileCall(xFrankieCustomerID, entityId, entityDetails, xFrankieCustomerChildID, xFrankieBackground, nopush, phase, _callback);

    }

    /**
     * Update Entity and Push Self-Verification Link
     * Update an existing entity object and begin the process of verification after pushing a message to a mobile number.  The entity will receive a link on their mobile and will then be guided through a series of steps to capture and OCR scan their ID, and perform a selfie comparison. We&#39;ll then attempt to verify the data received and push a notification back to the calling customer.  At a minimum, you will need to supply the name and a MOBILE_PHONE document type.         If you wish to skip the detail capture and jump straight to the ID and selfie capture, the append the call with the ?phase&#x3D;2 parameter.   SPECIAL NOTE: This will only ever return a 202 response if successfully accepted. You will need to ensure your account is configured for push notifications. Contact developer supprt to arrange this. 
     * @param xFrankieCustomerID Customer ID issued by Frankie Financial. This will never change. Your API key, which is mapped to this identity, will change over time.  (required)
     * @param entityId The entityId returned previously from an earlier call to /check or /entity (required)
     * @param entityDetails The entity and any associated / additional information to be checked (required)
     * @param xFrankieCustomerChildID If, as a Frankie Customer, you are acting on behalf of your own customers, then you can populate this field with a Frankie-assigned ID.  Note: If using a CustomerChildID, you will also need a separate api_key for each child.  Any documents, checks, entities that are created when this field has been populated will now be tied to this CustomerID + CustomerChildID combination. Just as Customers cannot see data created by other Customers, so too a Customer&#39;s Children will not be able to see each other&#39;s data.  A Customer can see the documents/entities and checks of all their Children.  (optional)
     * @param xFrankieBackground If this header parameter is supplied and set to 1, then the request will not wait for the process to finish, and will return a 202 if there are no obvious errors in the input. The request will then run in the background and send a notification back to the customer. See out callback API for details on this.  See more details here:   https://apidocs.frankiefinancial.com/docs/asynchronous-calls-backgrounding-processes  (optional)
     * @param nopush If set to true, then no SMS/email will be pushed. It will be up to the API caller to manage the delivery of the link.  (optional)
     * @param phase Set the Push To Mobile phase.  Currently supported values: - 2  (optional)
     * @return AcceptedEntityResultObject
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 202 </td><td> The request was valid and can potentially be fulfilled. The Frankie service has now accepted responsibility for processing and we will either push the results to you, or send you a notification, depending on the request and your configuration. </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad request. One or more request fields is either missing or incorrect. Details are in the error response. </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> The request has failed an authorisation check. This can happen for a variety of reasons, such as an invalid or expired API key, or invalid Customer/CustomerChildIDs.  * NOTE: This does not include attempts to read/write data you don&#39;t have access to - that&#39;s a 404 error (as we don&#39;t want to leak information through guessing)  </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Cannot return response. In the case of a query, or reference to a specific entity/check/etc, it means that the requested item was not found, or you don&#39;t have access to it. Please check your query before trying again. </td><td>  -  </td></tr>
        <tr><td> 405 </td><td> A request to POST an update to an object was not allowed due to it&#39;s state. This may indicate an already completed check, or a document that has been processed. You need to create a new document/check if you wish to update the object in question. </td><td>  -  </td></tr>
        <tr><td> 415 </td><td> For requests with payloads, an unsupported Content-Type was specified. The Frankie Financial API only supports a content type of application/json. </td><td>  -  </td></tr>
        <tr><td> 422 </td><td> Unprocessable request. This can be triggered in a number of ways. * An attempt to force a check or scan to run, but there is insufficient data to be able to do so. * An attempt to run a utility comparison, or similar industry/document/entity specific scan or process on an unsupported document type (e.g. electricity comparison on a passport) Details of what is required will be in the issues list of the error response.  </td><td>  -  </td></tr>
        <tr><td> 429 </td><td> The API client is making too many concurrent requests, and some are being throttled. Throttled requests can be retried after a short delay. </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Unexpected error. Something went wrong during the checking process. </td><td>  -  </td></tr>
        <tr><td> 503 </td><td> All of the ID sources configured by the customer are unavailable, or there is no available document processor. </td><td>  -  </td></tr>
     </table>
     */
    public AcceptedEntityResultObject updateCheckEntityPushToMobile(UUID xFrankieCustomerID, UUID entityId, EntityCheckDetailsObject entityDetails, UUID xFrankieCustomerChildID, Integer xFrankieBackground, Boolean nopush, Integer phase) throws ApiException {
        ApiResponse<AcceptedEntityResultObject> localVarResp = updateCheckEntityPushToMobileWithHttpInfo(xFrankieCustomerID, entityId, entityDetails, xFrankieCustomerChildID, xFrankieBackground, nopush, phase);
        return localVarResp.getData();
    }

    /**
     * Update Entity and Push Self-Verification Link
     * Update an existing entity object and begin the process of verification after pushing a message to a mobile number.  The entity will receive a link on their mobile and will then be guided through a series of steps to capture and OCR scan their ID, and perform a selfie comparison. We&#39;ll then attempt to verify the data received and push a notification back to the calling customer.  At a minimum, you will need to supply the name and a MOBILE_PHONE document type.         If you wish to skip the detail capture and jump straight to the ID and selfie capture, the append the call with the ?phase&#x3D;2 parameter.   SPECIAL NOTE: This will only ever return a 202 response if successfully accepted. You will need to ensure your account is configured for push notifications. Contact developer supprt to arrange this. 
     * @param xFrankieCustomerID Customer ID issued by Frankie Financial. This will never change. Your API key, which is mapped to this identity, will change over time.  (required)
     * @param entityId The entityId returned previously from an earlier call to /check or /entity (required)
     * @param entityDetails The entity and any associated / additional information to be checked (required)
     * @param xFrankieCustomerChildID If, as a Frankie Customer, you are acting on behalf of your own customers, then you can populate this field with a Frankie-assigned ID.  Note: If using a CustomerChildID, you will also need a separate api_key for each child.  Any documents, checks, entities that are created when this field has been populated will now be tied to this CustomerID + CustomerChildID combination. Just as Customers cannot see data created by other Customers, so too a Customer&#39;s Children will not be able to see each other&#39;s data.  A Customer can see the documents/entities and checks of all their Children.  (optional)
     * @param xFrankieBackground If this header parameter is supplied and set to 1, then the request will not wait for the process to finish, and will return a 202 if there are no obvious errors in the input. The request will then run in the background and send a notification back to the customer. See out callback API for details on this.  See more details here:   https://apidocs.frankiefinancial.com/docs/asynchronous-calls-backgrounding-processes  (optional)
     * @param nopush If set to true, then no SMS/email will be pushed. It will be up to the API caller to manage the delivery of the link.  (optional)
     * @param phase Set the Push To Mobile phase.  Currently supported values: - 2  (optional)
     * @return ApiResponse&lt;AcceptedEntityResultObject&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 202 </td><td> The request was valid and can potentially be fulfilled. The Frankie service has now accepted responsibility for processing and we will either push the results to you, or send you a notification, depending on the request and your configuration. </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad request. One or more request fields is either missing or incorrect. Details are in the error response. </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> The request has failed an authorisation check. This can happen for a variety of reasons, such as an invalid or expired API key, or invalid Customer/CustomerChildIDs.  * NOTE: This does not include attempts to read/write data you don&#39;t have access to - that&#39;s a 404 error (as we don&#39;t want to leak information through guessing)  </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Cannot return response. In the case of a query, or reference to a specific entity/check/etc, it means that the requested item was not found, or you don&#39;t have access to it. Please check your query before trying again. </td><td>  -  </td></tr>
        <tr><td> 405 </td><td> A request to POST an update to an object was not allowed due to it&#39;s state. This may indicate an already completed check, or a document that has been processed. You need to create a new document/check if you wish to update the object in question. </td><td>  -  </td></tr>
        <tr><td> 415 </td><td> For requests with payloads, an unsupported Content-Type was specified. The Frankie Financial API only supports a content type of application/json. </td><td>  -  </td></tr>
        <tr><td> 422 </td><td> Unprocessable request. This can be triggered in a number of ways. * An attempt to force a check or scan to run, but there is insufficient data to be able to do so. * An attempt to run a utility comparison, or similar industry/document/entity specific scan or process on an unsupported document type (e.g. electricity comparison on a passport) Details of what is required will be in the issues list of the error response.  </td><td>  -  </td></tr>
        <tr><td> 429 </td><td> The API client is making too many concurrent requests, and some are being throttled. Throttled requests can be retried after a short delay. </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Unexpected error. Something went wrong during the checking process. </td><td>  -  </td></tr>
        <tr><td> 503 </td><td> All of the ID sources configured by the customer are unavailable, or there is no available document processor. </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<AcceptedEntityResultObject> updateCheckEntityPushToMobileWithHttpInfo(UUID xFrankieCustomerID, UUID entityId, EntityCheckDetailsObject entityDetails, UUID xFrankieCustomerChildID, Integer xFrankieBackground, Boolean nopush, Integer phase) throws ApiException {
        okhttp3.Call localVarCall = updateCheckEntityPushToMobileValidateBeforeCall(xFrankieCustomerID, entityId, entityDetails, xFrankieCustomerChildID, xFrankieBackground, nopush, phase, null);
        Type localVarReturnType = new TypeToken<AcceptedEntityResultObject>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Update Entity and Push Self-Verification Link (asynchronously)
     * Update an existing entity object and begin the process of verification after pushing a message to a mobile number.  The entity will receive a link on their mobile and will then be guided through a series of steps to capture and OCR scan their ID, and perform a selfie comparison. We&#39;ll then attempt to verify the data received and push a notification back to the calling customer.  At a minimum, you will need to supply the name and a MOBILE_PHONE document type.         If you wish to skip the detail capture and jump straight to the ID and selfie capture, the append the call with the ?phase&#x3D;2 parameter.   SPECIAL NOTE: This will only ever return a 202 response if successfully accepted. You will need to ensure your account is configured for push notifications. Contact developer supprt to arrange this. 
     * @param xFrankieCustomerID Customer ID issued by Frankie Financial. This will never change. Your API key, which is mapped to this identity, will change over time.  (required)
     * @param entityId The entityId returned previously from an earlier call to /check or /entity (required)
     * @param entityDetails The entity and any associated / additional information to be checked (required)
     * @param xFrankieCustomerChildID If, as a Frankie Customer, you are acting on behalf of your own customers, then you can populate this field with a Frankie-assigned ID.  Note: If using a CustomerChildID, you will also need a separate api_key for each child.  Any documents, checks, entities that are created when this field has been populated will now be tied to this CustomerID + CustomerChildID combination. Just as Customers cannot see data created by other Customers, so too a Customer&#39;s Children will not be able to see each other&#39;s data.  A Customer can see the documents/entities and checks of all their Children.  (optional)
     * @param xFrankieBackground If this header parameter is supplied and set to 1, then the request will not wait for the process to finish, and will return a 202 if there are no obvious errors in the input. The request will then run in the background and send a notification back to the customer. See out callback API for details on this.  See more details here:   https://apidocs.frankiefinancial.com/docs/asynchronous-calls-backgrounding-processes  (optional)
     * @param nopush If set to true, then no SMS/email will be pushed. It will be up to the API caller to manage the delivery of the link.  (optional)
     * @param phase Set the Push To Mobile phase.  Currently supported values: - 2  (optional)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 202 </td><td> The request was valid and can potentially be fulfilled. The Frankie service has now accepted responsibility for processing and we will either push the results to you, or send you a notification, depending on the request and your configuration. </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad request. One or more request fields is either missing or incorrect. Details are in the error response. </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> The request has failed an authorisation check. This can happen for a variety of reasons, such as an invalid or expired API key, or invalid Customer/CustomerChildIDs.  * NOTE: This does not include attempts to read/write data you don&#39;t have access to - that&#39;s a 404 error (as we don&#39;t want to leak information through guessing)  </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Cannot return response. In the case of a query, or reference to a specific entity/check/etc, it means that the requested item was not found, or you don&#39;t have access to it. Please check your query before trying again. </td><td>  -  </td></tr>
        <tr><td> 405 </td><td> A request to POST an update to an object was not allowed due to it&#39;s state. This may indicate an already completed check, or a document that has been processed. You need to create a new document/check if you wish to update the object in question. </td><td>  -  </td></tr>
        <tr><td> 415 </td><td> For requests with payloads, an unsupported Content-Type was specified. The Frankie Financial API only supports a content type of application/json. </td><td>  -  </td></tr>
        <tr><td> 422 </td><td> Unprocessable request. This can be triggered in a number of ways. * An attempt to force a check or scan to run, but there is insufficient data to be able to do so. * An attempt to run a utility comparison, or similar industry/document/entity specific scan or process on an unsupported document type (e.g. electricity comparison on a passport) Details of what is required will be in the issues list of the error response.  </td><td>  -  </td></tr>
        <tr><td> 429 </td><td> The API client is making too many concurrent requests, and some are being throttled. Throttled requests can be retried after a short delay. </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Unexpected error. Something went wrong during the checking process. </td><td>  -  </td></tr>
        <tr><td> 503 </td><td> All of the ID sources configured by the customer are unavailable, or there is no available document processor. </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call updateCheckEntityPushToMobileAsync(UUID xFrankieCustomerID, UUID entityId, EntityCheckDetailsObject entityDetails, UUID xFrankieCustomerChildID, Integer xFrankieBackground, Boolean nopush, Integer phase, final ApiCallback<AcceptedEntityResultObject> _callback) throws ApiException {

        okhttp3.Call localVarCall = updateCheckEntityPushToMobileValidateBeforeCall(xFrankieCustomerID, entityId, entityDetails, xFrankieCustomerChildID, xFrankieBackground, nopush, phase, _callback);
        Type localVarReturnType = new TypeToken<AcceptedEntityResultObject>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for updateEntity
     * @param xFrankieCustomerID Customer ID issued by Frankie Financial. This will never change. Your API key, which is mapped to this identity, will change over time.  (required)
     * @param entityId The entityId returned previously from an earlier call to /check or /entity (required)
     * @param entity The entity to be updated (required)
     * @param xFrankieCustomerChildID If, as a Frankie Customer, you are acting on behalf of your own customers, then you can populate this field with a Frankie-assigned ID.  Note: If using a CustomerChildID, you will also need a separate api_key for each child.  Any documents, checks, entities that are created when this field has been populated will now be tied to this CustomerID + CustomerChildID combination. Just as Customers cannot see data created by other Customers, so too a Customer&#39;s Children will not be able to see each other&#39;s data.  A Customer can see the documents/entities and checks of all their Children.  (optional)
     * @param xFrankieBackground If this header parameter is supplied and set to 1, then the request will not wait for the process to finish, and will return a 202 if there are no obvious errors in the input. The request will then run in the background and send a notification back to the customer. See out callback API for details on this.  See more details here:   https://apidocs.frankiefinancial.com/docs/asynchronous-calls-backgrounding-processes  (optional)
     * @param noInvalidate Disable check result invalidation for this update request.  (optional)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> The request was valid and able to be processed in some fashion. Results may or may not be successful, but it was completed as far as practical with no actual errors. Returns the entity object as it stands now. No docScan file data from any attached ID documents will be returned unless the /full variant is requested. </td><td>  -  </td></tr>
        <tr><td> 202 </td><td> The request was valid and can potentially be fulfilled. The Frankie service has now accepted responsibility for processing and we will either push the results to you, or send you a notification, depending on the request and your configuration. </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad request. One or more request fields is either missing or incorrect. Details are in the error response. </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> The request has failed an authorisation check. This can happen for a variety of reasons, such as an invalid or expired API key, or invalid Customer/CustomerChildIDs.  * NOTE: This does not include attempts to read/write data you don&#39;t have access to - that&#39;s a 404 error (as we don&#39;t want to leak information through guessing)  </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Cannot return response. In the case of a query, or reference to a specific entity/check/etc, it means that the requested item was not found, or you don&#39;t have access to it. Please check your query before trying again. </td><td>  -  </td></tr>
        <tr><td> 405 </td><td> A request to POST an update to an object was not allowed due to it&#39;s state. This may indicate an already completed check, or a document that has been processed. You need to create a new document/check if you wish to update the object in question. </td><td>  -  </td></tr>
        <tr><td> 415 </td><td> For requests with payloads, an unsupported Content-Type was specified. The Frankie Financial API only supports a content type of application/json. </td><td>  -  </td></tr>
        <tr><td> 422 </td><td> Unprocessable request. This can be triggered in a number of ways. * An attempt to force a check or scan to run, but there is insufficient data to be able to do so. * An attempt to run a utility comparison, or similar industry/document/entity specific scan or process on an unsupported document type (e.g. electricity comparison on a passport) Details of what is required will be in the issues list of the error response.  </td><td>  -  </td></tr>
        <tr><td> 429 </td><td> The API client is making too many concurrent requests, and some are being throttled. Throttled requests can be retried after a short delay. </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Unexpected error. Something went wrong during the checking process. </td><td>  -  </td></tr>
        <tr><td> 503 </td><td> All of the ID sources configured by the customer are unavailable, or there is no available document processor. </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call updateEntityCall(UUID xFrankieCustomerID, UUID entityId, EntityObject entity, UUID xFrankieCustomerChildID, Integer xFrankieBackground, Boolean noInvalidate, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = entity;

        // create path and map variables
        String localVarPath = "/entity/{entityId}"
            .replace("{" + "entityId" + "}", localVarApiClient.escapeString(entityId.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (noInvalidate != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("noInvalidate", noInvalidate));
        }

        if (xFrankieCustomerID != null) {
            localVarHeaderParams.put("X-Frankie-CustomerID", localVarApiClient.parameterToString(xFrankieCustomerID));
        }

        if (xFrankieCustomerChildID != null) {
            localVarHeaderParams.put("X-Frankie-CustomerChildID", localVarApiClient.parameterToString(xFrankieCustomerChildID));
        }

        if (xFrankieBackground != null) {
            localVarHeaderParams.put("X-Frankie-Background", localVarApiClient.parameterToString(xFrankieBackground));
        }

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            "application/json"
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "api_key" };
        return localVarApiClient.buildCall(basePath, localVarPath, "POST", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call updateEntityValidateBeforeCall(UUID xFrankieCustomerID, UUID entityId, EntityObject entity, UUID xFrankieCustomerChildID, Integer xFrankieBackground, Boolean noInvalidate, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'xFrankieCustomerID' is set
        if (xFrankieCustomerID == null) {
            throw new ApiException("Missing the required parameter 'xFrankieCustomerID' when calling updateEntity(Async)");
        }

        // verify the required parameter 'entityId' is set
        if (entityId == null) {
            throw new ApiException("Missing the required parameter 'entityId' when calling updateEntity(Async)");
        }

        // verify the required parameter 'entity' is set
        if (entity == null) {
            throw new ApiException("Missing the required parameter 'entity' when calling updateEntity(Async)");
        }

        return updateEntityCall(xFrankieCustomerID, entityId, entity, xFrankieCustomerChildID, xFrankieBackground, noInvalidate, _callback);

    }

    /**
     * Update Existing Entity.
     * Using a previously uploaded but incomplete Entity, you can optionally supply updated details (such as corrections on a previous address), along with one or more additional ID docs/scans (e.g. new documents to parse, etc). 
     * @param xFrankieCustomerID Customer ID issued by Frankie Financial. This will never change. Your API key, which is mapped to this identity, will change over time.  (required)
     * @param entityId The entityId returned previously from an earlier call to /check or /entity (required)
     * @param entity The entity to be updated (required)
     * @param xFrankieCustomerChildID If, as a Frankie Customer, you are acting on behalf of your own customers, then you can populate this field with a Frankie-assigned ID.  Note: If using a CustomerChildID, you will also need a separate api_key for each child.  Any documents, checks, entities that are created when this field has been populated will now be tied to this CustomerID + CustomerChildID combination. Just as Customers cannot see data created by other Customers, so too a Customer&#39;s Children will not be able to see each other&#39;s data.  A Customer can see the documents/entities and checks of all their Children.  (optional)
     * @param xFrankieBackground If this header parameter is supplied and set to 1, then the request will not wait for the process to finish, and will return a 202 if there are no obvious errors in the input. The request will then run in the background and send a notification back to the customer. See out callback API for details on this.  See more details here:   https://apidocs.frankiefinancial.com/docs/asynchronous-calls-backgrounding-processes  (optional)
     * @param noInvalidate Disable check result invalidation for this update request.  (optional)
     * @return EntityResultObject
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> The request was valid and able to be processed in some fashion. Results may or may not be successful, but it was completed as far as practical with no actual errors. Returns the entity object as it stands now. No docScan file data from any attached ID documents will be returned unless the /full variant is requested. </td><td>  -  </td></tr>
        <tr><td> 202 </td><td> The request was valid and can potentially be fulfilled. The Frankie service has now accepted responsibility for processing and we will either push the results to you, or send you a notification, depending on the request and your configuration. </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad request. One or more request fields is either missing or incorrect. Details are in the error response. </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> The request has failed an authorisation check. This can happen for a variety of reasons, such as an invalid or expired API key, or invalid Customer/CustomerChildIDs.  * NOTE: This does not include attempts to read/write data you don&#39;t have access to - that&#39;s a 404 error (as we don&#39;t want to leak information through guessing)  </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Cannot return response. In the case of a query, or reference to a specific entity/check/etc, it means that the requested item was not found, or you don&#39;t have access to it. Please check your query before trying again. </td><td>  -  </td></tr>
        <tr><td> 405 </td><td> A request to POST an update to an object was not allowed due to it&#39;s state. This may indicate an already completed check, or a document that has been processed. You need to create a new document/check if you wish to update the object in question. </td><td>  -  </td></tr>
        <tr><td> 415 </td><td> For requests with payloads, an unsupported Content-Type was specified. The Frankie Financial API only supports a content type of application/json. </td><td>  -  </td></tr>
        <tr><td> 422 </td><td> Unprocessable request. This can be triggered in a number of ways. * An attempt to force a check or scan to run, but there is insufficient data to be able to do so. * An attempt to run a utility comparison, or similar industry/document/entity specific scan or process on an unsupported document type (e.g. electricity comparison on a passport) Details of what is required will be in the issues list of the error response.  </td><td>  -  </td></tr>
        <tr><td> 429 </td><td> The API client is making too many concurrent requests, and some are being throttled. Throttled requests can be retried after a short delay. </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Unexpected error. Something went wrong during the checking process. </td><td>  -  </td></tr>
        <tr><td> 503 </td><td> All of the ID sources configured by the customer are unavailable, or there is no available document processor. </td><td>  -  </td></tr>
     </table>
     */
    public EntityResultObject updateEntity(UUID xFrankieCustomerID, UUID entityId, EntityObject entity, UUID xFrankieCustomerChildID, Integer xFrankieBackground, Boolean noInvalidate) throws ApiException {
        ApiResponse<EntityResultObject> localVarResp = updateEntityWithHttpInfo(xFrankieCustomerID, entityId, entity, xFrankieCustomerChildID, xFrankieBackground, noInvalidate);
        return localVarResp.getData();
    }

    /**
     * Update Existing Entity.
     * Using a previously uploaded but incomplete Entity, you can optionally supply updated details (such as corrections on a previous address), along with one or more additional ID docs/scans (e.g. new documents to parse, etc). 
     * @param xFrankieCustomerID Customer ID issued by Frankie Financial. This will never change. Your API key, which is mapped to this identity, will change over time.  (required)
     * @param entityId The entityId returned previously from an earlier call to /check or /entity (required)
     * @param entity The entity to be updated (required)
     * @param xFrankieCustomerChildID If, as a Frankie Customer, you are acting on behalf of your own customers, then you can populate this field with a Frankie-assigned ID.  Note: If using a CustomerChildID, you will also need a separate api_key for each child.  Any documents, checks, entities that are created when this field has been populated will now be tied to this CustomerID + CustomerChildID combination. Just as Customers cannot see data created by other Customers, so too a Customer&#39;s Children will not be able to see each other&#39;s data.  A Customer can see the documents/entities and checks of all their Children.  (optional)
     * @param xFrankieBackground If this header parameter is supplied and set to 1, then the request will not wait for the process to finish, and will return a 202 if there are no obvious errors in the input. The request will then run in the background and send a notification back to the customer. See out callback API for details on this.  See more details here:   https://apidocs.frankiefinancial.com/docs/asynchronous-calls-backgrounding-processes  (optional)
     * @param noInvalidate Disable check result invalidation for this update request.  (optional)
     * @return ApiResponse&lt;EntityResultObject&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> The request was valid and able to be processed in some fashion. Results may or may not be successful, but it was completed as far as practical with no actual errors. Returns the entity object as it stands now. No docScan file data from any attached ID documents will be returned unless the /full variant is requested. </td><td>  -  </td></tr>
        <tr><td> 202 </td><td> The request was valid and can potentially be fulfilled. The Frankie service has now accepted responsibility for processing and we will either push the results to you, or send you a notification, depending on the request and your configuration. </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad request. One or more request fields is either missing or incorrect. Details are in the error response. </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> The request has failed an authorisation check. This can happen for a variety of reasons, such as an invalid or expired API key, or invalid Customer/CustomerChildIDs.  * NOTE: This does not include attempts to read/write data you don&#39;t have access to - that&#39;s a 404 error (as we don&#39;t want to leak information through guessing)  </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Cannot return response. In the case of a query, or reference to a specific entity/check/etc, it means that the requested item was not found, or you don&#39;t have access to it. Please check your query before trying again. </td><td>  -  </td></tr>
        <tr><td> 405 </td><td> A request to POST an update to an object was not allowed due to it&#39;s state. This may indicate an already completed check, or a document that has been processed. You need to create a new document/check if you wish to update the object in question. </td><td>  -  </td></tr>
        <tr><td> 415 </td><td> For requests with payloads, an unsupported Content-Type was specified. The Frankie Financial API only supports a content type of application/json. </td><td>  -  </td></tr>
        <tr><td> 422 </td><td> Unprocessable request. This can be triggered in a number of ways. * An attempt to force a check or scan to run, but there is insufficient data to be able to do so. * An attempt to run a utility comparison, or similar industry/document/entity specific scan or process on an unsupported document type (e.g. electricity comparison on a passport) Details of what is required will be in the issues list of the error response.  </td><td>  -  </td></tr>
        <tr><td> 429 </td><td> The API client is making too many concurrent requests, and some are being throttled. Throttled requests can be retried after a short delay. </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Unexpected error. Something went wrong during the checking process. </td><td>  -  </td></tr>
        <tr><td> 503 </td><td> All of the ID sources configured by the customer are unavailable, or there is no available document processor. </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<EntityResultObject> updateEntityWithHttpInfo(UUID xFrankieCustomerID, UUID entityId, EntityObject entity, UUID xFrankieCustomerChildID, Integer xFrankieBackground, Boolean noInvalidate) throws ApiException {
        okhttp3.Call localVarCall = updateEntityValidateBeforeCall(xFrankieCustomerID, entityId, entity, xFrankieCustomerChildID, xFrankieBackground, noInvalidate, null);
        Type localVarReturnType = new TypeToken<EntityResultObject>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Update Existing Entity. (asynchronously)
     * Using a previously uploaded but incomplete Entity, you can optionally supply updated details (such as corrections on a previous address), along with one or more additional ID docs/scans (e.g. new documents to parse, etc). 
     * @param xFrankieCustomerID Customer ID issued by Frankie Financial. This will never change. Your API key, which is mapped to this identity, will change over time.  (required)
     * @param entityId The entityId returned previously from an earlier call to /check or /entity (required)
     * @param entity The entity to be updated (required)
     * @param xFrankieCustomerChildID If, as a Frankie Customer, you are acting on behalf of your own customers, then you can populate this field with a Frankie-assigned ID.  Note: If using a CustomerChildID, you will also need a separate api_key for each child.  Any documents, checks, entities that are created when this field has been populated will now be tied to this CustomerID + CustomerChildID combination. Just as Customers cannot see data created by other Customers, so too a Customer&#39;s Children will not be able to see each other&#39;s data.  A Customer can see the documents/entities and checks of all their Children.  (optional)
     * @param xFrankieBackground If this header parameter is supplied and set to 1, then the request will not wait for the process to finish, and will return a 202 if there are no obvious errors in the input. The request will then run in the background and send a notification back to the customer. See out callback API for details on this.  See more details here:   https://apidocs.frankiefinancial.com/docs/asynchronous-calls-backgrounding-processes  (optional)
     * @param noInvalidate Disable check result invalidation for this update request.  (optional)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> The request was valid and able to be processed in some fashion. Results may or may not be successful, but it was completed as far as practical with no actual errors. Returns the entity object as it stands now. No docScan file data from any attached ID documents will be returned unless the /full variant is requested. </td><td>  -  </td></tr>
        <tr><td> 202 </td><td> The request was valid and can potentially be fulfilled. The Frankie service has now accepted responsibility for processing and we will either push the results to you, or send you a notification, depending on the request and your configuration. </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad request. One or more request fields is either missing or incorrect. Details are in the error response. </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> The request has failed an authorisation check. This can happen for a variety of reasons, such as an invalid or expired API key, or invalid Customer/CustomerChildIDs.  * NOTE: This does not include attempts to read/write data you don&#39;t have access to - that&#39;s a 404 error (as we don&#39;t want to leak information through guessing)  </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Cannot return response. In the case of a query, or reference to a specific entity/check/etc, it means that the requested item was not found, or you don&#39;t have access to it. Please check your query before trying again. </td><td>  -  </td></tr>
        <tr><td> 405 </td><td> A request to POST an update to an object was not allowed due to it&#39;s state. This may indicate an already completed check, or a document that has been processed. You need to create a new document/check if you wish to update the object in question. </td><td>  -  </td></tr>
        <tr><td> 415 </td><td> For requests with payloads, an unsupported Content-Type was specified. The Frankie Financial API only supports a content type of application/json. </td><td>  -  </td></tr>
        <tr><td> 422 </td><td> Unprocessable request. This can be triggered in a number of ways. * An attempt to force a check or scan to run, but there is insufficient data to be able to do so. * An attempt to run a utility comparison, or similar industry/document/entity specific scan or process on an unsupported document type (e.g. electricity comparison on a passport) Details of what is required will be in the issues list of the error response.  </td><td>  -  </td></tr>
        <tr><td> 429 </td><td> The API client is making too many concurrent requests, and some are being throttled. Throttled requests can be retried after a short delay. </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Unexpected error. Something went wrong during the checking process. </td><td>  -  </td></tr>
        <tr><td> 503 </td><td> All of the ID sources configured by the customer are unavailable, or there is no available document processor. </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call updateEntityAsync(UUID xFrankieCustomerID, UUID entityId, EntityObject entity, UUID xFrankieCustomerChildID, Integer xFrankieBackground, Boolean noInvalidate, final ApiCallback<EntityResultObject> _callback) throws ApiException {

        okhttp3.Call localVarCall = updateEntityValidateBeforeCall(xFrankieCustomerID, entityId, entity, xFrankieCustomerChildID, xFrankieBackground, noInvalidate, _callback);
        Type localVarReturnType = new TypeToken<EntityResultObject>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for updateEntityGetIDVToken
     * @param xFrankieCustomerID Customer ID issued by Frankie Financial. This will never change. Your API key, which is mapped to this identity, will change over time.  (required)
     * @param entityId The entityId returned previously from an earlier call to /check or /entity (required)
     * @param entityIDVDetails The entity to update and required data to generate an IDV token (required)
     * @param xFrankieCustomerChildID If, as a Frankie Customer, you are acting on behalf of your own customers, then you can populate this field with a Frankie-assigned ID.  Note: If using a CustomerChildID, you will also need a separate api_key for each child.  Any documents, checks, entities that are created when this field has been populated will now be tied to this CustomerID + CustomerChildID combination. Just as Customers cannot see data created by other Customers, so too a Customer&#39;s Children will not be able to see each other&#39;s data.  A Customer can see the documents/entities and checks of all their Children.  (optional)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> The request was valid and able to be processed in some fashion. Results may or may not be successful, but it was completed as far as practical with no actual errors. Returns the entity object as it stands now. No docScan file data from any attached ID documents will be returned unless the /full variant is requested.  Also returned is the applicantId and token to be in the IDV process.  </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad request. One or more request fields is either missing or incorrect. Details are in the error response. </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> The request has failed an authorisation check. This can happen for a variety of reasons, such as an invalid or expired API key, or invalid Customer/CustomerChildIDs.  * NOTE: This does not include attempts to read/write data you don&#39;t have access to - that&#39;s a 404 error (as we don&#39;t want to leak information through guessing)  </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Cannot return response. In the case of a query, or reference to a specific entity/check/etc, it means that the requested item was not found, or you don&#39;t have access to it. Please check your query before trying again. </td><td>  -  </td></tr>
        <tr><td> 405 </td><td> A request to POST an update to an object was not allowed due to it&#39;s state. This may indicate an already completed check, or a document that has been processed. You need to create a new document/check if you wish to update the object in question. </td><td>  -  </td></tr>
        <tr><td> 415 </td><td> For requests with payloads, an unsupported Content-Type was specified. The Frankie Financial API only supports a content type of application/json. </td><td>  -  </td></tr>
        <tr><td> 422 </td><td> Unprocessable request. This can be triggered in a number of ways. * An attempt to force a check or scan to run, but there is insufficient data to be able to do so. * An attempt to run a utility comparison, or similar industry/document/entity specific scan or process on an unsupported document type (e.g. electricity comparison on a passport) Details of what is required will be in the issues list of the error response.  </td><td>  -  </td></tr>
        <tr><td> 429 </td><td> The API client is making too many concurrent requests, and some are being throttled. Throttled requests can be retried after a short delay. </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Unexpected error. Something went wrong during the checking process. </td><td>  -  </td></tr>
        <tr><td> 503 </td><td> All of the ID sources configured by the customer are unavailable, or there is no available document processor. </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call updateEntityGetIDVTokenCall(UUID xFrankieCustomerID, UUID entityId, EntityIDVDetailsObject entityIDVDetails, UUID xFrankieCustomerChildID, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = entityIDVDetails;

        // create path and map variables
        String localVarPath = "/entity/{entityId}/idvalidate/getToken"
            .replace("{" + "entityId" + "}", localVarApiClient.escapeString(entityId.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (xFrankieCustomerID != null) {
            localVarHeaderParams.put("X-Frankie-CustomerID", localVarApiClient.parameterToString(xFrankieCustomerID));
        }

        if (xFrankieCustomerChildID != null) {
            localVarHeaderParams.put("X-Frankie-CustomerChildID", localVarApiClient.parameterToString(xFrankieCustomerChildID));
        }

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            "application/json"
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "api_key" };
        return localVarApiClient.buildCall(basePath, localVarPath, "POST", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call updateEntityGetIDVTokenValidateBeforeCall(UUID xFrankieCustomerID, UUID entityId, EntityIDVDetailsObject entityIDVDetails, UUID xFrankieCustomerChildID, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'xFrankieCustomerID' is set
        if (xFrankieCustomerID == null) {
            throw new ApiException("Missing the required parameter 'xFrankieCustomerID' when calling updateEntityGetIDVToken(Async)");
        }

        // verify the required parameter 'entityId' is set
        if (entityId == null) {
            throw new ApiException("Missing the required parameter 'entityId' when calling updateEntityGetIDVToken(Async)");
        }

        // verify the required parameter 'entityIDVDetails' is set
        if (entityIDVDetails == null) {
            throw new ApiException("Missing the required parameter 'entityIDVDetails' when calling updateEntityGetIDVToken(Async)");
        }

        return updateEntityGetIDVTokenCall(xFrankieCustomerID, entityId, entityIDVDetails, xFrankieCustomerChildID, _callback);

    }

    /**
     * Update Entity and Get IDV Token
     * Update an entity object and if successful, obtain a token for use in an ID Validation service SDK (web or native app)   At a minimum, the entity will need to have a name. For best results, you should gather the DoB, address, ID document details as well before calling the initProcess function.  SPECIAL NOTE 1: Tokens have a limited lifespan, typically only 1 hour. Make sure you&#39;ve used it or you will need to create another using update version of this function.   SPECIAL NOTE 2: This function will need to be followed up with a call to /entity/{id}/idvalidate/initProcess once you&#39;ve collected all your data in your app/web capture process. 
     * @param xFrankieCustomerID Customer ID issued by Frankie Financial. This will never change. Your API key, which is mapped to this identity, will change over time.  (required)
     * @param entityId The entityId returned previously from an earlier call to /check or /entity (required)
     * @param entityIDVDetails The entity to update and required data to generate an IDV token (required)
     * @param xFrankieCustomerChildID If, as a Frankie Customer, you are acting on behalf of your own customers, then you can populate this field with a Frankie-assigned ID.  Note: If using a CustomerChildID, you will also need a separate api_key for each child.  Any documents, checks, entities that are created when this field has been populated will now be tied to this CustomerID + CustomerChildID combination. Just as Customers cannot see data created by other Customers, so too a Customer&#39;s Children will not be able to see each other&#39;s data.  A Customer can see the documents/entities and checks of all their Children.  (optional)
     * @return EntityIDVResultObject
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> The request was valid and able to be processed in some fashion. Results may or may not be successful, but it was completed as far as practical with no actual errors. Returns the entity object as it stands now. No docScan file data from any attached ID documents will be returned unless the /full variant is requested.  Also returned is the applicantId and token to be in the IDV process.  </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad request. One or more request fields is either missing or incorrect. Details are in the error response. </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> The request has failed an authorisation check. This can happen for a variety of reasons, such as an invalid or expired API key, or invalid Customer/CustomerChildIDs.  * NOTE: This does not include attempts to read/write data you don&#39;t have access to - that&#39;s a 404 error (as we don&#39;t want to leak information through guessing)  </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Cannot return response. In the case of a query, or reference to a specific entity/check/etc, it means that the requested item was not found, or you don&#39;t have access to it. Please check your query before trying again. </td><td>  -  </td></tr>
        <tr><td> 405 </td><td> A request to POST an update to an object was not allowed due to it&#39;s state. This may indicate an already completed check, or a document that has been processed. You need to create a new document/check if you wish to update the object in question. </td><td>  -  </td></tr>
        <tr><td> 415 </td><td> For requests with payloads, an unsupported Content-Type was specified. The Frankie Financial API only supports a content type of application/json. </td><td>  -  </td></tr>
        <tr><td> 422 </td><td> Unprocessable request. This can be triggered in a number of ways. * An attempt to force a check or scan to run, but there is insufficient data to be able to do so. * An attempt to run a utility comparison, or similar industry/document/entity specific scan or process on an unsupported document type (e.g. electricity comparison on a passport) Details of what is required will be in the issues list of the error response.  </td><td>  -  </td></tr>
        <tr><td> 429 </td><td> The API client is making too many concurrent requests, and some are being throttled. Throttled requests can be retried after a short delay. </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Unexpected error. Something went wrong during the checking process. </td><td>  -  </td></tr>
        <tr><td> 503 </td><td> All of the ID sources configured by the customer are unavailable, or there is no available document processor. </td><td>  -  </td></tr>
     </table>
     */
    public EntityIDVResultObject updateEntityGetIDVToken(UUID xFrankieCustomerID, UUID entityId, EntityIDVDetailsObject entityIDVDetails, UUID xFrankieCustomerChildID) throws ApiException {
        ApiResponse<EntityIDVResultObject> localVarResp = updateEntityGetIDVTokenWithHttpInfo(xFrankieCustomerID, entityId, entityIDVDetails, xFrankieCustomerChildID);
        return localVarResp.getData();
    }

    /**
     * Update Entity and Get IDV Token
     * Update an entity object and if successful, obtain a token for use in an ID Validation service SDK (web or native app)   At a minimum, the entity will need to have a name. For best results, you should gather the DoB, address, ID document details as well before calling the initProcess function.  SPECIAL NOTE 1: Tokens have a limited lifespan, typically only 1 hour. Make sure you&#39;ve used it or you will need to create another using update version of this function.   SPECIAL NOTE 2: This function will need to be followed up with a call to /entity/{id}/idvalidate/initProcess once you&#39;ve collected all your data in your app/web capture process. 
     * @param xFrankieCustomerID Customer ID issued by Frankie Financial. This will never change. Your API key, which is mapped to this identity, will change over time.  (required)
     * @param entityId The entityId returned previously from an earlier call to /check or /entity (required)
     * @param entityIDVDetails The entity to update and required data to generate an IDV token (required)
     * @param xFrankieCustomerChildID If, as a Frankie Customer, you are acting on behalf of your own customers, then you can populate this field with a Frankie-assigned ID.  Note: If using a CustomerChildID, you will also need a separate api_key for each child.  Any documents, checks, entities that are created when this field has been populated will now be tied to this CustomerID + CustomerChildID combination. Just as Customers cannot see data created by other Customers, so too a Customer&#39;s Children will not be able to see each other&#39;s data.  A Customer can see the documents/entities and checks of all their Children.  (optional)
     * @return ApiResponse&lt;EntityIDVResultObject&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> The request was valid and able to be processed in some fashion. Results may or may not be successful, but it was completed as far as practical with no actual errors. Returns the entity object as it stands now. No docScan file data from any attached ID documents will be returned unless the /full variant is requested.  Also returned is the applicantId and token to be in the IDV process.  </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad request. One or more request fields is either missing or incorrect. Details are in the error response. </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> The request has failed an authorisation check. This can happen for a variety of reasons, such as an invalid or expired API key, or invalid Customer/CustomerChildIDs.  * NOTE: This does not include attempts to read/write data you don&#39;t have access to - that&#39;s a 404 error (as we don&#39;t want to leak information through guessing)  </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Cannot return response. In the case of a query, or reference to a specific entity/check/etc, it means that the requested item was not found, or you don&#39;t have access to it. Please check your query before trying again. </td><td>  -  </td></tr>
        <tr><td> 405 </td><td> A request to POST an update to an object was not allowed due to it&#39;s state. This may indicate an already completed check, or a document that has been processed. You need to create a new document/check if you wish to update the object in question. </td><td>  -  </td></tr>
        <tr><td> 415 </td><td> For requests with payloads, an unsupported Content-Type was specified. The Frankie Financial API only supports a content type of application/json. </td><td>  -  </td></tr>
        <tr><td> 422 </td><td> Unprocessable request. This can be triggered in a number of ways. * An attempt to force a check or scan to run, but there is insufficient data to be able to do so. * An attempt to run a utility comparison, or similar industry/document/entity specific scan or process on an unsupported document type (e.g. electricity comparison on a passport) Details of what is required will be in the issues list of the error response.  </td><td>  -  </td></tr>
        <tr><td> 429 </td><td> The API client is making too many concurrent requests, and some are being throttled. Throttled requests can be retried after a short delay. </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Unexpected error. Something went wrong during the checking process. </td><td>  -  </td></tr>
        <tr><td> 503 </td><td> All of the ID sources configured by the customer are unavailable, or there is no available document processor. </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<EntityIDVResultObject> updateEntityGetIDVTokenWithHttpInfo(UUID xFrankieCustomerID, UUID entityId, EntityIDVDetailsObject entityIDVDetails, UUID xFrankieCustomerChildID) throws ApiException {
        okhttp3.Call localVarCall = updateEntityGetIDVTokenValidateBeforeCall(xFrankieCustomerID, entityId, entityIDVDetails, xFrankieCustomerChildID, null);
        Type localVarReturnType = new TypeToken<EntityIDVResultObject>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Update Entity and Get IDV Token (asynchronously)
     * Update an entity object and if successful, obtain a token for use in an ID Validation service SDK (web or native app)   At a minimum, the entity will need to have a name. For best results, you should gather the DoB, address, ID document details as well before calling the initProcess function.  SPECIAL NOTE 1: Tokens have a limited lifespan, typically only 1 hour. Make sure you&#39;ve used it or you will need to create another using update version of this function.   SPECIAL NOTE 2: This function will need to be followed up with a call to /entity/{id}/idvalidate/initProcess once you&#39;ve collected all your data in your app/web capture process. 
     * @param xFrankieCustomerID Customer ID issued by Frankie Financial. This will never change. Your API key, which is mapped to this identity, will change over time.  (required)
     * @param entityId The entityId returned previously from an earlier call to /check or /entity (required)
     * @param entityIDVDetails The entity to update and required data to generate an IDV token (required)
     * @param xFrankieCustomerChildID If, as a Frankie Customer, you are acting on behalf of your own customers, then you can populate this field with a Frankie-assigned ID.  Note: If using a CustomerChildID, you will also need a separate api_key for each child.  Any documents, checks, entities that are created when this field has been populated will now be tied to this CustomerID + CustomerChildID combination. Just as Customers cannot see data created by other Customers, so too a Customer&#39;s Children will not be able to see each other&#39;s data.  A Customer can see the documents/entities and checks of all their Children.  (optional)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> The request was valid and able to be processed in some fashion. Results may or may not be successful, but it was completed as far as practical with no actual errors. Returns the entity object as it stands now. No docScan file data from any attached ID documents will be returned unless the /full variant is requested.  Also returned is the applicantId and token to be in the IDV process.  </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad request. One or more request fields is either missing or incorrect. Details are in the error response. </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> The request has failed an authorisation check. This can happen for a variety of reasons, such as an invalid or expired API key, or invalid Customer/CustomerChildIDs.  * NOTE: This does not include attempts to read/write data you don&#39;t have access to - that&#39;s a 404 error (as we don&#39;t want to leak information through guessing)  </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Cannot return response. In the case of a query, or reference to a specific entity/check/etc, it means that the requested item was not found, or you don&#39;t have access to it. Please check your query before trying again. </td><td>  -  </td></tr>
        <tr><td> 405 </td><td> A request to POST an update to an object was not allowed due to it&#39;s state. This may indicate an already completed check, or a document that has been processed. You need to create a new document/check if you wish to update the object in question. </td><td>  -  </td></tr>
        <tr><td> 415 </td><td> For requests with payloads, an unsupported Content-Type was specified. The Frankie Financial API only supports a content type of application/json. </td><td>  -  </td></tr>
        <tr><td> 422 </td><td> Unprocessable request. This can be triggered in a number of ways. * An attempt to force a check or scan to run, but there is insufficient data to be able to do so. * An attempt to run a utility comparison, or similar industry/document/entity specific scan or process on an unsupported document type (e.g. electricity comparison on a passport) Details of what is required will be in the issues list of the error response.  </td><td>  -  </td></tr>
        <tr><td> 429 </td><td> The API client is making too many concurrent requests, and some are being throttled. Throttled requests can be retried after a short delay. </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Unexpected error. Something went wrong during the checking process. </td><td>  -  </td></tr>
        <tr><td> 503 </td><td> All of the ID sources configured by the customer are unavailable, or there is no available document processor. </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call updateEntityGetIDVTokenAsync(UUID xFrankieCustomerID, UUID entityId, EntityIDVDetailsObject entityIDVDetails, UUID xFrankieCustomerChildID, final ApiCallback<EntityIDVResultObject> _callback) throws ApiException {

        okhttp3.Call localVarCall = updateEntityGetIDVTokenValidateBeforeCall(xFrankieCustomerID, entityId, entityIDVDetails, xFrankieCustomerChildID, _callback);
        Type localVarReturnType = new TypeToken<EntityIDVResultObject>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for updateEntityInitIDVProcess
     * @param xFrankieCustomerID Customer ID issued by Frankie Financial. This will never change. Your API key, which is mapped to this identity, will change over time.  (required)
     * @param entityId The entityId returned previously from an earlier call to /check or /entity (required)
     * @param entityDetails The entity to update (required)
     * @param xFrankieCustomerChildID If, as a Frankie Customer, you are acting on behalf of your own customers, then you can populate this field with a Frankie-assigned ID.  Note: If using a CustomerChildID, you will also need a separate api_key for each child.  Any documents, checks, entities that are created when this field has been populated will now be tied to this CustomerID + CustomerChildID combination. Just as Customers cannot see data created by other Customers, so too a Customer&#39;s Children will not be able to see each other&#39;s data.  A Customer can see the documents/entities and checks of all their Children.  (optional)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> The request was valid and able to be processed in some fashion. Results may or may not be successful, but it was completed as far as practical with no actual errors. Returns the entity object as it stands now. No docScan file data from any attached ID documents will be returned unless the /full variant is requested.  Also returned is the applicantId and token to be in the IDV process.  </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad request. One or more request fields is either missing or incorrect. Details are in the error response. </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> The request has failed an authorisation check. This can happen for a variety of reasons, such as an invalid or expired API key, or invalid Customer/CustomerChildIDs.  * NOTE: This does not include attempts to read/write data you don&#39;t have access to - that&#39;s a 404 error (as we don&#39;t want to leak information through guessing)  </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Cannot return response. In the case of a query, or reference to a specific entity/check/etc, it means that the requested item was not found, or you don&#39;t have access to it. Please check your query before trying again. </td><td>  -  </td></tr>
        <tr><td> 405 </td><td> A request to POST an update to an object was not allowed due to it&#39;s state. This may indicate an already completed check, or a document that has been processed. You need to create a new document/check if you wish to update the object in question. </td><td>  -  </td></tr>
        <tr><td> 415 </td><td> For requests with payloads, an unsupported Content-Type was specified. The Frankie Financial API only supports a content type of application/json. </td><td>  -  </td></tr>
        <tr><td> 422 </td><td> Unprocessable request. This can be triggered in a number of ways. * An attempt to force a check or scan to run, but there is insufficient data to be able to do so. * An attempt to run a utility comparison, or similar industry/document/entity specific scan or process on an unsupported document type (e.g. electricity comparison on a passport) Details of what is required will be in the issues list of the error response.  </td><td>  -  </td></tr>
        <tr><td> 429 </td><td> The API client is making too many concurrent requests, and some are being throttled. Throttled requests can be retried after a short delay. </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Unexpected error. Something went wrong during the checking process. </td><td>  -  </td></tr>
        <tr><td> 503 </td><td> All of the ID sources configured by the customer are unavailable, or there is no available document processor. </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call updateEntityInitIDVProcessCall(UUID xFrankieCustomerID, UUID entityId, EntityCheckDetailsObject entityDetails, UUID xFrankieCustomerChildID, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = entityDetails;

        // create path and map variables
        String localVarPath = "/entity/{entityId}/idvalidate/initProcess"
            .replace("{" + "entityId" + "}", localVarApiClient.escapeString(entityId.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (xFrankieCustomerID != null) {
            localVarHeaderParams.put("X-Frankie-CustomerID", localVarApiClient.parameterToString(xFrankieCustomerID));
        }

        if (xFrankieCustomerChildID != null) {
            localVarHeaderParams.put("X-Frankie-CustomerChildID", localVarApiClient.parameterToString(xFrankieCustomerChildID));
        }

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            "application/json"
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "api_key" };
        return localVarApiClient.buildCall(basePath, localVarPath, "POST", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call updateEntityInitIDVProcessValidateBeforeCall(UUID xFrankieCustomerID, UUID entityId, EntityCheckDetailsObject entityDetails, UUID xFrankieCustomerChildID, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'xFrankieCustomerID' is set
        if (xFrankieCustomerID == null) {
            throw new ApiException("Missing the required parameter 'xFrankieCustomerID' when calling updateEntityInitIDVProcess(Async)");
        }

        // verify the required parameter 'entityId' is set
        if (entityId == null) {
            throw new ApiException("Missing the required parameter 'entityId' when calling updateEntityInitIDVProcess(Async)");
        }

        // verify the required parameter 'entityDetails' is set
        if (entityDetails == null) {
            throw new ApiException("Missing the required parameter 'entityDetails' when calling updateEntityInitIDVProcess(Async)");
        }

        return updateEntityInitIDVProcessCall(xFrankieCustomerID, entityId, entityDetails, xFrankieCustomerChildID, _callback);

    }

    /**
     * Update Entity and Initiate IDV Process
     * Update an entity object and if successful, start the process of downloading the captured data and processing the reports and results of the ID validation process.   At a minimum, the entity will need to have a name. For best results, you should gather the DoB, address, ID document details as well before calling this initProcess function, or supply the details as part of this update. 
     * @param xFrankieCustomerID Customer ID issued by Frankie Financial. This will never change. Your API key, which is mapped to this identity, will change over time.  (required)
     * @param entityId The entityId returned previously from an earlier call to /check or /entity (required)
     * @param entityDetails The entity to update (required)
     * @param xFrankieCustomerChildID If, as a Frankie Customer, you are acting on behalf of your own customers, then you can populate this field with a Frankie-assigned ID.  Note: If using a CustomerChildID, you will also need a separate api_key for each child.  Any documents, checks, entities that are created when this field has been populated will now be tied to this CustomerID + CustomerChildID combination. Just as Customers cannot see data created by other Customers, so too a Customer&#39;s Children will not be able to see each other&#39;s data.  A Customer can see the documents/entities and checks of all their Children.  (optional)
     * @return EntityIDVResultObject
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> The request was valid and able to be processed in some fashion. Results may or may not be successful, but it was completed as far as practical with no actual errors. Returns the entity object as it stands now. No docScan file data from any attached ID documents will be returned unless the /full variant is requested.  Also returned is the applicantId and token to be in the IDV process.  </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad request. One or more request fields is either missing or incorrect. Details are in the error response. </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> The request has failed an authorisation check. This can happen for a variety of reasons, such as an invalid or expired API key, or invalid Customer/CustomerChildIDs.  * NOTE: This does not include attempts to read/write data you don&#39;t have access to - that&#39;s a 404 error (as we don&#39;t want to leak information through guessing)  </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Cannot return response. In the case of a query, or reference to a specific entity/check/etc, it means that the requested item was not found, or you don&#39;t have access to it. Please check your query before trying again. </td><td>  -  </td></tr>
        <tr><td> 405 </td><td> A request to POST an update to an object was not allowed due to it&#39;s state. This may indicate an already completed check, or a document that has been processed. You need to create a new document/check if you wish to update the object in question. </td><td>  -  </td></tr>
        <tr><td> 415 </td><td> For requests with payloads, an unsupported Content-Type was specified. The Frankie Financial API only supports a content type of application/json. </td><td>  -  </td></tr>
        <tr><td> 422 </td><td> Unprocessable request. This can be triggered in a number of ways. * An attempt to force a check or scan to run, but there is insufficient data to be able to do so. * An attempt to run a utility comparison, or similar industry/document/entity specific scan or process on an unsupported document type (e.g. electricity comparison on a passport) Details of what is required will be in the issues list of the error response.  </td><td>  -  </td></tr>
        <tr><td> 429 </td><td> The API client is making too many concurrent requests, and some are being throttled. Throttled requests can be retried after a short delay. </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Unexpected error. Something went wrong during the checking process. </td><td>  -  </td></tr>
        <tr><td> 503 </td><td> All of the ID sources configured by the customer are unavailable, or there is no available document processor. </td><td>  -  </td></tr>
     </table>
     */
    public EntityIDVResultObject updateEntityInitIDVProcess(UUID xFrankieCustomerID, UUID entityId, EntityCheckDetailsObject entityDetails, UUID xFrankieCustomerChildID) throws ApiException {
        ApiResponse<EntityIDVResultObject> localVarResp = updateEntityInitIDVProcessWithHttpInfo(xFrankieCustomerID, entityId, entityDetails, xFrankieCustomerChildID);
        return localVarResp.getData();
    }

    /**
     * Update Entity and Initiate IDV Process
     * Update an entity object and if successful, start the process of downloading the captured data and processing the reports and results of the ID validation process.   At a minimum, the entity will need to have a name. For best results, you should gather the DoB, address, ID document details as well before calling this initProcess function, or supply the details as part of this update. 
     * @param xFrankieCustomerID Customer ID issued by Frankie Financial. This will never change. Your API key, which is mapped to this identity, will change over time.  (required)
     * @param entityId The entityId returned previously from an earlier call to /check or /entity (required)
     * @param entityDetails The entity to update (required)
     * @param xFrankieCustomerChildID If, as a Frankie Customer, you are acting on behalf of your own customers, then you can populate this field with a Frankie-assigned ID.  Note: If using a CustomerChildID, you will also need a separate api_key for each child.  Any documents, checks, entities that are created when this field has been populated will now be tied to this CustomerID + CustomerChildID combination. Just as Customers cannot see data created by other Customers, so too a Customer&#39;s Children will not be able to see each other&#39;s data.  A Customer can see the documents/entities and checks of all their Children.  (optional)
     * @return ApiResponse&lt;EntityIDVResultObject&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> The request was valid and able to be processed in some fashion. Results may or may not be successful, but it was completed as far as practical with no actual errors. Returns the entity object as it stands now. No docScan file data from any attached ID documents will be returned unless the /full variant is requested.  Also returned is the applicantId and token to be in the IDV process.  </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad request. One or more request fields is either missing or incorrect. Details are in the error response. </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> The request has failed an authorisation check. This can happen for a variety of reasons, such as an invalid or expired API key, or invalid Customer/CustomerChildIDs.  * NOTE: This does not include attempts to read/write data you don&#39;t have access to - that&#39;s a 404 error (as we don&#39;t want to leak information through guessing)  </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Cannot return response. In the case of a query, or reference to a specific entity/check/etc, it means that the requested item was not found, or you don&#39;t have access to it. Please check your query before trying again. </td><td>  -  </td></tr>
        <tr><td> 405 </td><td> A request to POST an update to an object was not allowed due to it&#39;s state. This may indicate an already completed check, or a document that has been processed. You need to create a new document/check if you wish to update the object in question. </td><td>  -  </td></tr>
        <tr><td> 415 </td><td> For requests with payloads, an unsupported Content-Type was specified. The Frankie Financial API only supports a content type of application/json. </td><td>  -  </td></tr>
        <tr><td> 422 </td><td> Unprocessable request. This can be triggered in a number of ways. * An attempt to force a check or scan to run, but there is insufficient data to be able to do so. * An attempt to run a utility comparison, or similar industry/document/entity specific scan or process on an unsupported document type (e.g. electricity comparison on a passport) Details of what is required will be in the issues list of the error response.  </td><td>  -  </td></tr>
        <tr><td> 429 </td><td> The API client is making too many concurrent requests, and some are being throttled. Throttled requests can be retried after a short delay. </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Unexpected error. Something went wrong during the checking process. </td><td>  -  </td></tr>
        <tr><td> 503 </td><td> All of the ID sources configured by the customer are unavailable, or there is no available document processor. </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<EntityIDVResultObject> updateEntityInitIDVProcessWithHttpInfo(UUID xFrankieCustomerID, UUID entityId, EntityCheckDetailsObject entityDetails, UUID xFrankieCustomerChildID) throws ApiException {
        okhttp3.Call localVarCall = updateEntityInitIDVProcessValidateBeforeCall(xFrankieCustomerID, entityId, entityDetails, xFrankieCustomerChildID, null);
        Type localVarReturnType = new TypeToken<EntityIDVResultObject>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Update Entity and Initiate IDV Process (asynchronously)
     * Update an entity object and if successful, start the process of downloading the captured data and processing the reports and results of the ID validation process.   At a minimum, the entity will need to have a name. For best results, you should gather the DoB, address, ID document details as well before calling this initProcess function, or supply the details as part of this update. 
     * @param xFrankieCustomerID Customer ID issued by Frankie Financial. This will never change. Your API key, which is mapped to this identity, will change over time.  (required)
     * @param entityId The entityId returned previously from an earlier call to /check or /entity (required)
     * @param entityDetails The entity to update (required)
     * @param xFrankieCustomerChildID If, as a Frankie Customer, you are acting on behalf of your own customers, then you can populate this field with a Frankie-assigned ID.  Note: If using a CustomerChildID, you will also need a separate api_key for each child.  Any documents, checks, entities that are created when this field has been populated will now be tied to this CustomerID + CustomerChildID combination. Just as Customers cannot see data created by other Customers, so too a Customer&#39;s Children will not be able to see each other&#39;s data.  A Customer can see the documents/entities and checks of all their Children.  (optional)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> The request was valid and able to be processed in some fashion. Results may or may not be successful, but it was completed as far as practical with no actual errors. Returns the entity object as it stands now. No docScan file data from any attached ID documents will be returned unless the /full variant is requested.  Also returned is the applicantId and token to be in the IDV process.  </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad request. One or more request fields is either missing or incorrect. Details are in the error response. </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> The request has failed an authorisation check. This can happen for a variety of reasons, such as an invalid or expired API key, or invalid Customer/CustomerChildIDs.  * NOTE: This does not include attempts to read/write data you don&#39;t have access to - that&#39;s a 404 error (as we don&#39;t want to leak information through guessing)  </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Cannot return response. In the case of a query, or reference to a specific entity/check/etc, it means that the requested item was not found, or you don&#39;t have access to it. Please check your query before trying again. </td><td>  -  </td></tr>
        <tr><td> 405 </td><td> A request to POST an update to an object was not allowed due to it&#39;s state. This may indicate an already completed check, or a document that has been processed. You need to create a new document/check if you wish to update the object in question. </td><td>  -  </td></tr>
        <tr><td> 415 </td><td> For requests with payloads, an unsupported Content-Type was specified. The Frankie Financial API only supports a content type of application/json. </td><td>  -  </td></tr>
        <tr><td> 422 </td><td> Unprocessable request. This can be triggered in a number of ways. * An attempt to force a check or scan to run, but there is insufficient data to be able to do so. * An attempt to run a utility comparison, or similar industry/document/entity specific scan or process on an unsupported document type (e.g. electricity comparison on a passport) Details of what is required will be in the issues list of the error response.  </td><td>  -  </td></tr>
        <tr><td> 429 </td><td> The API client is making too many concurrent requests, and some are being throttled. Throttled requests can be retried after a short delay. </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Unexpected error. Something went wrong during the checking process. </td><td>  -  </td></tr>
        <tr><td> 503 </td><td> All of the ID sources configured by the customer are unavailable, or there is no available document processor. </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call updateEntityInitIDVProcessAsync(UUID xFrankieCustomerID, UUID entityId, EntityCheckDetailsObject entityDetails, UUID xFrankieCustomerChildID, final ApiCallback<EntityIDVResultObject> _callback) throws ApiException {

        okhttp3.Call localVarCall = updateEntityInitIDVProcessValidateBeforeCall(xFrankieCustomerID, entityId, entityDetails, xFrankieCustomerChildID, _callback);
        Type localVarReturnType = new TypeToken<EntityIDVResultObject>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for updateEntityState
     * @param xFrankieCustomerID Customer ID issued by Frankie Financial. This will never change. Your API key, which is mapped to this identity, will change over time.  (required)
     * @param entityId The entityId returned previously from an earlier call to /check or /entity (required)
     * @param xFrankieCustomerChildID If, as a Frankie Customer, you are acting on behalf of your own customers, then you can populate this field with a Frankie-assigned ID.  Note: If using a CustomerChildID, you will also need a separate api_key for each child.  Any documents, checks, entities that are created when this field has been populated will now be tied to this CustomerID + CustomerChildID combination. Just as Customers cannot see data created by other Customers, so too a Customer&#39;s Children will not be able to see each other&#39;s data.  A Customer can see the documents/entities and checks of all their Children.  (optional)
     * @param set The status of an entity. Valid values are:   - \&quot;wait\&quot;: Waiting for new details from entity.   - \&quot;fail\&quot;: Manually fail the onboarding process.   - \&quot;archived\&quot;: Hide entity from on onboarding.   - \&quot;clear\&quot;: Remove any of the above manual states as well as any manual risk.   - \&quot;inactive\&quot;: Hide entity and prevent any further operations on it. Cannot be cleared.  (optional)
     * @param risk The risk override setting for an entity. This value will be used until a verify result updates a real risk factor. Valid values are:   - \&quot;low\&quot;   - \&quot;medium\&quot;   - \&quot;high\&quot;   - \&quot;unacceptable\&quot;   - \&quot;significant\&quot;  (optional)
     * @param comment A comment describing the reason for a request.  (optional)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> The request was valid and able to be processed in some fashion. Results may or may not be successful, but it was completed as far as practical with no actual errors. Returns the entity object as it stands now. No docScan file data from any attached ID documents will be returned unless the /full variant is requested. </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad request. One or more request fields is either missing or incorrect. Details are in the error response. </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> The request has failed an authorisation check. This can happen for a variety of reasons, such as an invalid or expired API key, or invalid Customer/CustomerChildIDs.  * NOTE: This does not include attempts to read/write data you don&#39;t have access to - that&#39;s a 404 error (as we don&#39;t want to leak information through guessing)  </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Cannot return response. In the case of a query, or reference to a specific entity/check/etc, it means that the requested item was not found, or you don&#39;t have access to it. Please check your query before trying again. </td><td>  -  </td></tr>
        <tr><td> 405 </td><td> A request to POST an update to an object was not allowed due to it&#39;s state. This may indicate an already completed check, or a document that has been processed. You need to create a new document/check if you wish to update the object in question. </td><td>  -  </td></tr>
        <tr><td> 422 </td><td> Unprocessable request. This can be triggered in a number of ways. * An attempt to force a check or scan to run, but there is insufficient data to be able to do so. * An attempt to run a utility comparison, or similar industry/document/entity specific scan or process on an unsupported document type (e.g. electricity comparison on a passport) Details of what is required will be in the issues list of the error response.  </td><td>  -  </td></tr>
        <tr><td> 429 </td><td> The API client is making too many concurrent requests, and some are being throttled. Throttled requests can be retried after a short delay. </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Unexpected error. Something went wrong during the checking process. </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call updateEntityStateCall(UUID xFrankieCustomerID, UUID entityId, UUID xFrankieCustomerChildID, String set, String risk, String comment, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/entity/{entityId}/status"
            .replace("{" + "entityId" + "}", localVarApiClient.escapeString(entityId.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (set != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("set", set));
        }

        if (risk != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("risk", risk));
        }

        if (comment != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("comment", comment));
        }

        if (xFrankieCustomerID != null) {
            localVarHeaderParams.put("X-Frankie-CustomerID", localVarApiClient.parameterToString(xFrankieCustomerID));
        }

        if (xFrankieCustomerChildID != null) {
            localVarHeaderParams.put("X-Frankie-CustomerChildID", localVarApiClient.parameterToString(xFrankieCustomerChildID));
        }

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "api_key" };
        return localVarApiClient.buildCall(basePath, localVarPath, "POST", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call updateEntityStateValidateBeforeCall(UUID xFrankieCustomerID, UUID entityId, UUID xFrankieCustomerChildID, String set, String risk, String comment, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'xFrankieCustomerID' is set
        if (xFrankieCustomerID == null) {
            throw new ApiException("Missing the required parameter 'xFrankieCustomerID' when calling updateEntityState(Async)");
        }

        // verify the required parameter 'entityId' is set
        if (entityId == null) {
            throw new ApiException("Missing the required parameter 'entityId' when calling updateEntityState(Async)");
        }

        return updateEntityStateCall(xFrankieCustomerID, entityId, xFrankieCustomerChildID, set, risk, comment, _callback);

    }

    /**
     * Update Entity States
     * Internal only  Add a special internal &#39;entity result&#39; to superceed any previous real checks until the next one. 
     * @param xFrankieCustomerID Customer ID issued by Frankie Financial. This will never change. Your API key, which is mapped to this identity, will change over time.  (required)
     * @param entityId The entityId returned previously from an earlier call to /check or /entity (required)
     * @param xFrankieCustomerChildID If, as a Frankie Customer, you are acting on behalf of your own customers, then you can populate this field with a Frankie-assigned ID.  Note: If using a CustomerChildID, you will also need a separate api_key for each child.  Any documents, checks, entities that are created when this field has been populated will now be tied to this CustomerID + CustomerChildID combination. Just as Customers cannot see data created by other Customers, so too a Customer&#39;s Children will not be able to see each other&#39;s data.  A Customer can see the documents/entities and checks of all their Children.  (optional)
     * @param set The status of an entity. Valid values are:   - \&quot;wait\&quot;: Waiting for new details from entity.   - \&quot;fail\&quot;: Manually fail the onboarding process.   - \&quot;archived\&quot;: Hide entity from on onboarding.   - \&quot;clear\&quot;: Remove any of the above manual states as well as any manual risk.   - \&quot;inactive\&quot;: Hide entity and prevent any further operations on it. Cannot be cleared.  (optional)
     * @param risk The risk override setting for an entity. This value will be used until a verify result updates a real risk factor. Valid values are:   - \&quot;low\&quot;   - \&quot;medium\&quot;   - \&quot;high\&quot;   - \&quot;unacceptable\&quot;   - \&quot;significant\&quot;  (optional)
     * @param comment A comment describing the reason for a request.  (optional)
     * @return CheckEntityCheckResultObject
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> The request was valid and able to be processed in some fashion. Results may or may not be successful, but it was completed as far as practical with no actual errors. Returns the entity object as it stands now. No docScan file data from any attached ID documents will be returned unless the /full variant is requested. </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad request. One or more request fields is either missing or incorrect. Details are in the error response. </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> The request has failed an authorisation check. This can happen for a variety of reasons, such as an invalid or expired API key, or invalid Customer/CustomerChildIDs.  * NOTE: This does not include attempts to read/write data you don&#39;t have access to - that&#39;s a 404 error (as we don&#39;t want to leak information through guessing)  </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Cannot return response. In the case of a query, or reference to a specific entity/check/etc, it means that the requested item was not found, or you don&#39;t have access to it. Please check your query before trying again. </td><td>  -  </td></tr>
        <tr><td> 405 </td><td> A request to POST an update to an object was not allowed due to it&#39;s state. This may indicate an already completed check, or a document that has been processed. You need to create a new document/check if you wish to update the object in question. </td><td>  -  </td></tr>
        <tr><td> 422 </td><td> Unprocessable request. This can be triggered in a number of ways. * An attempt to force a check or scan to run, but there is insufficient data to be able to do so. * An attempt to run a utility comparison, or similar industry/document/entity specific scan or process on an unsupported document type (e.g. electricity comparison on a passport) Details of what is required will be in the issues list of the error response.  </td><td>  -  </td></tr>
        <tr><td> 429 </td><td> The API client is making too many concurrent requests, and some are being throttled. Throttled requests can be retried after a short delay. </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Unexpected error. Something went wrong during the checking process. </td><td>  -  </td></tr>
     </table>
     */
    public CheckEntityCheckResultObject updateEntityState(UUID xFrankieCustomerID, UUID entityId, UUID xFrankieCustomerChildID, String set, String risk, String comment) throws ApiException {
        ApiResponse<CheckEntityCheckResultObject> localVarResp = updateEntityStateWithHttpInfo(xFrankieCustomerID, entityId, xFrankieCustomerChildID, set, risk, comment);
        return localVarResp.getData();
    }

    /**
     * Update Entity States
     * Internal only  Add a special internal &#39;entity result&#39; to superceed any previous real checks until the next one. 
     * @param xFrankieCustomerID Customer ID issued by Frankie Financial. This will never change. Your API key, which is mapped to this identity, will change over time.  (required)
     * @param entityId The entityId returned previously from an earlier call to /check or /entity (required)
     * @param xFrankieCustomerChildID If, as a Frankie Customer, you are acting on behalf of your own customers, then you can populate this field with a Frankie-assigned ID.  Note: If using a CustomerChildID, you will also need a separate api_key for each child.  Any documents, checks, entities that are created when this field has been populated will now be tied to this CustomerID + CustomerChildID combination. Just as Customers cannot see data created by other Customers, so too a Customer&#39;s Children will not be able to see each other&#39;s data.  A Customer can see the documents/entities and checks of all their Children.  (optional)
     * @param set The status of an entity. Valid values are:   - \&quot;wait\&quot;: Waiting for new details from entity.   - \&quot;fail\&quot;: Manually fail the onboarding process.   - \&quot;archived\&quot;: Hide entity from on onboarding.   - \&quot;clear\&quot;: Remove any of the above manual states as well as any manual risk.   - \&quot;inactive\&quot;: Hide entity and prevent any further operations on it. Cannot be cleared.  (optional)
     * @param risk The risk override setting for an entity. This value will be used until a verify result updates a real risk factor. Valid values are:   - \&quot;low\&quot;   - \&quot;medium\&quot;   - \&quot;high\&quot;   - \&quot;unacceptable\&quot;   - \&quot;significant\&quot;  (optional)
     * @param comment A comment describing the reason for a request.  (optional)
     * @return ApiResponse&lt;CheckEntityCheckResultObject&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> The request was valid and able to be processed in some fashion. Results may or may not be successful, but it was completed as far as practical with no actual errors. Returns the entity object as it stands now. No docScan file data from any attached ID documents will be returned unless the /full variant is requested. </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad request. One or more request fields is either missing or incorrect. Details are in the error response. </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> The request has failed an authorisation check. This can happen for a variety of reasons, such as an invalid or expired API key, or invalid Customer/CustomerChildIDs.  * NOTE: This does not include attempts to read/write data you don&#39;t have access to - that&#39;s a 404 error (as we don&#39;t want to leak information through guessing)  </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Cannot return response. In the case of a query, or reference to a specific entity/check/etc, it means that the requested item was not found, or you don&#39;t have access to it. Please check your query before trying again. </td><td>  -  </td></tr>
        <tr><td> 405 </td><td> A request to POST an update to an object was not allowed due to it&#39;s state. This may indicate an already completed check, or a document that has been processed. You need to create a new document/check if you wish to update the object in question. </td><td>  -  </td></tr>
        <tr><td> 422 </td><td> Unprocessable request. This can be triggered in a number of ways. * An attempt to force a check or scan to run, but there is insufficient data to be able to do so. * An attempt to run a utility comparison, or similar industry/document/entity specific scan or process on an unsupported document type (e.g. electricity comparison on a passport) Details of what is required will be in the issues list of the error response.  </td><td>  -  </td></tr>
        <tr><td> 429 </td><td> The API client is making too many concurrent requests, and some are being throttled. Throttled requests can be retried after a short delay. </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Unexpected error. Something went wrong during the checking process. </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<CheckEntityCheckResultObject> updateEntityStateWithHttpInfo(UUID xFrankieCustomerID, UUID entityId, UUID xFrankieCustomerChildID, String set, String risk, String comment) throws ApiException {
        okhttp3.Call localVarCall = updateEntityStateValidateBeforeCall(xFrankieCustomerID, entityId, xFrankieCustomerChildID, set, risk, comment, null);
        Type localVarReturnType = new TypeToken<CheckEntityCheckResultObject>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Update Entity States (asynchronously)
     * Internal only  Add a special internal &#39;entity result&#39; to superceed any previous real checks until the next one. 
     * @param xFrankieCustomerID Customer ID issued by Frankie Financial. This will never change. Your API key, which is mapped to this identity, will change over time.  (required)
     * @param entityId The entityId returned previously from an earlier call to /check or /entity (required)
     * @param xFrankieCustomerChildID If, as a Frankie Customer, you are acting on behalf of your own customers, then you can populate this field with a Frankie-assigned ID.  Note: If using a CustomerChildID, you will also need a separate api_key for each child.  Any documents, checks, entities that are created when this field has been populated will now be tied to this CustomerID + CustomerChildID combination. Just as Customers cannot see data created by other Customers, so too a Customer&#39;s Children will not be able to see each other&#39;s data.  A Customer can see the documents/entities and checks of all their Children.  (optional)
     * @param set The status of an entity. Valid values are:   - \&quot;wait\&quot;: Waiting for new details from entity.   - \&quot;fail\&quot;: Manually fail the onboarding process.   - \&quot;archived\&quot;: Hide entity from on onboarding.   - \&quot;clear\&quot;: Remove any of the above manual states as well as any manual risk.   - \&quot;inactive\&quot;: Hide entity and prevent any further operations on it. Cannot be cleared.  (optional)
     * @param risk The risk override setting for an entity. This value will be used until a verify result updates a real risk factor. Valid values are:   - \&quot;low\&quot;   - \&quot;medium\&quot;   - \&quot;high\&quot;   - \&quot;unacceptable\&quot;   - \&quot;significant\&quot;  (optional)
     * @param comment A comment describing the reason for a request.  (optional)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> The request was valid and able to be processed in some fashion. Results may or may not be successful, but it was completed as far as practical with no actual errors. Returns the entity object as it stands now. No docScan file data from any attached ID documents will be returned unless the /full variant is requested. </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad request. One or more request fields is either missing or incorrect. Details are in the error response. </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> The request has failed an authorisation check. This can happen for a variety of reasons, such as an invalid or expired API key, or invalid Customer/CustomerChildIDs.  * NOTE: This does not include attempts to read/write data you don&#39;t have access to - that&#39;s a 404 error (as we don&#39;t want to leak information through guessing)  </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Cannot return response. In the case of a query, or reference to a specific entity/check/etc, it means that the requested item was not found, or you don&#39;t have access to it. Please check your query before trying again. </td><td>  -  </td></tr>
        <tr><td> 405 </td><td> A request to POST an update to an object was not allowed due to it&#39;s state. This may indicate an already completed check, or a document that has been processed. You need to create a new document/check if you wish to update the object in question. </td><td>  -  </td></tr>
        <tr><td> 422 </td><td> Unprocessable request. This can be triggered in a number of ways. * An attempt to force a check or scan to run, but there is insufficient data to be able to do so. * An attempt to run a utility comparison, or similar industry/document/entity specific scan or process on an unsupported document type (e.g. electricity comparison on a passport) Details of what is required will be in the issues list of the error response.  </td><td>  -  </td></tr>
        <tr><td> 429 </td><td> The API client is making too many concurrent requests, and some are being throttled. Throttled requests can be retried after a short delay. </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Unexpected error. Something went wrong during the checking process. </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call updateEntityStateAsync(UUID xFrankieCustomerID, UUID entityId, UUID xFrankieCustomerChildID, String set, String risk, String comment, final ApiCallback<CheckEntityCheckResultObject> _callback) throws ApiException {

        okhttp3.Call localVarCall = updateEntityStateValidateBeforeCall(xFrankieCustomerID, entityId, xFrankieCustomerChildID, set, risk, comment, _callback);
        Type localVarReturnType = new TypeToken<CheckEntityCheckResultObject>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
}
