/*
 * Frankie Financial API
 * ------   This API allows developers to integrate the Frankie Financial Compliance Utility into their applications. The API allows:   - Checking name, address, date of birth against national databases   - Validating Australian driver's licences, passports, medicare, visas and other Australian national ID documents   - Validating Australian electricity bills   - Validating NZ driver's licences   - Validating Chinese bank cards and national ID card   - Validating International passports and national ID documents   - PEP, Sanctions, Watchlist and adverse media checking   - Australian visa checks    - Fraud list and fraud background checks   - ID validation and selfie check comparisons.    ------     Industry specific services    - Comparing Australian electricity retailers for a better deal.  ------     KYB specific services    - Query organisation ownership   - Perform KYC & AML checks on shareholders, beneficial owners and office bearers.   - Query credit score and credit reports   - International company searches   - International company profiles    ------   The full version of this documentation along with supplemental articles can be found here:   - https://apidocs.frankiefinancial.com/  The traditional Swagger view of this documentation can be found here:   - https://app.swaggerhub.com/apis-docs/FrankieFinancial/kycutility  ------   Sandbox base URL is:   - https://api.demo.frankiefinancial.io/compliance/v1.2      - We do have an old sandbox at https://sandbox.frankiefinancial.com/compliance/v1.2 but this has been retired.    - All calls are the same as production, only with canned data.     - Full Swagger definition, along with test data for playing in the sandbox can be obtained once initial commercial discussions have commenced.    - Production and optional UAT access will be opened up only to those with a signed commercial contract.    ------   Contact us at hello@frankiefinancial.com to speak with a sales rep about issuing a Customer ID and Sandbox api key. 
 *
 * The version of the OpenAPI document: 1.5.3
 * Contact: dev-support@frankiefinancial.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package org.openapitools.client.model;

import java.util.Objects;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;
import java.time.OffsetDateTime;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.UUID;
import org.openapitools.client.model.EntityProfileCheckResultMessage;
import org.openapitools.client.model.EntityProfileItemMatchResultObject;
import org.openapitools.client.model.EntityProfileKYCMatchResultObject;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonArray;
import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;
import com.google.gson.TypeAdapterFactory;
import com.google.gson.reflect.TypeToken;
import com.google.gson.TypeAdapter;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;

import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import org.openapitools.client.JSON;

/**
 * Contains the results of a check against an entity profile.   The entityProfileResult will be returned instead of a checkSummary to provide the full details of the verification process. 
 */
@javax.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen", date = "2024-10-12T11:57:14.064522-04:00[America/New_York]", comments = "Generator version: 7.9.0")
public class EntityProfileResultObject {
  public static final String SERIALIZED_NAME_ACTION_RECOMMENDED = "actionRecommended";
  @SerializedName(SERIALIZED_NAME_ACTION_RECOMMENDED)
  private String actionRecommended;

  public static final String SERIALIZED_NAME_ADDRESS_RESULTS = "addressResults";
  @SerializedName(SERIALIZED_NAME_ADDRESS_RESULTS)
  private Map<String, EntityProfileItemMatchResultObject> addressResults = new HashMap<>();

  public static final String SERIALIZED_NAME_CHECK_ID = "checkId";
  @SerializedName(SERIALIZED_NAME_CHECK_ID)
  private UUID checkId;

  public static final String SERIALIZED_NAME_CHECK_RESULTS = "checkResults";
  @SerializedName(SERIALIZED_NAME_CHECK_RESULTS)
  private List<EntityProfileCheckResultMessage> checkResults = new ArrayList<>();

  public static final String SERIALIZED_NAME_CHECK_TYPE = "checkType";
  @SerializedName(SERIALIZED_NAME_CHECK_TYPE)
  private String checkType;

  public static final String SERIALIZED_NAME_CREDIT_HEADER_FAILURES = "creditHeaderFailures";
  @SerializedName(SERIALIZED_NAME_CREDIT_HEADER_FAILURES)
  private List<String> creditHeaderFailures = new ArrayList<>();

  public static final String SERIALIZED_NAME_DOCUMENT_RESULTS = "documentResults";
  @SerializedName(SERIALIZED_NAME_DOCUMENT_RESULTS)
  private Map<String, EntityProfileItemMatchResultObject> documentResults = new HashMap<>();

  public static final String SERIALIZED_NAME_ENTITY_ID = "entityId";
  @SerializedName(SERIALIZED_NAME_ENTITY_ID)
  private UUID entityId;

  public static final String SERIALIZED_NAME_ISSUE_LIST = "issueList";
  @SerializedName(SERIALIZED_NAME_ISSUE_LIST)
  private List<String> issueList = new ArrayList<>();

  public static final String SERIALIZED_NAME_KYC_RESULTS = "kycResults";
  @SerializedName(SERIALIZED_NAME_KYC_RESULTS)
  private List<EntityProfileKYCMatchResultObject> kycResults = new ArrayList<>();

  public static final String SERIALIZED_NAME_LATEST_CHECK_DATE = "latestCheckDate";
  @SerializedName(SERIALIZED_NAME_LATEST_CHECK_DATE)
  private OffsetDateTime latestCheckDate;

  public static final String SERIALIZED_NAME_MANUAL_INTERVENTION = "manualIntervention";
  @SerializedName(SERIALIZED_NAME_MANUAL_INTERVENTION)
  private Boolean manualIntervention;

  public static final String SERIALIZED_NAME_POLICY_NAME = "policyName";
  @SerializedName(SERIALIZED_NAME_POLICY_NAME)
  private String policyName;

  public static final String SERIALIZED_NAME_PROFILE_NAME = "profileName";
  @SerializedName(SERIALIZED_NAME_PROFILE_NAME)
  private String profileName;

  public static final String SERIALIZED_NAME_RESOLVER_RECOMMENDED = "resolverRecommended";
  @SerializedName(SERIALIZED_NAME_RESOLVER_RECOMMENDED)
  private String resolverRecommended;

  public static final String SERIALIZED_NAME_RISK_LEVEL = "riskLevel";
  @SerializedName(SERIALIZED_NAME_RISK_LEVEL)
  private String riskLevel;

  public static final String SERIALIZED_NAME_RISK_POLICY = "riskPolicy";
  @SerializedName(SERIALIZED_NAME_RISK_POLICY)
  private String riskPolicy;

  public EntityProfileResultObject() {
  }

  public EntityProfileResultObject actionRecommended(String actionRecommended) {
    this.actionRecommended = actionRecommended;
    return this;
  }

  /**
   * The recommended onboarding action for this entity after the profile check this result refers to. The action can also be an entity state set by you. - UNCHECKED: New entity with no checks applied - PASS - FAIL - PASS_MANUAL: Manual intervention was applied to achieve a pass - FAIL_MANUAL: Manual intervention was applied but the entity still fails - REFER: Manual intervention required - WAIT: Externally applied state, waiting for more entity details - ARCHIVED: Externally applied state, entity hidden from on onboarding list - INACTIVE: Externally applied state, entity hidden from on onboarding list, indexes and further changes will be blocked. 
   * @return actionRecommended
   */
  @javax.annotation.Nullable
  public String getActionRecommended() {
    return actionRecommended;
  }

  public void setActionRecommended(String actionRecommended) {
    this.actionRecommended = actionRecommended;
  }


  public EntityProfileResultObject addressResults(Map<String, EntityProfileItemMatchResultObject> addressResults) {
    this.addressResults = addressResults;
    return this;
  }

  public EntityProfileResultObject putAddressResultsItem(String key, EntityProfileItemMatchResultObject addressResultsItem) {
    if (this.addressResults == null) {
      this.addressResults = new HashMap<>();
    }
    this.addressResults.put(key, addressResultsItem);
    return this;
  }

  /**
   * KYC match counts for each checked address, whether matched or not. The keys in this map are the address IDs. The match type in the value will be either \&quot;curr_addr\&quot; or \&quot;prev_addr\&quot;. The resultant structure would look like:      \&quot;addressResults\&quot;: {       \&quot;addressId\&quot;: {         \&quot;matchType\&quot;: \&quot;curr_addr\&quot;,         \&quot;matchCount\&quot;: 5,         \&quot;verified\&quot;: true       },       \&quot;addressId\&quot;: {         \&quot;matchType\&quot;: \&quot;prev_addr\&quot;,         \&quot;matchCount\&quot;: 5,         \&quot;verified\&quot;: true       }     } 
   * @return addressResults
   */
  @javax.annotation.Nullable
  public Map<String, EntityProfileItemMatchResultObject> getAddressResults() {
    return addressResults;
  }

  public void setAddressResults(Map<String, EntityProfileItemMatchResultObject> addressResults) {
    this.addressResults = addressResults;
  }


  public EntityProfileResultObject checkId(UUID checkId) {
    this.checkId = checkId;
    return this;
  }

  /**
   * Unique identifier for every check/comparison/verification. Make sure you reference this ID whenever updating check details. This ID will also be used when pushing check results back to you.
   * @return checkId
   */
  @javax.annotation.Nullable
  public UUID getCheckId() {
    return checkId;
  }

  public void setCheckId(UUID checkId) {
    this.checkId = checkId;
  }


  public EntityProfileResultObject checkResults(List<EntityProfileCheckResultMessage> checkResults) {
    this.checkResults = checkResults;
    return this;
  }

  public EntityProfileResultObject addCheckResultsItem(EntityProfileCheckResultMessage checkResultsItem) {
    if (this.checkResults == null) {
      this.checkResults = new ArrayList<>();
    }
    this.checkResults.add(checkResultsItem);
    return this;
  }

  /**
   * The basic result for each check type required for the profile.  The results are listed in the order they are run so you can also see how far progressed through a check process you are. 
   * @return checkResults
   */
  @javax.annotation.Nullable
  public List<EntityProfileCheckResultMessage> getCheckResults() {
    return checkResults;
  }

  public void setCheckResults(List<EntityProfileCheckResultMessage> checkResults) {
    this.checkResults = checkResults;
  }


  public EntityProfileResultObject checkType(String checkType) {
    this.checkType = checkType;
    return this;
  }

  /**
   * Comma separated list of checks required for the entity profile.
   * @return checkType
   */
  @javax.annotation.Nullable
  public String getCheckType() {
    return checkType;
  }

  public void setCheckType(String checkType) {
    this.checkType = checkType;
  }


  public EntityProfileResultObject creditHeaderFailures(List<String> creditHeaderFailures) {
    this.creditHeaderFailures = creditHeaderFailures;
    return this;
  }

  public EntityProfileResultObject addCreditHeaderFailuresItem(String creditHeaderFailuresItem) {
    if (this.creditHeaderFailures == null) {
      this.creditHeaderFailures = new ArrayList<>();
    }
    this.creditHeaderFailures.add(creditHeaderFailuresItem);
    return this;
  }

  /**
   * List of vendors from failed credit header sources.
   * @return creditHeaderFailures
   */
  @javax.annotation.Nullable
  public List<String> getCreditHeaderFailures() {
    return creditHeaderFailures;
  }

  public void setCreditHeaderFailures(List<String> creditHeaderFailures) {
    this.creditHeaderFailures = creditHeaderFailures;
  }


  public EntityProfileResultObject documentResults(Map<String, EntityProfileItemMatchResultObject> documentResults) {
    this.documentResults = documentResults;
    return this;
  }

  public EntityProfileResultObject putDocumentResultsItem(String key, EntityProfileItemMatchResultObject documentResultsItem) {
    if (this.documentResults == null) {
      this.documentResults = new HashMap<>();
    }
    this.documentResults.put(key, documentResultsItem);
    return this;
  }

  /**
   * KYC match counts for each checked document, whether matched or not. The keys in this map are the document IDs. The match type in the value will be either \&quot;gov_id\&quot; or \&quot;other_id\&quot;. The resultant structure would look like:  documentResults: {     \&quot;documentId\&quot; : {       \&quot;matchType\&quot;: \&quot;gov_id\&quot;,       \&quot;matchCount\&quot;: 5,       \&quot;verified\&quot;: true     },     \&quot;documentId\&quot;: {       \&quot;matchType\&quot;: \&quot;other_id\&quot;,       \&quot;matchCount\&quot;: 5,       \&quot;verified\&quot;: true     } } 
   * @return documentResults
   */
  @javax.annotation.Nullable
  public Map<String, EntityProfileItemMatchResultObject> getDocumentResults() {
    return documentResults;
  }

  public void setDocumentResults(Map<String, EntityProfileItemMatchResultObject> documentResults) {
    this.documentResults = documentResults;
  }


  public EntityProfileResultObject entityId(UUID entityId) {
    this.entityId = entityId;
    return this;
  }

  /**
   * Unique ID for the entity. 
   * @return entityId
   */
  @javax.annotation.Nullable
  public UUID getEntityId() {
    return entityId;
  }

  public void setEntityId(UUID entityId) {
    this.entityId = entityId;
  }


  public EntityProfileResultObject issueList(List<String> issueList) {
    this.issueList = issueList;
    return this;
  }

  public EntityProfileResultObject addIssueListItem(String issueListItem) {
    if (this.issueList == null) {
      this.issueList = new ArrayList<>();
    }
    this.issueList.add(issueListItem);
    return this;
  }

  /**
   * Get issueList
   * @return issueList
   */
  @javax.annotation.Nullable
  public List<String> getIssueList() {
    return issueList;
  }

  public void setIssueList(List<String> issueList) {
    this.issueList = issueList;
  }


  public EntityProfileResultObject kycResults(List<EntityProfileKYCMatchResultObject> kycResults) {
    this.kycResults = kycResults;
    return this;
  }

  public EntityProfileResultObject addKycResultsItem(EntityProfileKYCMatchResultObject kycResultsItem) {
    if (this.kycResults == null) {
      this.kycResults = new ArrayList<>();
    }
    this.kycResults.add(kycResultsItem);
    return this;
  }

  /**
   * Summary of KYC match counts.
   * @return kycResults
   */
  @javax.annotation.Nullable
  public List<EntityProfileKYCMatchResultObject> getKycResults() {
    return kycResults;
  }

  public void setKycResults(List<EntityProfileKYCMatchResultObject> kycResults) {
    this.kycResults = kycResults;
  }


  public EntityProfileResultObject latestCheckDate(OffsetDateTime latestCheckDate) {
    this.latestCheckDate = latestCheckDate;
    return this;
  }

  /**
   * The date and time of the last check that contributed to this result.
   * @return latestCheckDate
   */
  @javax.annotation.Nullable
  public OffsetDateTime getLatestCheckDate() {
    return latestCheckDate;
  }

  public void setLatestCheckDate(OffsetDateTime latestCheckDate) {
    this.latestCheckDate = latestCheckDate;
  }


  public EntityProfileResultObject manualIntervention(Boolean manualIntervention) {
    this.manualIntervention = manualIntervention;
    return this;
  }

  /**
   * Indicates if any manual actions have been involved in the check result.
   * @return manualIntervention
   */
  @javax.annotation.Nullable
  public Boolean getManualIntervention() {
    return manualIntervention;
  }

  public void setManualIntervention(Boolean manualIntervention) {
    this.manualIntervention = manualIntervention;
  }


  public EntityProfileResultObject policyName(String policyName) {
    this.policyName = policyName;
    return this;
  }

  /**
   * The name of the policy within the profile used for this check. This may or may not incorporate the &#39;riskPolicy&#39; that is also an attribute in this object.
   * @return policyName
   */
  @javax.annotation.Nullable
  public String getPolicyName() {
    return policyName;
  }

  public void setPolicyName(String policyName) {
    this.policyName = policyName;
  }


  public EntityProfileResultObject profileName(String profileName) {
    this.profileName = profileName;
    return this;
  }

  /**
   * The name of the profile used for this check.
   * @return profileName
   */
  @javax.annotation.Nullable
  public String getProfileName() {
    return profileName;
  }

  public void setProfileName(String profileName) {
    this.profileName = profileName;
  }


  public EntityProfileResultObject resolverRecommended(String resolverRecommended) {
    this.resolverRecommended = resolverRecommended;
    return this;
  }

  /**
   * Workflow hint by arrangement with Frankie
   * @return resolverRecommended
   */
  @javax.annotation.Nullable
  public String getResolverRecommended() {
    return resolverRecommended;
  }

  public void setResolverRecommended(String resolverRecommended) {
    this.resolverRecommended = resolverRecommended;
  }


  public EntityProfileResultObject riskLevel(String riskLevel) {
    this.riskLevel = riskLevel;
    return this;
  }

  /**
   * Risk level. One of:  - LOW,  - MEDIUM,  - HIGH,  - UACCEPTABLE  - or UNKNOWN 
   * @return riskLevel
   */
  @javax.annotation.Nullable
  public String getRiskLevel() {
    return riskLevel;
  }

  public void setRiskLevel(String riskLevel) {
    this.riskLevel = riskLevel;
  }


  public EntityProfileResultObject riskPolicy(String riskPolicy) {
    this.riskPolicy = riskPolicy;
    return this;
  }

  /**
   * Risk policy. Contents depend on account configuration but would typically be one of:  - SDD,  - CDD,  - EDD  - or FAIL 
   * @return riskPolicy
   */
  @javax.annotation.Nullable
  public String getRiskPolicy() {
    return riskPolicy;
  }

  public void setRiskPolicy(String riskPolicy) {
    this.riskPolicy = riskPolicy;
  }



  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    EntityProfileResultObject entityProfileResultObject = (EntityProfileResultObject) o;
    return Objects.equals(this.actionRecommended, entityProfileResultObject.actionRecommended) &&
        Objects.equals(this.addressResults, entityProfileResultObject.addressResults) &&
        Objects.equals(this.checkId, entityProfileResultObject.checkId) &&
        Objects.equals(this.checkResults, entityProfileResultObject.checkResults) &&
        Objects.equals(this.checkType, entityProfileResultObject.checkType) &&
        Objects.equals(this.creditHeaderFailures, entityProfileResultObject.creditHeaderFailures) &&
        Objects.equals(this.documentResults, entityProfileResultObject.documentResults) &&
        Objects.equals(this.entityId, entityProfileResultObject.entityId) &&
        Objects.equals(this.issueList, entityProfileResultObject.issueList) &&
        Objects.equals(this.kycResults, entityProfileResultObject.kycResults) &&
        Objects.equals(this.latestCheckDate, entityProfileResultObject.latestCheckDate) &&
        Objects.equals(this.manualIntervention, entityProfileResultObject.manualIntervention) &&
        Objects.equals(this.policyName, entityProfileResultObject.policyName) &&
        Objects.equals(this.profileName, entityProfileResultObject.profileName) &&
        Objects.equals(this.resolverRecommended, entityProfileResultObject.resolverRecommended) &&
        Objects.equals(this.riskLevel, entityProfileResultObject.riskLevel) &&
        Objects.equals(this.riskPolicy, entityProfileResultObject.riskPolicy);
  }

  @Override
  public int hashCode() {
    return Objects.hash(actionRecommended, addressResults, checkId, checkResults, checkType, creditHeaderFailures, documentResults, entityId, issueList, kycResults, latestCheckDate, manualIntervention, policyName, profileName, resolverRecommended, riskLevel, riskPolicy);
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class EntityProfileResultObject {\n");
    sb.append("    actionRecommended: ").append(toIndentedString(actionRecommended)).append("\n");
    sb.append("    addressResults: ").append(toIndentedString(addressResults)).append("\n");
    sb.append("    checkId: ").append(toIndentedString(checkId)).append("\n");
    sb.append("    checkResults: ").append(toIndentedString(checkResults)).append("\n");
    sb.append("    checkType: ").append(toIndentedString(checkType)).append("\n");
    sb.append("    creditHeaderFailures: ").append(toIndentedString(creditHeaderFailures)).append("\n");
    sb.append("    documentResults: ").append(toIndentedString(documentResults)).append("\n");
    sb.append("    entityId: ").append(toIndentedString(entityId)).append("\n");
    sb.append("    issueList: ").append(toIndentedString(issueList)).append("\n");
    sb.append("    kycResults: ").append(toIndentedString(kycResults)).append("\n");
    sb.append("    latestCheckDate: ").append(toIndentedString(latestCheckDate)).append("\n");
    sb.append("    manualIntervention: ").append(toIndentedString(manualIntervention)).append("\n");
    sb.append("    policyName: ").append(toIndentedString(policyName)).append("\n");
    sb.append("    profileName: ").append(toIndentedString(profileName)).append("\n");
    sb.append("    resolverRecommended: ").append(toIndentedString(resolverRecommended)).append("\n");
    sb.append("    riskLevel: ").append(toIndentedString(riskLevel)).append("\n");
    sb.append("    riskPolicy: ").append(toIndentedString(riskPolicy)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }


  public static HashSet<String> openapiFields;
  public static HashSet<String> openapiRequiredFields;

  static {
    // a set of all properties/fields (JSON key names)
    openapiFields = new HashSet<String>();
    openapiFields.add("actionRecommended");
    openapiFields.add("addressResults");
    openapiFields.add("checkId");
    openapiFields.add("checkResults");
    openapiFields.add("checkType");
    openapiFields.add("creditHeaderFailures");
    openapiFields.add("documentResults");
    openapiFields.add("entityId");
    openapiFields.add("issueList");
    openapiFields.add("kycResults");
    openapiFields.add("latestCheckDate");
    openapiFields.add("manualIntervention");
    openapiFields.add("policyName");
    openapiFields.add("profileName");
    openapiFields.add("resolverRecommended");
    openapiFields.add("riskLevel");
    openapiFields.add("riskPolicy");

    // a set of required properties/fields (JSON key names)
    openapiRequiredFields = new HashSet<String>();
  }

  /**
   * Validates the JSON Element and throws an exception if issues found
   *
   * @param jsonElement JSON Element
   * @throws IOException if the JSON Element is invalid with respect to EntityProfileResultObject
   */
  public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      if (jsonElement == null) {
        if (!EntityProfileResultObject.openapiRequiredFields.isEmpty()) { // has required fields but JSON element is null
          throw new IllegalArgumentException(String.format("The required field(s) %s in EntityProfileResultObject is not found in the empty JSON string", EntityProfileResultObject.openapiRequiredFields.toString()));
        }
      }

      Set<Map.Entry<String, JsonElement>> entries = jsonElement.getAsJsonObject().entrySet();
      // check to see if the JSON string contains additional fields
      for (Map.Entry<String, JsonElement> entry : entries) {
        if (!EntityProfileResultObject.openapiFields.contains(entry.getKey())) {
          throw new IllegalArgumentException(String.format("The field `%s` in the JSON string is not defined in the `EntityProfileResultObject` properties. JSON: %s", entry.getKey(), jsonElement.toString()));
        }
      }
        JsonObject jsonObj = jsonElement.getAsJsonObject();
      if ((jsonObj.get("actionRecommended") != null && !jsonObj.get("actionRecommended").isJsonNull()) && !jsonObj.get("actionRecommended").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `actionRecommended` to be a primitive type in the JSON string but got `%s`", jsonObj.get("actionRecommended").toString()));
      }
      if ((jsonObj.get("checkId") != null && !jsonObj.get("checkId").isJsonNull()) && !jsonObj.get("checkId").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `checkId` to be a primitive type in the JSON string but got `%s`", jsonObj.get("checkId").toString()));
      }
      if (jsonObj.get("checkResults") != null && !jsonObj.get("checkResults").isJsonNull()) {
        JsonArray jsonArraycheckResults = jsonObj.getAsJsonArray("checkResults");
        if (jsonArraycheckResults != null) {
          // ensure the json data is an array
          if (!jsonObj.get("checkResults").isJsonArray()) {
            throw new IllegalArgumentException(String.format("Expected the field `checkResults` to be an array in the JSON string but got `%s`", jsonObj.get("checkResults").toString()));
          }

          // validate the optional field `checkResults` (array)
          for (int i = 0; i < jsonArraycheckResults.size(); i++) {
            EntityProfileCheckResultMessage.validateJsonElement(jsonArraycheckResults.get(i));
          };
        }
      }
      if ((jsonObj.get("checkType") != null && !jsonObj.get("checkType").isJsonNull()) && !jsonObj.get("checkType").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `checkType` to be a primitive type in the JSON string but got `%s`", jsonObj.get("checkType").toString()));
      }
      // ensure the optional json data is an array if present
      if (jsonObj.get("creditHeaderFailures") != null && !jsonObj.get("creditHeaderFailures").isJsonNull() && !jsonObj.get("creditHeaderFailures").isJsonArray()) {
        throw new IllegalArgumentException(String.format("Expected the field `creditHeaderFailures` to be an array in the JSON string but got `%s`", jsonObj.get("creditHeaderFailures").toString()));
      }
      if ((jsonObj.get("entityId") != null && !jsonObj.get("entityId").isJsonNull()) && !jsonObj.get("entityId").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `entityId` to be a primitive type in the JSON string but got `%s`", jsonObj.get("entityId").toString()));
      }
      // ensure the optional json data is an array if present
      if (jsonObj.get("issueList") != null && !jsonObj.get("issueList").isJsonNull() && !jsonObj.get("issueList").isJsonArray()) {
        throw new IllegalArgumentException(String.format("Expected the field `issueList` to be an array in the JSON string but got `%s`", jsonObj.get("issueList").toString()));
      }
      if (jsonObj.get("kycResults") != null && !jsonObj.get("kycResults").isJsonNull()) {
        JsonArray jsonArraykycResults = jsonObj.getAsJsonArray("kycResults");
        if (jsonArraykycResults != null) {
          // ensure the json data is an array
          if (!jsonObj.get("kycResults").isJsonArray()) {
            throw new IllegalArgumentException(String.format("Expected the field `kycResults` to be an array in the JSON string but got `%s`", jsonObj.get("kycResults").toString()));
          }

          // validate the optional field `kycResults` (array)
          for (int i = 0; i < jsonArraykycResults.size(); i++) {
            EntityProfileKYCMatchResultObject.validateJsonElement(jsonArraykycResults.get(i));
          };
        }
      }
      if ((jsonObj.get("policyName") != null && !jsonObj.get("policyName").isJsonNull()) && !jsonObj.get("policyName").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `policyName` to be a primitive type in the JSON string but got `%s`", jsonObj.get("policyName").toString()));
      }
      if ((jsonObj.get("profileName") != null && !jsonObj.get("profileName").isJsonNull()) && !jsonObj.get("profileName").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `profileName` to be a primitive type in the JSON string but got `%s`", jsonObj.get("profileName").toString()));
      }
      if ((jsonObj.get("resolverRecommended") != null && !jsonObj.get("resolverRecommended").isJsonNull()) && !jsonObj.get("resolverRecommended").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `resolverRecommended` to be a primitive type in the JSON string but got `%s`", jsonObj.get("resolverRecommended").toString()));
      }
      if ((jsonObj.get("riskLevel") != null && !jsonObj.get("riskLevel").isJsonNull()) && !jsonObj.get("riskLevel").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `riskLevel` to be a primitive type in the JSON string but got `%s`", jsonObj.get("riskLevel").toString()));
      }
      if ((jsonObj.get("riskPolicy") != null && !jsonObj.get("riskPolicy").isJsonNull()) && !jsonObj.get("riskPolicy").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `riskPolicy` to be a primitive type in the JSON string but got `%s`", jsonObj.get("riskPolicy").toString()));
      }
  }

  public static class CustomTypeAdapterFactory implements TypeAdapterFactory {
    @SuppressWarnings("unchecked")
    @Override
    public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
       if (!EntityProfileResultObject.class.isAssignableFrom(type.getRawType())) {
         return null; // this class only serializes 'EntityProfileResultObject' and its subtypes
       }
       final TypeAdapter<JsonElement> elementAdapter = gson.getAdapter(JsonElement.class);
       final TypeAdapter<EntityProfileResultObject> thisAdapter
                        = gson.getDelegateAdapter(this, TypeToken.get(EntityProfileResultObject.class));

       return (TypeAdapter<T>) new TypeAdapter<EntityProfileResultObject>() {
           @Override
           public void write(JsonWriter out, EntityProfileResultObject value) throws IOException {
             JsonObject obj = thisAdapter.toJsonTree(value).getAsJsonObject();
             elementAdapter.write(out, obj);
           }

           @Override
           public EntityProfileResultObject read(JsonReader in) throws IOException {
             JsonElement jsonElement = elementAdapter.read(in);
             validateJsonElement(jsonElement);
             return thisAdapter.fromJsonTree(jsonElement);
           }

       }.nullSafe();
    }
  }

  /**
   * Create an instance of EntityProfileResultObject given an JSON string
   *
   * @param jsonString JSON string
   * @return An instance of EntityProfileResultObject
   * @throws IOException if the JSON string is invalid with respect to EntityProfileResultObject
   */
  public static EntityProfileResultObject fromJson(String jsonString) throws IOException {
    return JSON.getGson().fromJson(jsonString, EntityProfileResultObject.class);
  }

  /**
   * Convert an instance of EntityProfileResultObject to an JSON string
   *
   * @return JSON string
   */
  public String toJson() {
    return JSON.getGson().toJson(this);
  }
}

