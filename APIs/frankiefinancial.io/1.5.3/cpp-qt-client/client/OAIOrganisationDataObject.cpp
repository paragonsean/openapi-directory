/**
 * Frankie Financial API
 * ------   This API allows developers to integrate the Frankie Financial Compliance Utility into their applications. The API allows:   - Checking name, address, date of birth against national databases   - Validating Australian driver's licences, passports, medicare, visas and other Australian national ID documents   - Validating Australian electricity bills   - Validating NZ driver's licences   - Validating Chinese bank cards and national ID card   - Validating International passports and national ID documents   - PEP, Sanctions, Watchlist and adverse media checking   - Australian visa checks    - Fraud list and fraud background checks   - ID validation and selfie check comparisons.    ------     Industry specific services    - Comparing Australian electricity retailers for a better deal.  ------     KYB specific services    - Query organisation ownership   - Perform KYC & AML checks on shareholders, beneficial owners and office bearers.   - Query credit score and credit reports   - International company searches   - International company profiles    ------   The full version of this documentation along with supplemental articles can be found here:   - https://apidocs.frankiefinancial.com/  The traditional Swagger view of this documentation can be found here:   - https://app.swaggerhub.com/apis-docs/FrankieFinancial/kycutility  ------   Sandbox base URL is:   - https://api.demo.frankiefinancial.io/compliance/v1.2      - We do have an old sandbox at https://sandbox.frankiefinancial.com/compliance/v1.2 but this has been retired.    - All calls are the same as production, only with canned data.     - Full Swagger definition, along with test data for playing in the sandbox can be obtained once initial commercial discussions have commenced.    - Production and optional UAT access will be opened up only to those with a signed commercial contract.    ------   Contact us at hello@frankiefinancial.com to speak with a sales rep about issuing a Customer ID and Sandbox api key. 
 *
 * The version of the OpenAPI document: 1.5.3
 * Contact: dev-support@frankiefinancial.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

#include "OAIOrganisationDataObject.h"

#include <QDebug>
#include <QJsonArray>
#include <QJsonDocument>
#include <QObject>

#include "OAIHelpers.h"

namespace OpenAPI {

OAIOrganisationDataObject::OAIOrganisationDataObject(QString json) {
    this->initializeModel();
    this->fromJson(json);
}

OAIOrganisationDataObject::OAIOrganisationDataObject() {
    this->initializeModel();
}

OAIOrganisationDataObject::~OAIOrganisationDataObject() {}

void OAIOrganisationDataObject::initializeModel() {

    m_adverse_credit_data_present_isSet = false;
    m_adverse_credit_data_present_isValid = false;

    m_r_class_isSet = false;
    m_r_class_isValid = false;

    m_disclosing_entity_indicator_isSet = false;
    m_disclosing_entity_indicator_isValid = false;

    m_includes_non_beneficially_held_isSet = false;
    m_includes_non_beneficially_held_isValid = false;

    m_kyc_customer_type_isSet = false;
    m_kyc_customer_type_isValid = false;

    m_last_check_date_isSet = false;
    m_last_check_date_isValid = false;

    m_ownership_resolved_isSet = false;
    m_ownership_resolved_isValid = false;

    m_registered_name_isSet = false;
    m_registered_name_isValid = false;

    m_registration_isSet = false;
    m_registration_isValid = false;

    m_share_structure_isSet = false;
    m_share_structure_isValid = false;

    m_start_date_isSet = false;
    m_start_date_isValid = false;

    m_status_isSet = false;
    m_status_isValid = false;

    m_subclass_isSet = false;
    m_subclass_isValid = false;

    m_type_isSet = false;
    m_type_isValid = false;
}

void OAIOrganisationDataObject::fromJson(QString jsonString) {
    QByteArray array(jsonString.toStdString().c_str());
    QJsonDocument doc = QJsonDocument::fromJson(array);
    QJsonObject jsonObject = doc.object();
    this->fromJsonObject(jsonObject);
}

void OAIOrganisationDataObject::fromJsonObject(QJsonObject json) {

    m_adverse_credit_data_present_isValid = ::OpenAPI::fromJsonValue(m_adverse_credit_data_present, json[QString("adverseCreditDataPresent")]);
    m_adverse_credit_data_present_isSet = !json[QString("adverseCreditDataPresent")].isNull() && m_adverse_credit_data_present_isValid;

    m_r_class_isValid = ::OpenAPI::fromJsonValue(m_r_class, json[QString("class")]);
    m_r_class_isSet = !json[QString("class")].isNull() && m_r_class_isValid;

    m_disclosing_entity_indicator_isValid = ::OpenAPI::fromJsonValue(m_disclosing_entity_indicator, json[QString("disclosingEntityIndicator")]);
    m_disclosing_entity_indicator_isSet = !json[QString("disclosingEntityIndicator")].isNull() && m_disclosing_entity_indicator_isValid;

    m_includes_non_beneficially_held_isValid = ::OpenAPI::fromJsonValue(m_includes_non_beneficially_held, json[QString("includesNonBeneficiallyHeld")]);
    m_includes_non_beneficially_held_isSet = !json[QString("includesNonBeneficiallyHeld")].isNull() && m_includes_non_beneficially_held_isValid;

    m_kyc_customer_type_isValid = ::OpenAPI::fromJsonValue(m_kyc_customer_type, json[QString("kycCustomerType")]);
    m_kyc_customer_type_isSet = !json[QString("kycCustomerType")].isNull() && m_kyc_customer_type_isValid;

    m_last_check_date_isValid = ::OpenAPI::fromJsonValue(m_last_check_date, json[QString("lastCheckDate")]);
    m_last_check_date_isSet = !json[QString("lastCheckDate")].isNull() && m_last_check_date_isValid;

    m_ownership_resolved_isValid = ::OpenAPI::fromJsonValue(m_ownership_resolved, json[QString("ownershipResolved")]);
    m_ownership_resolved_isSet = !json[QString("ownershipResolved")].isNull() && m_ownership_resolved_isValid;

    m_registered_name_isValid = ::OpenAPI::fromJsonValue(m_registered_name, json[QString("registeredName")]);
    m_registered_name_isSet = !json[QString("registeredName")].isNull() && m_registered_name_isValid;

    m_registration_isValid = ::OpenAPI::fromJsonValue(m_registration, json[QString("registration")]);
    m_registration_isSet = !json[QString("registration")].isNull() && m_registration_isValid;

    m_share_structure_isValid = ::OpenAPI::fromJsonValue(m_share_structure, json[QString("shareStructure")]);
    m_share_structure_isSet = !json[QString("shareStructure")].isNull() && m_share_structure_isValid;

    m_start_date_isValid = ::OpenAPI::fromJsonValue(m_start_date, json[QString("startDate")]);
    m_start_date_isSet = !json[QString("startDate")].isNull() && m_start_date_isValid;

    m_status_isValid = ::OpenAPI::fromJsonValue(m_status, json[QString("status")]);
    m_status_isSet = !json[QString("status")].isNull() && m_status_isValid;

    m_subclass_isValid = ::OpenAPI::fromJsonValue(m_subclass, json[QString("subclass")]);
    m_subclass_isSet = !json[QString("subclass")].isNull() && m_subclass_isValid;

    m_type_isValid = ::OpenAPI::fromJsonValue(m_type, json[QString("type")]);
    m_type_isSet = !json[QString("type")].isNull() && m_type_isValid;
}

QString OAIOrganisationDataObject::asJson() const {
    QJsonObject obj = this->asJsonObject();
    QJsonDocument doc(obj);
    QByteArray bytes = doc.toJson();
    return QString(bytes);
}

QJsonObject OAIOrganisationDataObject::asJsonObject() const {
    QJsonObject obj;
    if (m_adverse_credit_data_present_isSet) {
        obj.insert(QString("adverseCreditDataPresent"), ::OpenAPI::toJsonValue(m_adverse_credit_data_present));
    }
    if (m_r_class.isSet()) {
        obj.insert(QString("class"), ::OpenAPI::toJsonValue(m_r_class));
    }
    if (m_disclosing_entity_indicator_isSet) {
        obj.insert(QString("disclosingEntityIndicator"), ::OpenAPI::toJsonValue(m_disclosing_entity_indicator));
    }
    if (m_includes_non_beneficially_held_isSet) {
        obj.insert(QString("includesNonBeneficiallyHeld"), ::OpenAPI::toJsonValue(m_includes_non_beneficially_held));
    }
    if (m_kyc_customer_type_isSet) {
        obj.insert(QString("kycCustomerType"), ::OpenAPI::toJsonValue(m_kyc_customer_type));
    }
    if (m_last_check_date_isSet) {
        obj.insert(QString("lastCheckDate"), ::OpenAPI::toJsonValue(m_last_check_date));
    }
    if (m_ownership_resolved_isSet) {
        obj.insert(QString("ownershipResolved"), ::OpenAPI::toJsonValue(m_ownership_resolved));
    }
    if (m_registered_name_isSet) {
        obj.insert(QString("registeredName"), ::OpenAPI::toJsonValue(m_registered_name));
    }
    if (m_registration.isSet()) {
        obj.insert(QString("registration"), ::OpenAPI::toJsonValue(m_registration));
    }
    if (m_share_structure.size() > 0) {
        obj.insert(QString("shareStructure"), ::OpenAPI::toJsonValue(m_share_structure));
    }
    if (m_start_date_isSet) {
        obj.insert(QString("startDate"), ::OpenAPI::toJsonValue(m_start_date));
    }
    if (m_status.isSet()) {
        obj.insert(QString("status"), ::OpenAPI::toJsonValue(m_status));
    }
    if (m_subclass.isSet()) {
        obj.insert(QString("subclass"), ::OpenAPI::toJsonValue(m_subclass));
    }
    if (m_type.isSet()) {
        obj.insert(QString("type"), ::OpenAPI::toJsonValue(m_type));
    }
    return obj;
}

bool OAIOrganisationDataObject::isAdverseCreditDataPresent() const {
    return m_adverse_credit_data_present;
}
void OAIOrganisationDataObject::setAdverseCreditDataPresent(const bool &adverse_credit_data_present) {
    m_adverse_credit_data_present = adverse_credit_data_present;
    m_adverse_credit_data_present_isSet = true;
}

bool OAIOrganisationDataObject::is_adverse_credit_data_present_Set() const{
    return m_adverse_credit_data_present_isSet;
}

bool OAIOrganisationDataObject::is_adverse_credit_data_present_Valid() const{
    return m_adverse_credit_data_present_isValid;
}

OAICodeDescription OAIOrganisationDataObject::getRClass() const {
    return m_r_class;
}
void OAIOrganisationDataObject::setRClass(const OAICodeDescription &r_class) {
    m_r_class = r_class;
    m_r_class_isSet = true;
}

bool OAIOrganisationDataObject::is_r_class_Set() const{
    return m_r_class_isSet;
}

bool OAIOrganisationDataObject::is_r_class_Valid() const{
    return m_r_class_isValid;
}

bool OAIOrganisationDataObject::isDisclosingEntityIndicator() const {
    return m_disclosing_entity_indicator;
}
void OAIOrganisationDataObject::setDisclosingEntityIndicator(const bool &disclosing_entity_indicator) {
    m_disclosing_entity_indicator = disclosing_entity_indicator;
    m_disclosing_entity_indicator_isSet = true;
}

bool OAIOrganisationDataObject::is_disclosing_entity_indicator_Set() const{
    return m_disclosing_entity_indicator_isSet;
}

bool OAIOrganisationDataObject::is_disclosing_entity_indicator_Valid() const{
    return m_disclosing_entity_indicator_isValid;
}

bool OAIOrganisationDataObject::isIncludesNonBeneficiallyHeld() const {
    return m_includes_non_beneficially_held;
}
void OAIOrganisationDataObject::setIncludesNonBeneficiallyHeld(const bool &includes_non_beneficially_held) {
    m_includes_non_beneficially_held = includes_non_beneficially_held;
    m_includes_non_beneficially_held_isSet = true;
}

bool OAIOrganisationDataObject::is_includes_non_beneficially_held_Set() const{
    return m_includes_non_beneficially_held_isSet;
}

bool OAIOrganisationDataObject::is_includes_non_beneficially_held_Valid() const{
    return m_includes_non_beneficially_held_isValid;
}

QString OAIOrganisationDataObject::getKycCustomerType() const {
    return m_kyc_customer_type;
}
void OAIOrganisationDataObject::setKycCustomerType(const QString &kyc_customer_type) {
    m_kyc_customer_type = kyc_customer_type;
    m_kyc_customer_type_isSet = true;
}

bool OAIOrganisationDataObject::is_kyc_customer_type_Set() const{
    return m_kyc_customer_type_isSet;
}

bool OAIOrganisationDataObject::is_kyc_customer_type_Valid() const{
    return m_kyc_customer_type_isValid;
}

QDate OAIOrganisationDataObject::getLastCheckDate() const {
    return m_last_check_date;
}
void OAIOrganisationDataObject::setLastCheckDate(const QDate &last_check_date) {
    m_last_check_date = last_check_date;
    m_last_check_date_isSet = true;
}

bool OAIOrganisationDataObject::is_last_check_date_Set() const{
    return m_last_check_date_isSet;
}

bool OAIOrganisationDataObject::is_last_check_date_Valid() const{
    return m_last_check_date_isValid;
}

bool OAIOrganisationDataObject::isOwnershipResolved() const {
    return m_ownership_resolved;
}
void OAIOrganisationDataObject::setOwnershipResolved(const bool &ownership_resolved) {
    m_ownership_resolved = ownership_resolved;
    m_ownership_resolved_isSet = true;
}

bool OAIOrganisationDataObject::is_ownership_resolved_Set() const{
    return m_ownership_resolved_isSet;
}

bool OAIOrganisationDataObject::is_ownership_resolved_Valid() const{
    return m_ownership_resolved_isValid;
}

QString OAIOrganisationDataObject::getRegisteredName() const {
    return m_registered_name;
}
void OAIOrganisationDataObject::setRegisteredName(const QString &registered_name) {
    m_registered_name = registered_name;
    m_registered_name_isSet = true;
}

bool OAIOrganisationDataObject::is_registered_name_Set() const{
    return m_registered_name_isSet;
}

bool OAIOrganisationDataObject::is_registered_name_Valid() const{
    return m_registered_name_isValid;
}

OAIOrganisationDataObject_registration OAIOrganisationDataObject::getRegistration() const {
    return m_registration;
}
void OAIOrganisationDataObject::setRegistration(const OAIOrganisationDataObject_registration &registration) {
    m_registration = registration;
    m_registration_isSet = true;
}

bool OAIOrganisationDataObject::is_registration_Set() const{
    return m_registration_isSet;
}

bool OAIOrganisationDataObject::is_registration_Valid() const{
    return m_registration_isValid;
}

QList<OAIShareStructureObject> OAIOrganisationDataObject::getShareStructure() const {
    return m_share_structure;
}
void OAIOrganisationDataObject::setShareStructure(const QList<OAIShareStructureObject> &share_structure) {
    m_share_structure = share_structure;
    m_share_structure_isSet = true;
}

bool OAIOrganisationDataObject::is_share_structure_Set() const{
    return m_share_structure_isSet;
}

bool OAIOrganisationDataObject::is_share_structure_Valid() const{
    return m_share_structure_isValid;
}

QDate OAIOrganisationDataObject::getStartDate() const {
    return m_start_date;
}
void OAIOrganisationDataObject::setStartDate(const QDate &start_date) {
    m_start_date = start_date;
    m_start_date_isSet = true;
}

bool OAIOrganisationDataObject::is_start_date_Set() const{
    return m_start_date_isSet;
}

bool OAIOrganisationDataObject::is_start_date_Valid() const{
    return m_start_date_isValid;
}

OAICodeDescription OAIOrganisationDataObject::getStatus() const {
    return m_status;
}
void OAIOrganisationDataObject::setStatus(const OAICodeDescription &status) {
    m_status = status;
    m_status_isSet = true;
}

bool OAIOrganisationDataObject::is_status_Set() const{
    return m_status_isSet;
}

bool OAIOrganisationDataObject::is_status_Valid() const{
    return m_status_isValid;
}

OAICodeDescription OAIOrganisationDataObject::getSubclass() const {
    return m_subclass;
}
void OAIOrganisationDataObject::setSubclass(const OAICodeDescription &subclass) {
    m_subclass = subclass;
    m_subclass_isSet = true;
}

bool OAIOrganisationDataObject::is_subclass_Set() const{
    return m_subclass_isSet;
}

bool OAIOrganisationDataObject::is_subclass_Valid() const{
    return m_subclass_isValid;
}

OAICodeDescription OAIOrganisationDataObject::getType() const {
    return m_type;
}
void OAIOrganisationDataObject::setType(const OAICodeDescription &type) {
    m_type = type;
    m_type_isSet = true;
}

bool OAIOrganisationDataObject::is_type_Set() const{
    return m_type_isSet;
}

bool OAIOrganisationDataObject::is_type_Valid() const{
    return m_type_isValid;
}

bool OAIOrganisationDataObject::isSet() const {
    bool isObjectUpdated = false;
    do {
        if (m_adverse_credit_data_present_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_r_class.isSet()) {
            isObjectUpdated = true;
            break;
        }

        if (m_disclosing_entity_indicator_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_includes_non_beneficially_held_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_kyc_customer_type_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_last_check_date_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_ownership_resolved_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_registered_name_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_registration.isSet()) {
            isObjectUpdated = true;
            break;
        }

        if (m_share_structure.size() > 0) {
            isObjectUpdated = true;
            break;
        }

        if (m_start_date_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_status.isSet()) {
            isObjectUpdated = true;
            break;
        }

        if (m_subclass.isSet()) {
            isObjectUpdated = true;
            break;
        }

        if (m_type.isSet()) {
            isObjectUpdated = true;
            break;
        }
    } while (false);
    return isObjectUpdated;
}

bool OAIOrganisationDataObject::isValid() const {
    // only required properties are required for the object to be considered valid
    return true;
}

} // namespace OpenAPI
