/**
 * Frankie Financial API
 * ------   This API allows developers to integrate the Frankie Financial Compliance Utility into their applications. The API allows:   - Checking name, address, date of birth against national databases   - Validating Australian driver's licences, passports, medicare, visas and other Australian national ID documents   - Validating Australian electricity bills   - Validating NZ driver's licences   - Validating Chinese bank cards and national ID card   - Validating International passports and national ID documents   - PEP, Sanctions, Watchlist and adverse media checking   - Australian visa checks    - Fraud list and fraud background checks   - ID validation and selfie check comparisons.    ------     Industry specific services    - Comparing Australian electricity retailers for a better deal.  ------     KYB specific services    - Query organisation ownership   - Perform KYC & AML checks on shareholders, beneficial owners and office bearers.   - Query credit score and credit reports   - International company searches   - International company profiles    ------   The full version of this documentation along with supplemental articles can be found here:   - https://apidocs.frankiefinancial.com/  The traditional Swagger view of this documentation can be found here:   - https://app.swaggerhub.com/apis-docs/FrankieFinancial/kycutility  ------   Sandbox base URL is:   - https://api.demo.frankiefinancial.io/compliance/v1.2      - We do have an old sandbox at https://sandbox.frankiefinancial.com/compliance/v1.2 but this has been retired.    - All calls are the same as production, only with canned data.     - Full Swagger definition, along with test data for playing in the sandbox can be obtained once initial commercial discussions have commenced.    - Production and optional UAT access will be opened up only to those with a signed commercial contract.    ------   Contact us at hello@frankiefinancial.com to speak with a sales rep about issuing a Customer ID and Sandbox api key. 
 *
 * The version of the OpenAPI document: 1.5.3
 * Contact: dev-support@frankiefinancial.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 *
 */


import ApiClient from "../ApiClient";
import AcceptedEntityResultObject from '../model/AcceptedEntityResultObject';
import BasicStatusResultObject from '../model/BasicStatusResultObject';
import CheckEntityCheckResultObject from '../model/CheckEntityCheckResultObject';
import CheckResultUpdateObject from '../model/CheckResultUpdateObject';
import EntityCheckDetailsObject from '../model/EntityCheckDetailsObject';
import EntityIDVDetailsObject from '../model/EntityIDVDetailsObject';
import EntityIDVResultObject from '../model/EntityIDVResultObject';
import EntityObject from '../model/EntityObject';
import EntityResultObject from '../model/EntityResultObject';
import EntitySearchResultObject from '../model/EntitySearchResultObject';
import ErrorObject from '../model/ErrorObject';

/**
* Entity service.
* @module api/EntityApi
* @version 1.5.3
*/
export default class EntityApi {

    /**
    * Constructs a new EntityApi. 
    * @alias module:api/EntityApi
    * @class
    * @param {module:ApiClient} [apiClient] Optional API client implementation to use,
    * default to {@link module:ApiClient#instance} if unspecified.
    */
    constructor(apiClient) {
        this.apiClient = apiClient || ApiClient.instance;
    }


    /**
     * Callback function to receive the result of the createCheckEntity operation.
     * @callback module:api/EntityApi~createCheckEntityCallback
     * @param {String} error Error message, if any.
     * @param {module:model/CheckEntityCheckResultObject} data The data returned by the service call.
     * @param {String} response The complete HTTP response.
     */

    /**
     * Create and Verify Entity
     * Create an entity object. An entity object can be used to simply store data around a given identity. You can attach ID documents, scans, PDFs, photos, videos, etc to the entity if you wish and these may be processed later (using the /scan function) to extract useful information. Or you can manually supply the  information if you choose.  If the entity is successfully created, take the details and documents provided, and set about verifying them all. So for example, you might extract:  * The name from the entity.name object * The address from the entity.address object * The DoB..  All documents that are attached to the entity will also be verified (if possible).  You can also specify the level of detail returned using the resultLevel parameter. You can choose \"summary\" or \"full\". For the \"profile\" check type you can also select \"simple\" to only get the entity profile result.  SPECIAL NOTE: A \"Full\" response includes details of all checks and how they map against each element, along with all the details of pep/sanctions/etc checks too.  Your account also needs to be configured to support a full response too (talk to your account manager for more information). If you're not configured for full responses, we'll only return summary level data regardless. 
     * @param {String} xFrankieCustomerID Customer ID issued by Frankie Financial. This will never change. Your API key, which is mapped to this identity, will change over time. 
     * @param {String} checkType When creating a new check, you need to define the checks you wish to run.    The checkType is make up of a comma separated list of the types of check you wish to run. The order of the requested checks is not important, they will be re-ordered by the service and in some cases, depending on your account configuration, may be skipped.    The validation that is performed on the requested checks is to:   - ensure the check type is known   - is suitable for the type of entity (no KYC for organisations)   - disallow manual (mKYC) check with any other kind of KYC   - disallow mixing the \"profile\" check with any other kind of check.  The supported check types are:  Profile:   - \"profile\": By arrangement with Frankie we will create a \"profile\" check type that applies checks according to a recipe that you assign to the entity from a predefined set of profiles.      The profile to use will be taken from the entity.entityProfile field if set, or be run through a set of configurable rules to determine which one to use.      Profiles provide a pre-defined combination of individual checkTypes (see the list below). But they offer a lot more besides, including rules for determining default settings, inbuilt data aging and other configurable features.   They also allow for a new result set top be returned that provides a more detailed and useful breakdown of the check/verification process.      Entity Profiles are a recent feature (since v1.4.0) but are now the default checkType to use with Frankie Financial.  **Individual Check Types**  Whilst we strongly recommend the use of the \"profile\" checktype, it does map of any combination of the types below. If you wish to use these individually, please contact developer support for more details on how to use these effectively.  Entity Checks - One of:   - \"one_plus\": Checks name, address and DoB against a minimum of 1 data source. (also known as a 1+1)   - \"two_plus\": Checks name, address and DoB against a minimum of 2 independent data sources (also known as a 2+2)  ID Checks - One of:   - \"id\": Checks all of the identity documents, but not necessarily the entity itself independently. Use this in conjunction with a one_plus or two_plus for more.   - \"visa\":    ID Validate - One of:   - \"idvalidate\": Checks to see if photo ID has had OCR scanning, ID document validation and photo comparison run against it. Can be used in conjunction with any of the KYC/ID/AML checks.    Manual Check:   - \"manual\": (mKYC) Checks user has a sufficient amount of operator verified ID and will then \"pass\" all Entity and ID related checks.    Fraud Checks - One or more of:   - \"fraudlist\": Checks to see if the identity appears on any known fraud lists. Should be run after KYC/ID checks have passed.   - \"fraudcheck\": Checks external ID services to see if details appear in fraud detection services (e.g. EmailAge or FraudNet)    PEP Checks - One of:   - \"pep\": Will only run PEP/Sanctions checks (no identity verification)   - \"pep_media\": Will run PEP/Sanctions checks, as well as watchlist and adverse media checks. (no identity verification)      * NOTE: These checks will ONLY run if either the KYC/ID checks have been run prior, or it is the only check requested.    Custom:   - By arrangement with Frankie you can define your own KYC check type.      This will allow you to set the minimum number of matches for:     - name      - date of birth     - address     - government id      This allows for alternatives to the \"standard\" two_plus or one_plus (note, these can be overridden too). 
     * @param {module:model/String} resultLevel How much detail we return.   Acceptable values are:   * simple - Only available with \"profile\" check type. Returns just an EntityProfileResultObject (which is also included for \"profile\" checks at the other result levels), and a CheckEntityCheckResultObjectEntityResult with just the entity details but no separate results.   * summary   * full - You need to have your account configured for this. 
     * @param {module:model/EntityCheckDetailsObject} entityDetails The entity and any associated / additional information to be checked
     * @param {Object} opts Optional parameters
     * @param {String} [xFrankieCustomerChildID] If, as a Frankie Customer, you are acting on behalf of your own customers, then you can populate this field with a Frankie-assigned ID.  Note: If using a CustomerChildID, you will also need a separate api_key for each child.  Any documents, checks, entities that are created when this field has been populated will now be tied to this CustomerID + CustomerChildID combination. Just as Customers cannot see data created by other Customers, so too a Customer's Children will not be able to see each other's data.  A Customer can see the documents/entities and checks of all their Children. 
     * @param {Number} [xFrankieBackground] If this header parameter is supplied and set to 1, then the request will not wait for the process to finish, and will return a 202 if there are no obvious errors in the input. The request will then run in the background and send a notification back to the customer. See out callback API for details on this.  See more details here:   https://apidocs.frankiefinancial.com/docs/asynchronous-calls-backgrounding-processes 
     * @param {module:api/EntityApi~createCheckEntityCallback} callback The callback function, accepting three arguments: error, data, response
     * data is of type: {@link module:model/CheckEntityCheckResultObject}
     */
    createCheckEntity(xFrankieCustomerID, checkType, resultLevel, entityDetails, opts, callback) {
      opts = opts || {};
      let postBody = entityDetails;
      // verify the required parameter 'xFrankieCustomerID' is set
      if (xFrankieCustomerID === undefined || xFrankieCustomerID === null) {
        throw new Error("Missing the required parameter 'xFrankieCustomerID' when calling createCheckEntity");
      }
      // verify the required parameter 'checkType' is set
      if (checkType === undefined || checkType === null) {
        throw new Error("Missing the required parameter 'checkType' when calling createCheckEntity");
      }
      // verify the required parameter 'resultLevel' is set
      if (resultLevel === undefined || resultLevel === null) {
        throw new Error("Missing the required parameter 'resultLevel' when calling createCheckEntity");
      }
      // verify the required parameter 'entityDetails' is set
      if (entityDetails === undefined || entityDetails === null) {
        throw new Error("Missing the required parameter 'entityDetails' when calling createCheckEntity");
      }

      let pathParams = {
        'checkType': checkType,
        'resultLevel': resultLevel
      };
      let queryParams = {
      };
      let headerParams = {
        'X-Frankie-CustomerID': xFrankieCustomerID,
        'X-Frankie-CustomerChildID': opts['xFrankieCustomerChildID'],
        'X-Frankie-Background': opts['xFrankieBackground']
      };
      let formParams = {
      };

      let authNames = ['api_key'];
      let contentTypes = ['application/json'];
      let accepts = ['application/json'];
      let returnType = CheckEntityCheckResultObject;
      return this.apiClient.callApi(
        '/entity/new/verify/{checkType}/{resultLevel}', 'POST',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null, callback
      );
    }

    /**
     * Callback function to receive the result of the createCheckEntityPushToMobile operation.
     * @callback module:api/EntityApi~createCheckEntityPushToMobileCallback
     * @param {String} error Error message, if any.
     * @param {module:model/AcceptedEntityResultObject} data The data returned by the service call.
     * @param {String} response The complete HTTP response.
     */

    /**
     * Create Entity and Push Self-Verification Link
     * Create an entity object and begin the process of verification after pushing a message to a mobile number.  The entity will receive a link on their mobile and will then be guided through a series of steps to capture and OCR scan their ID, and perform a selfie comparison. We'll then attempt to verify the data received and push a notification back to the calling customer.  At a minimum, you will need to supply the name and a MOBILE_PHONE document type.   SPECIAL NOTE: This will only ever return a 202 response if successfully accepted. You will need to ensure your account is configured for push notifications. Contact developer supprt to arrange this. 
     * @param {String} xFrankieCustomerID Customer ID issued by Frankie Financial. This will never change. Your API key, which is mapped to this identity, will change over time. 
     * @param {module:model/EntityCheckDetailsObject} entityDetails The entity and any associated / additional information to be checked
     * @param {Object} opts Optional parameters
     * @param {String} [xFrankieCustomerChildID] If, as a Frankie Customer, you are acting on behalf of your own customers, then you can populate this field with a Frankie-assigned ID.  Note: If using a CustomerChildID, you will also need a separate api_key for each child.  Any documents, checks, entities that are created when this field has been populated will now be tied to this CustomerID + CustomerChildID combination. Just as Customers cannot see data created by other Customers, so too a Customer's Children will not be able to see each other's data.  A Customer can see the documents/entities and checks of all their Children. 
     * @param {Number} [xFrankieBackground] If this header parameter is supplied and set to 1, then the request will not wait for the process to finish, and will return a 202 if there are no obvious errors in the input. The request will then run in the background and send a notification back to the customer. See out callback API for details on this.  See more details here:   https://apidocs.frankiefinancial.com/docs/asynchronous-calls-backgrounding-processes 
     * @param {Boolean} [nopush] If set to true, then no SMS/email will be pushed. It will be up to the API caller to manage the delivery of the link. 
     * @param {module:api/EntityApi~createCheckEntityPushToMobileCallback} callback The callback function, accepting three arguments: error, data, response
     * data is of type: {@link module:model/AcceptedEntityResultObject}
     */
    createCheckEntityPushToMobile(xFrankieCustomerID, entityDetails, opts, callback) {
      opts = opts || {};
      let postBody = entityDetails;
      // verify the required parameter 'xFrankieCustomerID' is set
      if (xFrankieCustomerID === undefined || xFrankieCustomerID === null) {
        throw new Error("Missing the required parameter 'xFrankieCustomerID' when calling createCheckEntityPushToMobile");
      }
      // verify the required parameter 'entityDetails' is set
      if (entityDetails === undefined || entityDetails === null) {
        throw new Error("Missing the required parameter 'entityDetails' when calling createCheckEntityPushToMobile");
      }

      let pathParams = {
      };
      let queryParams = {
        'nopush': opts['nopush']
      };
      let headerParams = {
        'X-Frankie-CustomerID': xFrankieCustomerID,
        'X-Frankie-CustomerChildID': opts['xFrankieCustomerChildID'],
        'X-Frankie-Background': opts['xFrankieBackground']
      };
      let formParams = {
      };

      let authNames = ['api_key'];
      let contentTypes = ['application/json'];
      let accepts = ['application/json'];
      let returnType = AcceptedEntityResultObject;
      return this.apiClient.callApi(
        '/entity/new/verify/pushToMobile', 'POST',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null, callback
      );
    }

    /**
     * Callback function to receive the result of the createEntity operation.
     * @callback module:api/EntityApi~createEntityCallback
     * @param {String} error Error message, if any.
     * @param {module:model/EntityResultObject} data The data returned by the service call.
     * @param {String} response The complete HTTP response.
     */

    /**
     * Create New Entity.
     * Create an entity object. An entity object can be used to simply store data around a given identity. You can attach ID documents, scans, PDFs, photos, videos, etc to the entity if you wish and these may be processed later (using the /scan function) to extract useful information. Or you can manually supply the  information if you choose.  Entity objects can be used to run a check, using the data held in the records. 
     * @param {String} xFrankieCustomerID Customer ID issued by Frankie Financial. This will never change. Your API key, which is mapped to this identity, will change over time. 
     * @param {Object} opts Optional parameters
     * @param {String} [xFrankieCustomerChildID] If, as a Frankie Customer, you are acting on behalf of your own customers, then you can populate this field with a Frankie-assigned ID.  Note: If using a CustomerChildID, you will also need a separate api_key for each child.  Any documents, checks, entities that are created when this field has been populated will now be tied to this CustomerID + CustomerChildID combination. Just as Customers cannot see data created by other Customers, so too a Customer's Children will not be able to see each other's data.  A Customer can see the documents/entities and checks of all their Children. 
     * @param {module:model/EntityObject} [entity] 
     * @param {module:api/EntityApi~createEntityCallback} callback The callback function, accepting three arguments: error, data, response
     * data is of type: {@link module:model/EntityResultObject}
     */
    createEntity(xFrankieCustomerID, opts, callback) {
      opts = opts || {};
      let postBody = opts['entity'];
      // verify the required parameter 'xFrankieCustomerID' is set
      if (xFrankieCustomerID === undefined || xFrankieCustomerID === null) {
        throw new Error("Missing the required parameter 'xFrankieCustomerID' when calling createEntity");
      }

      let pathParams = {
      };
      let queryParams = {
      };
      let headerParams = {
        'X-Frankie-CustomerID': xFrankieCustomerID,
        'X-Frankie-CustomerChildID': opts['xFrankieCustomerChildID']
      };
      let formParams = {
      };

      let authNames = ['api_key'];
      let contentTypes = ['application/json'];
      let accepts = ['application/json'];
      let returnType = EntityResultObject;
      return this.apiClient.callApi(
        '/entity', 'POST',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null, callback
      );
    }

    /**
     * Callback function to receive the result of the createEntityGetIDVToken operation.
     * @callback module:api/EntityApi~createEntityGetIDVTokenCallback
     * @param {String} error Error message, if any.
     * @param {module:model/EntityIDVResultObject} data The data returned by the service call.
     * @param {String} response The complete HTTP response.
     */

    /**
     * Create Entity and Get IDV Token
     * Create an entity object and if successful, obtain a token for use in an ID Validation service SDK (web or native app)   At a minimum, you will need to supply:  - the entity familyName.   - the entity givenName    For best results, you should gather the DoB, address, ID document details as well before  calling the initProcess function.  SPECIAL NOTE 1: Tokens have a limited lifespan, typically only 1 hour. Make sure you've used it or you will need to create another using update version of this function.   SPECIAL NOTE 2: This function will need to be followed up with a call to /entity/{id}/idvalidate/initProcess once you've collected all your data in your app/web capture process. 
     * @param {String} xFrankieCustomerID Customer ID issued by Frankie Financial. This will never change. Your API key, which is mapped to this identity, will change over time. 
     * @param {module:model/EntityIDVDetailsObject} entityIDVDetails The entity and required data to generate an IDV token
     * @param {Object} opts Optional parameters
     * @param {String} [xFrankieCustomerChildID] If, as a Frankie Customer, you are acting on behalf of your own customers, then you can populate this field with a Frankie-assigned ID.  Note: If using a CustomerChildID, you will also need a separate api_key for each child.  Any documents, checks, entities that are created when this field has been populated will now be tied to this CustomerID + CustomerChildID combination. Just as Customers cannot see data created by other Customers, so too a Customer's Children will not be able to see each other's data.  A Customer can see the documents/entities and checks of all their Children. 
     * @param {module:api/EntityApi~createEntityGetIDVTokenCallback} callback The callback function, accepting three arguments: error, data, response
     * data is of type: {@link module:model/EntityIDVResultObject}
     */
    createEntityGetIDVToken(xFrankieCustomerID, entityIDVDetails, opts, callback) {
      opts = opts || {};
      let postBody = entityIDVDetails;
      // verify the required parameter 'xFrankieCustomerID' is set
      if (xFrankieCustomerID === undefined || xFrankieCustomerID === null) {
        throw new Error("Missing the required parameter 'xFrankieCustomerID' when calling createEntityGetIDVToken");
      }
      // verify the required parameter 'entityIDVDetails' is set
      if (entityIDVDetails === undefined || entityIDVDetails === null) {
        throw new Error("Missing the required parameter 'entityIDVDetails' when calling createEntityGetIDVToken");
      }

      let pathParams = {
      };
      let queryParams = {
      };
      let headerParams = {
        'X-Frankie-CustomerID': xFrankieCustomerID,
        'X-Frankie-CustomerChildID': opts['xFrankieCustomerChildID']
      };
      let formParams = {
      };

      let authNames = ['api_key'];
      let contentTypes = ['application/json'];
      let accepts = ['application/json'];
      let returnType = EntityIDVResultObject;
      return this.apiClient.callApi(
        '/entity/new/idvalidate/getToken', 'POST',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null, callback
      );
    }

    /**
     * Callback function to receive the result of the deleteEntity operation.
     * @callback module:api/EntityApi~deleteEntityCallback
     * @param {String} error Error message, if any.
     * @param {module:model/BasicStatusResultObject} data The data returned by the service call.
     * @param {String} response The complete HTTP response.
     */

    /**
     * Delete Entity
     * Marks the entity as deleted in the system, and no further operations or general queries may be executed against it by the Customer. If another customer is presently relying on this data, it will still be available to them (but only in the partially anonymised form they originally had.  An entity and its related data is only completely deleted from the database when either:    - a) There are no more references to it (i.e. it has been DELETEd by all Customers relying on the data), and 12 months have passed.      - b) The actual consumer who owns the data makes a direct request. If this occurs, then all subscribing Customers will be notified that this entity has been removed and they will need to contact them if needed in order to update their own records again. 
     * @param {String} xFrankieCustomerID Customer ID issued by Frankie Financial. This will never change. Your API key, which is mapped to this identity, will change over time. 
     * @param {String} entityId The entityId returned previously from an earlier call to /check or /entity
     * @param {Object} opts Optional parameters
     * @param {String} [xFrankieCustomerChildID] If, as a Frankie Customer, you are acting on behalf of your own customers, then you can populate this field with a Frankie-assigned ID.  Note: If using a CustomerChildID, you will also need a separate api_key for each child.  Any documents, checks, entities that are created when this field has been populated will now be tied to this CustomerID + CustomerChildID combination. Just as Customers cannot see data created by other Customers, so too a Customer's Children will not be able to see each other's data.  A Customer can see the documents/entities and checks of all their Children. 
     * @param {Number} [xFrankieBackground] If this header parameter is supplied and set to 1, then the request will not wait for the process to finish, and will return a 202 if there are no obvious errors in the input. The request will then run in the background and send a notification back to the customer. See out callback API for details on this.  See more details here:   https://apidocs.frankiefinancial.com/docs/asynchronous-calls-backgrounding-processes 
     * @param {module:api/EntityApi~deleteEntityCallback} callback The callback function, accepting three arguments: error, data, response
     * data is of type: {@link module:model/BasicStatusResultObject}
     */
    deleteEntity(xFrankieCustomerID, entityId, opts, callback) {
      opts = opts || {};
      let postBody = null;
      // verify the required parameter 'xFrankieCustomerID' is set
      if (xFrankieCustomerID === undefined || xFrankieCustomerID === null) {
        throw new Error("Missing the required parameter 'xFrankieCustomerID' when calling deleteEntity");
      }
      // verify the required parameter 'entityId' is set
      if (entityId === undefined || entityId === null) {
        throw new Error("Missing the required parameter 'entityId' when calling deleteEntity");
      }

      let pathParams = {
        'entityId': entityId
      };
      let queryParams = {
      };
      let headerParams = {
        'X-Frankie-CustomerID': xFrankieCustomerID,
        'X-Frankie-CustomerChildID': opts['xFrankieCustomerChildID'],
        'X-Frankie-Background': opts['xFrankieBackground']
      };
      let formParams = {
      };

      let authNames = ['api_key'];
      let contentTypes = [];
      let accepts = ['application/json'];
      let returnType = BasicStatusResultObject;
      return this.apiClient.callApi(
        '/entity/{entityId}', 'DELETE',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null, callback
      );
    }

    /**
     * Callback function to receive the result of the queryEntity operation.
     * @callback module:api/EntityApi~queryEntityCallback
     * @param {String} error Error message, if any.
     * @param {module:model/EntityResultObject} data The data returned by the service call.
     * @param {String} response The complete HTTP response.
     */

    /**
     * Retrieve Entity Details
     * Query the current status and details of a given entityId. 
     * @param {String} xFrankieCustomerID Customer ID issued by Frankie Financial. This will never change. Your API key, which is mapped to this identity, will change over time. 
     * @param {String} entityId The entityId returned previously from an earlier call to /check or /entity
     * @param {Object} opts Optional parameters
     * @param {String} [xFrankieCustomerChildID] If, as a Frankie Customer, you are acting on behalf of your own customers, then you can populate this field with a Frankie-assigned ID.  Note: If using a CustomerChildID, you will also need a separate api_key for each child.  Any documents, checks, entities that are created when this field has been populated will now be tied to this CustomerID + CustomerChildID combination. Just as Customers cannot see data created by other Customers, so too a Customer's Children will not be able to see each other's data.  A Customer can see the documents/entities and checks of all their Children. 
     * @param {module:api/EntityApi~queryEntityCallback} callback The callback function, accepting three arguments: error, data, response
     * data is of type: {@link module:model/EntityResultObject}
     */
    queryEntity(xFrankieCustomerID, entityId, opts, callback) {
      opts = opts || {};
      let postBody = null;
      // verify the required parameter 'xFrankieCustomerID' is set
      if (xFrankieCustomerID === undefined || xFrankieCustomerID === null) {
        throw new Error("Missing the required parameter 'xFrankieCustomerID' when calling queryEntity");
      }
      // verify the required parameter 'entityId' is set
      if (entityId === undefined || entityId === null) {
        throw new Error("Missing the required parameter 'entityId' when calling queryEntity");
      }

      let pathParams = {
        'entityId': entityId
      };
      let queryParams = {
      };
      let headerParams = {
        'X-Frankie-CustomerID': xFrankieCustomerID,
        'X-Frankie-CustomerChildID': opts['xFrankieCustomerChildID']
      };
      let formParams = {
      };

      let authNames = ['api_key'];
      let contentTypes = [];
      let accepts = ['application/json'];
      let returnType = EntityResultObject;
      return this.apiClient.callApi(
        '/entity/{entityId}', 'GET',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null, callback
      );
    }

    /**
     * Callback function to receive the result of the queryEntityChecks operation.
     * @callback module:api/EntityApi~queryEntityChecksCallback
     * @param {String} error Error message, if any.
     * @param {module:model/CheckEntityCheckResultObject} data The data returned by the service call.
     * @param {String} response The complete HTTP response.
     */

    /**
     * Retrieve Entity Verication Check Details 
     * Get the complete list of all checks that have been performed upon a given entity and its documents, including the checks that have been performed by others (in those cases you just get the id, status and date run, none of the details). 
     * @param {String} xFrankieCustomerID Customer ID issued by Frankie Financial. This will never change. Your API key, which is mapped to this identity, will change over time. 
     * @param {String} entityId The entityId returned previously from an earlier call to /check or /entity
     * @param {Object} opts Optional parameters
     * @param {String} [xFrankieCustomerChildID] If, as a Frankie Customer, you are acting on behalf of your own customers, then you can populate this field with a Frankie-assigned ID.  Note: If using a CustomerChildID, you will also need a separate api_key for each child.  Any documents, checks, entities that are created when this field has been populated will now be tied to this CustomerID + CustomerChildID combination. Just as Customers cannot see data created by other Customers, so too a Customer's Children will not be able to see each other's data.  A Customer can see the documents/entities and checks of all their Children. 
     * @param {Boolean} [alldata] Requests that literally all data should be included in the response to a \"get checks\" request. This is as opposed to a filtered view where expired results are by default not included for entities that have an assigned profile. 
     * @param {module:api/EntityApi~queryEntityChecksCallback} callback The callback function, accepting three arguments: error, data, response
     * data is of type: {@link module:model/CheckEntityCheckResultObject}
     */
    queryEntityChecks(xFrankieCustomerID, entityId, opts, callback) {
      opts = opts || {};
      let postBody = null;
      // verify the required parameter 'xFrankieCustomerID' is set
      if (xFrankieCustomerID === undefined || xFrankieCustomerID === null) {
        throw new Error("Missing the required parameter 'xFrankieCustomerID' when calling queryEntityChecks");
      }
      // verify the required parameter 'entityId' is set
      if (entityId === undefined || entityId === null) {
        throw new Error("Missing the required parameter 'entityId' when calling queryEntityChecks");
      }

      let pathParams = {
        'entityId': entityId
      };
      let queryParams = {
        'alldata': opts['alldata']
      };
      let headerParams = {
        'X-Frankie-CustomerID': xFrankieCustomerID,
        'X-Frankie-CustomerChildID': opts['xFrankieCustomerChildID']
      };
      let formParams = {
      };

      let authNames = ['api_key'];
      let contentTypes = [];
      let accepts = ['application/json'];
      let returnType = CheckEntityCheckResultObject;
      return this.apiClient.callApi(
        '/entity/{entityId}/checks', 'GET',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null, callback
      );
    }

    /**
     * Callback function to receive the result of the queryEntityFull operation.
     * @callback module:api/EntityApi~queryEntityFullCallback
     * @param {String} error Error message, if any.
     * @param {module:model/EntityResultObject} data The data returned by the service call.
     * @param {String} response The complete HTTP response.
     */

    /**
     * Retrieve Entity Details and Document Scan Data 
     * Query the current status and details of a given entityId. Also returns all attached document file data, not just the metadata. Equivalent to a get /document/{documentId}/full) 
     * @param {String} xFrankieCustomerID Customer ID issued by Frankie Financial. This will never change. Your API key, which is mapped to this identity, will change over time. 
     * @param {String} entityId The entityId returned previously from an earlier call to /check or /entity
     * @param {Object} opts Optional parameters
     * @param {String} [xFrankieCustomerChildID] If, as a Frankie Customer, you are acting on behalf of your own customers, then you can populate this field with a Frankie-assigned ID.  Note: If using a CustomerChildID, you will also need a separate api_key for each child.  Any documents, checks, entities that are created when this field has been populated will now be tied to this CustomerID + CustomerChildID combination. Just as Customers cannot see data created by other Customers, so too a Customer's Children will not be able to see each other's data.  A Customer can see the documents/entities and checks of all their Children. 
     * @param {module:api/EntityApi~queryEntityFullCallback} callback The callback function, accepting three arguments: error, data, response
     * data is of type: {@link module:model/EntityResultObject}
     */
    queryEntityFull(xFrankieCustomerID, entityId, opts, callback) {
      opts = opts || {};
      let postBody = null;
      // verify the required parameter 'xFrankieCustomerID' is set
      if (xFrankieCustomerID === undefined || xFrankieCustomerID === null) {
        throw new Error("Missing the required parameter 'xFrankieCustomerID' when calling queryEntityFull");
      }
      // verify the required parameter 'entityId' is set
      if (entityId === undefined || entityId === null) {
        throw new Error("Missing the required parameter 'entityId' when calling queryEntityFull");
      }

      let pathParams = {
        'entityId': entityId
      };
      let queryParams = {
      };
      let headerParams = {
        'X-Frankie-CustomerID': xFrankieCustomerID,
        'X-Frankie-CustomerChildID': opts['xFrankieCustomerChildID']
      };
      let formParams = {
      };

      let authNames = ['api_key'];
      let contentTypes = [];
      let accepts = ['application/json'];
      let returnType = EntityResultObject;
      return this.apiClient.callApi(
        '/entity/{entityId}/full', 'GET',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null, callback
      );
    }

    /**
     * Callback function to receive the result of the searchEntity operation.
     * @callback module:api/EntityApi~searchEntityCallback
     * @param {String} error Error message, if any.
     * @param {module:model/EntitySearchResultObject} data The data returned by the service call.
     * @param {String} response The complete HTTP response.
     */

    /**
     * Search for Entity
     *  Search for an existing entity that matches the criteria supplied  Criteria are supplied in the form of a populated entity object, with the name/address/DoB details supplied. You can also include documents that can be used to further refine your search (see the /document/search function for minimum requirements for a document search)  At an absolute minimum, you must supply one of the following combinations:    * name.familyName +   * name.givenNames      or      * name.familyName +   * one identityDocument object (that meets minimum criteria)    Obviously, the more data you provide, the better search results we can provide.  The service will return a list of matching entities with confidence levels.  If you are the \"owner\" of the entity - i.e. the same CustomerID and CustomerChildID (if relevant) - then the full details of the entity and any owned documents will be returned, except for the contents of any attached scans.  If you are not the owner of the entity (or linked documents), then just the ID and confidence level is returned. You can still use this ID to retrieve any check results (see GET  /entity/{entityId}/checks and GET /document/{documentId}/checks)  Note: This functionality must be enabled by Frankie administrators. Please contact your sales representative if you wish to discuss this. 
     * @param {String} xFrankieCustomerID Customer ID issued by Frankie Financial. This will never change. Your API key, which is mapped to this identity, will change over time. 
     * @param {module:model/EntityObject} searchEntity An entity object with the parameters you wish to search on. 
     * @param {Object} opts Optional parameters
     * @param {String} [xFrankieCustomerChildID] If, as a Frankie Customer, you are acting on behalf of your own customers, then you can populate this field with a Frankie-assigned ID.  Note: If using a CustomerChildID, you will also need a separate api_key for each child.  Any documents, checks, entities that are created when this field has been populated will now be tied to this CustomerID + CustomerChildID combination. Just as Customers cannot see data created by other Customers, so too a Customer's Children will not be able to see each other's data.  A Customer can see the documents/entities and checks of all their Children. 
     * @param {module:api/EntityApi~searchEntityCallback} callback The callback function, accepting three arguments: error, data, response
     * data is of type: {@link module:model/EntitySearchResultObject}
     */
    searchEntity(xFrankieCustomerID, searchEntity, opts, callback) {
      opts = opts || {};
      let postBody = searchEntity;
      // verify the required parameter 'xFrankieCustomerID' is set
      if (xFrankieCustomerID === undefined || xFrankieCustomerID === null) {
        throw new Error("Missing the required parameter 'xFrankieCustomerID' when calling searchEntity");
      }
      // verify the required parameter 'searchEntity' is set
      if (searchEntity === undefined || searchEntity === null) {
        throw new Error("Missing the required parameter 'searchEntity' when calling searchEntity");
      }

      let pathParams = {
      };
      let queryParams = {
      };
      let headerParams = {
        'X-Frankie-CustomerID': xFrankieCustomerID,
        'X-Frankie-CustomerChildID': opts['xFrankieCustomerChildID']
      };
      let formParams = {
      };

      let authNames = ['api_key'];
      let contentTypes = ['application/json'];
      let accepts = ['application/json'];
      let returnType = EntitySearchResultObject;
      return this.apiClient.callApi(
        '/entity/search', 'POST',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null, callback
      );
    }

    /**
     * Callback function to receive the result of the updateCheckClassResult operation.
     * @callback module:api/EntityApi~updateCheckClassResultCallback
     * @param {String} error Error message, if any.
     * @param {module:model/CheckEntityCheckResultObject} data The data returned by the service call.
     * @param {String} response The complete HTTP response.
     */

    /**
     * Update Check Result State
     * Internal only  Update a given KYC or AML check result status in order to force a re-evaluation of the overall check result. 
     * @param {String} xFrankieCustomerID Customer ID issued by Frankie Financial. This will never change. Your API key, which is mapped to this identity, will change over time. 
     * @param {String} entityId The entityId returned previously from an earlier call to /check or /entity
     * @param {String} checkId The checkId returned previously from an earlier call to *_/verify
     * @param {module:model/String} checkClass Specify which check Class this action will apply to (PRO, BCRO etc.). Valid values are:   - \"pro\": Update a Process Result Object   - \"bcro\": Update a Background Check Result Object. The class IDs in the request must be the IDs from Background Check Result Object Containers.   - \"fraudlist\": Update a fraud list Process Result Object. The class IDs in the request must be check sources from fraudlist Process Result Objects. 
     * @param {String} checkClassId A PRO/BCRO ID 
     * @param {String} status Set the new status of the Check Class (PRO/BCRO). Valid values are:   - \"unknown\"   - \"true_positive\"   - \"true_positive_accept\"   - \"true_positive_reject\"   - \"false_positive\"   - \"stale\" 
     * @param {Object} opts Optional parameters
     * @param {String} [xFrankieCustomerChildID] If, as a Frankie Customer, you are acting on behalf of your own customers, then you can populate this field with a Frankie-assigned ID.  Note: If using a CustomerChildID, you will also need a separate api_key for each child.  Any documents, checks, entities that are created when this field has been populated will now be tied to this CustomerID + CustomerChildID combination. Just as Customers cannot see data created by other Customers, so too a Customer's Children will not be able to see each other's data.  A Customer can see the documents/entities and checks of all their Children. 
     * @param {Boolean} [undo] Undo a prior operation. 
     * @param {module:api/EntityApi~updateCheckClassResultCallback} callback The callback function, accepting three arguments: error, data, response
     * data is of type: {@link module:model/CheckEntityCheckResultObject}
     */
    updateCheckClassResult(xFrankieCustomerID, entityId, checkId, checkClass, checkClassId, status, opts, callback) {
      opts = opts || {};
      let postBody = null;
      // verify the required parameter 'xFrankieCustomerID' is set
      if (xFrankieCustomerID === undefined || xFrankieCustomerID === null) {
        throw new Error("Missing the required parameter 'xFrankieCustomerID' when calling updateCheckClassResult");
      }
      // verify the required parameter 'entityId' is set
      if (entityId === undefined || entityId === null) {
        throw new Error("Missing the required parameter 'entityId' when calling updateCheckClassResult");
      }
      // verify the required parameter 'checkId' is set
      if (checkId === undefined || checkId === null) {
        throw new Error("Missing the required parameter 'checkId' when calling updateCheckClassResult");
      }
      // verify the required parameter 'checkClass' is set
      if (checkClass === undefined || checkClass === null) {
        throw new Error("Missing the required parameter 'checkClass' when calling updateCheckClassResult");
      }
      // verify the required parameter 'checkClassId' is set
      if (checkClassId === undefined || checkClassId === null) {
        throw new Error("Missing the required parameter 'checkClassId' when calling updateCheckClassResult");
      }
      // verify the required parameter 'status' is set
      if (status === undefined || status === null) {
        throw new Error("Missing the required parameter 'status' when calling updateCheckClassResult");
      }

      let pathParams = {
        'entityId': entityId,
        'checkId': checkId,
        'checkClass': checkClass,
        'checkClassId': checkClassId
      };
      let queryParams = {
        'status': status,
        'undo': opts['undo']
      };
      let headerParams = {
        'X-Frankie-CustomerID': xFrankieCustomerID,
        'X-Frankie-CustomerChildID': opts['xFrankieCustomerChildID']
      };
      let formParams = {
      };

      let authNames = ['api_key'];
      let contentTypes = [];
      let accepts = ['application/json'];
      let returnType = CheckEntityCheckResultObject;
      return this.apiClient.callApi(
        '/entity/{entityId}/check/{checkId}/{checkClass}/{checkClassId}', 'POST',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null, callback
      );
    }

    /**
     * Callback function to receive the result of the updateCheckClassResults operation.
     * @callback module:api/EntityApi~updateCheckClassResultsCallback
     * @param {String} error Error message, if any.
     * @param {module:model/CheckEntityCheckResultObject} data The data returned by the service call.
     * @param {String} response The complete HTTP response.
     */

    /**
     * Update Check Result States (Batch)
     * Internal only  Update a given set of KYC and/or AML check result statuses in order to force a re-evaluation of the overall check result. 
     * @param {String} xFrankieCustomerID Customer ID issued by Frankie Financial. This will never change. Your API key, which is mapped to this identity, will change over time. 
     * @param {String} entityId The entityId returned previously from an earlier call to /check or /entity
     * @param {String} checkId The checkId returned previously from an earlier call to *_/verify
     * @param {module:model/String} checkClass Specify which check Class this action will apply to (PRO, BCRO etc.). Valid values are:   - \"pro\": Update a Process Result Object   - \"bcro\": Update a Background Check Result Object. The class IDs in the request must be the IDs from Background Check Result Object Containers.   - \"fraudlist\": Update a fraud list Process Result Object. The class IDs in the request must be check sources from fraudlist Process Result Objects. 
     * @param {module:model/CheckResultUpdateObject} checkResultUpdate The check result status change details to apply
     * @param {Object} opts Optional parameters
     * @param {String} [xFrankieCustomerChildID] If, as a Frankie Customer, you are acting on behalf of your own customers, then you can populate this field with a Frankie-assigned ID.  Note: If using a CustomerChildID, you will also need a separate api_key for each child.  Any documents, checks, entities that are created when this field has been populated will now be tied to this CustomerID + CustomerChildID combination. Just as Customers cannot see data created by other Customers, so too a Customer's Children will not be able to see each other's data.  A Customer can see the documents/entities and checks of all their Children. 
     * @param {module:api/EntityApi~updateCheckClassResultsCallback} callback The callback function, accepting three arguments: error, data, response
     * data is of type: {@link module:model/CheckEntityCheckResultObject}
     */
    updateCheckClassResults(xFrankieCustomerID, entityId, checkId, checkClass, checkResultUpdate, opts, callback) {
      opts = opts || {};
      let postBody = checkResultUpdate;
      // verify the required parameter 'xFrankieCustomerID' is set
      if (xFrankieCustomerID === undefined || xFrankieCustomerID === null) {
        throw new Error("Missing the required parameter 'xFrankieCustomerID' when calling updateCheckClassResults");
      }
      // verify the required parameter 'entityId' is set
      if (entityId === undefined || entityId === null) {
        throw new Error("Missing the required parameter 'entityId' when calling updateCheckClassResults");
      }
      // verify the required parameter 'checkId' is set
      if (checkId === undefined || checkId === null) {
        throw new Error("Missing the required parameter 'checkId' when calling updateCheckClassResults");
      }
      // verify the required parameter 'checkClass' is set
      if (checkClass === undefined || checkClass === null) {
        throw new Error("Missing the required parameter 'checkClass' when calling updateCheckClassResults");
      }
      // verify the required parameter 'checkResultUpdate' is set
      if (checkResultUpdate === undefined || checkResultUpdate === null) {
        throw new Error("Missing the required parameter 'checkResultUpdate' when calling updateCheckClassResults");
      }

      let pathParams = {
        'entityId': entityId,
        'checkId': checkId,
        'checkClass': checkClass
      };
      let queryParams = {
      };
      let headerParams = {
        'X-Frankie-CustomerID': xFrankieCustomerID,
        'X-Frankie-CustomerChildID': opts['xFrankieCustomerChildID']
      };
      let formParams = {
      };

      let authNames = ['api_key'];
      let contentTypes = ['application/json'];
      let accepts = ['application/json'];
      let returnType = CheckEntityCheckResultObject;
      return this.apiClient.callApi(
        '/entity/{entityId}/check/{checkId}/{checkClass}', 'POST',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null, callback
      );
    }

    /**
     * Callback function to receive the result of the updateCheckEntity operation.
     * @callback module:api/EntityApi~updateCheckEntityCallback
     * @param {String} error Error message, if any.
     * @param {module:model/CheckEntityCheckResultObject} data The data returned by the service call.
     * @param {String} response The complete HTTP response.
     */

    /**
     * Update Entity and Verify Details
     * Take the details and documents provided in the entity, and set about verifying them all. So for example, you might extract:  * The name from the entity.name object * The address from the entity.address object * The DoB..  All documents that are presently attached to the entity will also be verified (if requested)  You can also specify the level of detail returned using the resultLevel parameter. You can choose \"summary\" or \"full\". For the \"profile\" check type you can also select \"simple\" to only get the entity profile result.  SPECIAL NOTE: A \"Full\" response includes details of all checks and how they map against each element, along with all the details of pep/sanctions/etc checks too.  Your account also needs to be configured to support a full response too (talk to your account manager for more information). If you're not configured for full responses, we'll only return summary level data regardless. 
     * @param {String} xFrankieCustomerID Customer ID issued by Frankie Financial. This will never change. Your API key, which is mapped to this identity, will change over time. 
     * @param {String} entityId The entityId returned previously from an earlier call to /check or /entity
     * @param {String} checkType When creating a new check, you need to define the checks you wish to run.    The checkType is make up of a comma separated list of the types of check you wish to run. The order of the requested checks is not important, they will be re-ordered by the service and in some cases, depending on your account configuration, may be skipped.    The validation that is performed on the requested checks is to:   - ensure the check type is known   - is suitable for the type of entity (no KYC for organisations)   - disallow manual (mKYC) check with any other kind of KYC   - disallow mixing the \"profile\" check with any other kind of check.  The supported check types are:  Profile:   - \"profile\": By arrangement with Frankie we will create a \"profile\" check type that applies checks according to a recipe that you assign to the entity from a predefined set of profiles.      The profile to use will be taken from the entity.entityProfile field if set, or be run through a set of configurable rules to determine which one to use.      Profiles provide a pre-defined combination of individual checkTypes (see the list below). But they offer a lot more besides, including rules for determining default settings, inbuilt data aging and other configurable features.   They also allow for a new result set top be returned that provides a more detailed and useful breakdown of the check/verification process.      Entity Profiles are a recent feature (since v1.4.0) but are now the default checkType to use with Frankie Financial.  **Individual Check Types**  Whilst we strongly recommend the use of the \"profile\" checktype, it does map of any combination of the types below. If you wish to use these individually, please contact developer support for more details on how to use these effectively.  Entity Checks - One of:   - \"one_plus\": Checks name, address and DoB against a minimum of 1 data source. (also known as a 1+1)   - \"two_plus\": Checks name, address and DoB against a minimum of 2 independent data sources (also known as a 2+2)  ID Checks - One of:   - \"id\": Checks all of the identity documents, but not necessarily the entity itself independently. Use this in conjunction with a one_plus or two_plus for more.   - \"visa\":    ID Validate - One of:   - \"idvalidate\": Checks to see if photo ID has had OCR scanning, ID document validation and photo comparison run against it. Can be used in conjunction with any of the KYC/ID/AML checks.    Manual Check:   - \"manual\": (mKYC) Checks user has a sufficient amount of operator verified ID and will then \"pass\" all Entity and ID related checks.    Fraud Checks - One or more of:   - \"fraudlist\": Checks to see if the identity appears on any known fraud lists. Should be run after KYC/ID checks have passed.   - \"fraudcheck\": Checks external ID services to see if details appear in fraud detection services (e.g. EmailAge or FraudNet)    PEP Checks - One of:   - \"pep\": Will only run PEP/Sanctions checks (no identity verification)   - \"pep_media\": Will run PEP/Sanctions checks, as well as watchlist and adverse media checks. (no identity verification)      * NOTE: These checks will ONLY run if either the KYC/ID checks have been run prior, or it is the only check requested.    Custom:   - By arrangement with Frankie you can define your own KYC check type.      This will allow you to set the minimum number of matches for:     - name      - date of birth     - address     - government id      This allows for alternatives to the \"standard\" two_plus or one_plus (note, these can be overridden too). 
     * @param {module:model/String} resultLevel How much detail we return.   Acceptable values are:   * simple - Only available with \"profile\" check type. Returns just an EntityProfileResultObject (which is also included for \"profile\" checks at the other result levels), and a CheckEntityCheckResultObjectEntityResult with just the entity details but no separate results.   * summary   * full - You need to have your account configured for this. 
     * @param {module:model/EntityCheckDetailsObject} entityDetails The entity to be checked
     * @param {Object} opts Optional parameters
     * @param {String} [xFrankieCustomerChildID] If, as a Frankie Customer, you are acting on behalf of your own customers, then you can populate this field with a Frankie-assigned ID.  Note: If using a CustomerChildID, you will also need a separate api_key for each child.  Any documents, checks, entities that are created when this field has been populated will now be tied to this CustomerID + CustomerChildID combination. Just as Customers cannot see data created by other Customers, so too a Customer's Children will not be able to see each other's data.  A Customer can see the documents/entities and checks of all their Children. 
     * @param {Number} [xFrankieBackground] If this header parameter is supplied and set to 1, then the request will not wait for the process to finish, and will return a 202 if there are no obvious errors in the input. The request will then run in the background and send a notification back to the customer. See out callback API for details on this.  See more details here:   https://apidocs.frankiefinancial.com/docs/asynchronous-calls-backgrounding-processes 
     * @param {Boolean} [force] Force the verification to run, overriding any data aging or past check 
     * @param {Boolean} [noInvalidate] Disable check result invalidation for this update request. 
     * @param {module:api/EntityApi~updateCheckEntityCallback} callback The callback function, accepting three arguments: error, data, response
     * data is of type: {@link module:model/CheckEntityCheckResultObject}
     */
    updateCheckEntity(xFrankieCustomerID, entityId, checkType, resultLevel, entityDetails, opts, callback) {
      opts = opts || {};
      let postBody = entityDetails;
      // verify the required parameter 'xFrankieCustomerID' is set
      if (xFrankieCustomerID === undefined || xFrankieCustomerID === null) {
        throw new Error("Missing the required parameter 'xFrankieCustomerID' when calling updateCheckEntity");
      }
      // verify the required parameter 'entityId' is set
      if (entityId === undefined || entityId === null) {
        throw new Error("Missing the required parameter 'entityId' when calling updateCheckEntity");
      }
      // verify the required parameter 'checkType' is set
      if (checkType === undefined || checkType === null) {
        throw new Error("Missing the required parameter 'checkType' when calling updateCheckEntity");
      }
      // verify the required parameter 'resultLevel' is set
      if (resultLevel === undefined || resultLevel === null) {
        throw new Error("Missing the required parameter 'resultLevel' when calling updateCheckEntity");
      }
      // verify the required parameter 'entityDetails' is set
      if (entityDetails === undefined || entityDetails === null) {
        throw new Error("Missing the required parameter 'entityDetails' when calling updateCheckEntity");
      }

      let pathParams = {
        'entityId': entityId,
        'checkType': checkType,
        'resultLevel': resultLevel
      };
      let queryParams = {
        'force': opts['force'],
        'noInvalidate': opts['noInvalidate']
      };
      let headerParams = {
        'X-Frankie-CustomerID': xFrankieCustomerID,
        'X-Frankie-CustomerChildID': opts['xFrankieCustomerChildID'],
        'X-Frankie-Background': opts['xFrankieBackground']
      };
      let formParams = {
      };

      let authNames = ['api_key'];
      let contentTypes = ['application/json'];
      let accepts = ['application/json'];
      let returnType = CheckEntityCheckResultObject;
      return this.apiClient.callApi(
        '/entity/{entityId}/verify/{checkType}/{resultLevel}', 'POST',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null, callback
      );
    }

    /**
     * Callback function to receive the result of the updateCheckEntityPushToMobile operation.
     * @callback module:api/EntityApi~updateCheckEntityPushToMobileCallback
     * @param {String} error Error message, if any.
     * @param {module:model/AcceptedEntityResultObject} data The data returned by the service call.
     * @param {String} response The complete HTTP response.
     */

    /**
     * Update Entity and Push Self-Verification Link
     * Update an existing entity object and begin the process of verification after pushing a message to a mobile number.  The entity will receive a link on their mobile and will then be guided through a series of steps to capture and OCR scan their ID, and perform a selfie comparison. We'll then attempt to verify the data received and push a notification back to the calling customer.  At a minimum, you will need to supply the name and a MOBILE_PHONE document type.         If you wish to skip the detail capture and jump straight to the ID and selfie capture, the append the call with the ?phase=2 parameter.   SPECIAL NOTE: This will only ever return a 202 response if successfully accepted. You will need to ensure your account is configured for push notifications. Contact developer supprt to arrange this. 
     * @param {String} xFrankieCustomerID Customer ID issued by Frankie Financial. This will never change. Your API key, which is mapped to this identity, will change over time. 
     * @param {String} entityId The entityId returned previously from an earlier call to /check or /entity
     * @param {module:model/EntityCheckDetailsObject} entityDetails The entity and any associated / additional information to be checked
     * @param {Object} opts Optional parameters
     * @param {String} [xFrankieCustomerChildID] If, as a Frankie Customer, you are acting on behalf of your own customers, then you can populate this field with a Frankie-assigned ID.  Note: If using a CustomerChildID, you will also need a separate api_key for each child.  Any documents, checks, entities that are created when this field has been populated will now be tied to this CustomerID + CustomerChildID combination. Just as Customers cannot see data created by other Customers, so too a Customer's Children will not be able to see each other's data.  A Customer can see the documents/entities and checks of all their Children. 
     * @param {Number} [xFrankieBackground] If this header parameter is supplied and set to 1, then the request will not wait for the process to finish, and will return a 202 if there are no obvious errors in the input. The request will then run in the background and send a notification back to the customer. See out callback API for details on this.  See more details here:   https://apidocs.frankiefinancial.com/docs/asynchronous-calls-backgrounding-processes 
     * @param {Boolean} [nopush] If set to true, then no SMS/email will be pushed. It will be up to the API caller to manage the delivery of the link. 
     * @param {Number} [phase] Set the Push To Mobile phase.  Currently supported values: - 2 
     * @param {module:api/EntityApi~updateCheckEntityPushToMobileCallback} callback The callback function, accepting three arguments: error, data, response
     * data is of type: {@link module:model/AcceptedEntityResultObject}
     */
    updateCheckEntityPushToMobile(xFrankieCustomerID, entityId, entityDetails, opts, callback) {
      opts = opts || {};
      let postBody = entityDetails;
      // verify the required parameter 'xFrankieCustomerID' is set
      if (xFrankieCustomerID === undefined || xFrankieCustomerID === null) {
        throw new Error("Missing the required parameter 'xFrankieCustomerID' when calling updateCheckEntityPushToMobile");
      }
      // verify the required parameter 'entityId' is set
      if (entityId === undefined || entityId === null) {
        throw new Error("Missing the required parameter 'entityId' when calling updateCheckEntityPushToMobile");
      }
      // verify the required parameter 'entityDetails' is set
      if (entityDetails === undefined || entityDetails === null) {
        throw new Error("Missing the required parameter 'entityDetails' when calling updateCheckEntityPushToMobile");
      }

      let pathParams = {
        'entityId': entityId
      };
      let queryParams = {
        'nopush': opts['nopush'],
        'phase': opts['phase']
      };
      let headerParams = {
        'X-Frankie-CustomerID': xFrankieCustomerID,
        'X-Frankie-CustomerChildID': opts['xFrankieCustomerChildID'],
        'X-Frankie-Background': opts['xFrankieBackground']
      };
      let formParams = {
      };

      let authNames = ['api_key'];
      let contentTypes = ['application/json'];
      let accepts = ['application/json'];
      let returnType = AcceptedEntityResultObject;
      return this.apiClient.callApi(
        '/entity/{entityId}/verify/pushToMobile', 'POST',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null, callback
      );
    }

    /**
     * Callback function to receive the result of the updateEntity operation.
     * @callback module:api/EntityApi~updateEntityCallback
     * @param {String} error Error message, if any.
     * @param {module:model/EntityResultObject} data The data returned by the service call.
     * @param {String} response The complete HTTP response.
     */

    /**
     * Update Existing Entity.
     * Using a previously uploaded but incomplete Entity, you can optionally supply updated details (such as corrections on a previous address), along with one or more additional ID docs/scans (e.g. new documents to parse, etc). 
     * @param {String} xFrankieCustomerID Customer ID issued by Frankie Financial. This will never change. Your API key, which is mapped to this identity, will change over time. 
     * @param {String} entityId The entityId returned previously from an earlier call to /check or /entity
     * @param {module:model/EntityObject} entity The entity to be updated
     * @param {Object} opts Optional parameters
     * @param {String} [xFrankieCustomerChildID] If, as a Frankie Customer, you are acting on behalf of your own customers, then you can populate this field with a Frankie-assigned ID.  Note: If using a CustomerChildID, you will also need a separate api_key for each child.  Any documents, checks, entities that are created when this field has been populated will now be tied to this CustomerID + CustomerChildID combination. Just as Customers cannot see data created by other Customers, so too a Customer's Children will not be able to see each other's data.  A Customer can see the documents/entities and checks of all their Children. 
     * @param {Number} [xFrankieBackground] If this header parameter is supplied and set to 1, then the request will not wait for the process to finish, and will return a 202 if there are no obvious errors in the input. The request will then run in the background and send a notification back to the customer. See out callback API for details on this.  See more details here:   https://apidocs.frankiefinancial.com/docs/asynchronous-calls-backgrounding-processes 
     * @param {Boolean} [noInvalidate] Disable check result invalidation for this update request. 
     * @param {module:api/EntityApi~updateEntityCallback} callback The callback function, accepting three arguments: error, data, response
     * data is of type: {@link module:model/EntityResultObject}
     */
    updateEntity(xFrankieCustomerID, entityId, entity, opts, callback) {
      opts = opts || {};
      let postBody = entity;
      // verify the required parameter 'xFrankieCustomerID' is set
      if (xFrankieCustomerID === undefined || xFrankieCustomerID === null) {
        throw new Error("Missing the required parameter 'xFrankieCustomerID' when calling updateEntity");
      }
      // verify the required parameter 'entityId' is set
      if (entityId === undefined || entityId === null) {
        throw new Error("Missing the required parameter 'entityId' when calling updateEntity");
      }
      // verify the required parameter 'entity' is set
      if (entity === undefined || entity === null) {
        throw new Error("Missing the required parameter 'entity' when calling updateEntity");
      }

      let pathParams = {
        'entityId': entityId
      };
      let queryParams = {
        'noInvalidate': opts['noInvalidate']
      };
      let headerParams = {
        'X-Frankie-CustomerID': xFrankieCustomerID,
        'X-Frankie-CustomerChildID': opts['xFrankieCustomerChildID'],
        'X-Frankie-Background': opts['xFrankieBackground']
      };
      let formParams = {
      };

      let authNames = ['api_key'];
      let contentTypes = ['application/json'];
      let accepts = ['application/json'];
      let returnType = EntityResultObject;
      return this.apiClient.callApi(
        '/entity/{entityId}', 'POST',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null, callback
      );
    }

    /**
     * Callback function to receive the result of the updateEntityGetIDVToken operation.
     * @callback module:api/EntityApi~updateEntityGetIDVTokenCallback
     * @param {String} error Error message, if any.
     * @param {module:model/EntityIDVResultObject} data The data returned by the service call.
     * @param {String} response The complete HTTP response.
     */

    /**
     * Update Entity and Get IDV Token
     * Update an entity object and if successful, obtain a token for use in an ID Validation service SDK (web or native app)   At a minimum, the entity will need to have a name. For best results, you should gather the DoB, address, ID document details as well before calling the initProcess function.  SPECIAL NOTE 1: Tokens have a limited lifespan, typically only 1 hour. Make sure you've used it or you will need to create another using update version of this function.   SPECIAL NOTE 2: This function will need to be followed up with a call to /entity/{id}/idvalidate/initProcess once you've collected all your data in your app/web capture process. 
     * @param {String} xFrankieCustomerID Customer ID issued by Frankie Financial. This will never change. Your API key, which is mapped to this identity, will change over time. 
     * @param {String} entityId The entityId returned previously from an earlier call to /check or /entity
     * @param {module:model/EntityIDVDetailsObject} entityIDVDetails The entity to update and required data to generate an IDV token
     * @param {Object} opts Optional parameters
     * @param {String} [xFrankieCustomerChildID] If, as a Frankie Customer, you are acting on behalf of your own customers, then you can populate this field with a Frankie-assigned ID.  Note: If using a CustomerChildID, you will also need a separate api_key for each child.  Any documents, checks, entities that are created when this field has been populated will now be tied to this CustomerID + CustomerChildID combination. Just as Customers cannot see data created by other Customers, so too a Customer's Children will not be able to see each other's data.  A Customer can see the documents/entities and checks of all their Children. 
     * @param {module:api/EntityApi~updateEntityGetIDVTokenCallback} callback The callback function, accepting three arguments: error, data, response
     * data is of type: {@link module:model/EntityIDVResultObject}
     */
    updateEntityGetIDVToken(xFrankieCustomerID, entityId, entityIDVDetails, opts, callback) {
      opts = opts || {};
      let postBody = entityIDVDetails;
      // verify the required parameter 'xFrankieCustomerID' is set
      if (xFrankieCustomerID === undefined || xFrankieCustomerID === null) {
        throw new Error("Missing the required parameter 'xFrankieCustomerID' when calling updateEntityGetIDVToken");
      }
      // verify the required parameter 'entityId' is set
      if (entityId === undefined || entityId === null) {
        throw new Error("Missing the required parameter 'entityId' when calling updateEntityGetIDVToken");
      }
      // verify the required parameter 'entityIDVDetails' is set
      if (entityIDVDetails === undefined || entityIDVDetails === null) {
        throw new Error("Missing the required parameter 'entityIDVDetails' when calling updateEntityGetIDVToken");
      }

      let pathParams = {
        'entityId': entityId
      };
      let queryParams = {
      };
      let headerParams = {
        'X-Frankie-CustomerID': xFrankieCustomerID,
        'X-Frankie-CustomerChildID': opts['xFrankieCustomerChildID']
      };
      let formParams = {
      };

      let authNames = ['api_key'];
      let contentTypes = ['application/json'];
      let accepts = ['application/json'];
      let returnType = EntityIDVResultObject;
      return this.apiClient.callApi(
        '/entity/{entityId}/idvalidate/getToken', 'POST',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null, callback
      );
    }

    /**
     * Callback function to receive the result of the updateEntityInitIDVProcess operation.
     * @callback module:api/EntityApi~updateEntityInitIDVProcessCallback
     * @param {String} error Error message, if any.
     * @param {module:model/EntityIDVResultObject} data The data returned by the service call.
     * @param {String} response The complete HTTP response.
     */

    /**
     * Update Entity and Initiate IDV Process
     * Update an entity object and if successful, start the process of downloading the captured data and processing the reports and results of the ID validation process.   At a minimum, the entity will need to have a name. For best results, you should gather the DoB, address, ID document details as well before calling this initProcess function, or supply the details as part of this update. 
     * @param {String} xFrankieCustomerID Customer ID issued by Frankie Financial. This will never change. Your API key, which is mapped to this identity, will change over time. 
     * @param {String} entityId The entityId returned previously from an earlier call to /check or /entity
     * @param {module:model/EntityCheckDetailsObject} entityDetails The entity to update
     * @param {Object} opts Optional parameters
     * @param {String} [xFrankieCustomerChildID] If, as a Frankie Customer, you are acting on behalf of your own customers, then you can populate this field with a Frankie-assigned ID.  Note: If using a CustomerChildID, you will also need a separate api_key for each child.  Any documents, checks, entities that are created when this field has been populated will now be tied to this CustomerID + CustomerChildID combination. Just as Customers cannot see data created by other Customers, so too a Customer's Children will not be able to see each other's data.  A Customer can see the documents/entities and checks of all their Children. 
     * @param {module:api/EntityApi~updateEntityInitIDVProcessCallback} callback The callback function, accepting three arguments: error, data, response
     * data is of type: {@link module:model/EntityIDVResultObject}
     */
    updateEntityInitIDVProcess(xFrankieCustomerID, entityId, entityDetails, opts, callback) {
      opts = opts || {};
      let postBody = entityDetails;
      // verify the required parameter 'xFrankieCustomerID' is set
      if (xFrankieCustomerID === undefined || xFrankieCustomerID === null) {
        throw new Error("Missing the required parameter 'xFrankieCustomerID' when calling updateEntityInitIDVProcess");
      }
      // verify the required parameter 'entityId' is set
      if (entityId === undefined || entityId === null) {
        throw new Error("Missing the required parameter 'entityId' when calling updateEntityInitIDVProcess");
      }
      // verify the required parameter 'entityDetails' is set
      if (entityDetails === undefined || entityDetails === null) {
        throw new Error("Missing the required parameter 'entityDetails' when calling updateEntityInitIDVProcess");
      }

      let pathParams = {
        'entityId': entityId
      };
      let queryParams = {
      };
      let headerParams = {
        'X-Frankie-CustomerID': xFrankieCustomerID,
        'X-Frankie-CustomerChildID': opts['xFrankieCustomerChildID']
      };
      let formParams = {
      };

      let authNames = ['api_key'];
      let contentTypes = ['application/json'];
      let accepts = ['application/json'];
      let returnType = EntityIDVResultObject;
      return this.apiClient.callApi(
        '/entity/{entityId}/idvalidate/initProcess', 'POST',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null, callback
      );
    }

    /**
     * Callback function to receive the result of the updateEntityState operation.
     * @callback module:api/EntityApi~updateEntityStateCallback
     * @param {String} error Error message, if any.
     * @param {module:model/CheckEntityCheckResultObject} data The data returned by the service call.
     * @param {String} response The complete HTTP response.
     */

    /**
     * Update Entity States
     * Internal only  Add a special internal 'entity result' to superceed any previous real checks until the next one. 
     * @param {String} xFrankieCustomerID Customer ID issued by Frankie Financial. This will never change. Your API key, which is mapped to this identity, will change over time. 
     * @param {String} entityId The entityId returned previously from an earlier call to /check or /entity
     * @param {Object} opts Optional parameters
     * @param {String} [xFrankieCustomerChildID] If, as a Frankie Customer, you are acting on behalf of your own customers, then you can populate this field with a Frankie-assigned ID.  Note: If using a CustomerChildID, you will also need a separate api_key for each child.  Any documents, checks, entities that are created when this field has been populated will now be tied to this CustomerID + CustomerChildID combination. Just as Customers cannot see data created by other Customers, so too a Customer's Children will not be able to see each other's data.  A Customer can see the documents/entities and checks of all their Children. 
     * @param {module:model/String} [set] The status of an entity. Valid values are:   - \"wait\": Waiting for new details from entity.   - \"fail\": Manually fail the onboarding process.   - \"archived\": Hide entity from on onboarding.   - \"clear\": Remove any of the above manual states as well as any manual risk.   - \"inactive\": Hide entity and prevent any further operations on it. Cannot be cleared. 
     * @param {module:model/String} [risk] The risk override setting for an entity. This value will be used until a verify result updates a real risk factor. Valid values are:   - \"low\"   - \"medium\"   - \"high\"   - \"unacceptable\"   - \"significant\" 
     * @param {String} [comment] A comment describing the reason for a request. 
     * @param {module:api/EntityApi~updateEntityStateCallback} callback The callback function, accepting three arguments: error, data, response
     * data is of type: {@link module:model/CheckEntityCheckResultObject}
     */
    updateEntityState(xFrankieCustomerID, entityId, opts, callback) {
      opts = opts || {};
      let postBody = null;
      // verify the required parameter 'xFrankieCustomerID' is set
      if (xFrankieCustomerID === undefined || xFrankieCustomerID === null) {
        throw new Error("Missing the required parameter 'xFrankieCustomerID' when calling updateEntityState");
      }
      // verify the required parameter 'entityId' is set
      if (entityId === undefined || entityId === null) {
        throw new Error("Missing the required parameter 'entityId' when calling updateEntityState");
      }

      let pathParams = {
        'entityId': entityId
      };
      let queryParams = {
        'set': opts['set'],
        'risk': opts['risk'],
        'comment': opts['comment']
      };
      let headerParams = {
        'X-Frankie-CustomerID': xFrankieCustomerID,
        'X-Frankie-CustomerChildID': opts['xFrankieCustomerChildID']
      };
      let formParams = {
      };

      let authNames = ['api_key'];
      let contentTypes = [];
      let accepts = ['application/json'];
      let returnType = CheckEntityCheckResultObject;
      return this.apiClient.callApi(
        '/entity/{entityId}/status', 'POST',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null, callback
      );
    }


}
